"use strict";
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/format/format.js
var require_format = __commonJS({
  "node_modules/format/format.js"(exports, module2) {
    (function() {
      var namespace;
      if (typeof module2 !== "undefined") {
        namespace = module2.exports = format;
      } else {
        namespace = function() {
          return this || (1, eval)("this");
        }();
      }
      namespace.format = format;
      namespace.vsprintf = vsprintf;
      if (typeof console !== "undefined" && typeof console.log === "function") {
        namespace.printf = printf;
      }
      function printf() {
        console.log(format.apply(null, arguments));
      }
      function vsprintf(fmt, replacements) {
        return format.apply(null, [fmt].concat(replacements));
      }
      function format(fmt) {
        var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
          return args[argIndex++];
        }, slurpNumber = function() {
          var digits = "";
          while (/\d/.test(fmt[i])) {
            digits += fmt[i++];
            c = fmt[i];
          }
          return digits.length > 0 ? parseInt(digits) : null;
        };
        for (; i < n; ++i) {
          c = fmt[i];
          if (escaped) {
            escaped = false;
            if (c == ".") {
              leadingZero = false;
              c = fmt[++i];
            } else if (c == "0" && fmt[i + 1] == ".") {
              leadingZero = true;
              i += 2;
              c = fmt[i];
            } else {
              leadingZero = true;
            }
            precision = slurpNumber();
            switch (c) {
              case "b":
                result += parseInt(nextArg(), 10).toString(2);
                break;
              case "c":
                arg = nextArg();
                if (typeof arg === "string" || arg instanceof String)
                  result += arg;
                else
                  result += String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
                result += parseInt(nextArg(), 10);
                break;
              case "f":
                tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                result += leadingZero ? tmp : tmp.replace(/^0/, "");
                break;
              case "j":
                result += JSON.stringify(nextArg());
                break;
              case "o":
                result += "0" + parseInt(nextArg(), 10).toString(8);
                break;
              case "s":
                result += nextArg();
                break;
              case "x":
                result += "0x" + parseInt(nextArg(), 10).toString(16);
                break;
              case "X":
                result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                break;
              default:
                result += c;
                break;
            }
          } else if (c === "%") {
            escaped = true;
          } else {
            result += c;
          }
        }
        return result;
      }
    })();
  }
});

// node_modules/antlr4ts/ANTLRErrorListener.js
var require_ANTLRErrorListener = __commonJS({
  "node_modules/antlr4ts/ANTLRErrorListener.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/ANTLRErrorStrategy.js
var require_ANTLRErrorStrategy = __commonJS({
  "node_modules/antlr4ts/ANTLRErrorStrategy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/Decorators.js
var require_Decorators = __commonJS({
  "node_modules/antlr4ts/Decorators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SuppressWarnings = exports.Override = exports.Nullable = exports.NotNull = void 0;
    function NotNull(target, propertyKey, propertyDescriptor) {
    }
    exports.NotNull = NotNull;
    function Nullable(target, propertyKey, propertyDescriptor) {
    }
    exports.Nullable = Nullable;
    function Override(target, propertyKey, propertyDescriptor) {
    }
    exports.Override = Override;
    function SuppressWarnings(options) {
      return (target, propertyKey, descriptor) => {
      };
    }
    exports.SuppressWarnings = SuppressWarnings;
  }
});

// node_modules/antlr4ts/IntStream.js
var require_IntStream = __commonJS({
  "node_modules/antlr4ts/IntStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntStream = void 0;
    var IntStream;
    (function(IntStream2) {
      IntStream2.EOF = -1;
      IntStream2.UNKNOWN_SOURCE_NAME = "<unknown>";
    })(IntStream = exports.IntStream || (exports.IntStream = {}));
  }
});

// node_modules/antlr4ts/ANTLRInputStream.js
var require_ANTLRInputStream = __commonJS({
  "node_modules/antlr4ts/ANTLRInputStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ANTLRInputStream = void 0;
    var assert = require("assert");
    var Decorators_1 = require_Decorators();
    var IntStream_1 = require_IntStream();
    var ANTLRInputStream2 = class {
      constructor(input) {
        this.p = 0;
        this.data = input;
        this.n = input.length;
      }
      reset() {
        this.p = 0;
      }
      consume() {
        if (this.p >= this.n) {
          assert(this.LA(1) === IntStream_1.IntStream.EOF);
          throw new Error("cannot consume EOF");
        }
        if (this.p < this.n) {
          this.p++;
        }
      }
      LA(i) {
        if (i === 0) {
          return 0;
        }
        if (i < 0) {
          i++;
          if (this.p + i - 1 < 0) {
            return IntStream_1.IntStream.EOF;
          }
        }
        if (this.p + i - 1 >= this.n) {
          return IntStream_1.IntStream.EOF;
        }
        return this.data.charCodeAt(this.p + i - 1);
      }
      LT(i) {
        return this.LA(i);
      }
      get index() {
        return this.p;
      }
      get size() {
        return this.n;
      }
      mark() {
        return -1;
      }
      release(marker) {
      }
      seek(index2) {
        if (index2 <= this.p) {
          this.p = index2;
          return;
        }
        index2 = Math.min(index2, this.n);
        while (this.p < index2) {
          this.consume();
        }
      }
      getText(interval) {
        let start = interval.a;
        let stop = interval.b;
        if (stop >= this.n) {
          stop = this.n - 1;
        }
        let count = stop - start + 1;
        if (start >= this.n) {
          return "";
        }
        return this.data.substr(start, count);
      }
      get sourceName() {
        if (!this.name) {
          return IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        return this.name;
      }
      toString() {
        return this.data;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "LA", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "getText", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "toString", null);
    exports.ANTLRInputStream = ANTLRInputStream2;
  }
});

// node_modules/antlr4ts/atn/ATNState.js
var require_ATNState = __commonJS({
  "node_modules/antlr4ts/atn/ATNState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNState = void 0;
    var Decorators_1 = require_Decorators();
    var ATNState = class {
      constructor() {
        this.stateNumber = ATNState.INVALID_STATE_NUMBER;
        this.ruleIndex = 0;
        this.epsilonOnlyTransitions = false;
        this.transitions = [];
        this.optimizedTransitions = this.transitions;
      }
      getStateNumber() {
        return this.stateNumber;
      }
      get nonStopStateNumber() {
        return this.getStateNumber();
      }
      hashCode() {
        return this.stateNumber;
      }
      equals(o) {
        if (o instanceof ATNState) {
          return this.stateNumber === o.stateNumber;
        }
        return false;
      }
      get isNonGreedyExitState() {
        return false;
      }
      toString() {
        return String(this.stateNumber);
      }
      getTransitions() {
        return this.transitions.slice(0);
      }
      get numberOfTransitions() {
        return this.transitions.length;
      }
      addTransition(e, index2) {
        if (this.transitions.length === 0) {
          this.epsilonOnlyTransitions = e.isEpsilon;
        } else if (this.epsilonOnlyTransitions !== e.isEpsilon) {
          this.epsilonOnlyTransitions = false;
          throw new Error("ATN state " + this.stateNumber + " has both epsilon and non-epsilon transitions.");
        }
        this.transitions.splice(index2 !== void 0 ? index2 : this.transitions.length, 0, e);
      }
      transition(i) {
        return this.transitions[i];
      }
      setTransition(i, e) {
        this.transitions[i] = e;
      }
      removeTransition(index2) {
        return this.transitions.splice(index2, 1)[0];
      }
      get onlyHasEpsilonTransitions() {
        return this.epsilonOnlyTransitions;
      }
      setRuleIndex(ruleIndex) {
        this.ruleIndex = ruleIndex;
      }
      get isOptimized() {
        return this.optimizedTransitions !== this.transitions;
      }
      get numberOfOptimizedTransitions() {
        return this.optimizedTransitions.length;
      }
      getOptimizedTransition(i) {
        return this.optimizedTransitions[i];
      }
      addOptimizedTransition(e) {
        if (!this.isOptimized) {
          this.optimizedTransitions = new Array();
        }
        this.optimizedTransitions.push(e);
      }
      setOptimizedTransition(i, e) {
        if (!this.isOptimized) {
          throw new Error("This ATNState is not optimized.");
        }
        this.optimizedTransitions[i] = e;
      }
      removeOptimizedTransition(i) {
        if (!this.isOptimized) {
          throw new Error("This ATNState is not optimized.");
        }
        this.optimizedTransitions.splice(i, 1);
      }
    };
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "toString", null);
    exports.ATNState = ATNState;
    (function(ATNState2) {
      ATNState2.INVALID_STATE_NUMBER = -1;
    })(ATNState = exports.ATNState || (exports.ATNState = {}));
  }
});

// node_modules/antlr4ts/atn/ATNStateType.js
var require_ATNStateType = __commonJS({
  "node_modules/antlr4ts/atn/ATNStateType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNStateType = void 0;
    var ATNStateType;
    (function(ATNStateType2) {
      ATNStateType2[ATNStateType2["INVALID_TYPE"] = 0] = "INVALID_TYPE";
      ATNStateType2[ATNStateType2["BASIC"] = 1] = "BASIC";
      ATNStateType2[ATNStateType2["RULE_START"] = 2] = "RULE_START";
      ATNStateType2[ATNStateType2["BLOCK_START"] = 3] = "BLOCK_START";
      ATNStateType2[ATNStateType2["PLUS_BLOCK_START"] = 4] = "PLUS_BLOCK_START";
      ATNStateType2[ATNStateType2["STAR_BLOCK_START"] = 5] = "STAR_BLOCK_START";
      ATNStateType2[ATNStateType2["TOKEN_START"] = 6] = "TOKEN_START";
      ATNStateType2[ATNStateType2["RULE_STOP"] = 7] = "RULE_STOP";
      ATNStateType2[ATNStateType2["BLOCK_END"] = 8] = "BLOCK_END";
      ATNStateType2[ATNStateType2["STAR_LOOP_BACK"] = 9] = "STAR_LOOP_BACK";
      ATNStateType2[ATNStateType2["STAR_LOOP_ENTRY"] = 10] = "STAR_LOOP_ENTRY";
      ATNStateType2[ATNStateType2["PLUS_LOOP_BACK"] = 11] = "PLUS_LOOP_BACK";
      ATNStateType2[ATNStateType2["LOOP_END"] = 12] = "LOOP_END";
    })(ATNStateType = exports.ATNStateType || (exports.ATNStateType = {}));
  }
});

// node_modules/antlr4ts/RecognitionException.js
var require_RecognitionException = __commonJS({
  "node_modules/antlr4ts/RecognitionException.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecognitionException = void 0;
    var RecognitionException2 = class extends Error {
      constructor(recognizer, input, ctx, message) {
        super(message);
        this._offendingState = -1;
        this._recognizer = recognizer;
        this.input = input;
        this.ctx = ctx;
        if (recognizer) {
          this._offendingState = recognizer.state;
        }
      }
      get offendingState() {
        return this._offendingState;
      }
      setOffendingState(offendingState) {
        this._offendingState = offendingState;
      }
      get expectedTokens() {
        if (this._recognizer) {
          return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);
        }
        return void 0;
      }
      get context() {
        return this.ctx;
      }
      get inputStream() {
        return this.input;
      }
      getOffendingToken(recognizer) {
        if (recognizer && recognizer !== this._recognizer) {
          return void 0;
        }
        return this.offendingToken;
      }
      setOffendingToken(recognizer, offendingToken) {
        if (recognizer === this._recognizer) {
          this.offendingToken = offendingToken;
        }
      }
      get recognizer() {
        return this._recognizer;
      }
    };
    exports.RecognitionException = RecognitionException2;
  }
});

// node_modules/antlr4ts/atn/Transition.js
var require_Transition = __commonJS({
  "node_modules/antlr4ts/atn/Transition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition = class Transition {
      constructor(target) {
        if (target == null) {
          throw new Error("target cannot be null.");
        }
        this.target = target;
      }
      get isEpsilon() {
        return false;
      }
      get label() {
        return void 0;
      }
    };
    Transition.serializationNames = [
      "INVALID",
      "EPSILON",
      "RANGE",
      "RULE",
      "PREDICATE",
      "ATOM",
      "ACTION",
      "SET",
      "NOT_SET",
      "WILDCARD",
      "PRECEDENCE"
    ];
    __decorate([
      Decorators_1.NotNull
    ], Transition.prototype, "target", void 0);
    Transition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], Transition);
    exports.Transition = Transition;
  }
});

// node_modules/antlr4ts/atn/AbstractPredicateTransition.js
var require_AbstractPredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/AbstractPredicateTransition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractPredicateTransition = void 0;
    var Transition_1 = require_Transition();
    var AbstractPredicateTransition = class extends Transition_1.Transition {
      constructor(target) {
        super(target);
      }
    };
    exports.AbstractPredicateTransition = AbstractPredicateTransition;
  }
});

// node_modules/antlr4ts/misc/MurmurHash.js
var require_MurmurHash = __commonJS({
  "node_modules/antlr4ts/misc/MurmurHash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MurmurHash = void 0;
    var MurmurHash;
    (function(MurmurHash2) {
      const DEFAULT_SEED = 0;
      function initialize(seed = DEFAULT_SEED) {
        return seed;
      }
      MurmurHash2.initialize = initialize;
      function update(hash, value2) {
        const c1 = 3432918353;
        const c2 = 461845907;
        const r1 = 15;
        const r2 = 13;
        const m = 5;
        const n = 3864292196;
        if (value2 == null) {
          value2 = 0;
        } else if (typeof value2 === "string") {
          value2 = hashString(value2);
        } else if (typeof value2 === "object") {
          value2 = value2.hashCode();
        }
        let k = value2;
        k = Math.imul(k, c1);
        k = k << r1 | k >>> 32 - r1;
        k = Math.imul(k, c2);
        hash = hash ^ k;
        hash = hash << r2 | hash >>> 32 - r2;
        hash = Math.imul(hash, m) + n;
        return hash & 4294967295;
      }
      MurmurHash2.update = update;
      function finish(hash, numberOfWords) {
        hash = hash ^ numberOfWords * 4;
        hash = hash ^ hash >>> 16;
        hash = Math.imul(hash, 2246822507);
        hash = hash ^ hash >>> 13;
        hash = Math.imul(hash, 3266489909);
        hash = hash ^ hash >>> 16;
        return hash;
      }
      MurmurHash2.finish = finish;
      function hashCode(data, seed = DEFAULT_SEED) {
        let hash = initialize(seed);
        let length = 0;
        for (let value2 of data) {
          hash = update(hash, value2);
          length++;
        }
        hash = finish(hash, length);
        return hash;
      }
      MurmurHash2.hashCode = hashCode;
      function hashString(str) {
        let len = str.length;
        if (len === 0) {
          return 0;
        }
        let hash = 0;
        for (let i = 0; i < len; i++) {
          let c = str.charCodeAt(i);
          hash = (hash << 5 >>> 0) - hash + c;
          hash |= 0;
        }
        return hash;
      }
    })(MurmurHash = exports.MurmurHash || (exports.MurmurHash = {}));
  }
});

// node_modules/antlr4ts/misc/ObjectEqualityComparator.js
var require_ObjectEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/ObjectEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator = class {
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return obj.hashCode();
      }
      equals(a, b) {
        if (a == null) {
          return b == null;
        }
        return a.equals(b);
      }
    };
    ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], ObjectEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ObjectEqualityComparator.prototype, "equals", null);
    exports.ObjectEqualityComparator = ObjectEqualityComparator;
  }
});

// node_modules/antlr4ts/misc/DefaultEqualityComparator.js
var require_DefaultEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/DefaultEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var DefaultEqualityComparator = class {
      hashCode(obj) {
        if (obj == null) {
          return 0;
        } else if (typeof obj === "string" || typeof obj === "number") {
          return MurmurHash_1.MurmurHash.hashCode([obj]);
        } else {
          return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.hashCode(obj);
        }
      }
      equals(a, b) {
        if (a == null) {
          return b == null;
        } else if (typeof a === "string" || typeof a === "number") {
          return a === b;
        } else {
          return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a, b);
        }
      }
    };
    DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], DefaultEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], DefaultEqualityComparator.prototype, "equals", null);
    exports.DefaultEqualityComparator = DefaultEqualityComparator;
  }
});

// node_modules/antlr4ts/misc/Array2DHashSet.js
var require_Array2DHashSet = __commonJS({
  "node_modules/antlr4ts/misc/Array2DHashSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Array2DHashSet = void 0;
    var assert = require("assert");
    var DefaultEqualityComparator_1 = require_DefaultEqualityComparator();
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var INITAL_CAPACITY = 16;
    var LOAD_FACTOR = 0.75;
    var Array2DHashSet = class {
      constructor(comparatorOrSet, initialCapacity = INITAL_CAPACITY) {
        this.n = 0;
        this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
        if (comparatorOrSet instanceof Array2DHashSet) {
          this.comparator = comparatorOrSet.comparator;
          this.buckets = comparatorOrSet.buckets.slice(0);
          for (let i = 0; i < this.buckets.length; i++) {
            let bucket = this.buckets[i];
            if (bucket) {
              this.buckets[i] = bucket.slice(0);
            }
          }
          this.n = comparatorOrSet.n;
          this.threshold = comparatorOrSet.threshold;
        } else {
          this.comparator = comparatorOrSet || DefaultEqualityComparator_1.DefaultEqualityComparator.INSTANCE;
          this.buckets = this.createBuckets(initialCapacity);
        }
      }
      getOrAdd(o) {
        if (this.n > this.threshold) {
          this.expand();
        }
        return this.getOrAddImpl(o);
      }
      getOrAddImpl(o) {
        let b = this.getBucket(o);
        let bucket = this.buckets[b];
        if (!bucket) {
          bucket = [o];
          this.buckets[b] = bucket;
          this.n++;
          return o;
        }
        for (let existing of bucket) {
          if (this.comparator.equals(existing, o)) {
            return existing;
          }
        }
        bucket.push(o);
        this.n++;
        return o;
      }
      get(o) {
        if (o == null) {
          return o;
        }
        let b = this.getBucket(o);
        let bucket = this.buckets[b];
        if (!bucket) {
          return void 0;
        }
        for (let e of bucket) {
          if (this.comparator.equals(e, o)) {
            return e;
          }
        }
        return void 0;
      }
      getBucket(o) {
        let hash = this.comparator.hashCode(o);
        let b = hash & this.buckets.length - 1;
        return b;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            hash = MurmurHash_1.MurmurHash.update(hash, this.comparator.hashCode(o));
          }
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, this.size);
        return hash;
      }
      equals(o) {
        if (o === this) {
          return true;
        }
        if (!(o instanceof Array2DHashSet)) {
          return false;
        }
        if (o.size !== this.size) {
          return false;
        }
        let same = this.containsAll(o);
        return same;
      }
      expand() {
        let old = this.buckets;
        let newCapacity = this.buckets.length * 2;
        let newTable = this.createBuckets(newCapacity);
        this.buckets = newTable;
        this.threshold = Math.floor(newCapacity * LOAD_FACTOR);
        let oldSize = this.size;
        for (let bucket of old) {
          if (!bucket) {
            continue;
          }
          for (let o of bucket) {
            let b = this.getBucket(o);
            let newBucket = this.buckets[b];
            if (!newBucket) {
              newBucket = [];
              this.buckets[b] = newBucket;
            }
            newBucket.push(o);
          }
        }
        assert(this.n === oldSize);
      }
      add(t) {
        let existing = this.getOrAdd(t);
        return existing === t;
      }
      get size() {
        return this.n;
      }
      get isEmpty() {
        return this.n === 0;
      }
      contains(o) {
        return this.containsFast(this.asElementType(o));
      }
      containsFast(obj) {
        if (obj == null) {
          return false;
        }
        return this.get(obj) != null;
      }
      *[Symbol.iterator]() {
        yield* this.toArray();
      }
      toArray() {
        const a = new Array(this.size);
        let i = 0;
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            a[i++] = o;
          }
        }
        return a;
      }
      containsAll(collection) {
        if (collection instanceof Array2DHashSet) {
          let s = collection;
          for (let bucket of s.buckets) {
            if (bucket == null) {
              continue;
            }
            for (let o of bucket) {
              if (o == null) {
                break;
              }
              if (!this.containsFast(this.asElementType(o))) {
                return false;
              }
            }
          }
        } else {
          for (let o of collection) {
            if (!this.containsFast(this.asElementType(o))) {
              return false;
            }
          }
        }
        return true;
      }
      addAll(c) {
        let changed = false;
        for (let o of c) {
          let existing = this.getOrAdd(o);
          if (existing !== o) {
            changed = true;
          }
        }
        return changed;
      }
      clear() {
        this.buckets = this.createBuckets(INITAL_CAPACITY);
        this.n = 0;
        this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
      }
      toString() {
        if (this.size === 0) {
          return "{}";
        }
        let buf = "{";
        let first = true;
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            buf += o.toString();
          }
        }
        buf += "}";
        return buf;
      }
      toTableString() {
        let buf = "";
        for (let bucket of this.buckets) {
          if (bucket == null) {
            buf += "null\n";
            continue;
          }
          buf += "[";
          let first = true;
          for (let o of bucket) {
            if (first) {
              first = false;
            } else {
              buf += " ";
            }
            if (o == null) {
              buf += "_";
            } else {
              buf += o.toString();
            }
          }
          buf += "]\n";
        }
        return buf;
      }
      asElementType(o) {
        return o;
      }
      createBuckets(capacity) {
        return new Array(capacity);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], Array2DHashSet.prototype, "comparator", void 0);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "add", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "contains", null);
    __decorate([
      __param(0, Decorators_1.Nullable)
    ], Array2DHashSet.prototype, "containsFast", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, Symbol.iterator, null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "toArray", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "containsAll", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "addAll", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "clear", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "toString", null);
    __decorate([
      Decorators_1.SuppressWarnings("unchecked")
    ], Array2DHashSet.prototype, "asElementType", null);
    __decorate([
      Decorators_1.SuppressWarnings("unchecked")
    ], Array2DHashSet.prototype, "createBuckets", null);
    exports.Array2DHashSet = Array2DHashSet;
  }
});

// node_modules/antlr4ts/misc/ArrayEqualityComparator.js
var require_ArrayEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/ArrayEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var ArrayEqualityComparator = class {
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return MurmurHash_1.MurmurHash.hashCode(obj, 0);
      }
      equals(a, b) {
        if (a == null) {
          return b == null;
        } else if (b == null) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; i++) {
          if (!ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
    };
    ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], ArrayEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ArrayEqualityComparator.prototype, "equals", null);
    exports.ArrayEqualityComparator = ArrayEqualityComparator;
  }
});

// node_modules/antlr4ts/misc/Utils.js
var require_Utils = __commonJS({
  "node_modules/antlr4ts/misc/Utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toCharArray = exports.toMap = exports.equals = exports.join = exports.escapeWhitespace = void 0;
    function escapeWhitespace(s, escapeSpaces) {
      return escapeSpaces ? s.replace(/ /, "\xB7") : s.replace(/\t/, "\\t").replace(/\n/, "\\n").replace(/\r/, "\\r");
    }
    exports.escapeWhitespace = escapeWhitespace;
    function join(collection, separator) {
      let buf = "";
      let first = true;
      for (let current of collection) {
        if (first) {
          first = false;
        } else {
          buf += separator;
        }
        buf += current;
      }
      return buf;
    }
    exports.join = join;
    function equals(x, y) {
      if (x === y) {
        return true;
      }
      if (x === void 0 || y === void 0) {
        return false;
      }
      return x.equals(y);
    }
    exports.equals = equals;
    function toMap(keys) {
      let m = /* @__PURE__ */ new Map();
      for (let i = 0; i < keys.length; i++) {
        m.set(keys[i], i);
      }
      return m;
    }
    exports.toMap = toMap;
    function toCharArray3(str) {
      if (typeof str === "string") {
        let result = new Uint16Array(str.length);
        for (let i = 0; i < str.length; i++) {
          result[i] = str.charCodeAt(i);
        }
        return result;
      } else {
        return str.toCharArray();
      }
    }
    exports.toCharArray = toCharArray3;
  }
});

// node_modules/antlr4ts/atn/SemanticContext.js
var require_SemanticContext = __commonJS({
  "node_modules/antlr4ts/atn/SemanticContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticContext = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var Utils3 = require_Utils();
    function max(items) {
      let result;
      for (let current of items) {
        if (result === void 0) {
          result = current;
          continue;
        }
        let comparison = result.compareTo(current);
        if (comparison < 0) {
          result = current;
        }
      }
      return result;
    }
    function min(items) {
      let result;
      for (let current of items) {
        if (result === void 0) {
          result = current;
          continue;
        }
        let comparison = result.compareTo(current);
        if (comparison > 0) {
          result = current;
        }
      }
      return result;
    }
    var SemanticContext = class {
      static get NONE() {
        if (SemanticContext._NONE === void 0) {
          SemanticContext._NONE = new SemanticContext.Predicate();
        }
        return SemanticContext._NONE;
      }
      evalPrecedence(parser, parserCallStack) {
        return this;
      }
      static and(a, b) {
        if (!a || a === SemanticContext.NONE) {
          return b;
        }
        if (b === SemanticContext.NONE) {
          return a;
        }
        let result = new SemanticContext.AND(a, b);
        if (result.opnds.length === 1) {
          return result.opnds[0];
        }
        return result;
      }
      static or(a, b) {
        if (!a) {
          return b;
        }
        if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
          return SemanticContext.NONE;
        }
        let result = new SemanticContext.OR(a, b);
        if (result.opnds.length === 1) {
          return result.opnds[0];
        }
        return result;
      }
    };
    exports.SemanticContext = SemanticContext;
    (function(SemanticContext2) {
      const AND_HASHCODE = 40363613;
      const OR_HASHCODE = 486279973;
      function filterPrecedencePredicates(collection) {
        let result = [];
        for (let i = 0; i < collection.length; i++) {
          let context = collection[i];
          if (context instanceof SemanticContext2.PrecedencePredicate) {
            result.push(context);
            collection.splice(i, 1);
            i--;
          }
        }
        return result;
      }
      class Predicate extends SemanticContext2 {
        constructor(ruleIndex = -1, predIndex = -1, isCtxDependent = false) {
          super();
          this.ruleIndex = ruleIndex;
          this.predIndex = predIndex;
          this.isCtxDependent = isCtxDependent;
        }
        eval(parser, parserCallStack) {
          let localctx = this.isCtxDependent ? parserCallStack : void 0;
          return parser.sempred(localctx, this.ruleIndex, this.predIndex);
        }
        hashCode() {
          let hashCode = MurmurHash_1.MurmurHash.initialize();
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);
          return hashCode;
        }
        equals(obj) {
          if (!(obj instanceof Predicate)) {
            return false;
          }
          if (this === obj) {
            return true;
          }
          return this.ruleIndex === obj.ruleIndex && this.predIndex === obj.predIndex && this.isCtxDependent === obj.isCtxDependent;
        }
        toString() {
          return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
        }
      }
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "toString", null);
      SemanticContext2.Predicate = Predicate;
      class PrecedencePredicate extends SemanticContext2 {
        constructor(precedence) {
          super();
          this.precedence = precedence;
        }
        eval(parser, parserCallStack) {
          return parser.precpred(parserCallStack, this.precedence);
        }
        evalPrecedence(parser, parserCallStack) {
          if (parser.precpred(parserCallStack, this.precedence)) {
            return SemanticContext2.NONE;
          } else {
            return void 0;
          }
        }
        compareTo(o) {
          return this.precedence - o.precedence;
        }
        hashCode() {
          let hashCode = 1;
          hashCode = 31 * hashCode + this.precedence;
          return hashCode;
        }
        equals(obj) {
          if (!(obj instanceof PrecedencePredicate)) {
            return false;
          }
          if (this === obj) {
            return true;
          }
          return this.precedence === obj.precedence;
        }
        toString() {
          return "{" + this.precedence + ">=prec}?";
        }
      }
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "compareTo", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "toString", null);
      SemanticContext2.PrecedencePredicate = PrecedencePredicate;
      class Operator extends SemanticContext2 {
      }
      SemanticContext2.Operator = Operator;
      let AND = class AND2 extends Operator {
        constructor(a, b) {
          super();
          let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          if (a instanceof AND2) {
            operands.addAll(a.opnds);
          } else {
            operands.add(a);
          }
          if (b instanceof AND2) {
            operands.addAll(b.opnds);
          } else {
            operands.add(b);
          }
          this.opnds = operands.toArray();
          let precedencePredicates = filterPrecedencePredicates(this.opnds);
          let reduced = min(precedencePredicates);
          if (reduced) {
            this.opnds.push(reduced);
          }
        }
        get operands() {
          return this.opnds;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof AND2)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);
        }
        eval(parser, parserCallStack) {
          for (let opnd of this.opnds) {
            if (!opnd.eval(parser, parserCallStack)) {
              return false;
            }
          }
          return true;
        }
        evalPrecedence(parser, parserCallStack) {
          let differs = false;
          let operands = [];
          for (let context of this.opnds) {
            let evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated == null) {
              return void 0;
            } else if (evaluated !== SemanticContext2.NONE) {
              operands.push(evaluated);
            }
          }
          if (!differs) {
            return this;
          }
          if (operands.length === 0) {
            return SemanticContext2.NONE;
          }
          let result = operands[0];
          for (let i = 1; i < operands.length; i++) {
            result = SemanticContext2.and(result, operands[i]);
          }
          return result;
        }
        toString() {
          return Utils3.join(this.opnds, "&&");
        }
      };
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "operands", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "toString", null);
      AND = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], AND);
      SemanticContext2.AND = AND;
      let OR = class OR2 extends Operator {
        constructor(a, b) {
          super();
          let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          if (a instanceof OR2) {
            operands.addAll(a.opnds);
          } else {
            operands.add(a);
          }
          if (b instanceof OR2) {
            operands.addAll(b.opnds);
          } else {
            operands.add(b);
          }
          this.opnds = operands.toArray();
          let precedencePredicates = filterPrecedencePredicates(this.opnds);
          let reduced = max(precedencePredicates);
          if (reduced) {
            this.opnds.push(reduced);
          }
        }
        get operands() {
          return this.opnds;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof OR2)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);
        }
        eval(parser, parserCallStack) {
          for (let opnd of this.opnds) {
            if (opnd.eval(parser, parserCallStack)) {
              return true;
            }
          }
          return false;
        }
        evalPrecedence(parser, parserCallStack) {
          let differs = false;
          let operands = [];
          for (let context of this.opnds) {
            let evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated === SemanticContext2.NONE) {
              return SemanticContext2.NONE;
            } else if (evaluated) {
              operands.push(evaluated);
            }
          }
          if (!differs) {
            return this;
          }
          if (operands.length === 0) {
            return void 0;
          }
          let result = operands[0];
          for (let i = 1; i < operands.length; i++) {
            result = SemanticContext2.or(result, operands[i]);
          }
          return result;
        }
        toString() {
          return Utils3.join(this.opnds, "||");
        }
      };
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "operands", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "toString", null);
      OR = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], OR);
      SemanticContext2.OR = OR;
    })(SemanticContext = exports.SemanticContext || (exports.SemanticContext = {}));
  }
});

// node_modules/antlr4ts/atn/PredicateTransition.js
var require_PredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/PredicateTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredicateTransition = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Decorators_1 = require_Decorators();
    var SemanticContext_1 = require_SemanticContext();
    var PredicateTransition = class PredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
      constructor(target, ruleIndex, predIndex, isCtxDependent) {
        super(target);
        this.ruleIndex = ruleIndex;
        this.predIndex = predIndex;
        this.isCtxDependent = isCtxDependent;
      }
      get serializationType() {
        return 4;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      get predicate() {
        return new SemanticContext_1.SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
      }
      toString() {
        return "pred_" + this.ruleIndex + ":" + this.predIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], PredicateTransition.prototype, "toString", null);
    PredicateTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], PredicateTransition);
    exports.PredicateTransition = PredicateTransition;
  }
});

// node_modules/antlr4ts/FailedPredicateException.js
var require_FailedPredicateException = __commonJS({
  "node_modules/antlr4ts/FailedPredicateException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FailedPredicateException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var PredicateTransition_1 = require_PredicateTransition();
    var FailedPredicateException2 = class FailedPredicateException3 extends RecognitionException_1.RecognitionException {
      constructor(recognizer, predicate, message) {
        super(recognizer, recognizer.inputStream, recognizer.context, FailedPredicateException3.formatMessage(predicate, message));
        let s = recognizer.interpreter.atn.states[recognizer.state];
        let trans = s.transition(0);
        if (trans instanceof PredicateTransition_1.PredicateTransition) {
          this._ruleIndex = trans.ruleIndex;
          this._predicateIndex = trans.predIndex;
        } else {
          this._ruleIndex = 0;
          this._predicateIndex = 0;
        }
        this._predicate = predicate;
        super.setOffendingToken(recognizer, recognizer.currentToken);
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
      get predicateIndex() {
        return this._predicateIndex;
      }
      get predicate() {
        return this._predicate;
      }
      static formatMessage(predicate, message) {
        if (message) {
          return message;
        }
        return `failed predicate: {${predicate}}?`;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], FailedPredicateException2, "formatMessage", null);
    FailedPredicateException2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], FailedPredicateException2);
    exports.FailedPredicateException = FailedPredicateException2;
  }
});

// node_modules/antlr4ts/InputMismatchException.js
var require_InputMismatchException = __commonJS({
  "node_modules/antlr4ts/InputMismatchException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputMismatchException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var InputMismatchException = class InputMismatchException extends RecognitionException_1.RecognitionException {
      constructor(recognizer, state, context) {
        if (context === void 0) {
          context = recognizer.context;
        }
        super(recognizer, recognizer.inputStream, context);
        if (state !== void 0) {
          this.setOffendingState(state);
        }
        this.setOffendingToken(recognizer, recognizer.currentToken);
      }
    };
    InputMismatchException = __decorate([
      __param(0, Decorators_1.NotNull)
    ], InputMismatchException);
    exports.InputMismatchException = InputMismatchException;
  }
});

// node_modules/antlr4ts/misc/Arrays.js
var require_Arrays = __commonJS({
  "node_modules/antlr4ts/misc/Arrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Arrays = void 0;
    var Arrays;
    (function(Arrays2) {
      function binarySearch(array, key, fromIndex, toIndex) {
        return binarySearch0(array, fromIndex !== void 0 ? fromIndex : 0, toIndex !== void 0 ? toIndex : array.length, key);
      }
      Arrays2.binarySearch = binarySearch;
      function binarySearch0(array, fromIndex, toIndex, key) {
        let low = fromIndex;
        let high = toIndex - 1;
        while (low <= high) {
          let mid = low + high >>> 1;
          let midVal = array[mid];
          if (midVal < key) {
            low = mid + 1;
          } else if (midVal > key) {
            high = mid - 1;
          } else {
            return mid;
          }
        }
        return -(low + 1);
      }
      function toString2(array) {
        let result = "[";
        let first = true;
        for (let element2 of array) {
          if (first) {
            first = false;
          } else {
            result += ", ";
          }
          if (element2 === null) {
            result += "null";
          } else if (element2 === void 0) {
            result += "undefined";
          } else {
            result += element2;
          }
        }
        result += "]";
        return result;
      }
      Arrays2.toString = toString2;
    })(Arrays = exports.Arrays || (exports.Arrays = {}));
  }
});

// node_modules/antlr4ts/misc/IntegerList.js
var require_IntegerList = __commonJS({
  "node_modules/antlr4ts/misc/IntegerList.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntegerList = void 0;
    var Arrays_1 = require_Arrays();
    var Decorators_1 = require_Decorators();
    var EMPTY_DATA = new Int32Array(0);
    var INITIAL_SIZE = 4;
    var MAX_ARRAY_SIZE = (1 << 31 >>> 0) - 1 - 8;
    var IntegerList = class {
      constructor(arg) {
        if (!arg) {
          this._data = EMPTY_DATA;
          this._size = 0;
        } else if (arg instanceof IntegerList) {
          this._data = arg._data.slice(0);
          this._size = arg._size;
        } else if (typeof arg === "number") {
          if (arg === 0) {
            this._data = EMPTY_DATA;
            this._size = 0;
          } else {
            this._data = new Int32Array(arg);
            this._size = 0;
          }
        } else {
          this._data = EMPTY_DATA;
          this._size = 0;
          for (let value2 of arg) {
            this.add(value2);
          }
        }
      }
      add(value2) {
        if (this._data.length === this._size) {
          this.ensureCapacity(this._size + 1);
        }
        this._data[this._size] = value2;
        this._size++;
      }
      addAll(list2) {
        if (Array.isArray(list2)) {
          this.ensureCapacity(this._size + list2.length);
          this._data.subarray(this._size, this._size + list2.length).set(list2);
          this._size += list2.length;
        } else if (list2 instanceof IntegerList) {
          this.ensureCapacity(this._size + list2._size);
          this._data.subarray(this._size, this._size + list2.size).set(list2._data);
          this._size += list2._size;
        } else {
          this.ensureCapacity(this._size + list2.size);
          let current = 0;
          for (let xi of list2) {
            this._data[this._size + current] = xi;
            current++;
          }
          this._size += list2.size;
        }
      }
      get(index2) {
        if (index2 < 0 || index2 >= this._size) {
          throw RangeError();
        }
        return this._data[index2];
      }
      contains(value2) {
        for (let i = 0; i < this._size; i++) {
          if (this._data[i] === value2) {
            return true;
          }
        }
        return false;
      }
      set(index2, value2) {
        if (index2 < 0 || index2 >= this._size) {
          throw RangeError();
        }
        let previous4 = this._data[index2];
        this._data[index2] = value2;
        return previous4;
      }
      removeAt(index2) {
        let value2 = this.get(index2);
        this._data.copyWithin(index2, index2 + 1, this._size);
        this._data[this._size - 1] = 0;
        this._size--;
        return value2;
      }
      removeRange(fromIndex, toIndex) {
        if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
          throw RangeError();
        }
        if (fromIndex > toIndex) {
          throw RangeError();
        }
        this._data.copyWithin(toIndex, fromIndex, this._size);
        this._data.fill(0, this._size - (toIndex - fromIndex), this._size);
        this._size -= toIndex - fromIndex;
      }
      get isEmpty() {
        return this._size === 0;
      }
      get size() {
        return this._size;
      }
      trimToSize() {
        if (this._data.length === this._size) {
          return;
        }
        this._data = this._data.slice(0, this._size);
      }
      clear() {
        this._data.fill(0, 0, this._size);
        this._size = 0;
      }
      toArray() {
        if (this._size === 0) {
          return [];
        }
        return Array.from(this._data.subarray(0, this._size));
      }
      sort() {
        this._data.subarray(0, this._size).sort();
      }
      equals(o) {
        if (o === this) {
          return true;
        }
        if (!(o instanceof IntegerList)) {
          return false;
        }
        if (this._size !== o._size) {
          return false;
        }
        for (let i = 0; i < this._size; i++) {
          if (this._data[i] !== o._data[i]) {
            return false;
          }
        }
        return true;
      }
      hashCode() {
        let hashCode = 1;
        for (let i = 0; i < this._size; i++) {
          hashCode = 31 * hashCode + this._data[i];
        }
        return hashCode;
      }
      toString() {
        return this._data.toString();
      }
      binarySearch(key, fromIndex, toIndex) {
        if (fromIndex === void 0) {
          fromIndex = 0;
        }
        if (toIndex === void 0) {
          toIndex = this._size;
        }
        if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
          throw new RangeError();
        }
        if (fromIndex > toIndex) {
          throw new RangeError();
        }
        return Arrays_1.Arrays.binarySearch(this._data, key, fromIndex, toIndex);
      }
      ensureCapacity(capacity) {
        if (capacity < 0 || capacity > MAX_ARRAY_SIZE) {
          throw new RangeError();
        }
        let newLength;
        if (this._data.length === 0) {
          newLength = INITIAL_SIZE;
        } else {
          newLength = this._data.length;
        }
        while (newLength < capacity) {
          newLength = newLength * 2;
          if (newLength < 0 || newLength > MAX_ARRAY_SIZE) {
            newLength = MAX_ARRAY_SIZE;
          }
        }
        let tmp = new Int32Array(newLength);
        tmp.set(this._data);
        this._data = tmp;
      }
      toCharArray() {
        let resultArray = new Uint16Array(this._size);
        let resultIdx = 0;
        let calculatedPreciseResultSize = false;
        for (let i = 0; i < this._size; i++) {
          let codePoint = this._data[i];
          if (codePoint >= 0 && codePoint < 65536) {
            resultArray[resultIdx] = codePoint;
            resultIdx++;
            continue;
          }
          if (!calculatedPreciseResultSize) {
            let newResultArray = new Uint16Array(this.charArraySize());
            newResultArray.set(resultArray, 0);
            resultArray = newResultArray;
            calculatedPreciseResultSize = true;
          }
          let pair = String.fromCodePoint(codePoint);
          resultArray[resultIdx] = pair.charCodeAt(0);
          resultArray[resultIdx + 1] = pair.charCodeAt(1);
          resultIdx += 2;
        }
        return resultArray;
      }
      charArraySize() {
        let result = 0;
        for (let i = 0; i < this._size; i++) {
          result += this._data[i] >= 65536 ? 2 : 1;
        }
        return result;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], IntegerList.prototype, "_data", void 0);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "toString", null);
    exports.IntegerList = IntegerList;
  }
});

// node_modules/antlr4ts/misc/Interval.js
var require_Interval = __commonJS({
  "node_modules/antlr4ts/misc/Interval.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Interval = void 0;
    var Decorators_1 = require_Decorators();
    var INTERVAL_POOL_MAX_VALUE = 1e3;
    var Interval = class {
      constructor(a, b) {
        this.a = a;
        this.b = b;
      }
      static get INVALID() {
        return Interval._INVALID;
      }
      static of(a, b) {
        if (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {
          return new Interval(a, b);
        }
        if (Interval.cache[a] == null) {
          Interval.cache[a] = new Interval(a, a);
        }
        return Interval.cache[a];
      }
      get length() {
        if (this.b < this.a) {
          return 0;
        }
        return this.b - this.a + 1;
      }
      equals(o) {
        if (o === this) {
          return true;
        } else if (!(o instanceof Interval)) {
          return false;
        }
        return this.a === o.a && this.b === o.b;
      }
      hashCode() {
        let hash = 23;
        hash = hash * 31 + this.a;
        hash = hash * 31 + this.b;
        return hash;
      }
      startsBeforeDisjoint(other) {
        return this.a < other.a && this.b < other.a;
      }
      startsBeforeNonDisjoint(other) {
        return this.a <= other.a && this.b >= other.a;
      }
      startsAfter(other) {
        return this.a > other.a;
      }
      startsAfterDisjoint(other) {
        return this.a > other.b;
      }
      startsAfterNonDisjoint(other) {
        return this.a > other.a && this.a <= other.b;
      }
      disjoint(other) {
        return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
      }
      adjacent(other) {
        return this.a === other.b + 1 || this.b === other.a - 1;
      }
      properlyContains(other) {
        return other.a >= this.a && other.b <= this.b;
      }
      union(other) {
        return Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));
      }
      intersection(other) {
        return Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));
      }
      differenceNotProperlyContained(other) {
        let diff;
        if (other.startsBeforeNonDisjoint(this)) {
          diff = Interval.of(Math.max(this.a, other.b + 1), this.b);
        } else if (other.startsAfterNonDisjoint(this)) {
          diff = Interval.of(this.a, other.a - 1);
        }
        return diff;
      }
      toString() {
        return this.a + ".." + this.b;
      }
    };
    Interval._INVALID = new Interval(-1, -2);
    Interval.cache = new Array(INTERVAL_POOL_MAX_VALUE + 1);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "toString", null);
    exports.Interval = Interval;
  }
});

// node_modules/antlr4ts/Token.js
var require_Token = __commonJS({
  "node_modules/antlr4ts/Token.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Token = void 0;
    var IntStream_1 = require_IntStream();
    var Token2;
    (function(Token3) {
      Token3.INVALID_TYPE = 0;
      Token3.EPSILON = -2;
      Token3.MIN_USER_TOKEN_TYPE = 1;
      Token3.EOF = IntStream_1.IntStream.EOF;
      Token3.DEFAULT_CHANNEL = 0;
      Token3.HIDDEN_CHANNEL = 1;
      Token3.MIN_USER_CHANNEL_VALUE = 2;
    })(Token2 = exports.Token || (exports.Token = {}));
  }
});

// node_modules/antlr4ts/CommonToken.js
var require_CommonToken = __commonJS({
  "node_modules/antlr4ts/CommonToken.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonToken = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var CommonToken = class CommonToken2 {
      constructor(type, text4, source = CommonToken2.EMPTY_SOURCE, channel = Token_1.Token.DEFAULT_CHANNEL, start = 0, stop = 0) {
        this._line = 0;
        this._charPositionInLine = -1;
        this._channel = Token_1.Token.DEFAULT_CHANNEL;
        this.index = -1;
        this._text = text4;
        this._type = type;
        this.source = source;
        this._channel = channel;
        this.start = start;
        this.stop = stop;
        if (source.source != null) {
          this._line = source.source.line;
          this._charPositionInLine = source.source.charPositionInLine;
        }
      }
      static fromToken(oldToken) {
        let result = new CommonToken2(oldToken.type, void 0, CommonToken2.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);
        result._line = oldToken.line;
        result.index = oldToken.tokenIndex;
        result._charPositionInLine = oldToken.charPositionInLine;
        if (oldToken instanceof CommonToken2) {
          result._text = oldToken._text;
          result.source = oldToken.source;
        } else {
          result._text = oldToken.text;
          result.source = { source: oldToken.tokenSource, stream: oldToken.inputStream };
        }
        return result;
      }
      get type() {
        return this._type;
      }
      set type(type) {
        this._type = type;
      }
      get line() {
        return this._line;
      }
      set line(line) {
        this._line = line;
      }
      get text() {
        if (this._text != null) {
          return this._text;
        }
        let input = this.inputStream;
        if (input == null) {
          return void 0;
        }
        let n = input.size;
        if (this.start < n && this.stop < n) {
          return input.getText(Interval_1.Interval.of(this.start, this.stop));
        } else {
          return "<EOF>";
        }
      }
      set text(text4) {
        this._text = text4;
      }
      get charPositionInLine() {
        return this._charPositionInLine;
      }
      set charPositionInLine(charPositionInLine) {
        this._charPositionInLine = charPositionInLine;
      }
      get channel() {
        return this._channel;
      }
      set channel(channel) {
        this._channel = channel;
      }
      get startIndex() {
        return this.start;
      }
      set startIndex(start) {
        this.start = start;
      }
      get stopIndex() {
        return this.stop;
      }
      set stopIndex(stop) {
        this.stop = stop;
      }
      get tokenIndex() {
        return this.index;
      }
      set tokenIndex(index2) {
        this.index = index2;
      }
      get tokenSource() {
        return this.source.source;
      }
      get inputStream() {
        return this.source.stream;
      }
      toString(recognizer) {
        let channelStr = "";
        if (this._channel > 0) {
          channelStr = ",channel=" + this._channel;
        }
        let txt = this.text;
        if (txt != null) {
          txt = txt.replace(/\n/g, "\\n");
          txt = txt.replace(/\r/g, "\\r");
          txt = txt.replace(/\t/g, "\\t");
        } else {
          txt = "<no text>";
        }
        let typeString = String(this._type);
        if (recognizer) {
          typeString = recognizer.vocabulary.getDisplayName(this._type);
        }
        return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + typeString + ">" + channelStr + "," + this._line + ":" + this.charPositionInLine + "]";
      }
    };
    CommonToken.EMPTY_SOURCE = { source: void 0, stream: void 0 };
    __decorate([
      Decorators_1.NotNull
    ], CommonToken.prototype, "source", void 0);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "type", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "channel", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "startIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "stopIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "tokenIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "toString", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], CommonToken, "fromToken", null);
    CommonToken = __decorate([
      __param(2, Decorators_1.NotNull)
    ], CommonToken);
    exports.CommonToken = CommonToken;
  }
});

// node_modules/antlr4ts/CommonTokenFactory.js
var require_CommonTokenFactory = __commonJS({
  "node_modules/antlr4ts/CommonTokenFactory.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonTokenFactory = void 0;
    var CommonToken_1 = require_CommonToken();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var CommonTokenFactory = class {
      constructor(copyText = false) {
        this.copyText = copyText;
      }
      create(source, type, text4, channel, start, stop, line, charPositionInLine) {
        let t = new CommonToken_1.CommonToken(type, text4, source, channel, start, stop);
        t.line = line;
        t.charPositionInLine = charPositionInLine;
        if (text4 == null && this.copyText && source.stream != null) {
          t.text = source.stream.getText(Interval_1.Interval.of(start, stop));
        }
        return t;
      }
      createSimple(type, text4) {
        return new CommonToken_1.CommonToken(type, text4);
      }
    };
    __decorate([
      Decorators_1.Override
    ], CommonTokenFactory.prototype, "create", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenFactory.prototype, "createSimple", null);
    exports.CommonTokenFactory = CommonTokenFactory;
    (function(CommonTokenFactory2) {
      CommonTokenFactory2.DEFAULT = new CommonTokenFactory2();
    })(CommonTokenFactory = exports.CommonTokenFactory || (exports.CommonTokenFactory = {}));
  }
});

// node_modules/antlr4ts/misc/IntegerStack.js
var require_IntegerStack = __commonJS({
  "node_modules/antlr4ts/misc/IntegerStack.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntegerStack = void 0;
    var IntegerList_1 = require_IntegerList();
    var IntegerStack = class extends IntegerList_1.IntegerList {
      constructor(arg) {
        super(arg);
      }
      push(value2) {
        this.add(value2);
      }
      pop() {
        return this.removeAt(this.size - 1);
      }
      peek() {
        return this.get(this.size - 1);
      }
    };
    exports.IntegerStack = IntegerStack;
  }
});

// node_modules/antlr4ts/dfa/AcceptStateInfo.js
var require_AcceptStateInfo = __commonJS({
  "node_modules/antlr4ts/dfa/AcceptStateInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AcceptStateInfo = void 0;
    var AcceptStateInfo = class {
      constructor(prediction, lexerActionExecutor) {
        this._prediction = prediction;
        this._lexerActionExecutor = lexerActionExecutor;
      }
      get prediction() {
        return this._prediction;
      }
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
    };
    exports.AcceptStateInfo = AcceptStateInfo;
  }
});

// node_modules/antlr4ts/misc/Array2DHashMap.js
var require_Array2DHashMap = __commonJS({
  "node_modules/antlr4ts/misc/Array2DHashMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Array2DHashMap = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var MapKeyEqualityComparator = class {
      constructor(keyComparator) {
        this.keyComparator = keyComparator;
      }
      hashCode(obj) {
        return this.keyComparator.hashCode(obj.key);
      }
      equals(a, b) {
        return this.keyComparator.equals(a.key, b.key);
      }
    };
    var Array2DHashMap = class {
      constructor(keyComparer) {
        if (keyComparer instanceof Array2DHashMap) {
          this.backingStore = new Array2DHashSet_1.Array2DHashSet(keyComparer.backingStore);
        } else {
          this.backingStore = new Array2DHashSet_1.Array2DHashSet(new MapKeyEqualityComparator(keyComparer));
        }
      }
      clear() {
        this.backingStore.clear();
      }
      containsKey(key) {
        return this.backingStore.contains({ key });
      }
      get(key) {
        let bucket = this.backingStore.get({ key });
        if (!bucket) {
          return void 0;
        }
        return bucket.value;
      }
      get isEmpty() {
        return this.backingStore.isEmpty;
      }
      put(key, value2) {
        let element2 = this.backingStore.get({ key, value: value2 });
        let result;
        if (!element2) {
          this.backingStore.add({ key, value: value2 });
        } else {
          result = element2.value;
          element2.value = value2;
        }
        return result;
      }
      putIfAbsent(key, value2) {
        let element2 = this.backingStore.get({ key, value: value2 });
        let result;
        if (!element2) {
          this.backingStore.add({ key, value: value2 });
        } else {
          result = element2.value;
        }
        return result;
      }
      get size() {
        return this.backingStore.size;
      }
      hashCode() {
        return this.backingStore.hashCode();
      }
      equals(o) {
        if (!(o instanceof Array2DHashMap)) {
          return false;
        }
        return this.backingStore.equals(o.backingStore);
      }
    };
    exports.Array2DHashMap = Array2DHashMap;
  }
});

// node_modules/antlr4ts/atn/DecisionState.js
var require_DecisionState = __commonJS({
  "node_modules/antlr4ts/atn/DecisionState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionState = void 0;
    var ATNState_1 = require_ATNState();
    var DecisionState = class extends ATNState_1.ATNState {
      constructor() {
        super(...arguments);
        this.decision = -1;
        this.nonGreedy = false;
        this.sll = false;
      }
    };
    exports.DecisionState = DecisionState;
  }
});

// node_modules/antlr4ts/atn/PredictionContextCache.js
var require_PredictionContextCache = __commonJS({
  "node_modules/antlr4ts/atn/PredictionContextCache.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredictionContextCache = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var assert = require("assert");
    var PredictionContextCache = class {
      constructor(enableCache = true) {
        this.contexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.childContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.joinContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.enableCache = enableCache;
      }
      getAsCached(context) {
        if (!this.enableCache) {
          return context;
        }
        let result = this.contexts.get(context);
        if (!result) {
          result = context;
          this.contexts.put(context, context);
        }
        return result;
      }
      getChild(context, invokingState) {
        if (!this.enableCache) {
          return context.getChild(invokingState);
        }
        let operands = new PredictionContextCache.PredictionContextAndInt(context, invokingState);
        let result = this.childContexts.get(operands);
        if (!result) {
          result = context.getChild(invokingState);
          result = this.getAsCached(result);
          this.childContexts.put(operands, result);
        }
        return result;
      }
      join(x, y) {
        if (!this.enableCache) {
          return PredictionContext_1.PredictionContext.join(x, y, this);
        }
        let operands = new PredictionContextCache.IdentityCommutativePredictionContextOperands(x, y);
        let result = this.joinContexts.get(operands);
        if (result) {
          return result;
        }
        result = PredictionContext_1.PredictionContext.join(x, y, this);
        result = this.getAsCached(result);
        this.joinContexts.put(operands, result);
        return result;
      }
    };
    exports.PredictionContextCache = PredictionContextCache;
    PredictionContextCache.UNCACHED = new PredictionContextCache(false);
    (function(PredictionContextCache2) {
      class PredictionContextAndInt {
        constructor(obj, value2) {
          this.obj = obj;
          this.value = value2;
        }
        equals(obj) {
          if (!(obj instanceof PredictionContextAndInt)) {
            return false;
          } else if (obj === this) {
            return true;
          }
          let other = obj;
          return this.value === other.value && (this.obj === other.obj || this.obj != null && this.obj.equals(other.obj));
        }
        hashCode() {
          let hashCode = 5;
          hashCode = 7 * hashCode + (this.obj != null ? this.obj.hashCode() : 0);
          hashCode = 7 * hashCode + this.value;
          return hashCode;
        }
      }
      __decorate([
        Decorators_1.Override
      ], PredictionContextAndInt.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], PredictionContextAndInt.prototype, "hashCode", null);
      PredictionContextCache2.PredictionContextAndInt = PredictionContextAndInt;
      class IdentityCommutativePredictionContextOperands {
        constructor(x, y) {
          assert(x != null);
          assert(y != null);
          this._x = x;
          this._y = y;
        }
        get x() {
          return this._x;
        }
        get y() {
          return this._y;
        }
        equals(o) {
          if (!(o instanceof IdentityCommutativePredictionContextOperands)) {
            return false;
          } else if (this === o) {
            return true;
          }
          let other = o;
          return this._x === other._x && this._y === other._y || this._x === other._y && this._y === other._x;
        }
        hashCode() {
          return this._x.hashCode() ^ this._y.hashCode();
        }
      }
      __decorate([
        Decorators_1.Override
      ], IdentityCommutativePredictionContextOperands.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], IdentityCommutativePredictionContextOperands.prototype, "hashCode", null);
      PredictionContextCache2.IdentityCommutativePredictionContextOperands = IdentityCommutativePredictionContextOperands;
    })(PredictionContextCache = exports.PredictionContextCache || (exports.PredictionContextCache = {}));
  }
});

// node_modules/antlr4ts/atn/PredictionContext.js
var require_PredictionContext = __commonJS({
  "node_modules/antlr4ts/atn/PredictionContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingletonPredictionContext = exports.PredictionContext = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var Arrays_1 = require_Arrays();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var assert = require("assert");
    var INITIAL_HASH = 1;
    var PredictionContext = class {
      constructor(cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
      }
      static calculateEmptyHashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        hash = MurmurHash_1.MurmurHash.finish(hash, 0);
        return hash;
      }
      static calculateSingleHashCode(parent, returnState) {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        hash = MurmurHash_1.MurmurHash.update(hash, parent);
        hash = MurmurHash_1.MurmurHash.update(hash, returnState);
        hash = MurmurHash_1.MurmurHash.finish(hash, 2);
        return hash;
      }
      static calculateHashCode(parents, returnStates) {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        for (let parent of parents) {
          hash = MurmurHash_1.MurmurHash.update(hash, parent);
        }
        for (let returnState of returnStates) {
          hash = MurmurHash_1.MurmurHash.update(hash, returnState);
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, 2 * parents.length);
        return hash;
      }
      static fromRuleContext(atn, outerContext, fullContext = true) {
        if (outerContext.isEmpty) {
          return fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
        }
        let parent;
        if (outerContext._parent) {
          parent = PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);
        } else {
          parent = fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
        }
        let state = atn.states[outerContext.invokingState];
        let transition = state.transition(0);
        return parent.getChild(transition.followState.stateNumber);
      }
      static addEmptyContext(context) {
        return context.addEmptyContext();
      }
      static removeEmptyContext(context) {
        return context.removeEmptyContext();
      }
      static join(context0, context1, contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED) {
        if (context0 === context1) {
          return context0;
        }
        if (context0.isEmpty) {
          return PredictionContext.isEmptyLocal(context0) ? context0 : PredictionContext.addEmptyContext(context1);
        } else if (context1.isEmpty) {
          return PredictionContext.isEmptyLocal(context1) ? context1 : PredictionContext.addEmptyContext(context0);
        }
        let context0size = context0.size;
        let context1size = context1.size;
        if (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {
          let merged = contextCache.join(context0.getParent(0), context1.getParent(0));
          if (merged === context0.getParent(0)) {
            return context0;
          } else if (merged === context1.getParent(0)) {
            return context1;
          } else {
            return merged.getChild(context0.getReturnState(0));
          }
        }
        let count = 0;
        let parentsList = new Array(context0size + context1size);
        let returnStatesList = new Array(parentsList.length);
        let leftIndex = 0;
        let rightIndex = 0;
        let canReturnLeft = true;
        let canReturnRight = true;
        while (leftIndex < context0size && rightIndex < context1size) {
          if (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {
            parentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));
            returnStatesList[count] = context0.getReturnState(leftIndex);
            canReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);
            canReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);
            leftIndex++;
            rightIndex++;
          } else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {
            parentsList[count] = context0.getParent(leftIndex);
            returnStatesList[count] = context0.getReturnState(leftIndex);
            canReturnRight = false;
            leftIndex++;
          } else {
            assert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));
            parentsList[count] = context1.getParent(rightIndex);
            returnStatesList[count] = context1.getReturnState(rightIndex);
            canReturnLeft = false;
            rightIndex++;
          }
          count++;
        }
        while (leftIndex < context0size) {
          parentsList[count] = context0.getParent(leftIndex);
          returnStatesList[count] = context0.getReturnState(leftIndex);
          leftIndex++;
          canReturnRight = false;
          count++;
        }
        while (rightIndex < context1size) {
          parentsList[count] = context1.getParent(rightIndex);
          returnStatesList[count] = context1.getReturnState(rightIndex);
          rightIndex++;
          canReturnLeft = false;
          count++;
        }
        if (canReturnLeft) {
          return context0;
        } else if (canReturnRight) {
          return context1;
        }
        if (count < parentsList.length) {
          parentsList = parentsList.slice(0, count);
          returnStatesList = returnStatesList.slice(0, count);
        }
        if (parentsList.length === 0) {
          return PredictionContext.EMPTY_FULL;
        } else if (parentsList.length === 1) {
          return new SingletonPredictionContext(parentsList[0], returnStatesList[0]);
        } else {
          return new ArrayPredictionContext(parentsList, returnStatesList);
        }
      }
      static isEmptyLocal(context) {
        return context === PredictionContext.EMPTY_LOCAL;
      }
      static getCachedContext(context, contextCache, visited) {
        if (context.isEmpty) {
          return context;
        }
        let existing = visited.get(context);
        if (existing) {
          return existing;
        }
        existing = contextCache.get(context);
        if (existing) {
          visited.put(context, existing);
          return existing;
        }
        let changed = false;
        let parents = new Array(context.size);
        for (let i = 0; i < parents.length; i++) {
          let parent = PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);
          if (changed || parent !== context.getParent(i)) {
            if (!changed) {
              parents = new Array(context.size);
              for (let j = 0; j < context.size; j++) {
                parents[j] = context.getParent(j);
              }
              changed = true;
            }
            parents[i] = parent;
          }
        }
        if (!changed) {
          existing = contextCache.putIfAbsent(context, context);
          visited.put(context, existing != null ? existing : context);
          return context;
        }
        let updated;
        if (parents.length === 1) {
          updated = new SingletonPredictionContext(parents[0], context.getReturnState(0));
        } else {
          let returnStates = new Array(context.size);
          for (let i = 0; i < context.size; i++) {
            returnStates[i] = context.getReturnState(i);
          }
          updated = new ArrayPredictionContext(parents, returnStates, context.hashCode());
        }
        existing = contextCache.putIfAbsent(updated, updated);
        visited.put(updated, existing || updated);
        visited.put(context, existing || updated);
        return updated;
      }
      appendSingleContext(returnContext, contextCache) {
        return this.appendContext(PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);
      }
      getChild(returnState) {
        return new SingletonPredictionContext(this, returnState);
      }
      hashCode() {
        return this.cachedHashCode;
      }
      toStrings(recognizer, currentState, stop = PredictionContext.EMPTY_FULL) {
        let result = [];
        outer:
          for (let perm = 0; ; perm++) {
            let offset = 0;
            let last = true;
            let p = this;
            let stateNumber = currentState;
            let localBuffer = "";
            localBuffer += "[";
            while (!p.isEmpty && p !== stop) {
              let index2 = 0;
              if (p.size > 0) {
                let bits = 1;
                while (1 << bits >>> 0 < p.size) {
                  bits++;
                }
                let mask = (1 << bits >>> 0) - 1;
                index2 = perm >> offset & mask;
                last = last && index2 >= p.size - 1;
                if (index2 >= p.size) {
                  continue outer;
                }
                offset += bits;
              }
              if (recognizer) {
                if (localBuffer.length > 1) {
                  localBuffer += " ";
                }
                let atn = recognizer.atn;
                let s = atn.states[stateNumber];
                let ruleName = recognizer.ruleNames[s.ruleIndex];
                localBuffer += ruleName;
              } else if (p.getReturnState(index2) !== PredictionContext.EMPTY_FULL_STATE_KEY) {
                if (!p.isEmpty) {
                  if (localBuffer.length > 1) {
                    localBuffer += " ";
                  }
                  localBuffer += p.getReturnState(index2);
                }
              }
              stateNumber = p.getReturnState(index2);
              p = p.getParent(index2);
            }
            localBuffer += "]";
            result.push(localBuffer);
            if (last) {
              break;
            }
          }
        return result;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PredictionContext.prototype, "hashCode", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], PredictionContext, "join", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], PredictionContext, "getCachedContext", null);
    exports.PredictionContext = PredictionContext;
    var EmptyPredictionContext = class extends PredictionContext {
      constructor(fullContext) {
        super(PredictionContext.calculateEmptyHashCode());
        this.fullContext = fullContext;
      }
      get isFullContext() {
        return this.fullContext;
      }
      addEmptyContext() {
        return this;
      }
      removeEmptyContext() {
        throw new Error("Cannot remove the empty context from itself.");
      }
      getParent(index2) {
        throw new Error("index out of bounds");
      }
      getReturnState(index2) {
        throw new Error("index out of bounds");
      }
      findReturnState(returnState) {
        return -1;
      }
      get size() {
        return 0;
      }
      appendSingleContext(returnContext, contextCache) {
        return contextCache.getChild(this, returnContext);
      }
      appendContext(suffix, contextCache) {
        return suffix;
      }
      get isEmpty() {
        return true;
      }
      get hasEmpty() {
        return true;
      }
      equals(o) {
        return this === o;
      }
      toStrings(recognizer, currentState, stop) {
        return ["[]"];
      }
    };
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "appendSingleContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "toStrings", null);
    var ArrayPredictionContext = class ArrayPredictionContext2 extends PredictionContext {
      constructor(parents, returnStates, hashCode) {
        super(hashCode || PredictionContext.calculateHashCode(parents, returnStates));
        assert(parents.length === returnStates.length);
        assert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, "Should be using PredictionContext.EMPTY instead.");
        this.parents = parents;
        this.returnStates = returnStates;
      }
      getParent(index2) {
        return this.parents[index2];
      }
      getReturnState(index2) {
        return this.returnStates[index2];
      }
      findReturnState(returnState) {
        return Arrays_1.Arrays.binarySearch(this.returnStates, returnState);
      }
      get size() {
        return this.returnStates.length;
      }
      get isEmpty() {
        return false;
      }
      get hasEmpty() {
        return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;
      }
      addEmptyContext() {
        if (this.hasEmpty) {
          return this;
        }
        let parents2 = this.parents.slice(0);
        let returnStates2 = this.returnStates.slice(0);
        parents2.push(PredictionContext.EMPTY_FULL);
        returnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);
        return new ArrayPredictionContext2(parents2, returnStates2);
      }
      removeEmptyContext() {
        if (!this.hasEmpty) {
          return this;
        }
        if (this.returnStates.length === 2) {
          return new SingletonPredictionContext(this.parents[0], this.returnStates[0]);
        } else {
          let parents2 = this.parents.slice(0, this.parents.length - 1);
          let returnStates2 = this.returnStates.slice(0, this.returnStates.length - 1);
          return new ArrayPredictionContext2(parents2, returnStates2);
        }
      }
      appendContext(suffix, contextCache) {
        return ArrayPredictionContext2.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());
      }
      static appendContextImpl(context, suffix, visited) {
        if (suffix.isEmpty) {
          if (PredictionContext.isEmptyLocal(suffix)) {
            if (context.hasEmpty) {
              return PredictionContext.EMPTY_LOCAL;
            }
            throw new Error("what to do here?");
          }
          return context;
        }
        if (suffix.size !== 1) {
          throw new Error("Appending a tree suffix is not yet supported.");
        }
        let result = visited.get(context);
        if (!result) {
          if (context.isEmpty) {
            result = suffix;
          } else {
            let parentCount = context.size;
            if (context.hasEmpty) {
              parentCount--;
            }
            let updatedParents = new Array(parentCount);
            let updatedReturnStates = new Array(parentCount);
            for (let i = 0; i < parentCount; i++) {
              updatedReturnStates[i] = context.getReturnState(i);
            }
            for (let i = 0; i < parentCount; i++) {
              updatedParents[i] = ArrayPredictionContext2.appendContextImpl(context.getParent(i), suffix, visited);
            }
            if (updatedParents.length === 1) {
              result = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);
            } else {
              assert(updatedParents.length > 1);
              result = new ArrayPredictionContext2(updatedParents, updatedReturnStates);
            }
            if (context.hasEmpty) {
              result = PredictionContext.join(result, suffix);
            }
          }
          visited.put(context, result);
        }
        return result;
      }
      equals(o) {
        if (this === o) {
          return true;
        } else if (!(o instanceof ArrayPredictionContext2)) {
          return false;
        }
        if (this.hashCode() !== o.hashCode()) {
          return false;
        }
        let other = o;
        return this.equalsImpl(other, new Array2DHashSet_1.Array2DHashSet());
      }
      equalsImpl(other, visited) {
        let selfWorkList = [];
        let otherWorkList = [];
        selfWorkList.push(this);
        otherWorkList.push(other);
        while (true) {
          let currentSelf = selfWorkList.pop();
          let currentOther = otherWorkList.pop();
          if (!currentSelf || !currentOther) {
            break;
          }
          let operands = new PredictionContextCache_1.PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);
          if (!visited.add(operands)) {
            continue;
          }
          let selfSize = operands.x.size;
          if (selfSize === 0) {
            if (!operands.x.equals(operands.y)) {
              return false;
            }
            continue;
          }
          let otherSize = operands.y.size;
          if (selfSize !== otherSize) {
            return false;
          }
          for (let i = 0; i < selfSize; i++) {
            if (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {
              return false;
            }
            let selfParent = operands.x.getParent(i);
            let otherParent = operands.y.getParent(i);
            if (selfParent.hashCode() !== otherParent.hashCode()) {
              return false;
            }
            if (selfParent !== otherParent) {
              selfWorkList.push(selfParent);
              otherWorkList.push(otherParent);
            }
          }
        }
        return true;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ArrayPredictionContext.prototype, "parents", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ArrayPredictionContext.prototype, "returnStates", void 0);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "equals", null);
    ArrayPredictionContext = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ArrayPredictionContext);
    var SingletonPredictionContext = class SingletonPredictionContext2 extends PredictionContext {
      constructor(parent, returnState) {
        super(PredictionContext.calculateSingleHashCode(parent, returnState));
        this.parent = parent;
        this.returnState = returnState;
      }
      getParent(index2) {
        return this.parent;
      }
      getReturnState(index2) {
        return this.returnState;
      }
      findReturnState(returnState) {
        return this.returnState === returnState ? 0 : -1;
      }
      get size() {
        return 1;
      }
      get isEmpty() {
        return false;
      }
      get hasEmpty() {
        return false;
      }
      appendContext(suffix, contextCache) {
        return contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);
      }
      addEmptyContext() {
        let parents = [this.parent, PredictionContext.EMPTY_FULL];
        let returnStates = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];
        return new ArrayPredictionContext(parents, returnStates);
      }
      removeEmptyContext() {
        return this;
      }
      equals(o) {
        if (o === this) {
          return true;
        } else if (!(o instanceof SingletonPredictionContext2)) {
          return false;
        }
        let other = o;
        if (this.hashCode() !== other.hashCode()) {
          return false;
        }
        return this.returnState === other.returnState && this.parent.equals(other.parent);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SingletonPredictionContext.prototype, "parent", void 0);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "equals", null);
    SingletonPredictionContext = __decorate([
      __param(0, Decorators_1.NotNull)
    ], SingletonPredictionContext);
    exports.SingletonPredictionContext = SingletonPredictionContext;
    (function(PredictionContext2) {
      PredictionContext2.EMPTY_LOCAL = new EmptyPredictionContext(false);
      PredictionContext2.EMPTY_FULL = new EmptyPredictionContext(true);
      PredictionContext2.EMPTY_LOCAL_STATE_KEY = -(1 << 31 >>> 0);
      PredictionContext2.EMPTY_FULL_STATE_KEY = (1 << 31 >>> 0) - 1;
      class IdentityHashMap extends Array2DHashMap_1.Array2DHashMap {
        constructor() {
          super(IdentityEqualityComparator.INSTANCE);
        }
      }
      PredictionContext2.IdentityHashMap = IdentityHashMap;
      class IdentityEqualityComparator {
        IdentityEqualityComparator() {
        }
        hashCode(obj) {
          return obj.hashCode();
        }
        equals(a, b) {
          return a === b;
        }
      }
      IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], IdentityEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], IdentityEqualityComparator.prototype, "equals", null);
      PredictionContext2.IdentityEqualityComparator = IdentityEqualityComparator;
    })(PredictionContext = exports.PredictionContext || (exports.PredictionContext = {}));
  }
});

// node_modules/antlr4ts/atn/ATNConfig.js
var require_ATNConfig = __commonJS({
  "node_modules/antlr4ts/atn/ATNConfig.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNConfig = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var DecisionState_1 = require_DecisionState();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var SemanticContext_1 = require_SemanticContext();
    var assert = require("assert");
    var SUPPRESS_PRECEDENCE_FILTER = 2147483648;
    var ATNConfig = class ATNConfig2 {
      constructor(state, altOrConfig, context) {
        if (typeof altOrConfig === "number") {
          assert((altOrConfig & 16777215) === altOrConfig);
          this._state = state;
          this.altAndOuterContextDepth = altOrConfig;
          this._context = context;
        } else {
          this._state = state;
          this.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;
          this._context = context;
        }
      }
      static create(state, alt, context, semanticContext = SemanticContext_1.SemanticContext.NONE, lexerActionExecutor) {
        if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
          if (lexerActionExecutor != null) {
            return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);
          } else {
            return new SemanticContextATNConfig(semanticContext, state, alt, context);
          }
        } else if (lexerActionExecutor != null) {
          return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);
        } else {
          return new ATNConfig2(state, alt, context);
        }
      }
      get state() {
        return this._state;
      }
      get alt() {
        return this.altAndOuterContextDepth & 16777215;
      }
      get context() {
        return this._context;
      }
      set context(context) {
        this._context = context;
      }
      get reachesIntoOuterContext() {
        return this.outerContextDepth !== 0;
      }
      get outerContextDepth() {
        return this.altAndOuterContextDepth >>> 24 & 127;
      }
      set outerContextDepth(outerContextDepth) {
        assert(outerContextDepth >= 0);
        outerContextDepth = Math.min(outerContextDepth, 127);
        this.altAndOuterContextDepth = outerContextDepth << 24 | (this.altAndOuterContextDepth & ~2130706432) >>> 0;
      }
      get lexerActionExecutor() {
        return void 0;
      }
      get semanticContext() {
        return SemanticContext_1.SemanticContext.NONE;
      }
      get hasPassedThroughNonGreedyDecision() {
        return false;
      }
      clone() {
        return this.transform(this.state, false);
      }
      transform(state, checkNonGreedy, arg2) {
        if (arg2 == null) {
          return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
        } else if (arg2 instanceof PredictionContext_1.PredictionContext) {
          return this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
        } else if (arg2 instanceof SemanticContext_1.SemanticContext) {
          return this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);
        } else {
          return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);
        }
      }
      transformImpl(state, context, semanticContext, checkNonGreedy, lexerActionExecutor) {
        let passedThroughNonGreedy = checkNonGreedy && ATNConfig2.checkNonGreedyDecision(this, state);
        if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
          if (lexerActionExecutor != null || passedThroughNonGreedy) {
            return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);
          } else {
            return new SemanticContextATNConfig(semanticContext, state, this, context);
          }
        } else if (lexerActionExecutor != null || passedThroughNonGreedy) {
          return new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);
        } else {
          return new ATNConfig2(state, this, context);
        }
      }
      static checkNonGreedyDecision(source, target) {
        return source.hasPassedThroughNonGreedyDecision || target instanceof DecisionState_1.DecisionState && target.nonGreedy;
      }
      appendContext(context, contextCache) {
        if (typeof context === "number") {
          let appendedContext = this.context.appendSingleContext(context, contextCache);
          let result = this.transform(this.state, false, appendedContext);
          return result;
        } else {
          let appendedContext = this.context.appendContext(context, contextCache);
          let result = this.transform(this.state, false, appendedContext);
          return result;
        }
      }
      contains(subconfig) {
        if (this.state.stateNumber !== subconfig.state.stateNumber || this.alt !== subconfig.alt || !this.semanticContext.equals(subconfig.semanticContext)) {
          return false;
        }
        let leftWorkList = [];
        let rightWorkList = [];
        leftWorkList.push(this.context);
        rightWorkList.push(subconfig.context);
        while (true) {
          let left = leftWorkList.pop();
          let right = rightWorkList.pop();
          if (!left || !right) {
            break;
          }
          if (left === right) {
            return true;
          }
          if (left.size < right.size) {
            return false;
          }
          if (right.isEmpty) {
            return left.hasEmpty;
          } else {
            for (let i = 0; i < right.size; i++) {
              let index2 = left.findReturnState(right.getReturnState(i));
              if (index2 < 0) {
                return false;
              }
              leftWorkList.push(left.getParent(index2));
              rightWorkList.push(right.getParent(i));
            }
          }
        }
        return false;
      }
      get isPrecedenceFilterSuppressed() {
        return (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;
      }
      set isPrecedenceFilterSuppressed(value2) {
        if (value2) {
          this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;
        } else {
          this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;
        }
      }
      equals(o) {
        if (this === o) {
          return true;
        } else if (!(o instanceof ATNConfig2)) {
          return false;
        }
        return this.state.stateNumber === o.state.stateNumber && this.alt === o.alt && this.reachesIntoOuterContext === o.reachesIntoOuterContext && this.context.equals(o.context) && this.semanticContext.equals(o.semanticContext) && this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed && this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision && ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);
      }
      hashCode() {
        let hashCode = MurmurHash_1.MurmurHash.initialize(7);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.state.stateNumber);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.alt);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.context);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.semanticContext);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.lexerActionExecutor);
        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 7);
        return hashCode;
      }
      toDotString() {
        let builder = "";
        builder += "digraph G {\n";
        builder += "rankdir=LR;\n";
        let visited = new Array2DHashMap_1.Array2DHashMap(PredictionContext_1.PredictionContext.IdentityEqualityComparator.INSTANCE);
        let workList = [];
        function getOrAddContext(context) {
          let newNumber = visited.size;
          let result = visited.putIfAbsent(context, newNumber);
          if (result != null) {
            return result;
          }
          workList.push(context);
          return newNumber;
        }
        workList.push(this.context);
        visited.put(this.context, 0);
        while (true) {
          let current = workList.pop();
          if (!current) {
            break;
          }
          for (let i = 0; i < current.size; i++) {
            builder += "  s" + getOrAddContext(current);
            builder += "->";
            builder += "s" + getOrAddContext(current.getParent(i));
            builder += '[label="' + current.getReturnState(i) + '"];\n';
          }
        }
        builder += "}\n";
        return builder.toString();
      }
      toString(recog, showAlt, showContext) {
        if (showContext == null) {
          showContext = showAlt != null;
        }
        if (showAlt == null) {
          showAlt = true;
        }
        let buf = "";
        let contexts;
        if (showContext) {
          contexts = this.context.toStrings(recog, this.state.stateNumber);
        } else {
          contexts = ["?"];
        }
        let first = true;
        for (let contextDesc of contexts) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          buf += "(";
          buf += this.state;
          if (showAlt) {
            buf += ",";
            buf += this.alt;
          }
          if (this.context) {
            buf += ",";
            buf += contextDesc;
          }
          if (this.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            buf += ",";
            buf += this.semanticContext;
          }
          if (this.reachesIntoOuterContext) {
            buf += ",up=" + this.outerContextDepth;
          }
          buf += ")";
        }
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "_state", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "_context", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "state", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ATNConfig.prototype, "context", null);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "semanticContext", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "clone", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ATNConfig.prototype, "transformImpl", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "hashCode", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ATNConfig, "create", null);
    ATNConfig = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ATNConfig);
    exports.ATNConfig = ATNConfig;
    var SemanticContextATNConfig = class SemanticContextATNConfig extends ATNConfig {
      constructor(semanticContext, state, altOrConfig, context) {
        if (typeof altOrConfig === "number") {
          super(state, altOrConfig, context);
        } else {
          super(state, altOrConfig, context);
        }
        this._semanticContext = semanticContext;
      }
      get semanticContext() {
        return this._semanticContext;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SemanticContextATNConfig.prototype, "_semanticContext", void 0);
    __decorate([
      Decorators_1.Override
    ], SemanticContextATNConfig.prototype, "semanticContext", null);
    SemanticContextATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], SemanticContextATNConfig);
    var ActionATNConfig = class ActionATNConfig extends ATNConfig {
      constructor(lexerActionExecutor, state, altOrConfig, context, passedThroughNonGreedyDecision) {
        if (typeof altOrConfig === "number") {
          super(state, altOrConfig, context);
        } else {
          super(state, altOrConfig, context);
          if (altOrConfig.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            throw new Error("Not supported");
          }
        }
        this._lexerActionExecutor = lexerActionExecutor;
        this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
      }
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
      get hasPassedThroughNonGreedyDecision() {
        return this.passedThroughNonGreedyDecision;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionATNConfig.prototype, "lexerActionExecutor", null);
    __decorate([
      Decorators_1.Override
    ], ActionATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
    ActionATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ActionATNConfig);
    var ActionSemanticContextATNConfig = class ActionSemanticContextATNConfig extends SemanticContextATNConfig {
      constructor(lexerActionExecutor, semanticContext, state, altOrConfig, context, passedThroughNonGreedyDecision) {
        if (typeof altOrConfig === "number") {
          super(semanticContext, state, altOrConfig, context);
        } else {
          super(semanticContext, state, altOrConfig, context);
        }
        this._lexerActionExecutor = lexerActionExecutor;
        this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
      }
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
      get hasPassedThroughNonGreedyDecision() {
        return this.passedThroughNonGreedyDecision;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionSemanticContextATNConfig.prototype, "lexerActionExecutor", null);
    __decorate([
      Decorators_1.Override
    ], ActionSemanticContextATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
    ActionSemanticContextATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ActionSemanticContextATNConfig);
  }
});

// node_modules/antlr4ts/misc/BitSet.js
var require_BitSet = __commonJS({
  "node_modules/antlr4ts/misc/BitSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitSet = void 0;
    var util = require("util");
    var MurmurHash_1 = require_MurmurHash();
    var EMPTY_DATA = new Uint16Array(0);
    function getIndex(bitNumber) {
      return bitNumber >>> 4;
    }
    function unIndex(n) {
      return n * 16;
    }
    function findLSBSet(word) {
      let bit = 1;
      for (let i = 0; i < 16; i++) {
        if ((word & bit) !== 0) {
          return i;
        }
        bit = bit << 1 >>> 0;
      }
      throw new RangeError("No specified bit found");
    }
    function findMSBSet(word) {
      let bit = 1 << 15 >>> 0;
      for (let i = 15; i >= 0; i--) {
        if ((word & bit) !== 0) {
          return i;
        }
        bit = bit >>> 1;
      }
      throw new RangeError("No specified bit found");
    }
    function bitsFor(fromBit, toBit) {
      fromBit &= 15;
      toBit &= 15;
      if (fromBit === toBit) {
        return 1 << fromBit >>> 0;
      }
      return 65535 >>> 15 - toBit ^ 65535 >>> 16 - fromBit;
    }
    var POP_CNT = new Uint8Array(65536);
    for (let i = 0; i < 16; i++) {
      const stride = 1 << i >>> 0;
      let index2 = 0;
      while (index2 < POP_CNT.length) {
        index2 += stride;
        for (let j = 0; j < stride; j++) {
          POP_CNT[index2]++;
          index2++;
        }
      }
    }
    var BitSet = class {
      constructor(arg) {
        if (!arg) {
          this.data = EMPTY_DATA;
        } else if (typeof arg === "number") {
          if (arg < 0) {
            throw new RangeError("nbits cannot be negative");
          } else {
            this.data = new Uint16Array(getIndex(arg - 1) + 1);
          }
        } else {
          if (arg instanceof BitSet) {
            this.data = arg.data.slice(0);
          } else {
            let max = -1;
            for (let v of arg) {
              if (max < v) {
                max = v;
              }
            }
            this.data = new Uint16Array(getIndex(max - 1) + 1);
            for (let v of arg) {
              this.set(v);
            }
          }
        }
      }
      and(set) {
        const data = this.data;
        const other = set.data;
        const words = Math.min(data.length, other.length);
        let lastWord = -1;
        for (let i = 0; i < words; i++) {
          let value2 = data[i] &= other[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        }
        if (lastWord < data.length - 1) {
          this.data = data.slice(0, lastWord + 1);
        }
      }
      andNot(set) {
        const data = this.data;
        const other = set.data;
        const words = Math.min(data.length, other.length);
        let lastWord = -1;
        for (let i = 0; i < words; i++) {
          let value2 = data[i] &= other[i] ^ 65535;
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        }
        if (lastWord < data.length - 1) {
          this.data = data.slice(0, lastWord + 1);
        }
      }
      cardinality() {
        if (this.isEmpty) {
          return 0;
        }
        const data = this.data;
        const length = data.length;
        let result = 0;
        for (let i = 0; i < length; i++) {
          result += POP_CNT[data[i]];
        }
        return result;
      }
      clear(fromIndex, toIndex) {
        if (fromIndex == null) {
          this.data.fill(0);
        } else if (toIndex == null) {
          this.set(fromIndex, false);
        } else {
          this.set(fromIndex, toIndex, false);
        }
      }
      flip(fromIndex, toIndex) {
        if (toIndex == null) {
          toIndex = fromIndex;
        }
        if (fromIndex < 0 || toIndex < fromIndex) {
          throw new RangeError();
        }
        let word = getIndex(fromIndex);
        const lastWord = getIndex(toIndex);
        if (word === lastWord) {
          this.data[word] ^= bitsFor(fromIndex, toIndex);
        } else {
          this.data[word++] ^= bitsFor(fromIndex, 15);
          while (word < lastWord) {
            this.data[word++] ^= 65535;
          }
          this.data[word++] ^= bitsFor(0, toIndex);
        }
      }
      get(fromIndex, toIndex) {
        if (toIndex === void 0) {
          return !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));
        } else {
          let result = new BitSet(toIndex + 1);
          for (let i = fromIndex; i <= toIndex; i++) {
            result.set(i, this.get(i));
          }
          return result;
        }
      }
      intersects(set) {
        let smallerLength = Math.min(this.length(), set.length());
        if (smallerLength === 0) {
          return false;
        }
        let bound = getIndex(smallerLength - 1);
        for (let i = 0; i <= bound; i++) {
          if ((this.data[i] & set.data[i]) !== 0) {
            return true;
          }
        }
        return false;
      }
      get isEmpty() {
        return this.length() === 0;
      }
      length() {
        if (!this.data.length) {
          return 0;
        }
        return this.previousSetBit(unIndex(this.data.length) - 1) + 1;
      }
      nextClearBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word > length) {
          return -1;
        }
        let ignore = 65535 ^ bitsFor(fromIndex, 15);
        if ((data[word] | ignore) === 65535) {
          word++;
          ignore = 0;
          for (; word < length; word++) {
            if (data[word] !== 65535) {
              break;
            }
          }
          if (word === length) {
            return -1;
          }
        }
        return unIndex(word) + findLSBSet((data[word] | ignore) ^ 65535);
      }
      nextSetBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word > length) {
          return -1;
        }
        let mask = bitsFor(fromIndex, 15);
        if ((data[word] & mask) === 0) {
          word++;
          mask = 65535;
          for (; word < length; word++) {
            if (data[word] !== 0) {
              break;
            }
          }
          if (word >= length) {
            return -1;
          }
        }
        return unIndex(word) + findLSBSet(data[word] & mask);
      }
      or(set) {
        const data = this.data;
        const other = set.data;
        const minWords = Math.min(data.length, other.length);
        const words = Math.max(data.length, other.length);
        const dest = data.length === words ? data : new Uint16Array(words);
        let lastWord = -1;
        for (let i = 0; i < minWords; i++) {
          let value2 = dest[i] = data[i] | other[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        const longer = data.length > other.length ? data : other;
        for (let i = minWords; i < words; i++) {
          let value2 = dest[i] = longer[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        } else if (dest.length === lastWord + 1) {
          this.data = dest;
        } else {
          this.data = dest.slice(0, lastWord);
        }
      }
      previousClearBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word >= length) {
          word = length - 1;
        }
        let ignore = 65535 ^ bitsFor(0, fromIndex);
        if ((data[word] | ignore) === 65535) {
          ignore = 0;
          word--;
          for (; word >= 0; word--) {
            if (data[word] !== 65535) {
              break;
            }
          }
          if (word < 0) {
            return -1;
          }
        }
        return unIndex(word) + findMSBSet((data[word] | ignore) ^ 65535);
      }
      previousSetBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word >= length) {
          word = length - 1;
        }
        let mask = bitsFor(0, fromIndex);
        if ((data[word] & mask) === 0) {
          word--;
          mask = 65535;
          for (; word >= 0; word--) {
            if (data[word] !== 0) {
              break;
            }
          }
          if (word < 0) {
            return -1;
          }
        }
        return unIndex(word) + findMSBSet(data[word] & mask);
      }
      set(fromIndex, toIndex, value2) {
        if (toIndex === void 0) {
          toIndex = fromIndex;
          value2 = true;
        } else if (typeof toIndex === "boolean") {
          value2 = toIndex;
          toIndex = fromIndex;
        }
        if (value2 === void 0) {
          value2 = true;
        }
        if (fromIndex < 0 || fromIndex > toIndex) {
          throw new RangeError();
        }
        let word = getIndex(fromIndex);
        let lastWord = getIndex(toIndex);
        if (value2 && lastWord >= this.data.length) {
          let temp = new Uint16Array(lastWord + 1);
          this.data.forEach((value3, index2) => temp[index2] = value3);
          this.data = temp;
        } else if (!value2) {
          if (word >= this.data.length) {
            return;
          }
          if (lastWord >= this.data.length) {
            lastWord = this.data.length - 1;
            toIndex = this.data.length * 16 - 1;
          }
        }
        if (word === lastWord) {
          this._setBits(word, value2, bitsFor(fromIndex, toIndex));
        } else {
          this._setBits(word++, value2, bitsFor(fromIndex, 15));
          while (word < lastWord) {
            this.data[word++] = value2 ? 65535 : 0;
          }
          this._setBits(word, value2, bitsFor(0, toIndex));
        }
      }
      _setBits(word, value2, mask) {
        if (value2) {
          this.data[word] |= mask;
        } else {
          this.data[word] &= 65535 ^ mask;
        }
      }
      get size() {
        return this.data.byteLength * 8;
      }
      hashCode() {
        return MurmurHash_1.MurmurHash.hashCode(this.data, 22);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof BitSet)) {
          return false;
        }
        const len = this.length();
        if (len !== obj.length()) {
          return false;
        }
        if (len === 0) {
          return true;
        }
        let bound = getIndex(len - 1);
        for (let i = 0; i <= bound; i++) {
          if (this.data[i] !== obj.data[i]) {
            return false;
          }
        }
        return true;
      }
      toString() {
        let result = "{";
        let first = true;
        for (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {
          if (first) {
            first = false;
          } else {
            result += ", ";
          }
          result += i;
        }
        result += "}";
        return result;
      }
      xor(set) {
        const data = this.data;
        const other = set.data;
        const minWords = Math.min(data.length, other.length);
        const words = Math.max(data.length, other.length);
        const dest = data.length === words ? data : new Uint16Array(words);
        let lastWord = -1;
        for (let i = 0; i < minWords; i++) {
          let value2 = dest[i] = data[i] ^ other[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        const longer = data.length > other.length ? data : other;
        for (let i = minWords; i < words; i++) {
          let value2 = dest[i] = longer[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        } else if (dest.length === lastWord + 1) {
          this.data = dest;
        } else {
          this.data = dest.slice(0, lastWord + 1);
        }
      }
      clone() {
        return new BitSet(this);
      }
      [Symbol.iterator]() {
        return new BitSetIterator(this.data);
      }
      [util.inspect.custom]() {
        return "BitSet " + this.toString();
      }
    };
    exports.BitSet = BitSet;
    var BitSetIterator = class {
      constructor(data) {
        this.data = data;
        this.index = 0;
        this.mask = 65535;
      }
      next() {
        while (this.index < this.data.length) {
          const bits = this.data[this.index] & this.mask;
          if (bits !== 0) {
            const bitNumber = unIndex(this.index) + findLSBSet(bits);
            this.mask = bitsFor(bitNumber + 1, 15);
            return { done: false, value: bitNumber };
          }
          this.index++;
          this.mask = 65535;
        }
        return { done: true, value: -1 };
      }
      [Symbol.iterator]() {
        return this;
      }
    };
  }
});

// node_modules/antlr4ts/atn/ATNConfigSet.js
var require_ATNConfigSet = __commonJS({
  "node_modules/antlr4ts/atn/ATNConfigSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNConfigSet = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var BitSet_1 = require_BitSet();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var SemanticContext_1 = require_SemanticContext();
    var assert = require("assert");
    var Utils3 = require_Utils();
    var KeyTypeEqualityComparer = class {
      hashCode(key) {
        return key.state ^ key.alt;
      }
      equals(a, b) {
        return a.state === b.state && a.alt === b.alt;
      }
    };
    KeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer();
    function NewKeyedConfigMap(map) {
      if (map) {
        return new Array2DHashMap_1.Array2DHashMap(map);
      } else {
        return new Array2DHashMap_1.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE);
      }
    }
    var ATNConfigSet = class {
      constructor(set, readonly) {
        this._uniqueAlt = 0;
        this._hasSemanticContext = false;
        this._dipsIntoOuterContext = false;
        this.outermostConfigSet = false;
        this.cachedHashCode = -1;
        if (!set) {
          this.mergedConfigs = NewKeyedConfigMap();
          this.unmerged = [];
          this.configs = [];
          this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        } else {
          if (readonly) {
            this.mergedConfigs = void 0;
            this.unmerged = void 0;
          } else if (!set.isReadOnly) {
            this.mergedConfigs = NewKeyedConfigMap(set.mergedConfigs);
            this.unmerged = set.unmerged.slice(0);
          } else {
            this.mergedConfigs = NewKeyedConfigMap();
            this.unmerged = [];
          }
          this.configs = set.configs.slice(0);
          this._dipsIntoOuterContext = set._dipsIntoOuterContext;
          this._hasSemanticContext = set._hasSemanticContext;
          this.outermostConfigSet = set.outermostConfigSet;
          if (readonly || !set.isReadOnly) {
            this._uniqueAlt = set._uniqueAlt;
            this._conflictInfo = set._conflictInfo;
          }
        }
      }
      getRepresentedAlternatives() {
        if (this._conflictInfo != null) {
          return this._conflictInfo.conflictedAlts.clone();
        }
        let alts = new BitSet_1.BitSet();
        for (let config of this) {
          alts.set(config.alt);
        }
        return alts;
      }
      get isReadOnly() {
        return this.mergedConfigs == null;
      }
      get isOutermostConfigSet() {
        return this.outermostConfigSet;
      }
      set isOutermostConfigSet(outermostConfigSet) {
        if (this.outermostConfigSet && !outermostConfigSet) {
          throw new Error("IllegalStateException");
        }
        assert(!outermostConfigSet || !this._dipsIntoOuterContext);
        this.outermostConfigSet = outermostConfigSet;
      }
      getStates() {
        let states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        for (let c of this.configs) {
          states.add(c.state);
        }
        return states;
      }
      optimizeConfigs(interpreter) {
        if (this.configs.length === 0) {
          return;
        }
        for (let config of this.configs) {
          config.context = interpreter.atn.getCachedContext(config.context);
        }
      }
      clone(readonly) {
        let copy = new ATNConfigSet(this, readonly);
        if (!readonly && this.isReadOnly) {
          copy.addAll(this.configs);
        }
        return copy;
      }
      get size() {
        return this.configs.length;
      }
      get isEmpty() {
        return this.configs.length === 0;
      }
      contains(o) {
        if (!(o instanceof ATNConfig_1.ATNConfig)) {
          return false;
        }
        if (this.mergedConfigs && this.unmerged) {
          let config = o;
          let configKey = this.getKey(config);
          let mergedConfig = this.mergedConfigs.get(configKey);
          if (mergedConfig != null && this.canMerge(config, configKey, mergedConfig)) {
            return mergedConfig.contains(config);
          }
          for (let c of this.unmerged) {
            if (c.contains(o)) {
              return true;
            }
          }
        } else {
          for (let c of this.configs) {
            if (c.contains(o)) {
              return true;
            }
          }
        }
        return false;
      }
      *[Symbol.iterator]() {
        yield* this.configs;
      }
      toArray() {
        return this.configs;
      }
      add(e, contextCache) {
        this.ensureWritable();
        if (!this.mergedConfigs || !this.unmerged) {
          throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
        }
        assert(!this.outermostConfigSet || !e.reachesIntoOuterContext);
        if (contextCache == null) {
          contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
        }
        let addKey;
        let key = this.getKey(e);
        let mergedConfig = this.mergedConfigs.get(key);
        addKey = mergedConfig == null;
        if (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {
          mergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);
          if (e.isPrecedenceFilterSuppressed) {
            mergedConfig.isPrecedenceFilterSuppressed = true;
          }
          let joined = PredictionContext_1.PredictionContext.join(mergedConfig.context, e.context, contextCache);
          this.updatePropertiesForMergedConfig(e);
          if (mergedConfig.context === joined) {
            return false;
          }
          mergedConfig.context = joined;
          return true;
        }
        for (let i = 0; i < this.unmerged.length; i++) {
          let unmergedConfig = this.unmerged[i];
          if (this.canMerge(e, key, unmergedConfig)) {
            unmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);
            if (e.isPrecedenceFilterSuppressed) {
              unmergedConfig.isPrecedenceFilterSuppressed = true;
            }
            let joined = PredictionContext_1.PredictionContext.join(unmergedConfig.context, e.context, contextCache);
            this.updatePropertiesForMergedConfig(e);
            if (unmergedConfig.context === joined) {
              return false;
            }
            unmergedConfig.context = joined;
            if (addKey) {
              this.mergedConfigs.put(key, unmergedConfig);
              this.unmerged.splice(i, 1);
            }
            return true;
          }
        }
        this.configs.push(e);
        if (addKey) {
          this.mergedConfigs.put(key, e);
        } else {
          this.unmerged.push(e);
        }
        this.updatePropertiesForAddedConfig(e);
        return true;
      }
      updatePropertiesForMergedConfig(config) {
        this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
        assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
      }
      updatePropertiesForAddedConfig(config) {
        if (this.configs.length === 1) {
          this._uniqueAlt = config.alt;
        } else if (this._uniqueAlt !== config.alt) {
          this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        this._hasSemanticContext = this._hasSemanticContext || !SemanticContext_1.SemanticContext.NONE.equals(config.semanticContext);
        this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
        assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
      }
      canMerge(left, leftKey, right) {
        if (left.state.stateNumber !== right.state.stateNumber) {
          return false;
        }
        if (leftKey.alt !== right.alt) {
          return false;
        }
        return left.semanticContext.equals(right.semanticContext);
      }
      getKey(e) {
        return { state: e.state.stateNumber, alt: e.alt };
      }
      containsAll(c) {
        for (let o of c) {
          if (!(o instanceof ATNConfig_1.ATNConfig)) {
            return false;
          }
          if (!this.contains(o)) {
            return false;
          }
        }
        return true;
      }
      addAll(c, contextCache) {
        this.ensureWritable();
        let changed = false;
        for (let group of c) {
          if (this.add(group, contextCache)) {
            changed = true;
          }
        }
        return changed;
      }
      clear() {
        this.ensureWritable();
        if (!this.mergedConfigs || !this.unmerged) {
          throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
        }
        this.mergedConfigs.clear();
        this.unmerged.length = 0;
        this.configs.length = 0;
        this._dipsIntoOuterContext = false;
        this._hasSemanticContext = false;
        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        this._conflictInfo = void 0;
      }
      equals(obj) {
        if (this === obj) {
          return true;
        }
        if (!(obj instanceof ATNConfigSet)) {
          return false;
        }
        return this.outermostConfigSet === obj.outermostConfigSet && Utils3.equals(this._conflictInfo, obj._conflictInfo) && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);
      }
      hashCode() {
        if (this.isReadOnly && this.cachedHashCode !== -1) {
          return this.cachedHashCode;
        }
        let hashCode = 1;
        hashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);
        hashCode = 5 * hashCode ^ ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);
        if (this.isReadOnly) {
          this.cachedHashCode = hashCode;
        }
        return hashCode;
      }
      toString(showContext) {
        if (showContext == null) {
          showContext = false;
        }
        let buf = "";
        let sortedConfigs = this.configs.slice(0);
        sortedConfigs.sort((o1, o2) => {
          if (o1.alt !== o2.alt) {
            return o1.alt - o2.alt;
          } else if (o1.state.stateNumber !== o2.state.stateNumber) {
            return o1.state.stateNumber - o2.state.stateNumber;
          } else {
            return o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());
          }
        });
        buf += "[";
        for (let i = 0; i < sortedConfigs.length; i++) {
          if (i > 0) {
            buf += ", ";
          }
          buf += sortedConfigs[i].toString(void 0, true, showContext);
        }
        buf += "]";
        if (this._hasSemanticContext) {
          buf += ",hasSemanticContext=" + this._hasSemanticContext;
        }
        if (this._uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          buf += ",uniqueAlt=" + this._uniqueAlt;
        }
        if (this._conflictInfo != null) {
          buf += ",conflictingAlts=" + this._conflictInfo.conflictedAlts;
          if (!this._conflictInfo.isExact) {
            buf += "*";
          }
        }
        if (this._dipsIntoOuterContext) {
          buf += ",dipsIntoOuterContext";
        }
        return buf.toString();
      }
      get uniqueAlt() {
        return this._uniqueAlt;
      }
      get hasSemanticContext() {
        return this._hasSemanticContext;
      }
      set hasSemanticContext(value2) {
        this.ensureWritable();
        this._hasSemanticContext = value2;
      }
      get conflictInfo() {
        return this._conflictInfo;
      }
      set conflictInfo(conflictInfo) {
        this.ensureWritable();
        this._conflictInfo = conflictInfo;
      }
      get conflictingAlts() {
        if (this._conflictInfo == null) {
          return void 0;
        }
        return this._conflictInfo.conflictedAlts;
      }
      get isExactConflict() {
        if (this._conflictInfo == null) {
          return false;
        }
        return this._conflictInfo.isExact;
      }
      get dipsIntoOuterContext() {
        return this._dipsIntoOuterContext;
      }
      get(index2) {
        return this.configs[index2];
      }
      ensureWritable() {
        if (this.isReadOnly) {
          throw new Error("This ATNConfigSet is read only.");
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNConfigSet.prototype, "getRepresentedAlternatives", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "contains", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, Symbol.iterator, null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "toArray", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "containsAll", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "clear", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "hashCode", null);
    exports.ATNConfigSet = ATNConfigSet;
  }
});

// node_modules/antlr4ts/dfa/DFAState.js
var require_DFAState = __commonJS({
  "node_modules/antlr4ts/dfa/DFAState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DFAState = void 0;
    var ATN_1 = require_ATN();
    var BitSet_1 = require_BitSet();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var assert = require("assert");
    var DFAState = class {
      constructor(configs) {
        this.stateNumber = -1;
        this.configs = configs;
        this.edges = /* @__PURE__ */ new Map();
        this.contextEdges = /* @__PURE__ */ new Map();
      }
      get isContextSensitive() {
        return !!this.contextSymbols;
      }
      isContextSymbol(symbol) {
        if (!this.isContextSensitive) {
          return false;
        }
        return this.contextSymbols.get(symbol);
      }
      setContextSymbol(symbol) {
        assert(this.isContextSensitive);
        this.contextSymbols.set(symbol);
      }
      setContextSensitive(atn) {
        assert(!this.configs.isOutermostConfigSet);
        if (this.isContextSensitive) {
          return;
        }
        if (!this.contextSymbols) {
          this.contextSymbols = new BitSet_1.BitSet();
        }
      }
      get acceptStateInfo() {
        return this._acceptStateInfo;
      }
      set acceptStateInfo(acceptStateInfo) {
        this._acceptStateInfo = acceptStateInfo;
      }
      get isAcceptState() {
        return !!this._acceptStateInfo;
      }
      get prediction() {
        if (!this._acceptStateInfo) {
          return ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        return this._acceptStateInfo.prediction;
      }
      get lexerActionExecutor() {
        if (!this._acceptStateInfo) {
          return void 0;
        }
        return this._acceptStateInfo.lexerActionExecutor;
      }
      getTarget(symbol) {
        return this.edges.get(symbol);
      }
      setTarget(symbol, target) {
        this.edges.set(symbol, target);
      }
      getEdgeMap() {
        return this.edges;
      }
      getContextTarget(invokingState) {
        if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          invokingState = -1;
        }
        return this.contextEdges.get(invokingState);
      }
      setContextTarget(invokingState, target) {
        if (!this.isContextSensitive) {
          throw new Error("The state is not context sensitive.");
        }
        if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          invokingState = -1;
        }
        this.contextEdges.set(invokingState, target);
      }
      getContextEdgeMap() {
        let map = new Map(this.contextEdges);
        let existing = map.get(-1);
        if (existing !== void 0) {
          if (map.size === 1) {
            let result = /* @__PURE__ */ new Map();
            result.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
            return result;
          } else {
            map.delete(-1);
            map.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
          }
        }
        return map;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize(7);
        hash = MurmurHash_1.MurmurHash.update(hash, this.configs.hashCode());
        hash = MurmurHash_1.MurmurHash.finish(hash, 1);
        return hash;
      }
      equals(o) {
        if (this === o) {
          return true;
        }
        if (!(o instanceof DFAState)) {
          return false;
        }
        let other = o;
        let sameSet = this.configs.equals(other.configs);
        return sameSet;
      }
      toString() {
        let buf = "";
        buf += this.stateNumber + ":" + this.configs;
        if (this.isAcceptState) {
          buf += "=>";
          if (this.predicates) {
            buf += this.predicates;
          } else {
            buf += this.prediction;
          }
        }
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "configs", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "edges", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "contextEdges", void 0);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "toString", null);
    exports.DFAState = DFAState;
    (function(DFAState2) {
      let PredPrediction = class PredPrediction {
        constructor(pred, alt) {
          this.alt = alt;
          this.pred = pred;
        }
        toString() {
          return "(" + this.pred + ", " + this.alt + ")";
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], PredPrediction.prototype, "pred", void 0);
      __decorate([
        Decorators_1.Override
      ], PredPrediction.prototype, "toString", null);
      PredPrediction = __decorate([
        __param(0, Decorators_1.NotNull)
      ], PredPrediction);
      DFAState2.PredPrediction = PredPrediction;
    })(DFAState = exports.DFAState || (exports.DFAState = {}));
  }
});

// node_modules/antlr4ts/atn/ATNSimulator.js
var require_ATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNSimulator = void 0;
    var ATNConfigSet_1 = require_ATNConfigSet();
    var DFAState_1 = require_DFAState();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var ATNSimulator = class ATNSimulator2 {
      constructor(atn) {
        this.atn = atn;
      }
      static get ERROR() {
        if (!ATNSimulator2._ERROR) {
          ATNSimulator2._ERROR = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
          ATNSimulator2._ERROR.stateNumber = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
        }
        return ATNSimulator2._ERROR;
      }
      clearDFA() {
        this.atn.clearDFA();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNSimulator.prototype, "atn", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNSimulator, "ERROR", null);
    ATNSimulator = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNSimulator);
    exports.ATNSimulator = ATNSimulator;
    (function(ATNSimulator2) {
      const RULE_VARIANT_DELIMITER = "$";
      const RULE_LF_VARIANT_MARKER = "$lf$";
      const RULE_NOLF_VARIANT_MARKER = "$nolf$";
    })(ATNSimulator = exports.ATNSimulator || (exports.ATNSimulator = {}));
    exports.ATNSimulator = ATNSimulator;
  }
});

// node_modules/antlr4ts/ConsoleErrorListener.js
var require_ConsoleErrorListener = __commonJS({
  "node_modules/antlr4ts/ConsoleErrorListener.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConsoleErrorListener = void 0;
    var ConsoleErrorListener = class {
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        console.error(`line ${line}:${charPositionInLine} ${msg}`);
      }
    };
    exports.ConsoleErrorListener = ConsoleErrorListener;
    ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
  }
});

// node_modules/antlr4ts/ProxyErrorListener.js
var require_ProxyErrorListener = __commonJS({
  "node_modules/antlr4ts/ProxyErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyErrorListener = void 0;
    var Decorators_1 = require_Decorators();
    var ProxyErrorListener = class {
      constructor(delegates) {
        this.delegates = delegates;
        if (!delegates) {
          throw new Error("Invalid delegates");
        }
      }
      getDelegates() {
        return this.delegates;
      }
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        this.delegates.forEach((listener) => {
          if (listener.syntaxError) {
            listener.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e);
          }
        });
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull)
    ], ProxyErrorListener.prototype, "syntaxError", null);
    exports.ProxyErrorListener = ProxyErrorListener;
  }
});

// node_modules/antlr4ts/Recognizer.js
var require_Recognizer = __commonJS({
  "node_modules/antlr4ts/Recognizer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Recognizer = void 0;
    var ConsoleErrorListener_1 = require_ConsoleErrorListener();
    var ProxyErrorListener_1 = require_ProxyErrorListener();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var Utils3 = require_Utils();
    var Recognizer = class {
      constructor() {
        this._listeners = [ConsoleErrorListener_1.ConsoleErrorListener.INSTANCE];
        this._stateNumber = -1;
      }
      getTokenTypeMap() {
        let vocabulary = this.vocabulary;
        let result = Recognizer.tokenTypeMapCache.get(vocabulary);
        if (result == null) {
          let intermediateResult = /* @__PURE__ */ new Map();
          for (let i = 0; i <= this.atn.maxTokenType; i++) {
            let literalName = vocabulary.getLiteralName(i);
            if (literalName != null) {
              intermediateResult.set(literalName, i);
            }
            let symbolicName = vocabulary.getSymbolicName(i);
            if (symbolicName != null) {
              intermediateResult.set(symbolicName, i);
            }
          }
          intermediateResult.set("EOF", Token_1.Token.EOF);
          result = intermediateResult;
          Recognizer.tokenTypeMapCache.set(vocabulary, result);
        }
        return result;
      }
      getRuleIndexMap() {
        let ruleNames = this.ruleNames;
        if (ruleNames == null) {
          throw new Error("The current recognizer does not provide a list of rule names.");
        }
        let result = Recognizer.ruleIndexMapCache.get(ruleNames);
        if (result == null) {
          result = Utils3.toMap(ruleNames);
          Recognizer.ruleIndexMapCache.set(ruleNames, result);
        }
        return result;
      }
      getTokenType(tokenName) {
        let ttype = this.getTokenTypeMap().get(tokenName);
        if (ttype != null) {
          return ttype;
        }
        return Token_1.Token.INVALID_TYPE;
      }
      get serializedATN() {
        throw new Error("there is no serialized ATN");
      }
      get atn() {
        return this._interp.atn;
      }
      get interpreter() {
        return this._interp;
      }
      set interpreter(interpreter) {
        this._interp = interpreter;
      }
      get parseInfo() {
        return Promise.resolve(void 0);
      }
      getErrorHeader(e) {
        let token = e.getOffendingToken();
        if (!token) {
          return "";
        }
        let line = token.line;
        let charPositionInLine = token.charPositionInLine;
        return "line " + line + ":" + charPositionInLine;
      }
      addErrorListener(listener) {
        if (!listener) {
          throw new TypeError("listener must not be null");
        }
        this._listeners.push(listener);
      }
      removeErrorListener(listener) {
        let position2 = this._listeners.indexOf(listener);
        if (position2 !== -1) {
          this._listeners.splice(position2, 1);
        }
      }
      removeErrorListeners() {
        this._listeners.length = 0;
      }
      getErrorListeners() {
        return this._listeners.slice(0);
      }
      getErrorListenerDispatch() {
        return new ProxyErrorListener_1.ProxyErrorListener(this.getErrorListeners());
      }
      sempred(_localctx, ruleIndex, actionIndex) {
        return true;
      }
      precpred(localctx, precedence) {
        return true;
      }
      action(_localctx, ruleIndex, actionIndex) {
      }
      get state() {
        return this._stateNumber;
      }
      set state(atnState) {
        this._stateNumber = atnState;
      }
    };
    Recognizer.EOF = -1;
    Recognizer.tokenTypeMapCache = /* @__PURE__ */ new WeakMap();
    Recognizer.ruleIndexMapCache = /* @__PURE__ */ new WeakMap();
    __decorate([
      Decorators_1.SuppressWarnings("serial"),
      Decorators_1.NotNull
    ], Recognizer.prototype, "_listeners", void 0);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getTokenTypeMap", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getRuleIndexMap", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "serializedATN", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "atn", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "interpreter", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "getErrorHeader", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "addErrorListener", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "removeErrorListener", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getErrorListeners", null);
    exports.Recognizer = Recognizer;
  }
});

// node_modules/antlr4ts/VocabularyImpl.js
var require_VocabularyImpl = __commonJS({
  "node_modules/antlr4ts/VocabularyImpl.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VocabularyImpl = void 0;
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var VocabularyImpl3 = class {
      constructor(literalNames, symbolicNames, displayNames) {
        this.literalNames = literalNames;
        this.symbolicNames = symbolicNames;
        this.displayNames = displayNames;
        this._maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
      }
      get maxTokenType() {
        return this._maxTokenType;
      }
      getLiteralName(tokenType) {
        if (tokenType >= 0 && tokenType < this.literalNames.length) {
          return this.literalNames[tokenType];
        }
        return void 0;
      }
      getSymbolicName(tokenType) {
        if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
          return this.symbolicNames[tokenType];
        }
        if (tokenType === Token_1.Token.EOF) {
          return "EOF";
        }
        return void 0;
      }
      getDisplayName(tokenType) {
        if (tokenType >= 0 && tokenType < this.displayNames.length) {
          let displayName = this.displayNames[tokenType];
          if (displayName) {
            return displayName;
          }
        }
        let literalName = this.getLiteralName(tokenType);
        if (literalName) {
          return literalName;
        }
        let symbolicName = this.getSymbolicName(tokenType);
        if (symbolicName) {
          return symbolicName;
        }
        return String(tokenType);
      }
    };
    VocabularyImpl3.EMPTY_VOCABULARY = new VocabularyImpl3([], [], []);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "literalNames", void 0);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "symbolicNames", void 0);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "displayNames", void 0);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl3.prototype, "maxTokenType", null);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl3.prototype, "getLiteralName", null);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl3.prototype, "getSymbolicName", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "getDisplayName", null);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3, "EMPTY_VOCABULARY", void 0);
    exports.VocabularyImpl = VocabularyImpl3;
  }
});

// node_modules/antlr4ts/dfa/DFASerializer.js
var require_DFASerializer = __commonJS({
  "node_modules/antlr4ts/dfa/DFASerializer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DFASerializer = void 0;
    var ATNSimulator_1 = require_ATNSimulator();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var Recognizer_1 = require_Recognizer();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var DFASerializer = class {
      constructor(dfa, vocabulary, ruleNames, atn) {
        if (vocabulary instanceof Recognizer_1.Recognizer) {
          ruleNames = vocabulary.ruleNames;
          atn = vocabulary.atn;
          vocabulary = vocabulary.vocabulary;
        } else if (!vocabulary) {
          vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        }
        this.dfa = dfa;
        this.vocabulary = vocabulary;
        this.ruleNames = ruleNames;
        this.atn = atn;
      }
      toString() {
        if (!this.dfa.s0) {
          return "";
        }
        let buf = "";
        if (this.dfa.states) {
          let states = new Array(...this.dfa.states.toArray());
          states.sort((o1, o2) => o1.stateNumber - o2.stateNumber);
          for (let s of states) {
            let edges = s.getEdgeMap();
            let edgeKeys = [...edges.keys()].sort((a, b) => a - b);
            let contextEdges = s.getContextEdgeMap();
            let contextEdgeKeys = [...contextEdges.keys()].sort((a, b) => a - b);
            for (let entry of edgeKeys) {
              let value2 = edges.get(entry);
              if ((value2 == null || value2 === ATNSimulator_1.ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {
                continue;
              }
              let contextSymbol = false;
              buf += this.getStateString(s) + "-" + this.getEdgeLabel(entry) + "->";
              if (s.isContextSymbol(entry)) {
                buf += "!";
                contextSymbol = true;
              }
              let t = value2;
              if (t && t.stateNumber !== ATNSimulator_1.ATNSimulator.ERROR.stateNumber) {
                buf += this.getStateString(t) + "\n";
              } else if (contextSymbol) {
                buf += "ctx\n";
              }
            }
            if (s.isContextSensitive) {
              for (let entry of contextEdgeKeys) {
                buf += this.getStateString(s) + "-" + this.getContextLabel(entry) + "->" + this.getStateString(contextEdges.get(entry)) + "\n";
              }
            }
          }
        }
        let output = buf;
        if (output.length === 0) {
          return "";
        }
        return output;
      }
      getContextLabel(i) {
        if (i === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          return "ctx:EMPTY_FULL";
        } else if (i === PredictionContext_1.PredictionContext.EMPTY_LOCAL_STATE_KEY) {
          return "ctx:EMPTY_LOCAL";
        }
        if (this.atn && i > 0 && i <= this.atn.states.length) {
          let state = this.atn.states[i];
          let ruleIndex = state.ruleIndex;
          if (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {
            return "ctx:" + String(i) + "(" + this.ruleNames[ruleIndex] + ")";
          }
        }
        return "ctx:" + String(i);
      }
      getEdgeLabel(i) {
        return this.vocabulary.getDisplayName(i);
      }
      getStateString(s) {
        if (s === ATNSimulator_1.ATNSimulator.ERROR) {
          return "ERROR";
        }
        let n = s.stateNumber;
        let stateStr = "s" + n;
        if (s.isAcceptState) {
          if (s.predicates) {
            stateStr = ":s" + n + "=>" + s.predicates;
          } else {
            stateStr = ":s" + n + "=>" + s.prediction;
          }
        }
        if (s.isContextSensitive) {
          stateStr += "*";
          for (let config of s.configs) {
            if (config.reachesIntoOuterContext) {
              stateStr += "*";
              break;
            }
          }
        }
        return stateStr;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFASerializer.prototype, "dfa", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFASerializer.prototype, "vocabulary", void 0);
    __decorate([
      Decorators_1.Override
    ], DFASerializer.prototype, "toString", null);
    exports.DFASerializer = DFASerializer;
  }
});

// node_modules/antlr4ts/dfa/LexerDFASerializer.js
var require_LexerDFASerializer = __commonJS({
  "node_modules/antlr4ts/dfa/LexerDFASerializer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerDFASerializer = void 0;
    var DFASerializer_1 = require_DFASerializer();
    var Decorators_1 = require_Decorators();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var LexerDFASerializer = class LexerDFASerializer extends DFASerializer_1.DFASerializer {
      constructor(dfa) {
        super(dfa, VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY);
      }
      getEdgeLabel(i) {
        return "'" + String.fromCodePoint(i) + "'";
      }
    };
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], LexerDFASerializer.prototype, "getEdgeLabel", null);
    LexerDFASerializer = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerDFASerializer);
    exports.LexerDFASerializer = LexerDFASerializer;
  }
});

// node_modules/antlr4ts/atn/StarLoopEntryState.js
var require_StarLoopEntryState = __commonJS({
  "node_modules/antlr4ts/atn/StarLoopEntryState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarLoopEntryState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BitSet_1 = require_BitSet();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var StarLoopEntryState = class extends DecisionState_1.DecisionState {
      constructor() {
        super(...arguments);
        this.precedenceRuleDecision = false;
        this.precedenceLoopbackStates = new BitSet_1.BitSet();
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarLoopEntryState.prototype, "stateType", null);
    exports.StarLoopEntryState = StarLoopEntryState;
  }
});

// node_modules/antlr4ts/dfa/DFA.js
var require_DFA = __commonJS({
  "node_modules/antlr4ts/dfa/DFA.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DFA = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var DFASerializer_1 = require_DFASerializer();
    var DFAState_1 = require_DFAState();
    var LexerDFASerializer_1 = require_LexerDFASerializer();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var DFA = class DFA {
      constructor(atnStartState, decision = 0) {
        this.states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.nextStateNumber = 0;
        if (!atnStartState.atn) {
          throw new Error("The ATNState must be associated with an ATN");
        }
        this.atnStartState = atnStartState;
        this.atn = atnStartState.atn;
        this.decision = decision;
        let isPrecedenceDfa = false;
        if (atnStartState instanceof StarLoopEntryState_1.StarLoopEntryState) {
          if (atnStartState.precedenceRuleDecision) {
            isPrecedenceDfa = true;
            this.s0 = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
            this.s0full = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
          }
        }
        this.precedenceDfa = isPrecedenceDfa;
      }
      get isPrecedenceDfa() {
        return this.precedenceDfa;
      }
      getPrecedenceStartState(precedence, fullContext) {
        if (!this.isPrecedenceDfa) {
          throw new Error("Only precedence DFAs may contain a precedence start state.");
        }
        if (fullContext) {
          return this.s0full.getTarget(precedence);
        } else {
          return this.s0.getTarget(precedence);
        }
      }
      setPrecedenceStartState(precedence, fullContext, startState) {
        if (!this.isPrecedenceDfa) {
          throw new Error("Only precedence DFAs may contain a precedence start state.");
        }
        if (precedence < 0) {
          return;
        }
        if (fullContext) {
          this.s0full.setTarget(precedence, startState);
        } else {
          this.s0.setTarget(precedence, startState);
        }
      }
      get isEmpty() {
        if (this.isPrecedenceDfa) {
          return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0;
        }
        return this.s0 == null && this.s0full == null;
      }
      get isContextSensitive() {
        if (this.isPrecedenceDfa) {
          return this.s0full.getEdgeMap().size > 0;
        }
        return this.s0full != null;
      }
      addState(state) {
        state.stateNumber = this.nextStateNumber++;
        return this.states.getOrAdd(state);
      }
      toString(vocabulary, ruleNames) {
        if (!vocabulary) {
          vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        }
        if (!this.s0) {
          return "";
        }
        let serializer;
        if (ruleNames) {
          serializer = new DFASerializer_1.DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);
        } else {
          serializer = new DFASerializer_1.DFASerializer(this, vocabulary);
        }
        return serializer.toString();
      }
      toLexerString() {
        if (!this.s0) {
          return "";
        }
        let serializer = new LexerDFASerializer_1.LexerDFASerializer(this);
        return serializer.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "states", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "atnStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "atn", void 0);
    DFA = __decorate([
      __param(0, Decorators_1.NotNull)
    ], DFA);
    exports.DFA = DFA;
  }
});

// node_modules/antlr4ts/atn/BasicState.js
var require_BasicState = __commonJS({
  "node_modules/antlr4ts/atn/BasicState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var BasicState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BASIC;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BasicState.prototype, "stateType", null);
    exports.BasicState = BasicState;
  }
});

// node_modules/antlr4ts/atn/InvalidState.js
var require_InvalidState = __commonJS({
  "node_modules/antlr4ts/atn/InvalidState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BasicState_1 = require_BasicState();
    var Decorators_1 = require_Decorators();
    var InvalidState = class extends BasicState_1.BasicState {
      get stateType() {
        return ATNStateType_1.ATNStateType.INVALID_TYPE;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InvalidState.prototype, "stateType", null);
    exports.InvalidState = InvalidState;
  }
});

// node_modules/antlr4ts/atn/SetTransition.js
var require_SetTransition = __commonJS({
  "node_modules/antlr4ts/atn/SetTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var Transition_1 = require_Transition();
    var SetTransition = class SetTransition extends Transition_1.Transition {
      constructor(target, set) {
        super(target);
        if (set == null) {
          set = IntervalSet_1.IntervalSet.of(Token_1.Token.INVALID_TYPE);
        }
        this.set = set;
      }
      get serializationType() {
        return 7;
      }
      get label() {
        return this.set;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this.set.contains(symbol);
      }
      toString() {
        return this.set.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SetTransition.prototype, "set", void 0);
    __decorate([
      Decorators_1.Override
    ], SetTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], SetTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], SetTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], SetTransition.prototype, "toString", null);
    SetTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.Nullable)
    ], SetTransition);
    exports.SetTransition = SetTransition;
  }
});

// node_modules/antlr4ts/atn/NotSetTransition.js
var require_NotSetTransition = __commonJS({
  "node_modules/antlr4ts/atn/NotSetTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotSetTransition = void 0;
    var Decorators_1 = require_Decorators();
    var SetTransition_1 = require_SetTransition();
    var NotSetTransition = class NotSetTransition extends SetTransition_1.SetTransition {
      constructor(target, set) {
        super(target, set);
      }
      get serializationType() {
        return 8;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
      }
      toString() {
        return "~" + super.toString();
      }
    };
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "toString", null);
    NotSetTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.Nullable)
    ], NotSetTransition);
    exports.NotSetTransition = NotSetTransition;
  }
});

// node_modules/antlr4ts/atn/RuleStopState.js
var require_RuleStopState = __commonJS({
  "node_modules/antlr4ts/atn/RuleStopState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleStopState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var RuleStopState = class extends ATNState_1.ATNState {
      get nonStopStateNumber() {
        return -1;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.RULE_STOP;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleStopState.prototype, "nonStopStateNumber", null);
    __decorate([
      Decorators_1.Override
    ], RuleStopState.prototype, "stateType", null);
    exports.RuleStopState = RuleStopState;
  }
});

// node_modules/antlr4ts/atn/RuleTransition.js
var require_RuleTransition = __commonJS({
  "node_modules/antlr4ts/atn/RuleTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var RuleTransition = class RuleTransition extends Transition_1.Transition {
      constructor(ruleStart, ruleIndex, precedence, followState) {
        super(ruleStart);
        this.tailCall = false;
        this.optimizedTailCall = false;
        this.ruleIndex = ruleIndex;
        this.precedence = precedence;
        this.followState = followState;
      }
      get serializationType() {
        return 3;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], RuleTransition.prototype, "followState", void 0);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "matches", null);
    RuleTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], RuleTransition);
    exports.RuleTransition = RuleTransition;
  }
});

// node_modules/antlr4ts/atn/WildcardTransition.js
var require_WildcardTransition = __commonJS({
  "node_modules/antlr4ts/atn/WildcardTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WildcardTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var WildcardTransition = class WildcardTransition extends Transition_1.Transition {
      constructor(target) {
        super(target);
      }
      get serializationType() {
        return 9;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
      }
      toString() {
        return ".";
      }
    };
    __decorate([
      Decorators_1.Override
    ], WildcardTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], WildcardTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], WildcardTransition.prototype, "toString", null);
    WildcardTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], WildcardTransition);
    exports.WildcardTransition = WildcardTransition;
  }
});

// node_modules/antlr4ts/atn/LL1Analyzer.js
var require_LL1Analyzer = __commonJS({
  "node_modules/antlr4ts/atn/LL1Analyzer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LL1Analyzer = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATNConfig_1 = require_ATNConfig();
    var BitSet_1 = require_BitSet();
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var Token_1 = require_Token();
    var WildcardTransition_1 = require_WildcardTransition();
    var LL1Analyzer = class LL1Analyzer2 {
      constructor(atn) {
        this.atn = atn;
      }
      getDecisionLookahead(s) {
        if (s == null) {
          return void 0;
        }
        let look = new Array(s.numberOfTransitions);
        for (let alt = 0; alt < s.numberOfTransitions; alt++) {
          let current = new IntervalSet_1.IntervalSet();
          look[alt] = current;
          let lookBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          let seeThruPreds = false;
          this._LOOK(s.transition(alt).target, void 0, PredictionContext_1.PredictionContext.EMPTY_LOCAL, current, lookBusy, new BitSet_1.BitSet(), seeThruPreds, false);
          if (current.size === 0 || current.contains(LL1Analyzer2.HIT_PRED)) {
            current = void 0;
            look[alt] = current;
          }
        }
        return look;
      }
      LOOK(s, ctx, stopState) {
        if (stopState === void 0) {
          if (s.atn == null) {
            throw new Error("Illegal state");
          }
          stopState = s.atn.ruleToStopState[s.ruleIndex];
        } else if (stopState === null) {
          stopState = void 0;
        }
        let r = new IntervalSet_1.IntervalSet();
        let seeThruPreds = true;
        let addEOF = true;
        this._LOOK(s, stopState, ctx, r, new Array2DHashSet_1.Array2DHashSet(), new BitSet_1.BitSet(), seeThruPreds, addEOF);
        return r;
      }
      _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
        let c = ATNConfig_1.ATNConfig.create(s, 0, ctx);
        if (!lookBusy.add(c)) {
          return;
        }
        if (s === stopState) {
          if (PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
            look.add(Token_1.Token.EPSILON);
            return;
          } else if (ctx.isEmpty) {
            if (addEOF) {
              look.add(Token_1.Token.EOF);
            }
            return;
          }
        }
        if (s instanceof RuleStopState_1.RuleStopState) {
          if (ctx.isEmpty && !PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
            if (addEOF) {
              look.add(Token_1.Token.EOF);
            }
            return;
          }
          let removed = calledRuleStack.get(s.ruleIndex);
          try {
            calledRuleStack.clear(s.ruleIndex);
            for (let i = 0; i < ctx.size; i++) {
              if (ctx.getReturnState(i) === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                continue;
              }
              let returnState = this.atn.states[ctx.getReturnState(i)];
              this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            }
          } finally {
            if (removed) {
              calledRuleStack.set(s.ruleIndex);
            }
          }
        }
        let n = s.numberOfTransitions;
        for (let i = 0; i < n; i++) {
          let t = s.transition(i);
          if (t instanceof RuleTransition_1.RuleTransition) {
            if (calledRuleStack.get(t.ruleIndex)) {
              continue;
            }
            let newContext = ctx.getChild(t.followState.stateNumber);
            try {
              calledRuleStack.set(t.ruleIndex);
              this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } finally {
              calledRuleStack.clear(t.ruleIndex);
            }
          } else if (t instanceof AbstractPredicateTransition_1.AbstractPredicateTransition) {
            if (seeThruPreds) {
              this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else {
              look.add(LL1Analyzer2.HIT_PRED);
            }
          } else if (t.isEpsilon) {
            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } else if (t instanceof WildcardTransition_1.WildcardTransition) {
            look.addAll(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
          } else {
            let set = t.label;
            if (set != null) {
              if (t instanceof NotSetTransition_1.NotSetTransition) {
                set = set.complement(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
              }
              look.addAll(set);
            }
          }
        }
      }
    };
    LL1Analyzer.HIT_PRED = Token_1.Token.INVALID_TYPE;
    __decorate([
      Decorators_1.NotNull
    ], LL1Analyzer.prototype, "atn", void 0);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LL1Analyzer.prototype, "LOOK", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], LL1Analyzer.prototype, "_LOOK", null);
    LL1Analyzer = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LL1Analyzer);
    exports.LL1Analyzer = LL1Analyzer;
  }
});

// node_modules/antlr4ts/atn/ATN.js
var require_ATN = __commonJS({
  "node_modules/antlr4ts/atn/ATN.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATN = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var DFA_1 = require_DFA();
    var IntervalSet_1 = require_IntervalSet();
    var InvalidState_1 = require_InvalidState();
    var LL1Analyzer_1 = require_LL1Analyzer();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var Token_1 = require_Token();
    var assert = require("assert");
    var ATN2 = class ATN {
      constructor(grammarType, maxTokenType) {
        this.states = [];
        this.decisionToState = [];
        this.modeNameToStartState = /* @__PURE__ */ new Map();
        this.modeToStartState = [];
        this.contextCache = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.decisionToDFA = [];
        this.modeToDFA = [];
        this.LL1Table = /* @__PURE__ */ new Map();
        this.grammarType = grammarType;
        this.maxTokenType = maxTokenType;
      }
      clearDFA() {
        this.decisionToDFA = new Array(this.decisionToState.length);
        for (let i = 0; i < this.decisionToDFA.length; i++) {
          this.decisionToDFA[i] = new DFA_1.DFA(this.decisionToState[i], i);
        }
        this.modeToDFA = new Array(this.modeToStartState.length);
        for (let i = 0; i < this.modeToDFA.length; i++) {
          this.modeToDFA[i] = new DFA_1.DFA(this.modeToStartState[i]);
        }
        this.contextCache.clear();
        this.LL1Table.clear();
      }
      get contextCacheSize() {
        return this.contextCache.size;
      }
      getCachedContext(context) {
        return PredictionContext_1.PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext_1.PredictionContext.IdentityHashMap());
      }
      getDecisionToDFA() {
        assert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);
        return this.decisionToDFA;
      }
      nextTokens(s, ctx) {
        if (ctx) {
          let anal = new LL1Analyzer_1.LL1Analyzer(this);
          let next = anal.LOOK(s, ctx);
          return next;
        } else {
          if (s.nextTokenWithinRule) {
            return s.nextTokenWithinRule;
          }
          s.nextTokenWithinRule = this.nextTokens(s, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
          s.nextTokenWithinRule.setReadonly(true);
          return s.nextTokenWithinRule;
        }
      }
      addState(state) {
        state.atn = this;
        state.stateNumber = this.states.length;
        this.states.push(state);
      }
      removeState(state) {
        let invalidState = new InvalidState_1.InvalidState();
        invalidState.atn = this;
        invalidState.stateNumber = state.stateNumber;
        this.states[state.stateNumber] = invalidState;
      }
      defineMode(name, s) {
        this.modeNameToStartState.set(name, s);
        this.modeToStartState.push(s);
        this.modeToDFA.push(new DFA_1.DFA(s));
        this.defineDecisionState(s);
      }
      defineDecisionState(s) {
        this.decisionToState.push(s);
        s.decision = this.decisionToState.length - 1;
        this.decisionToDFA.push(new DFA_1.DFA(s, s.decision));
        return s.decision;
      }
      getDecisionState(decision) {
        if (this.decisionToState.length > 0) {
          return this.decisionToState[decision];
        }
        return void 0;
      }
      get numberOfDecisions() {
        return this.decisionToState.length;
      }
      getExpectedTokens(stateNumber, context) {
        if (stateNumber < 0 || stateNumber >= this.states.length) {
          throw new RangeError("Invalid state number.");
        }
        let ctx = context;
        let s = this.states[stateNumber];
        let following = this.nextTokens(s);
        if (!following.contains(Token_1.Token.EPSILON)) {
          return following;
        }
        let expected = new IntervalSet_1.IntervalSet();
        expected.addAll(following);
        expected.remove(Token_1.Token.EPSILON);
        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
          let invokingState = this.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          following = this.nextTokens(rt.followState);
          expected.addAll(following);
          expected.remove(Token_1.Token.EPSILON);
          ctx = ctx._parent;
        }
        if (following.contains(Token_1.Token.EPSILON)) {
          expected.add(Token_1.Token.EOF);
        }
        return expected;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "states", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "decisionToState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "modeNameToStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "modeToStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "decisionToDFA", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "modeToDFA", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "nextTokens", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN2.prototype, "removeState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ATN2.prototype, "defineMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN2.prototype, "defineDecisionState", null);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "getExpectedTokens", null);
    ATN2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN2);
    exports.ATN = ATN2;
    (function(ATN3) {
      ATN3.INVALID_ALT_NUMBER = 0;
    })(ATN2 = exports.ATN || (exports.ATN = {}));
    exports.ATN = ATN2;
  }
});

// node_modules/antlr4ts/atn/LexerIndexedCustomAction.js
var require_LexerIndexedCustomAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerIndexedCustomAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerIndexedCustomAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerIndexedCustomAction = class LexerIndexedCustomAction2 {
      constructor(offset, action) {
        this._offset = offset;
        this._action = action;
      }
      get offset() {
        return this._offset;
      }
      get action() {
        return this._action;
      }
      get actionType() {
        return this._action.actionType;
      }
      get isPositionDependent() {
        return true;
      }
      execute(lexer) {
        this._action.execute(lexer);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this._offset);
        hash = MurmurHash_1.MurmurHash.update(hash, this._action);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerIndexedCustomAction2)) {
          return false;
        }
        return this._offset === obj._offset && this._action.equals(obj._action);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerIndexedCustomAction.prototype, "action", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "equals", null);
    LexerIndexedCustomAction = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerIndexedCustomAction);
    exports.LexerIndexedCustomAction = LexerIndexedCustomAction;
  }
});

// node_modules/antlr4ts/atn/LexerActionExecutor.js
var require_LexerActionExecutor = __commonJS({
  "node_modules/antlr4ts/atn/LexerActionExecutor.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerActionExecutor = void 0;
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var LexerIndexedCustomAction_1 = require_LexerIndexedCustomAction();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerActionExecutor = class LexerActionExecutor2 {
      constructor(lexerActions) {
        this._lexerActions = lexerActions;
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let lexerAction of lexerActions) {
          hash = MurmurHash_1.MurmurHash.update(hash, lexerAction);
        }
        this.cachedHashCode = MurmurHash_1.MurmurHash.finish(hash, lexerActions.length);
      }
      static append(lexerActionExecutor, lexerAction) {
        if (!lexerActionExecutor) {
          return new LexerActionExecutor2([lexerAction]);
        }
        let lexerActions = lexerActionExecutor._lexerActions.slice(0);
        lexerActions.push(lexerAction);
        return new LexerActionExecutor2(lexerActions);
      }
      fixOffsetBeforeMatch(offset) {
        let updatedLexerActions;
        for (let i = 0; i < this._lexerActions.length; i++) {
          if (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction)) {
            if (!updatedLexerActions) {
              updatedLexerActions = this._lexerActions.slice(0);
            }
            updatedLexerActions[i] = new LexerIndexedCustomAction_1.LexerIndexedCustomAction(offset, this._lexerActions[i]);
          }
        }
        if (!updatedLexerActions) {
          return this;
        }
        return new LexerActionExecutor2(updatedLexerActions);
      }
      get lexerActions() {
        return this._lexerActions;
      }
      execute(lexer, input, startIndex) {
        let requiresSeek = false;
        let stopIndex = input.index;
        try {
          for (let lexerAction of this._lexerActions) {
            if (lexerAction instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction) {
              let offset = lexerAction.offset;
              input.seek(startIndex + offset);
              lexerAction = lexerAction.action;
              requiresSeek = startIndex + offset !== stopIndex;
            } else if (lexerAction.isPositionDependent) {
              input.seek(stopIndex);
              requiresSeek = false;
            }
            lexerAction.execute(lexer);
          }
        } finally {
          if (requiresSeek) {
            input.seek(stopIndex);
          }
        }
      }
      hashCode() {
        return this.cachedHashCode;
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerActionExecutor2)) {
          return false;
        }
        return this.cachedHashCode === obj.cachedHashCode && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerActionExecutor.prototype, "_lexerActions", void 0);
    __decorate([
      Decorators_1.NotNull
    ], LexerActionExecutor.prototype, "lexerActions", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerActionExecutor.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerActionExecutor.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerActionExecutor.prototype, "equals", null);
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], LexerActionExecutor, "append", null);
    LexerActionExecutor = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerActionExecutor);
    exports.LexerActionExecutor = LexerActionExecutor;
  }
});

// node_modules/antlr4ts/LexerNoViableAltException.js
var require_LexerNoViableAltException = __commonJS({
  "node_modules/antlr4ts/LexerNoViableAltException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerNoViableAltException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var Interval_1 = require_Interval();
    var Utils3 = require_Utils();
    var LexerNoViableAltException = class LexerNoViableAltException extends RecognitionException_1.RecognitionException {
      constructor(lexer, input, startIndex, deadEndConfigs) {
        super(lexer, input);
        this._startIndex = startIndex;
        this._deadEndConfigs = deadEndConfigs;
      }
      get startIndex() {
        return this._startIndex;
      }
      get deadEndConfigs() {
        return this._deadEndConfigs;
      }
      get inputStream() {
        return super.inputStream;
      }
      toString() {
        let symbol = "";
        if (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {
          symbol = this.inputStream.getText(Interval_1.Interval.of(this._startIndex, this._startIndex));
          symbol = Utils3.escapeWhitespace(symbol, false);
        }
        return `LexerNoViableAltException('${symbol}')`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerNoViableAltException.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], LexerNoViableAltException.prototype, "toString", null);
    LexerNoViableAltException = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerNoViableAltException);
    exports.LexerNoViableAltException = LexerNoViableAltException;
  }
});

// node_modules/antlr4ts/atn/OrderedATNConfigSet.js
var require_OrderedATNConfigSet = __commonJS({
  "node_modules/antlr4ts/atn/OrderedATNConfigSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OrderedATNConfigSet = void 0;
    var ATNConfigSet_1 = require_ATNConfigSet();
    var Decorators_1 = require_Decorators();
    var OrderedATNConfigSet = class extends ATNConfigSet_1.ATNConfigSet {
      constructor(set, readonly) {
        if (set != null && readonly != null) {
          super(set, readonly);
        } else {
          super();
        }
      }
      clone(readonly) {
        let copy = new OrderedATNConfigSet(this, readonly);
        if (!readonly && this.isReadOnly) {
          copy.addAll(this);
        }
        return copy;
      }
      getKey(e) {
        return { state: 0, alt: e.hashCode() };
      }
      canMerge(left, leftKey, right) {
        return left.equals(right);
      }
    };
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "clone", null);
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "getKey", null);
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "canMerge", null);
    exports.OrderedATNConfigSet = OrderedATNConfigSet;
  }
});

// node_modules/antlr4ts/atn/LexerATNSimulator.js
var require_LexerATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/LexerATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerATNSimulator = void 0;
    var AcceptStateInfo_1 = require_AcceptStateInfo();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var ATNSimulator_1 = require_ATNSimulator();
    var DFAState_1 = require_DFAState();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var Lexer_1 = require_Lexer();
    var LexerActionExecutor_1 = require_LexerActionExecutor();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var Decorators_1 = require_Decorators();
    var OrderedATNConfigSet_1 = require_OrderedATNConfigSet();
    var PredictionContext_1 = require_PredictionContext();
    var RuleStopState_1 = require_RuleStopState();
    var Token_1 = require_Token();
    var assert = require("assert");
    var LexerATNSimulator2 = class LexerATNSimulator3 extends ATNSimulator_1.ATNSimulator {
      constructor(atn, recog) {
        super(atn);
        this.optimize_tail_calls = true;
        this.startIndex = -1;
        this._line = 1;
        this._charPositionInLine = 0;
        this.mode = Lexer_1.Lexer.DEFAULT_MODE;
        this.prevAccept = new LexerATNSimulator3.SimState();
        this.recog = recog;
      }
      copyState(simulator) {
        this._charPositionInLine = simulator.charPositionInLine;
        this._line = simulator._line;
        this.mode = simulator.mode;
        this.startIndex = simulator.startIndex;
      }
      match(input, mode) {
        this.mode = mode;
        let mark = input.mark();
        try {
          this.startIndex = input.index;
          this.prevAccept.reset();
          let s0 = this.atn.modeToDFA[mode].s0;
          if (s0 == null) {
            return this.matchATN(input);
          } else {
            return this.execATN(input, s0);
          }
        } finally {
          input.release(mark);
        }
      }
      reset() {
        this.prevAccept.reset();
        this.startIndex = -1;
        this._line = 1;
        this._charPositionInLine = 0;
        this.mode = Lexer_1.Lexer.DEFAULT_MODE;
      }
      matchATN(input) {
        let startState = this.atn.modeToStartState[this.mode];
        if (LexerATNSimulator3.debug) {
          console.log(`matchATN mode ${this.mode} start: ${startState}`);
        }
        let old_mode = this.mode;
        let s0_closure = this.computeStartState(input, startState);
        let suppressEdge = s0_closure.hasSemanticContext;
        if (suppressEdge) {
          s0_closure.hasSemanticContext = false;
        }
        let next = this.addDFAState(s0_closure);
        if (!suppressEdge) {
          let dfa = this.atn.modeToDFA[this.mode];
          if (!dfa.s0) {
            dfa.s0 = next;
          } else {
            next = dfa.s0;
          }
        }
        let predict = this.execATN(input, next);
        if (LexerATNSimulator3.debug) {
          console.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);
        }
        return predict;
      }
      execATN(input, ds0) {
        if (LexerATNSimulator3.debug) {
          console.log(`start state closure=${ds0.configs}`);
        }
        if (ds0.isAcceptState) {
          this.captureSimState(this.prevAccept, input, ds0);
        }
        let t = input.LA(1);
        let s = ds0;
        while (true) {
          if (LexerATNSimulator3.debug) {
            console.log(`execATN loop starting closure: ${s.configs}`);
          }
          let target = this.getExistingTargetState(s, t);
          if (target == null) {
            target = this.computeTargetState(input, s, t);
          }
          if (target === ATNSimulator_1.ATNSimulator.ERROR) {
            break;
          }
          if (t !== IntStream_1.IntStream.EOF) {
            this.consume(input);
          }
          if (target.isAcceptState) {
            this.captureSimState(this.prevAccept, input, target);
            if (t === IntStream_1.IntStream.EOF) {
              break;
            }
          }
          t = input.LA(1);
          s = target;
        }
        return this.failOrAccept(this.prevAccept, input, s.configs, t);
      }
      getExistingTargetState(s, t) {
        let target = s.getTarget(t);
        if (LexerATNSimulator3.debug && target != null) {
          console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
        }
        return target;
      }
      computeTargetState(input, s, t) {
        let reach = new OrderedATNConfigSet_1.OrderedATNConfigSet();
        this.getReachableConfigSet(input, s.configs, reach, t);
        if (reach.isEmpty) {
          if (!reach.hasSemanticContext) {
            this.addDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
          }
          return ATNSimulator_1.ATNSimulator.ERROR;
        }
        return this.addDFAEdge(s, t, reach);
      }
      failOrAccept(prevAccept, input, reach, t) {
        if (prevAccept.dfaState != null) {
          let lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
          this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.charPos);
          return prevAccept.dfaState.prediction;
        } else {
          if (t === IntStream_1.IntStream.EOF && input.index === this.startIndex) {
            return Token_1.Token.EOF;
          }
          throw new LexerNoViableAltException_1.LexerNoViableAltException(this.recog, input, this.startIndex, reach);
        }
      }
      getReachableConfigSet(input, closure, reach, t) {
        let skipAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        for (let c of closure) {
          let currentAltReachedAcceptState = c.alt === skipAlt;
          if (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {
            continue;
          }
          if (LexerATNSimulator3.debug) {
            console.log(`testing ${this.getTokenName(t)} at ${c.toString(this.recog, true)}`);
          }
          let n = c.state.numberOfOptimizedTransitions;
          for (let ti = 0; ti < n; ti++) {
            let trans = c.state.getOptimizedTransition(ti);
            let target = this.getReachableTarget(trans, t);
            if (target != null) {
              let lexerActionExecutor = c.lexerActionExecutor;
              let config;
              if (lexerActionExecutor != null) {
                lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
                config = c.transform(target, true, lexerActionExecutor);
              } else {
                assert(c.lexerActionExecutor == null);
                config = c.transform(target, true);
              }
              let treatEofAsEpsilon = t === IntStream_1.IntStream.EOF;
              if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
                skipAlt = c.alt;
                break;
              }
            }
          }
        }
      }
      accept(input, lexerActionExecutor, startIndex, index2, line, charPos) {
        if (LexerATNSimulator3.debug) {
          console.log(`ACTION ${lexerActionExecutor}`);
        }
        input.seek(index2);
        this._line = line;
        this._charPositionInLine = charPos;
        if (lexerActionExecutor != null && this.recog != null) {
          lexerActionExecutor.execute(this.recog, input, startIndex);
        }
      }
      getReachableTarget(trans, t) {
        if (trans.matches(t, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
          return trans.target;
        }
        return void 0;
      }
      computeStartState(input, p) {
        let initialContext = PredictionContext_1.PredictionContext.EMPTY_FULL;
        let configs = new OrderedATNConfigSet_1.OrderedATNConfigSet();
        for (let i = 0; i < p.numberOfTransitions; i++) {
          let target = p.transition(i).target;
          let c = ATNConfig_1.ATNConfig.create(target, i + 1, initialContext);
          this.closure(input, c, configs, false, false, false);
        }
        return configs;
      }
      closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
        if (LexerATNSimulator3.debug) {
          console.log("closure(" + config.toString(this.recog, true) + ")");
        }
        if (config.state instanceof RuleStopState_1.RuleStopState) {
          if (LexerATNSimulator3.debug) {
            if (this.recog != null) {
              console.log(`closure at ${this.recog.ruleNames[config.state.ruleIndex]} rule stop ${config}`);
            } else {
              console.log(`closure at rule stop ${config}`);
            }
          }
          let context = config.context;
          if (context.isEmpty) {
            configs.add(config);
            return true;
          } else if (context.hasEmpty) {
            configs.add(config.transform(config.state, true, PredictionContext_1.PredictionContext.EMPTY_FULL));
            currentAltReachedAcceptState = true;
          }
          for (let i = 0; i < context.size; i++) {
            let returnStateNumber = context.getReturnState(i);
            if (returnStateNumber === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              continue;
            }
            let newContext = context.getParent(i);
            let returnState = this.atn.states[returnStateNumber];
            let c = config.transform(returnState, false, newContext);
            currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
          }
          return currentAltReachedAcceptState;
        }
        if (!config.state.onlyHasEpsilonTransitions) {
          if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision) {
            configs.add(config);
          }
        }
        let p = config.state;
        for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
          let t = p.getOptimizedTransition(i);
          let c = this.getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon);
          if (c != null) {
            currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
          }
        }
        return currentAltReachedAcceptState;
      }
      getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon) {
        let c;
        switch (t.serializationType) {
          case 3:
            let ruleTransition = t;
            if (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config.context.hasEmpty) {
              c = config.transform(t.target, true);
            } else {
              let newContext = config.context.getChild(ruleTransition.followState.stateNumber);
              c = config.transform(t.target, true, newContext);
            }
            break;
          case 10:
            throw new Error("Precedence predicates are not supported in lexers.");
          case 4:
            let pt = t;
            if (LexerATNSimulator3.debug) {
              console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
            }
            configs.hasSemanticContext = true;
            if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
              c = config.transform(t.target, true);
            } else {
              c = void 0;
            }
            break;
          case 6:
            if (config.context.hasEmpty) {
              let lexerActionExecutor = LexerActionExecutor_1.LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[t.actionIndex]);
              c = config.transform(t.target, true, lexerActionExecutor);
              break;
            } else {
              c = config.transform(t.target, true);
              break;
            }
          case 1:
            c = config.transform(t.target, true);
            break;
          case 5:
          case 2:
          case 7:
            if (treatEofAsEpsilon) {
              if (t.matches(IntStream_1.IntStream.EOF, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
                c = config.transform(t.target, false);
                break;
              }
            }
            c = void 0;
            break;
          default:
            c = void 0;
            break;
        }
        return c;
      }
      evaluatePredicate(input, ruleIndex, predIndex, speculative) {
        if (this.recog == null) {
          return true;
        }
        if (!speculative) {
          return this.recog.sempred(void 0, ruleIndex, predIndex);
        }
        let savedCharPositionInLine = this._charPositionInLine;
        let savedLine = this._line;
        let index2 = input.index;
        let marker = input.mark();
        try {
          this.consume(input);
          return this.recog.sempred(void 0, ruleIndex, predIndex);
        } finally {
          this._charPositionInLine = savedCharPositionInLine;
          this._line = savedLine;
          input.seek(index2);
          input.release(marker);
        }
      }
      captureSimState(settings, input, dfaState) {
        settings.index = input.index;
        settings.line = this._line;
        settings.charPos = this._charPositionInLine;
        settings.dfaState = dfaState;
      }
      addDFAEdge(p, t, q) {
        if (q instanceof ATNConfigSet_1.ATNConfigSet) {
          let suppressEdge = q.hasSemanticContext;
          if (suppressEdge) {
            q.hasSemanticContext = false;
          }
          let to = this.addDFAState(q);
          if (suppressEdge) {
            return to;
          }
          this.addDFAEdge(p, t, to);
          return to;
        } else {
          if (LexerATNSimulator3.debug) {
            console.log("EDGE " + p + " -> " + q + " upon " + String.fromCharCode(t));
          }
          if (p != null) {
            p.setTarget(t, q);
          }
        }
      }
      addDFAState(configs) {
        assert(!configs.hasSemanticContext);
        let proposed = new DFAState_1.DFAState(configs);
        let existing = this.atn.modeToDFA[this.mode].states.get(proposed);
        if (existing != null) {
          return existing;
        }
        configs.optimizeConfigs(this);
        let newState = new DFAState_1.DFAState(configs.clone(true));
        let firstConfigWithRuleStopState;
        for (let c of configs) {
          if (c.state instanceof RuleStopState_1.RuleStopState) {
            firstConfigWithRuleStopState = c;
            break;
          }
        }
        if (firstConfigWithRuleStopState != null) {
          let prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
          let lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(prediction, lexerActionExecutor);
        }
        return this.atn.modeToDFA[this.mode].addState(newState);
      }
      getDFA(mode) {
        return this.atn.modeToDFA[mode];
      }
      getText(input) {
        return input.getText(Interval_1.Interval.of(this.startIndex, input.index - 1));
      }
      get line() {
        return this._line;
      }
      set line(line) {
        this._line = line;
      }
      get charPositionInLine() {
        return this._charPositionInLine;
      }
      set charPositionInLine(charPositionInLine) {
        this._charPositionInLine = charPositionInLine;
      }
      consume(input) {
        let curChar = input.LA(1);
        if (curChar === "\n".charCodeAt(0)) {
          this._line++;
          this._charPositionInLine = 0;
        } else {
          this._charPositionInLine++;
        }
        input.consume();
      }
      getTokenName(t) {
        if (t === -1) {
          return "EOF";
        }
        return "'" + String.fromCharCode(t) + "'";
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator2.prototype, "prevAccept", void 0);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "copyState", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "match", null);
    __decorate([
      Decorators_1.Override
    ], LexerATNSimulator2.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "matchATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "execATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "computeTargetState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getReachableConfigSet", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "accept", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "computeStartState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "closure", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getEpsilonTarget", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "evaluatePredicate", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "captureSimState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "addDFAState", null);
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator2.prototype, "getDFA", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getText", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "consume", null);
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator2.prototype, "getTokenName", null);
    LexerATNSimulator2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2);
    exports.LexerATNSimulator = LexerATNSimulator2;
    (function(LexerATNSimulator3) {
      LexerATNSimulator3.debug = false;
      LexerATNSimulator3.dfa_debug = false;
      class SimState {
        constructor() {
          this.index = -1;
          this.line = 0;
          this.charPos = -1;
        }
        reset() {
          this.index = -1;
          this.line = 0;
          this.charPos = -1;
          this.dfaState = void 0;
        }
      }
      LexerATNSimulator3.SimState = SimState;
    })(LexerATNSimulator2 = exports.LexerATNSimulator || (exports.LexerATNSimulator = {}));
    exports.LexerATNSimulator = LexerATNSimulator2;
  }
});

// node_modules/antlr4ts/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/antlr4ts/Lexer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lexer = void 0;
    var CommonTokenFactory_1 = require_CommonTokenFactory();
    var IntegerStack_1 = require_IntegerStack();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var Decorators_1 = require_Decorators();
    var Recognizer_1 = require_Recognizer();
    var Token_1 = require_Token();
    var Lexer2 = class extends Recognizer_1.Recognizer {
      constructor(input) {
        super();
        this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
        this._tokenStartCharIndex = -1;
        this._tokenStartLine = 0;
        this._tokenStartCharPositionInLine = 0;
        this._hitEOF = false;
        this._channel = 0;
        this._type = 0;
        this._modeStack = new IntegerStack_1.IntegerStack();
        this._mode = Lexer2.DEFAULT_MODE;
        this._input = input;
        this._tokenFactorySourcePair = { source: this, stream: input };
      }
      static get DEFAULT_TOKEN_CHANNEL() {
        return Token_1.Token.DEFAULT_CHANNEL;
      }
      static get HIDDEN() {
        return Token_1.Token.HIDDEN_CHANNEL;
      }
      reset(resetInput) {
        if (resetInput === void 0 || resetInput) {
          this._input.seek(0);
        }
        this._token = void 0;
        this._type = Token_1.Token.INVALID_TYPE;
        this._channel = Token_1.Token.DEFAULT_CHANNEL;
        this._tokenStartCharIndex = -1;
        this._tokenStartCharPositionInLine = -1;
        this._tokenStartLine = -1;
        this._text = void 0;
        this._hitEOF = false;
        this._mode = Lexer2.DEFAULT_MODE;
        this._modeStack.clear();
        this.interpreter.reset();
      }
      nextToken() {
        if (this._input == null) {
          throw new Error("nextToken requires a non-null input stream.");
        }
        let tokenStartMarker = this._input.mark();
        try {
          outer:
            while (true) {
              if (this._hitEOF) {
                return this.emitEOF();
              }
              this._token = void 0;
              this._channel = Token_1.Token.DEFAULT_CHANNEL;
              this._tokenStartCharIndex = this._input.index;
              this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;
              this._tokenStartLine = this.interpreter.line;
              this._text = void 0;
              do {
                this._type = Token_1.Token.INVALID_TYPE;
                let ttype;
                try {
                  ttype = this.interpreter.match(this._input, this._mode);
                } catch (e) {
                  if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
                    this.notifyListeners(e);
                    this.recover(e);
                    ttype = Lexer2.SKIP;
                  } else {
                    throw e;
                  }
                }
                if (this._input.LA(1) === IntStream_1.IntStream.EOF) {
                  this._hitEOF = true;
                }
                if (this._type === Token_1.Token.INVALID_TYPE) {
                  this._type = ttype;
                }
                if (this._type === Lexer2.SKIP) {
                  continue outer;
                }
              } while (this._type === Lexer2.MORE);
              if (this._token == null) {
                return this.emit();
              }
              return this._token;
            }
        } finally {
          this._input.release(tokenStartMarker);
        }
      }
      skip() {
        this._type = Lexer2.SKIP;
      }
      more() {
        this._type = Lexer2.MORE;
      }
      mode(m) {
        this._mode = m;
      }
      pushMode(m) {
        if (LexerATNSimulator_1.LexerATNSimulator.debug) {
          console.log("pushMode " + m);
        }
        this._modeStack.push(this._mode);
        this.mode(m);
      }
      popMode() {
        if (this._modeStack.isEmpty) {
          throw new Error("EmptyStackException");
        }
        if (LexerATNSimulator_1.LexerATNSimulator.debug) {
          console.log("popMode back to " + this._modeStack.peek());
        }
        this.mode(this._modeStack.pop());
        return this._mode;
      }
      get tokenFactory() {
        return this._factory;
      }
      set tokenFactory(factory) {
        this._factory = factory;
      }
      get inputStream() {
        return this._input;
      }
      set inputStream(input) {
        this.reset(false);
        this._input = input;
        this._tokenFactorySourcePair = { source: this, stream: this._input };
      }
      get sourceName() {
        return this._input.sourceName;
      }
      emit(token) {
        if (!token) {
          token = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine);
        }
        this._token = token;
        return token;
      }
      emitEOF() {
        let cpos = this.charPositionInLine;
        let line = this.line;
        let eof = this._factory.create(this._tokenFactorySourcePair, Token_1.Token.EOF, void 0, Token_1.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, line, cpos);
        this.emit(eof);
        return eof;
      }
      get line() {
        return this.interpreter.line;
      }
      set line(line) {
        this.interpreter.line = line;
      }
      get charPositionInLine() {
        return this.interpreter.charPositionInLine;
      }
      set charPositionInLine(charPositionInLine) {
        this.interpreter.charPositionInLine = charPositionInLine;
      }
      get charIndex() {
        return this._input.index;
      }
      get text() {
        if (this._text != null) {
          return this._text;
        }
        return this.interpreter.getText(this._input);
      }
      set text(text4) {
        this._text = text4;
      }
      get token() {
        return this._token;
      }
      set token(_token) {
        this._token = _token;
      }
      set type(ttype) {
        this._type = ttype;
      }
      get type() {
        return this._type;
      }
      set channel(channel) {
        this._channel = channel;
      }
      get channel() {
        return this._channel;
      }
      getAllTokens() {
        let tokens = [];
        let t = this.nextToken();
        while (t.type !== Token_1.Token.EOF) {
          tokens.push(t);
          t = this.nextToken();
        }
        return tokens;
      }
      notifyListeners(e) {
        let text4 = this._input.getText(Interval_1.Interval.of(this._tokenStartCharIndex, this._input.index));
        let msg = "token recognition error at: '" + this.getErrorDisplay(text4) + "'";
        let listener = this.getErrorListenerDispatch();
        if (listener.syntaxError) {
          listener.syntaxError(this, void 0, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);
        }
      }
      getErrorDisplay(s) {
        if (typeof s === "number") {
          switch (s) {
            case Token_1.Token.EOF:
              return "<EOF>";
            case 10:
              return "\\n";
            case 9:
              return "\\t";
            case 13:
              return "\\r";
          }
          return String.fromCharCode(s);
        }
        return s.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
      }
      getCharErrorDisplay(c) {
        let s = this.getErrorDisplay(c);
        return "'" + s + "'";
      }
      recover(re) {
        if (re instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
          if (this._input.LA(1) !== IntStream_1.IntStream.EOF) {
            this.interpreter.consume(this._input);
          }
        } else {
          this._input.consume();
        }
      }
    };
    Lexer2.DEFAULT_MODE = 0;
    Lexer2.MORE = -2;
    Lexer2.SKIP = -3;
    Lexer2.MIN_CHAR_VALUE = 0;
    Lexer2.MAX_CHAR_VALUE = 1114111;
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "nextToken", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "tokenFactory", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "charPositionInLine", null);
    exports.Lexer = Lexer2;
  }
});

// node_modules/antlr4ts/misc/IntervalSet.js
var require_IntervalSet = __commonJS({
  "node_modules/antlr4ts/misc/IntervalSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntervalSet = void 0;
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var IntegerList_1 = require_IntegerList();
    var Interval_1 = require_Interval();
    var Lexer_1 = require_Lexer();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var IntervalSet = class {
      constructor(intervals) {
        this.readonly = false;
        if (intervals != null) {
          this._intervals = intervals.slice(0);
        } else {
          this._intervals = [];
        }
      }
      static get COMPLETE_CHAR_SET() {
        if (IntervalSet._COMPLETE_CHAR_SET === void 0) {
          IntervalSet._COMPLETE_CHAR_SET = IntervalSet.of(Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE);
          IntervalSet._COMPLETE_CHAR_SET.setReadonly(true);
        }
        return IntervalSet._COMPLETE_CHAR_SET;
      }
      static get EMPTY_SET() {
        if (IntervalSet._EMPTY_SET == null) {
          IntervalSet._EMPTY_SET = new IntervalSet();
          IntervalSet._EMPTY_SET.setReadonly(true);
        }
        return IntervalSet._EMPTY_SET;
      }
      static of(a, b = a) {
        let s = new IntervalSet();
        s.add(a, b);
        return s;
      }
      clear() {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        this._intervals.length = 0;
      }
      add(a, b = a) {
        this.addRange(Interval_1.Interval.of(a, b));
      }
      addRange(addition) {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        if (addition.b < addition.a) {
          return;
        }
        for (let i = 0; i < this._intervals.length; i++) {
          let r = this._intervals[i];
          if (addition.equals(r)) {
            return;
          }
          if (addition.adjacent(r) || !addition.disjoint(r)) {
            let bigger = addition.union(r);
            this._intervals[i] = bigger;
            while (i < this._intervals.length - 1) {
              i++;
              let next = this._intervals[i];
              if (!bigger.adjacent(next) && bigger.disjoint(next)) {
                break;
              }
              this._intervals.splice(i, 1);
              i--;
              this._intervals[i] = bigger.union(next);
            }
            return;
          }
          if (addition.startsBeforeDisjoint(r)) {
            this._intervals.splice(i, 0, addition);
            return;
          }
        }
        this._intervals.push(addition);
      }
      static or(sets) {
        let r = new IntervalSet();
        for (let s of sets) {
          r.addAll(s);
        }
        return r;
      }
      addAll(set) {
        if (set == null) {
          return this;
        }
        if (set instanceof IntervalSet) {
          let other = set;
          let n = other._intervals.length;
          for (let i = 0; i < n; i++) {
            let I = other._intervals[i];
            this.add(I.a, I.b);
          }
        } else {
          for (let value2 of set.toArray()) {
            this.add(value2);
          }
        }
        return this;
      }
      complementRange(minElement, maxElement) {
        return this.complement(IntervalSet.of(minElement, maxElement));
      }
      complement(vocabulary) {
        if (vocabulary.isNil) {
          return IntervalSet.EMPTY_SET;
        }
        let vocabularyIS;
        if (vocabulary instanceof IntervalSet) {
          vocabularyIS = vocabulary;
        } else {
          vocabularyIS = new IntervalSet();
          vocabularyIS.addAll(vocabulary);
        }
        return vocabularyIS.subtract(this);
      }
      subtract(a) {
        if (a == null || a.isNil) {
          return new IntervalSet(this._intervals);
        }
        if (a instanceof IntervalSet) {
          return IntervalSet.subtract(this, a);
        }
        let other = new IntervalSet();
        other.addAll(a);
        return IntervalSet.subtract(this, other);
      }
      static subtract(left, right) {
        if (left.isNil) {
          return new IntervalSet();
        }
        let result = new IntervalSet(left._intervals);
        if (right.isNil) {
          return result;
        }
        let resultI = 0;
        let rightI = 0;
        while (resultI < result._intervals.length && rightI < right._intervals.length) {
          let resultInterval = result._intervals[resultI];
          let rightInterval = right._intervals[rightI];
          if (rightInterval.b < resultInterval.a) {
            rightI++;
            continue;
          }
          if (rightInterval.a > resultInterval.b) {
            resultI++;
            continue;
          }
          let beforeCurrent;
          let afterCurrent;
          if (rightInterval.a > resultInterval.a) {
            beforeCurrent = new Interval_1.Interval(resultInterval.a, rightInterval.a - 1);
          }
          if (rightInterval.b < resultInterval.b) {
            afterCurrent = new Interval_1.Interval(rightInterval.b + 1, resultInterval.b);
          }
          if (beforeCurrent) {
            if (afterCurrent) {
              result._intervals[resultI] = beforeCurrent;
              result._intervals.splice(resultI + 1, 0, afterCurrent);
              resultI++;
              rightI++;
              continue;
            } else {
              result._intervals[resultI] = beforeCurrent;
              resultI++;
              continue;
            }
          } else {
            if (afterCurrent) {
              result._intervals[resultI] = afterCurrent;
              rightI++;
              continue;
            } else {
              result._intervals.splice(resultI, 1);
              continue;
            }
          }
        }
        return result;
      }
      or(a) {
        let o = new IntervalSet();
        o.addAll(this);
        o.addAll(a);
        return o;
      }
      and(other) {
        if (other.isNil) {
          return new IntervalSet();
        }
        let myIntervals = this._intervals;
        let theirIntervals = other._intervals;
        let intersection;
        let mySize = myIntervals.length;
        let theirSize = theirIntervals.length;
        let i = 0;
        let j = 0;
        while (i < mySize && j < theirSize) {
          let mine = myIntervals[i];
          let theirs = theirIntervals[j];
          if (mine.startsBeforeDisjoint(theirs)) {
            i++;
          } else if (theirs.startsBeforeDisjoint(mine)) {
            j++;
          } else if (mine.properlyContains(theirs)) {
            if (!intersection) {
              intersection = new IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            j++;
          } else if (theirs.properlyContains(mine)) {
            if (!intersection) {
              intersection = new IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            i++;
          } else if (!mine.disjoint(theirs)) {
            if (!intersection) {
              intersection = new IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            if (mine.startsAfterNonDisjoint(theirs)) {
              j++;
            } else if (theirs.startsAfterNonDisjoint(mine)) {
              i++;
            }
          }
        }
        if (!intersection) {
          return new IntervalSet();
        }
        return intersection;
      }
      contains(el) {
        let n = this._intervals.length;
        let l = 0;
        let r = n - 1;
        while (l <= r) {
          let m = l + r >> 1;
          let I = this._intervals[m];
          let a = I.a;
          let b = I.b;
          if (b < el) {
            l = m + 1;
          } else if (a > el) {
            r = m - 1;
          } else {
            return true;
          }
        }
        return false;
      }
      get isNil() {
        return this._intervals == null || this._intervals.length === 0;
      }
      get maxElement() {
        if (this.isNil) {
          throw new RangeError("set is empty");
        }
        let last = this._intervals[this._intervals.length - 1];
        return last.b;
      }
      get minElement() {
        if (this.isNil) {
          throw new RangeError("set is empty");
        }
        return this._intervals[0].a;
      }
      get intervals() {
        return this._intervals;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let I of this._intervals) {
          hash = MurmurHash_1.MurmurHash.update(hash, I.a);
          hash = MurmurHash_1.MurmurHash.update(hash, I.b);
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, this._intervals.length * 2);
        return hash;
      }
      equals(o) {
        if (o == null || !(o instanceof IntervalSet)) {
          return false;
        }
        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);
      }
      toString(elemAreChar = false) {
        let buf = "";
        if (this._intervals == null || this._intervals.length === 0) {
          return "{}";
        }
        if (this.size > 1) {
          buf += "{";
        }
        let first = true;
        for (let I of this._intervals) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          let a = I.a;
          let b = I.b;
          if (a === b) {
            if (a === Token_1.Token.EOF) {
              buf += "<EOF>";
            } else if (elemAreChar) {
              buf += "'" + String.fromCodePoint(a) + "'";
            } else {
              buf += a;
            }
          } else {
            if (elemAreChar) {
              buf += "'" + String.fromCodePoint(a) + "'..'" + String.fromCodePoint(b) + "'";
            } else {
              buf += a + ".." + b;
            }
          }
        }
        if (this.size > 1) {
          buf += "}";
        }
        return buf;
      }
      toStringVocabulary(vocabulary) {
        if (this._intervals == null || this._intervals.length === 0) {
          return "{}";
        }
        let buf = "";
        if (this.size > 1) {
          buf += "{";
        }
        let first = true;
        for (let I of this._intervals) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          let a = I.a;
          let b = I.b;
          if (a === b) {
            buf += this.elementName(vocabulary, a);
          } else {
            for (let i = a; i <= b; i++) {
              if (i > a) {
                buf += ", ";
              }
              buf += this.elementName(vocabulary, i);
            }
          }
        }
        if (this.size > 1) {
          buf += "}";
        }
        return buf;
      }
      elementName(vocabulary, a) {
        if (a === Token_1.Token.EOF) {
          return "<EOF>";
        } else if (a === Token_1.Token.EPSILON) {
          return "<EPSILON>";
        } else {
          return vocabulary.getDisplayName(a);
        }
      }
      get size() {
        let n = 0;
        let numIntervals = this._intervals.length;
        if (numIntervals === 1) {
          let firstInterval = this._intervals[0];
          return firstInterval.b - firstInterval.a + 1;
        }
        for (let i = 0; i < numIntervals; i++) {
          let I = this._intervals[i];
          n += I.b - I.a + 1;
        }
        return n;
      }
      toIntegerList() {
        let values = new IntegerList_1.IntegerList(this.size);
        let n = this._intervals.length;
        for (let i = 0; i < n; i++) {
          let I = this._intervals[i];
          let a = I.a;
          let b = I.b;
          for (let v = a; v <= b; v++) {
            values.add(v);
          }
        }
        return values;
      }
      toSet() {
        let s = /* @__PURE__ */ new Set();
        for (let I of this._intervals) {
          let a = I.a;
          let b = I.b;
          for (let v = a; v <= b; v++) {
            s.add(v);
          }
        }
        return s;
      }
      toArray() {
        let values = new Array();
        let n = this._intervals.length;
        for (let i = 0; i < n; i++) {
          let I = this._intervals[i];
          let a = I.a;
          let b = I.b;
          for (let v = a; v <= b; v++) {
            values.push(v);
          }
        }
        return values;
      }
      remove(el) {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        let n = this._intervals.length;
        for (let i = 0; i < n; i++) {
          let I = this._intervals[i];
          let a = I.a;
          let b = I.b;
          if (el < a) {
            break;
          }
          if (el === a && el === b) {
            this._intervals.splice(i, 1);
            break;
          }
          if (el === a) {
            this._intervals[i] = Interval_1.Interval.of(I.a + 1, I.b);
            break;
          }
          if (el === b) {
            this._intervals[i] = Interval_1.Interval.of(I.a, I.b - 1);
            break;
          }
          if (el > a && el < b) {
            let oldb = I.b;
            this._intervals[i] = Interval_1.Interval.of(I.a, el - 1);
            this.add(el + 1, oldb);
          }
        }
      }
      get isReadonly() {
        return this.readonly;
      }
      setReadonly(readonly) {
        if (this.readonly && !readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        this.readonly = readonly;
      }
    };
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "addAll", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "complement", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "subtract", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "or", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "and", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "contains", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "isNil", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "equals", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], IntervalSet.prototype, "toStringVocabulary", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], IntervalSet.prototype, "elementName", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "remove", null);
    __decorate([
      Decorators_1.NotNull
    ], IntervalSet, "of", null);
    __decorate([
      Decorators_1.NotNull
    ], IntervalSet, "subtract", null);
    exports.IntervalSet = IntervalSet;
  }
});

// node_modules/antlr4ts/atn/ATNDeserializationOptions.js
var require_ATNDeserializationOptions = __commonJS({
  "node_modules/antlr4ts/atn/ATNDeserializationOptions.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNDeserializationOptions = void 0;
    var Decorators_1 = require_Decorators();
    var ATNDeserializationOptions = class {
      constructor(options) {
        this.readOnly = false;
        if (options) {
          this.verifyATN = options.verifyATN;
          this.generateRuleBypassTransitions = options.generateRuleBypassTransitions;
          this.optimize = options.optimize;
        } else {
          this.verifyATN = true;
          this.generateRuleBypassTransitions = false;
          this.optimize = true;
        }
      }
      static get defaultOptions() {
        if (ATNDeserializationOptions._defaultOptions == null) {
          ATNDeserializationOptions._defaultOptions = new ATNDeserializationOptions();
          ATNDeserializationOptions._defaultOptions.makeReadOnly();
        }
        return ATNDeserializationOptions._defaultOptions;
      }
      get isReadOnly() {
        return this.readOnly;
      }
      makeReadOnly() {
        this.readOnly = true;
      }
      get isVerifyATN() {
        return this.verifyATN;
      }
      set isVerifyATN(verifyATN) {
        this.throwIfReadOnly();
        this.verifyATN = verifyATN;
      }
      get isGenerateRuleBypassTransitions() {
        return this.generateRuleBypassTransitions;
      }
      set isGenerateRuleBypassTransitions(generateRuleBypassTransitions) {
        this.throwIfReadOnly();
        this.generateRuleBypassTransitions = generateRuleBypassTransitions;
      }
      get isOptimize() {
        return this.optimize;
      }
      set isOptimize(optimize) {
        this.throwIfReadOnly();
        this.optimize = optimize;
      }
      throwIfReadOnly() {
        if (this.isReadOnly) {
          throw new Error("The object is read only.");
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNDeserializationOptions, "defaultOptions", null);
    exports.ATNDeserializationOptions = ATNDeserializationOptions;
  }
});

// node_modules/antlr4ts/atn/ActionTransition.js
var require_ActionTransition = __commonJS({
  "node_modules/antlr4ts/atn/ActionTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var ActionTransition = class ActionTransition extends Transition_1.Transition {
      constructor(target, ruleIndex, actionIndex = -1, isCtxDependent = false) {
        super(target);
        this.ruleIndex = ruleIndex;
        this.actionIndex = actionIndex;
        this.isCtxDependent = isCtxDependent;
      }
      get serializationType() {
        return 6;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      toString() {
        return "action_" + this.ruleIndex + ":" + this.actionIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "toString", null);
    ActionTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ActionTransition);
    exports.ActionTransition = ActionTransition;
  }
});

// node_modules/antlr4ts/atn/AtomTransition.js
var require_AtomTransition = __commonJS({
  "node_modules/antlr4ts/atn/AtomTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AtomTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var AtomTransition = class AtomTransition extends Transition_1.Transition {
      constructor(target, label) {
        super(target);
        this._label = label;
      }
      get serializationType() {
        return 5;
      }
      get label() {
        return IntervalSet_1.IntervalSet.of(this._label);
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this._label === symbol;
      }
      toString() {
        return String(this.label);
      }
    };
    __decorate([
      Decorators_1.Override
    ], AtomTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], AtomTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], AtomTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], AtomTransition.prototype, "toString", null);
    AtomTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], AtomTransition);
    exports.AtomTransition = AtomTransition;
  }
});

// node_modules/antlr4ts/atn/BlockStartState.js
var require_BlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/BlockStartState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockStartState = void 0;
    var DecisionState_1 = require_DecisionState();
    var BlockStartState = class extends DecisionState_1.DecisionState {
    };
    exports.BlockStartState = BlockStartState;
  }
});

// node_modules/antlr4ts/atn/BasicBlockStartState.js
var require_BasicBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/BasicBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var BasicBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BasicBlockStartState.prototype, "stateType", null);
    exports.BasicBlockStartState = BasicBlockStartState;
  }
});

// node_modules/antlr4ts/atn/BlockEndState.js
var require_BlockEndState = __commonJS({
  "node_modules/antlr4ts/atn/BlockEndState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockEndState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var BlockEndState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BLOCK_END;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BlockEndState.prototype, "stateType", null);
    exports.BlockEndState = BlockEndState;
  }
});

// node_modules/antlr4ts/atn/EpsilonTransition.js
var require_EpsilonTransition = __commonJS({
  "node_modules/antlr4ts/atn/EpsilonTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EpsilonTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var EpsilonTransition = class EpsilonTransition extends Transition_1.Transition {
      constructor(target, outermostPrecedenceReturn = -1) {
        super(target);
        this._outermostPrecedenceReturn = outermostPrecedenceReturn;
      }
      get outermostPrecedenceReturn() {
        return this._outermostPrecedenceReturn;
      }
      get serializationType() {
        return 1;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      toString() {
        return "epsilon";
      }
    };
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], EpsilonTransition.prototype, "toString", null);
    EpsilonTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], EpsilonTransition);
    exports.EpsilonTransition = EpsilonTransition;
  }
});

// node_modules/antlr4ts/atn/LexerChannelAction.js
var require_LexerChannelAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerChannelAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerChannelAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerChannelAction = class {
      constructor(channel) {
        this._channel = channel;
      }
      get channel() {
        return this._channel;
      }
      get actionType() {
        return 0;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.channel = this._channel;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._channel);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerChannelAction)) {
          return false;
        }
        return this._channel === obj._channel;
      }
      toString() {
        return `channel(${this._channel})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerChannelAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "toString", null);
    exports.LexerChannelAction = LexerChannelAction;
  }
});

// node_modules/antlr4ts/atn/LexerCustomAction.js
var require_LexerCustomAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerCustomAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerCustomAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerCustomAction = class {
      constructor(ruleIndex, actionIndex) {
        this._ruleIndex = ruleIndex;
        this._actionIndex = actionIndex;
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
      get actionIndex() {
        return this._actionIndex;
      }
      get actionType() {
        return 1;
      }
      get isPositionDependent() {
        return true;
      }
      execute(lexer) {
        lexer.action(void 0, this._ruleIndex, this._actionIndex);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._ruleIndex);
        hash = MurmurHash_1.MurmurHash.update(hash, this._actionIndex);
        return MurmurHash_1.MurmurHash.finish(hash, 3);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerCustomAction)) {
          return false;
        }
        return this._ruleIndex === obj._ruleIndex && this._actionIndex === obj._actionIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerCustomAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "equals", null);
    exports.LexerCustomAction = LexerCustomAction;
  }
});

// node_modules/antlr4ts/atn/LexerModeAction.js
var require_LexerModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerModeAction = class {
      constructor(mode) {
        this._mode = mode;
      }
      get mode() {
        return this._mode;
      }
      get actionType() {
        return 2;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.mode(this._mode);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerModeAction)) {
          return false;
        }
        return this._mode === obj._mode;
      }
      toString() {
        return `mode(${this._mode})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "toString", null);
    exports.LexerModeAction = LexerModeAction;
  }
});

// node_modules/antlr4ts/atn/LexerMoreAction.js
var require_LexerMoreAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerMoreAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerMoreAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerMoreAction = class {
      constructor() {
      }
      get actionType() {
        return 3;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.more();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "more";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerMoreAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "toString", null);
    exports.LexerMoreAction = LexerMoreAction;
    (function(LexerMoreAction2) {
      LexerMoreAction2.INSTANCE = new LexerMoreAction2();
    })(LexerMoreAction = exports.LexerMoreAction || (exports.LexerMoreAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerPopModeAction.js
var require_LexerPopModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerPopModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerPopModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerPopModeAction = class {
      constructor() {
      }
      get actionType() {
        return 4;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.popMode();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "popMode";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerPopModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "toString", null);
    exports.LexerPopModeAction = LexerPopModeAction;
    (function(LexerPopModeAction2) {
      LexerPopModeAction2.INSTANCE = new LexerPopModeAction2();
    })(LexerPopModeAction = exports.LexerPopModeAction || (exports.LexerPopModeAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerPushModeAction.js
var require_LexerPushModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerPushModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerPushModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerPushModeAction = class {
      constructor(mode) {
        this._mode = mode;
      }
      get mode() {
        return this._mode;
      }
      get actionType() {
        return 5;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.pushMode(this._mode);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerPushModeAction)) {
          return false;
        }
        return this._mode === obj._mode;
      }
      toString() {
        return `pushMode(${this._mode})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerPushModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "toString", null);
    exports.LexerPushModeAction = LexerPushModeAction;
  }
});

// node_modules/antlr4ts/atn/LexerSkipAction.js
var require_LexerSkipAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerSkipAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerSkipAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerSkipAction = class {
      constructor() {
      }
      get actionType() {
        return 6;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.skip();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "skip";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerSkipAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "toString", null);
    exports.LexerSkipAction = LexerSkipAction;
    (function(LexerSkipAction2) {
      LexerSkipAction2.INSTANCE = new LexerSkipAction2();
    })(LexerSkipAction = exports.LexerSkipAction || (exports.LexerSkipAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerTypeAction.js
var require_LexerTypeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerTypeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerTypeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerTypeAction = class {
      constructor(type) {
        this._type = type;
      }
      get type() {
        return this._type;
      }
      get actionType() {
        return 7;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.type = this._type;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._type);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerTypeAction)) {
          return false;
        }
        return this._type === obj._type;
      }
      toString() {
        return `type(${this._type})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerTypeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "toString", null);
    exports.LexerTypeAction = LexerTypeAction;
  }
});

// node_modules/antlr4ts/atn/LoopEndState.js
var require_LoopEndState = __commonJS({
  "node_modules/antlr4ts/atn/LoopEndState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoopEndState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var LoopEndState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.LOOP_END;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LoopEndState.prototype, "stateType", null);
    exports.LoopEndState = LoopEndState;
  }
});

// node_modules/antlr4ts/atn/ConflictInfo.js
var require_ConflictInfo = __commonJS({
  "node_modules/antlr4ts/atn/ConflictInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConflictInfo = void 0;
    var Decorators_1 = require_Decorators();
    var Utils3 = require_Utils();
    var ConflictInfo = class {
      constructor(conflictedAlts, exact) {
        this._conflictedAlts = conflictedAlts;
        this.exact = exact;
      }
      get conflictedAlts() {
        return this._conflictedAlts;
      }
      get isExact() {
        return this.exact;
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof ConflictInfo)) {
          return false;
        }
        return this.isExact === obj.isExact && Utils3.equals(this.conflictedAlts, obj.conflictedAlts);
      }
      hashCode() {
        return this.conflictedAlts.hashCode();
      }
    };
    __decorate([
      Decorators_1.Override
    ], ConflictInfo.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ConflictInfo.prototype, "hashCode", null);
    exports.ConflictInfo = ConflictInfo;
  }
});

// node_modules/antlr4ts/tree/TerminalNode.js
var require_TerminalNode = __commonJS({
  "node_modules/antlr4ts/tree/TerminalNode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TerminalNode = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var TerminalNode = class {
      constructor(symbol) {
        this._symbol = symbol;
      }
      getChild(i) {
        throw new RangeError("Terminal Node has no children.");
      }
      get symbol() {
        return this._symbol;
      }
      get parent() {
        return this._parent;
      }
      setParent(parent) {
        this._parent = parent;
      }
      get payload() {
        return this._symbol;
      }
      get sourceInterval() {
        let tokenIndex = this._symbol.tokenIndex;
        return new Interval_1.Interval(tokenIndex, tokenIndex);
      }
      get childCount() {
        return 0;
      }
      accept(visitor) {
        return visitor.visitTerminal(this);
      }
      get text() {
        return this._symbol.text || "";
      }
      toStringTree(parser) {
        return this.toString();
      }
      toString() {
        if (this._symbol.type === Token_1.Token.EOF) {
          return "<EOF>";
        }
        return this._symbol.text || "";
      }
    };
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "getChild", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "setParent", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "payload", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "sourceInterval", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "accept", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "toStringTree", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "toString", null);
    exports.TerminalNode = TerminalNode;
  }
});

// node_modules/antlr4ts/tree/ErrorNode.js
var require_ErrorNode = __commonJS({
  "node_modules/antlr4ts/tree/ErrorNode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorNode = void 0;
    var Decorators_1 = require_Decorators();
    var TerminalNode_1 = require_TerminalNode();
    var ErrorNode = class extends TerminalNode_1.TerminalNode {
      constructor(token) {
        super(token);
      }
      accept(visitor) {
        return visitor.visitErrorNode(this);
      }
    };
    __decorate([
      Decorators_1.Override
    ], ErrorNode.prototype, "accept", null);
    exports.ErrorNode = ErrorNode;
  }
});

// node_modules/antlr4ts/tree/RuleNode.js
var require_RuleNode = __commonJS({
  "node_modules/antlr4ts/tree/RuleNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleNode = void 0;
    var RuleNode = class {
    };
    exports.RuleNode = RuleNode;
  }
});

// node_modules/antlr4ts/tree/Trees.js
var require_Trees = __commonJS({
  "node_modules/antlr4ts/tree/Trees.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Trees = void 0;
    var ATN_1 = require_ATN();
    var CommonToken_1 = require_CommonToken();
    var ErrorNode_1 = require_ErrorNode();
    var Decorators_1 = require_Decorators();
    var Parser_1 = require_Parser();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleNode_1 = require_RuleNode();
    var TerminalNode_1 = require_TerminalNode();
    var Token_1 = require_Token();
    var Utils3 = require_Utils();
    var Trees = class {
      static toStringTree(t, arg2) {
        let ruleNames;
        if (arg2 instanceof Parser_1.Parser) {
          ruleNames = arg2.ruleNames;
        } else {
          ruleNames = arg2;
        }
        let s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
        if (t.childCount === 0) {
          return s;
        }
        let buf = "";
        buf += "(";
        s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
        buf += s;
        buf += " ";
        for (let i = 0; i < t.childCount; i++) {
          if (i > 0) {
            buf += " ";
          }
          buf += this.toStringTree(t.getChild(i), ruleNames);
        }
        buf += ")";
        return buf;
      }
      static getNodeText(t, arg2) {
        let ruleNames;
        if (arg2 instanceof Parser_1.Parser) {
          ruleNames = arg2.ruleNames;
        } else if (arg2) {
          ruleNames = arg2;
        } else {
          let payload = t.payload;
          if (typeof payload.text === "string") {
            return payload.text;
          }
          return t.payload.toString();
        }
        if (t instanceof RuleNode_1.RuleNode) {
          let ruleContext = t.ruleContext;
          let ruleIndex = ruleContext.ruleIndex;
          let ruleName = ruleNames[ruleIndex];
          let altNumber = ruleContext.altNumber;
          if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            return ruleName + ":" + altNumber;
          }
          return ruleName;
        } else if (t instanceof ErrorNode_1.ErrorNode) {
          return t.toString();
        } else if (t instanceof TerminalNode_1.TerminalNode) {
          let symbol = t.symbol;
          return symbol.text || "";
        }
        throw new TypeError("Unexpected node type");
      }
      static getChildren(t) {
        let kids = [];
        for (let i = 0; i < t.childCount; i++) {
          kids.push(t.getChild(i));
        }
        return kids;
      }
      static getAncestors(t) {
        let ancestors = [];
        let p = t.parent;
        while (p) {
          ancestors.unshift(p);
          p = p.parent;
        }
        return ancestors;
      }
      static isAncestorOf(t, u) {
        if (!t || !u || !t.parent) {
          return false;
        }
        let p = u.parent;
        while (p) {
          if (t === p) {
            return true;
          }
          p = p.parent;
        }
        return false;
      }
      static findAllTokenNodes(t, ttype) {
        return Trees.findAllNodes(t, ttype, true);
      }
      static findAllRuleNodes(t, ruleIndex) {
        return Trees.findAllNodes(t, ruleIndex, false);
      }
      static findAllNodes(t, index2, findTokens) {
        let nodes = [];
        Trees._findAllNodes(t, index2, findTokens, nodes);
        return nodes;
      }
      static _findAllNodes(t, index2, findTokens, nodes) {
        if (findTokens && t instanceof TerminalNode_1.TerminalNode) {
          if (t.symbol.type === index2) {
            nodes.push(t);
          }
        } else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {
          if (t.ruleIndex === index2) {
            nodes.push(t);
          }
        }
        for (let i = 0; i < t.childCount; i++) {
          Trees._findAllNodes(t.getChild(i), index2, findTokens, nodes);
        }
      }
      static getDescendants(t) {
        let nodes = [];
        function recurse(e) {
          nodes.push(e);
          const n = e.childCount;
          for (let i = 0; i < n; i++) {
            recurse(e.getChild(i));
          }
        }
        recurse(t);
        return nodes;
      }
      static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
        let n = t.childCount;
        for (let i = 0; i < n; i++) {
          let child = t.getChild(i);
          let r = Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
          if (r) {
            return r;
          }
        }
        if (t instanceof ParserRuleContext_1.ParserRuleContext) {
          let stopToken = t.stop;
          if (startTokenIndex >= t.start.tokenIndex && (stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {
            return t;
          }
        }
        return void 0;
      }
      static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
        if (!t) {
          return;
        }
        let count = t.childCount;
        for (let i = 0; i < count; i++) {
          let child = t.getChild(i);
          let range = child.sourceInterval;
          if (child instanceof ParserRuleContext_1.ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {
            if (Trees.isAncestorOf(child, root)) {
              let abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, "...");
              t.children[i] = new TerminalNode_1.TerminalNode(abbrev);
            }
          }
        }
      }
      static findNodeSuchThat(t, pred) {
        if (pred(t)) {
          return t;
        }
        let n = t.childCount;
        for (let i = 0; i < n; i++) {
          let u = Trees.findNodeSuchThat(t.getChild(i), pred);
          if (u !== void 0) {
            return u;
          }
        }
        return void 0;
      }
    };
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Trees, "toStringTree", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Trees, "getAncestors", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Trees, "getRootOfSubtreeEnclosingRegion", null);
    exports.Trees = Trees;
  }
});

// node_modules/antlr4ts/RuleContext.js
var require_RuleContext = __commonJS({
  "node_modules/antlr4ts/RuleContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleContext = void 0;
    var ATN_1 = require_ATN();
    var Recognizer_1 = require_Recognizer();
    var RuleNode_1 = require_RuleNode();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleContext = class extends RuleNode_1.RuleNode {
      constructor(parent, invokingState) {
        super();
        this._parent = parent;
        this.invokingState = invokingState != null ? invokingState : -1;
      }
      static getChildContext(parent, invokingState) {
        return new RuleContext(parent, invokingState);
      }
      depth() {
        let n = 0;
        let p = this;
        while (p) {
          p = p._parent;
          n++;
        }
        return n;
      }
      get isEmpty() {
        return this.invokingState === -1;
      }
      get sourceInterval() {
        return Interval_1.Interval.INVALID;
      }
      get ruleContext() {
        return this;
      }
      get parent() {
        return this._parent;
      }
      setParent(parent) {
        this._parent = parent;
      }
      get payload() {
        return this;
      }
      get text() {
        if (this.childCount === 0) {
          return "";
        }
        let builder = "";
        for (let i = 0; i < this.childCount; i++) {
          builder += this.getChild(i).text;
        }
        return builder.toString();
      }
      get ruleIndex() {
        return -1;
      }
      get altNumber() {
        return ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      set altNumber(altNumber) {
      }
      getChild(i) {
        throw new RangeError("i must be greater than or equal to 0 and less than childCount");
      }
      get childCount() {
        return 0;
      }
      accept(visitor) {
        return visitor.visitChildren(this);
      }
      toStringTree(recog) {
        return Trees_1.Trees.toStringTree(this, recog);
      }
      toString(arg1, stop) {
        const ruleNames = arg1 instanceof Recognizer_1.Recognizer ? arg1.ruleNames : arg1;
        stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();
        let buf = "";
        let p = this;
        buf += "[";
        while (p && p !== stop) {
          if (!ruleNames) {
            if (!p.isEmpty) {
              buf += p.invokingState;
            }
          } else {
            let ruleIndex = p.ruleIndex;
            let ruleName = ruleIndex >= 0 && ruleIndex < ruleNames.length ? ruleNames[ruleIndex] : ruleIndex.toString();
            buf += ruleName;
          }
          if (p._parent && (ruleNames || !p._parent.isEmpty)) {
            buf += " ";
          }
          p = p._parent;
        }
        buf += "]";
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "sourceInterval", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "ruleContext", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "setParent", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "payload", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "getChild", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "accept", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "toStringTree", null);
    exports.RuleContext = RuleContext;
  }
});

// node_modules/antlr4ts/ParserRuleContext.js
var require_ParserRuleContext = __commonJS({
  "node_modules/antlr4ts/ParserRuleContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserRuleContext = void 0;
    var ErrorNode_1 = require_ErrorNode();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var RuleContext_1 = require_RuleContext();
    var TerminalNode_1 = require_TerminalNode();
    var ParserRuleContext3 = class extends RuleContext_1.RuleContext {
      constructor(parent, invokingStateNumber) {
        if (invokingStateNumber == null) {
          super();
        } else {
          super(parent, invokingStateNumber);
        }
      }
      static emptyContext() {
        return ParserRuleContext3.EMPTY;
      }
      copyFrom(ctx) {
        this._parent = ctx._parent;
        this.invokingState = ctx.invokingState;
        this._start = ctx._start;
        this._stop = ctx._stop;
        if (ctx.children) {
          this.children = [];
          for (let child of ctx.children) {
            if (child instanceof ErrorNode_1.ErrorNode) {
              this.addChild(child);
            }
          }
        }
      }
      enterRule(listener) {
      }
      exitRule(listener) {
      }
      addAnyChild(t) {
        if (!this.children) {
          this.children = [t];
        } else {
          this.children.push(t);
        }
        return t;
      }
      addChild(t) {
        let result;
        if (t instanceof TerminalNode_1.TerminalNode) {
          t.setParent(this);
          this.addAnyChild(t);
          return;
        } else if (t instanceof RuleContext_1.RuleContext) {
          this.addAnyChild(t);
          return;
        } else {
          t = new TerminalNode_1.TerminalNode(t);
          this.addAnyChild(t);
          t.setParent(this);
          return t;
        }
      }
      addErrorNode(node) {
        if (node instanceof ErrorNode_1.ErrorNode) {
          const errorNode = node;
          errorNode.setParent(this);
          return this.addAnyChild(errorNode);
        } else {
          const badToken = node;
          let t = new ErrorNode_1.ErrorNode(badToken);
          this.addAnyChild(t);
          t.setParent(this);
          return t;
        }
      }
      removeLastChild() {
        if (this.children) {
          this.children.pop();
        }
      }
      get parent() {
        let parent = super.parent;
        if (parent === void 0 || parent instanceof ParserRuleContext3) {
          return parent;
        }
        throw new TypeError("Invalid parent type for ParserRuleContext");
      }
      getChild(i, ctxType) {
        if (!this.children || i < 0 || i >= this.children.length) {
          throw new RangeError("index parameter must be between >= 0 and <= number of children.");
        }
        if (ctxType == null) {
          return this.children[i];
        }
        let result = this.tryGetChild(i, ctxType);
        if (result === void 0) {
          throw new Error("The specified node does not exist");
        }
        return result;
      }
      tryGetChild(i, ctxType) {
        if (!this.children || i < 0 || i >= this.children.length) {
          return void 0;
        }
        let j = -1;
        for (let o of this.children) {
          if (o instanceof ctxType) {
            j++;
            if (j === i) {
              return o;
            }
          }
        }
        return void 0;
      }
      getToken(ttype, i) {
        let result = this.tryGetToken(ttype, i);
        if (result === void 0) {
          throw new Error("The specified token does not exist");
        }
        return result;
      }
      tryGetToken(ttype, i) {
        if (!this.children || i < 0 || i >= this.children.length) {
          return void 0;
        }
        let j = -1;
        for (let o of this.children) {
          if (o instanceof TerminalNode_1.TerminalNode) {
            let symbol = o.symbol;
            if (symbol.type === ttype) {
              j++;
              if (j === i) {
                return o;
              }
            }
          }
        }
        return void 0;
      }
      getTokens(ttype) {
        let tokens = [];
        if (!this.children) {
          return tokens;
        }
        for (let o of this.children) {
          if (o instanceof TerminalNode_1.TerminalNode) {
            let symbol = o.symbol;
            if (symbol.type === ttype) {
              tokens.push(o);
            }
          }
        }
        return tokens;
      }
      get ruleContext() {
        return this;
      }
      getRuleContext(i, ctxType) {
        return this.getChild(i, ctxType);
      }
      tryGetRuleContext(i, ctxType) {
        return this.tryGetChild(i, ctxType);
      }
      getRuleContexts(ctxType) {
        let contexts = [];
        if (!this.children) {
          return contexts;
        }
        for (let o of this.children) {
          if (o instanceof ctxType) {
            contexts.push(o);
          }
        }
        return contexts;
      }
      get childCount() {
        return this.children ? this.children.length : 0;
      }
      get sourceInterval() {
        if (!this._start) {
          return Interval_1.Interval.INVALID;
        }
        if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {
          return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1);
        }
        return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);
      }
      get start() {
        return this._start;
      }
      get stop() {
        return this._stop;
      }
      toInfoString(recognizer) {
        let rules = recognizer.getRuleInvocationStack(this).reverse();
        return "ParserRuleContext" + rules + "{start=" + this._start + ", stop=" + this._stop + "}";
      }
    };
    ParserRuleContext3.EMPTY = new ParserRuleContext3();
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext3.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext3.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext3.prototype, "sourceInterval", null);
    exports.ParserRuleContext = ParserRuleContext3;
  }
});

// node_modules/antlr4ts/atn/PredictionMode.js
var require_PredictionMode = __commonJS({
  "node_modules/antlr4ts/atn/PredictionMode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredictionMode = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var RuleStopState_1 = require_RuleStopState();
    var PredictionMode;
    (function(PredictionMode2) {
      PredictionMode2[PredictionMode2["SLL"] = 0] = "SLL";
      PredictionMode2[PredictionMode2["LL"] = 1] = "LL";
      PredictionMode2[PredictionMode2["LL_EXACT_AMBIG_DETECTION"] = 2] = "LL_EXACT_AMBIG_DETECTION";
    })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
    (function(PredictionMode2) {
      class AltAndContextMap extends Array2DHashMap_1.Array2DHashMap {
        constructor() {
          super(AltAndContextConfigEqualityComparator.INSTANCE);
        }
      }
      class AltAndContextConfigEqualityComparator {
        AltAndContextConfigEqualityComparator() {
        }
        hashCode(o) {
          let hashCode = MurmurHash_1.MurmurHash.initialize(7);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.state.stateNumber);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.context);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 2);
          return hashCode;
        }
        equals(a, b) {
          if (a === b) {
            return true;
          }
          if (a == null || b == null) {
            return false;
          }
          return a.state.stateNumber === b.state.stateNumber && a.context.equals(b.context);
        }
      }
      AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], AltAndContextConfigEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], AltAndContextConfigEqualityComparator.prototype, "equals", null);
      function hasConfigInRuleStopState(configs) {
        for (let c of configs) {
          if (c.state instanceof RuleStopState_1.RuleStopState) {
            return true;
          }
        }
        return false;
      }
      PredictionMode2.hasConfigInRuleStopState = hasConfigInRuleStopState;
      function allConfigsInRuleStopStates(configs) {
        for (let config of configs) {
          if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
            return false;
          }
        }
        return true;
      }
      PredictionMode2.allConfigsInRuleStopStates = allConfigsInRuleStopStates;
    })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
  }
});

// node_modules/antlr4ts/atn/SimulatorState.js
var require_SimulatorState = __commonJS({
  "node_modules/antlr4ts/atn/SimulatorState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimulatorState = void 0;
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var SimulatorState = class SimulatorState {
      constructor(outerContext, s0, useContext, remainingOuterContext) {
        this.outerContext = outerContext != null ? outerContext : ParserRuleContext_1.ParserRuleContext.emptyContext();
        this.s0 = s0;
        this.useContext = useContext;
        this.remainingOuterContext = remainingOuterContext;
      }
    };
    SimulatorState = __decorate([
      __param(1, Decorators_1.NotNull)
    ], SimulatorState);
    exports.SimulatorState = SimulatorState;
  }
});

// node_modules/antlr4ts/atn/ParserATNSimulator.js
var require_ParserATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ParserATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserATNSimulator = void 0;
    var AcceptStateInfo_1 = require_AcceptStateInfo();
    var ActionTransition_1 = require_ActionTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var Arrays_1 = require_Arrays();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var ATNSimulator_1 = require_ATNSimulator();
    var ATNStateType_1 = require_ATNStateType();
    var AtomTransition_1 = require_AtomTransition();
    var BitSet_1 = require_BitSet();
    var ConflictInfo_1 = require_ConflictInfo();
    var DecisionState_1 = require_DecisionState();
    var DFAState_1 = require_DFAState();
    var IntegerList_1 = require_IntegerList();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var NoViableAltException_1 = require_NoViableAltException();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var PredictionContext_1 = require_PredictionContext();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var PredictionMode_1 = require_PredictionMode();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var SemanticContext_1 = require_SemanticContext();
    var SetTransition_1 = require_SetTransition();
    var SimulatorState_1 = require_SimulatorState();
    var Token_1 = require_Token();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var assert = require("assert");
    var MAX_SHORT_VALUE = 65535;
    var MIN_INTEGER_VALUE = -(1 << 31 >>> 0);
    var ParserATNSimulator2 = class ParserATNSimulator3 extends ATNSimulator_1.ATNSimulator {
      constructor(atn, parser) {
        super(atn);
        this.predictionMode = PredictionMode_1.PredictionMode.LL;
        this.force_global_context = false;
        this.always_try_local_context = true;
        this.enable_global_context_dfa = false;
        this.optimize_unique_closure = true;
        this.optimize_ll1 = true;
        this.optimize_tail_calls = true;
        this.tail_call_preserves_sll = true;
        this.treat_sllk1_conflict_as_ambiguity = false;
        this.reportAmbiguities = false;
        this.userWantsCtxSensitive = true;
        this._parser = parser;
      }
      getPredictionMode() {
        return this.predictionMode;
      }
      setPredictionMode(predictionMode) {
        this.predictionMode = predictionMode;
      }
      reset() {
      }
      adaptivePredict(input, decision, outerContext, useContext) {
        if (useContext === void 0) {
          useContext = false;
        }
        let dfa = this.atn.decisionToDFA[decision];
        assert(dfa != null);
        if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {
          let ll_1 = input.LA(1);
          if (ll_1 >= 0 && ll_1 <= 65535) {
            let key = (decision << 16 >>> 0) + ll_1;
            let alt = this.atn.LL1Table.get(key);
            if (alt != null) {
              return alt;
            }
          }
        }
        this.dfa = dfa;
        if (this.force_global_context) {
          useContext = true;
        } else if (!this.always_try_local_context) {
          useContext = useContext || dfa.isContextSensitive;
        }
        this.userWantsCtxSensitive = useContext || this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll;
        if (outerContext == null) {
          outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
        }
        let state;
        if (!dfa.isEmpty) {
          state = this.getStartState(dfa, input, outerContext, useContext);
        }
        if (state == null) {
          if (outerContext == null) {
            outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
          }
          if (ParserATNSimulator3.debug) {
            console.log("ATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
          }
          state = this.computeStartState(dfa, outerContext, useContext);
        }
        let m = input.mark();
        let index2 = input.index;
        try {
          let alt = this.execDFA(dfa, input, index2, state);
          if (ParserATNSimulator3.debug) {
            console.log("DFA after predictATN: " + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
          }
          return alt;
        } finally {
          this.dfa = void 0;
          input.seek(index2);
          input.release(m);
        }
      }
      getStartState(dfa, input, outerContext, useContext) {
        if (!useContext) {
          if (dfa.isPrecedenceDfa) {
            let state = dfa.getPrecedenceStartState(this._parser.precedence, false);
            if (state == null) {
              return void 0;
            }
            return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);
          } else {
            if (dfa.s0 == null) {
              return void 0;
            }
            return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);
          }
        }
        if (!this.enable_global_context_dfa) {
          return void 0;
        }
        let remainingContext = outerContext;
        assert(outerContext != null);
        let s0;
        if (dfa.isPrecedenceDfa) {
          s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);
        } else {
          s0 = dfa.s0full;
        }
        while (remainingContext != null && s0 != null && s0.isContextSensitive) {
          remainingContext = this.skipTailCalls(remainingContext);
          s0 = s0.getContextTarget(this.getReturnState(remainingContext));
          if (remainingContext.isEmpty) {
            assert(s0 == null || !s0.isContextSensitive);
          } else {
            remainingContext = remainingContext.parent;
          }
        }
        if (s0 == null) {
          return void 0;
        }
        return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);
      }
      execDFA(dfa, input, startIndex, state) {
        let outerContext = state.outerContext;
        if (ParserATNSimulator3.dfa_debug) {
          console.log("DFA decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
        }
        if (ParserATNSimulator3.dfa_debug) {
          console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
        }
        let s = state.s0;
        let t = input.LA(1);
        let remainingOuterContext = state.remainingOuterContext;
        while (true) {
          if (ParserATNSimulator3.dfa_debug) {
            console.log("DFA state " + s.stateNumber + " LA(1)==" + this.getLookaheadName(input));
          }
          if (state.useContext) {
            while (s.isContextSymbol(t)) {
              let next;
              if (remainingOuterContext != null) {
                remainingOuterContext = this.skipTailCalls(remainingOuterContext);
                next = s.getContextTarget(this.getReturnState(remainingOuterContext));
              }
              if (next == null) {
                let initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);
                return this.execATN(dfa, input, startIndex, initialState);
              }
              assert(remainingOuterContext != null);
              remainingOuterContext = remainingOuterContext.parent;
              s = next;
            }
          }
          if (this.isAcceptState(s, state.useContext)) {
            if (s.predicates != null) {
              if (ParserATNSimulator3.dfa_debug) {
                console.log("accept " + s);
              }
            } else {
              if (ParserATNSimulator3.dfa_debug) {
                console.log("accept; predict " + s.prediction + " in state " + s.stateNumber);
              }
            }
            break;
          }
          assert(!this.isAcceptState(s, state.useContext));
          let target = this.getExistingTargetState(s, t);
          if (target == null) {
            if (ParserATNSimulator3.dfa_debug && t >= 0) {
              console.log("no edge for " + this._parser.vocabulary.getDisplayName(t));
            }
            let alt;
            if (ParserATNSimulator3.dfa_debug) {
              let interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);
              console.log("ATN exec upon " + this._parser.inputStream.getText(interval) + " at DFA state " + s.stateNumber);
            }
            let initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
            alt = this.execATN(dfa, input, startIndex, initialState);
            if (ParserATNSimulator3.dfa_debug) {
              console.log("back from DFA update, alt=" + alt + ", dfa=\n" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
            }
            if (ParserATNSimulator3.dfa_debug) {
              console.log("DFA decision " + dfa.decision + " predicts " + alt);
            }
            return alt;
          } else if (target === ATNSimulator_1.ATNSimulator.ERROR) {
            let errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
            return this.handleNoViableAlt(input, startIndex, errorState);
          }
          s = target;
          if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
        if (!state.useContext && s.configs.conflictInfo != null) {
          if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {
            if (!this.userWantsCtxSensitive || !s.configs.dipsIntoOuterContext && s.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex) {
            } else {
              assert(!state.useContext);
              let conflictingAlts;
              let predicates2 = s.predicates;
              if (predicates2 != null) {
                let conflictIndex = input.index;
                if (conflictIndex !== startIndex) {
                  input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(predicates2, outerContext, true);
                if (conflictingAlts.cardinality() === 1) {
                  return conflictingAlts.nextSetBit(0);
                }
                if (conflictIndex !== startIndex) {
                  input.seek(conflictIndex);
                }
              }
              if (this.reportAmbiguities) {
                let conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
                this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);
              }
              input.seek(startIndex);
              return this.adaptivePredict(input, dfa.decision, outerContext, true);
            }
          }
        }
        let predicates = s.predicates;
        if (predicates != null) {
          let stopIndex = input.index;
          if (startIndex !== stopIndex) {
            input.seek(startIndex);
          }
          let alts = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);
          switch (alts.cardinality()) {
            case 0:
              throw this.noViableAlt(input, outerContext, s.configs, startIndex);
            case 1:
              return alts.nextSetBit(0);
            default:
              if (startIndex !== stopIndex) {
                input.seek(stopIndex);
              }
              this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);
              return alts.nextSetBit(0);
          }
        }
        if (ParserATNSimulator3.dfa_debug) {
          console.log("DFA decision " + dfa.decision + " predicts " + s.prediction);
        }
        return s.prediction;
      }
      isAcceptState(state, useContext) {
        if (!state.isAcceptState) {
          return false;
        }
        if (state.configs.conflictingAlts == null) {
          return true;
        }
        if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {
          return state.configs.isExactConflict;
        }
        return true;
      }
      execATN(dfa, input, startIndex, initialState) {
        if (ParserATNSimulator3.debug) {
          console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input));
        }
        let outerContext = initialState.outerContext;
        let useContext = initialState.useContext;
        let t = input.LA(1);
        let previous4 = initialState;
        let contextCache = new PredictionContextCache_1.PredictionContextCache();
        while (true) {
          let nextState = this.computeReachSet(dfa, previous4, t, contextCache);
          if (nextState == null) {
            this.setDFAEdge(previous4.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);
            return this.handleNoViableAlt(input, startIndex, previous4);
          }
          let D = nextState.s0;
          assert(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);
          assert(D.isAcceptState || D.configs.conflictInfo == null);
          if (this.isAcceptState(D, useContext)) {
            let conflictingAlts = D.configs.conflictingAlts;
            let predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;
            if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (this.optimize_ll1 && input.index === startIndex && !dfa.isPrecedenceDfa && nextState.outerContext === nextState.remainingOuterContext && dfa.decision >= 0 && !D.configs.hasSemanticContext) {
                if (t >= 0 && t <= MAX_SHORT_VALUE) {
                  let key = (dfa.decision << 16 >>> 0) + t;
                  this.atn.LL1Table.set(key, predictedAlt);
                }
              }
              if (useContext && this.always_try_local_context) {
                this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);
              }
            }
            predictedAlt = D.prediction;
            let attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;
            if (attemptFullContext) {
              attemptFullContext = !useContext && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);
            }
            if (D.configs.hasSemanticContext) {
              let predPredictions = D.predicates;
              if (predPredictions != null) {
                let conflictIndex = input.index;
                if (conflictIndex !== startIndex) {
                  input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);
                switch (conflictingAlts.cardinality()) {
                  case 0:
                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                  case 1:
                    return conflictingAlts.nextSetBit(0);
                  default:
                    break;
                }
                if (conflictIndex !== startIndex) {
                  input.seek(conflictIndex);
                }
              }
            }
            if (!attemptFullContext) {
              if (conflictingAlts != null) {
                if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {
                  this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);
                }
                predictedAlt = conflictingAlts.nextSetBit(0);
              }
              return predictedAlt;
            } else {
              assert(!useContext);
              assert(this.isAcceptState(D, false));
              if (ParserATNSimulator3.debug) {
                console.log("RETRY with outerContext=" + outerContext);
              }
              let fullContextState = this.computeStartState(dfa, outerContext, true);
              if (this.reportAmbiguities) {
                this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);
              }
              input.seek(startIndex);
              return this.execATN(dfa, input, startIndex, fullContextState);
            }
          }
          previous4 = nextState;
          if (t !== IntStream_1.IntStream.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
      }
      handleNoViableAlt(input, startIndex, previous4) {
        if (previous4.s0 != null) {
          let alts = new BitSet_1.BitSet();
          let maxAlt = 0;
          for (let config of previous4.s0.configs) {
            if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
              alts.set(config.alt);
              maxAlt = Math.max(maxAlt, config.alt);
            }
          }
          switch (alts.cardinality()) {
            case 0:
              break;
            case 1:
              return alts.nextSetBit(0);
            default:
              if (!previous4.s0.configs.hasSemanticContext) {
                return alts.nextSetBit(0);
              }
              let filteredConfigs = new ATNConfigSet_1.ATNConfigSet();
              for (let config of previous4.s0.configs) {
                if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
                  filteredConfigs.add(config);
                }
              }
              let altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);
              if (altToPred != null) {
                let predicates = this.getPredicatePredictions(alts, altToPred);
                if (predicates != null) {
                  let stopIndex = input.index;
                  try {
                    input.seek(startIndex);
                    let filteredAlts = this.evalSemanticContext(predicates, previous4.outerContext, false);
                    if (!filteredAlts.isEmpty) {
                      return filteredAlts.nextSetBit(0);
                    }
                  } finally {
                    input.seek(stopIndex);
                  }
                }
              }
              return alts.nextSetBit(0);
          }
        }
        throw this.noViableAlt(input, previous4.outerContext, previous4.s0.configs, startIndex);
      }
      computeReachSet(dfa, previous4, t, contextCache) {
        let useContext = previous4.useContext;
        let remainingGlobalContext = previous4.remainingOuterContext;
        let s = previous4.s0;
        if (useContext) {
          while (s.isContextSymbol(t)) {
            let next;
            if (remainingGlobalContext != null) {
              remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
              next = s.getContextTarget(this.getReturnState(remainingGlobalContext));
            }
            if (next == null) {
              break;
            }
            assert(remainingGlobalContext != null);
            remainingGlobalContext = remainingGlobalContext.parent;
            s = next;
          }
        }
        assert(!this.isAcceptState(s, useContext));
        if (this.isAcceptState(s, useContext)) {
          return new SimulatorState_1.SimulatorState(previous4.outerContext, s, useContext, remainingGlobalContext);
        }
        let s0 = s;
        let target = this.getExistingTargetState(s0, t);
        if (target == null) {
          let result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);
          target = result[0];
          remainingGlobalContext = result[1];
        }
        if (target === ATNSimulator_1.ATNSimulator.ERROR) {
          return void 0;
        }
        assert(!useContext || !target.configs.dipsIntoOuterContext);
        return new SimulatorState_1.SimulatorState(previous4.outerContext, target, useContext, remainingGlobalContext);
      }
      getExistingTargetState(s, t) {
        return s.getTarget(t);
      }
      computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
        let closureConfigs = s.configs.toArray();
        let contextElements;
        let reach = new ATNConfigSet_1.ATNConfigSet();
        let stepIntoGlobal;
        do {
          let hasMoreContext = !useContext || remainingGlobalContext != null;
          if (!hasMoreContext) {
            reach.isOutermostConfigSet = true;
          }
          let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
          let skippedStopStates;
          for (let c of closureConfigs) {
            if (ParserATNSimulator3.debug) {
              console.log("testing " + this.getTokenName(t) + " at " + c.toString());
            }
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              assert(c.context.isEmpty);
              if (useContext && !c.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {
                if (skippedStopStates == null) {
                  skippedStopStates = [];
                }
                skippedStopStates.push(c);
              }
              continue;
            }
            let n = c.state.numberOfOptimizedTransitions;
            for (let ti = 0; ti < n; ti++) {
              let trans = c.state.getOptimizedTransition(ti);
              let target = this.getReachableTarget(c, trans, t);
              if (target != null) {
                reachIntermediate.add(c.transform(target, false), contextCache);
              }
            }
          }
          if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;
            reach = reachIntermediate;
            break;
          }
          let collectPredicates = false;
          let treatEofAsEpsilon = t === Token_1.Token.EOF;
          this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);
          stepIntoGlobal = reach.dipsIntoOuterContext;
          if (t === IntStream_1.IntStream.EOF) {
            reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);
          }
          if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {
            assert(skippedStopStates.length > 0);
            for (let c of skippedStopStates) {
              reach.add(c, contextCache);
            }
          }
          if (useContext && stepIntoGlobal) {
            reach.clear();
            remainingGlobalContext = remainingGlobalContext;
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            let nextContextElement = this.getReturnState(remainingGlobalContext);
            if (contextElements == null) {
              contextElements = new IntegerList_1.IntegerList();
            }
            if (remainingGlobalContext.isEmpty) {
              remainingGlobalContext = void 0;
            } else {
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            contextElements.add(nextContextElement);
            if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              for (let i = 0; i < closureConfigs.length; i++) {
                closureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);
              }
            }
          }
        } while (useContext && stepIntoGlobal);
        if (reach.isEmpty) {
          this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
          return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];
        }
        let result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);
        return [result, remainingGlobalContext];
      }
      removeAllConfigsNotInRuleStopState(configs, contextCache) {
        if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {
          return configs;
        }
        let result = new ATNConfigSet_1.ATNConfigSet();
        for (let config of configs) {
          if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          result.add(config, contextCache);
        }
        return result;
      }
      computeStartState(dfa, globalContext, useContext) {
        let s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) : useContext ? dfa.s0full : dfa.s0;
        if (s0 != null) {
          if (!useContext) {
            return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);
          }
          s0.setContextSensitive(this.atn);
        }
        let decision = dfa.decision;
        let p = dfa.atnStartState;
        let previousContext = 0;
        let remainingGlobalContext = globalContext;
        let initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL;
        let contextCache = new PredictionContextCache_1.PredictionContextCache();
        if (useContext) {
          if (!this.enable_global_context_dfa) {
            while (remainingGlobalContext != null) {
              if (remainingGlobalContext.isEmpty) {
                previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                remainingGlobalContext = void 0;
              } else {
                previousContext = this.getReturnState(remainingGlobalContext);
                initialContext = initialContext.appendSingleContext(previousContext, contextCache);
                remainingGlobalContext = remainingGlobalContext.parent;
              }
            }
          }
          while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {
            let next;
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            if (remainingGlobalContext.isEmpty) {
              next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);
              previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
              remainingGlobalContext = void 0;
            } else {
              previousContext = this.getReturnState(remainingGlobalContext);
              next = s0.getContextTarget(previousContext);
              initialContext = initialContext.appendSingleContext(previousContext, contextCache);
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            if (next == null) {
              break;
            }
            s0 = next;
          }
        }
        if (s0 != null && !s0.isContextSensitive) {
          return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
        }
        let configs = new ATNConfigSet_1.ATNConfigSet();
        while (true) {
          let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
          let n = p.numberOfTransitions;
          for (let ti = 0; ti < n; ti++) {
            let target = p.transition(ti).target;
            reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));
          }
          let hasMoreContext = remainingGlobalContext != null;
          if (!hasMoreContext) {
            configs.isOutermostConfigSet = true;
          }
          let collectPredicates = true;
          this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);
          let stepIntoGlobal = configs.dipsIntoOuterContext;
          let next;
          if (useContext && !this.enable_global_context_dfa) {
            s0 = this.addDFAState(dfa, configs, contextCache);
            break;
          } else if (s0 == null) {
            if (!dfa.isPrecedenceDfa) {
              next = this.addDFAState(dfa, configs, contextCache);
              if (useContext) {
                if (!dfa.s0full) {
                  dfa.s0full = next;
                } else {
                  next = dfa.s0full;
                }
              } else {
                if (!dfa.s0) {
                  dfa.s0 = next;
                } else {
                  next = dfa.s0;
                }
              }
            } else {
              configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
              next = this.addDFAState(dfa, configs, contextCache);
              dfa.setPrecedenceStartState(this._parser.precedence, useContext, next);
            }
          } else {
            if (dfa.isPrecedenceDfa) {
              configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
            }
            next = this.addDFAState(dfa, configs, contextCache);
            s0.setContextTarget(previousContext, next);
          }
          s0 = next;
          if (!useContext || !stepIntoGlobal) {
            break;
          }
          next.setContextSensitive(this.atn);
          remainingGlobalContext = remainingGlobalContext;
          configs.clear();
          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
          let nextContextElement = this.getReturnState(remainingGlobalContext);
          if (remainingGlobalContext.isEmpty) {
            remainingGlobalContext = void 0;
          } else {
            remainingGlobalContext = remainingGlobalContext.parent;
          }
          if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);
          }
          previousContext = nextContextElement;
        }
        return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
      }
      applyPrecedenceFilter(configs, globalContext, contextCache) {
        let statesFromAlt1 = /* @__PURE__ */ new Map();
        let configSet = new ATNConfigSet_1.ATNConfigSet();
        for (let config of configs) {
          if (config.alt !== 1) {
            continue;
          }
          let updatedContext = config.semanticContext.evalPrecedence(this._parser, globalContext);
          if (updatedContext == null) {
            continue;
          }
          statesFromAlt1.set(config.state.stateNumber, config.context);
          if (updatedContext !== config.semanticContext) {
            configSet.add(config.transform(config.state, false, updatedContext), contextCache);
          } else {
            configSet.add(config, contextCache);
          }
        }
        for (let config of configs) {
          if (config.alt === 1) {
            continue;
          }
          if (!config.isPrecedenceFilterSuppressed) {
            let context = statesFromAlt1.get(config.state.stateNumber);
            if (context != null && context.equals(config.context)) {
              continue;
            }
          }
          configSet.add(config, contextCache);
        }
        return configSet;
      }
      getReachableTarget(source, trans, ttype) {
        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
          return trans.target;
        }
        return void 0;
      }
      predicateDFAState(D, configs, nalts) {
        let conflictingAlts = this.getConflictingAltsFromConfigSet(configs);
        if (!conflictingAlts) {
          throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");
        }
        if (ParserATNSimulator3.debug) {
          console.log("predicateDFAState " + D);
        }
        let altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);
        let predPredictions;
        if (altToPred != null) {
          predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);
          D.predicates = predPredictions;
        }
        return predPredictions;
      }
      getPredsForAmbigAlts(ambigAlts, configs, nalts) {
        let altToPred = new Array(nalts + 1);
        let n = altToPred.length;
        for (let c of configs) {
          if (ambigAlts.get(c.alt)) {
            altToPred[c.alt] = SemanticContext_1.SemanticContext.or(altToPred[c.alt], c.semanticContext);
          }
        }
        let nPredAlts = 0;
        for (let i = 0; i < n; i++) {
          if (altToPred[i] == null) {
            altToPred[i] = SemanticContext_1.SemanticContext.NONE;
          } else if (altToPred[i] !== SemanticContext_1.SemanticContext.NONE) {
            nPredAlts++;
          }
        }
        let result = altToPred;
        if (nPredAlts === 0) {
          result = void 0;
        }
        if (ParserATNSimulator3.debug) {
          console.log("getPredsForAmbigAlts result " + (result ? Arrays_1.Arrays.toString(result) : "undefined"));
        }
        return result;
      }
      getPredicatePredictions(ambigAlts, altToPred) {
        let pairs = [];
        let containsPredicate = false;
        for (let i = 1; i < altToPred.length; i++) {
          let pred = altToPred[i];
          assert(pred != null);
          if (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext_1.SemanticContext.NONE) {
            pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
          } else if (pred !== SemanticContext_1.SemanticContext.NONE) {
            containsPredicate = true;
            pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
          }
        }
        if (!containsPredicate) {
          return void 0;
        }
        return pairs;
      }
      evalSemanticContext(predPredictions, outerContext, complete) {
        let predictions = new BitSet_1.BitSet();
        for (let pair of predPredictions) {
          if (pair.pred === SemanticContext_1.SemanticContext.NONE) {
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
            continue;
          }
          let evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);
          if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
            console.log("eval pred " + pair + "=" + evaluatedResult);
          }
          if (evaluatedResult) {
            if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
              console.log("PREDICT " + pair.alt);
            }
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
          }
        }
        return predictions;
      }
      evalSemanticContextImpl(pred, parserCallStack, alt) {
        return pred.eval(this._parser, parserCallStack);
      }
      closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {
        if (contextCache == null) {
          contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
        }
        let currentConfigs = sourceConfigs;
        let closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        while (currentConfigs.size > 0) {
          let intermediate = new ATNConfigSet_1.ATNConfigSet();
          for (let config of currentConfigs) {
            this.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);
          }
          currentConfigs = intermediate;
        }
      }
      closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {
        if (ParserATNSimulator3.debug) {
          console.log("closure(" + config.toString(this._parser, true) + ")");
        }
        if (config.state instanceof RuleStopState_1.RuleStopState) {
          if (!config.context.isEmpty) {
            let hasEmpty = config.context.hasEmpty;
            let nonEmptySize = config.context.size - (hasEmpty ? 1 : 0);
            for (let i = 0; i < nonEmptySize; i++) {
              let newContext = config.context.getParent(i);
              let returnState = this.atn.states[config.context.getReturnState(i)];
              let c = ATNConfig_1.ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);
              c.outerContextDepth = config.outerContextDepth;
              c.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;
              assert(depth > MIN_INTEGER_VALUE);
              this.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);
            }
            if (!hasEmpty || !hasMoreContexts) {
              return;
            }
            config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
          } else if (!hasMoreContexts) {
            configs.add(config, contextCache);
            return;
          } else {
            if (ParserATNSimulator3.debug) {
              console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
            }
            if (config.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {
              config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
            } else if (!config.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
              configs.add(config, contextCache);
            }
          }
        }
        let p = config.state;
        if (!p.onlyHasEpsilonTransitions) {
          configs.add(config, contextCache);
          if (ParserATNSimulator3.debug) {
            console.log("added config " + configs);
          }
        }
        for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
          if (i === 0 && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY && p.precedenceRuleDecision && !config.context.hasEmpty) {
            let precedenceDecision = p;
            let suppress = true;
            for (let j = 0; j < config.context.size; j++) {
              if (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {
                suppress = false;
                break;
              }
            }
            if (suppress) {
              continue;
            }
          }
          let t = p.getOptimizedTransition(i);
          let continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;
          let c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);
          if (c != null) {
            if (t instanceof RuleTransition_1.RuleTransition) {
              if (intermediate != null && !collectPredicates) {
                intermediate.add(c, contextCache);
                continue;
              }
            }
            let newDepth = depth;
            if (config.state instanceof RuleStopState_1.RuleStopState) {
              if (this.dfa != null && this.dfa.isPrecedenceDfa) {
                let outermostPrecedenceReturn = t.outermostPrecedenceReturn;
                if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {
                  c.isPrecedenceFilterSuppressed = true;
                }
              }
              c.outerContextDepth = c.outerContextDepth + 1;
              if (!closureBusy.add(c)) {
                continue;
              }
              assert(newDepth > MIN_INTEGER_VALUE);
              newDepth--;
              if (ParserATNSimulator3.debug) {
                console.log("dips into outer ctx: " + c);
              }
            } else if (t instanceof RuleTransition_1.RuleTransition) {
              if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
                assert(c.context === config.context);
                if (newDepth === 0) {
                  newDepth--;
                  if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
                    c.outerContextDepth = c.outerContextDepth + 1;
                  }
                }
              } else {
                if (newDepth >= 0) {
                  newDepth++;
                }
              }
            } else {
              if (!t.isEpsilon && !closureBusy.add(c)) {
                continue;
              }
            }
            this.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);
          }
        }
      }
      getRuleName(index2) {
        if (this._parser != null && index2 >= 0) {
          return this._parser.ruleNames[index2];
        }
        return "<rule " + index2 + ">";
      }
      getEpsilonTarget(config, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {
        switch (t.serializationType) {
          case 3:
            return this.ruleTransition(config, t, contextCache);
          case 10:
            return this.precedenceTransition(config, t, collectPredicates, inContext);
          case 4:
            return this.predTransition(config, t, collectPredicates, inContext);
          case 6:
            return this.actionTransition(config, t);
          case 1:
            return config.transform(t.target, false);
          case 5:
          case 2:
          case 7:
            if (treatEofAsEpsilon) {
              if (t.matches(Token_1.Token.EOF, 0, 1)) {
                return config.transform(t.target, false);
              }
            }
            return void 0;
          default:
            return void 0;
        }
      }
      actionTransition(config, t) {
        if (ParserATNSimulator3.debug) {
          console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
        }
        return config.transform(t.target, false);
      }
      precedenceTransition(config, pt, collectPredicates, inContext) {
        if (ParserATNSimulator3.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
          if (this._parser != null) {
            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
          }
        }
        let c;
        if (collectPredicates && inContext) {
          let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
          c = config.transform(pt.target, false, newSemCtx);
        } else {
          c = config.transform(pt.target, false);
        }
        if (ParserATNSimulator3.debug) {
          console.log("config from pred transition=" + c);
        }
        return c;
      }
      predTransition(config, pt, collectPredicates, inContext) {
        if (ParserATNSimulator3.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
          if (this._parser != null) {
            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
          }
        }
        let c;
        if (collectPredicates && (!pt.isCtxDependent || pt.isCtxDependent && inContext)) {
          let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
          c = config.transform(pt.target, false, newSemCtx);
        } else {
          c = config.transform(pt.target, false);
        }
        if (ParserATNSimulator3.debug) {
          console.log("config from pred transition=" + c);
        }
        return c;
      }
      ruleTransition(config, t, contextCache) {
        if (ParserATNSimulator3.debug) {
          console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
        }
        let returnState = t.followState;
        let newContext;
        if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
          newContext = config.context;
        } else if (contextCache != null) {
          newContext = contextCache.getChild(config.context, returnState.stateNumber);
        } else {
          newContext = config.context.getChild(returnState.stateNumber);
        }
        return config.transform(t.target, false, newContext);
      }
      isConflicted(configset, contextCache) {
        if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {
          return void 0;
        }
        let configs = configset.toArray();
        configs.sort(ParserATNSimulator3.STATE_ALT_SORT_COMPARATOR);
        let exact = !configset.dipsIntoOuterContext;
        let alts = new BitSet_1.BitSet();
        let minAlt = configs[0].alt;
        alts.set(minAlt);
        let currentState = configs[0].state.nonStopStateNumber;
        for (let config of configs) {
          let stateNumber = config.state.nonStopStateNumber;
          if (stateNumber !== currentState) {
            if (config.alt !== minAlt) {
              return void 0;
            }
            currentState = stateNumber;
          }
        }
        let representedAlts;
        if (exact) {
          currentState = configs[0].state.nonStopStateNumber;
          representedAlts = new BitSet_1.BitSet();
          let maxAlt = minAlt;
          for (let config of configs) {
            if (config.state.nonStopStateNumber !== currentState) {
              break;
            }
            let alt = config.alt;
            representedAlts.set(alt);
            maxAlt = alt;
          }
          currentState = configs[0].state.nonStopStateNumber;
          let currentAlt = minAlt;
          for (let config of configs) {
            let stateNumber = config.state.nonStopStateNumber;
            let alt = config.alt;
            if (stateNumber !== currentState) {
              if (currentAlt !== maxAlt) {
                exact = false;
                break;
              }
              currentState = stateNumber;
              currentAlt = minAlt;
            } else if (alt !== currentAlt) {
              if (alt !== representedAlts.nextSetBit(currentAlt + 1)) {
                exact = false;
                break;
              }
              currentAlt = alt;
            }
          }
        }
        currentState = configs[0].state.nonStopStateNumber;
        let firstIndexCurrentState = 0;
        let lastIndexCurrentStateMinAlt = 0;
        let joinedCheckContext = configs[0].context;
        for (let i = 1; i < configs.length; i++) {
          let config = configs[i];
          if (config.alt !== minAlt) {
            break;
          }
          if (config.state.nonStopStateNumber !== currentState) {
            break;
          }
          lastIndexCurrentStateMinAlt = i;
          joinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);
        }
        for (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {
          let config = configs[i];
          let state = config.state;
          alts.set(config.alt);
          if (state.nonStopStateNumber !== currentState) {
            currentState = state.nonStopStateNumber;
            firstIndexCurrentState = i;
            lastIndexCurrentStateMinAlt = i;
            joinedCheckContext = config.context;
            for (let j = firstIndexCurrentState + 1; j < configs.length; j++) {
              let config2 = configs[j];
              if (config2.alt !== minAlt) {
                break;
              }
              if (config2.state.nonStopStateNumber !== currentState) {
                break;
              }
              lastIndexCurrentStateMinAlt = j;
              joinedCheckContext = contextCache.join(joinedCheckContext, config2.context);
            }
            i = lastIndexCurrentStateMinAlt;
            continue;
          }
          let joinedCheckContext2 = config.context;
          let currentAlt = config.alt;
          let lastIndexCurrentStateCurrentAlt = i;
          for (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {
            let config2 = configs[j];
            if (config2.alt !== currentAlt) {
              break;
            }
            if (config2.state.nonStopStateNumber !== currentState) {
              break;
            }
            lastIndexCurrentStateCurrentAlt = j;
            joinedCheckContext2 = contextCache.join(joinedCheckContext2, config2.context);
          }
          i = lastIndexCurrentStateCurrentAlt;
          let check = contextCache.join(joinedCheckContext, joinedCheckContext2);
          if (!joinedCheckContext.equals(check)) {
            return void 0;
          }
          exact = exact && joinedCheckContext.equals(joinedCheckContext2);
        }
        return new ConflictInfo_1.ConflictInfo(alts, exact);
      }
      getConflictingAltsFromConfigSet(configs) {
        let conflictingAlts = configs.conflictingAlts;
        if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          conflictingAlts = new BitSet_1.BitSet();
          conflictingAlts.set(configs.uniqueAlt);
        }
        return conflictingAlts;
      }
      getTokenName(t) {
        if (t === Token_1.Token.EOF) {
          return "EOF";
        }
        let vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        let displayName = vocabulary.getDisplayName(t);
        if (displayName === String(t)) {
          return displayName;
        }
        return displayName + "<" + t + ">";
      }
      getLookaheadName(input) {
        return this.getTokenName(input.LA(1));
      }
      dumpDeadEndConfigs(nvae) {
        console.log("dead end configs: ");
        let deadEndConfigs = nvae.deadEndConfigs;
        if (!deadEndConfigs) {
          return;
        }
        for (let c of deadEndConfigs) {
          let trans = "no edges";
          if (c.state.numberOfOptimizedTransitions > 0) {
            let t = c.state.getOptimizedTransition(0);
            if (t instanceof AtomTransition_1.AtomTransition) {
              trans = "Atom " + this.getTokenName(t._label);
            } else if (t instanceof SetTransition_1.SetTransition) {
              let not = t instanceof NotSetTransition_1.NotSetTransition;
              trans = (not ? "~" : "") + "Set " + t.set.toString();
            }
          }
          console.log(c.toString(this._parser, true) + ":" + trans);
        }
      }
      noViableAlt(input, outerContext, configs, startIndex) {
        return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
      }
      getUniqueAlt(configs) {
        let alt = ATN_1.ATN.INVALID_ALT_NUMBER;
        for (let c of configs) {
          if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {
            alt = c.alt;
          } else if (c.alt !== alt) {
            return ATN_1.ATN.INVALID_ALT_NUMBER;
          }
        }
        return alt;
      }
      configWithAltAtStopState(configs, alt) {
        for (let c of configs) {
          if (c.alt === alt) {
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              return true;
            }
          }
        }
        return false;
      }
      addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {
        assert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);
        let from = fromState;
        let to = this.addDFAState(dfa, toConfigs, contextCache);
        if (contextTransitions != null) {
          for (let context of contextTransitions.toArray()) {
            if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              if (from.configs.isOutermostConfigSet) {
                continue;
              }
            }
            from.setContextSensitive(this.atn);
            from.setContextSymbol(t);
            let next = from.getContextTarget(context);
            if (next != null) {
              from = next;
              continue;
            }
            next = this.addDFAContextState(dfa, from.configs, context, contextCache);
            assert(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);
            from.setContextTarget(context, next);
            from = next;
          }
        }
        if (ParserATNSimulator3.debug) {
          console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
        }
        this.setDFAEdge(from, t, to);
        if (ParserATNSimulator3.debug) {
          console.log("DFA=\n" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : void 0));
        }
        return to;
      }
      setDFAEdge(p, t, q) {
        if (p != null) {
          p.setTarget(t, q);
        }
      }
      addDFAContextState(dfa, configs, returnContext, contextCache) {
        if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          let contextConfigs = new ATNConfigSet_1.ATNConfigSet();
          for (let config of configs) {
            contextConfigs.add(config.appendContext(returnContext, contextCache));
          }
          return this.addDFAState(dfa, contextConfigs, contextCache);
        } else {
          assert(!configs.isOutermostConfigSet, "Shouldn't be adding a duplicate edge.");
          configs = configs.clone(true);
          configs.isOutermostConfigSet = true;
          return this.addDFAState(dfa, configs, contextCache);
        }
      }
      addDFAState(dfa, configs, contextCache) {
        let enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;
        if (enableDfa) {
          if (!configs.isReadOnly) {
            configs.optimizeConfigs(this);
          }
          let proposed = this.createDFAState(dfa, configs);
          let existing = dfa.states.get(proposed);
          if (existing != null) {
            return existing;
          }
        }
        if (!configs.isReadOnly) {
          if (configs.conflictInfo == null) {
            configs.conflictInfo = this.isConflicted(configs, contextCache);
          }
        }
        let newState = this.createDFAState(dfa, configs.clone(true));
        let decisionState = this.atn.getDecisionState(dfa.decision);
        let predictedAlt = this.getUniqueAlt(configs);
        if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);
        } else if (configs.conflictingAlts != null) {
          let conflictingAlts = configs.conflictingAlts;
          if (conflictingAlts) {
            newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));
          }
        }
        if (newState.isAcceptState && configs.hasSemanticContext) {
          this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);
        }
        if (!enableDfa) {
          return newState;
        }
        let added = dfa.addState(newState);
        if (ParserATNSimulator3.debug && added === newState) {
          console.log("adding new DFA state: " + newState);
        }
        return added;
      }
      createDFAState(dfa, configs) {
        return new DFAState_1.DFAState(configs);
      }
      reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
        if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + conflictState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportAttemptingFullContext) {
            listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
          }
        }
      }
      reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
        if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportContextSensitivity decision=" + dfa.decision + ":" + acceptState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportContextSensitivity) {
            listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);
          }
        }
      }
      reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportAmbiguity) {
            listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
          }
        }
      }
      getReturnState(context) {
        if (context.isEmpty) {
          return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
        }
        let state = this.atn.states[context.invokingState];
        let transition = state.transition(0);
        return transition.followState.stateNumber;
      }
      skipTailCalls(context) {
        if (!this.optimize_tail_calls) {
          return context;
        }
        while (!context.isEmpty) {
          let state = this.atn.states[context.invokingState];
          assert(state.numberOfTransitions === 1 && state.transition(0).serializationType === 3);
          let transition = state.transition(0);
          if (!transition.tailCall) {
            break;
          }
          context = context.parent;
        }
        return context;
      }
      get parser() {
        return this._parser;
      }
    };
    ParserATNSimulator2.debug = false;
    ParserATNSimulator2.dfa_debug = false;
    ParserATNSimulator2.retry_debug = false;
    ParserATNSimulator2.STATE_ALT_SORT_COMPARATOR = (o1, o2) => {
      let diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;
      if (diff !== 0) {
        return diff;
      }
      diff = o1.alt - o2.alt;
      if (diff !== 0) {
        return diff;
      }
      return 0;
    };
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "predictionMode", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "getPredictionMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "setPredictionMode", null);
    __decorate([
      Decorators_1.Override
    ], ParserATNSimulator2.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "adaptivePredict", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getStartState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "execDFA", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "execATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "handleNoViableAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "computeTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "removeAllConfigsNotInRuleStopState", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "computeStartState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "applyPrecedenceFilter", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getReachableTarget", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getPredsForAmbigAlts", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "evalSemanticContext", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "evalSemanticContextImpl", null);
    __decorate([
      __param(1, Decorators_1.NotNull),
      __param(4, Decorators_1.Nullable)
    ], ParserATNSimulator2.prototype, "closure", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.Nullable),
      __param(3, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "closureImpl", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "getRuleName", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getEpsilonTarget", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "actionTransition", null);
    __decorate([
      Decorators_1.Nullable,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "precedenceTransition", null);
    __decorate([
      Decorators_1.Nullable,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "predTransition", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.Nullable)
    ], ParserATNSimulator2.prototype, "ruleTransition", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "isConflicted", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "getTokenName", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "dumpDeadEndConfigs", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "noViableAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getUniqueAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "configWithAltAtStopState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "addDFAEdge", null);
    __decorate([
      __param(0, Decorators_1.Nullable),
      __param(2, Decorators_1.Nullable)
    ], ParserATNSimulator2.prototype, "setDFAEdge", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "addDFAContextState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "addDFAState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "createDFAState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "reportAttemptingFullContext", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "reportContextSensitivity", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "reportAmbiguity", null);
    ParserATNSimulator2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2);
    exports.ParserATNSimulator = ParserATNSimulator2;
  }
});

// node_modules/antlr4ts/atn/PlusBlockStartState.js
var require_PlusBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/PlusBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlusBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var PlusBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.PLUS_BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PlusBlockStartState.prototype, "stateType", null);
    exports.PlusBlockStartState = PlusBlockStartState;
  }
});

// node_modules/antlr4ts/atn/PlusLoopbackState.js
var require_PlusLoopbackState = __commonJS({
  "node_modules/antlr4ts/atn/PlusLoopbackState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlusLoopbackState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var PlusLoopbackState = class extends DecisionState_1.DecisionState {
      get stateType() {
        return ATNStateType_1.ATNStateType.PLUS_LOOP_BACK;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PlusLoopbackState.prototype, "stateType", null);
    exports.PlusLoopbackState = PlusLoopbackState;
  }
});

// node_modules/antlr4ts/atn/PrecedencePredicateTransition.js
var require_PrecedencePredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/PrecedencePredicateTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrecedencePredicateTransition = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Decorators_1 = require_Decorators();
    var SemanticContext_1 = require_SemanticContext();
    var PrecedencePredicateTransition = class PrecedencePredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
      constructor(target, precedence) {
        super(target);
        this.precedence = precedence;
      }
      get serializationType() {
        return 10;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      get predicate() {
        return new SemanticContext_1.SemanticContext.PrecedencePredicate(this.precedence);
      }
      toString() {
        return this.precedence + " >= _p";
      }
    };
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "toString", null);
    PrecedencePredicateTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], PrecedencePredicateTransition);
    exports.PrecedencePredicateTransition = PrecedencePredicateTransition;
  }
});

// node_modules/antlr4ts/atn/RangeTransition.js
var require_RangeTransition = __commonJS({
  "node_modules/antlr4ts/atn/RangeTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RangeTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var RangeTransition = class RangeTransition extends Transition_1.Transition {
      constructor(target, from, to) {
        super(target);
        this.from = from;
        this.to = to;
      }
      get serializationType() {
        return 2;
      }
      get label() {
        return IntervalSet_1.IntervalSet.of(this.from, this.to);
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= this.from && symbol <= this.to;
      }
      toString() {
        return "'" + String.fromCodePoint(this.from) + "'..'" + String.fromCodePoint(this.to) + "'";
      }
    };
    __decorate([
      Decorators_1.Override
    ], RangeTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], RangeTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], RangeTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], RangeTransition.prototype, "toString", null);
    RangeTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], RangeTransition);
    exports.RangeTransition = RangeTransition;
  }
});

// node_modules/antlr4ts/atn/RuleStartState.js
var require_RuleStartState = __commonJS({
  "node_modules/antlr4ts/atn/RuleStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleStartState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var RuleStartState = class extends ATNState_1.ATNState {
      constructor() {
        super(...arguments);
        this.isPrecedenceRule = false;
        this.leftFactored = false;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.RULE_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleStartState.prototype, "stateType", null);
    exports.RuleStartState = RuleStartState;
  }
});

// node_modules/antlr4ts/atn/StarBlockStartState.js
var require_StarBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/StarBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var StarBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarBlockStartState.prototype, "stateType", null);
    exports.StarBlockStartState = StarBlockStartState;
  }
});

// node_modules/antlr4ts/atn/StarLoopbackState.js
var require_StarLoopbackState = __commonJS({
  "node_modules/antlr4ts/atn/StarLoopbackState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarLoopbackState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var StarLoopbackState = class extends ATNState_1.ATNState {
      get loopEntryState() {
        return this.transition(0).target;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_LOOP_BACK;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarLoopbackState.prototype, "stateType", null);
    exports.StarLoopbackState = StarLoopbackState;
  }
});

// node_modules/antlr4ts/atn/TokensStartState.js
var require_TokensStartState = __commonJS({
  "node_modules/antlr4ts/atn/TokensStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokensStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var TokensStartState = class extends DecisionState_1.DecisionState {
      get stateType() {
        return ATNStateType_1.ATNStateType.TOKEN_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], TokensStartState.prototype, "stateType", null);
    exports.TokensStartState = TokensStartState;
  }
});

// node_modules/antlr4ts/misc/UUID.js
var require_UUID = __commonJS({
  "node_modules/antlr4ts/misc/UUID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UUID = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var UUID = class {
      constructor(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {
        this.data = new Uint32Array(4);
        this.data[0] = mostSigBits;
        this.data[1] = moreSigBits;
        this.data[2] = lessSigBits;
        this.data[3] = leastSigBits;
      }
      static fromString(data) {
        if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {
          throw new Error("Incorrectly formatted UUID");
        }
        let segments = data.split("-");
        let mostSigBits = parseInt(segments[0], 16);
        let moreSigBits = (parseInt(segments[1], 16) << 16 >>> 0) + parseInt(segments[2], 16);
        let lessSigBits = (parseInt(segments[3], 16) << 16 >>> 0) + parseInt(segments[4].substr(0, 4), 16);
        let leastSigBits = parseInt(segments[4].substr(-8), 16);
        return new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
      }
      hashCode() {
        return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof UUID)) {
          return false;
        }
        return this.data[0] === obj.data[0] && this.data[1] === obj.data[1] && this.data[2] === obj.data[2] && this.data[3] === obj.data[3];
      }
      toString() {
        return ("00000000" + this.data[0].toString(16)).substr(-8) + "-" + ("0000" + (this.data[1] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[1].toString(16)).substr(-4) + "-" + ("0000" + (this.data[2] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[2].toString(16)).substr(-4) + ("00000000" + this.data[3].toString(16)).substr(-8);
      }
    };
    exports.UUID = UUID;
  }
});

// node_modules/antlr4ts/atn/ATNDeserializer.js
var require_ATNDeserializer = __commonJS({
  "node_modules/antlr4ts/atn/ATNDeserializer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNDeserializer = void 0;
    var ActionTransition_1 = require_ActionTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATN_1 = require_ATN();
    var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
    var ATNStateType_1 = require_ATNStateType();
    var AtomTransition_1 = require_AtomTransition();
    var BasicBlockStartState_1 = require_BasicBlockStartState();
    var BasicState_1 = require_BasicState();
    var BitSet_1 = require_BitSet();
    var BlockEndState_1 = require_BlockEndState();
    var BlockStartState_1 = require_BlockStartState();
    var DecisionState_1 = require_DecisionState();
    var DFA_1 = require_DFA();
    var EpsilonTransition_1 = require_EpsilonTransition();
    var IntervalSet_1 = require_IntervalSet();
    var InvalidState_1 = require_InvalidState();
    var LexerChannelAction_1 = require_LexerChannelAction();
    var LexerCustomAction_1 = require_LexerCustomAction();
    var LexerModeAction_1 = require_LexerModeAction();
    var LexerMoreAction_1 = require_LexerMoreAction();
    var LexerPopModeAction_1 = require_LexerPopModeAction();
    var LexerPushModeAction_1 = require_LexerPushModeAction();
    var LexerSkipAction_1 = require_LexerSkipAction();
    var LexerTypeAction_1 = require_LexerTypeAction();
    var LoopEndState_1 = require_LoopEndState();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var PlusBlockStartState_1 = require_PlusBlockStartState();
    var PlusLoopbackState_1 = require_PlusLoopbackState();
    var PrecedencePredicateTransition_1 = require_PrecedencePredicateTransition();
    var PredicateTransition_1 = require_PredicateTransition();
    var RangeTransition_1 = require_RangeTransition();
    var RuleStartState_1 = require_RuleStartState();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var SetTransition_1 = require_SetTransition();
    var StarBlockStartState_1 = require_StarBlockStartState();
    var StarLoopbackState_1 = require_StarLoopbackState();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var Token_1 = require_Token();
    var TokensStartState_1 = require_TokensStartState();
    var UUID_1 = require_UUID();
    var WildcardTransition_1 = require_WildcardTransition();
    var UnicodeDeserializingMode;
    (function(UnicodeDeserializingMode2) {
      UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_BMP"] = 0] = "UNICODE_BMP";
      UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_SMP"] = 1] = "UNICODE_SMP";
    })(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));
    var ATNDeserializer3 = class {
      constructor(deserializationOptions) {
        if (deserializationOptions === void 0) {
          deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;
        }
        this.deserializationOptions = deserializationOptions;
      }
      static get SERIALIZED_VERSION() {
        return 3;
      }
      static isFeatureSupported(feature, actualUuid) {
        let featureIndex = ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));
        if (featureIndex < 0) {
          return false;
        }
        return ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;
      }
      static getUnicodeDeserializer(mode) {
        if (mode === 0) {
          return {
            readUnicode: (data, p) => {
              return ATNDeserializer3.toInt(data[p]);
            },
            size: 1
          };
        } else {
          return {
            readUnicode: (data, p) => {
              return ATNDeserializer3.toInt32(data, p);
            },
            size: 2
          };
        }
      }
      deserialize(data) {
        data = data.slice(0);
        for (let i = 1; i < data.length; i++) {
          data[i] = data[i] - 2 & 65535;
        }
        let p = 0;
        let version = ATNDeserializer3.toInt(data[p++]);
        if (version !== ATNDeserializer3.SERIALIZED_VERSION) {
          let reason = `Could not deserialize ATN with version ${version} (expected ${ATNDeserializer3.SERIALIZED_VERSION}).`;
          throw new Error(reason);
        }
        let uuid = ATNDeserializer3.toUUID(data, p);
        p += 8;
        if (ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {
          let reason = `Could not deserialize ATN with UUID ${uuid} (expected ${ATNDeserializer3.SERIALIZED_UUID} or a legacy UUID).`;
          throw new Error(reason);
        }
        let supportsLexerActions = ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_LEXER_ACTIONS, uuid);
        let grammarType = ATNDeserializer3.toInt(data[p++]);
        let maxTokenType = ATNDeserializer3.toInt(data[p++]);
        let atn = new ATN_1.ATN(grammarType, maxTokenType);
        let loopBackStateNumbers = [];
        let endStateNumbers = [];
        let nstates = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nstates; i++) {
          let stype = ATNDeserializer3.toInt(data[p++]);
          if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {
            atn.addState(new InvalidState_1.InvalidState());
            continue;
          }
          let ruleIndex = ATNDeserializer3.toInt(data[p++]);
          if (ruleIndex === 65535) {
            ruleIndex = -1;
          }
          let s = this.stateFactory(stype, ruleIndex);
          if (stype === ATNStateType_1.ATNStateType.LOOP_END) {
            let loopBackStateNumber = ATNDeserializer3.toInt(data[p++]);
            loopBackStateNumbers.push([s, loopBackStateNumber]);
          } else if (s instanceof BlockStartState_1.BlockStartState) {
            let endStateNumber = ATNDeserializer3.toInt(data[p++]);
            endStateNumbers.push([s, endStateNumber]);
          }
          atn.addState(s);
        }
        for (let pair of loopBackStateNumbers) {
          pair[0].loopBackState = atn.states[pair[1]];
        }
        for (let pair of endStateNumbers) {
          pair[0].endState = atn.states[pair[1]];
        }
        let numNonGreedyStates = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < numNonGreedyStates; i++) {
          let stateNumber = ATNDeserializer3.toInt(data[p++]);
          atn.states[stateNumber].nonGreedy = true;
        }
        let numSllDecisions = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < numSllDecisions; i++) {
          let stateNumber = ATNDeserializer3.toInt(data[p++]);
          atn.states[stateNumber].sll = true;
        }
        let numPrecedenceStates = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < numPrecedenceStates; i++) {
          let stateNumber = ATNDeserializer3.toInt(data[p++]);
          atn.states[stateNumber].isPrecedenceRule = true;
        }
        let nrules = ATNDeserializer3.toInt(data[p++]);
        if (atn.grammarType === 0) {
          atn.ruleToTokenType = new Int32Array(nrules);
        }
        atn.ruleToStartState = new Array(nrules);
        for (let i = 0; i < nrules; i++) {
          let s = ATNDeserializer3.toInt(data[p++]);
          let startState = atn.states[s];
          startState.leftFactored = ATNDeserializer3.toInt(data[p++]) !== 0;
          atn.ruleToStartState[i] = startState;
          if (atn.grammarType === 0) {
            let tokenType = ATNDeserializer3.toInt(data[p++]);
            if (tokenType === 65535) {
              tokenType = Token_1.Token.EOF;
            }
            atn.ruleToTokenType[i] = tokenType;
            if (!ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_LEXER_ACTIONS, uuid)) {
              let actionIndexIgnored = ATNDeserializer3.toInt(data[p++]);
              if (actionIndexIgnored === 65535) {
                actionIndexIgnored = -1;
              }
            }
          }
        }
        atn.ruleToStopState = new Array(nrules);
        for (let state of atn.states) {
          if (!(state instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          atn.ruleToStopState[state.ruleIndex] = state;
          atn.ruleToStartState[state.ruleIndex].stopState = state;
        }
        let nmodes = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nmodes; i++) {
          let s = ATNDeserializer3.toInt(data[p++]);
          atn.modeToStartState.push(atn.states[s]);
        }
        atn.modeToDFA = new Array(nmodes);
        for (let i = 0; i < nmodes; i++) {
          atn.modeToDFA[i] = new DFA_1.DFA(atn.modeToStartState[i]);
        }
        let sets = [];
        p = this.deserializeSets(data, p, sets, ATNDeserializer3.getUnicodeDeserializer(0));
        if (ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_UNICODE_SMP, uuid)) {
          p = this.deserializeSets(data, p, sets, ATNDeserializer3.getUnicodeDeserializer(1));
        }
        let nedges = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nedges; i++) {
          let src = ATNDeserializer3.toInt(data[p]);
          let trg = ATNDeserializer3.toInt(data[p + 1]);
          let ttype = ATNDeserializer3.toInt(data[p + 2]);
          let arg1 = ATNDeserializer3.toInt(data[p + 3]);
          let arg2 = ATNDeserializer3.toInt(data[p + 4]);
          let arg3 = ATNDeserializer3.toInt(data[p + 5]);
          let trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
          let srcState = atn.states[src];
          srcState.addTransition(trans);
          p += 6;
        }
        let returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({
          hashCode: (o) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,
          equals: (a, b) => {
            return a.stopState === b.stopState && a.returnState === b.returnState && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;
          }
        });
        let returnTransitions = [];
        for (let state of atn.states) {
          let returningToLeftFactored = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;
          for (let i = 0; i < state.numberOfTransitions; i++) {
            let t = state.transition(i);
            if (!(t instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            let ruleTransition = t;
            let returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;
            if (!returningFromLeftFactored && returningToLeftFactored) {
              continue;
            }
            let outermostPrecedenceReturn = -1;
            if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {
              if (ruleTransition.precedence === 0) {
                outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
              }
            }
            let current = { stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn };
            if (returnTransitionsSet.add(current)) {
              returnTransitions.push(current);
            }
          }
        }
        for (let returnTransition of returnTransitions) {
          let transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);
          atn.ruleToStopState[returnTransition.stopState].addTransition(transition);
        }
        for (let state of atn.states) {
          if (state instanceof BlockStartState_1.BlockStartState) {
            if (state.endState === void 0) {
              throw new Error("IllegalStateException");
            }
            if (state.endState.startState !== void 0) {
              throw new Error("IllegalStateException");
            }
            state.endState.startState = state;
          }
          if (state instanceof PlusLoopbackState_1.PlusLoopbackState) {
            let loopbackState = state;
            for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
              let target = loopbackState.transition(i).target;
              if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {
                target.loopBackState = loopbackState;
              }
            }
          } else if (state instanceof StarLoopbackState_1.StarLoopbackState) {
            let loopbackState = state;
            for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
              let target = loopbackState.transition(i).target;
              if (target instanceof StarLoopEntryState_1.StarLoopEntryState) {
                target.loopBackState = loopbackState;
              }
            }
          }
        }
        let ndecisions = ATNDeserializer3.toInt(data[p++]);
        for (let i = 1; i <= ndecisions; i++) {
          let s = ATNDeserializer3.toInt(data[p++]);
          let decState = atn.states[s];
          atn.decisionToState.push(decState);
          decState.decision = i - 1;
        }
        if (atn.grammarType === 0) {
          if (supportsLexerActions) {
            atn.lexerActions = new Array(ATNDeserializer3.toInt(data[p++]));
            for (let i = 0; i < atn.lexerActions.length; i++) {
              let actionType = ATNDeserializer3.toInt(data[p++]);
              let data1 = ATNDeserializer3.toInt(data[p++]);
              if (data1 === 65535) {
                data1 = -1;
              }
              let data2 = ATNDeserializer3.toInt(data[p++]);
              if (data2 === 65535) {
                data2 = -1;
              }
              let lexerAction = this.lexerActionFactory(actionType, data1, data2);
              atn.lexerActions[i] = lexerAction;
            }
          } else {
            let legacyLexerActions = [];
            for (let state of atn.states) {
              for (let i = 0; i < state.numberOfTransitions; i++) {
                let transition = state.transition(i);
                if (!(transition instanceof ActionTransition_1.ActionTransition)) {
                  continue;
                }
                let ruleIndex = transition.ruleIndex;
                let actionIndex = transition.actionIndex;
                let lexerAction = new LexerCustomAction_1.LexerCustomAction(ruleIndex, actionIndex);
                state.setTransition(i, new ActionTransition_1.ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));
                legacyLexerActions.push(lexerAction);
              }
            }
            atn.lexerActions = legacyLexerActions;
          }
        }
        this.markPrecedenceDecisions(atn);
        atn.decisionToDFA = new Array(ndecisions);
        for (let i = 0; i < ndecisions; i++) {
          atn.decisionToDFA[i] = new DFA_1.DFA(atn.decisionToState[i], i);
        }
        if (this.deserializationOptions.isVerifyATN) {
          this.verifyATN(atn);
        }
        if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1) {
          atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);
          for (let i = 0; i < atn.ruleToStartState.length; i++) {
            atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
          }
          for (let i = 0; i < atn.ruleToStartState.length; i++) {
            let bypassStart = new BasicBlockStartState_1.BasicBlockStartState();
            bypassStart.ruleIndex = i;
            atn.addState(bypassStart);
            let bypassStop = new BlockEndState_1.BlockEndState();
            bypassStop.ruleIndex = i;
            atn.addState(bypassStop);
            bypassStart.endState = bypassStop;
            atn.defineDecisionState(bypassStart);
            bypassStop.startState = bypassStart;
            let endState;
            let excludeTransition;
            if (atn.ruleToStartState[i].isPrecedenceRule) {
              endState = void 0;
              for (let state of atn.states) {
                if (state.ruleIndex !== i) {
                  continue;
                }
                if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                  continue;
                }
                let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
                if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {
                  continue;
                }
                if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                  endState = state;
                  break;
                }
              }
              if (!endState) {
                throw new Error("Couldn't identify final state of the precedence rule prefix section.");
              }
              excludeTransition = endState.loopBackState.transition(0);
            } else {
              endState = atn.ruleToStopState[i];
            }
            for (let state of atn.states) {
              for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {
                let transition = state.transition(i2);
                if (transition === excludeTransition) {
                  continue;
                }
                if (transition.target === endState) {
                  transition.target = bypassStop;
                }
              }
            }
            while (atn.ruleToStartState[i].numberOfTransitions > 0) {
              let transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);
              bypassStart.addTransition(transition);
            }
            atn.ruleToStartState[i].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));
            bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));
            let matchState = new BasicState_1.BasicState();
            atn.addState(matchState);
            matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[i]));
            bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
        }
        if (this.deserializationOptions.isOptimize) {
          while (true) {
            let optimizationCount = 0;
            optimizationCount += ATNDeserializer3.inlineSetRules(atn);
            optimizationCount += ATNDeserializer3.combineChainedEpsilons(atn);
            let preserveOrder = atn.grammarType === 0;
            optimizationCount += ATNDeserializer3.optimizeSets(atn, preserveOrder);
            if (optimizationCount === 0) {
              break;
            }
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
        }
        ATNDeserializer3.identifyTailCalls(atn);
        return atn;
      }
      deserializeSets(data, p, sets, unicodeDeserializer) {
        let nsets = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nsets; i++) {
          let nintervals = ATNDeserializer3.toInt(data[p]);
          p++;
          let set = new IntervalSet_1.IntervalSet();
          sets.push(set);
          let containsEof = ATNDeserializer3.toInt(data[p++]) !== 0;
          if (containsEof) {
            set.add(-1);
          }
          for (let j = 0; j < nintervals; j++) {
            let a = unicodeDeserializer.readUnicode(data, p);
            p += unicodeDeserializer.size;
            let b = unicodeDeserializer.readUnicode(data, p);
            p += unicodeDeserializer.size;
            set.add(a, b);
          }
        }
        return p;
      }
      markPrecedenceDecisions(atn) {
        let rulePrecedenceDecisions = /* @__PURE__ */ new Map();
        for (let state of atn.states) {
          if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
            continue;
          }
          if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
            let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
            if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {
              if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                rulePrecedenceDecisions.set(state.ruleIndex, state);
                state.precedenceRuleDecision = true;
                state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);
              }
            }
          }
        }
        for (let precedenceDecision of rulePrecedenceDecisions) {
          for (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {
            if (transition.serializationType !== 1) {
              continue;
            }
            let epsilonTransition = transition;
            if (epsilonTransition.outermostPrecedenceReturn !== -1) {
              continue;
            }
            precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);
          }
        }
      }
      verifyATN(atn) {
        for (let state of atn.states) {
          this.checkCondition(state !== void 0, "ATN states should not be undefined.");
          if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {
            continue;
          }
          this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);
          if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {
            this.checkCondition(state.loopBackState !== void 0);
          }
          if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {
            let starLoopEntryState = state;
            this.checkCondition(starLoopEntryState.loopBackState !== void 0);
            this.checkCondition(starLoopEntryState.numberOfTransitions === 2);
            if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);
              this.checkCondition(!starLoopEntryState.nonGreedy);
            } else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);
              this.checkCondition(starLoopEntryState.nonGreedy);
            } else {
              throw new Error("IllegalStateException");
            }
          }
          if (state instanceof StarLoopbackState_1.StarLoopbackState) {
            this.checkCondition(state.numberOfTransitions === 1);
            this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);
          }
          if (state instanceof LoopEndState_1.LoopEndState) {
            this.checkCondition(state.loopBackState !== void 0);
          }
          if (state instanceof RuleStartState_1.RuleStartState) {
            this.checkCondition(state.stopState !== void 0);
          }
          if (state instanceof BlockStartState_1.BlockStartState) {
            this.checkCondition(state.endState !== void 0);
          }
          if (state instanceof BlockEndState_1.BlockEndState) {
            this.checkCondition(state.startState !== void 0);
          }
          if (state instanceof DecisionState_1.DecisionState) {
            let decisionState = state;
            this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);
          } else {
            this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);
          }
        }
      }
      checkCondition(condition, message) {
        if (!condition) {
          throw new Error("IllegalStateException: " + message);
        }
      }
      static inlineSetRules(atn) {
        let inlinedCalls = 0;
        let ruleToInlineTransition = new Array(atn.ruleToStartState.length);
        for (let i = 0; i < atn.ruleToStartState.length; i++) {
          let startState = atn.ruleToStartState[i];
          let middleState = startState;
          while (middleState.onlyHasEpsilonTransitions && middleState.numberOfOptimizedTransitions === 1 && middleState.getOptimizedTransition(0).serializationType === 1) {
            middleState = middleState.getOptimizedTransition(0).target;
          }
          if (middleState.numberOfOptimizedTransitions !== 1) {
            continue;
          }
          let matchTransition = middleState.getOptimizedTransition(0);
          let matchTarget = matchTransition.target;
          if (matchTransition.isEpsilon || !matchTarget.onlyHasEpsilonTransitions || matchTarget.numberOfOptimizedTransitions !== 1 || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          switch (matchTransition.serializationType) {
            case 5:
            case 2:
            case 7:
              ruleToInlineTransition[i] = matchTransition;
              break;
            case 8:
            case 9:
              continue;
            default:
              continue;
          }
        }
        for (let state of atn.states) {
          if (state.ruleIndex < 0) {
            continue;
          }
          let optimizedTransitions;
          for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
            let transition = state.getOptimizedTransition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            let ruleTransition = transition;
            let effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
            if (effective === void 0) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            if (optimizedTransitions === void 0) {
              optimizedTransitions = [];
              for (let j = 0; j < i; j++) {
                optimizedTransitions.push(state.getOptimizedTransition(i));
              }
            }
            inlinedCalls++;
            let target = ruleTransition.followState;
            let intermediateState = new BasicState_1.BasicState();
            intermediateState.setRuleIndex(target.ruleIndex);
            atn.addState(intermediateState);
            optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));
            switch (effective.serializationType) {
              case 5:
                intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));
                break;
              case 2:
                intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));
                break;
              case 7:
                intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));
                break;
              default:
                throw new Error("UnsupportedOperationException");
            }
          }
          if (optimizedTransitions !== void 0) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              state.addOptimizedTransition(transition);
            }
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + inlinedCalls + " rule invocations by inlining sets.");
        }
        return inlinedCalls;
      }
      static combineChainedEpsilons(atn) {
        let removedEdges = 0;
        for (let state of atn.states) {
          if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {
            continue;
          }
          let optimizedTransitions;
          nextTransition:
            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
              let transition = state.getOptimizedTransition(i);
              let intermediate = transition.target;
              if (transition.serializationType !== 1 || transition.outermostPrecedenceReturn !== -1 || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC || !intermediate.onlyHasEpsilonTransitions) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue nextTransition;
              }
              for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                if (intermediate.getOptimizedTransition(j).serializationType !== 1 || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {
                  if (optimizedTransitions !== void 0) {
                    optimizedTransitions.push(transition);
                  }
                  continue nextTransition;
                }
              }
              removedEdges++;
              if (optimizedTransitions === void 0) {
                optimizedTransitions = [];
                for (let j = 0; j < i; j++) {
                  optimizedTransitions.push(state.getOptimizedTransition(j));
                }
              }
              for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                let target = intermediate.getOptimizedTransition(j).target;
                optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));
              }
            }
          if (optimizedTransitions !== void 0) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              state.addOptimizedTransition(transition);
            }
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + removedEdges + " transitions by combining chained epsilon transitions.");
        }
        return removedEdges;
      }
      static optimizeSets(atn, preserveOrder) {
        if (preserveOrder) {
          return 0;
        }
        let removedPaths = 0;
        let decisions = atn.decisionToState;
        for (let decision of decisions) {
          let setTransitions = new IntervalSet_1.IntervalSet();
          for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
            let epsTransition = decision.getOptimizedTransition(i);
            if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {
              continue;
            }
            if (epsTransition.target.numberOfOptimizedTransitions !== 1) {
              continue;
            }
            let transition = epsTransition.target.getOptimizedTransition(0);
            if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {
              continue;
            }
            if (transition instanceof NotSetTransition_1.NotSetTransition) {
              continue;
            }
            if (transition instanceof AtomTransition_1.AtomTransition || transition instanceof RangeTransition_1.RangeTransition || transition instanceof SetTransition_1.SetTransition) {
              setTransitions.add(i);
            }
          }
          if (setTransitions.size <= 1) {
            continue;
          }
          let optimizedTransitions = [];
          for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
            if (!setTransitions.contains(i)) {
              optimizedTransitions.push(decision.getOptimizedTransition(i));
            }
          }
          let blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;
          let matchSet = new IntervalSet_1.IntervalSet();
          for (let interval of setTransitions.intervals) {
            for (let j = interval.a; j <= interval.b; j++) {
              let matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);
              if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {
                throw new Error("Not yet implemented.");
              } else {
                matchSet.addAll(matchTransition.label);
              }
            }
          }
          let newTransition;
          if (matchSet.intervals.length === 1) {
            if (matchSet.size === 1) {
              newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);
            } else {
              let matchInterval = matchSet.intervals[0];
              newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
            }
          } else {
            newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);
          }
          let setOptimizedState = new BasicState_1.BasicState();
          setOptimizedState.setRuleIndex(decision.ruleIndex);
          atn.addState(setOptimizedState);
          setOptimizedState.addTransition(newTransition);
          optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));
          removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;
          if (decision.isOptimized) {
            while (decision.numberOfOptimizedTransitions > 0) {
              decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);
            }
          }
          for (let transition of optimizedTransitions) {
            decision.addOptimizedTransition(transition);
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + removedPaths + " paths by collapsing sets.");
        }
        return removedPaths;
      }
      static identifyTailCalls(atn) {
        for (let state of atn.states) {
          for (let i = 0; i < state.numberOfTransitions; i++) {
            let transition = state.transition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            transition.tailCall = this.testTailCall(atn, transition, false);
            transition.optimizedTailCall = this.testTailCall(atn, transition, true);
          }
          if (!state.isOptimized) {
            continue;
          }
          for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
            let transition = state.getOptimizedTransition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            transition.tailCall = this.testTailCall(atn, transition, false);
            transition.optimizedTailCall = this.testTailCall(atn, transition, true);
          }
        }
      }
      static testTailCall(atn, transition, optimizedPath) {
        if (!optimizedPath && transition.tailCall) {
          return true;
        }
        if (optimizedPath && transition.optimizedTailCall) {
          return true;
        }
        let reachable = new BitSet_1.BitSet(atn.states.length);
        let worklist = [];
        worklist.push(transition.followState);
        while (true) {
          let state = worklist.pop();
          if (!state) {
            break;
          }
          if (reachable.get(state.stateNumber)) {
            continue;
          }
          if (state instanceof RuleStopState_1.RuleStopState) {
            continue;
          }
          if (!state.onlyHasEpsilonTransitions) {
            return false;
          }
          let transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;
          for (let i = 0; i < transitionCount; i++) {
            let t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);
            if (t.serializationType !== 1) {
              return false;
            }
            worklist.push(t.target);
          }
        }
        return true;
      }
      static toInt(c) {
        return c;
      }
      static toInt32(data, offset) {
        return (data[offset] | data[offset + 1] << 16) >>> 0;
      }
      static toUUID(data, offset) {
        let leastSigBits = ATNDeserializer3.toInt32(data, offset);
        let lessSigBits = ATNDeserializer3.toInt32(data, offset + 2);
        let moreSigBits = ATNDeserializer3.toInt32(data, offset + 4);
        let mostSigBits = ATNDeserializer3.toInt32(data, offset + 6);
        return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
      }
      edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
        let target = atn.states[trg];
        switch (type) {
          case 1:
            return new EpsilonTransition_1.EpsilonTransition(target);
          case 2:
            if (arg3 !== 0) {
              return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);
            } else {
              return new RangeTransition_1.RangeTransition(target, arg1, arg2);
            }
          case 3:
            let rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);
            return rt;
          case 4:
            let pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);
            return pt;
          case 10:
            return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);
          case 5:
            if (arg3 !== 0) {
              return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);
            } else {
              return new AtomTransition_1.AtomTransition(target, arg1);
            }
          case 6:
            let a = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);
            return a;
          case 7:
            return new SetTransition_1.SetTransition(target, sets[arg1]);
          case 8:
            return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);
          case 9:
            return new WildcardTransition_1.WildcardTransition(target);
        }
        throw new Error("The specified transition type is not valid.");
      }
      stateFactory(type, ruleIndex) {
        let s;
        switch (type) {
          case ATNStateType_1.ATNStateType.INVALID_TYPE:
            return new InvalidState_1.InvalidState();
          case ATNStateType_1.ATNStateType.BASIC:
            s = new BasicState_1.BasicState();
            break;
          case ATNStateType_1.ATNStateType.RULE_START:
            s = new RuleStartState_1.RuleStartState();
            break;
          case ATNStateType_1.ATNStateType.BLOCK_START:
            s = new BasicBlockStartState_1.BasicBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
            s = new PlusBlockStartState_1.PlusBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
            s = new StarBlockStartState_1.StarBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.TOKEN_START:
            s = new TokensStartState_1.TokensStartState();
            break;
          case ATNStateType_1.ATNStateType.RULE_STOP:
            s = new RuleStopState_1.RuleStopState();
            break;
          case ATNStateType_1.ATNStateType.BLOCK_END:
            s = new BlockEndState_1.BlockEndState();
            break;
          case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
            s = new StarLoopbackState_1.StarLoopbackState();
            break;
          case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
            s = new StarLoopEntryState_1.StarLoopEntryState();
            break;
          case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
            s = new PlusLoopbackState_1.PlusLoopbackState();
            break;
          case ATNStateType_1.ATNStateType.LOOP_END:
            s = new LoopEndState_1.LoopEndState();
            break;
          default:
            let message = `The specified state type ${type} is not valid.`;
            throw new Error(message);
        }
        s.ruleIndex = ruleIndex;
        return s;
      }
      lexerActionFactory(type, data1, data2) {
        switch (type) {
          case 0:
            return new LexerChannelAction_1.LexerChannelAction(data1);
          case 1:
            return new LexerCustomAction_1.LexerCustomAction(data1, data2);
          case 2:
            return new LexerModeAction_1.LexerModeAction(data1);
          case 3:
            return LexerMoreAction_1.LexerMoreAction.INSTANCE;
          case 4:
            return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;
          case 5:
            return new LexerPushModeAction_1.LexerPushModeAction(data1);
          case 6:
            return LexerSkipAction_1.LexerSkipAction.INSTANCE;
          case 7:
            return new LexerTypeAction_1.LexerTypeAction(data1);
          default:
            let message = `The specified lexer action type ${type} is not valid.`;
            throw new Error(message);
        }
      }
    };
    ATNDeserializer3.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3");
    ATNDeserializer3.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D");
    ATNDeserializer3.ADDED_UNICODE_SMP = UUID_1.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B");
    ATNDeserializer3.SUPPORTED_UUIDS = [
      ATNDeserializer3.BASE_SERIALIZED_UUID,
      ATNDeserializer3.ADDED_LEXER_ACTIONS,
      ATNDeserializer3.ADDED_UNICODE_SMP
    ];
    ATNDeserializer3.SERIALIZED_UUID = ATNDeserializer3.ADDED_UNICODE_SMP;
    __decorate([
      Decorators_1.NotNull
    ], ATNDeserializer3.prototype, "deserializationOptions", void 0);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer3.prototype, "deserialize", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer3.prototype, "markPrecedenceDecisions", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer3.prototype, "edgeFactory", null);
    exports.ATNDeserializer = ATNDeserializer3;
  }
});

// node_modules/antlr4ts/atn/ParseInfo.js
var require_ParseInfo = __commonJS({
  "node_modules/antlr4ts/atn/ParseInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseInfo = void 0;
    var Decorators_1 = require_Decorators();
    var ParseInfo = class ParseInfo {
      constructor(atnSimulator) {
        this.atnSimulator = atnSimulator;
      }
      getDecisionInfo() {
        return this.atnSimulator.getDecisionInfo();
      }
      getLLDecisions() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let LL = [];
        for (let i = 0; i < decisions.length; i++) {
          let fallBack = decisions[i].LL_Fallback;
          if (fallBack > 0) {
            LL.push(i);
          }
        }
        return LL;
      }
      getTotalTimeInPrediction() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let t = 0;
        for (let decision of decisions) {
          t += decision.timeInPrediction;
        }
        return t;
      }
      getTotalSLLLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_TotalLook;
        }
        return k;
      }
      getTotalLLLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.LL_TotalLook;
        }
        return k;
      }
      getTotalSLLATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_ATNTransitions;
        }
        return k;
      }
      getTotalLLATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.LL_ATNTransitions;
        }
        return k;
      }
      getTotalATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_ATNTransitions;
          k += decision.LL_ATNTransitions;
        }
        return k;
      }
      getDFASize(decision) {
        if (decision) {
          let decisionToDFA = this.atnSimulator.atn.decisionToDFA[decision];
          return decisionToDFA.states.size;
        } else {
          let n = 0;
          let decisionToDFA = this.atnSimulator.atn.decisionToDFA;
          for (let i = 0; i < decisionToDFA.length; i++) {
            n += this.getDFASize(i);
          }
          return n;
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParseInfo.prototype, "getDecisionInfo", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseInfo.prototype, "getLLDecisions", null);
    ParseInfo = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParseInfo);
    exports.ParseInfo = ParseInfo;
  }
});

// node_modules/antlr4ts/ProxyParserErrorListener.js
var require_ProxyParserErrorListener = __commonJS({
  "node_modules/antlr4ts/ProxyParserErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyParserErrorListener = void 0;
    var ProxyErrorListener_1 = require_ProxyErrorListener();
    var Decorators_1 = require_Decorators();
    var ProxyParserErrorListener = class extends ProxyErrorListener_1.ProxyErrorListener {
      constructor(delegates) {
        super(delegates);
      }
      reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportAmbiguity) {
            listener.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
          }
        });
      }
      reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportAttemptingFullContext) {
            listener.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
          }
        });
      }
      reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportContextSensitivity) {
            listener.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState);
          }
        });
      }
    };
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportAmbiguity", null);
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportContextSensitivity", null);
    exports.ProxyParserErrorListener = ProxyParserErrorListener;
  }
});

// node_modules/antlr4ts/misc/Character.js
var require_Character = __commonJS({
  "node_modules/antlr4ts/misc/Character.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSupplementaryCodePoint = exports.isLowSurrogate = exports.isHighSurrogate = void 0;
    function isHighSurrogate(ch) {
      return ch >= 55296 && ch <= 56319;
    }
    exports.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(ch) {
      return ch >= 56320 && ch <= 57343;
    }
    exports.isLowSurrogate = isLowSurrogate;
    function isSupplementaryCodePoint(ch) {
      return ch >= 65536;
    }
    exports.isSupplementaryCodePoint = isSupplementaryCodePoint;
  }
});

// node_modules/antlr4ts/CodePointBuffer.js
var require_CodePointBuffer = __commonJS({
  "node_modules/antlr4ts/CodePointBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodePointBuffer = void 0;
    var assert = require("assert");
    var Character = require_Character();
    var CodePointBuffer = class {
      constructor(buffer, size) {
        this.buffer = buffer;
        this._position = 0;
        this._size = size;
      }
      static withArray(buffer) {
        return new CodePointBuffer(buffer, buffer.length);
      }
      get position() {
        return this._position;
      }
      set position(newPosition) {
        if (newPosition < 0 || newPosition > this._size) {
          throw new RangeError();
        }
        this._position = newPosition;
      }
      get remaining() {
        return this._size - this.position;
      }
      get(offset) {
        return this.buffer[offset];
      }
      array() {
        return this.buffer.slice(0, this._size);
      }
      static builder(initialBufferSize) {
        return new CodePointBuffer.Builder(initialBufferSize);
      }
    };
    exports.CodePointBuffer = CodePointBuffer;
    (function(CodePointBuffer2) {
      let Type;
      (function(Type2) {
        Type2[Type2["BYTE"] = 0] = "BYTE";
        Type2[Type2["CHAR"] = 1] = "CHAR";
        Type2[Type2["INT"] = 2] = "INT";
      })(Type || (Type = {}));
      class Builder {
        constructor(initialBufferSize) {
          this.type = 0;
          this.buffer = new Uint8Array(initialBufferSize);
          this.prevHighSurrogate = -1;
          this.position = 0;
        }
        build() {
          return new CodePointBuffer2(this.buffer, this.position);
        }
        static roundUpToNextPowerOfTwo(i) {
          let nextPowerOfTwo = 32 - Math.clz32(i - 1);
          return Math.pow(2, nextPowerOfTwo);
        }
        ensureRemaining(remainingNeeded) {
          switch (this.type) {
            case 0:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Uint8Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
            case 1:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Uint16Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
            case 2:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Int32Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
          }
        }
        append(utf16In) {
          this.ensureRemaining(utf16In.length);
          this.appendArray(utf16In);
        }
        appendArray(utf16In) {
          switch (this.type) {
            case 0:
              this.appendArrayByte(utf16In);
              break;
            case 1:
              this.appendArrayChar(utf16In);
              break;
            case 2:
              this.appendArrayInt(utf16In);
              break;
          }
        }
        appendArrayByte(utf16In) {
          assert(this.prevHighSurrogate === -1);
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outByte = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            if (c <= 255) {
              outByte[outOffset] = c;
            } else {
              utf16In = utf16In.subarray(inOffset, inLimit);
              this.position = outOffset;
              if (!Character.isHighSurrogate(c)) {
                this.byteToCharBuffer(utf16In.length);
                this.appendArrayChar(utf16In);
                return;
              } else {
                this.byteToIntBuffer(utf16In.length);
                this.appendArrayInt(utf16In);
                return;
              }
            }
            inOffset++;
            outOffset++;
          }
          this.position = outOffset;
        }
        appendArrayChar(utf16In) {
          assert(this.prevHighSurrogate === -1);
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outChar = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            if (!Character.isHighSurrogate(c)) {
              outChar[outOffset] = c;
            } else {
              utf16In = utf16In.subarray(inOffset, inLimit);
              this.position = outOffset;
              this.charToIntBuffer(utf16In.length);
              this.appendArrayInt(utf16In);
              return;
            }
            inOffset++;
            outOffset++;
          }
          this.position = outOffset;
        }
        appendArrayInt(utf16In) {
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outInt = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            inOffset++;
            if (this.prevHighSurrogate !== -1) {
              if (Character.isLowSurrogate(c)) {
                outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0);
                outOffset++;
                this.prevHighSurrogate = -1;
              } else {
                outInt[outOffset] = this.prevHighSurrogate;
                outOffset++;
                if (Character.isHighSurrogate(c)) {
                  this.prevHighSurrogate = c;
                } else {
                  outInt[outOffset] = c;
                  outOffset++;
                  this.prevHighSurrogate = -1;
                }
              }
            } else if (Character.isHighSurrogate(c)) {
              this.prevHighSurrogate = c;
            } else {
              outInt[outOffset] = c;
              outOffset++;
            }
          }
          if (this.prevHighSurrogate !== -1) {
            outInt[outOffset] = this.prevHighSurrogate;
            outOffset++;
          }
          this.position = outOffset;
        }
        byteToCharBuffer(toAppend) {
          let newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 1;
          this.buffer = newBuffer;
        }
        byteToIntBuffer(toAppend) {
          let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 2;
          this.buffer = newBuffer;
        }
        charToIntBuffer(toAppend) {
          let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 2;
          this.buffer = newBuffer;
        }
      }
      CodePointBuffer2.Builder = Builder;
    })(CodePointBuffer = exports.CodePointBuffer || (exports.CodePointBuffer = {}));
  }
});

// node_modules/antlr4ts/CodePointCharStream.js
var require_CodePointCharStream = __commonJS({
  "node_modules/antlr4ts/CodePointCharStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodePointCharStream = void 0;
    var assert = require("assert");
    var IntStream_1 = require_IntStream();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var CodePointCharStream = class {
      constructor(array, position2, remaining, name) {
        assert(position2 === 0);
        this._array = array;
        this._size = remaining;
        this._name = name;
        this._position = 0;
      }
      get internalStorage() {
        return this._array;
      }
      static fromBuffer(codePointBuffer, name) {
        if (name === void 0 || name.length === 0) {
          name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        return new CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);
      }
      consume() {
        if (this._size - this._position === 0) {
          assert(this.LA(1) === IntStream_1.IntStream.EOF);
          throw new RangeError("cannot consume EOF");
        }
        this._position++;
      }
      get index() {
        return this._position;
      }
      get size() {
        return this._size;
      }
      mark() {
        return -1;
      }
      release(marker) {
      }
      seek(index2) {
        this._position = index2;
      }
      get sourceName() {
        return this._name;
      }
      toString() {
        return this.getText(Interval_1.Interval.of(0, this.size - 1));
      }
      LA(i) {
        let offset;
        switch (Math.sign(i)) {
          case -1:
            offset = this.index + i;
            if (offset < 0) {
              return IntStream_1.IntStream.EOF;
            }
            return this._array[offset];
          case 0:
            return 0;
          case 1:
            offset = this.index + i - 1;
            if (offset >= this.size) {
              return IntStream_1.IntStream.EOF;
            }
            return this._array[offset];
        }
        throw new RangeError("Not reached");
      }
      getText(interval) {
        const startIdx = Math.min(interval.a, this.size);
        const len = Math.min(interval.b - interval.a + 1, this.size - startIdx);
        if (this._array instanceof Int32Array) {
          return String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));
        } else {
          return String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));
        }
      }
    };
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "toString", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "LA", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "getText", null);
    exports.CodePointCharStream = CodePointCharStream;
  }
});

// node_modules/antlr4ts/CharStreams.js
var require_CharStreams = __commonJS({
  "node_modules/antlr4ts/CharStreams.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CharStreams = void 0;
    var CodePointBuffer_1 = require_CodePointBuffer();
    var CodePointCharStream_1 = require_CodePointCharStream();
    var IntStream_1 = require_IntStream();
    var CharStreams;
    (function(CharStreams2) {
      function fromString(s, sourceName) {
        if (sourceName === void 0 || sourceName.length === 0) {
          sourceName = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        let codePointBufferBuilder = CodePointBuffer_1.CodePointBuffer.builder(s.length);
        let cb = new Uint16Array(s.length);
        for (let i = 0; i < s.length; i++) {
          cb[i] = s.charCodeAt(i);
        }
        codePointBufferBuilder.append(cb);
        return CodePointCharStream_1.CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);
      }
      CharStreams2.fromString = fromString;
    })(CharStreams = exports.CharStreams || (exports.CharStreams = {}));
  }
});

// node_modules/antlr4ts/BufferedTokenStream.js
var require_BufferedTokenStream = __commonJS({
  "node_modules/antlr4ts/BufferedTokenStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BufferedTokenStream = void 0;
    var assert = require("assert");
    var CommonToken_1 = require_CommonToken();
    var Interval_1 = require_Interval();
    var Lexer_1 = require_Lexer();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var BufferedTokenStream = class BufferedTokenStream {
      constructor(tokenSource) {
        this.tokens = [];
        this.p = -1;
        this.fetchedEOF = false;
        if (tokenSource == null) {
          throw new Error("tokenSource cannot be null");
        }
        this._tokenSource = tokenSource;
      }
      get tokenSource() {
        return this._tokenSource;
      }
      set tokenSource(tokenSource) {
        this._tokenSource = tokenSource;
        this.tokens.length = 0;
        this.p = -1;
        this.fetchedEOF = false;
      }
      get index() {
        return this.p;
      }
      mark() {
        return 0;
      }
      release(marker) {
      }
      seek(index2) {
        this.lazyInit();
        this.p = this.adjustSeekIndex(index2);
      }
      get size() {
        return this.tokens.length;
      }
      consume() {
        let skipEofCheck;
        if (this.p >= 0) {
          if (this.fetchedEOF) {
            skipEofCheck = this.p < this.tokens.length - 1;
          } else {
            skipEofCheck = this.p < this.tokens.length;
          }
        } else {
          skipEofCheck = false;
        }
        if (!skipEofCheck && this.LA(1) === Token_1.Token.EOF) {
          throw new Error("cannot consume EOF");
        }
        if (this.sync(this.p + 1)) {
          this.p = this.adjustSeekIndex(this.p + 1);
        }
      }
      sync(i) {
        assert(i >= 0);
        let n = i - this.tokens.length + 1;
        if (n > 0) {
          let fetched = this.fetch(n);
          return fetched >= n;
        }
        return true;
      }
      fetch(n) {
        if (this.fetchedEOF) {
          return 0;
        }
        for (let i = 0; i < n; i++) {
          let t = this.tokenSource.nextToken();
          if (this.isWritableToken(t)) {
            t.tokenIndex = this.tokens.length;
          }
          this.tokens.push(t);
          if (t.type === Token_1.Token.EOF) {
            this.fetchedEOF = true;
            return i + 1;
          }
        }
        return n;
      }
      get(i) {
        if (i < 0 || i >= this.tokens.length) {
          throw new RangeError("token index " + i + " out of range 0.." + (this.tokens.length - 1));
        }
        return this.tokens[i];
      }
      getRange(start, stop) {
        if (start < 0 || stop < 0) {
          return [];
        }
        this.lazyInit();
        let subset = new Array();
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        for (let i = start; i <= stop; i++) {
          let t = this.tokens[i];
          if (t.type === Token_1.Token.EOF) {
            break;
          }
          subset.push(t);
        }
        return subset;
      }
      LA(i) {
        let token = this.LT(i);
        if (!token) {
          return Token_1.Token.INVALID_TYPE;
        }
        return token.type;
      }
      tryLB(k) {
        if (this.p - k < 0) {
          return void 0;
        }
        return this.tokens[this.p - k];
      }
      LT(k) {
        let result = this.tryLT(k);
        if (result === void 0) {
          throw new RangeError("requested lookback index out of range");
        }
        return result;
      }
      tryLT(k) {
        this.lazyInit();
        if (k === 0) {
          throw new RangeError("0 is not a valid lookahead index");
        }
        if (k < 0) {
          return this.tryLB(-k);
        }
        let i = this.p + k - 1;
        this.sync(i);
        if (i >= this.tokens.length) {
          return this.tokens[this.tokens.length - 1];
        }
        return this.tokens[i];
      }
      adjustSeekIndex(i) {
        return i;
      }
      lazyInit() {
        if (this.p === -1) {
          this.setup();
        }
      }
      setup() {
        this.sync(0);
        this.p = this.adjustSeekIndex(0);
      }
      getTokens(start, stop, types) {
        this.lazyInit();
        if (start === void 0) {
          assert(stop === void 0 && types === void 0);
          return this.tokens;
        } else if (stop === void 0) {
          stop = this.tokens.length - 1;
        }
        if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
          throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
        }
        if (start > stop) {
          return [];
        }
        if (types === void 0) {
          return this.tokens.slice(start, stop + 1);
        } else if (typeof types === "number") {
          types = (/* @__PURE__ */ new Set()).add(types);
        }
        let typesSet = types;
        let filteredTokens = this.tokens.slice(start, stop + 1);
        filteredTokens = filteredTokens.filter((value2) => typesSet.has(value2.type));
        return filteredTokens;
      }
      nextTokenOnChannel(i, channel) {
        this.sync(i);
        if (i >= this.size) {
          return this.size - 1;
        }
        let token = this.tokens[i];
        while (token.channel !== channel) {
          if (token.type === Token_1.Token.EOF) {
            return i;
          }
          i++;
          this.sync(i);
          token = this.tokens[i];
        }
        return i;
      }
      previousTokenOnChannel(i, channel) {
        this.sync(i);
        if (i >= this.size) {
          return this.size - 1;
        }
        while (i >= 0) {
          let token = this.tokens[i];
          if (token.type === Token_1.Token.EOF || token.channel === channel) {
            return i;
          }
          i--;
        }
        return i;
      }
      getHiddenTokensToRight(tokenIndex, channel = -1) {
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
        }
        let nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
        let to;
        let from = tokenIndex + 1;
        if (nextOnChannel === -1) {
          to = this.size - 1;
        } else {
          to = nextOnChannel;
        }
        return this.filterForChannel(from, to, channel);
      }
      getHiddenTokensToLeft(tokenIndex, channel = -1) {
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
        }
        if (tokenIndex === 0) {
          return [];
        }
        let prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
        if (prevOnChannel === tokenIndex - 1) {
          return [];
        }
        let from = prevOnChannel + 1;
        let to = tokenIndex - 1;
        return this.filterForChannel(from, to, channel);
      }
      filterForChannel(from, to, channel) {
        let hidden = new Array();
        for (let i = from; i <= to; i++) {
          let t = this.tokens[i];
          if (channel === -1) {
            if (t.channel !== Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL) {
              hidden.push(t);
            }
          } else {
            if (t.channel === channel) {
              hidden.push(t);
            }
          }
        }
        return hidden;
      }
      get sourceName() {
        return this.tokenSource.sourceName;
      }
      getText(interval) {
        if (interval === void 0) {
          interval = Interval_1.Interval.of(0, this.size - 1);
        } else if (!(interval instanceof Interval_1.Interval)) {
          interval = interval.sourceInterval;
        }
        let start = interval.a;
        let stop = interval.b;
        if (start < 0 || stop < 0) {
          return "";
        }
        this.fill();
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        let buf = "";
        for (let i = start; i <= stop; i++) {
          let t = this.tokens[i];
          if (t.type === Token_1.Token.EOF) {
            break;
          }
          buf += t.text;
        }
        return buf.toString();
      }
      getTextFromRange(start, stop) {
        if (this.isToken(start) && this.isToken(stop)) {
          return this.getText(Interval_1.Interval.of(start.tokenIndex, stop.tokenIndex));
        }
        return "";
      }
      fill() {
        this.lazyInit();
        const blockSize = 1e3;
        while (true) {
          let fetched = this.fetch(blockSize);
          if (fetched < blockSize) {
            return;
          }
        }
      }
      isWritableToken(t) {
        return t instanceof CommonToken_1.CommonToken;
      }
      isToken(t) {
        return t instanceof CommonToken_1.CommonToken;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], BufferedTokenStream.prototype, "_tokenSource", void 0);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "get", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "LA", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "LT", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "sourceName", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "getText", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "getTextFromRange", null);
    BufferedTokenStream = __decorate([
      __param(0, Decorators_1.NotNull)
    ], BufferedTokenStream);
    exports.BufferedTokenStream = BufferedTokenStream;
  }
});

// node_modules/antlr4ts/CommonTokenStream.js
var require_CommonTokenStream = __commonJS({
  "node_modules/antlr4ts/CommonTokenStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonTokenStream = void 0;
    var BufferedTokenStream_1 = require_BufferedTokenStream();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var CommonTokenStream2 = class CommonTokenStream extends BufferedTokenStream_1.BufferedTokenStream {
      constructor(tokenSource, channel = Token_1.Token.DEFAULT_CHANNEL) {
        super(tokenSource);
        this.channel = channel;
      }
      adjustSeekIndex(i) {
        return this.nextTokenOnChannel(i, this.channel);
      }
      tryLB(k) {
        if (this.p - k < 0) {
          return void 0;
        }
        let i = this.p;
        let n = 1;
        while (n <= k && i > 0) {
          i = this.previousTokenOnChannel(i - 1, this.channel);
          n++;
        }
        if (i < 0) {
          return void 0;
        }
        return this.tokens[i];
      }
      tryLT(k) {
        this.lazyInit();
        if (k === 0) {
          throw new RangeError("0 is not a valid lookahead index");
        }
        if (k < 0) {
          return this.tryLB(-k);
        }
        let i = this.p;
        let n = 1;
        while (n < k) {
          if (this.sync(i + 1)) {
            i = this.nextTokenOnChannel(i + 1, this.channel);
          }
          n++;
        }
        return this.tokens[i];
      }
      getNumberOfOnChannelTokens() {
        let n = 0;
        this.fill();
        for (let t of this.tokens) {
          if (t.channel === this.channel) {
            n++;
          }
          if (t.type === Token_1.Token.EOF) {
            break;
          }
        }
        return n;
      }
    };
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "adjustSeekIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "tryLB", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "tryLT", null);
    CommonTokenStream2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], CommonTokenStream2);
    exports.CommonTokenStream = CommonTokenStream2;
  }
});

// node_modules/antlr4ts/ListTokenSource.js
var require_ListTokenSource = __commonJS({
  "node_modules/antlr4ts/ListTokenSource.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListTokenSource = void 0;
    var CommonTokenFactory_1 = require_CommonTokenFactory();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var ListTokenSource = class ListTokenSource {
      constructor(tokens, sourceName) {
        this.i = 0;
        this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
        if (tokens == null) {
          throw new Error("tokens cannot be null");
        }
        this.tokens = tokens;
        this._sourceName = sourceName;
      }
      get charPositionInLine() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].charPositionInLine;
        } else if (this.eofToken != null) {
          return this.eofToken.charPositionInLine;
        } else if (this.tokens.length > 0) {
          let lastToken = this.tokens[this.tokens.length - 1];
          let tokenText = lastToken.text;
          if (tokenText != null) {
            let lastNewLine = tokenText.lastIndexOf("\n");
            if (lastNewLine >= 0) {
              return tokenText.length - lastNewLine - 1;
            }
          }
          return lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;
        }
        return 0;
      }
      nextToken() {
        if (this.i >= this.tokens.length) {
          if (this.eofToken == null) {
            let start = -1;
            if (this.tokens.length > 0) {
              let previousStop = this.tokens[this.tokens.length - 1].stopIndex;
              if (previousStop !== -1) {
                start = previousStop + 1;
              }
            }
            let stop = Math.max(-1, start - 1);
            this.eofToken = this._factory.create({ source: this, stream: this.inputStream }, Token_1.Token.EOF, "EOF", Token_1.Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);
          }
          return this.eofToken;
        }
        let t = this.tokens[this.i];
        if (this.i === this.tokens.length - 1 && t.type === Token_1.Token.EOF) {
          this.eofToken = t;
        }
        this.i++;
        return t;
      }
      get line() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].line;
        } else if (this.eofToken != null) {
          return this.eofToken.line;
        } else if (this.tokens.length > 0) {
          let lastToken = this.tokens[this.tokens.length - 1];
          let line = lastToken.line;
          let tokenText = lastToken.text;
          if (tokenText != null) {
            for (let i = 0; i < tokenText.length; i++) {
              if (tokenText.charAt(i) === "\n") {
                line++;
              }
            }
          }
          return line;
        }
        return 1;
      }
      get inputStream() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].inputStream;
        } else if (this.eofToken != null) {
          return this.eofToken.inputStream;
        } else if (this.tokens.length > 0) {
          return this.tokens[this.tokens.length - 1].inputStream;
        }
        return void 0;
      }
      get sourceName() {
        if (this._sourceName) {
          return this._sourceName;
        }
        let inputStream = this.inputStream;
        if (inputStream != null) {
          return inputStream.sourceName;
        }
        return "List";
      }
      set tokenFactory(factory) {
        this._factory = factory;
      }
      get tokenFactory() {
        return this._factory;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "nextToken", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ListTokenSource.prototype, "tokenFactory", null);
    ListTokenSource = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ListTokenSource);
    exports.ListTokenSource = ListTokenSource;
  }
});

// node_modules/antlr4ts/misc/MultiMap.js
var require_MultiMap = __commonJS({
  "node_modules/antlr4ts/misc/MultiMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiMap = void 0;
    var MultiMap = class extends Map {
      constructor() {
        super();
      }
      map(key, value2) {
        let elementsForKey = super.get(key);
        if (!elementsForKey) {
          elementsForKey = [];
          super.set(key, elementsForKey);
        }
        elementsForKey.push(value2);
      }
      getPairs() {
        let pairs = [];
        this.forEach((values, key) => {
          values.forEach((v) => {
            pairs.push([key, v]);
          });
        });
        return pairs;
      }
    };
    exports.MultiMap = MultiMap;
  }
});

// node_modules/antlr4ts/misc/ParseCancellationException.js
var require_ParseCancellationException = __commonJS({
  "node_modules/antlr4ts/misc/ParseCancellationException.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseCancellationException = void 0;
    var ParseCancellationException = class extends Error {
      constructor(cause) {
        super(cause.message);
        this.cause = cause;
        this.stack = cause.stack;
      }
      getCause() {
        return this.cause;
      }
    };
    exports.ParseCancellationException = ParseCancellationException;
  }
});

// node_modules/antlr4ts/InterpreterRuleContext.js
var require_InterpreterRuleContext = __commonJS({
  "node_modules/antlr4ts/InterpreterRuleContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InterpreterRuleContext = void 0;
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var InterpreterRuleContext = class extends ParserRuleContext_1.ParserRuleContext {
      constructor(ruleIndex, parent, invokingStateNumber) {
        if (invokingStateNumber !== void 0) {
          super(parent, invokingStateNumber);
        } else {
          super();
        }
        this._ruleIndex = ruleIndex;
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InterpreterRuleContext.prototype, "ruleIndex", null);
    exports.InterpreterRuleContext = InterpreterRuleContext;
  }
});

// node_modules/antlr4ts/ParserInterpreter.js
var require_ParserInterpreter = __commonJS({
  "node_modules/antlr4ts/ParserInterpreter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserInterpreter = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var BitSet_1 = require_BitSet();
    var FailedPredicateException_1 = require_FailedPredicateException();
    var InputMismatchException_1 = require_InputMismatchException();
    var InterpreterRuleContext_1 = require_InterpreterRuleContext();
    var LoopEndState_1 = require_LoopEndState();
    var Decorators_1 = require_Decorators();
    var Decorators_2 = require_Decorators();
    var Parser_1 = require_Parser();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var RecognitionException_1 = require_RecognitionException();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var Token_1 = require_Token();
    var ParserInterpreter = class ParserInterpreter2 extends Parser_1.Parser {
      constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
        super(grammarFileName instanceof ParserInterpreter2 ? grammarFileName.inputStream : input);
        this._parentContextStack = [];
        this.overrideDecision = -1;
        this.overrideDecisionInputIndex = -1;
        this.overrideDecisionAlt = -1;
        this.overrideDecisionReached = false;
        this._overrideDecisionRoot = void 0;
        if (grammarFileName instanceof ParserInterpreter2) {
          let old = grammarFileName;
          this._grammarFileName = old._grammarFileName;
          this._atn = old._atn;
          this.pushRecursionContextStates = old.pushRecursionContextStates;
          this._ruleNames = old._ruleNames;
          this._vocabulary = old._vocabulary;
          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this._atn, this);
        } else {
          vocabulary = vocabulary;
          ruleNames = ruleNames;
          atn = atn;
          this._grammarFileName = grammarFileName;
          this._atn = atn;
          this._ruleNames = ruleNames.slice(0);
          this._vocabulary = vocabulary;
          this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);
          for (let state of atn.states) {
            if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
              continue;
            }
            if (state.precedenceRuleDecision) {
              this.pushRecursionContextStates.set(state.stateNumber);
            }
          }
          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, this);
        }
      }
      reset(resetInput) {
        if (resetInput === void 0) {
          super.reset();
        } else {
          super.reset(resetInput);
        }
        this.overrideDecisionReached = false;
        this._overrideDecisionRoot = void 0;
      }
      get atn() {
        return this._atn;
      }
      get vocabulary() {
        return this._vocabulary;
      }
      get ruleNames() {
        return this._ruleNames;
      }
      get grammarFileName() {
        return this._grammarFileName;
      }
      parse(startRuleIndex) {
        let startRuleStartState = this._atn.ruleToStartState[startRuleIndex];
        this._rootContext = this.createInterpreterRuleContext(void 0, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);
        if (startRuleStartState.isPrecedenceRule) {
          this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
        } else {
          this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);
        }
        while (true) {
          let p = this.atnState;
          switch (p.stateType) {
            case ATNStateType_1.ATNStateType.RULE_STOP:
              if (this._ctx.isEmpty) {
                if (startRuleStartState.isPrecedenceRule) {
                  let result = this._ctx;
                  let parentContext = this._parentContextStack.pop();
                  this.unrollRecursionContexts(parentContext[0]);
                  return result;
                } else {
                  this.exitRule();
                  return this._rootContext;
                }
              }
              this.visitRuleStopState(p);
              break;
            default:
              try {
                this.visitState(p);
              } catch (e) {
                if (e instanceof RecognitionException_1.RecognitionException) {
                  this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;
                  this.context.exception = e;
                  this.errorHandler.reportError(this, e);
                  this.recover(e);
                } else {
                  throw e;
                }
              }
              break;
          }
        }
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this._parentContextStack.push([this._ctx, localctx.invokingState]);
        super.enterRecursionRule(localctx, state, ruleIndex, precedence);
      }
      get atnState() {
        return this._atn.states[this.state];
      }
      visitState(p) {
        let predictedAlt = 1;
        if (p.numberOfTransitions > 1) {
          predictedAlt = this.visitDecisionState(p);
        }
        let transition = p.transition(predictedAlt - 1);
        switch (transition.serializationType) {
          case 1:
            if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target instanceof LoopEndState_1.LoopEndState)) {
              let parentContext = this._parentContextStack[this._parentContextStack.length - 1];
              let localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);
              this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);
            }
            break;
          case 5:
            this.match(transition._label);
            break;
          case 2:
          case 7:
          case 8:
            if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {
              this.recoverInline();
            }
            this.matchWildcard();
            break;
          case 9:
            this.matchWildcard();
            break;
          case 3:
            let ruleStartState = transition.target;
            let ruleIndex = ruleStartState.ruleIndex;
            let newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);
            if (ruleStartState.isPrecedenceRule) {
              this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);
            } else {
              this.enterRule(newctx, transition.target.stateNumber, ruleIndex);
            }
            break;
          case 4:
            let predicateTransition = transition;
            if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
              throw new FailedPredicateException_1.FailedPredicateException(this);
            }
            break;
          case 6:
            let actionTransition = transition;
            this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);
            break;
          case 10:
            if (!this.precpred(this._ctx, transition.precedence)) {
              let precedence = transition.precedence;
              throw new FailedPredicateException_1.FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
            }
            break;
          default:
            throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
        }
        this.state = transition.target.stateNumber;
      }
      visitDecisionState(p) {
        let predictedAlt;
        this.errorHandler.sync(this);
        let decision = p.decision;
        if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {
          predictedAlt = this.overrideDecisionAlt;
          this.overrideDecisionReached = true;
        } else {
          predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);
        }
        return predictedAlt;
      }
      createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
        return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
      }
      visitRuleStopState(p) {
        let ruleStartState = this._atn.ruleToStartState[p.ruleIndex];
        if (ruleStartState.isPrecedenceRule) {
          let parentContext = this._parentContextStack.pop();
          this.unrollRecursionContexts(parentContext[0]);
          this.state = parentContext[1];
        } else {
          this.exitRule();
        }
        let ruleTransition = this._atn.states[this.state].transition(0);
        this.state = ruleTransition.followState.stateNumber;
      }
      addDecisionOverride(decision, tokenIndex, forcedAlt) {
        this.overrideDecision = decision;
        this.overrideDecisionInputIndex = tokenIndex;
        this.overrideDecisionAlt = forcedAlt;
      }
      get overrideDecisionRoot() {
        return this._overrideDecisionRoot;
      }
      recover(e) {
        let i = this._input.index;
        this.errorHandler.recover(this, e);
        if (this._input.index === i) {
          let tok = e.getOffendingToken();
          if (!tok) {
            throw new Error("Expected exception to have an offending token");
          }
          let source = tok.tokenSource;
          let stream = source !== void 0 ? source.inputStream : void 0;
          let sourcePair = { source, stream };
          if (e instanceof InputMismatchException_1.InputMismatchException) {
            let expectedTokens = e.expectedTokens;
            if (expectedTokens === void 0) {
              throw new Error("Expected the exception to provide expected tokens");
            }
            let expectedTokenType = Token_1.Token.INVALID_TYPE;
            if (!expectedTokens.isNil) {
              expectedTokenType = expectedTokens.minElement;
            }
            let errToken = this.tokenFactory.create(sourcePair, expectedTokenType, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, tok.line, tok.charPositionInLine);
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
          } else {
            let source2 = tok.tokenSource;
            let errToken = this.tokenFactory.create(sourcePair, Token_1.Token.INVALID_TYPE, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, tok.line, tok.charPositionInLine);
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
          }
        }
      }
      recoverInline() {
        return this._errHandler.recoverInline(this);
      }
      get rootContext() {
        return this._rootContext;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParserInterpreter.prototype, "_vocabulary", void 0);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "reset", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "atn", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "vocabulary", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "ruleNames", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "grammarFileName", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "enterRecursionRule", null);
    ParserInterpreter = __decorate([
      __param(1, Decorators_1.NotNull)
    ], ParserInterpreter);
    exports.ParserInterpreter = ParserInterpreter;
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js
var require_ParseTreeMatch = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreeMatch = void 0;
    var Decorators_1 = require_Decorators();
    var ParseTreeMatch = class ParseTreeMatch {
      constructor(tree, pattern, labels, mismatchedNode) {
        if (!tree) {
          throw new Error("tree cannot be null");
        }
        if (!pattern) {
          throw new Error("pattern cannot be null");
        }
        if (!labels) {
          throw new Error("labels cannot be null");
        }
        this._tree = tree;
        this._pattern = pattern;
        this._labels = labels;
        this._mismatchedNode = mismatchedNode;
      }
      get(label) {
        let parseTrees = this._labels.get(label);
        if (!parseTrees || parseTrees.length === 0) {
          return void 0;
        }
        return parseTrees[parseTrees.length - 1];
      }
      getAll(label) {
        const nodes = this._labels.get(label);
        if (!nodes) {
          return [];
        }
        return nodes;
      }
      get labels() {
        return this._labels;
      }
      get mismatchedNode() {
        return this._mismatchedNode;
      }
      get succeeded() {
        return !this._mismatchedNode;
      }
      get pattern() {
        return this._pattern;
      }
      get tree() {
        return this._tree;
      }
      toString() {
        return `Match ${this.succeeded ? "succeeded" : "failed"}; found ${this.labels.size} labels`;
      }
    };
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParseTreeMatch.prototype, "getAll", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "labels", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "pattern", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "tree", null);
    __decorate([
      Decorators_1.Override
    ], ParseTreeMatch.prototype, "toString", null);
    ParseTreeMatch = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParseTreeMatch);
    exports.ParseTreeMatch = ParseTreeMatch;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathLexer.js
var require_XPathLexer = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathLexer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathLexer = void 0;
    var ATNDeserializer_1 = require_ATNDeserializer();
    var Lexer_1 = require_Lexer();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var Utils3 = require_Utils();
    var XPathLexer = class extends Lexer_1.Lexer {
      constructor(input) {
        super(input);
        this._interp = new LexerATNSimulator_1.LexerATNSimulator(XPathLexer._ATN, this);
      }
      get vocabulary() {
        return XPathLexer.VOCABULARY;
      }
      get grammarFileName() {
        return "XPathLexer.g4";
      }
      get ruleNames() {
        return XPathLexer.ruleNames;
      }
      get serializedATN() {
        return XPathLexer._serializedATN;
      }
      get channelNames() {
        return XPathLexer.channelNames;
      }
      get modeNames() {
        return XPathLexer.modeNames;
      }
      action(_localctx, ruleIndex, actionIndex) {
        switch (ruleIndex) {
          case 4:
            this.ID_action(_localctx, actionIndex);
            break;
        }
      }
      ID_action(_localctx, actionIndex) {
        switch (actionIndex) {
          case 0:
            let text4 = this.text;
            if (text4.charAt(0) === text4.charAt(0).toUpperCase()) {
              this.type = XPathLexer.TOKEN_REF;
            } else {
              this.type = XPathLexer.RULE_REF;
            }
            break;
        }
      }
      static get _ATN() {
        if (!XPathLexer.__ATN) {
          XPathLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils3.toCharArray(XPathLexer._serializedATN));
        }
        return XPathLexer.__ATN;
      }
    };
    exports.XPathLexer = XPathLexer;
    XPathLexer.TOKEN_REF = 1;
    XPathLexer.RULE_REF = 2;
    XPathLexer.ANYWHERE = 3;
    XPathLexer.ROOT = 4;
    XPathLexer.WILDCARD = 5;
    XPathLexer.BANG = 6;
    XPathLexer.ID = 7;
    XPathLexer.STRING = 8;
    XPathLexer.channelNames = [
      "DEFAULT_TOKEN_CHANNEL",
      "HIDDEN"
    ];
    XPathLexer.modeNames = [
      "DEFAULT_MODE"
    ];
    XPathLexer.ruleNames = [
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "NameChar",
      "NameStartChar",
      "STRING"
    ];
    XPathLexer._LITERAL_NAMES = [
      void 0,
      void 0,
      void 0,
      "'//'",
      "'/'",
      "'*'",
      "'!'"
    ];
    XPathLexer._SYMBOLIC_NAMES = [
      void 0,
      "TOKEN_REF",
      "RULE_REF",
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "STRING"
    ];
    XPathLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);
    XPathLexer._serializedATNSegments = 2;
    XPathLexer._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\n2\b					\x07	\x07\b	\b			\x07\n\f"\v\x07\x07\b\b		\x07	,\n	\f		/\v			-\n\x07\x07	\b\v	\r\n\u02B6\n2;C\\aac|\x81\xA1\xAC\xAC\xAF\xAF\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0302\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u0485\u0489\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u0593\u05BF\u05C1\u05C1\u05C3\u05C4\u05C6\u05C7\u05C9\u05C9\u05D2\u05EC\u05F2\u05F4\u0602\u0607\u0612\u061C\u061E\u061E\u0622\u066B\u0670\u06D5\u06D7\u06DF\u06E1\u06EA\u06EC\u06FE\u0701\u0701\u0711\u074C\u074F\u07B3\u07C2\u07F7\u07FC\u07FC\u0802\u082F\u0842\u085D\u08A2\u08B6\u08B8\u08BF\u08D6\u0965\u0968\u0971\u0973\u0985\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BE\u09C6\u09C9\u09CA\u09CD\u09D0\u09D9\u09D9\u09DE\u09DF\u09E1\u09E5\u09E8\u09F3\u0A03\u0A05\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A3E\u0A3E\u0A40\u0A44\u0A49\u0A4A\u0A4D\u0A4F\u0A53\u0A53\u0A5B\u0A5E\u0A60\u0A60\u0A68\u0A77\u0A83\u0A85\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABE\u0AC7\u0AC9\u0ACB\u0ACD\u0ACF\u0AD2\u0AD2\u0AE2\u0AE5\u0AE8\u0AF1\u0AFB\u0AFB\u0B03\u0B05\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3E\u0B46\u0B49\u0B4A\u0B4D\u0B4F\u0B58\u0B59\u0B5E\u0B5F\u0B61\u0B65\u0B68\u0B71\u0B73\u0B73\u0B84\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BC0\u0BC4\u0BC8\u0BCA\u0BCC\u0BCF\u0BD2\u0BD2\u0BD9\u0BD9\u0BE8\u0BF1\u0C02\u0C05\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C46\u0C48\u0C4A\u0C4C\u0C4F\u0C57\u0C58\u0C5A\u0C5C\u0C62\u0C65\u0C68\u0C71\u0C82\u0C85\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBE\u0CC6\u0CC8\u0CCA\u0CCC\u0CCF\u0CD7\u0CD8\u0CE0\u0CE0\u0CE2\u0CE5\u0CE8\u0CF1\u0CF3\u0CF4\u0D03\u0D05\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D46\u0D48\u0D4A\u0D4C\u0D50\u0D56\u0D59\u0D61\u0D65\u0D68\u0D71\u0D7C\u0D81\u0D84\u0D85\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0DCC\u0DCC\u0DD1\u0DD6\u0DD8\u0DD8\u0DDA\u0DE1\u0DE8\u0DF1\u0DF4\u0DF5\u0E03\u0E3C\u0E42\u0E50\u0E52\u0E5B\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EBB\u0EBD\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0ECA\u0ECF\u0ED2\u0EDB\u0EDE\u0EE1\u0F02\u0F02\u0F1A\u0F1B\u0F22\u0F2B\u0F37\u0F37\u0F39\u0F39\u0F3B\u0F3B\u0F40\u0F49\u0F4B\u0F6E\u0F73\u0F86\u0F88\u0F99\u0F9B\u0FBE\u0FC8\u0FC8\u1002\u104B\u1052\u109F\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u135F\u1361\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1716\u1722\u1736\u1742\u1755\u1762\u176E\u1770\u1772\u1774\u1775\u1782\u17D5\u17D9\u17D9\u17DE\u17DF\u17E2\u17EB\u180D\u1810\u1812\u181B\u1822\u1879\u1882\u18AC\u18B2\u18F7\u1902\u1920\u1922\u192D\u1932\u193D\u1948\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u19D2\u19DB\u1A02\u1A1D\u1A22\u1A60\u1A62\u1A7E\u1A81\u1A8B\u1A92\u1A9B\u1AA9\u1AA9\u1AB2\u1ABF\u1B02\u1B4D\u1B52\u1B5B\u1B6D\u1B75\u1B82\u1BF5\u1C02\u1C39\u1C42\u1C4B\u1C4F\u1C7F\u1C82\u1C8A\u1CD2\u1CD4\u1CD6\u1CF8\u1CFA\u1CFB\u1D02\u1DF7\u1DFD\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u200D\u2011\u202C\u2030\u2041\u2042\u2056\u2056\u2062\u2066\u2068\u2071\u2073\u2073\u2081\u2081\u2092\u209E\u20D2\u20DE\u20E3\u20E3\u20E7\u20F2\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D81\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2DE2\u2E01\u2E31\u2E31\u3007\u3009\u3023\u3031\u3033\u3037\u303A\u303E\u3043\u3098\u309B\u309C\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA62D\uA642\uA671\uA676\uA67F\uA681\uA6F3\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA829\uA842\uA875\uA882\uA8C7\uA8D2\uA8DB\uA8E2\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA902\uA92F\uA932\uA955\uA962\uA97E\uA982\uA9C2\uA9D1\uA9DB\uA9E2\uAA00\uAA02\uAA38\uAA42\uAA4F\uAA52\uAA5B\uAA62\uAA78\uAA7C\uAAC4\uAADD\uAADF\uAAE2\uAAF1\uAAF4\uAAF8\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABEC\uABEE\uABEF\uABF2\uABFB\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE02\uFE11\uFE22\uFE31\uFE35\uFE36\uFE4F\uFE51\uFE72\uFE76\uFE78\uFEFE\uFF01\uFF01\uFF12\uFF1B\uFF23\uFF3C\uFF41\uFF41\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\uFFFB\uFFFD\r(*<>?AOR_\x82\xFC\u0142\u0176\u01FF\u01FF\u0282\u029E\u02A2\u02D2\u02E2\u02E2\u0302\u0321\u0332\u034C\u0352\u037C\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04A2\u04AB\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A05\u0A07\u0A08\u0A0E\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A3A\u0A3C\u0A41\u0A41\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE8\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1002\u1048\u1068\u1071\u1081\u10BC\u10BF\u10BF\u10D2\u10EA\u10F2\u10FB\u1102\u1136\u1138\u1141\u1152\u1175\u1178\u1178\u1182\u11C6\u11CC\u11CE\u11D2\u11DC\u11DE\u11DE\u1202\u1213\u1215\u1239\u1240\u1240\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12EC\u12F2\u12FB\u1302\u1305\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133E\u1346\u1349\u134A\u134D\u134F\u1352\u1352\u1359\u1359\u135F\u1365\u1368\u136E\u1372\u1376\u1402\u144C\u1452\u145B\u1482\u14C7\u14C9\u14C9\u14D2\u14DB\u1582\u15B7\u15BA\u15C2\u15DA\u15DF\u1602\u1642\u1646\u1646\u1652\u165B\u1682\u16B9\u16C2\u16CB\u1702\u171B\u171F\u172D\u1732\u173B\u18A2\u18EB\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C38\u1C3A\u1C42\u1C52\u1C5B\u1C74\u1C91\u1C94\u1CA9\u1CAB\u1CB8\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6A62\u6A6B\u6AD2\u6AEF\u6AF2\u6AF6\u6B02\u6B38\u6B42\u6B45\u6B52\u6B5B\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F80\u6F91\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uBC9F\uBCA0\uBCA2\uBCA5\uD167\uD16B\uD16F\uD184\uD187\uD18D\uD1AC\uD1AF\uD244\uD246\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uD7D0\uD801\uDA02\uDA38\uDA3D\uDA6E\uDA77\uDA77\uDA86\uDA86\uDA9D\uDAA1\uDAA3\uDAB1\uE002\uE008\uE00A\uE01A\uE01D\uE023\uE025\uE026\uE028\uE02C\uE802\uE8C6\uE8D2\uE8D8\uE902\uE94C\uE952\uE95B\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F"\x81\u0102\u01F1\u0240C\\c|\xAC\xAC\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0372\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u05D2\u05EC\u05F2\u05F4\u0622\u064C\u0670\u0671\u0673\u06D5\u06D7\u06D7\u06E7\u06E8\u06F0\u06F1\u06FC\u06FE\u0701\u0701\u0712\u0712\u0714\u0731\u074F\u07A7\u07B3\u07B3\u07CC\u07EC\u07F6\u07F7\u07FC\u07FC\u0802\u0817\u081C\u081C\u0826\u0826\u082A\u082A\u0842\u085A\u08A2\u08B6\u08B8\u08BF\u0906\u093B\u093F\u093F\u0952\u0952\u095A\u0963\u0973\u0982\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BF\u09BF\u09D0\u09D0\u09DE\u09DF\u09E1\u09E3\u09F2\u09F3\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A5B\u0A5E\u0A60\u0A60\u0A74\u0A76\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABF\u0ABF\u0AD2\u0AD2\u0AE2\u0AE3\u0AFB\u0AFB\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3F\u0B3F\u0B5E\u0B5F\u0B61\u0B63\u0B73\u0B73\u0B85\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BD2\u0BD2\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C3F\u0C5A\u0C5C\u0C62\u0C63\u0C82\u0C82\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBF\u0CBF\u0CE0\u0CE0\u0CE2\u0CE3\u0CF3\u0CF4\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D3F\u0D50\u0D50\u0D56\u0D58\u0D61\u0D63\u0D7C\u0D81\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0E03\u0E32\u0E34\u0E35\u0E42\u0E48\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EB2\u0EB4\u0EB5\u0EBF\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0EDE\u0EE1\u0F02\u0F02\u0F42\u0F49\u0F4B\u0F6E\u0F8A\u0F8E\u1002\u102C\u1041\u1041\u1052\u1057\u105C\u105F\u1063\u1063\u1067\u1068\u1070\u1072\u1077\u1083\u1090\u1090\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1713\u1722\u1733\u1742\u1753\u1762\u176E\u1770\u1772\u1782\u17B5\u17D9\u17D9\u17DE\u17DE\u1822\u1879\u1882\u1886\u1889\u18AA\u18AC\u18AC\u18B2\u18F7\u1902\u1920\u1952\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u1A02\u1A18\u1A22\u1A56\u1AA9\u1AA9\u1B07\u1B35\u1B47\u1B4D\u1B85\u1BA2\u1BB0\u1BB1\u1BBC\u1BE7\u1C02\u1C25\u1C4F\u1C51\u1C5C\u1C7F\u1C82\u1C8A\u1CEB\u1CEE\u1CF0\u1CF3\u1CF7\u1CF8\u1D02\u1DC1\u1E02\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u2073\u2073\u2081\u2081\u2092\u209E\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF0\u2CF4\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D82\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2E31\u2E31\u3007\u3009\u3023\u302B\u3033\u3037\u303A\u303E\u3043\u3098\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA621\uA62C\uA62D\uA642\uA670\uA681\uA69F\uA6A2\uA6F1\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA803\uA805\uA807\uA809\uA80C\uA80E\uA824\uA842\uA875\uA884\uA8B5\uA8F4\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA90C\uA927\uA932\uA948\uA962\uA97E\uA986\uA9B4\uA9D1\uA9D1\uA9E2\uA9E6\uA9E8\uA9F1\uA9FC\uAA00\uAA02\uAA2A\uAA42\uAA44\uAA46\uAA4D\uAA62\uAA78\uAA7C\uAA7C\uAA80\uAAB1\uAAB3\uAAB3\uAAB7\uAAB8\uAABB\uAABF\uAAC2\uAAC2\uAAC4\uAAC4\uAADD\uAADF\uAAE2\uAAEC\uAAF4\uAAF6\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABE4\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB1F\uFB21\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE72\uFE76\uFE78\uFEFE\uFF23\uFF3C\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\r(*<>?AOR_\x82\xFC\u0142\u0176\u0282\u029E\u02A2\u02D2\u0302\u0321\u0332\u034C\u0352\u0377\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A02\u0A12\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE6\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1005\u1039\u1085\u10B1\u10D2\u10EA\u1105\u1128\u1152\u1174\u1178\u1178\u1185\u11B4\u11C3\u11C6\u11DC\u11DC\u11DE\u11DE\u1202\u1213\u1215\u122D\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12E0\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133F\u133F\u1352\u1352\u135F\u1363\u1402\u1436\u1449\u144C\u1482\u14B1\u14C6\u14C7\u14C9\u14C9\u1582\u15B0\u15DA\u15DD\u1602\u1631\u1646\u1646\u1682\u16AC\u1702\u171B\u18A2\u18E1\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C30\u1C42\u1C42\u1C74\u1C91\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6AD2\u6AEF\u6B02\u6B31\u6B42\u6B45\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F52\u6F95\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548';
    XPathLexer._serializedATNSegment1 = `\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uE802\uE8C6\uE902\uE945\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F1\x07	\v\x07	\v\r%')\x071\x071\x071\x07,\b\x1B\x07#\x1B
 \b\r\x07"  !!#" #$\b$\f%&	&'(	()-\x07)*,\v+*,/-.-+.0/-01\x07)1 -`;
    XPathLexer._serializedATN = Utils3.join([
      XPathLexer._serializedATNSegment0,
      XPathLexer._serializedATNSegment1
    ], "");
  }
});

// node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js
var require_XPathLexerErrorListener = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathLexerErrorListener = void 0;
    var Decorators_1 = require_Decorators();
    var XPathLexerErrorListener = class {
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathLexerErrorListener.prototype, "syntaxError", null);
    exports.XPathLexerErrorListener = XPathLexerErrorListener;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathElement.js
var require_XPathElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathElement = void 0;
    var Decorators_1 = require_Decorators();
    var XPathElement = class {
      constructor(nodeName) {
        this.nodeName = nodeName;
        this.invert = false;
      }
      toString() {
        let inv = this.invert ? "!" : "";
        let className = Object.constructor.name;
        return className + "[" + inv + this.nodeName + "]";
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathElement.prototype, "toString", null);
    exports.XPathElement = XPathElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js
var require_XPathRuleAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathRuleAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathRuleAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        return Trees_1.Trees.findAllRuleNodes(t, this.ruleIndex);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathRuleAnywhereElement.prototype, "evaluate", null);
    exports.XPathRuleAnywhereElement = XPathRuleAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathRuleElement.js
var require_XPathRuleElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathRuleElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathRuleElement = void 0;
    var ParserRuleContext_1 = require_ParserRuleContext();
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathRuleElement = class extends XPathElement_1.XPathElement {
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        let nodes = [];
        for (let c of Trees_1.Trees.getChildren(t)) {
          if (c instanceof ParserRuleContext_1.ParserRuleContext) {
            if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
              nodes.push(c);
            }
          }
        }
        return nodes;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathRuleElement.prototype, "evaluate", null);
    exports.XPathRuleElement = XPathRuleElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js
var require_XPathTokenAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathTokenAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathTokenAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        return Trees_1.Trees.findAllTokenNodes(t, this.tokenType);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathTokenAnywhereElement.prototype, "evaluate", null);
    exports.XPathTokenAnywhereElement = XPathTokenAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathTokenElement.js
var require_XPathTokenElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathTokenElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathTokenElement = void 0;
    var Decorators_1 = require_Decorators();
    var TerminalNode_1 = require_TerminalNode();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathTokenElement = class extends XPathElement_1.XPathElement {
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        let nodes = [];
        for (let c of Trees_1.Trees.getChildren(t)) {
          if (c instanceof TerminalNode_1.TerminalNode) {
            if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
              nodes.push(c);
            }
          }
        }
        return nodes;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathTokenElement.prototype, "evaluate", null);
    exports.XPathTokenElement = XPathTokenElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js
var require_XPathWildcardAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathWildcardAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPath_1 = require_XPath();
    var XPathElement_1 = require_XPathElement();
    var XPathWildcardAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor() {
        super(XPath_1.XPath.WILDCARD);
      }
      evaluate(t) {
        if (this.invert) {
          return [];
        }
        return Trees_1.Trees.getDescendants(t);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathWildcardAnywhereElement.prototype, "evaluate", null);
    exports.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js
var require_XPathWildcardElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathWildcardElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPath_1 = require_XPath();
    var XPathElement_1 = require_XPathElement();
    var XPathWildcardElement = class extends XPathElement_1.XPathElement {
      constructor() {
        super(XPath_1.XPath.WILDCARD);
      }
      evaluate(t) {
        let kids = [];
        if (this.invert) {
          return kids;
        }
        for (let c of Trees_1.Trees.getChildren(t)) {
          kids.push(c);
        }
        return kids;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathWildcardElement.prototype, "evaluate", null);
    exports.XPathWildcardElement = XPathWildcardElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPath.js
var require_XPath = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPath = void 0;
    var CharStreams_1 = require_CharStreams();
    var CommonTokenStream_1 = require_CommonTokenStream();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var Token_1 = require_Token();
    var XPathLexer_1 = require_XPathLexer();
    var XPathLexerErrorListener_1 = require_XPathLexerErrorListener();
    var XPathRuleAnywhereElement_1 = require_XPathRuleAnywhereElement();
    var XPathRuleElement_1 = require_XPathRuleElement();
    var XPathTokenAnywhereElement_1 = require_XPathTokenAnywhereElement();
    var XPathTokenElement_1 = require_XPathTokenElement();
    var XPathWildcardAnywhereElement_1 = require_XPathWildcardAnywhereElement();
    var XPathWildcardElement_1 = require_XPathWildcardElement();
    var XPath = class {
      constructor(parser, path2) {
        this.parser = parser;
        this.path = path2;
        this.elements = this.split(path2);
      }
      split(path2) {
        let lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path2));
        lexer.recover = (e) => {
          throw e;
        };
        lexer.removeErrorListeners();
        lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());
        let tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);
        try {
          tokenStream.fill();
        } catch (e) {
          if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
            let pos = lexer.charPositionInLine;
            let msg = "Invalid tokens or characters at index " + pos + " in path '" + path2 + "' -- " + e.message;
            throw new RangeError(msg);
          }
          throw e;
        }
        let tokens = tokenStream.getTokens();
        let elements = [];
        let n = tokens.length;
        let i = 0;
        loop:
          while (i < n) {
            let el = tokens[i];
            let next;
            switch (el.type) {
              case XPathLexer_1.XPathLexer.ROOT:
              case XPathLexer_1.XPathLexer.ANYWHERE:
                let anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;
                i++;
                next = tokens[i];
                let invert = next.type === XPathLexer_1.XPathLexer.BANG;
                if (invert) {
                  i++;
                  next = tokens[i];
                }
                let pathElement = this.getXPathElement(next, anywhere);
                pathElement.invert = invert;
                elements.push(pathElement);
                i++;
                break;
              case XPathLexer_1.XPathLexer.TOKEN_REF:
              case XPathLexer_1.XPathLexer.RULE_REF:
              case XPathLexer_1.XPathLexer.WILDCARD:
                elements.push(this.getXPathElement(el, false));
                i++;
                break;
              case Token_1.Token.EOF:
                break loop;
              default:
                throw new Error("Unknowth path element " + el);
            }
          }
        return elements;
      }
      getXPathElement(wordToken, anywhere) {
        if (wordToken.type === Token_1.Token.EOF) {
          throw new Error("Missing path element at end of path");
        }
        let word = wordToken.text;
        if (word == null) {
          throw new Error("Expected wordToken to have text content.");
        }
        let ttype = this.parser.getTokenType(word);
        let ruleIndex = this.parser.getRuleIndex(word);
        switch (wordToken.type) {
          case XPathLexer_1.XPathLexer.WILDCARD:
            return anywhere ? new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() : new XPathWildcardElement_1.XPathWildcardElement();
          case XPathLexer_1.XPathLexer.TOKEN_REF:
          case XPathLexer_1.XPathLexer.STRING:
            if (ttype === Token_1.Token.INVALID_TYPE) {
              throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid token name");
            }
            return anywhere ? new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement_1.XPathTokenElement(word, ttype);
          default:
            if (ruleIndex === -1) {
              throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid rule name");
            }
            return anywhere ? new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);
        }
      }
      static findAll(tree, xpath, parser) {
        let p = new XPath(parser, xpath);
        return p.evaluate(tree);
      }
      evaluate(t) {
        let dummyRoot = new ParserRuleContext_1.ParserRuleContext();
        dummyRoot.addChild(t);
        let work = /* @__PURE__ */ new Set([dummyRoot]);
        let i = 0;
        while (i < this.elements.length) {
          let next = /* @__PURE__ */ new Set();
          for (let node of work) {
            if (node.childCount > 0) {
              let matching = this.elements[i].evaluate(node);
              matching.forEach(next.add, next);
            }
          }
          i++;
          work = next;
        }
        return work;
      }
    };
    exports.XPath = XPath;
    XPath.WILDCARD = "*";
    XPath.NOT = "!";
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreePattern.js
var require_ParseTreePattern = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreePattern.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreePattern = void 0;
    var Decorators_1 = require_Decorators();
    var XPath_1 = require_XPath();
    var ParseTreePattern = class ParseTreePattern {
      constructor(matcher, pattern, patternRuleIndex, patternTree) {
        this._matcher = matcher;
        this._patternRuleIndex = patternRuleIndex;
        this._pattern = pattern;
        this._patternTree = patternTree;
      }
      match(tree) {
        return this._matcher.match(tree, this);
      }
      matches(tree) {
        return this._matcher.match(tree, this).succeeded;
      }
      findAll(tree, xpath) {
        let subtrees = XPath_1.XPath.findAll(tree, xpath, this._matcher.parser);
        let matches = [];
        for (let t of subtrees) {
          let match = this.match(t);
          if (match.succeeded) {
            matches.push(match);
          }
        }
        return matches;
      }
      get matcher() {
        return this._matcher;
      }
      get pattern() {
        return this._pattern;
      }
      get patternRuleIndex() {
        return this._patternRuleIndex;
      }
      get patternTree() {
        return this._patternTree;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_pattern", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_patternTree", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_matcher", void 0);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "match", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "matches", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "findAll", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "matcher", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "pattern", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "patternTree", null);
    ParseTreePattern = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParseTreePattern);
    exports.ParseTreePattern = ParseTreePattern;
  }
});

// node_modules/antlr4ts/tree/pattern/RuleTagToken.js
var require_RuleTagToken = __commonJS({
  "node_modules/antlr4ts/tree/pattern/RuleTagToken.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleTagToken = void 0;
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var RuleTagToken = class RuleTagToken {
      constructor(ruleName, bypassTokenType, label) {
        if (ruleName == null || ruleName.length === 0) {
          throw new Error("ruleName cannot be null or empty.");
        }
        this._ruleName = ruleName;
        this.bypassTokenType = bypassTokenType;
        this._label = label;
      }
      get ruleName() {
        return this._ruleName;
      }
      get label() {
        return this._label;
      }
      get channel() {
        return Token_1.Token.DEFAULT_CHANNEL;
      }
      get text() {
        if (this._label != null) {
          return "<" + this._label + ":" + this._ruleName + ">";
        }
        return "<" + this._ruleName + ">";
      }
      get type() {
        return this.bypassTokenType;
      }
      get line() {
        return 0;
      }
      get charPositionInLine() {
        return -1;
      }
      get tokenIndex() {
        return -1;
      }
      get startIndex() {
        return -1;
      }
      get stopIndex() {
        return -1;
      }
      get tokenSource() {
        return void 0;
      }
      get inputStream() {
        return void 0;
      }
      toString() {
        return this._ruleName + ":" + this.bypassTokenType;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], RuleTagToken.prototype, "ruleName", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "channel", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "type", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "tokenIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "startIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "stopIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "toString", null);
    RuleTagToken = __decorate([
      __param(0, Decorators_1.NotNull)
    ], RuleTagToken);
    exports.RuleTagToken = RuleTagToken;
  }
});

// node_modules/antlr4ts/tree/pattern/Chunk.js
var require_Chunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/Chunk.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chunk = void 0;
    var Chunk = class {
    };
    exports.Chunk = Chunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TagChunk.js
var require_TagChunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TagChunk.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TagChunk = void 0;
    var Chunk_1 = require_Chunk();
    var Decorators_1 = require_Decorators();
    var TagChunk = class extends Chunk_1.Chunk {
      constructor(tag, label) {
        super();
        if (tag == null || tag.length === 0) {
          throw new Error("tag cannot be null or empty");
        }
        this._tag = tag;
        this._label = label;
      }
      get tag() {
        return this._tag;
      }
      get label() {
        return this._label;
      }
      toString() {
        if (this._label != null) {
          return this._label + ":" + this._tag;
        }
        return this._tag;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TagChunk.prototype, "tag", null);
    __decorate([
      Decorators_1.Override
    ], TagChunk.prototype, "toString", null);
    exports.TagChunk = TagChunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TextChunk.js
var require_TextChunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TextChunk.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextChunk = void 0;
    var Chunk_1 = require_Chunk();
    var Decorators_1 = require_Decorators();
    var TextChunk = class TextChunk extends Chunk_1.Chunk {
      constructor(text4) {
        super();
        if (text4 == null) {
          throw new Error("text cannot be null");
        }
        this._text = text4;
      }
      get text() {
        return this._text;
      }
      toString() {
        return "'" + this._text + "'";
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TextChunk.prototype, "_text", void 0);
    __decorate([
      Decorators_1.NotNull
    ], TextChunk.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TextChunk.prototype, "toString", null);
    TextChunk = __decorate([
      __param(0, Decorators_1.NotNull)
    ], TextChunk);
    exports.TextChunk = TextChunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TokenTagToken.js
var require_TokenTagToken = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TokenTagToken.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenTagToken = void 0;
    var CommonToken_1 = require_CommonToken();
    var Decorators_1 = require_Decorators();
    var TokenTagToken = class TokenTagToken extends CommonToken_1.CommonToken {
      constructor(tokenName, type, label) {
        super(type);
        this._tokenName = tokenName;
        this._label = label;
      }
      get tokenName() {
        return this._tokenName;
      }
      get label() {
        return this._label;
      }
      get text() {
        if (this._label != null) {
          return "<" + this._label + ":" + this._tokenName + ">";
        }
        return "<" + this._tokenName + ">";
      }
      toString() {
        return this._tokenName + ":" + this.type;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TokenTagToken.prototype, "_tokenName", void 0);
    __decorate([
      Decorators_1.NotNull
    ], TokenTagToken.prototype, "tokenName", null);
    __decorate([
      Decorators_1.Override
    ], TokenTagToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TokenTagToken.prototype, "toString", null);
    TokenTagToken = __decorate([
      __param(0, Decorators_1.NotNull)
    ], TokenTagToken);
    exports.TokenTagToken = TokenTagToken;
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js
var require_ParseTreePatternMatcher = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreePatternMatcher = void 0;
    var BailErrorStrategy_1 = require_BailErrorStrategy();
    var CharStreams_1 = require_CharStreams();
    var CommonTokenStream_1 = require_CommonTokenStream();
    var ListTokenSource_1 = require_ListTokenSource();
    var MultiMap_1 = require_MultiMap();
    var Decorators_1 = require_Decorators();
    var ParseCancellationException_1 = require_ParseCancellationException();
    var ParserInterpreter_1 = require_ParserInterpreter();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var ParseTreeMatch_1 = require_ParseTreeMatch();
    var ParseTreePattern_1 = require_ParseTreePattern();
    var RecognitionException_1 = require_RecognitionException();
    var RuleNode_1 = require_RuleNode();
    var RuleTagToken_1 = require_RuleTagToken();
    var TagChunk_1 = require_TagChunk();
    var TerminalNode_1 = require_TerminalNode();
    var TextChunk_1 = require_TextChunk();
    var Token_1 = require_Token();
    var TokenTagToken_1 = require_TokenTagToken();
    var ParseTreePatternMatcher = class {
      constructor(lexer, parser) {
        this.start = "<";
        this.stop = ">";
        this.escape = "\\";
        this.escapeRE = /\\/g;
        this._lexer = lexer;
        this._parser = parser;
      }
      setDelimiters(start, stop, escapeLeft) {
        if (!start) {
          throw new Error("start cannot be null or empty");
        }
        if (!stop) {
          throw new Error("stop cannot be null or empty");
        }
        this.start = start;
        this.stop = stop;
        this.escape = escapeLeft;
        this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
      }
      matches(tree, pattern, patternRuleIndex = 0) {
        if (typeof pattern === "string") {
          let p = this.compile(pattern, patternRuleIndex);
          return this.matches(tree, p);
        } else {
          let labels = new MultiMap_1.MultiMap();
          let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
          return !mismatchedNode;
        }
      }
      match(tree, pattern, patternRuleIndex = 0) {
        if (typeof pattern === "string") {
          let p = this.compile(pattern, patternRuleIndex);
          return this.match(tree, p);
        } else {
          let labels = new MultiMap_1.MultiMap();
          let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
          return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);
        }
      }
      compile(pattern, patternRuleIndex) {
        let tokenList = this.tokenize(pattern);
        let tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);
        let tokens = new CommonTokenStream_1.CommonTokenStream(tokenSrc);
        const parser = this._parser;
        let parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens);
        let tree;
        try {
          parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();
          tree = parserInterp.parse(patternRuleIndex);
        } catch (e) {
          if (e instanceof ParseCancellationException_1.ParseCancellationException) {
            throw e.getCause();
          } else if (e instanceof RecognitionException_1.RecognitionException) {
            throw e;
          } else if (e instanceof Error) {
            throw new ParseTreePatternMatcher.CannotInvokeStartRule(e);
          } else {
            throw e;
          }
        }
        if (tokens.LA(1) !== Token_1.Token.EOF) {
          throw new ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();
        }
        return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);
      }
      get lexer() {
        return this._lexer;
      }
      get parser() {
        return this._parser;
      }
      matchImpl(tree, patternTree, labels) {
        if (!tree) {
          throw new TypeError("tree cannot be null");
        }
        if (!patternTree) {
          throw new TypeError("patternTree cannot be null");
        }
        if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {
          let mismatchedNode;
          if (tree.symbol.type === patternTree.symbol.type) {
            if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) {
              let tokenTagToken = patternTree.symbol;
              labels.map(tokenTagToken.tokenName, tree);
              const l = tokenTagToken.label;
              if (l) {
                labels.map(l, tree);
              }
            } else if (tree.text === patternTree.text) {
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
          } else {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
          }
          return mismatchedNode;
        }
        if (tree instanceof ParserRuleContext_1.ParserRuleContext && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {
          let mismatchedNode;
          let ruleTagToken = this.getRuleTagToken(patternTree);
          if (ruleTagToken) {
            let m;
            if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {
              labels.map(ruleTagToken.ruleName, tree);
              const l = ruleTagToken.label;
              if (l) {
                labels.map(l, tree);
              }
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
            return mismatchedNode;
          }
          if (tree.childCount !== patternTree.childCount) {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
            return mismatchedNode;
          }
          let n = tree.childCount;
          for (let i = 0; i < n; i++) {
            let childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
            if (childMatch) {
              return childMatch;
            }
          }
          return mismatchedNode;
        }
        return tree;
      }
      getRuleTagToken(t) {
        if (t instanceof RuleNode_1.RuleNode) {
          if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {
            let c = t.getChild(0);
            if (c.symbol instanceof RuleTagToken_1.RuleTagToken) {
              return c.symbol;
            }
          }
        }
        return void 0;
      }
      tokenize(pattern) {
        let chunks = this.split(pattern);
        let tokens = [];
        for (let chunk of chunks) {
          if (chunk instanceof TagChunk_1.TagChunk) {
            let tagChunk = chunk;
            const firstChar = tagChunk.tag.substr(0, 1);
            if (firstChar === firstChar.toUpperCase()) {
              let ttype = this._parser.getTokenType(tagChunk.tag);
              if (ttype === Token_1.Token.INVALID_TYPE) {
                throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
              }
              let t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
              tokens.push(t);
            } else if (firstChar === firstChar.toLowerCase()) {
              let ruleIndex = this._parser.getRuleIndex(tagChunk.tag);
              if (ruleIndex === -1) {
                throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
              }
              let ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
              tokens.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
            } else {
              throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
            }
          } else {
            let textChunk = chunk;
            this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);
            let t = this._lexer.nextToken();
            while (t.type !== Token_1.Token.EOF) {
              tokens.push(t);
              t = this._lexer.nextToken();
            }
          }
        }
        return tokens;
      }
      split(pattern) {
        let p = 0;
        let n = pattern.length;
        let chunks = [];
        let buf;
        let starts = [];
        let stops = [];
        while (p < n) {
          if (p === pattern.indexOf(this.escape + this.start, p)) {
            p += this.escape.length + this.start.length;
          } else if (p === pattern.indexOf(this.escape + this.stop, p)) {
            p += this.escape.length + this.stop.length;
          } else if (p === pattern.indexOf(this.start, p)) {
            starts.push(p);
            p += this.start.length;
          } else if (p === pattern.indexOf(this.stop, p)) {
            stops.push(p);
            p += this.stop.length;
          } else {
            p++;
          }
        }
        if (starts.length > stops.length) {
          throw new Error("unterminated tag in pattern: " + pattern);
        }
        if (starts.length < stops.length) {
          throw new Error("missing start tag in pattern: " + pattern);
        }
        let ntags = starts.length;
        for (let i = 0; i < ntags; i++) {
          if (starts[i] >= stops[i]) {
            throw new Error("tag delimiters out of order in pattern: " + pattern);
          }
        }
        if (ntags === 0) {
          let text4 = pattern.substring(0, n);
          chunks.push(new TextChunk_1.TextChunk(text4));
        }
        if (ntags > 0 && starts[0] > 0) {
          let text4 = pattern.substring(0, starts[0]);
          chunks.push(new TextChunk_1.TextChunk(text4));
        }
        for (let i = 0; i < ntags; i++) {
          let tag = pattern.substring(starts[i] + this.start.length, stops[i]);
          let ruleOrToken = tag;
          let label;
          let colon = tag.indexOf(":");
          if (colon >= 0) {
            label = tag.substring(0, colon);
            ruleOrToken = tag.substring(colon + 1, tag.length);
          }
          chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));
          if (i + 1 < ntags) {
            let text4 = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);
            chunks.push(new TextChunk_1.TextChunk(text4));
          }
        }
        if (ntags > 0) {
          let afterLastTag = stops[ntags - 1] + this.stop.length;
          if (afterLastTag < n) {
            let text4 = pattern.substring(afterLastTag, n);
            chunks.push(new TextChunk_1.TextChunk(text4));
          }
        }
        for (let i = 0; i < chunks.length; i++) {
          let c = chunks[i];
          if (c instanceof TextChunk_1.TextChunk) {
            let unescaped = c.text.replace(this.escapeRE, "");
            if (unescaped.length < c.text.length) {
              chunks[i] = new TextChunk_1.TextChunk(unescaped);
            }
          }
        }
        return chunks;
      }
    };
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], ParseTreePatternMatcher.prototype, "match", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePatternMatcher.prototype, "lexer", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePatternMatcher.prototype, "parser", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParseTreePatternMatcher.prototype, "matchImpl", null);
    exports.ParseTreePatternMatcher = ParseTreePatternMatcher;
    (function(ParseTreePatternMatcher2) {
      class CannotInvokeStartRule extends Error {
        constructor(error) {
          super(`CannotInvokeStartRule: ${error}`);
          this.error = error;
        }
      }
      ParseTreePatternMatcher2.CannotInvokeStartRule = CannotInvokeStartRule;
      class StartRuleDoesNotConsumeFullPattern extends Error {
        constructor() {
          super("StartRuleDoesNotConsumeFullPattern");
        }
      }
      ParseTreePatternMatcher2.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;
    })(ParseTreePatternMatcher = exports.ParseTreePatternMatcher || (exports.ParseTreePatternMatcher = {}));
  }
});

// node_modules/antlr4ts/atn/DecisionEventInfo.js
var require_DecisionEventInfo = __commonJS({
  "node_modules/antlr4ts/atn/DecisionEventInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionEventInfo = void 0;
    var Decorators_1 = require_Decorators();
    var DecisionEventInfo = class DecisionEventInfo {
      constructor(decision, state, input, startIndex, stopIndex, fullCtx) {
        this.decision = decision;
        this.fullCtx = fullCtx;
        this.stopIndex = stopIndex;
        this.input = input;
        this.startIndex = startIndex;
        this.state = state;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DecisionEventInfo.prototype, "input", void 0);
    DecisionEventInfo = __decorate([
      __param(2, Decorators_1.NotNull)
    ], DecisionEventInfo);
    exports.DecisionEventInfo = DecisionEventInfo;
  }
});

// node_modules/antlr4ts/atn/AmbiguityInfo.js
var require_AmbiguityInfo = __commonJS({
  "node_modules/antlr4ts/atn/AmbiguityInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AmbiguityInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var AmbiguityInfo = class AmbiguityInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, ambigAlts, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
        this.ambigAlts = ambigAlts;
      }
      get ambiguousAlternatives() {
        return this.ambigAlts;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], AmbiguityInfo.prototype, "ambigAlts", void 0);
    __decorate([
      Decorators_1.NotNull
    ], AmbiguityInfo.prototype, "ambiguousAlternatives", null);
    AmbiguityInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], AmbiguityInfo);
    exports.AmbiguityInfo = AmbiguityInfo;
  }
});

// node_modules/antlr4ts/atn/ContextSensitivityInfo.js
var require_ContextSensitivityInfo = __commonJS({
  "node_modules/antlr4ts/atn/ContextSensitivityInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextSensitivityInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var ContextSensitivityInfo = class ContextSensitivityInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, true);
      }
    };
    ContextSensitivityInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ContextSensitivityInfo);
    exports.ContextSensitivityInfo = ContextSensitivityInfo;
  }
});

// node_modules/antlr4ts/atn/DecisionInfo.js
var require_DecisionInfo = __commonJS({
  "node_modules/antlr4ts/atn/DecisionInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionInfo = void 0;
    var Decorators_1 = require_Decorators();
    var DecisionInfo = class {
      constructor(decision) {
        this.invocations = 0;
        this.timeInPrediction = 0;
        this.SLL_TotalLook = 0;
        this.SLL_MinLook = 0;
        this.SLL_MaxLook = 0;
        this.LL_TotalLook = 0;
        this.LL_MinLook = 0;
        this.LL_MaxLook = 0;
        this.contextSensitivities = [];
        this.errors = [];
        this.ambiguities = [];
        this.predicateEvals = [];
        this.SLL_ATNTransitions = 0;
        this.SLL_DFATransitions = 0;
        this.LL_Fallback = 0;
        this.LL_ATNTransitions = 0;
        this.LL_DFATransitions = 0;
        this.decision = decision;
      }
      toString() {
        return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", SLL_lookahead=" + this.SLL_TotalLook + ", SLL_ATNTransitions=" + this.SLL_ATNTransitions + ", SLL_DFATransitions=" + this.SLL_DFATransitions + ", LL_Fallback=" + this.LL_Fallback + ", LL_lookahead=" + this.LL_TotalLook + ", LL_ATNTransitions=" + this.LL_ATNTransitions + "}";
      }
    };
    __decorate([
      Decorators_1.Override
    ], DecisionInfo.prototype, "toString", null);
    exports.DecisionInfo = DecisionInfo;
  }
});

// node_modules/antlr4ts/atn/ErrorInfo.js
var require_ErrorInfo = __commonJS({
  "node_modules/antlr4ts/atn/ErrorInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var ErrorInfo = class ErrorInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
      }
    };
    ErrorInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ErrorInfo);
    exports.ErrorInfo = ErrorInfo;
  }
});

// node_modules/antlr4ts/atn/LookaheadEventInfo.js
var require_LookaheadEventInfo = __commonJS({
  "node_modules/antlr4ts/atn/LookaheadEventInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LookaheadEventInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var LookaheadEventInfo = class LookaheadEventInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {
        super(decision, state, input, startIndex, stopIndex, fullCtx);
        this.predictedAlt = predictedAlt;
      }
    };
    LookaheadEventInfo = __decorate([
      __param(3, Decorators_1.NotNull)
    ], LookaheadEventInfo);
    exports.LookaheadEventInfo = LookaheadEventInfo;
  }
});

// node_modules/antlr4ts/atn/PredicateEvalInfo.js
var require_PredicateEvalInfo = __commonJS({
  "node_modules/antlr4ts/atn/PredicateEvalInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredicateEvalInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var PredicateEvalInfo = class PredicateEvalInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
        this.semctx = semctx;
        this.evalResult = evalResult;
        this.predictedAlt = predictedAlt;
      }
    };
    PredicateEvalInfo = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], PredicateEvalInfo);
    exports.PredicateEvalInfo = PredicateEvalInfo;
  }
});

// node_modules/antlr4ts/atn/ProfilingATNSimulator.js
var require_ProfilingATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ProfilingATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProfilingATNSimulator = void 0;
    var AmbiguityInfo_1 = require_AmbiguityInfo();
    var ATN_1 = require_ATN();
    var ATNSimulator_1 = require_ATNSimulator();
    var ContextSensitivityInfo_1 = require_ContextSensitivityInfo();
    var DecisionInfo_1 = require_DecisionInfo();
    var ErrorInfo_1 = require_ErrorInfo();
    var Decorators_1 = require_Decorators();
    var LookaheadEventInfo_1 = require_LookaheadEventInfo();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var PredicateEvalInfo_1 = require_PredicateEvalInfo();
    var SemanticContext_1 = require_SemanticContext();
    var SimulatorState_1 = require_SimulatorState();
    var ProfilingATNSimulator = class extends ParserATNSimulator_1.ParserATNSimulator {
      constructor(parser) {
        super(parser.interpreter.atn, parser);
        this._startIndex = 0;
        this._sllStopIndex = 0;
        this._llStopIndex = 0;
        this.currentDecision = 0;
        this.conflictingAltResolvedBySLL = 0;
        this.optimize_ll1 = false;
        this.reportAmbiguities = true;
        this.numDecisions = this.atn.decisionToState.length;
        this.decisions = [];
        for (let i = 0; i < this.numDecisions; i++) {
          this.decisions.push(new DecisionInfo_1.DecisionInfo(i));
        }
      }
      adaptivePredict(input, decision, outerContext, useContext) {
        if (useContext !== void 0) {
          return super.adaptivePredict(input, decision, outerContext, useContext);
        }
        try {
          this._input = input;
          this._startIndex = input.index;
          this._sllStopIndex = this._startIndex - 1;
          this._llStopIndex = -1;
          this.currentDecision = decision;
          this.currentState = void 0;
          this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;
          let start = process.hrtime();
          let alt = super.adaptivePredict(input, decision, outerContext);
          let stop = process.hrtime();
          let nanoseconds = (stop[0] - start[0]) * 1e9;
          if (nanoseconds === 0) {
            nanoseconds = stop[1] - start[1];
          } else {
            nanoseconds += 1e9 - start[1] + stop[1];
          }
          this.decisions[decision].timeInPrediction += nanoseconds;
          this.decisions[decision].invocations++;
          let SLL_k = this._sllStopIndex - this._startIndex + 1;
          this.decisions[decision].SLL_TotalLook += SLL_k;
          this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);
          if (SLL_k > this.decisions[decision].SLL_MaxLook) {
            this.decisions[decision].SLL_MaxLook = SLL_k;
            this.decisions[decision].SLL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._sllStopIndex, false);
          }
          if (this._llStopIndex >= 0) {
            let LL_k = this._llStopIndex - this._startIndex + 1;
            this.decisions[decision].LL_TotalLook += LL_k;
            this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);
            if (LL_k > this.decisions[decision].LL_MaxLook) {
              this.decisions[decision].LL_MaxLook = LL_k;
              this.decisions[decision].LL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._llStopIndex, true);
            }
          }
          return alt;
        } finally {
          this._input = void 0;
          this.currentDecision = -1;
        }
      }
      getStartState(dfa, input, outerContext, useContext) {
        let state = super.getStartState(dfa, input, outerContext, useContext);
        this.currentState = state;
        return state;
      }
      computeStartState(dfa, globalContext, useContext) {
        let state = super.computeStartState(dfa, globalContext, useContext);
        this.currentState = state;
        return state;
      }
      computeReachSet(dfa, previous4, t, contextCache) {
        if (this._input === void 0) {
          throw new Error("Invalid state");
        }
        let reachState = super.computeReachSet(dfa, previous4, t, contextCache);
        if (reachState == null) {
          this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous4, this._input, this._startIndex, this._input.index));
        }
        this.currentState = reachState;
        return reachState;
      }
      getExistingTargetState(previousD, t) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        if (this.currentState.useContext) {
          this._llStopIndex = this._input.index;
        } else {
          this._sllStopIndex = this._input.index;
        }
        let existingTargetState = super.getExistingTargetState(previousD, t);
        if (existingTargetState != null) {
          this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);
          if (this.currentState.useContext) {
            this.decisions[this.currentDecision].LL_DFATransitions++;
          } else {
            this.decisions[this.currentDecision].SLL_DFATransitions++;
          }
          if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {
            let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);
            this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));
          }
        }
        return existingTargetState;
      }
      computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
        let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);
        if (useContext) {
          this.decisions[this.currentDecision].LL_ATNTransitions++;
        } else {
          this.decisions[this.currentDecision].SLL_ATNTransitions++;
        }
        return targetState;
      }
      evalSemanticContextImpl(pred, parserCallStack, alt) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);
        if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {
          let fullContext = this._llStopIndex >= 0;
          let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;
          this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));
        }
        return result;
      }
      reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
        if (this._input === void 0) {
          throw new Error("Invalid state");
        }
        if (prediction !== this.conflictingAltResolvedBySLL) {
          this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));
        }
        super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);
      }
      reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
        if (conflictingAlts != null) {
          this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
        } else {
          this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);
        }
        this.decisions[this.currentDecision].LL_Fallback++;
        super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);
      }
      reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        let prediction;
        if (ambigAlts != null) {
          prediction = ambigAlts.nextSetBit(0);
        } else {
          prediction = configs.getRepresentedAlternatives().nextSetBit(0);
        }
        if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {
          this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));
        }
        this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));
        super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);
      }
      getDecisionInfo() {
        return this.decisions;
      }
      getCurrentState() {
        return this.currentState;
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], ProfilingATNSimulator.prototype, "adaptivePredict", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "getStartState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeStartState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeReachSet", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeTargetState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "evalSemanticContextImpl", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "reportContextSensitivity", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ProfilingATNSimulator.prototype, "reportAmbiguity", null);
    exports.ProfilingATNSimulator = ProfilingATNSimulator;
  }
});

// node_modules/antlr4ts/Parser.js
var require_Parser = __commonJS({
  "node_modules/antlr4ts/Parser.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Utils3 = require_Utils();
    var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
    var ATNDeserializer_1 = require_ATNDeserializer();
    var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
    var ErrorNode_1 = require_ErrorNode();
    var IntegerStack_1 = require_IntegerStack();
    var Lexer_1 = require_Lexer();
    var Decorators_1 = require_Decorators();
    var ParseInfo_1 = require_ParseInfo();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var ProxyParserErrorListener_1 = require_ProxyParserErrorListener();
    var Recognizer_1 = require_Recognizer();
    var TerminalNode_1 = require_TerminalNode();
    var Token_1 = require_Token();
    var TraceListener = class {
      constructor(ruleNames, tokenStream) {
        this.ruleNames = ruleNames;
        this.tokenStream = tokenStream;
      }
      enterEveryRule(ctx) {
        console.log("enter   " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
      }
      exitEveryRule(ctx) {
        console.log("exit    " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
      }
      visitErrorNode(node) {
      }
      visitTerminal(node) {
        let parent = node.parent.ruleContext;
        let token = node.symbol;
        console.log("consume " + token + " rule " + this.ruleNames[parent.ruleIndex]);
      }
    };
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "enterEveryRule", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "exitEveryRule", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "visitErrorNode", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "visitTerminal", null);
    var Parser2 = class extends Recognizer_1.Recognizer {
      constructor(input) {
        super();
        this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();
        this._precedenceStack = new IntegerStack_1.IntegerStack();
        this._buildParseTrees = true;
        this._parseListeners = [];
        this._syntaxErrors = 0;
        this.matchedEOF = false;
        this._precedenceStack.push(0);
        this.inputStream = input;
      }
      reset(resetInput) {
        if (resetInput === void 0 || resetInput) {
          this.inputStream.seek(0);
        }
        this._errHandler.reset(this);
        this._ctx = void 0;
        this._syntaxErrors = 0;
        this.matchedEOF = false;
        this.isTrace = false;
        this._precedenceStack.clear();
        this._precedenceStack.push(0);
        let interpreter = this.interpreter;
        if (interpreter != null) {
          interpreter.reset();
        }
      }
      match(ttype) {
        let t = this.currentToken;
        if (t.type === ttype) {
          if (ttype === Token_1.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        } else {
          t = this._errHandler.recoverInline(this);
          if (this._buildParseTrees && t.tokenIndex === -1) {
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
          }
        }
        return t;
      }
      matchWildcard() {
        let t = this.currentToken;
        if (t.type > 0) {
          this._errHandler.reportMatch(this);
          this.consume();
        } else {
          t = this._errHandler.recoverInline(this);
          if (this._buildParseTrees && t.tokenIndex === -1) {
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
          }
        }
        return t;
      }
      set buildParseTree(buildParseTrees) {
        this._buildParseTrees = buildParseTrees;
      }
      get buildParseTree() {
        return this._buildParseTrees;
      }
      getParseListeners() {
        return this._parseListeners;
      }
      addParseListener(listener) {
        if (listener == null) {
          throw new TypeError("listener cannot be null");
        }
        this._parseListeners.push(listener);
      }
      removeParseListener(listener) {
        let index2 = this._parseListeners.findIndex((l) => l === listener);
        if (index2 !== -1) {
          this._parseListeners.splice(index2, 1);
        }
      }
      removeParseListeners() {
        this._parseListeners.length = 0;
      }
      triggerEnterRuleEvent() {
        for (let listener of this._parseListeners) {
          if (listener.enterEveryRule) {
            listener.enterEveryRule(this._ctx);
          }
          this._ctx.enterRule(listener);
        }
      }
      triggerExitRuleEvent() {
        for (let i = this._parseListeners.length - 1; i >= 0; i--) {
          let listener = this._parseListeners[i];
          this._ctx.exitRule(listener);
          if (listener.exitEveryRule) {
            listener.exitEveryRule(this._ctx);
          }
        }
      }
      get numberOfSyntaxErrors() {
        return this._syntaxErrors;
      }
      get tokenFactory() {
        return this._input.tokenSource.tokenFactory;
      }
      getATNWithBypassAlts() {
        let serializedAtn = this.serializedATN;
        if (serializedAtn == null) {
          throw new Error("The current parser does not support an ATN with bypass alternatives.");
        }
        let result = Parser2.bypassAltsAtnCache.get(serializedAtn);
        if (result == null) {
          let deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();
          deserializationOptions.isGenerateRuleBypassTransitions = true;
          result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils3.toCharArray(serializedAtn));
          Parser2.bypassAltsAtnCache.set(serializedAtn, result);
        }
        return result;
      }
      compileParseTreePattern(pattern, patternRuleIndex, lexer) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!lexer) {
            if (this.inputStream) {
              let tokenSource = this.inputStream.tokenSource;
              if (tokenSource instanceof Lexer_1.Lexer) {
                lexer = tokenSource;
              }
            }
            if (!lexer) {
              throw new Error("Parser can't discover a lexer to use");
            }
          }
          let currentLexer = lexer;
          let m = yield Promise.resolve().then(() => require_ParseTreePatternMatcher());
          let matcher = new m.ParseTreePatternMatcher(currentLexer, this);
          return matcher.compile(pattern, patternRuleIndex);
        });
      }
      get errorHandler() {
        return this._errHandler;
      }
      set errorHandler(handler) {
        this._errHandler = handler;
      }
      get inputStream() {
        return this._input;
      }
      set inputStream(input) {
        this.reset(false);
        this._input = input;
      }
      get currentToken() {
        return this._input.LT(1);
      }
      notifyErrorListeners(msg, offendingToken, e) {
        if (offendingToken === void 0) {
          offendingToken = this.currentToken;
        } else if (offendingToken === null) {
          offendingToken = void 0;
        }
        this._syntaxErrors++;
        let line = -1;
        let charPositionInLine = -1;
        if (offendingToken != null) {
          line = offendingToken.line;
          charPositionInLine = offendingToken.charPositionInLine;
        }
        let listener = this.getErrorListenerDispatch();
        if (listener.syntaxError) {
          listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
        }
      }
      consume() {
        let o = this.currentToken;
        if (o.type !== Parser2.EOF) {
          this.inputStream.consume();
        }
        let hasListener = this._parseListeners.length !== 0;
        if (this._buildParseTrees || hasListener) {
          if (this._errHandler.inErrorRecoveryMode(this)) {
            let node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));
            if (hasListener) {
              for (let listener of this._parseListeners) {
                if (listener.visitErrorNode) {
                  listener.visitErrorNode(node);
                }
              }
            }
          } else {
            let node = this.createTerminalNode(this._ctx, o);
            this._ctx.addChild(node);
            if (hasListener) {
              for (let listener of this._parseListeners) {
                if (listener.visitTerminal) {
                  listener.visitTerminal(node);
                }
              }
            }
          }
        }
        return o;
      }
      createTerminalNode(parent, t) {
        return new TerminalNode_1.TerminalNode(t);
      }
      createErrorNode(parent, t) {
        return new ErrorNode_1.ErrorNode(t);
      }
      addContextToParseTree() {
        let parent = this._ctx._parent;
        if (parent != null) {
          parent.addChild(this._ctx);
        }
      }
      enterRule(localctx, state, ruleIndex) {
        this.state = state;
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        if (this._buildParseTrees) {
          this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
      }
      enterLeftFactoredRule(localctx, state, ruleIndex) {
        this.state = state;
        if (this._buildParseTrees) {
          let factoredContext = this._ctx.getChild(this._ctx.childCount - 1);
          this._ctx.removeLastChild();
          factoredContext._parent = localctx;
          localctx.addChild(factoredContext);
        }
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        if (this._buildParseTrees) {
          this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
      }
      exitRule() {
        if (this.matchedEOF) {
          this._ctx._stop = this._input.LT(1);
        } else {
          this._ctx._stop = this._input.tryLT(-1);
        }
        this.triggerExitRuleEvent();
        this.state = this._ctx.invokingState;
        this._ctx = this._ctx._parent;
      }
      enterOuterAlt(localctx, altNum) {
        localctx.altNumber = altNum;
        if (this._buildParseTrees && this._ctx !== localctx) {
          let parent = this._ctx._parent;
          if (parent != null) {
            parent.removeLastChild();
            parent.addChild(localctx);
          }
        }
        this._ctx = localctx;
      }
      get precedence() {
        if (this._precedenceStack.isEmpty) {
          return -1;
        }
        return this._precedenceStack.peek();
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this.state = state;
        this._precedenceStack.push(precedence);
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        this.triggerEnterRuleEvent();
      }
      pushNewRecursionContext(localctx, state, ruleIndex) {
        let previous4 = this._ctx;
        previous4._parent = localctx;
        previous4.invokingState = state;
        previous4._stop = this._input.tryLT(-1);
        this._ctx = localctx;
        this._ctx._start = previous4._start;
        if (this._buildParseTrees) {
          this._ctx.addChild(previous4);
        }
        this.triggerEnterRuleEvent();
      }
      unrollRecursionContexts(_parentctx) {
        this._precedenceStack.pop();
        this._ctx._stop = this._input.tryLT(-1);
        let retctx = this._ctx;
        if (this._parseListeners.length > 0) {
          while (this._ctx !== _parentctx) {
            this.triggerExitRuleEvent();
            this._ctx = this._ctx._parent;
          }
        } else {
          this._ctx = _parentctx;
        }
        retctx._parent = _parentctx;
        if (this._buildParseTrees && _parentctx != null) {
          _parentctx.addChild(retctx);
        }
      }
      getInvokingContext(ruleIndex) {
        let p = this._ctx;
        while (p && p.ruleIndex !== ruleIndex) {
          p = p._parent;
        }
        return p;
      }
      get context() {
        return this._ctx;
      }
      set context(ctx) {
        this._ctx = ctx;
      }
      precpred(localctx, precedence) {
        return precedence >= this._precedenceStack.peek();
      }
      getErrorListenerDispatch() {
        return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());
      }
      inContext(context) {
        return false;
      }
      isExpectedToken(symbol) {
        let atn = this.interpreter.atn;
        let ctx = this._ctx;
        let s = atn.states[this.state];
        let following = atn.nextTokens(s);
        if (following.contains(symbol)) {
          return true;
        }
        if (!following.contains(Token_1.Token.EPSILON)) {
          return false;
        }
        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
          let invokingState = atn.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          following = atn.nextTokens(rt.followState);
          if (following.contains(symbol)) {
            return true;
          }
          ctx = ctx._parent;
        }
        if (following.contains(Token_1.Token.EPSILON) && symbol === Token_1.Token.EOF) {
          return true;
        }
        return false;
      }
      get isMatchedEOF() {
        return this.matchedEOF;
      }
      getExpectedTokens() {
        return this.atn.getExpectedTokens(this.state, this.context);
      }
      getExpectedTokensWithinCurrentRule() {
        let atn = this.interpreter.atn;
        let s = atn.states[this.state];
        return atn.nextTokens(s);
      }
      getRuleIndex(ruleName) {
        let ruleIndex = this.getRuleIndexMap().get(ruleName);
        if (ruleIndex != null) {
          return ruleIndex;
        }
        return -1;
      }
      get ruleContext() {
        return this._ctx;
      }
      getRuleInvocationStack(ctx = this._ctx) {
        let p = ctx;
        let ruleNames = this.ruleNames;
        let stack = [];
        while (p != null) {
          let ruleIndex = p.ruleIndex;
          if (ruleIndex < 0) {
            stack.push("n/a");
          } else {
            stack.push(ruleNames[ruleIndex]);
          }
          p = p._parent;
        }
        return stack;
      }
      getDFAStrings() {
        let s = [];
        for (let dfa of this._interp.atn.decisionToDFA) {
          s.push(dfa.toString(this.vocabulary, this.ruleNames));
        }
        return s;
      }
      dumpDFA() {
        let seenOne = false;
        for (let dfa of this._interp.atn.decisionToDFA) {
          if (!dfa.isEmpty) {
            if (seenOne) {
              console.log();
            }
            console.log("Decision " + dfa.decision + ":");
            process.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));
            seenOne = true;
          }
        }
      }
      get sourceName() {
        return this._input.sourceName;
      }
      get parseInfo() {
        return Promise.resolve().then(() => require_ProfilingATNSimulator()).then((m) => {
          let interp = this.interpreter;
          if (interp instanceof m.ProfilingATNSimulator) {
            return new ParseInfo_1.ParseInfo(interp);
          }
          return void 0;
        });
      }
      setProfile(profile) {
        return __awaiter(this, void 0, void 0, function* () {
          let m = yield Promise.resolve().then(() => require_ProfilingATNSimulator());
          let interp = this.interpreter;
          if (profile) {
            if (!(interp instanceof m.ProfilingATNSimulator)) {
              this.interpreter = new m.ProfilingATNSimulator(this);
            }
          } else if (interp instanceof m.ProfilingATNSimulator) {
            this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);
          }
          this.interpreter.setPredictionMode(interp.getPredictionMode());
        });
      }
      set isTrace(trace) {
        if (!trace) {
          if (this._tracer) {
            this.removeParseListener(this._tracer);
            this._tracer = void 0;
          }
        } else {
          if (this._tracer) {
            this.removeParseListener(this._tracer);
          } else {
            this._tracer = new TraceListener(this.ruleNames, this._input);
          }
          this.addParseListener(this._tracer);
        }
      }
      get isTrace() {
        return this._tracer != null;
      }
    };
    Parser2.bypassAltsAtnCache = /* @__PURE__ */ new Map();
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "_errHandler", void 0);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "match", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "matchWildcard", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getParseListeners", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Parser2.prototype, "addParseListener", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getATNWithBypassAlts", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Parser2.prototype, "errorHandler", null);
    __decorate([
      Decorators_1.Override
    ], Parser2.prototype, "inputStream", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "currentToken", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Parser2.prototype, "enterRule", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.Nullable)
    ], Parser2.prototype, "precpred", null);
    __decorate([
      Decorators_1.Override
    ], Parser2.prototype, "getErrorListenerDispatch", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getExpectedTokens", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getExpectedTokensWithinCurrentRule", null);
    __decorate([
      Decorators_1.Override
    ], Parser2.prototype, "parseInfo", null);
    exports.Parser = Parser2;
  }
});

// node_modules/antlr4ts/NoViableAltException.js
var require_NoViableAltException = __commonJS({
  "node_modules/antlr4ts/NoViableAltException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoViableAltException = void 0;
    var Parser_1 = require_Parser();
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var NoViableAltException2 = class extends RecognitionException_1.RecognitionException {
      constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
        if (recognizer instanceof Parser_1.Parser) {
          if (input === void 0) {
            input = recognizer.inputStream;
          }
          if (startToken === void 0) {
            startToken = recognizer.currentToken;
          }
          if (offendingToken === void 0) {
            offendingToken = recognizer.currentToken;
          }
          if (ctx === void 0) {
            ctx = recognizer.context;
          }
        }
        super(recognizer, input, ctx);
        this._deadEndConfigs = deadEndConfigs;
        this._startToken = startToken;
        this.setOffendingToken(recognizer, offendingToken);
      }
      get startToken() {
        return this._startToken;
      }
      get deadEndConfigs() {
        return this._deadEndConfigs;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], NoViableAltException2.prototype, "_startToken", void 0);
    exports.NoViableAltException = NoViableAltException2;
  }
});

// node_modules/antlr4ts/DefaultErrorStrategy.js
var require_DefaultErrorStrategy = __commonJS({
  "node_modules/antlr4ts/DefaultErrorStrategy.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultErrorStrategy = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var FailedPredicateException_1 = require_FailedPredicateException();
    var InputMismatchException_1 = require_InputMismatchException();
    var IntervalSet_1 = require_IntervalSet();
    var NoViableAltException_1 = require_NoViableAltException();
    var PredictionContext_1 = require_PredictionContext();
    var Token_1 = require_Token();
    var Decorators_1 = require_Decorators();
    var DefaultErrorStrategy = class {
      constructor() {
        this.errorRecoveryMode = false;
        this.lastErrorIndex = -1;
        this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
      }
      reset(recognizer) {
        this.endErrorCondition(recognizer);
      }
      beginErrorCondition(recognizer) {
        this.errorRecoveryMode = true;
      }
      inErrorRecoveryMode(recognizer) {
        return this.errorRecoveryMode;
      }
      endErrorCondition(recognizer) {
        this.errorRecoveryMode = false;
        this.lastErrorStates = void 0;
        this.lastErrorIndex = -1;
      }
      reportMatch(recognizer) {
        this.endErrorCondition(recognizer);
      }
      reportError(recognizer, e) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        if (e instanceof NoViableAltException_1.NoViableAltException) {
          this.reportNoViableAlternative(recognizer, e);
        } else if (e instanceof InputMismatchException_1.InputMismatchException) {
          this.reportInputMismatch(recognizer, e);
        } else if (e instanceof FailedPredicateException_1.FailedPredicateException) {
          this.reportFailedPredicate(recognizer, e);
        } else {
          console.error(`unknown recognition error type: ${e}`);
          this.notifyErrorListeners(recognizer, e.toString(), e);
        }
      }
      notifyErrorListeners(recognizer, message, e) {
        let offendingToken = e.getOffendingToken(recognizer);
        if (offendingToken === void 0) {
          offendingToken = null;
        }
        recognizer.notifyErrorListeners(message, offendingToken, e);
      }
      recover(recognizer, e) {
        if (this.lastErrorIndex === recognizer.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(recognizer.state)) {
          recognizer.consume();
        }
        this.lastErrorIndex = recognizer.inputStream.index;
        if (!this.lastErrorStates) {
          this.lastErrorStates = new IntervalSet_1.IntervalSet();
        }
        this.lastErrorStates.add(recognizer.state);
        let followSet = this.getErrorRecoverySet(recognizer);
        this.consumeUntil(recognizer, followSet);
      }
      sync(recognizer) {
        let s = recognizer.interpreter.atn.states[recognizer.state];
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        let tokens = recognizer.inputStream;
        let la = tokens.LA(1);
        let nextTokens = recognizer.atn.nextTokens(s);
        if (nextTokens.contains(la)) {
          this.nextTokensContext = void 0;
          this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
          return;
        }
        if (nextTokens.contains(Token_1.Token.EPSILON)) {
          if (this.nextTokensContext === void 0) {
            this.nextTokensContext = recognizer.context;
            this.nextTokensState = recognizer.state;
          }
          return;
        }
        switch (s.stateType) {
          case ATNStateType_1.ATNStateType.BLOCK_START:
          case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
          case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
          case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
            if (this.singleTokenDeletion(recognizer)) {
              return;
            }
            throw new InputMismatchException_1.InputMismatchException(recognizer);
          case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
          case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
            this.reportUnwantedToken(recognizer);
            let expecting = recognizer.getExpectedTokens();
            let whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));
            this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
            break;
          default:
            break;
        }
      }
      reportNoViableAlternative(recognizer, e) {
        let tokens = recognizer.inputStream;
        let input;
        if (tokens) {
          if (e.startToken.type === Token_1.Token.EOF) {
            input = "<EOF>";
          } else {
            input = tokens.getTextFromRange(e.startToken, e.getOffendingToken());
          }
        } else {
          input = "<unknown input>";
        }
        let msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
        this.notifyErrorListeners(recognizer, msg, e);
      }
      reportInputMismatch(recognizer, e) {
        let expected = e.expectedTokens;
        let expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : "";
        let msg = "mismatched input " + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) + " expecting " + expectedString;
        this.notifyErrorListeners(recognizer, msg, e);
      }
      reportFailedPredicate(recognizer, e) {
        let ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
        let msg = "rule " + ruleName + " " + e.message;
        this.notifyErrorListeners(recognizer, msg, e);
      }
      reportUnwantedToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        let t = recognizer.currentToken;
        let tokenName = this.getTokenErrorDisplay(t);
        let expecting = this.getExpectedTokens(recognizer);
        let msg = "extraneous input " + tokenName + " expecting " + expecting.toStringVocabulary(recognizer.vocabulary);
        recognizer.notifyErrorListeners(msg, t, void 0);
      }
      reportMissingToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        let t = recognizer.currentToken;
        let expecting = this.getExpectedTokens(recognizer);
        let msg = "missing " + expecting.toStringVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
        recognizer.notifyErrorListeners(msg, t, void 0);
      }
      recoverInline(recognizer) {
        let matchedSymbol = this.singleTokenDeletion(recognizer);
        if (matchedSymbol) {
          recognizer.consume();
          return matchedSymbol;
        }
        if (this.singleTokenInsertion(recognizer)) {
          return this.getMissingSymbol(recognizer);
        }
        if (this.nextTokensContext === void 0) {
          throw new InputMismatchException_1.InputMismatchException(recognizer);
        } else {
          throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);
        }
      }
      singleTokenInsertion(recognizer) {
        let currentSymbolType = recognizer.inputStream.LA(1);
        let currentState = recognizer.interpreter.atn.states[recognizer.state];
        let next = currentState.transition(0).target;
        let atn = recognizer.interpreter.atn;
        let expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));
        if (expectingAtLL2.contains(currentSymbolType)) {
          this.reportMissingToken(recognizer);
          return true;
        }
        return false;
      }
      singleTokenDeletion(recognizer) {
        let nextTokenType = recognizer.inputStream.LA(2);
        let expecting = this.getExpectedTokens(recognizer);
        if (expecting.contains(nextTokenType)) {
          this.reportUnwantedToken(recognizer);
          recognizer.consume();
          let matchedSymbol = recognizer.currentToken;
          this.reportMatch(recognizer);
          return matchedSymbol;
        }
        return void 0;
      }
      getMissingSymbol(recognizer) {
        let currentSymbol = recognizer.currentToken;
        let expecting = this.getExpectedTokens(recognizer);
        let expectedTokenType = Token_1.Token.INVALID_TYPE;
        if (!expecting.isNil) {
          expectedTokenType = expecting.minElement;
        }
        let tokenText;
        if (expectedTokenType === Token_1.Token.EOF) {
          tokenText = "<missing EOF>";
        } else {
          tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
        }
        let current = currentSymbol;
        let lookback = recognizer.inputStream.tryLT(-1);
        if (current.type === Token_1.Token.EOF && lookback != null) {
          current = lookback;
        }
        return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);
      }
      constructToken(tokenSource, expectedTokenType, tokenText, current) {
        let factory = tokenSource.tokenFactory;
        let x = current.tokenSource;
        let stream = x ? x.inputStream : void 0;
        return factory.create({ source: tokenSource, stream }, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);
      }
      getExpectedTokens(recognizer) {
        return recognizer.getExpectedTokens();
      }
      getTokenErrorDisplay(t) {
        if (!t) {
          return "<no token>";
        }
        let s = this.getSymbolText(t);
        if (!s) {
          if (this.getSymbolType(t) === Token_1.Token.EOF) {
            s = "<EOF>";
          } else {
            s = `<${this.getSymbolType(t)}>`;
          }
        }
        return this.escapeWSAndQuote(s);
      }
      getSymbolText(symbol) {
        return symbol.text;
      }
      getSymbolType(symbol) {
        return symbol.type;
      }
      escapeWSAndQuote(s) {
        s = s.replace("\n", "\\n");
        s = s.replace("\r", "\\r");
        s = s.replace("	", "\\t");
        return "'" + s + "'";
      }
      getErrorRecoverySet(recognizer) {
        let atn = recognizer.interpreter.atn;
        let ctx = recognizer.context;
        let recoverSet = new IntervalSet_1.IntervalSet();
        while (ctx && ctx.invokingState >= 0) {
          let invokingState = atn.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          let follow = atn.nextTokens(rt.followState);
          recoverSet.addAll(follow);
          ctx = ctx._parent;
        }
        recoverSet.remove(Token_1.Token.EPSILON);
        return recoverSet;
      }
      consumeUntil(recognizer, set) {
        let ttype = recognizer.inputStream.LA(1);
        while (ttype !== Token_1.Token.EOF && !set.contains(ttype)) {
          recognizer.consume();
          ttype = recognizer.inputStream.LA(1);
        }
      }
    };
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "beginErrorCondition", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "inErrorRecoveryMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "endErrorCondition", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reportMatch", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reportError", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "notifyErrorListeners", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "recover", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "sync", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportNoViableAlternative", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportInputMismatch", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportFailedPredicate", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportUnwantedToken", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportMissingToken", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "recoverInline", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "singleTokenInsertion", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "singleTokenDeletion", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getMissingSymbol", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getExpectedTokens", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getSymbolText", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getSymbolType", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "escapeWSAndQuote", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getErrorRecoverySet", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "consumeUntil", null);
    exports.DefaultErrorStrategy = DefaultErrorStrategy;
  }
});

// node_modules/antlr4ts/BailErrorStrategy.js
var require_BailErrorStrategy = __commonJS({
  "node_modules/antlr4ts/BailErrorStrategy.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BailErrorStrategy = void 0;
    var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
    var InputMismatchException_1 = require_InputMismatchException();
    var Decorators_1 = require_Decorators();
    var ParseCancellationException_1 = require_ParseCancellationException();
    var BailErrorStrategy = class extends DefaultErrorStrategy_1.DefaultErrorStrategy {
      recover(recognizer, e) {
        for (let context = recognizer.context; context; context = context.parent) {
          context.exception = e;
        }
        throw new ParseCancellationException_1.ParseCancellationException(e);
      }
      recoverInline(recognizer) {
        let e = new InputMismatchException_1.InputMismatchException(recognizer);
        for (let context = recognizer.context; context; context = context.parent) {
          context.exception = e;
        }
        throw new ParseCancellationException_1.ParseCancellationException(e);
      }
      sync(recognizer) {
      }
    };
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "recover", null);
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "recoverInline", null);
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "sync", null);
    exports.BailErrorStrategy = BailErrorStrategy;
  }
});

// node_modules/antlr4ts/CharStream.js
var require_CharStream = __commonJS({
  "node_modules/antlr4ts/CharStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/Dependents.js
var require_Dependents = __commonJS({
  "node_modules/antlr4ts/Dependents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dependents = void 0;
    var Dependents;
    (function(Dependents2) {
      Dependents2[Dependents2["SELF"] = 0] = "SELF";
      Dependents2[Dependents2["PARENTS"] = 1] = "PARENTS";
      Dependents2[Dependents2["CHILDREN"] = 2] = "CHILDREN";
      Dependents2[Dependents2["ANCESTORS"] = 3] = "ANCESTORS";
      Dependents2[Dependents2["DESCENDANTS"] = 4] = "DESCENDANTS";
      Dependents2[Dependents2["SIBLINGS"] = 5] = "SIBLINGS";
      Dependents2[Dependents2["PRECEEDING_SIBLINGS"] = 6] = "PRECEEDING_SIBLINGS";
      Dependents2[Dependents2["FOLLOWING_SIBLINGS"] = 7] = "FOLLOWING_SIBLINGS";
      Dependents2[Dependents2["PRECEEDING"] = 8] = "PRECEEDING";
      Dependents2[Dependents2["FOLLOWING"] = 9] = "FOLLOWING";
    })(Dependents = exports.Dependents || (exports.Dependents = {}));
  }
});

// node_modules/antlr4ts/DiagnosticErrorListener.js
var require_DiagnosticErrorListener = __commonJS({
  "node_modules/antlr4ts/DiagnosticErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticErrorListener = void 0;
    var BitSet_1 = require_BitSet();
    var Decorators_1 = require_Decorators();
    var Interval_1 = require_Interval();
    var DiagnosticErrorListener = class {
      constructor(exactOnly = true) {
        this.exactOnly = exactOnly;
        this.exactOnly = exactOnly;
      }
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      }
      reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (this.exactOnly && !exact) {
          return;
        }
        let decision = this.getDecisionDescription(recognizer, dfa);
        let conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
        let text4 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text4}'`;
        recognizer.notifyErrorListeners(message);
      }
      reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
        let format = "reportAttemptingFullContext d=%s, input='%s'";
        let decision = this.getDecisionDescription(recognizer, dfa);
        let text4 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportAttemptingFullContext d=${decision}, input='${text4}'`;
        recognizer.notifyErrorListeners(message);
      }
      reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
        let format = "reportContextSensitivity d=%s, input='%s'";
        let decision = this.getDecisionDescription(recognizer, dfa);
        let text4 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportContextSensitivity d=${decision}, input='${text4}'`;
        recognizer.notifyErrorListeners(message);
      }
      getDecisionDescription(recognizer, dfa) {
        let decision = dfa.decision;
        let ruleIndex = dfa.atnStartState.ruleIndex;
        let ruleNames = recognizer.ruleNames;
        if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
          return decision.toString();
        }
        let ruleName = ruleNames[ruleIndex];
        if (!ruleName) {
          return decision.toString();
        }
        return `${decision} (${ruleName})`;
      }
      getConflictingAlts(reportedAlts, configs) {
        if (reportedAlts != null) {
          return reportedAlts;
        }
        let result = new BitSet_1.BitSet();
        for (let config of configs) {
          result.set(config.alt);
        }
        return result;
      }
    };
    __decorate([
      Decorators_1.Override
    ], DiagnosticErrorListener.prototype, "syntaxError", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportAmbiguity", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportContextSensitivity", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "getDecisionDescription", null);
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "getConflictingAlts", null);
    exports.DiagnosticErrorListener = DiagnosticErrorListener;
  }
});

// node_modules/antlr4ts/LexerInterpreter.js
var require_LexerInterpreter = __commonJS({
  "node_modules/antlr4ts/LexerInterpreter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerInterpreter = void 0;
    var Lexer_1 = require_Lexer();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var Decorators_1 = require_Decorators();
    var Decorators_2 = require_Decorators();
    var LexerInterpreter = class LexerInterpreter extends Lexer_1.Lexer {
      constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
        super(input);
        if (atn.grammarType !== 0) {
          throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
        }
        this._grammarFileName = grammarFileName;
        this._atn = atn;
        this._ruleNames = ruleNames.slice(0);
        this._channelNames = channelNames.slice(0);
        this._modeNames = modeNames.slice(0);
        this._vocabulary = vocabulary;
        this._interp = new LexerATNSimulator_1.LexerATNSimulator(atn, this);
      }
      get atn() {
        return this._atn;
      }
      get grammarFileName() {
        return this._grammarFileName;
      }
      get ruleNames() {
        return this._ruleNames;
      }
      get channelNames() {
        return this._channelNames;
      }
      get modeNames() {
        return this._modeNames;
      }
      get vocabulary() {
        return this._vocabulary;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerInterpreter.prototype, "_vocabulary", void 0);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "atn", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "grammarFileName", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "ruleNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "channelNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "modeNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "vocabulary", null);
    LexerInterpreter = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerInterpreter);
    exports.LexerInterpreter = LexerInterpreter;
  }
});

// node_modules/antlr4ts/ParserErrorListener.js
var require_ParserErrorListener = __commonJS({
  "node_modules/antlr4ts/ParserErrorListener.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/RuleContextWithAltNum.js
var require_RuleContextWithAltNum = __commonJS({
  "node_modules/antlr4ts/RuleContextWithAltNum.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleContextWithAltNum = void 0;
    var ATN_1 = require_ATN();
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleContextWithAltNum = class extends ParserRuleContext_1.ParserRuleContext {
      constructor(parent, invokingStateNumber) {
        if (invokingStateNumber !== void 0) {
          super(parent, invokingStateNumber);
        } else {
          super();
        }
        this._altNumber = ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      get altNumber() {
        return this._altNumber;
      }
      set altNumber(altNum) {
        this._altNumber = altNum;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleContextWithAltNum.prototype, "altNumber", null);
    exports.RuleContextWithAltNum = RuleContextWithAltNum;
  }
});

// node_modules/antlr4ts/RuleDependency.js
var require_RuleDependency = __commonJS({
  "node_modules/antlr4ts/RuleDependency.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleDependency = void 0;
    function RuleDependency(dependency) {
      return (target, propertyKey, propertyDescriptor) => {
      };
    }
    exports.RuleDependency = RuleDependency;
  }
});

// node_modules/antlr4ts/RuleVersion.js
var require_RuleVersion = __commonJS({
  "node_modules/antlr4ts/RuleVersion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleVersion = void 0;
    function RuleVersion(version) {
      return (target, propertyKey, propertyDescriptor) => {
      };
    }
    exports.RuleVersion = RuleVersion;
  }
});

// node_modules/antlr4ts/TokenFactory.js
var require_TokenFactory = __commonJS({
  "node_modules/antlr4ts/TokenFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenSource.js
var require_TokenSource = __commonJS({
  "node_modules/antlr4ts/TokenSource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenStream.js
var require_TokenStream = __commonJS({
  "node_modules/antlr4ts/TokenStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenStreamRewriter.js
var require_TokenStreamRewriter = __commonJS({
  "node_modules/antlr4ts/TokenStreamRewriter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RewriteOperation = exports.TokenStreamRewriter = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var TokenStreamRewriter = class {
      constructor(tokens) {
        this.tokens = tokens;
        this.programs = /* @__PURE__ */ new Map();
        this.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);
        this.lastRewriteTokenIndexes = /* @__PURE__ */ new Map();
      }
      getTokenStream() {
        return this.tokens;
      }
      rollback(instructionIndex, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let is = this.programs.get(programName);
        if (is != null) {
          this.programs.set(programName, is.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));
        }
      }
      deleteProgram(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        this.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, programName);
      }
      insertAfter(tokenOrIndex, text4, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let index2;
        if (typeof tokenOrIndex === "number") {
          index2 = tokenOrIndex;
        } else {
          index2 = tokenOrIndex.tokenIndex;
        }
        let rewrites = this.getProgram(programName);
        let op = new InsertAfterOp(this.tokens, index2, rewrites.length, text4);
        rewrites.push(op);
      }
      insertBefore(tokenOrIndex, text4, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let index2;
        if (typeof tokenOrIndex === "number") {
          index2 = tokenOrIndex;
        } else {
          index2 = tokenOrIndex.tokenIndex;
        }
        let rewrites = this.getProgram(programName);
        let op = new InsertBeforeOp(this.tokens, index2, rewrites.length, text4);
        rewrites.push(op);
      }
      replaceSingle(index2, text4) {
        if (typeof index2 === "number") {
          this.replace(index2, index2, text4);
        } else {
          this.replace(index2, index2, text4);
        }
      }
      replace(from, to, text4, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        if (typeof from !== "number") {
          from = from.tokenIndex;
        }
        if (typeof to !== "number") {
          to = to.tokenIndex;
        }
        if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
          throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);
        }
        let rewrites = this.getProgram(programName);
        let op = new ReplaceOp(this.tokens, from, to, rewrites.length, text4);
        rewrites.push(op);
      }
      delete(from, to, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        if (to === void 0) {
          to = from;
        }
        if (typeof from === "number") {
          this.replace(from, to, "", programName);
        } else {
          this.replace(from, to, "", programName);
        }
      }
      getLastRewriteTokenIndex(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let I = this.lastRewriteTokenIndexes.get(programName);
        if (I == null) {
          return -1;
        }
        return I;
      }
      setLastRewriteTokenIndex(programName, i) {
        this.lastRewriteTokenIndexes.set(programName, i);
      }
      getProgram(name) {
        let is = this.programs.get(name);
        if (is == null) {
          is = this.initializeProgram(name);
        }
        return is;
      }
      initializeProgram(name) {
        let is = [];
        this.programs.set(name, is);
        return is;
      }
      getText(intervalOrProgram, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let interval;
        if (intervalOrProgram instanceof Interval_1.Interval) {
          interval = intervalOrProgram;
        } else {
          interval = Interval_1.Interval.of(0, this.tokens.size - 1);
        }
        if (typeof intervalOrProgram === "string") {
          programName = intervalOrProgram;
        }
        let rewrites = this.programs.get(programName);
        let start = interval.a;
        let stop = interval.b;
        if (stop > this.tokens.size - 1) {
          stop = this.tokens.size - 1;
        }
        if (start < 0) {
          start = 0;
        }
        if (rewrites == null || rewrites.length === 0) {
          return this.tokens.getText(interval);
        }
        let buf = [];
        let indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
        let i = start;
        while (i <= stop && i < this.tokens.size) {
          let op = indexToOp.get(i);
          indexToOp.delete(i);
          let t = this.tokens.get(i);
          if (op == null) {
            if (t.type !== Token_1.Token.EOF) {
              buf.push(String(t.text));
            }
            i++;
          } else {
            i = op.execute(buf);
          }
        }
        if (stop === this.tokens.size - 1) {
          for (let op of indexToOp.values()) {
            if (op.index >= this.tokens.size - 1) {
              buf.push(op.text.toString());
            }
          }
        }
        return buf.join("");
      }
      reduceToSingleOperationPerIndex(rewrites) {
        for (let i = 0; i < rewrites.length; i++) {
          let op = rewrites[i];
          if (op == null) {
            continue;
          }
          if (!(op instanceof ReplaceOp)) {
            continue;
          }
          let rop = op;
          let inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
          for (let iop of inserts) {
            if (iop.index === rop.index) {
              rewrites[iop.instructionIndex] = void 0;
              rop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : "");
            } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
              rewrites[iop.instructionIndex] = void 0;
            }
          }
          let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
          for (let prevRop of prevReplaces) {
            if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
              rewrites[prevRop.instructionIndex] = void 0;
              continue;
            }
            let disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
            if (prevRop.text == null && rop.text == null && !disjoint) {
              rewrites[prevRop.instructionIndex] = void 0;
              rop.index = Math.min(prevRop.index, rop.index);
              rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
            } else if (!disjoint) {
              throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);
            }
          }
        }
        for (let i = 0; i < rewrites.length; i++) {
          let op = rewrites[i];
          if (op == null) {
            continue;
          }
          if (!(op instanceof InsertBeforeOp)) {
            continue;
          }
          let iop = op;
          let prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
          for (let prevIop of prevInserts) {
            if (prevIop.index === iop.index) {
              if (prevIop instanceof InsertAfterOp) {
                iop.text = this.catOpText(prevIop.text, iop.text);
                rewrites[prevIop.instructionIndex] = void 0;
              } else if (prevIop instanceof InsertBeforeOp) {
                iop.text = this.catOpText(iop.text, prevIop.text);
                rewrites[prevIop.instructionIndex] = void 0;
              }
            }
          }
          let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
          for (let rop of prevReplaces) {
            if (iop.index === rop.index) {
              rop.text = this.catOpText(iop.text, rop.text);
              rewrites[i] = void 0;
              continue;
            }
            if (iop.index >= rop.index && iop.index <= rop.lastIndex) {
              throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);
            }
          }
        }
        let m = /* @__PURE__ */ new Map();
        for (let op of rewrites) {
          if (op == null) {
            continue;
          }
          if (m.get(op.index) != null) {
            throw new Error("should only be one op per index");
          }
          m.set(op.index, op);
        }
        return m;
      }
      catOpText(a, b) {
        let x = "";
        let y = "";
        if (a != null) {
          x = a.toString();
        }
        if (b != null) {
          y = b.toString();
        }
        return x + y;
      }
      getKindOfOps(rewrites, kind, before) {
        let ops = [];
        for (let i = 0; i < before && i < rewrites.length; i++) {
          let op = rewrites[i];
          if (op == null) {
            continue;
          }
          if (op instanceof kind) {
            ops.push(op);
          }
        }
        return ops;
      }
    };
    exports.TokenStreamRewriter = TokenStreamRewriter;
    TokenStreamRewriter.DEFAULT_PROGRAM_NAME = "default";
    TokenStreamRewriter.PROGRAM_INIT_SIZE = 100;
    TokenStreamRewriter.MIN_TOKEN_INDEX = 0;
    var RewriteOperation = class {
      constructor(tokens, index2, instructionIndex, text4) {
        this.tokens = tokens;
        this.instructionIndex = instructionIndex;
        this.index = index2;
        this.text = text4 === void 0 ? "" : text4;
      }
      execute(buf) {
        return this.index;
      }
      toString() {
        let opName = this.constructor.name;
        let $index = opName.indexOf("$");
        opName = opName.substring($index + 1, opName.length);
        return "<" + opName + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
      }
    };
    __decorate([
      Decorators_1.Override
    ], RewriteOperation.prototype, "toString", null);
    exports.RewriteOperation = RewriteOperation;
    var InsertBeforeOp = class extends RewriteOperation {
      constructor(tokens, index2, instructionIndex, text4) {
        super(tokens, index2, instructionIndex, text4);
      }
      execute(buf) {
        buf.push(this.text.toString());
        if (this.tokens.get(this.index).type !== Token_1.Token.EOF) {
          buf.push(String(this.tokens.get(this.index).text));
        }
        return this.index + 1;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InsertBeforeOp.prototype, "execute", null);
    var InsertAfterOp = class extends InsertBeforeOp {
      constructor(tokens, index2, instructionIndex, text4) {
        super(tokens, index2 + 1, instructionIndex, text4);
      }
    };
    var ReplaceOp = class extends RewriteOperation {
      constructor(tokens, from, to, instructionIndex, text4) {
        super(tokens, from, instructionIndex, text4);
        this.lastIndex = to;
      }
      execute(buf) {
        if (this.text != null) {
          buf.push(this.text.toString());
        }
        return this.lastIndex + 1;
      }
      toString() {
        if (this.text == null) {
          return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
        }
        return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
      }
    };
    __decorate([
      Decorators_1.Override
    ], ReplaceOp.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], ReplaceOp.prototype, "toString", null);
  }
});

// node_modules/antlr4ts/Vocabulary.js
var require_Vocabulary = __commonJS({
  "node_modules/antlr4ts/Vocabulary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/WritableToken.js
var require_WritableToken = __commonJS({
  "node_modules/antlr4ts/WritableToken.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/index.js
var require_antlr4ts = __commonJS({
  "node_modules/antlr4ts/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ANTLRErrorListener(), exports);
    __exportStar(require_ANTLRErrorStrategy(), exports);
    __exportStar(require_ANTLRInputStream(), exports);
    __exportStar(require_BailErrorStrategy(), exports);
    __exportStar(require_BufferedTokenStream(), exports);
    __exportStar(require_CharStream(), exports);
    __exportStar(require_CharStreams(), exports);
    __exportStar(require_CodePointBuffer(), exports);
    __exportStar(require_CodePointCharStream(), exports);
    __exportStar(require_CommonToken(), exports);
    __exportStar(require_CommonTokenFactory(), exports);
    __exportStar(require_CommonTokenStream(), exports);
    __exportStar(require_ConsoleErrorListener(), exports);
    __exportStar(require_DefaultErrorStrategy(), exports);
    __exportStar(require_Dependents(), exports);
    __exportStar(require_DiagnosticErrorListener(), exports);
    __exportStar(require_FailedPredicateException(), exports);
    __exportStar(require_InputMismatchException(), exports);
    __exportStar(require_InterpreterRuleContext(), exports);
    __exportStar(require_IntStream(), exports);
    __exportStar(require_Lexer(), exports);
    __exportStar(require_LexerInterpreter(), exports);
    __exportStar(require_LexerNoViableAltException(), exports);
    __exportStar(require_ListTokenSource(), exports);
    __exportStar(require_NoViableAltException(), exports);
    __exportStar(require_Parser(), exports);
    __exportStar(require_ParserErrorListener(), exports);
    __exportStar(require_ParserInterpreter(), exports);
    __exportStar(require_ParserRuleContext(), exports);
    __exportStar(require_ProxyErrorListener(), exports);
    __exportStar(require_ProxyParserErrorListener(), exports);
    __exportStar(require_RecognitionException(), exports);
    __exportStar(require_Recognizer(), exports);
    __exportStar(require_RuleContext(), exports);
    __exportStar(require_RuleContextWithAltNum(), exports);
    __exportStar(require_RuleDependency(), exports);
    __exportStar(require_RuleVersion(), exports);
    __exportStar(require_Token(), exports);
    __exportStar(require_TokenFactory(), exports);
    __exportStar(require_TokenSource(), exports);
    __exportStar(require_TokenStream(), exports);
    __exportStar(require_TokenStreamRewriter(), exports);
    __exportStar(require_Vocabulary(), exports);
    __exportStar(require_VocabularyImpl(), exports);
    __exportStar(require_WritableToken(), exports);
  }
});

// node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js
var require_AbstractParseTreeVisitor = __commonJS({
  "node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractParseTreeVisitor = void 0;
    var Decorators_1 = require_Decorators();
    var AbstractParseTreeVisitor2 = class {
      visit(tree) {
        return tree.accept(this);
      }
      visitChildren(node) {
        let result = this.defaultResult();
        let n = node.childCount;
        for (let i = 0; i < n; i++) {
          if (!this.shouldVisitNextChild(node, result)) {
            break;
          }
          let c = node.getChild(i);
          let childResult = c.accept(this);
          result = this.aggregateResult(result, childResult);
        }
        return result;
      }
      visitTerminal(node) {
        return this.defaultResult();
      }
      visitErrorNode(node) {
        return this.defaultResult();
      }
      aggregateResult(aggregate, nextResult) {
        return nextResult;
      }
      shouldVisitNextChild(node, currentResult) {
        return true;
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visit", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visitChildren", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visitTerminal", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visitErrorNode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "shouldVisitNextChild", null);
    exports.AbstractParseTreeVisitor = AbstractParseTreeVisitor2;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StructuralEditPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/AstPos.ts
var AstPosMath = class {
  static fromEditorPosition(pos) {
    return {
      line: pos.line + 1,
      column: pos.ch + 1
    };
  }
  static toEditorPosition(pos) {
    return {
      line: pos.line - 1,
      ch: pos.column - 1
    };
  }
  static toOneBased(pos) {
    return {
      line: pos.line + 1,
      column: pos.column + 1
    };
  }
  static compareTo(pos, other) {
    if (pos.line < other.line) {
      return -1;
    }
    if (pos.line > other.line) {
      return 1;
    }
    if (pos.column < other.column) {
      return -1;
    }
    if (pos.column > other.column) {
      return 1;
    }
    return 0;
  }
  static equals(pos, other) {
    return this.compareTo(pos, other) === 0;
  }
  static inInclusiveRange(pos, range) {
    return this.compareTo(pos, range.start) >= 0 && this.compareTo(pos, range.end) <= 0;
  }
  static inRangeExcludingEnd(pos, range) {
    return this.compareTo(pos, range.start) >= 0 && this.compareTo(pos, range.end) < 0;
  }
  static covers(sourceRange, targetRange) {
    return this.compareTo(sourceRange.start, targetRange.start) <= 0 && this.compareTo(sourceRange.end, targetRange.end) >= 0;
  }
  static order(a, b) {
    if (this.compareTo(a, b) <= 0) {
      return {
        start: a,
        end: b
      };
    } else {
      return {
        start: b,
        end: a
      };
    }
  }
  static minus(pos, other) {
    return {
      line: pos.line - other.line,
      column: pos.column - other.column
    };
  }
  static plus(pos, other) {
    return {
      line: pos.line + other.line,
      column: pos.column - other.column
    };
  }
};

// src/Ast.ts
var Ast;
((Ast2) => {
  function inNode(node, pos) {
    var _a, _b;
    if (((_a = node.position.start) == null ? void 0 : _a.line) === void 0 || ((_b = node.position.end) == null ? void 0 : _b.line) === void 0) {
      return false;
    }
    return AstPosMath.inInclusiveRange(pos, { start: node.position.start, end: node.position.end });
  }
  Ast2.inNode = inNode;
  function fillsNode(node, selection) {
    var _a, _b;
    if (((_a = node.position.start) == null ? void 0 : _a.line) === void 0 || ((_b = node.position.end) == null ? void 0 : _b.line) === void 0) {
      return false;
    }
    return AstPosMath.covers(selection, { start: node.position.start, end: node.position.end });
  }
  Ast2.fillsNode = fillsNode;
  function findNodeWithRange(root, selection) {
    var _a, _b;
    let currentParent = root;
    const nodeStack = [];
    selection = {
      start: AstPosMath.compareTo(selection.start, root.position.end) > 0 ? root.position.end : selection.start,
      end: AstPosMath.compareTo(selection.end, root.position.end) > 0 ? root.position.end : selection.end
    };
    while (true) {
      console.log("trying node", currentParent);
      nodeStack.push(currentParent);
      let child = void 0;
      const children = (_b = (_a = currentParent.children) == null ? void 0 : _a.filter((child2) => !!child2.position.start && !!child2.position.end)) != null ? _b : [];
      for (let i = 0; i < children.length; ++i) {
        const node = children[i];
        const end = i >= children.length - 1 ? node.position.end : children[i + 1].position.start;
        const startInToken = AstPosMath.inInclusiveRange(selection.start, {
          start: node.position.start,
          end
        });
        const endInToken = i >= children.length - 1 ? AstPosMath.inInclusiveRange(selection.end, { start: node.position.start, end }) : AstPosMath.inRangeExcludingEnd(selection.end, { start: node.position.start, end });
        if (startInToken && endInToken) {
          child = node;
          break;
        }
      }
      if (!child) {
        console.log("no matching child");
        break;
      }
      if (child.children && child.children.length > 0) {
        console.log("child with children");
        currentParent = child;
      } else {
        console.log("child with no children");
        nodeStack.push(child);
        break;
      }
    }
    return {
      node: { ...nodeStack[nodeStack.length - 1], parent: nodeStack[Math.max(0, nodeStack.length - 2)] },
      ancestors: nodeStack
    };
  }
  Ast2.findNodeWithRange = findNodeWithRange;
})(Ast || (Ast = {}));

// node_modules/mdast-util-to-string/index.js
function toString(node, options) {
  var { includeImageAlt = true } = options || {};
  return one(node, includeImageAlt);
}
function one(node, includeImageAlt) {
  return node && typeof node === "object" && (node.value || (includeImageAlt ? node.alt : "") || "children" in node && all(node.children, includeImageAlt) || Array.isArray(node) && all(node, includeImageAlt)) || "";
}
function all(values, includeImageAlt) {
  var result = [];
  var index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one(values[index2], includeImageAlt);
  }
  return result.join("");
}

// node_modules/micromark-util-chunked/index.js
function splice(list2, start, remove, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    [].splice.apply(list2, parameters);
  } else {
    if (remove)
      [].splice.apply(list2, [start, remove]);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      [].splice.apply(list2, parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    for (code2 in right) {
      if (!hasOwnProperty.call(left, code2))
        left[code2] = [];
      const value2 = right[code2];
      constructs(left[code2], Array.isArray(value2) ? value2 : value2 ? [value2] : []);
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    ;
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-character/lib/unicode-punctuation-regex.js
var unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

// node_modules/micromark-util-character/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return code2 !== null && (code2 < 32 || code2 === 127);
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
var unicodeWhitespace = regexCheck(/\s/);
var unicodePunctuation = regexCheck(unicodePunctuationRegex);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && regex.test(String.fromCharCode(code2));
  }
}

// node_modules/micromark-factory-space/index.js
function factorySpace(effects, ok2, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok2(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok2(code2);
  }
}

// node_modules/micromark/lib/initialize/content.js
var content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  let previous4;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous4
    });
    if (previous4) {
      previous4.next = token;
    }
    previous4 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/micromark/lib/initialize/document.js
var document2 = {
  tokenize: initializeDocument
};
var containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self.containerState = item[1];
      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self.containerState._closeFlow) {
      self.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
      return checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
    }
    self.containerState = {};
    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self.parser.lazy[self.now().line] = continued !== stack.length;
    lineStartOffset = self.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self.currentConstruct, self.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self.parser.flow(self.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self.interrupt = void 0;
      return start;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
          return;
        }
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point2;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point2 = self.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self.containerState = entry[1];
      entry[0].exit.call(self, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}

// node_modules/micromark-util-classify-character/index.js
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text4;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text4 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text4, context]
          ]);
          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
          nextEvents = push(nextEvents, [
            ["exit", text4, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous4 = this.previous;
  const before = classifyCharacter(previous4);
  let marker;
  return start;
  function start(code2) {
    effects.enter("attentionSequence");
    marker = code2;
    return sequence(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return sequence;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close2 = !before || before === 2 && after || attentionMarkers2.includes(previous4);
    token._open = Boolean(marker === 42 ? open : open && (before || !close2));
    token._close = Boolean(marker === 42 ? close2 : close2 && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point2, offset) {
  point2.column += offset;
  point2.offset += offset;
  point2._bufferIndex += offset;
}

// node_modules/micromark-core-commonmark/lib/autolink.js
var autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 1;
  return start;
  function start(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return asciiAtext(code2) ? emailAtext(code2) : nok(code2);
  }
  function schemeOrEmailAtext(code2) {
    return code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2) ? schemeInsideOrEmailAtext(code2) : emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      return end(code2);
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      return end(code2);
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
      effects.consume(code2);
      return code2 === 45 ? emailValue : emailLabel;
    }
    return nok(code2);
  }
  function end(code2) {
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.exit("autolink");
    return ok2;
  }
}

// node_modules/micromark-core-commonmark/lib/blank-line.js
var blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return factorySpace(effects, afterWhitespace, "linePrefix");
  function afterWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 === 62) {
      const state = self.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(blockQuote, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function exit(effects) {
  effects.exit("blockQuote");
}

// node_modules/micromark-core-commonmark/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return open;
  }
  function open(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value2) {
  const characterReference2 = "&" + value2 + ";";
  element.innerHTML = characterReference2;
  const char = element.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value2 !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}

// node_modules/micromark-core-commonmark/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value2(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value2;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value2(code2);
  }
  function value2(code2) {
    let token;
    if (code2 === 59 && size) {
      token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code2) && size++ < max) {
      effects.consume(code2);
      return value2;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/code-fenced.js
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self = this;
  const closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  };
  const nonLazyLine2 = {
    tokenize: tokenizeNonLazyLine2,
    partial: true
  };
  const tail = this.events[this.events.length - 1];
  const initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    marker = code2;
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeFencedFenceSequence");
    return sizeOpen < 3 ? nok(code2) : factorySpace(effects, infoOpen, "whitespace")(code2);
  }
  function infoOpen(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, infoAfter, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return info;
  }
  function infoAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return openAfter(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return meta;
  }
  function openAfter(code2) {
    effects.exit("codeFencedFence");
    return self.interrupt ? ok2(code2) : contentStart(code2);
  }
  function contentStart(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(nonLazyLine2, effects.attempt(closingFenceConstruct, after, initialPrefix ? factorySpace(effects, contentStart, "linePrefix", initialPrefix + 1) : contentStart), after)(code2);
    }
    effects.enter("codeFlowValue");
    return contentContinue(code2);
  }
  function contentContinue(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return contentStart(code2);
    }
    effects.consume(code2);
    return contentContinue;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeNonLazyLine2(effects2, ok3, nok2) {
    const self2 = this;
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self2.parser.lazy[self2.now().line] ? nok2(code2) : ok3(code2);
    }
  }
  function tokenizeClosingFence(effects2, ok3, nok2) {
    let size = 0;
    return factorySpace(effects2, closingSequenceStart, "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function closingSequenceStart(code2) {
      effects2.enter("codeFencedFence");
      effects2.enter("codeFencedFenceSequence");
      return closingSequence(code2);
    }
    function closingSequence(code2) {
      if (code2 === marker) {
        effects2.consume(code2);
        size++;
        return closingSequence;
      }
      if (size < sizeOpen)
        return nok2(code2);
      effects2.exit("codeFencedFenceSequence");
      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code2);
    }
    function closingSequenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}

// node_modules/micromark-core-commonmark/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var indentedContent = {
  tokenize: tokenizeIndentedContent,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterStartPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterStartPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code2) : nok(code2);
  }
  function afterPrefix(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(indentedContent, afterPrefix, after)(code2);
    }
    effects.enter("codeFlowValue");
    return content3(code2);
  }
  function content3(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return afterPrefix(code2);
    }
    effects.consume(code2);
    return content3;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeIndentedContent(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (self.parser.lazy[self.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return start;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? start(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  const self = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return openingSequence(code2);
  }
  function openingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return openingSequence;
    }
    effects.exit("codeTextSequence");
    return gap(code2);
  }
  function gap(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return closingSequence(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return gap;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return gap;
    }
    effects.enter("codeTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return gap(code2);
    }
    effects.consume(code2);
    return data;
  }
  function closingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size++;
      return closingSequence;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token.type = "codeTextData";
    return data(code2);
  }
}

// node_modules/micromark-util-subtokenize/index.js
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous4;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous4) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous4 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.unshift([start2, start2 + slice.length - 1]);
    splice(events, start2, 2, slice);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/lib/content.js
var content2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous4;
  return start;
  function start(code2) {
    effects.enter("content");
    previous4 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
    }
    effects.consume(code2);
    return data;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous4.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous4
    });
    previous4 = previous4.next;
    return data;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self.events[self.events.length - 1];
    if (!self.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self.parser.constructs.flow, nok, ok2)(code2);
  }
}

// node_modules/micromark-factory-destination/index.js
function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return destinationEnclosedBefore;
    }
    if (code2 === null || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationRaw(code2);
  }
  function destinationEnclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationEnclosed(code2);
  }
  function destinationEnclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return destinationEnclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? destinationEnclosedEscape : destinationEnclosed;
  }
  function destinationEnclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return destinationEnclosed;
    }
    return destinationEnclosed(code2);
  }
  function destinationRaw(code2) {
    if (code2 === 40) {
      if (++balance > limit)
        return nok(code2);
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === 41) {
      if (!balance--) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok2(code2);
      }
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      if (balance)
        return nok(code2);
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code2);
    }
    if (asciiControl(code2))
      return nok(code2);
    effects.consume(code2);
    return code2 === 92 ? destinationRawEscape : destinationRaw;
  }
  function destinationRawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return destinationRaw;
    }
    return destinationRaw(code2);
  }
}

// node_modules/micromark-factory-label/index.js
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
  const self = this;
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 && !data || code2 === 94 && !size && "_hiddenFootnoteSupport" in self.parser.constructs || size > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return label(code2);
  }
  function label(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    data = data || !markdownSpace(code2);
    return code2 === 92 ? labelEscape : label;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return label;
    }
    return label(code2);
  }
}

// node_modules/micromark-factory-title/index.js
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    marker = code2 === 40 ? 41 : code2;
    return atFirstTitleBreak;
  }
  function atFirstTitleBreak(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    return atTitleBreak(code2);
  }
  function atTitleBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return atFirstTitleBreak(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atTitleBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return title(code2);
  }
  function title(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atTitleBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? titleEscape : title;
  }
  function titleEscape(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return title;
    }
    return title(code2);
  }
}

// node_modules/micromark-factory-whitespace/index.js
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code2);
    }
    return ok2(code2);
  }
}

// node_modules/micromark-util-normalize-identifier/index.js
function normalizeIdentifier(value2) {
  return value2.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-core-commonmark/lib/definition.js
var definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleConstruct = {
  tokenize: tokenizeTitle,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self = this;
  let identifier;
  return start;
  function start(code2) {
    effects.enter("definition");
    return factoryLabel.call(self, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return factoryWhitespace(effects, factoryDestination(effects, effects.attempt(titleConstruct, factorySpace(effects, after, "whitespace"), factorySpace(effects, after, "whitespace")), nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString"));
    }
    return nok(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      if (!self.parser.defined.includes(identifier)) {
        self.parser.defined.push(identifier);
      }
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitle(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, before)(code2) : nok(code2);
  }
  function before(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, factorySpace(effects, after, "whitespace"), nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("hardBreakEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("escapeMarker");
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text4;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text4 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text4, context],
      ["exit", text4, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  const self = this;
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("atxHeading");
    effects.enter("atxHeadingSequence");
    return fenceOpenInside(code2);
  }
  function fenceOpenInside(code2) {
    if (code2 === 35 && size++ < 6) {
      effects.consume(code2);
      return fenceOpenInside;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return self.interrupt ? ok2(code2) : headingBreak(code2);
    }
    return nok(code2);
  }
  function headingBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequence(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, headingBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data(code2);
  }
  function sequence(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequence;
    }
    effects.exit("atxHeadingSequence");
    return headingBreak(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return headingBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var nextBlankConstruct = {
  tokenize: tokenizeNextBlank,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self = this;
  let kind;
  let startTag;
  let buffer;
  let index2;
  let marker;
  return start;
  function start(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationStart;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      kind = 3;
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      startTag = true;
      return tagName;
    }
    return nok(code2);
  }
  function declarationStart(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      kind = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      kind = 5;
      buffer = "CDATA[";
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      kind = 4;
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    if (code2 === buffer.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === buffer.length ? self.interrupt ? ok2 : continuation : cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      if (code2 !== 47 && startTag && htmlRawNames.includes(buffer.toLowerCase())) {
        kind = 1;
        return self.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        kind = 6;
        if (code2 === 47) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self.interrupt ? ok2(code2) : continuation(code2);
      }
      kind = 7;
      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code2) : startTag ? completeAttributeNameBefore(code2) : completeClosingTagAfter(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    marker = null;
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    if (code2 === marker) {
      effects.consume(code2);
      return completeAttributeValueQuotedAfter;
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return code2 === null || markdownLineEnding(code2) ? continuation(code2) : nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && kind === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && kind === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && kind === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && kind === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && kind === 5) {
      effects.consume(code2);
      return continuationCharacterDataInside;
    }
    if (markdownLineEnding(code2) && (kind === 6 || kind === 7)) {
      return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationAtLineEnding(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationAtLineEnding(code2) {
    effects.exit("htmlFlowData");
    return htmlContinueStart(code2);
  }
  function htmlContinueStart(code2) {
    if (code2 === null) {
      return done(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt({
        tokenize: htmlLineEnd,
        partial: true
      }, htmlContinueStart, done)(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function htmlLineEnd(effects2, ok3, nok2) {
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self.parser.lazy[self.now().line] ? nok2(code2) : ok3(code2);
    }
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62 && htmlRawNames.includes(buffer.toLowerCase())) {
      effects.consume(code2);
      return continuationClose;
    }
    if (asciiAlpha(code2) && buffer.length < 8) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCharacterDataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 45 && kind === 2) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return done(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function done(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNextBlank(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.exit("htmlFlowData");
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    return effects.attempt(blankLine, ok2, nok);
  }
}

// node_modules/micromark-core-commonmark/lib/html-text.js
var htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self = this;
  let marker;
  let buffer;
  let index2;
  let returnState;
  return start;
  function start(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpen;
    }
    if (code2 === 91) {
      effects.consume(code2);
      buffer = "CDATA[";
      index2 = 0;
      return cdataOpen;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentStart;
    }
    return nok(code2);
  }
  function commentStart(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentStartDash;
    }
    return comment(code2);
  }
  function commentStartDash(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    return comment(code2);
  }
  function comment(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return end;
    }
    return comment(code2);
  }
  function cdataOpen(code2) {
    if (code2 === buffer.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === buffer.length ? cdata : cdataOpen;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === null || code2 === 62) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    marker = void 0;
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 62 || code2 === 47 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function atLineEnding(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, afterPrefix, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
  }
  function afterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
  function end(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var fullReferenceConstruct = {
  tokenize: tokenizeFullReference
};
var collapsedReferenceConstruct = {
  tokenize: tokenizeCollapsedReference
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  let token;
  while (++index2 < events.length) {
    token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close2;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close2) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close2 = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close2][1].end)
  };
  const text4 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close2 - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text4, context]]);
  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close2 - 3), context));
  media = push(media, [
    ["exit", text4, context],
    events[close2 - 2],
    events[close2 - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close2 + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self = this;
  let index2 = self.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self.events[index2][1].type === "labelImage" || self.events[index2][1].type === "labelLink") && !self.events[index2][1]._balanced) {
      labelStart = self.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive)
      return balanced(code2);
    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({
      start: labelStart.end,
      end: self.now()
    })));
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return afterLabelEnd;
  }
  function afterLabelEnd(code2) {
    if (code2 === 40) {
      return effects.attempt(resourceConstruct, ok2, defined ? ok2 : balanced)(code2);
    }
    if (code2 === 91) {
      return effects.attempt(fullReferenceConstruct, ok2, defined ? effects.attempt(collapsedReferenceConstruct, ok2, balanced) : balanced)(code2);
    }
    return defined ? ok2(code2) : balanced(code2);
  }
  function balanced(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return factoryWhitespace(effects, open);
  }
  function open(code2) {
    if (code2 === 41) {
      return end(code2);
    }
    return factoryDestination(effects, destinationAfter, nok, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code2);
  }
  function destinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, between)(code2) : end(code2);
  }
  function between(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, factoryWhitespace(effects, end), nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
    }
    return end(code2);
  }
  function end(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeFullReference(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    return factoryLabel.call(self, effects, afterLabel, nok, "reference", "referenceMarker", "referenceString")(code2);
  }
  function afterLabel(code2) {
    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok2(code2) : nok(code2);
  }
}
function tokenizeCollapsedReference(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/line-ending.js
var lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}

// node_modules/micromark-core-commonmark/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("thematicBreak");
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    if (size < 3 || code2 !== null && !markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.exit("thematicBreak");
    return ok2(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return atBreak(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/list.js
var list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code2) {
    const kind = self.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self.containerState.marker || code2 === self.containerState.marker : asciiDigit(code2)) {
      if (!self.containerState.type) {
        self.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code2 === self.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self.containerState.marker = self.containerState.marker || code2;
    return effects.check(blankLine, self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
  }
  function onBlank(code2) {
    self.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self.containerState.size = initialSize + self.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self = this;
  self.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;
    return factorySpace(effects, ok2, "listItemIndent", self.containerState.size + 1)(code2);
  }
  function notBlank(code2) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self.containerState.furtherBlankLines = void 0;
      self.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self.containerState.furtherBlankLines = void 0;
    self.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self.containerState._closeFlow = true;
    self.interrupt = void 0;
    return factorySpace(effects, effects.attempt(list, ok2, nok), "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self.containerState.size + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text4;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text4 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading = {
    type: "setextHeading",
    start: Object.assign({}, events[text4][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text4][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text4, 0, ["enter", heading, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content3][1] = heading;
  }
  events.push(["exit", heading, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self = this;
  let index2 = self.events.length;
  let marker;
  let paragraph;
  while (index2--) {
    if (self.events[index2][1].type !== "lineEnding" && self.events[index2][1].type !== "linePrefix" && self.events[index2][1].type !== "content") {
      paragraph = self.events[index2][1].type === "paragraph";
      break;
    }
  }
  return start;
  function start(code2) {
    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {
      effects.enter("setextHeadingLine");
      effects.enter("setextHeadingLineSequence");
      marker = code2;
      return closingSequence(code2);
    }
    return nok(code2);
  }
  function closingSequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return closingSequence;
    }
    effects.exit("setextHeadingLineSequence");
    return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code2);
  }
  function closingSequenceEnd(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark/lib/initialize/flow.js
var flow = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self = this;
  const initial = effects.attempt(blankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), "linePrefix")));
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/lib/initialize/text.js
var resolver = {
  resolveAll: createResolver()
};
var string = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0)
  };
  function initializeText(effects) {
    const self = this;
    const constructs2 = this.parser.constructs[field];
    const text4 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text4(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text4(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self, self.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) {
        } else {
          index2++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/lib/create-tokenizer.js
function createTokenizer(parser, initialize, from) {
  let point2 = Object.assign(from ? Object.assign({}, from) : {
    line: 1,
    column: 1,
    offset: 0
  }, {
    _index: 0,
    _bufferIndex: -1
  });
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit3,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    return Object.assign({}, point2);
  }
  function defineSkip(value2) {
    columnStart[value2.line] = value2.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    consumed = void 0;
    expectedCode = code2;
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code2;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit3(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start;
        function start(code2) {
          const def = code2 !== null && map[code2];
          const all2 = code2 !== null && map.null;
          const list2 = [
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code2);
          }
          return construct.tokenize.call(fields ? Object.assign(Object.create(context), fields) : context, effects, ok2, nok)(code2);
        }
      }
      function ok2(code2) {
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      view[0] = view[0].slice(startBufferIndex);
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value2;
    if (typeof chunk === "string") {
      value2 = chunk;
    } else
      switch (chunk) {
        case -5: {
          value2 = "\r";
          break;
        }
        case -4: {
          value2 = "\n";
          break;
        }
        case -3: {
          value2 = "\r\n";
          break;
        }
        case -2: {
          value2 = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value2 = " ";
          break;
        }
        default: {
          value2 = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value2);
  }
  return result.join("");
}

// node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text2
});
var document3 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
var contentInitial = {
  [91]: definition
};
var flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
var flow2 = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
var string2 = {
  [38]: characterReference,
  [92]: characterEscape
};
var text2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
var insideSpan = {
  null: [attention, resolver]
};
var attentionMarkers = {
  null: [42, 95]
};
var disable = {
  null: []
};

// node_modules/micromark/lib/parse.js
function parse(options = {}) {
  const constructs2 = combineExtensions([constructs_exports].concat(options.extensions || []));
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content),
    document: create2(document2),
    flow: create2(flow),
    string: create2(string),
    text: create2(text)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/micromark/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value2, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value2 = buffer + value2.toString(encoding);
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value2.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value2.length) {
      search.lastIndex = startPosition;
      match = search.exec(value2);
      endPosition = match && match.index !== void 0 ? match.index : value2.length;
      code2 = value2.charCodeAt(endPosition);
      if (!match) {
        buffer = value2.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value2.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer)
        chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}

// node_modules/micromark/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark-util-decode-numeric-character-reference/index.js
function decodeNumericCharacterReference(value2, base) {
  const code2 = Number.parseInt(value2, base);
  if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
    return "\uFFFD";
  }
  return String.fromCharCode(code2);
}

// node_modules/micromark-util-decode-string/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value2) {
  return value2.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/unist-util-stringify-position/index.js
function stringifyPosition(value2) {
  if (!value2 || typeof value2 !== "object") {
    return "";
  }
  if ("position" in value2 || "type" in value2) {
    return position(value2.position);
  }
  if ("start" in value2 || "end" in value2) {
    return position(value2);
  }
  if ("line" in value2 || "column" in value2) {
    return point(value2);
  }
  return "";
}
function point(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value2) {
  return value2 && typeof value2 === "number" ? value2 : 1;
}

// node_modules/mdast-util-from-markdown/lib/index.js
var own = {}.hasOwnProperty;
var fromMarkdown = function(value2, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value2, encoding, true))));
};
function compiler(options = {}) {
  const config = configure({
    transforms: [],
    canContainEols: [
      "emphasis",
      "fragment",
      "heading",
      "paragraph",
      "strong"
    ],
    enter: {
      autolink: opener2(link),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener2(heading),
      blockQuote: opener2(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener2(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener2(codeFlow, buffer),
      codeText: opener2(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener2(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener2(emphasis),
      hardBreakEscape: opener2(hardBreak),
      hardBreakTrailing: opener2(hardBreak),
      htmlFlow: opener2(html, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener2(html, buffer),
      htmlTextData: onenterdata,
      image: opener2(image),
      label: buffer,
      link: opener2(link),
      listItem: opener2(listItem),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener2(list2, onenterlistordered),
      listUnordered: opener2(list2),
      paragraph: opener2(paragraph),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener2(heading),
      strong: opener2(strong),
      thematicBreak: opener2(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  }, options.mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const stack = [tree];
    const tokenStack = [];
    const listStack = [];
    const context = {
      stack,
      tokenStack,
      config,
      enter,
      exit: exit3,
      buffer,
      resume,
      setData,
      getData
    };
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(Object.assign({
          sliceSerialize: events[index2][2].sliceSerialize
        }, context), events[index2][1]);
      }
    }
    if (tokenStack.length > 0) {
      const tail = tokenStack[tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point2(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem2;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
      } else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem2) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem2._spread = true;
          }
          listItem2.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem2, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem2 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start)
          };
          events.splice(index2, 0, ["enter", listItem2, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function setData(key, value2) {
    data[key] = value2;
  }
  function getData(key) {
    return data[key];
  }
  function point2(d) {
    return {
      line: d.line,
      column: d.column,
      offset: d.offset
    };
  }
  function opener2(create2, and) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    parent.children.push(node);
    this.stack.push(node);
    this.tokenStack.push([token, errorHandler]);
    node.position = {
      start: point2(token.start)
    };
    return node;
  }
  function closer(and) {
    return close2;
    function close2(token) {
      if (and)
        and.call(this, token);
      exit3.call(this, token);
    }
  }
  function exit3(token, onExitError) {
    const node = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
        start: token.start,
        end: token.end
      }) + "): it\u2019s not open");
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node.position.end = point2(token.end);
    return node;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.meta = data2;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside"))
      return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node = this.stack[this.stack.length - 1];
    if (!node.depth) {
      const depth = this.sliceSerialize(token).length;
      node.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    const node = this.stack[this.stack.length - 1];
    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    const parent = this.stack[this.stack.length - 1];
    let tail = parent.children[parent.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text4();
      tail.position = {
        start: point2(token.start)
      };
      parent.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point2(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexitlink() {
    const context = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context.type += "Reference";
      context.referenceType = getData("referenceType") || "shortcut";
      delete context.url;
      delete context.title;
    } else {
      delete context.identifier;
      delete context.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const context = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context.type += "Reference";
      context.referenceType = getData("referenceType") || "shortcut";
      delete context.url;
      delete context.title;
    } else {
      delete context.identifier;
      delete context.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    const ancestor = this.stack[this.stack.length - 2];
    const string3 = this.sliceSerialize(token);
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    setData("inReference", true);
    if (node.type === "link") {
      node.children = fragment.children;
    } else {
      node.alt = value2;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.title = data2;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = getData("characterReferenceType");
    let value2;
    if (type) {
      value2 = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
      setData("characterReferenceType");
    } else {
      value2 = decodeNamedCharacterReference(data2);
    }
    const tail = this.stack.pop();
    tail.value += value2;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node = this.stack[this.stack.length - 1];
    node.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node = this.stack[this.stack.length - 1];
    node.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function hardBreak() {
    return {
      type: "break"
    };
  }
  function html() {
    return {
      type: "html",
      value: ""
    };
  }
  function image() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong() {
    return {
      type: "strong",
      children: []
    };
  }
  function text4() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value2 = extensions[index2];
    if (Array.isArray(value2)) {
      configure(combined, value2);
    } else {
      extension(combined, value2);
    }
  }
  return combined;
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own.call(extension2, key)) {
      const list2 = key === "canContainEols" || key === "transforms";
      const maybe = own.call(combined, key) ? combined[key] : void 0;
      const left = maybe || (combined[key] = list2 ? [] : {});
      const right = extension2[key];
      if (right) {
        if (list2) {
          combined[key] = [...left, ...right];
        } else {
          Object.assign(left, right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
      start: left.start,
      end: left.end
    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is open");
  } else {
    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is still open");
  }
}

// node_modules/fault/index.js
var import_format = __toESM(require_format(), 1);
var fault = Object.assign(create(Error), {
  eval: create(EvalError),
  range: create(RangeError),
  reference: create(ReferenceError),
  syntax: create(SyntaxError),
  type: create(TypeError),
  uri: create(URIError)
});
function create(Constructor) {
  FormattedError.displayName = Constructor.displayName || Constructor.name;
  return FormattedError;
  function FormattedError(format, ...values) {
    const reason = format ? (0, import_format.default)(format, ...values) : format;
    return new Constructor(reason);
  }
}

// node_modules/micromark-extension-frontmatter/matters.js
var own2 = {}.hasOwnProperty;
var markers = {
  yaml: "-",
  toml: "+"
};
function matters(options = "yaml") {
  const results = [];
  let index2 = -1;
  if (!Array.isArray(options)) {
    options = [options];
  }
  while (++index2 < options.length) {
    results[index2] = matter(options[index2]);
  }
  return results;
}
function matter(option) {
  let result = option;
  if (typeof result === "string") {
    if (!own2.call(markers, result)) {
      throw fault("Missing matter definition for `%s`", result);
    }
    result = {
      type: result,
      marker: markers[result]
    };
  } else if (typeof result !== "object") {
    throw fault("Expected matter to be an object, not `%j`", result);
  }
  if (!own2.call(result, "type")) {
    throw fault("Missing `type` in matter `%j`", result);
  }
  if (!own2.call(result, "fence") && !own2.call(result, "marker")) {
    throw fault("Missing `marker` or `fence` in matter `%j`", result);
  }
  return result;
}

// node_modules/mdast-util-frontmatter/index.js
function frontmatterFromMarkdown(options) {
  const settings = matters(options);
  const enter = {};
  const exit3 = {};
  let index2 = -1;
  while (++index2 < settings.length) {
    const matter2 = settings[index2];
    enter[matter2.type] = opener(matter2);
    exit3[matter2.type] = close;
    exit3[matter2.type + "Value"] = value;
  }
  return { enter, exit: exit3 };
}
function opener(matter2) {
  return open;
  function open(token) {
    this.enter({ type: matter2.type, value: "" }, token);
    this.buffer();
  }
}
function close(token) {
  const data = this.resume();
  this.exit(token).value = data.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
}
function value(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}

// node_modules/ccount/index.js
function ccount(value2, character) {
  const source = String(value2);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character, index2 + character.length);
  }
  return count;
}

// node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/unist-util-is/index.js
var convert = function(test) {
  if (test === void 0 || test === null) {
    return ok;
  }
  if (typeof test === "string") {
    return typeFactory(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
  }
  if (typeof test === "function") {
    return castFactory(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all2);
  function all2(node) {
    let key;
    for (key in check) {
      if (node[key] !== check[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node) {
    return node && node.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(...parameters) {
    return Boolean(check.call(this, ...parameters));
  }
}
function ok() {
  return true;
}

// node_modules/unist-util-visit-parents/color.browser.js
function color(d) {
  return d;
}

// node_modules/unist-util-visit-parents/index.js
var CONTINUE = true;
var SKIP = "skip";
var EXIT = false;
var visitParents = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  const is = convert(test);
  const step = reverse ? -1 : 1;
  factory(tree, null, [])();
  function factory(node, index2, parents) {
    const value2 = typeof node === "object" && node !== null ? node : {};
    let name;
    if (typeof value2.type === "string") {
      name = typeof value2.tagName === "string" ? value2.tagName : typeof value2.name === "string" ? value2.name : void 0;
      Object.defineProperty(visit, "name", {
        value: "node (" + color(value2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit;
    function visit() {
      let result = [];
      let subresult;
      let offset;
      let grandparents;
      if (!test || is(node, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if (node.children && result[0] !== SKIP) {
        offset = (reverse ? node.children.length : -1) + step;
        grandparents = parents.concat(node);
        while (offset > -1 && offset < node.children.length) {
          subresult = factory(node.children[offset], offset, grandparents)();
          if (subresult[0] === EXIT) {
            return subresult;
          }
          offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
        }
      }
      return result;
    }
  }
};
function toResult(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  if (typeof value2 === "number") {
    return [CONTINUE, value2];
  }
  return [value2];
}

// node_modules/mdast-util-find-and-replace/lib/index.js
var own3 = {}.hasOwnProperty;
var findAndReplace = function(tree, find, replace2, options) {
  let settings;
  let schema;
  if (typeof find === "string" || find instanceof RegExp) {
    schema = [[find, replace2]];
    settings = options;
  } else {
    schema = find;
    settings = replace2;
  }
  if (!settings) {
    settings = {};
  }
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(schema);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  return tree;
  function visitor(node, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      if (ignored(parent, grandparent ? grandparent.children.indexOf(parent) : void 0, grandparent)) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node, parents);
    }
  }
  function handler(node, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace3 = pairs[pairIndex][1];
    let start = 0;
    const index2 = parent.children.indexOf(node);
    let change = false;
    let nodes = [];
    let position2;
    find2.lastIndex = 0;
    let match = find2.exec(node.value);
    while (match) {
      position2 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node]
      };
      let value2 = replace3(...match, matchObject);
      if (typeof value2 === "string") {
        value2 = value2.length > 0 ? { type: "text", value: value2 } : void 0;
      }
      if (value2 !== false) {
        if (start !== position2) {
          nodes.push({
            type: "text",
            value: node.value.slice(start, position2)
          });
        }
        if (Array.isArray(value2)) {
          nodes.push(...value2);
        } else if (value2) {
          nodes.push(value2);
        }
        start = position2 + match[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match = find2.exec(node.value);
    }
    if (change) {
      if (start < node.value.length) {
        nodes.push({ type: "text", value: node.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node];
    }
    return index2 + nodes.length;
  }
};
function toPairs(schema) {
  const result = [];
  if (typeof schema !== "object") {
    throw new TypeError("Expected array or object as schema");
  }
  if (Array.isArray(schema)) {
    let index2 = -1;
    while (++index2 < schema.length) {
      result.push([
        toExpression(schema[index2][0]),
        toFunction(schema[index2][1])
      ]);
    }
  } else {
    let key;
    for (key in schema) {
      if (own3.call(schema, key)) {
        result.push([toExpression(key), toFunction(schema[key])]);
      }
    }
  }
  return result;
}
function toExpression(find) {
  return typeof find === "string" ? new RegExp(escapeStringRegexp(find), "g") : find;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : () => replace2;
}

// node_modules/mdast-util-gfm-autolink-literal/index.js
var gfmAutolinkLiteralFromMarkdown = {
  transforms: [transformGfmAutolinkLiterals],
  enter: {
    literalAutolink: enterLiteralAutolink,
    literalAutolinkEmail: enterLiteralAutolinkValue,
    literalAutolinkHttp: enterLiteralAutolinkValue,
    literalAutolinkWww: enterLiteralAutolinkValue
  },
  exit: {
    literalAutolink: exitLiteralAutolink,
    literalAutolinkEmail: exitLiteralAutolinkEmail,
    literalAutolinkHttp: exitLiteralAutolinkHttp,
    literalAutolinkWww: exitLiteralAutolinkWww
  }
};
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node = this.stack[this.stack.length - 1];
  node.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(tree, [
    [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
    [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
  ], { ignore: ["link", "linkReference"] });
}
function findUrl(_, protocol, domain2, path2, match) {
  let prefix = "";
  if (!previous2(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path2);
  if (!parts[0])
    return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_, atext, label, match) {
  if (!previous2(match, true) || /[_-\d]$/.test(label)) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  let closingParenIndex;
  let openingParens;
  let closingParens;
  let trail;
  if (trailExec) {
    url = url.slice(0, trailExec.index);
    trail = trailExec[0];
    closingParenIndex = trail.indexOf(")");
    openingParens = ccount(url, "(");
    closingParens = ccount(url, ")");
    while (closingParenIndex !== -1 && openingParens > closingParens) {
      url += trail.slice(0, closingParenIndex + 1);
      trail = trail.slice(closingParenIndex + 1);
      closingParenIndex = trail.indexOf(")");
      closingParens++;
    }
  }
  return [url, trail];
}
function previous2(match, email) {
  const code2 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
}

// node_modules/mdast-util-to-markdown/lib/util/track.js
function track(options_) {
  const options = options_ || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;
  return { move, current, shift };
  function current() {
    return { now: { line, column }, lineShift };
  }
  function shift(value2) {
    lineShift += value2;
  }
  function move(value2 = "") {
    const chunks = value2.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value2;
  }
}

// node_modules/mdast-util-gfm-footnote/index.js
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
  function enterFootnoteDefinition(token) {
    this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, token);
  }
  function enterFootnoteDefinitionLabelString() {
    this.buffer();
  }
  function exitFootnoteDefinitionLabelString(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function exitFootnoteDefinition(token) {
    this.exit(token);
  }
  function enterFootnoteCall(token) {
    this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
  }
  function enterFootnoteCallString() {
    this.buffer();
  }
  function exitFootnoteCallString(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function exitFootnoteCall(token) {
    this.exit(token);
  }
}

// node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, context, safeOptions) {
  const indexStack = context.indexStack;
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  let before = safeOptions.before;
  indexStack.push(-1);
  let tracker = track(safeOptions);
  while (++index2 < children.length) {
    const child = children[index2];
    let after;
    indexStack[indexStack.length - 1] = index2;
    if (index2 + 1 < children.length) {
      let handle = context.handle.handlers[children[index2 + 1].type];
      if (handle && handle.peek)
        handle = handle.peek;
      after = handle ? handle(children[index2 + 1], parent, context, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after = safeOptions.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
      before = " ";
      tracker = track(safeOptions);
      tracker.move(results.join(""));
    }
    results.push(tracker.move(context.handle(child, parent, context, {
      ...tracker.current(),
      before,
      after
    })));
    before = results[results.length - 1].slice(-1);
  }
  indexStack.pop();
  return results.join("");
}

// node_modules/mdast-util-gfm-strikethrough/index.js
var gfmStrikethroughFromMarkdown = {
  canContainEols: ["delete"],
  enter: { strikethrough: enterStrikethrough },
  exit: { strikethrough: exitStrikethrough }
};
handleDelete.peek = peekDelete;
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node, _, context, safeOptions) {
  const tracker = track(safeOptions);
  const exit3 = context.enter("emphasis");
  let value2 = tracker.move("~~");
  value2 += containerPhrasing(node, context, {
    ...tracker.current(),
    before: value2,
    after: "~"
  });
  value2 += tracker.move("~~");
  exit3();
  return value2;
}
function peekDelete() {
  return "~";
}

// node_modules/mdast-util-gfm-table/lib/index.js
var gfmTableFromMarkdown = {
  enter: {
    table: enterTable,
    tableData: enterCell,
    tableHeader: enterCell,
    tableRow: enterRow
  },
  exit: {
    codeText: exitCodeText,
    table: exitTable,
    tableData: exit2,
    tableHeader: exit2,
    tableRow: exit2
  }
};
function enterTable(token) {
  const align = token._align;
  this.enter({
    type: "table",
    align: align.map((d) => d === "none" ? null : d),
    children: []
  }, token);
  this.setData("inTable", true);
}
function exitTable(token) {
  this.exit(token);
  this.setData("inTable");
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit2(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value2 = this.resume();
  if (this.getData("inTable")) {
    value2 = value2.replace(/\\([\\|])/g, replace);
  }
  const node = this.stack[this.stack.length - 1];
  node.value = value2;
  this.exit(token);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}

// node_modules/mdast-util-gfm-task-list-item/index.js
var gfmTaskListItemFromMarkdown = {
  exit: {
    taskListCheckValueChecked: exitCheck,
    taskListCheckValueUnchecked: exitCheck,
    paragraph: exitParagraphWithTaskListItem
  }
};
function exitCheck(token) {
  const node = this.stack[this.stack.length - 2];
  node.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  const node = this.stack[this.stack.length - 1];
  const siblings = parent.children;
  const head = node.children[0];
  let index2 = -1;
  let firstParaghraph;
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean" && head && head.type === "text") {
    while (++index2 < siblings.length) {
      const sibling = siblings[index2];
      if (sibling.type === "paragraph") {
        firstParaghraph = sibling;
        break;
      }
    }
    if (firstParaghraph === node) {
      head.value = head.value.slice(1);
      if (head.value.length === 0) {
        node.children.shift();
      } else if (node.position && head.position && typeof head.position.start.offset === "number") {
        head.position.start.column++;
        head.position.start.offset++;
        node.position.start = Object.assign({}, head.position.start);
      }
    }
  }
  this.exit(token);
}

// node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown,
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown,
    gfmTableFromMarkdown,
    gfmTaskListItemFromMarkdown
  ];
}

// node_modules/mdast-util-math/index.js
function mathFromMarkdown() {
  return {
    enter: {
      mathFlow: enterMathFlow,
      mathFlowFenceMeta: enterMathFlowMeta,
      mathText: enterMathText
    },
    exit: {
      mathFlow: exitMathFlow,
      mathFlowFence: exitMathFlowFence,
      mathFlowFenceMeta: exitMathFlowMeta,
      mathFlowValue: exitMathData,
      mathText: exitMathText,
      mathTextData: exitMathData
    }
  };
  function enterMathFlow(token) {
    this.enter({
      type: "math",
      meta: null,
      value: "",
      data: {
        hName: "div",
        hProperties: { className: ["math", "math-display"] },
        hChildren: [{ type: "text", value: "" }]
      }
    }, token);
  }
  function enterMathFlowMeta() {
    this.buffer();
  }
  function exitMathFlowMeta() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.meta = data;
  }
  function exitMathFlowFence() {
    if (this.getData("mathFlowInside"))
      return;
    this.buffer();
    this.setData("mathFlowInside", true);
  }
  function exitMathFlow(token) {
    const data = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    const node = this.exit(token);
    node.value = data;
    node.data.hChildren[0].value = data;
    this.setData("mathFlowInside");
  }
  function enterMathText(token) {
    this.enter({
      type: "inlineMath",
      value: "",
      data: {
        hName: "span",
        hProperties: { className: ["math", "math-inline"] },
        hChildren: [{ type: "text", value: "" }]
      }
    }, token);
    this.buffer();
  }
  function exitMathText(token) {
    const data = this.resume();
    const node = this.exit(token);
    node.value = data;
    node.data.hChildren[0].value = data;
  }
  function exitMathData(token) {
    this.config.enter.data.call(this, token);
    this.config.exit.data.call(this, token);
  }
}

// node_modules/micromark-extension-frontmatter/lib/syntax.js
function frontmatter(options) {
  const settings = matters(options);
  const flow3 = {};
  let index2 = -1;
  let matter2;
  let code2;
  while (++index2 < settings.length) {
    matter2 = settings[index2];
    code2 = fence(matter2, "open").charCodeAt(0);
    if (code2 in flow3) {
      flow3[code2].push(parse2(matter2));
    } else {
      flow3[code2] = [parse2(matter2)];
    }
  }
  return {
    flow: flow3
  };
}
function parse2(matter2) {
  const name = matter2.type;
  const anywhere = matter2.anywhere;
  const valueType = name + "Value";
  const fenceType = name + "Fence";
  const sequenceType = fenceType + "Sequence";
  const fenceConstruct = {
    tokenize: tokenizeFence,
    partial: true
  };
  let buffer;
  return {
    tokenize: tokenizeFrontmatter,
    concrete: true
  };
  function tokenizeFrontmatter(effects, ok2, nok) {
    const self = this;
    return start;
    function start(code2) {
      const position2 = self.now();
      if (position2.column !== 1 || !anywhere && position2.line !== 1) {
        return nok(code2);
      }
      effects.enter(name);
      buffer = fence(matter2, "open");
      return effects.attempt(fenceConstruct, afterOpeningFence, nok)(code2);
    }
    function afterOpeningFence(code2) {
      buffer = fence(matter2, "close");
      return lineEnd(code2);
    }
    function lineStart(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return lineEnd(code2);
      }
      effects.enter(valueType);
      return lineData(code2);
    }
    function lineData(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit(valueType);
        return lineEnd(code2);
      }
      effects.consume(code2);
      return lineData;
    }
    function lineEnd(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return effects.attempt(fenceConstruct, after, lineStart);
    }
    function after(code2) {
      effects.exit(name);
      return ok2(code2);
    }
  }
  function tokenizeFence(effects, ok2, nok) {
    let bufferIndex = 0;
    return start;
    function start(code2) {
      if (code2 === buffer.charCodeAt(bufferIndex)) {
        effects.enter(fenceType);
        effects.enter(sequenceType);
        return insideSequence(code2);
      }
      return nok(code2);
    }
    function insideSequence(code2) {
      if (bufferIndex === buffer.length) {
        effects.exit(sequenceType);
        if (markdownSpace(code2)) {
          effects.enter("whitespace");
          return insideWhitespace(code2);
        }
        return fenceEnd(code2);
      }
      if (code2 === buffer.charCodeAt(bufferIndex++)) {
        effects.consume(code2);
        return insideSequence;
      }
      return nok(code2);
    }
    function insideWhitespace(code2) {
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return insideWhitespace;
      }
      effects.exit("whitespace");
      return fenceEnd(code2);
    }
    function fenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit(fenceType);
        return ok2(code2);
      }
      return nok(code2);
    }
  }
}
function fence(matter2, prop) {
  return matter2.marker ? pick(matter2.marker, prop).repeat(3) : pick(matter2.fence, prop);
}
function pick(schema, prop) {
  return typeof schema === "string" ? schema : schema[prop];
}

// node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
var www = {
  tokenize: tokenizeWww,
  partial: true
};
var domain = {
  tokenize: tokenizeDomain,
  partial: true
};
var path = {
  tokenize: tokenizePath,
  partial: true
};
var punctuation = {
  tokenize: tokenizePunctuation,
  partial: true
};
var namedCharacterReference = {
  tokenize: tokenizeNamedCharacterReference,
  partial: true
};
var wwwAutolink = {
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
var httpAutolink = {
  tokenize: tokenizeHttpAutolink,
  previous: previousHttp
};
var emailAutolink = {
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
var text3 = {};
var gfmAutolinkLiteral = {
  text: text3
};
var code = 48;
while (code < 123) {
  text3[code] = emailAutolink;
  code++;
  if (code === 58)
    code = 65;
  else if (code === 91)
    code = 97;
}
text3[43] = emailAutolink;
text3[45] = emailAutolink;
text3[46] = emailAutolink;
text3[95] = emailAutolink;
text3[72] = [emailAutolink, httpAutolink];
text3[104] = [emailAutolink, httpAutolink];
text3[87] = [emailAutolink, wwwAutolink];
text3[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok2, nok) {
  const self = this;
  let hasDot;
  let hasDigitInLastSegment;
  return start;
  function start(code2) {
    if (!gfmAtext(code2) || !previousEmail(self.previous) || previousUnbalanced(self.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code2);
  }
  function atext(code2) {
    if (gfmAtext(code2)) {
      effects.consume(code2);
      return atext;
    }
    if (code2 === 64) {
      effects.consume(code2);
      return label;
    }
    return nok(code2);
  }
  function label(code2) {
    if (code2 === 46) {
      return effects.check(punctuation, done, dotContinuation)(code2);
    }
    if (code2 === 45 || code2 === 95) {
      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code2);
    }
    if (asciiAlphanumeric(code2)) {
      if (!hasDigitInLastSegment && asciiDigit(code2)) {
        hasDigitInLastSegment = true;
      }
      effects.consume(code2);
      return label;
    }
    return done(code2);
  }
  function dotContinuation(code2) {
    effects.consume(code2);
    hasDot = true;
    hasDigitInLastSegment = void 0;
    return label;
  }
  function dashOrUnderscoreContinuation(code2) {
    effects.consume(code2);
    return afterDashOrUnderscore;
  }
  function afterDashOrUnderscore(code2) {
    if (code2 === 46) {
      return effects.check(punctuation, nok, dotContinuation)(code2);
    }
    return label(code2);
  }
  function done(code2) {
    if (hasDot && !hasDigitInLastSegment) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeWwwAutolink(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 !== 87 && code2 !== 119 || !previousWww(self.previous) || previousUnbalanced(self.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(www, effects.attempt(domain, effects.attempt(path, done), nok), nok)(code2);
  }
  function done(code2) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeHttpAutolink(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 !== 72 && code2 !== 104 || !previousHttp(self.previous) || previousUnbalanced(self.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkHttp");
    effects.consume(code2);
    return t1;
  }
  function t1(code2) {
    if (code2 === 84 || code2 === 116) {
      effects.consume(code2);
      return t2;
    }
    return nok(code2);
  }
  function t2(code2) {
    if (code2 === 84 || code2 === 116) {
      effects.consume(code2);
      return p;
    }
    return nok(code2);
  }
  function p(code2) {
    if (code2 === 80 || code2 === 112) {
      effects.consume(code2);
      return s;
    }
    return nok(code2);
  }
  function s(code2) {
    if (code2 === 83 || code2 === 115) {
      effects.consume(code2);
      return colon;
    }
    return colon(code2);
  }
  function colon(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      return slash1;
    }
    return nok(code2);
  }
  function slash1(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return slash2;
    }
    return nok(code2);
  }
  function slash2(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || asciiControl(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path, done), nok)(code2);
  }
  function done(code2) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeWww(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return w2;
  }
  function w2(code2) {
    if (code2 === 87 || code2 === 119) {
      effects.consume(code2);
      return w3;
    }
    return nok(code2);
  }
  function w3(code2) {
    if (code2 === 87 || code2 === 119) {
      effects.consume(code2);
      return dot;
    }
    return nok(code2);
  }
  function dot(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? nok(code2) : ok2(code2);
  }
}
function tokenizeDomain(effects, ok2, nok) {
  let hasUnderscoreInLastSegment;
  let hasUnderscoreInLastLastSegment;
  return domain2;
  function domain2(code2) {
    if (code2 === 38) {
      return effects.check(namedCharacterReference, done, punctuationContinuation)(code2);
    }
    if (code2 === 46 || code2 === 95) {
      return effects.check(punctuation, done, punctuationContinuation)(code2);
    }
    if (code2 === null || asciiControl(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
      return done(code2);
    }
    effects.consume(code2);
    return domain2;
  }
  function punctuationContinuation(code2) {
    if (code2 === 46) {
      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
      hasUnderscoreInLastSegment = void 0;
      effects.consume(code2);
      return domain2;
    }
    if (code2 === 95)
      hasUnderscoreInLastSegment = true;
    effects.consume(code2);
    return domain2;
  }
  function done(code2) {
    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizePath(effects, ok2) {
  let balance = 0;
  return inPath;
  function inPath(code2) {
    if (code2 === 38) {
      return effects.check(namedCharacterReference, ok2, continuedPunctuation)(code2);
    }
    if (code2 === 40) {
      balance++;
    }
    if (code2 === 41) {
      return effects.check(punctuation, parenAtPathEnd, continuedPunctuation)(code2);
    }
    if (pathEnd(code2)) {
      return ok2(code2);
    }
    if (trailingPunctuation(code2)) {
      return effects.check(punctuation, ok2, continuedPunctuation)(code2);
    }
    effects.consume(code2);
    return inPath;
  }
  function continuedPunctuation(code2) {
    effects.consume(code2);
    return inPath;
  }
  function parenAtPathEnd(code2) {
    balance--;
    return balance < 0 ? ok2(code2) : continuedPunctuation(code2);
  }
}
function tokenizeNamedCharacterReference(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return inside;
  }
  function inside(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return inside;
    }
    if (code2 === 59) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return pathEnd(code2) ? ok2(code2) : nok(code2);
  }
}
function tokenizePunctuation(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (trailingPunctuation(code2)) {
      effects.consume(code2);
      return after;
    }
    return pathEnd(code2) ? ok2(code2) : nok(code2);
  }
}
function trailingPunctuation(code2) {
  return code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 95 || code2 === 126;
}
function pathEnd(code2) {
  return code2 === null || code2 === 60 || markdownLineEndingOrSpace(code2);
}
function gfmAtext(code2) {
  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
}
function previousWww(code2) {
  return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 126 || markdownLineEndingOrSpace(code2);
}
function previousHttp(code2) {
  return code2 === null || !asciiAlpha(code2);
}
function previousEmail(code2) {
  return code2 !== 47 && previousHttp(code2);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token = events[index2][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}

// node_modules/micromark-extension-gfm-footnote/lib/syntax.js
var indent = {
  tokenize: tokenizeIndent2,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
  const self = this;
  let index2 = self.events.length;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token = self.events[index2][1];
    if (token.type === "labelImage") {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code2);
    }
    const id = normalizeIdentifier(self.sliceSerialize({
      start: labelStart.end,
      end: self.now()
    }));
    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {
      return nok(code2);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok2(code2);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  let labelStart;
  while (index2--) {
    if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
      labelStart = events[index2][1];
      break;
    }
  }
  events[index2 + 1][1].type = "data";
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call, context],
    events[index2 + 3],
    events[index2 + 4],
    ["enter", marker, context],
    ["exit", marker, context],
    ["enter", string3, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string3, context],
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok2, nok) {
  const self = this;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code2) {
    if (code2 !== 94)
      return nok(code2);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code2) {
    let token;
    if (code2 === null || code2 === 91 || size++ > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      if (!data) {
        return nok(code2);
      }
      effects.exit("chunkString");
      token = effects.exit("gfmFootnoteCallString");
      return defined.includes(normalizeIdentifier(self.sliceSerialize(token))) ? end(code2) : nok(code2);
    }
    effects.consume(code2);
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    return code2 === 92 ? callEscape : callData;
  }
  function callEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return callData;
    }
    return callData(code2);
  }
  function end(code2) {
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    effects.exit("gfmFootnoteCall");
    return ok2;
  }
}
function tokenizeDefinitionStart(effects, ok2, nok) {
  const self = this;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let identifier;
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelStart;
  }
  function labelStart(code2) {
    if (code2 === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      return atBreak;
    }
    return nok(code2);
  }
  function atBreak(code2) {
    let token;
    if (code2 === null || code2 === 91 || size > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      if (!data) {
        return nok(code2);
      }
      token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      size++;
      return atBreak;
    }
    effects.enter("chunkString").contentType = "string";
    return label(code2);
  }
  function label(code2) {
    if (code2 === null || markdownLineEnding(code2) || code2 === 91 || code2 === 93 || size > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size++;
    effects.consume(code2);
    return code2 === 92 ? labelEscape : label;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return label;
    }
    return label(code2);
  }
  function labelAfter(code2) {
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return factorySpace(effects, done, "gfmFootnoteDefinitionWhitespace");
    }
    return nok(code2);
  }
  function done(code2) {
    if (!defined.includes(identifier)) {
      defined.push(identifier);
    }
    return ok2(code2);
  }
}
function tokenizeDefinitionContinuation(effects, ok2, nok) {
  return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent2(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 4 + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
function gfmStrikethrough(options = {}) {
  let single = options.singleTilde;
  const tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text4 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text4, context]
            ];
            splice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text4, context],
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context],
              ["exit", strikethrough, context]
            ]);
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok2, nok) {
    const previous4 = this.previous;
    const events = this.events;
    let size = 0;
    return start;
    function start(code2) {
      if (previous4 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code2);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code2);
    }
    function more(code2) {
      const before = classifyCharacter(previous4);
      if (code2 === 126) {
        if (size > 1)
          return nok(code2);
        effects.consume(code2);
        size++;
        return more;
      }
      if (size < 2 && !single)
        return nok(code2);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code2);
      token._open = !after || after === 2 && Boolean(before);
      token._close = !before || before === 2 && Boolean(after);
      return ok2(code2);
    }
  }
}

// node_modules/micromark-extension-gfm-table/lib/syntax.js
var gfmTable = {
  flow: {
    null: {
      tokenize: tokenizeTable,
      resolve: resolveTable
    }
  }
};
var nextPrefixedOrBlank = {
  tokenize: tokenizeNextPrefixedOrBlank,
  partial: true
};
function resolveTable(events, context) {
  let index2 = -1;
  let inHead;
  let inDelimiterRow;
  let inRow;
  let contentStart;
  let contentEnd;
  let cellStart;
  let seenCellInRow;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (inRow) {
      if (token.type === "temporaryTableCellContent") {
        contentStart = contentStart || index2;
        contentEnd = index2;
      }
      if ((token.type === "tableCellDivider" || token.type === "tableRow") && contentEnd) {
        const content3 = {
          type: "tableContent",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        const text4 = {
          type: "chunkText",
          start: content3.start,
          end: content3.end,
          contentType: "text"
        };
        events.splice(contentStart, contentEnd - contentStart + 1, ["enter", content3, context], ["enter", text4, context], ["exit", text4, context], ["exit", content3, context]);
        index2 -= contentEnd - contentStart - 3;
        contentStart = void 0;
        contentEnd = void 0;
      }
    }
    if (events[index2][0] === "exit" && cellStart !== void 0 && cellStart + (seenCellInRow ? 0 : 1) < index2 && (token.type === "tableCellDivider" || token.type === "tableRow" && (cellStart + 3 < index2 || events[cellStart][1].type !== "whitespace"))) {
      const cell = {
        type: inDelimiterRow ? "tableDelimiter" : inHead ? "tableHeader" : "tableData",
        start: events[cellStart][1].start,
        end: events[index2][1].end
      };
      events.splice(index2 + (token.type === "tableCellDivider" ? 1 : 0), 0, [
        "exit",
        cell,
        context
      ]);
      events.splice(cellStart, 0, ["enter", cell, context]);
      index2 += 2;
      cellStart = index2 + 1;
      seenCellInRow = true;
    }
    if (token.type === "tableRow") {
      inRow = events[index2][0] === "enter";
      if (inRow) {
        cellStart = index2 + 1;
        seenCellInRow = false;
      }
    }
    if (token.type === "tableDelimiterRow") {
      inDelimiterRow = events[index2][0] === "enter";
      if (inDelimiterRow) {
        cellStart = index2 + 1;
        seenCellInRow = false;
      }
    }
    if (token.type === "tableHead") {
      inHead = events[index2][0] === "enter";
    }
  }
  return events;
}
function tokenizeTable(effects, ok2, nok) {
  const self = this;
  const align = [];
  let tableHeaderCount = 0;
  let seenDelimiter;
  let hasDash;
  return start;
  function start(code2) {
    effects.enter("table")._align = align;
    effects.enter("tableHead");
    effects.enter("tableRow");
    if (code2 === 124) {
      return cellDividerHead(code2);
    }
    tableHeaderCount++;
    effects.enter("temporaryTableCellContent");
    return inCellContentHead(code2);
  }
  function cellDividerHead(code2) {
    effects.enter("tableCellDivider");
    effects.consume(code2);
    effects.exit("tableCellDivider");
    seenDelimiter = true;
    return cellBreakHead;
  }
  function cellBreakHead(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return atRowEndHead(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceHead;
    }
    if (seenDelimiter) {
      seenDelimiter = void 0;
      tableHeaderCount++;
    }
    if (code2 === 124) {
      return cellDividerHead(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentHead(code2);
  }
  function inWhitespaceHead(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceHead;
    }
    effects.exit("whitespace");
    return cellBreakHead(code2);
  }
  function inCellContentHead(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("temporaryTableCellContent");
      return cellBreakHead(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? inCellContentEscapeHead : inCellContentHead;
  }
  function inCellContentEscapeHead(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return inCellContentHead;
    }
    return inCellContentHead(code2);
  }
  function atRowEndHead(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.exit("tableRow");
    effects.exit("tableHead");
    const originalInterrupt = self.interrupt;
    self.interrupt = true;
    return effects.attempt({
      tokenize: tokenizeRowEnd,
      partial: true
    }, function(code3) {
      self.interrupt = originalInterrupt;
      effects.enter("tableDelimiterRow");
      return atDelimiterRowBreak(code3);
    }, function(code3) {
      self.interrupt = originalInterrupt;
      return nok(code3);
    })(code2);
  }
  function atDelimiterRowBreak(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return rowEndDelimiter(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      effects.consume(code2);
      hasDash = true;
      align.push("none");
      return inFillerDelimiter;
    }
    if (code2 === 58) {
      effects.enter("tableDelimiterAlignment");
      effects.consume(code2);
      effects.exit("tableDelimiterAlignment");
      align.push("left");
      return afterLeftAlignment;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return atDelimiterRowBreak;
    }
    return nok(code2);
  }
  function inWhitespaceDelimiter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    effects.exit("whitespace");
    return atDelimiterRowBreak(code2);
  }
  function inFillerDelimiter(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return inFillerDelimiter;
    }
    effects.exit("tableDelimiterFiller");
    if (code2 === 58) {
      effects.enter("tableDelimiterAlignment");
      effects.consume(code2);
      effects.exit("tableDelimiterAlignment");
      align[align.length - 1] = align[align.length - 1] === "left" ? "center" : "right";
      return afterRightAlignment;
    }
    return atDelimiterRowBreak(code2);
  }
  function afterLeftAlignment(code2) {
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      effects.consume(code2);
      hasDash = true;
      return inFillerDelimiter;
    }
    return nok(code2);
  }
  function afterRightAlignment(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return rowEndDelimiter(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return atDelimiterRowBreak;
    }
    return nok(code2);
  }
  function rowEndDelimiter(code2) {
    effects.exit("tableDelimiterRow");
    if (!hasDash || tableHeaderCount !== align.length) {
      return nok(code2);
    }
    if (code2 === null) {
      return tableClose(code2);
    }
    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({
      tokenize: tokenizeRowEnd,
      partial: true
    }, factorySpace(effects, bodyStart, "linePrefix", 4), tableClose))(code2);
  }
  function tableClose(code2) {
    effects.exit("table");
    return ok2(code2);
  }
  function bodyStart(code2) {
    effects.enter("tableBody");
    return rowStartBody(code2);
  }
  function rowStartBody(code2) {
    effects.enter("tableRow");
    if (code2 === 124) {
      return cellDividerBody(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentBody(code2);
  }
  function cellDividerBody(code2) {
    effects.enter("tableCellDivider");
    effects.consume(code2);
    effects.exit("tableCellDivider");
    return cellBreakBody;
  }
  function cellBreakBody(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return atRowEndBody(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceBody;
    }
    if (code2 === 124) {
      return cellDividerBody(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentBody(code2);
  }
  function inWhitespaceBody(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceBody;
    }
    effects.exit("whitespace");
    return cellBreakBody(code2);
  }
  function inCellContentBody(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("temporaryTableCellContent");
      return cellBreakBody(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? inCellContentEscapeBody : inCellContentBody;
  }
  function inCellContentEscapeBody(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return inCellContentBody;
    }
    return inCellContentBody(code2);
  }
  function atRowEndBody(code2) {
    effects.exit("tableRow");
    if (code2 === null) {
      return tableBodyClose(code2);
    }
    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({
      tokenize: tokenizeRowEnd,
      partial: true
    }, factorySpace(effects, rowStartBody, "linePrefix", 4), tableBodyClose))(code2);
  }
  function tableBodyClose(code2) {
    effects.exit("tableBody");
    return tableClose(code2);
  }
  function tokenizeRowEnd(effects2, ok3, nok2) {
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return factorySpace(effects2, prefixed, "linePrefix");
    }
    function prefixed(code2) {
      if (self.parser.lazy[self.now().line] || code2 === null || markdownLineEnding(code2)) {
        return nok2(code2);
      }
      const tail = self.events[self.events.length - 1];
      if (!self.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
        return nok2(code2);
      }
      self._gfmTableDynamicInterruptHack = true;
      return effects2.check(self.parser.constructs.flow, function(code3) {
        self._gfmTableDynamicInterruptHack = false;
        return nok2(code3);
      }, function(code3) {
        self._gfmTableDynamicInterruptHack = false;
        return ok3(code3);
      })(code2);
    }
  }
}
function tokenizeNextPrefixedOrBlank(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("check");
    effects.consume(code2);
    return whitespace;
  }
  function whitespace(code2) {
    if (code2 === -1 || code2 === 32) {
      effects.consume(code2);
      size++;
      return size === 4 ? ok2 : whitespace;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
var tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};
var gfmTaskListItem = {
  text: {
    [91]: tasklistCheck
  }
};
function tokenizeTasklistCheck(effects, ok2, nok) {
  const self = this;
  return open;
  function open(code2) {
    if (self.previous !== null || !self._gfmTasklistFirstContentOfListItem) {
      return nok(code2);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code2);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code2) {
    if (markdownLineEndingOrSpace(code2)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueUnchecked");
      return close2;
    }
    if (code2 === 88 || code2 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueChecked");
      return close2;
    }
    return nok(code2);
  }
  function close2(code2) {
    if (code2 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code2);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return effects.check({
        tokenize: spaceThenNonSpace
      }, ok2, nok);
    }
    return nok(code2);
  }
}
function spaceThenNonSpace(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, after, "whitespace");
  function after(code2) {
    const tail = self.events[self.events.length - 1];
    return (tail && tail[1].type === "whitespace" || markdownLineEnding(code2)) && code2 !== null ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral,
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable,
    gfmTaskListItem
  ]);
}

// node_modules/micromark-extension-math/lib/math-flow.js
var mathFlow = {
  tokenize: tokenizeMathFenced,
  concrete: true
};
var nonLazyLine = {
  tokenize: tokenizeNonLazyLine,
  partial: true
};
function tokenizeMathFenced(effects, ok2, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  const initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  return start;
  function start(code2) {
    effects.enter("mathFlow");
    effects.enter("mathFlowFence");
    effects.enter("mathFlowFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 36) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("mathFlowFenceSequence");
    return sizeOpen < 2 ? nok(code2) : factorySpace(effects, metaOpen, "whitespace")(code2);
  }
  function metaOpen(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("mathFlowFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("mathFlowFenceMeta");
      return openAfter(code2);
    }
    if (code2 === 36)
      return nok(code2);
    effects.consume(code2);
    return meta;
  }
  function openAfter(code2) {
    effects.exit("mathFlowFence");
    return self.interrupt ? ok2(code2) : contentStart(code2);
  }
  function contentStart(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(nonLazyLine, effects.attempt({
        tokenize: tokenizeClosingFence,
        partial: true
      }, after, initialSize ? factorySpace(effects, contentStart, "linePrefix", initialSize + 1) : contentStart), after)(code2);
    }
    effects.enter("mathFlowValue");
    return contentContinue(code2);
  }
  function contentContinue(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("mathFlowValue");
      return contentStart(code2);
    }
    effects.consume(code2);
    return contentContinue;
  }
  function after(code2) {
    effects.exit("mathFlow");
    return ok2(code2);
  }
  function tokenizeClosingFence(effects2, ok3, nok2) {
    let size = 0;
    return factorySpace(effects2, closingPrefixAfter, "linePrefix", 4);
    function closingPrefixAfter(code2) {
      effects2.enter("mathFlowFence");
      effects2.enter("mathFlowFenceSequence");
      return closingSequence(code2);
    }
    function closingSequence(code2) {
      if (code2 === 36) {
        effects2.consume(code2);
        size++;
        return closingSequence;
      }
      if (size < sizeOpen)
        return nok2(code2);
      effects2.exit("mathFlowFenceSequence");
      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code2);
    }
    function closingSequenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("mathFlowFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyLine(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self.parser.lazy[self.now().line] ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-extension-math/lib/math-text.js
function mathText(options = {}) {
  let single = options.singleDollarTextMath;
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    tokenize: tokenizeMathText,
    resolve: resolveMathText,
    previous: previous3
  };
  function tokenizeMathText(effects, ok2, nok) {
    const self = this;
    let sizeOpen = 0;
    let size;
    let token;
    return start;
    function start(code2) {
      effects.enter("mathText");
      effects.enter("mathTextSequence");
      return openingSequence(code2);
    }
    function openingSequence(code2) {
      if (code2 === 36) {
        effects.consume(code2);
        sizeOpen++;
        return openingSequence;
      }
      if (sizeOpen < 2 && !single)
        return nok(code2);
      effects.exit("mathTextSequence");
      return gap(code2);
    }
    function gap(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 36) {
        token = effects.enter("mathTextSequence");
        size = 0;
        return closingSequence(code2);
      }
      if (code2 === 32) {
        effects.enter("space");
        effects.consume(code2);
        effects.exit("space");
        return gap;
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return gap;
      }
      effects.enter("mathTextData");
      return data(code2);
    }
    function data(code2) {
      if (code2 === null || code2 === 32 || code2 === 36 || markdownLineEnding(code2)) {
        effects.exit("mathTextData");
        return gap(code2);
      }
      effects.consume(code2);
      return data;
    }
    function closingSequence(code2) {
      if (code2 === 36) {
        effects.consume(code2);
        size++;
        return closingSequence;
      }
      if (size === sizeOpen) {
        effects.exit("mathTextSequence");
        effects.exit("mathText");
        return ok2(code2);
      }
      token.type = "mathTextData";
      return data(code2);
    }
  }
}
function resolveMathText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "mathTextData") {
        events[tailExitIndex][1].type = "mathTextPadding";
        events[headEnterIndex][1].type = "mathTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "mathTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous3(code2) {
  return code2 !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}

// node_modules/micromark-extension-math/lib/syntax.js
function math(options) {
  return {
    flow: {
      [36]: mathFlow
    },
    text: {
      [36]: mathText(options)
    }
  };
}

// src/Mdast.ts
var Mdast = class {
  static isInParagraph(ancestors) {
    for (let i = ancestors.length - 1; i >= 0; --i) {
      if (ancestors[i].type === "paragraph") {
        return true;
      }
      if (ancestors[i].type === "section") {
        return false;
      }
    }
    return false;
  }
  static findParentParagraph(ancestors) {
    for (let i = ancestors.length - 1; i >= 0; --i) {
      if (ancestors[i].type === "paragraph") {
        return ancestors[i];
      }
      if (ancestors[i].type === "section") {
        return void 0;
      }
    }
    return void 0;
  }
  static findAncestorWithLargerRange(node, ancestors) {
    if (ancestors.length === 0) {
      return node;
    }
    for (let i = ancestors.length - 1; i >= 0; --i) {
      if (AstPosMath.compareTo(ancestors[i].position.start, node.position.start) < 0 || AstPosMath.compareTo(ancestors[i].position.end, node.position.end) > 0) {
        return ancestors[i];
      }
    }
    return ancestors[0];
  }
};
var MarkdownASTBuilder = class {
  static parse(markdown) {
    const tree = fromMarkdown(markdown, {
      extensions: [
        math(),
        gfmTaskListItem,
        gfmTable,
        gfmStrikethrough(),
        gfmFootnote(),
        gfmAutolinkLiteral,
        gfm(),
        frontmatter(["yaml"])
      ],
      mdastExtensions: [
        mathFromMarkdown(),
        gfmTaskListItemFromMarkdown,
        gfmTableFromMarkdown,
        gfmStrikethroughFromMarkdown,
        gfmFootnoteFromMarkdown(),
        gfmAutolinkLiteralFromMarkdown,
        gfmFromMarkdown(),
        frontmatterFromMarkdown(["yaml"])
      ]
    });
    this.nestSections(tree);
    return tree;
  }
  static nestSections(tree) {
    var _a, _b, _c, _d;
    for (let depth = 6; depth >= 1; --depth) {
      let currentSection = void 0;
      for (let i = 0; i < tree.children.length; ++i) {
        if (tree.children[i].type === "heading") {
          const heading = tree.children[i];
          if (heading.depth === depth) {
            const sectionContent = {
              type: "section-content",
              children: [],
              position: {
                start: heading.position.end,
                end: heading.position.end
              }
            };
            const subSections = {
              type: "sub-sections",
              children: [],
              position: {
                start: heading.position.end,
                end: heading.position.end
              }
            };
            currentSection = {
              type: "section",
              children: [heading, sectionContent, subSections],
              position: {
                start: heading.position.start,
                end: heading.position.end
              }
            };
            tree.children[i] = currentSection;
          } else if (heading.depth < depth) {
            currentSection = void 0;
          }
        } else {
          if (currentSection) {
            if (tree.children[i].type === "section") {
              if (currentSection.children[2].children.length == 0) {
                currentSection.children[2].position.start = (_a = tree.children[i].position) == null ? void 0 : _a.start;
              }
              currentSection.children[2].position.end = (_b = tree.children[i].position) == null ? void 0 : _b.end;
              currentSection.children[2].children.push(tree.children[i]);
            } else {
              if (currentSection.children[1].children.length == 0) {
                currentSection.children[1].position.start = (_c = tree.children[i].position) == null ? void 0 : _c.start;
              }
              currentSection.children[1].position.end = (_d = tree.children[i].position) == null ? void 0 : _d.end;
              currentSection.children[1].children.push(tree.children[i]);
              currentSection.children[2].position.start = currentSection.children[1].position.end;
              currentSection.children[2].position.end = currentSection.children[1].position.end;
            }
            currentSection.position.end = tree.children[i].position.end;
            tree.children[i] = void 0;
          }
        }
      }
      tree.children = tree.children.filter((node) => !!node);
    }
  }
};

// src/SimpleText.ts
var import_antlr4ts = __toESM(require_antlr4ts());
var import_AbstractParseTreeVisitor = __toESM(require_AbstractParseTreeVisitor());

// src/grammar/SimpleTextLexer.ts
var import_ATNDeserializer = __toESM(require_ATNDeserializer());
var import_Lexer = __toESM(require_Lexer());
var import_LexerATNSimulator = __toESM(require_LexerATNSimulator());
var import_VocabularyImpl = __toESM(require_VocabularyImpl());
var Utils = __toESM(require_Utils());
var _SimpleTextLexer = class extends import_Lexer.Lexer {
  get vocabulary() {
    return _SimpleTextLexer.VOCABULARY;
  }
  constructor(input) {
    super(input);
    this._interp = new import_LexerATNSimulator.LexerATNSimulator(_SimpleTextLexer._ATN, this);
  }
  get grammarFileName() {
    return "SimpleText.g4";
  }
  get ruleNames() {
    return _SimpleTextLexer.ruleNames;
  }
  get serializedATN() {
    return _SimpleTextLexer._serializedATN;
  }
  get channelNames() {
    return _SimpleTextLexer.channelNames;
  }
  get modeNames() {
    return _SimpleTextLexer.modeNames;
  }
  static get _ATN() {
    if (!_SimpleTextLexer.__ATN) {
      _SimpleTextLexer.__ATN = new import_ATNDeserializer.ATNDeserializer().deserialize(Utils.toCharArray(_SimpleTextLexer._serializedATN));
    }
    return _SimpleTextLexer.__ATN;
  }
};
var SimpleTextLexer = _SimpleTextLexer;
SimpleTextLexer.Word = 1;
SimpleTextLexer.Smiley = 2;
SimpleTextLexer.Url = 3;
SimpleTextLexer.DOT = 4;
SimpleTextLexer.QUESTION_MARK = 5;
SimpleTextLexer.EXCLAMATION_MARK = 6;
SimpleTextLexer.LPAREN = 7;
SimpleTextLexer.RPAREN = 8;
SimpleTextLexer.LACCOL = 9;
SimpleTextLexer.RACCOL = 10;
SimpleTextLexer.LBRACK = 11;
SimpleTextLexer.RBRACK = 12;
SimpleTextLexer.QUOTE = 13;
SimpleTextLexer.DQUOTE = 14;
SimpleTextLexer.COLON = 15;
SimpleTextLexer.COMMA = 16;
SimpleTextLexer.SEMICOLON = 17;
SimpleTextLexer.SMILEY = 18;
SimpleTextLexer.WS = 19;
SimpleTextLexer.channelNames = [
  "DEFAULT_TOKEN_CHANNEL",
  "HIDDEN"
];
SimpleTextLexer.modeNames = [
  "DEFAULT_MODE"
];
SimpleTextLexer.ruleNames = [
  "Word",
  "Smiley",
  "Url",
  "DOT",
  "QUESTION_MARK",
  "EXCLAMATION_MARK",
  "LPAREN",
  "RPAREN",
  "LACCOL",
  "RACCOL",
  "LBRACK",
  "RBRACK",
  "QUOTE",
  "DQUOTE",
  "COLON",
  "COMMA",
  "SEMICOLON",
  "SMILEY",
  "SPACE",
  "WS"
];
SimpleTextLexer._LITERAL_NAMES = [
  void 0,
  void 0,
  void 0,
  void 0,
  "'.'",
  "'?'",
  "'!'",
  "'('",
  "')'",
  "'{'",
  "'}'",
  "'['",
  "']'",
  void 0,
  `'"'`,
  "':'",
  "','",
  "';'"
];
SimpleTextLexer._SYMBOLIC_NAMES = [
  void 0,
  "Word",
  "Smiley",
  "Url",
  "DOT",
  "QUESTION_MARK",
  "EXCLAMATION_MARK",
  "LPAREN",
  "RPAREN",
  "LACCOL",
  "RACCOL",
  "LBRACK",
  "RBRACK",
  "QUOTE",
  "DQUOTE",
  "COLON",
  "COMMA",
  "SEMICOLON",
  "SMILEY",
  "WS"
];
SimpleTextLexer.VOCABULARY = new import_VocabularyImpl.VocabularyImpl(_SimpleTextLexer._LITERAL_NAMES, _SimpleTextLexer._SYMBOLIC_NAMES, []);
SimpleTextLexer._serializedATN = `\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\x7F\b					\x07	\x07\b	\b			
	
\v	\v\f	\f\r	\r								\x07-
\f0\v3
\r4?
G
\rH\x07\x07\b\b		

\v\v\f\f\r\r\`
l
u
z
\r{\x07	\v\x07\r\b	
\v\f\r\x1B!#%')	\v\f"$*+..00==AA]]__}}\x7F\x7F\v\f"$)+..00<=AA]]__}}\x7F\x7F2;C\\c|\x07%%''-]__c|<=*+FFrr~~\v\f""\x85\x07	\v\r\x1B!#%).6\x078	J\vL\rNPRTVXZ\x1B_ac!e#g%t'v)y+-
,+-0.,.//20.13
21344245567%789\x07j9:\x07v:;\x07v;<\x07r<>=?\x07u>=>??@@A\x07<AB\x071BC\x071CDDF	EG	FEGHHFHII\bJK\x070K
LM\x07AM\fNO\x07#OPQ\x07*QRS\x07+STU\x07}UVW\x07\x7FWXY\x07]YZ[\x07_[\\]\x07"]\`\x07)^\`\x07)_\\_^\`ab\x07$bcd\x07<d ef\x07.f"gh\x07=h$ik	jl\x07/kjkllmmn	\x07nu'op\x07:pq\x07/qr\x07+rssu'titou&vw	\bw(xz'yxz{{y{||}}~\b~*\v.4>H_kt{\b`;

// src/grammar/SimpleTextParser.ts
var import_ATN = __toESM(require_ATN());
var import_ATNDeserializer2 = __toESM(require_ATNDeserializer());
var import_FailedPredicateException = __toESM(require_FailedPredicateException());
var import_NoViableAltException = __toESM(require_NoViableAltException());
var import_Parser = __toESM(require_Parser());
var import_ParserRuleContext = __toESM(require_ParserRuleContext());
var import_ParserATNSimulator = __toESM(require_ParserATNSimulator());
var import_RecognitionException = __toESM(require_RecognitionException());
var import_Token = __toESM(require_Token());
var import_VocabularyImpl2 = __toESM(require_VocabularyImpl());
var Utils2 = __toESM(require_Utils());
var _SimpleTextParser = class extends import_Parser.Parser {
  get vocabulary() {
    return _SimpleTextParser.VOCABULARY;
  }
  get grammarFileName() {
    return "SimpleText.g4";
  }
  get ruleNames() {
    return _SimpleTextParser.ruleNames;
  }
  get serializedATN() {
    return _SimpleTextParser._serializedATN;
  }
  createFailedPredicateException(predicate, message) {
    return new import_FailedPredicateException.FailedPredicateException(this, predicate, message);
  }
  constructor(input) {
    super(input);
    this._interp = new import_ParserATNSimulator.ParserATNSimulator(_SimpleTextParser._ATN, this);
  }
  paragraph() {
    let _localctx = new ParagraphContext(this._ctx, this.state);
    this.enterRule(_localctx, 0, _SimpleTextParser.RULE_paragraph);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 17;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
          {
            {
              this.state = 14;
              this.sentence();
            }
          }
          this.state = 19;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  sentence() {
    let _localctx = new SentenceContext(this._ctx, this.state);
    this.enterRule(_localctx, 2, _SimpleTextParser.RULE_sentence);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 21;
        this._errHandler.sync(this);
        _alt = 1;
        do {
          switch (_alt) {
            case 1:
              {
                {
                  this.state = 20;
                  this.proposition();
                }
              }
              break;
            default:
              throw new import_NoViableAltException.NoViableAltException(this);
          }
          this.state = 23;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 1, this._ctx);
        } while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER);
        this.state = 26;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.DOT | 1 << _SimpleTextParser.QUESTION_MARK | 1 << _SimpleTextParser.EXCLAMATION_MARK)) !== 0) {
          {
            this.state = 25;
            this.endPunctuation();
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  proposition() {
    let _localctx = new PropositionContext(this._ctx, this.state);
    this.enterRule(_localctx, 4, _SimpleTextParser.RULE_proposition);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 30;
        this._errHandler.sync(this);
        _alt = 1;
        do {
          switch (_alt) {
            case 1:
              {
                this.state = 30;
                this._errHandler.sync(this);
                switch (this._input.LA(1)) {
                  case _SimpleTextParser.Word:
                  case _SimpleTextParser.Smiley:
                  case _SimpleTextParser.Url:
                    {
                      this.state = 28;
                      this.word();
                    }
                    break;
                  case _SimpleTextParser.LPAREN:
                  case _SimpleTextParser.LACCOL:
                  case _SimpleTextParser.LBRACK:
                  case _SimpleTextParser.QUOTE:
                  case _SimpleTextParser.DQUOTE:
                    {
                      this.state = 29;
                      this.expression();
                    }
                    break;
                  default:
                    throw new import_NoViableAltException.NoViableAltException(this);
                }
              }
              break;
            default:
              throw new import_NoViableAltException.NoViableAltException(this);
          }
          this.state = 32;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 4, this._ctx);
        } while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER);
        this.state = 35;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.COLON | 1 << _SimpleTextParser.COMMA | 1 << _SimpleTextParser.SEMICOLON)) !== 0) {
          {
            this.state = 34;
            this.midPunctuation();
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  midPunctuation() {
    let _localctx = new MidPunctuationContext(this._ctx, this.state);
    this.enterRule(_localctx, 6, _SimpleTextParser.RULE_midPunctuation);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 37;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.COLON | 1 << _SimpleTextParser.COMMA | 1 << _SimpleTextParser.SEMICOLON)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  endPunctuation() {
    let _localctx = new EndPunctuationContext(this._ctx, this.state);
    this.enterRule(_localctx, 8, _SimpleTextParser.RULE_endPunctuation);
    let _la;
    try {
      this.state = 46;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SimpleTextParser.DOT:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 40;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
              {
                {
                  this.state = 39;
                  this.match(_SimpleTextParser.DOT);
                }
              }
              this.state = 42;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            } while (_la === _SimpleTextParser.DOT);
          }
          break;
        case _SimpleTextParser.QUESTION_MARK:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 44;
            this.match(_SimpleTextParser.QUESTION_MARK);
          }
          break;
        case _SimpleTextParser.EXCLAMATION_MARK:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 45;
            this.match(_SimpleTextParser.EXCLAMATION_MARK);
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  word() {
    let _localctx = new WordContext(this._ctx, this.state);
    this.enterRule(_localctx, 10, _SimpleTextParser.RULE_word);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 48;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  expression() {
    let _localctx = new ExpressionContext(this._ctx, this.state);
    this.enterRule(_localctx, 12, _SimpleTextParser.RULE_expression);
    let _la;
    try {
      let _alt;
      this.state = 90;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SimpleTextParser.LPAREN:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 50;
            this.match(_SimpleTextParser.LPAREN);
            this.state = 54;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
              {
                {
                  this.state = 51;
                  this.sentence();
                }
              }
              this.state = 56;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 57;
            this.match(_SimpleTextParser.RPAREN);
          }
          break;
        case _SimpleTextParser.QUOTE:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 58;
            this.match(_SimpleTextParser.QUOTE);
            this.state = 62;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
            while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 59;
                    this.sentence();
                  }
                }
              }
              this.state = 64;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
            }
            this.state = 65;
            this.match(_SimpleTextParser.QUOTE);
          }
          break;
        case _SimpleTextParser.DQUOTE:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 66;
            this.match(_SimpleTextParser.DQUOTE);
            this.state = 70;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 10, this._ctx);
            while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 67;
                    this.sentence();
                  }
                }
              }
              this.state = 72;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 10, this._ctx);
            }
            this.state = 73;
            this.match(_SimpleTextParser.DQUOTE);
          }
          break;
        case _SimpleTextParser.LBRACK:
          this.enterOuterAlt(_localctx, 4);
          {
            this.state = 74;
            this.match(_SimpleTextParser.LBRACK);
            this.state = 78;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
              {
                {
                  this.state = 75;
                  this.sentence();
                }
              }
              this.state = 80;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 81;
            this.match(_SimpleTextParser.RBRACK);
          }
          break;
        case _SimpleTextParser.LACCOL:
          this.enterOuterAlt(_localctx, 5);
          {
            this.state = 82;
            this.match(_SimpleTextParser.LACCOL);
            this.state = 86;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
              {
                {
                  this.state = 83;
                  this.sentence();
                }
              }
              this.state = 88;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 89;
            this.match(_SimpleTextParser.RACCOL);
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  static get _ATN() {
    if (!_SimpleTextParser.__ATN) {
      _SimpleTextParser.__ATN = new import_ATNDeserializer2.ATNDeserializer().deserialize(Utils2.toCharArray(_SimpleTextParser._serializedATN));
    }
    return _SimpleTextParser.__ATN;
  }
};
var SimpleTextParser = _SimpleTextParser;
SimpleTextParser.Word = 1;
SimpleTextParser.Smiley = 2;
SimpleTextParser.Url = 3;
SimpleTextParser.DOT = 4;
SimpleTextParser.QUESTION_MARK = 5;
SimpleTextParser.EXCLAMATION_MARK = 6;
SimpleTextParser.LPAREN = 7;
SimpleTextParser.RPAREN = 8;
SimpleTextParser.LACCOL = 9;
SimpleTextParser.RACCOL = 10;
SimpleTextParser.LBRACK = 11;
SimpleTextParser.RBRACK = 12;
SimpleTextParser.QUOTE = 13;
SimpleTextParser.DQUOTE = 14;
SimpleTextParser.COLON = 15;
SimpleTextParser.COMMA = 16;
SimpleTextParser.SEMICOLON = 17;
SimpleTextParser.SMILEY = 18;
SimpleTextParser.WS = 19;
SimpleTextParser.RULE_paragraph = 0;
SimpleTextParser.RULE_sentence = 1;
SimpleTextParser.RULE_proposition = 2;
SimpleTextParser.RULE_midPunctuation = 3;
SimpleTextParser.RULE_endPunctuation = 4;
SimpleTextParser.RULE_word = 5;
SimpleTextParser.RULE_expression = 6;
SimpleTextParser.ruleNames = [
  "paragraph",
  "sentence",
  "proposition",
  "midPunctuation",
  "endPunctuation",
  "word",
  "expression"
];
SimpleTextParser._LITERAL_NAMES = [
  void 0,
  void 0,
  void 0,
  void 0,
  "'.'",
  "'?'",
  "'!'",
  "'('",
  "')'",
  "'{'",
  "'}'",
  "'['",
  "']'",
  void 0,
  `'"'`,
  "':'",
  "','",
  "';'"
];
SimpleTextParser._SYMBOLIC_NAMES = [
  void 0,
  "Word",
  "Smiley",
  "Url",
  "DOT",
  "QUESTION_MARK",
  "EXCLAMATION_MARK",
  "LPAREN",
  "RPAREN",
  "LACCOL",
  "RACCOL",
  "LBRACK",
  "RBRACK",
  "QUOTE",
  "DQUOTE",
  "COLON",
  "COMMA",
  "SEMICOLON",
  "SMILEY",
  "WS"
];
SimpleTextParser.VOCABULARY = new import_VocabularyImpl2.VocabularyImpl(_SimpleTextParser._LITERAL_NAMES, _SimpleTextParser._SYMBOLIC_NAMES, []);
SimpleTextParser._serializedATN = `\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241_					\x07	\x07\b	\b\x07
\f\v
\r
!
\r"&
+
\r,1
\x07\x07\b\b\x07\b7
\b\f\b\b:\v\b\b\b\b\x07\b?
\b\f\b\bB\v\b\b\b\b\x07\bG
\b\f\b\bJ\v\b\b\b\b\x07\bO
\b\f\b\bR\v\b\b\b\b\x07\bW
\b\f\b\bZ\v\b\b\b]
\b\b	\b
\fi \b'
0\f2\\\x1B
\x1B!\f\x07!\b  !"" "##%$&\b%$%&&\x07'(	(	)+\x07*)+,,*,--1.1\x07\x07/1\x07\b0*0.0/1\v23	3\r48\x07	57657:86899;:8;]\x07
<@\x07=?>=?B@>@AACB@C]\x07DH\x07EGFEGJHFHIIKJHK]\x07LP\x07\rMONMORPNPQQSRPS]\x07TX\x07\vUWVUWZXVXYY[ZX[]\x07\f\\4\\<\\D\\L\\T] "%,08@HPX\\`;
var ParagraphContext = class extends import_ParserRuleContext.ParserRuleContext {
  sentence(i) {
    if (i === void 0) {
      return this.getRuleContexts(SentenceContext);
    } else {
      return this.getRuleContext(i, SentenceContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_paragraph;
  }
  enterRule(listener) {
    if (listener.enterParagraph) {
      listener.enterParagraph(this);
    }
  }
  exitRule(listener) {
    if (listener.exitParagraph) {
      listener.exitParagraph(this);
    }
  }
  accept(visitor) {
    if (visitor.visitParagraph) {
      return visitor.visitParagraph(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var SentenceContext = class extends import_ParserRuleContext.ParserRuleContext {
  proposition(i) {
    if (i === void 0) {
      return this.getRuleContexts(PropositionContext);
    } else {
      return this.getRuleContext(i, PropositionContext);
    }
  }
  endPunctuation() {
    return this.tryGetRuleContext(0, EndPunctuationContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_sentence;
  }
  enterRule(listener) {
    if (listener.enterSentence) {
      listener.enterSentence(this);
    }
  }
  exitRule(listener) {
    if (listener.exitSentence) {
      listener.exitSentence(this);
    }
  }
  accept(visitor) {
    if (visitor.visitSentence) {
      return visitor.visitSentence(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var PropositionContext = class extends import_ParserRuleContext.ParserRuleContext {
  word(i) {
    if (i === void 0) {
      return this.getRuleContexts(WordContext);
    } else {
      return this.getRuleContext(i, WordContext);
    }
  }
  expression(i) {
    if (i === void 0) {
      return this.getRuleContexts(ExpressionContext);
    } else {
      return this.getRuleContext(i, ExpressionContext);
    }
  }
  midPunctuation() {
    return this.tryGetRuleContext(0, MidPunctuationContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_proposition;
  }
  enterRule(listener) {
    if (listener.enterProposition) {
      listener.enterProposition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitProposition) {
      listener.exitProposition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitProposition) {
      return visitor.visitProposition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var MidPunctuationContext = class extends import_ParserRuleContext.ParserRuleContext {
  COMMA() {
    return this.tryGetToken(SimpleTextParser.COMMA, 0);
  }
  COLON() {
    return this.tryGetToken(SimpleTextParser.COLON, 0);
  }
  SEMICOLON() {
    return this.tryGetToken(SimpleTextParser.SEMICOLON, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_midPunctuation;
  }
  enterRule(listener) {
    if (listener.enterMidPunctuation) {
      listener.enterMidPunctuation(this);
    }
  }
  exitRule(listener) {
    if (listener.exitMidPunctuation) {
      listener.exitMidPunctuation(this);
    }
  }
  accept(visitor) {
    if (visitor.visitMidPunctuation) {
      return visitor.visitMidPunctuation(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var EndPunctuationContext = class extends import_ParserRuleContext.ParserRuleContext {
  DOT(i) {
    if (i === void 0) {
      return this.getTokens(SimpleTextParser.DOT);
    } else {
      return this.getToken(SimpleTextParser.DOT, i);
    }
  }
  QUESTION_MARK() {
    return this.tryGetToken(SimpleTextParser.QUESTION_MARK, 0);
  }
  EXCLAMATION_MARK() {
    return this.tryGetToken(SimpleTextParser.EXCLAMATION_MARK, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_endPunctuation;
  }
  enterRule(listener) {
    if (listener.enterEndPunctuation) {
      listener.enterEndPunctuation(this);
    }
  }
  exitRule(listener) {
    if (listener.exitEndPunctuation) {
      listener.exitEndPunctuation(this);
    }
  }
  accept(visitor) {
    if (visitor.visitEndPunctuation) {
      return visitor.visitEndPunctuation(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var WordContext = class extends import_ParserRuleContext.ParserRuleContext {
  Word() {
    return this.tryGetToken(SimpleTextParser.Word, 0);
  }
  Smiley() {
    return this.tryGetToken(SimpleTextParser.Smiley, 0);
  }
  Url() {
    return this.tryGetToken(SimpleTextParser.Url, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_word;
  }
  enterRule(listener) {
    if (listener.enterWord) {
      listener.enterWord(this);
    }
  }
  exitRule(listener) {
    if (listener.exitWord) {
      listener.exitWord(this);
    }
  }
  accept(visitor) {
    if (visitor.visitWord) {
      return visitor.visitWord(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {
  LPAREN() {
    return this.tryGetToken(SimpleTextParser.LPAREN, 0);
  }
  RPAREN() {
    return this.tryGetToken(SimpleTextParser.RPAREN, 0);
  }
  sentence(i) {
    if (i === void 0) {
      return this.getRuleContexts(SentenceContext);
    } else {
      return this.getRuleContext(i, SentenceContext);
    }
  }
  QUOTE(i) {
    if (i === void 0) {
      return this.getTokens(SimpleTextParser.QUOTE);
    } else {
      return this.getToken(SimpleTextParser.QUOTE, i);
    }
  }
  DQUOTE(i) {
    if (i === void 0) {
      return this.getTokens(SimpleTextParser.DQUOTE);
    } else {
      return this.getToken(SimpleTextParser.DQUOTE, i);
    }
  }
  LBRACK() {
    return this.tryGetToken(SimpleTextParser.LBRACK, 0);
  }
  RBRACK() {
    return this.tryGetToken(SimpleTextParser.RBRACK, 0);
  }
  LACCOL() {
    return this.tryGetToken(SimpleTextParser.LACCOL, 0);
  }
  RACCOL() {
    return this.tryGetToken(SimpleTextParser.RACCOL, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_expression;
  }
  enterRule(listener) {
    if (listener.enterExpression) {
      listener.enterExpression(this);
    }
  }
  exitRule(listener) {
    if (listener.exitExpression) {
      listener.exitExpression(this);
    }
  }
  accept(visitor) {
    if (visitor.visitExpression) {
      return visitor.visitExpression(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};

// src/SimpleText.ts
var BuildASTVisitor = class extends import_AbstractParseTreeVisitor.AbstractParseTreeVisitor {
  defaultResult() {
    return {
      type: "default",
      position: {}
    };
  }
  visitParagraph(ctx) {
    return this.processGroup(ctx, "paragraph");
  }
  visitSentence(ctx) {
    return this.processGroup(ctx, "sentence");
  }
  visitProposition(ctx) {
    return this.processGroup(ctx, "proposition");
  }
  visitExpression(ctx) {
    return this.processGroup(ctx, "expression");
  }
  processGroup(ctx, type) {
    var _a;
    const children = (_a = ctx.children) == null ? void 0 : _a.map((child) => this.visit(child));
    return this.createNode(ctx, type, children != null ? children : []);
  }
  visitWord(ctx) {
    return this.processTerminal(ctx, "word");
  }
  visitEndPunctuation(ctx) {
    return this.processTerminal(ctx, "punctuation");
  }
  visitMidPunctuation(ctx) {
    return this.processTerminal(ctx, "mid-punctuation");
  }
  processTerminal(ctx, type) {
    return {
      type,
      position: {
        start: {
          line: ctx.start.line,
          column: ctx.start.charPositionInLine + 1
        },
        end: {
          line: ctx.start.line,
          column: ctx.start.charPositionInLine + ctx.text.length
        }
      },
      text: ctx.text,
      children: []
    };
  }
  createNode(ctx, type, children) {
    var _a;
    const endToken = (_a = ctx.stop) != null ? _a : ctx.start;
    return {
      type,
      position: {
        start: { line: ctx.start.line, column: 1 + ctx.start.charPositionInLine },
        end: { line: endToken.line, column: endToken.charPositionInLine }
      },
      text: ctx.text,
      children
    };
  }
};
function fixupAst(node) {
  var _a, _b;
  (_a = node.children) == null ? void 0 : _a.forEach((child) => fixupAst(child));
  const lastChild = node.children ? node.children[node.children.length - 1] : void 0;
  node.position.end = (_b = lastChild == null ? void 0 : lastChild.position.end) != null ? _b : node.position.end;
}
var SimpleText;
((SimpleText2) => {
  function parse3(text4) {
    const inputStream = new import_antlr4ts.ANTLRInputStream(text4);
    const lexer = new SimpleTextLexer(inputStream);
    const tokenStream = new import_antlr4ts.CommonTokenStream(lexer);
    const parser = new SimpleTextParser(tokenStream);
    const tree = parser.paragraph();
    const builder = new BuildASTVisitor();
    const ast = builder.visit(tree);
    fixupAst(ast);
    return ast;
  }
  SimpleText2.parse = parse3;
})(SimpleText || (SimpleText = {}));

// src/GrowCommand.ts
var GrowCommand = class {
  static growSelection(markdown, selection) {
    const tree = MarkdownASTBuilder.parse(markdown);
    console.log("tree", tree);
    const result = Ast.findNodeWithRange(tree, selection);
    let nodeWithSelection = result.node;
    console.log(result.ancestors.map((a) => a.type));
    const parentParagraph = Mdast.findParentParagraph([...result.ancestors, nodeWithSelection]);
    if (parentParagraph && !Ast.fillsNode(parentParagraph, selection)) {
      const subParserResult = this.selectInParagraph(markdown, parentParagraph, selection);
      if (subParserResult.status === "SUB_RANGE") {
        return subParserResult.range;
      } else {
        console.log("node is filled, selecting parent");
        nodeWithSelection = Mdast.findAncestorWithLargerRange(parentParagraph, result.ancestors);
        console.log(`filling node of type ${nodeWithSelection.type}`);
        return {
          start: nodeWithSelection.position.start,
          end: nodeWithSelection.position.end
        };
      }
    } else {
      if (Ast.fillsNode(nodeWithSelection, selection) && nodeWithSelection.parent) {
        console.log("node is filled, selecting parent");
        nodeWithSelection = Mdast.findAncestorWithLargerRange(nodeWithSelection, result.ancestors);
      }
      console.log(`filling node of type ${nodeWithSelection.type}`);
      return {
        start: nodeWithSelection.position.start,
        end: nodeWithSelection.position.end
      };
    }
  }
  static selectInParagraph(markdown, parentParagraph, range) {
    const paragraphRange = {
      start: parentParagraph.position.start,
      end: parentParagraph.position.end
    };
    console.log("==================== Using sub-parser ==================== ");
    console.log("paragraph start", paragraphRange.start);
    console.log("paragraph end", paragraphRange.end);
    const text4 = markdown.substring(paragraphRange.start.offset, paragraphRange.end.offset);
    console.log(text4);
    const tree = SimpleText.parse(text4);
    console.log(tree);
    const mappedSelection = {
      start: AstPosMath.toOneBased(AstPosMath.minus(range.start, paragraphRange.start)),
      end: AstPosMath.toOneBased(AstPosMath.minus(range.end, paragraphRange.start))
    };
    console.log("mapped selection:", mappedSelection);
    if (Ast.fillsNode(tree, mappedSelection)) {
      return {
        status: "PARENT_RANGE"
      };
    }
    const { node: nodeWithSelection, ancestors } = Ast.findNodeWithRange(tree, mappedSelection);
    console.log("antlr result node", nodeWithSelection);
    console.log("ancestors", ancestors);
    let textNode = nodeWithSelection;
    if (Ast.fillsNode(nodeWithSelection, mappedSelection)) {
      console.log("selection already fills the node, growing !");
      textNode = Mdast.findAncestorWithLargerRange(nodeWithSelection, ancestors);
    }
    console.log("selecting", textNode);
    console.log(`selecting text ${textNode.text}`);
    console.log("new selection start", textNode.position.start);
    console.log("new selection end", textNode.position.end);
    const remappedSelection = {
      start: {
        line: paragraphRange.start.line - 1 + textNode.position.start.line,
        column: paragraphRange.start.column - 1 + textNode.position.start.column
      },
      end: {
        line: paragraphRange.start.line - 1 + textNode.position.end.line,
        column: paragraphRange.start.column - 1 + textNode.position.end.column + 1
      }
    };
    console.log("mapped selection start", remappedSelection.start);
    console.log("mapped selection end", remappedSelection.end);
    return {
      status: "SUB_RANGE",
      range: remappedSelection
    };
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  convertSvgToBitmap: true
};
var StructuralEditPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "grow-selection",
      name: "Grow selection",
      editorCallback: async (editor, view) => {
        const { head, anchor } = editor.listSelections()[0];
        const selection = AstPosMath.order(AstPosMath.fromEditorPosition(head), AstPosMath.fromEditorPosition(anchor));
        console.log("selection start", selection.start);
        console.log("selection end", selection.end);
        const newSelection = GrowCommand.growSelection(view.data, selection);
        editor.setSelection(this.toEditorPosition(newSelection.end), this.toEditorPosition(newSelection.start));
      }
    });
  }
  toEditorPosition(pos) {
    return {
      line: pos.line - 1,
      ch: pos.column - 1
    };
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
