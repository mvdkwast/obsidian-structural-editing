"use strict";
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/antlr4ts/Decorators.js
var require_Decorators = __commonJS({
  "node_modules/antlr4ts/Decorators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SuppressWarnings = exports.Override = exports.Nullable = exports.NotNull = void 0;
    function NotNull(target, propertyKey, propertyDescriptor) {
    }
    exports.NotNull = NotNull;
    function Nullable(target, propertyKey, propertyDescriptor) {
    }
    exports.Nullable = Nullable;
    function Override(target, propertyKey, propertyDescriptor) {
    }
    exports.Override = Override;
    function SuppressWarnings(options) {
      return (target, propertyKey, descriptor) => {
      };
    }
    exports.SuppressWarnings = SuppressWarnings;
  }
});

// node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js
var require_AbstractParseTreeVisitor = __commonJS({
  "node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractParseTreeVisitor = void 0;
    var Decorators_1 = require_Decorators();
    var AbstractParseTreeVisitor2 = class {
      visit(tree) {
        return tree.accept(this);
      }
      visitChildren(node) {
        let result = this.defaultResult();
        let n = node.childCount;
        for (let i = 0; i < n; i++) {
          if (!this.shouldVisitNextChild(node, result)) {
            break;
          }
          let c = node.getChild(i);
          let childResult = c.accept(this);
          result = this.aggregateResult(result, childResult);
        }
        return result;
      }
      visitTerminal(node) {
        return this.defaultResult();
      }
      visitErrorNode(node) {
        return this.defaultResult();
      }
      aggregateResult(aggregate, nextResult) {
        return nextResult;
      }
      shouldVisitNextChild(node, currentResult) {
        return true;
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visit", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visitChildren", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visitTerminal", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visitErrorNode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "shouldVisitNextChild", null);
    exports.AbstractParseTreeVisitor = AbstractParseTreeVisitor2;
  }
});

// node_modules/antlr4ts/ANTLRErrorListener.js
var require_ANTLRErrorListener = __commonJS({
  "node_modules/antlr4ts/ANTLRErrorListener.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/ANTLRErrorStrategy.js
var require_ANTLRErrorStrategy = __commonJS({
  "node_modules/antlr4ts/ANTLRErrorStrategy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/IntStream.js
var require_IntStream = __commonJS({
  "node_modules/antlr4ts/IntStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntStream = void 0;
    var IntStream;
    (function(IntStream2) {
      IntStream2.EOF = -1;
      IntStream2.UNKNOWN_SOURCE_NAME = "<unknown>";
    })(IntStream = exports.IntStream || (exports.IntStream = {}));
  }
});

// node_modules/antlr4ts/ANTLRInputStream.js
var require_ANTLRInputStream = __commonJS({
  "node_modules/antlr4ts/ANTLRInputStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ANTLRInputStream = void 0;
    var assert = require("assert");
    var Decorators_1 = require_Decorators();
    var IntStream_1 = require_IntStream();
    var ANTLRInputStream2 = class {
      constructor(input) {
        this.p = 0;
        this.data = input;
        this.n = input.length;
      }
      reset() {
        this.p = 0;
      }
      consume() {
        if (this.p >= this.n) {
          assert(this.LA(1) === IntStream_1.IntStream.EOF);
          throw new Error("cannot consume EOF");
        }
        if (this.p < this.n) {
          this.p++;
        }
      }
      LA(i) {
        if (i === 0) {
          return 0;
        }
        if (i < 0) {
          i++;
          if (this.p + i - 1 < 0) {
            return IntStream_1.IntStream.EOF;
          }
        }
        if (this.p + i - 1 >= this.n) {
          return IntStream_1.IntStream.EOF;
        }
        return this.data.charCodeAt(this.p + i - 1);
      }
      LT(i) {
        return this.LA(i);
      }
      get index() {
        return this.p;
      }
      get size() {
        return this.n;
      }
      mark() {
        return -1;
      }
      release(marker) {
      }
      seek(index2) {
        if (index2 <= this.p) {
          this.p = index2;
          return;
        }
        index2 = Math.min(index2, this.n);
        while (this.p < index2) {
          this.consume();
        }
      }
      getText(interval) {
        let start = interval.a;
        let stop = interval.b;
        if (stop >= this.n) {
          stop = this.n - 1;
        }
        let count = stop - start + 1;
        if (start >= this.n) {
          return "";
        }
        return this.data.substr(start, count);
      }
      get sourceName() {
        if (!this.name) {
          return IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        return this.name;
      }
      toString() {
        return this.data;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "LA", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "getText", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "toString", null);
    exports.ANTLRInputStream = ANTLRInputStream2;
  }
});

// node_modules/antlr4ts/atn/ATNState.js
var require_ATNState = __commonJS({
  "node_modules/antlr4ts/atn/ATNState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNState = void 0;
    var Decorators_1 = require_Decorators();
    var ATNState = class {
      constructor() {
        this.stateNumber = ATNState.INVALID_STATE_NUMBER;
        this.ruleIndex = 0;
        this.epsilonOnlyTransitions = false;
        this.transitions = [];
        this.optimizedTransitions = this.transitions;
      }
      getStateNumber() {
        return this.stateNumber;
      }
      get nonStopStateNumber() {
        return this.getStateNumber();
      }
      hashCode() {
        return this.stateNumber;
      }
      equals(o) {
        if (o instanceof ATNState) {
          return this.stateNumber === o.stateNumber;
        }
        return false;
      }
      get isNonGreedyExitState() {
        return false;
      }
      toString() {
        return String(this.stateNumber);
      }
      getTransitions() {
        return this.transitions.slice(0);
      }
      get numberOfTransitions() {
        return this.transitions.length;
      }
      addTransition(e, index2) {
        if (this.transitions.length === 0) {
          this.epsilonOnlyTransitions = e.isEpsilon;
        } else if (this.epsilonOnlyTransitions !== e.isEpsilon) {
          this.epsilonOnlyTransitions = false;
          throw new Error("ATN state " + this.stateNumber + " has both epsilon and non-epsilon transitions.");
        }
        this.transitions.splice(index2 !== void 0 ? index2 : this.transitions.length, 0, e);
      }
      transition(i) {
        return this.transitions[i];
      }
      setTransition(i, e) {
        this.transitions[i] = e;
      }
      removeTransition(index2) {
        return this.transitions.splice(index2, 1)[0];
      }
      get onlyHasEpsilonTransitions() {
        return this.epsilonOnlyTransitions;
      }
      setRuleIndex(ruleIndex) {
        this.ruleIndex = ruleIndex;
      }
      get isOptimized() {
        return this.optimizedTransitions !== this.transitions;
      }
      get numberOfOptimizedTransitions() {
        return this.optimizedTransitions.length;
      }
      getOptimizedTransition(i) {
        return this.optimizedTransitions[i];
      }
      addOptimizedTransition(e) {
        if (!this.isOptimized) {
          this.optimizedTransitions = new Array();
        }
        this.optimizedTransitions.push(e);
      }
      setOptimizedTransition(i, e) {
        if (!this.isOptimized) {
          throw new Error("This ATNState is not optimized.");
        }
        this.optimizedTransitions[i] = e;
      }
      removeOptimizedTransition(i) {
        if (!this.isOptimized) {
          throw new Error("This ATNState is not optimized.");
        }
        this.optimizedTransitions.splice(i, 1);
      }
    };
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "toString", null);
    exports.ATNState = ATNState;
    (function(ATNState2) {
      ATNState2.INVALID_STATE_NUMBER = -1;
    })(ATNState = exports.ATNState || (exports.ATNState = {}));
  }
});

// node_modules/antlr4ts/atn/ATNStateType.js
var require_ATNStateType = __commonJS({
  "node_modules/antlr4ts/atn/ATNStateType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNStateType = void 0;
    var ATNStateType;
    (function(ATNStateType2) {
      ATNStateType2[ATNStateType2["INVALID_TYPE"] = 0] = "INVALID_TYPE";
      ATNStateType2[ATNStateType2["BASIC"] = 1] = "BASIC";
      ATNStateType2[ATNStateType2["RULE_START"] = 2] = "RULE_START";
      ATNStateType2[ATNStateType2["BLOCK_START"] = 3] = "BLOCK_START";
      ATNStateType2[ATNStateType2["PLUS_BLOCK_START"] = 4] = "PLUS_BLOCK_START";
      ATNStateType2[ATNStateType2["STAR_BLOCK_START"] = 5] = "STAR_BLOCK_START";
      ATNStateType2[ATNStateType2["TOKEN_START"] = 6] = "TOKEN_START";
      ATNStateType2[ATNStateType2["RULE_STOP"] = 7] = "RULE_STOP";
      ATNStateType2[ATNStateType2["BLOCK_END"] = 8] = "BLOCK_END";
      ATNStateType2[ATNStateType2["STAR_LOOP_BACK"] = 9] = "STAR_LOOP_BACK";
      ATNStateType2[ATNStateType2["STAR_LOOP_ENTRY"] = 10] = "STAR_LOOP_ENTRY";
      ATNStateType2[ATNStateType2["PLUS_LOOP_BACK"] = 11] = "PLUS_LOOP_BACK";
      ATNStateType2[ATNStateType2["LOOP_END"] = 12] = "LOOP_END";
    })(ATNStateType = exports.ATNStateType || (exports.ATNStateType = {}));
  }
});

// node_modules/antlr4ts/RecognitionException.js
var require_RecognitionException = __commonJS({
  "node_modules/antlr4ts/RecognitionException.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecognitionException = void 0;
    var RecognitionException2 = class extends Error {
      constructor(recognizer, input, ctx, message) {
        super(message);
        this._offendingState = -1;
        this._recognizer = recognizer;
        this.input = input;
        this.ctx = ctx;
        if (recognizer) {
          this._offendingState = recognizer.state;
        }
      }
      get offendingState() {
        return this._offendingState;
      }
      setOffendingState(offendingState) {
        this._offendingState = offendingState;
      }
      get expectedTokens() {
        if (this._recognizer) {
          return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);
        }
        return void 0;
      }
      get context() {
        return this.ctx;
      }
      get inputStream() {
        return this.input;
      }
      getOffendingToken(recognizer) {
        if (recognizer && recognizer !== this._recognizer) {
          return void 0;
        }
        return this.offendingToken;
      }
      setOffendingToken(recognizer, offendingToken) {
        if (recognizer === this._recognizer) {
          this.offendingToken = offendingToken;
        }
      }
      get recognizer() {
        return this._recognizer;
      }
    };
    exports.RecognitionException = RecognitionException2;
  }
});

// node_modules/antlr4ts/atn/Transition.js
var require_Transition = __commonJS({
  "node_modules/antlr4ts/atn/Transition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition = class Transition {
      constructor(target) {
        if (target == null) {
          throw new Error("target cannot be null.");
        }
        this.target = target;
      }
      get isEpsilon() {
        return false;
      }
      get label() {
        return void 0;
      }
    };
    Transition.serializationNames = [
      "INVALID",
      "EPSILON",
      "RANGE",
      "RULE",
      "PREDICATE",
      "ATOM",
      "ACTION",
      "SET",
      "NOT_SET",
      "WILDCARD",
      "PRECEDENCE"
    ];
    __decorate([
      Decorators_1.NotNull
    ], Transition.prototype, "target", void 0);
    Transition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], Transition);
    exports.Transition = Transition;
  }
});

// node_modules/antlr4ts/atn/AbstractPredicateTransition.js
var require_AbstractPredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/AbstractPredicateTransition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractPredicateTransition = void 0;
    var Transition_1 = require_Transition();
    var AbstractPredicateTransition = class extends Transition_1.Transition {
      constructor(target) {
        super(target);
      }
    };
    exports.AbstractPredicateTransition = AbstractPredicateTransition;
  }
});

// node_modules/antlr4ts/misc/MurmurHash.js
var require_MurmurHash = __commonJS({
  "node_modules/antlr4ts/misc/MurmurHash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MurmurHash = void 0;
    var MurmurHash;
    (function(MurmurHash2) {
      const DEFAULT_SEED = 0;
      function initialize(seed = DEFAULT_SEED) {
        return seed;
      }
      MurmurHash2.initialize = initialize;
      function update(hash, value2) {
        const c1 = 3432918353;
        const c2 = 461845907;
        const r1 = 15;
        const r2 = 13;
        const m = 5;
        const n = 3864292196;
        if (value2 == null) {
          value2 = 0;
        } else if (typeof value2 === "string") {
          value2 = hashString(value2);
        } else if (typeof value2 === "object") {
          value2 = value2.hashCode();
        }
        let k = value2;
        k = Math.imul(k, c1);
        k = k << r1 | k >>> 32 - r1;
        k = Math.imul(k, c2);
        hash = hash ^ k;
        hash = hash << r2 | hash >>> 32 - r2;
        hash = Math.imul(hash, m) + n;
        return hash & 4294967295;
      }
      MurmurHash2.update = update;
      function finish(hash, numberOfWords) {
        hash = hash ^ numberOfWords * 4;
        hash = hash ^ hash >>> 16;
        hash = Math.imul(hash, 2246822507);
        hash = hash ^ hash >>> 13;
        hash = Math.imul(hash, 3266489909);
        hash = hash ^ hash >>> 16;
        return hash;
      }
      MurmurHash2.finish = finish;
      function hashCode(data, seed = DEFAULT_SEED) {
        let hash = initialize(seed);
        let length = 0;
        for (let value2 of data) {
          hash = update(hash, value2);
          length++;
        }
        hash = finish(hash, length);
        return hash;
      }
      MurmurHash2.hashCode = hashCode;
      function hashString(str) {
        let len = str.length;
        if (len === 0) {
          return 0;
        }
        let hash = 0;
        for (let i = 0; i < len; i++) {
          let c = str.charCodeAt(i);
          hash = (hash << 5 >>> 0) - hash + c;
          hash |= 0;
        }
        return hash;
      }
    })(MurmurHash = exports.MurmurHash || (exports.MurmurHash = {}));
  }
});

// node_modules/antlr4ts/misc/ObjectEqualityComparator.js
var require_ObjectEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/ObjectEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator = class {
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return obj.hashCode();
      }
      equals(a, b) {
        if (a == null) {
          return b == null;
        }
        return a.equals(b);
      }
    };
    ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], ObjectEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ObjectEqualityComparator.prototype, "equals", null);
    exports.ObjectEqualityComparator = ObjectEqualityComparator;
  }
});

// node_modules/antlr4ts/misc/DefaultEqualityComparator.js
var require_DefaultEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/DefaultEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var DefaultEqualityComparator = class {
      hashCode(obj) {
        if (obj == null) {
          return 0;
        } else if (typeof obj === "string" || typeof obj === "number") {
          return MurmurHash_1.MurmurHash.hashCode([obj]);
        } else {
          return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.hashCode(obj);
        }
      }
      equals(a, b) {
        if (a == null) {
          return b == null;
        } else if (typeof a === "string" || typeof a === "number") {
          return a === b;
        } else {
          return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a, b);
        }
      }
    };
    DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], DefaultEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], DefaultEqualityComparator.prototype, "equals", null);
    exports.DefaultEqualityComparator = DefaultEqualityComparator;
  }
});

// node_modules/antlr4ts/misc/Array2DHashSet.js
var require_Array2DHashSet = __commonJS({
  "node_modules/antlr4ts/misc/Array2DHashSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Array2DHashSet = void 0;
    var assert = require("assert");
    var DefaultEqualityComparator_1 = require_DefaultEqualityComparator();
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var INITAL_CAPACITY = 16;
    var LOAD_FACTOR = 0.75;
    var Array2DHashSet = class {
      constructor(comparatorOrSet, initialCapacity = INITAL_CAPACITY) {
        this.n = 0;
        this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
        if (comparatorOrSet instanceof Array2DHashSet) {
          this.comparator = comparatorOrSet.comparator;
          this.buckets = comparatorOrSet.buckets.slice(0);
          for (let i = 0; i < this.buckets.length; i++) {
            let bucket = this.buckets[i];
            if (bucket) {
              this.buckets[i] = bucket.slice(0);
            }
          }
          this.n = comparatorOrSet.n;
          this.threshold = comparatorOrSet.threshold;
        } else {
          this.comparator = comparatorOrSet || DefaultEqualityComparator_1.DefaultEqualityComparator.INSTANCE;
          this.buckets = this.createBuckets(initialCapacity);
        }
      }
      getOrAdd(o) {
        if (this.n > this.threshold) {
          this.expand();
        }
        return this.getOrAddImpl(o);
      }
      getOrAddImpl(o) {
        let b = this.getBucket(o);
        let bucket = this.buckets[b];
        if (!bucket) {
          bucket = [o];
          this.buckets[b] = bucket;
          this.n++;
          return o;
        }
        for (let existing of bucket) {
          if (this.comparator.equals(existing, o)) {
            return existing;
          }
        }
        bucket.push(o);
        this.n++;
        return o;
      }
      get(o) {
        if (o == null) {
          return o;
        }
        let b = this.getBucket(o);
        let bucket = this.buckets[b];
        if (!bucket) {
          return void 0;
        }
        for (let e of bucket) {
          if (this.comparator.equals(e, o)) {
            return e;
          }
        }
        return void 0;
      }
      getBucket(o) {
        let hash = this.comparator.hashCode(o);
        let b = hash & this.buckets.length - 1;
        return b;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            hash = MurmurHash_1.MurmurHash.update(hash, this.comparator.hashCode(o));
          }
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, this.size);
        return hash;
      }
      equals(o) {
        if (o === this) {
          return true;
        }
        if (!(o instanceof Array2DHashSet)) {
          return false;
        }
        if (o.size !== this.size) {
          return false;
        }
        let same = this.containsAll(o);
        return same;
      }
      expand() {
        let old = this.buckets;
        let newCapacity = this.buckets.length * 2;
        let newTable = this.createBuckets(newCapacity);
        this.buckets = newTable;
        this.threshold = Math.floor(newCapacity * LOAD_FACTOR);
        let oldSize = this.size;
        for (let bucket of old) {
          if (!bucket) {
            continue;
          }
          for (let o of bucket) {
            let b = this.getBucket(o);
            let newBucket = this.buckets[b];
            if (!newBucket) {
              newBucket = [];
              this.buckets[b] = newBucket;
            }
            newBucket.push(o);
          }
        }
        assert(this.n === oldSize);
      }
      add(t) {
        let existing = this.getOrAdd(t);
        return existing === t;
      }
      get size() {
        return this.n;
      }
      get isEmpty() {
        return this.n === 0;
      }
      contains(o) {
        return this.containsFast(this.asElementType(o));
      }
      containsFast(obj) {
        if (obj == null) {
          return false;
        }
        return this.get(obj) != null;
      }
      *[Symbol.iterator]() {
        yield* this.toArray();
      }
      toArray() {
        const a = new Array(this.size);
        let i = 0;
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            a[i++] = o;
          }
        }
        return a;
      }
      containsAll(collection) {
        if (collection instanceof Array2DHashSet) {
          let s = collection;
          for (let bucket of s.buckets) {
            if (bucket == null) {
              continue;
            }
            for (let o of bucket) {
              if (o == null) {
                break;
              }
              if (!this.containsFast(this.asElementType(o))) {
                return false;
              }
            }
          }
        } else {
          for (let o of collection) {
            if (!this.containsFast(this.asElementType(o))) {
              return false;
            }
          }
        }
        return true;
      }
      addAll(c) {
        let changed = false;
        for (let o of c) {
          let existing = this.getOrAdd(o);
          if (existing !== o) {
            changed = true;
          }
        }
        return changed;
      }
      clear() {
        this.buckets = this.createBuckets(INITAL_CAPACITY);
        this.n = 0;
        this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
      }
      toString() {
        if (this.size === 0) {
          return "{}";
        }
        let buf = "{";
        let first = true;
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            buf += o.toString();
          }
        }
        buf += "}";
        return buf;
      }
      toTableString() {
        let buf = "";
        for (let bucket of this.buckets) {
          if (bucket == null) {
            buf += "null\n";
            continue;
          }
          buf += "[";
          let first = true;
          for (let o of bucket) {
            if (first) {
              first = false;
            } else {
              buf += " ";
            }
            if (o == null) {
              buf += "_";
            } else {
              buf += o.toString();
            }
          }
          buf += "]\n";
        }
        return buf;
      }
      asElementType(o) {
        return o;
      }
      createBuckets(capacity) {
        return new Array(capacity);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], Array2DHashSet.prototype, "comparator", void 0);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "add", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "contains", null);
    __decorate([
      __param(0, Decorators_1.Nullable)
    ], Array2DHashSet.prototype, "containsFast", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, Symbol.iterator, null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "toArray", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "containsAll", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "addAll", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "clear", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "toString", null);
    __decorate([
      Decorators_1.SuppressWarnings("unchecked")
    ], Array2DHashSet.prototype, "asElementType", null);
    __decorate([
      Decorators_1.SuppressWarnings("unchecked")
    ], Array2DHashSet.prototype, "createBuckets", null);
    exports.Array2DHashSet = Array2DHashSet;
  }
});

// node_modules/antlr4ts/misc/ArrayEqualityComparator.js
var require_ArrayEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/ArrayEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var ArrayEqualityComparator = class {
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return MurmurHash_1.MurmurHash.hashCode(obj, 0);
      }
      equals(a, b) {
        if (a == null) {
          return b == null;
        } else if (b == null) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; i++) {
          if (!ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
    };
    ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], ArrayEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ArrayEqualityComparator.prototype, "equals", null);
    exports.ArrayEqualityComparator = ArrayEqualityComparator;
  }
});

// node_modules/antlr4ts/misc/Utils.js
var require_Utils = __commonJS({
  "node_modules/antlr4ts/misc/Utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toCharArray = exports.toMap = exports.equals = exports.join = exports.escapeWhitespace = void 0;
    function escapeWhitespace(s, escapeSpaces) {
      return escapeSpaces ? s.replace(/ /, "\xB7") : s.replace(/\t/, "\\t").replace(/\n/, "\\n").replace(/\r/, "\\r");
    }
    exports.escapeWhitespace = escapeWhitespace;
    function join(collection, separator) {
      let buf = "";
      let first = true;
      for (let current of collection) {
        if (first) {
          first = false;
        } else {
          buf += separator;
        }
        buf += current;
      }
      return buf;
    }
    exports.join = join;
    function equals(x, y) {
      if (x === y) {
        return true;
      }
      if (x === void 0 || y === void 0) {
        return false;
      }
      return x.equals(y);
    }
    exports.equals = equals;
    function toMap(keys) {
      let m = /* @__PURE__ */ new Map();
      for (let i = 0; i < keys.length; i++) {
        m.set(keys[i], i);
      }
      return m;
    }
    exports.toMap = toMap;
    function toCharArray3(str) {
      if (typeof str === "string") {
        let result = new Uint16Array(str.length);
        for (let i = 0; i < str.length; i++) {
          result[i] = str.charCodeAt(i);
        }
        return result;
      } else {
        return str.toCharArray();
      }
    }
    exports.toCharArray = toCharArray3;
  }
});

// node_modules/antlr4ts/atn/SemanticContext.js
var require_SemanticContext = __commonJS({
  "node_modules/antlr4ts/atn/SemanticContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticContext = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var Utils3 = require_Utils();
    function max(items) {
      let result;
      for (let current of items) {
        if (result === void 0) {
          result = current;
          continue;
        }
        let comparison = result.compareTo(current);
        if (comparison < 0) {
          result = current;
        }
      }
      return result;
    }
    function min(items) {
      let result;
      for (let current of items) {
        if (result === void 0) {
          result = current;
          continue;
        }
        let comparison = result.compareTo(current);
        if (comparison > 0) {
          result = current;
        }
      }
      return result;
    }
    var SemanticContext = class {
      static get NONE() {
        if (SemanticContext._NONE === void 0) {
          SemanticContext._NONE = new SemanticContext.Predicate();
        }
        return SemanticContext._NONE;
      }
      evalPrecedence(parser, parserCallStack) {
        return this;
      }
      static and(a, b) {
        if (!a || a === SemanticContext.NONE) {
          return b;
        }
        if (b === SemanticContext.NONE) {
          return a;
        }
        let result = new SemanticContext.AND(a, b);
        if (result.opnds.length === 1) {
          return result.opnds[0];
        }
        return result;
      }
      static or(a, b) {
        if (!a) {
          return b;
        }
        if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
          return SemanticContext.NONE;
        }
        let result = new SemanticContext.OR(a, b);
        if (result.opnds.length === 1) {
          return result.opnds[0];
        }
        return result;
      }
    };
    exports.SemanticContext = SemanticContext;
    (function(SemanticContext2) {
      const AND_HASHCODE = 40363613;
      const OR_HASHCODE = 486279973;
      function filterPrecedencePredicates(collection) {
        let result = [];
        for (let i = 0; i < collection.length; i++) {
          let context = collection[i];
          if (context instanceof SemanticContext2.PrecedencePredicate) {
            result.push(context);
            collection.splice(i, 1);
            i--;
          }
        }
        return result;
      }
      class Predicate extends SemanticContext2 {
        constructor(ruleIndex = -1, predIndex = -1, isCtxDependent = false) {
          super();
          this.ruleIndex = ruleIndex;
          this.predIndex = predIndex;
          this.isCtxDependent = isCtxDependent;
        }
        eval(parser, parserCallStack) {
          let localctx = this.isCtxDependent ? parserCallStack : void 0;
          return parser.sempred(localctx, this.ruleIndex, this.predIndex);
        }
        hashCode() {
          let hashCode = MurmurHash_1.MurmurHash.initialize();
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);
          return hashCode;
        }
        equals(obj) {
          if (!(obj instanceof Predicate)) {
            return false;
          }
          if (this === obj) {
            return true;
          }
          return this.ruleIndex === obj.ruleIndex && this.predIndex === obj.predIndex && this.isCtxDependent === obj.isCtxDependent;
        }
        toString() {
          return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
        }
      }
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "toString", null);
      SemanticContext2.Predicate = Predicate;
      class PrecedencePredicate extends SemanticContext2 {
        constructor(precedence) {
          super();
          this.precedence = precedence;
        }
        eval(parser, parserCallStack) {
          return parser.precpred(parserCallStack, this.precedence);
        }
        evalPrecedence(parser, parserCallStack) {
          if (parser.precpred(parserCallStack, this.precedence)) {
            return SemanticContext2.NONE;
          } else {
            return void 0;
          }
        }
        compareTo(o) {
          return this.precedence - o.precedence;
        }
        hashCode() {
          let hashCode = 1;
          hashCode = 31 * hashCode + this.precedence;
          return hashCode;
        }
        equals(obj) {
          if (!(obj instanceof PrecedencePredicate)) {
            return false;
          }
          if (this === obj) {
            return true;
          }
          return this.precedence === obj.precedence;
        }
        toString() {
          return "{" + this.precedence + ">=prec}?";
        }
      }
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "compareTo", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "toString", null);
      SemanticContext2.PrecedencePredicate = PrecedencePredicate;
      class Operator extends SemanticContext2 {
      }
      SemanticContext2.Operator = Operator;
      let AND = class AND2 extends Operator {
        constructor(a, b) {
          super();
          let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          if (a instanceof AND2) {
            operands.addAll(a.opnds);
          } else {
            operands.add(a);
          }
          if (b instanceof AND2) {
            operands.addAll(b.opnds);
          } else {
            operands.add(b);
          }
          this.opnds = operands.toArray();
          let precedencePredicates = filterPrecedencePredicates(this.opnds);
          let reduced = min(precedencePredicates);
          if (reduced) {
            this.opnds.push(reduced);
          }
        }
        get operands() {
          return this.opnds;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof AND2)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);
        }
        eval(parser, parserCallStack) {
          for (let opnd of this.opnds) {
            if (!opnd.eval(parser, parserCallStack)) {
              return false;
            }
          }
          return true;
        }
        evalPrecedence(parser, parserCallStack) {
          let differs = false;
          let operands = [];
          for (let context of this.opnds) {
            let evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated == null) {
              return void 0;
            } else if (evaluated !== SemanticContext2.NONE) {
              operands.push(evaluated);
            }
          }
          if (!differs) {
            return this;
          }
          if (operands.length === 0) {
            return SemanticContext2.NONE;
          }
          let result = operands[0];
          for (let i = 1; i < operands.length; i++) {
            result = SemanticContext2.and(result, operands[i]);
          }
          return result;
        }
        toString() {
          return Utils3.join(this.opnds, "&&");
        }
      };
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "operands", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "toString", null);
      AND = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], AND);
      SemanticContext2.AND = AND;
      let OR = class OR2 extends Operator {
        constructor(a, b) {
          super();
          let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          if (a instanceof OR2) {
            operands.addAll(a.opnds);
          } else {
            operands.add(a);
          }
          if (b instanceof OR2) {
            operands.addAll(b.opnds);
          } else {
            operands.add(b);
          }
          this.opnds = operands.toArray();
          let precedencePredicates = filterPrecedencePredicates(this.opnds);
          let reduced = max(precedencePredicates);
          if (reduced) {
            this.opnds.push(reduced);
          }
        }
        get operands() {
          return this.opnds;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof OR2)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);
        }
        eval(parser, parserCallStack) {
          for (let opnd of this.opnds) {
            if (opnd.eval(parser, parserCallStack)) {
              return true;
            }
          }
          return false;
        }
        evalPrecedence(parser, parserCallStack) {
          let differs = false;
          let operands = [];
          for (let context of this.opnds) {
            let evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated === SemanticContext2.NONE) {
              return SemanticContext2.NONE;
            } else if (evaluated) {
              operands.push(evaluated);
            }
          }
          if (!differs) {
            return this;
          }
          if (operands.length === 0) {
            return void 0;
          }
          let result = operands[0];
          for (let i = 1; i < operands.length; i++) {
            result = SemanticContext2.or(result, operands[i]);
          }
          return result;
        }
        toString() {
          return Utils3.join(this.opnds, "||");
        }
      };
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "operands", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "toString", null);
      OR = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], OR);
      SemanticContext2.OR = OR;
    })(SemanticContext = exports.SemanticContext || (exports.SemanticContext = {}));
  }
});

// node_modules/antlr4ts/atn/PredicateTransition.js
var require_PredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/PredicateTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredicateTransition = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Decorators_1 = require_Decorators();
    var SemanticContext_1 = require_SemanticContext();
    var PredicateTransition = class PredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
      constructor(target, ruleIndex, predIndex, isCtxDependent) {
        super(target);
        this.ruleIndex = ruleIndex;
        this.predIndex = predIndex;
        this.isCtxDependent = isCtxDependent;
      }
      get serializationType() {
        return 4;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      get predicate() {
        return new SemanticContext_1.SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
      }
      toString() {
        return "pred_" + this.ruleIndex + ":" + this.predIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], PredicateTransition.prototype, "toString", null);
    PredicateTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], PredicateTransition);
    exports.PredicateTransition = PredicateTransition;
  }
});

// node_modules/antlr4ts/FailedPredicateException.js
var require_FailedPredicateException = __commonJS({
  "node_modules/antlr4ts/FailedPredicateException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FailedPredicateException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var PredicateTransition_1 = require_PredicateTransition();
    var FailedPredicateException2 = class FailedPredicateException3 extends RecognitionException_1.RecognitionException {
      constructor(recognizer, predicate, message) {
        super(recognizer, recognizer.inputStream, recognizer.context, FailedPredicateException3.formatMessage(predicate, message));
        let s = recognizer.interpreter.atn.states[recognizer.state];
        let trans = s.transition(0);
        if (trans instanceof PredicateTransition_1.PredicateTransition) {
          this._ruleIndex = trans.ruleIndex;
          this._predicateIndex = trans.predIndex;
        } else {
          this._ruleIndex = 0;
          this._predicateIndex = 0;
        }
        this._predicate = predicate;
        super.setOffendingToken(recognizer, recognizer.currentToken);
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
      get predicateIndex() {
        return this._predicateIndex;
      }
      get predicate() {
        return this._predicate;
      }
      static formatMessage(predicate, message) {
        if (message) {
          return message;
        }
        return `failed predicate: {${predicate}}?`;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], FailedPredicateException2, "formatMessage", null);
    FailedPredicateException2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], FailedPredicateException2);
    exports.FailedPredicateException = FailedPredicateException2;
  }
});

// node_modules/antlr4ts/InputMismatchException.js
var require_InputMismatchException = __commonJS({
  "node_modules/antlr4ts/InputMismatchException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputMismatchException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var InputMismatchException = class InputMismatchException extends RecognitionException_1.RecognitionException {
      constructor(recognizer, state, context) {
        if (context === void 0) {
          context = recognizer.context;
        }
        super(recognizer, recognizer.inputStream, context);
        if (state !== void 0) {
          this.setOffendingState(state);
        }
        this.setOffendingToken(recognizer, recognizer.currentToken);
      }
    };
    InputMismatchException = __decorate([
      __param(0, Decorators_1.NotNull)
    ], InputMismatchException);
    exports.InputMismatchException = InputMismatchException;
  }
});

// node_modules/antlr4ts/misc/Arrays.js
var require_Arrays = __commonJS({
  "node_modules/antlr4ts/misc/Arrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Arrays = void 0;
    var Arrays;
    (function(Arrays2) {
      function binarySearch(array, key, fromIndex, toIndex) {
        return binarySearch0(array, fromIndex !== void 0 ? fromIndex : 0, toIndex !== void 0 ? toIndex : array.length, key);
      }
      Arrays2.binarySearch = binarySearch;
      function binarySearch0(array, fromIndex, toIndex, key) {
        let low = fromIndex;
        let high = toIndex - 1;
        while (low <= high) {
          let mid = low + high >>> 1;
          let midVal = array[mid];
          if (midVal < key) {
            low = mid + 1;
          } else if (midVal > key) {
            high = mid - 1;
          } else {
            return mid;
          }
        }
        return -(low + 1);
      }
      function toString2(array) {
        let result = "[";
        let first = true;
        for (let element2 of array) {
          if (first) {
            first = false;
          } else {
            result += ", ";
          }
          if (element2 === null) {
            result += "null";
          } else if (element2 === void 0) {
            result += "undefined";
          } else {
            result += element2;
          }
        }
        result += "]";
        return result;
      }
      Arrays2.toString = toString2;
    })(Arrays = exports.Arrays || (exports.Arrays = {}));
  }
});

// node_modules/antlr4ts/misc/IntegerList.js
var require_IntegerList = __commonJS({
  "node_modules/antlr4ts/misc/IntegerList.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntegerList = void 0;
    var Arrays_1 = require_Arrays();
    var Decorators_1 = require_Decorators();
    var EMPTY_DATA = new Int32Array(0);
    var INITIAL_SIZE = 4;
    var MAX_ARRAY_SIZE = (1 << 31 >>> 0) - 1 - 8;
    var IntegerList = class {
      constructor(arg) {
        if (!arg) {
          this._data = EMPTY_DATA;
          this._size = 0;
        } else if (arg instanceof IntegerList) {
          this._data = arg._data.slice(0);
          this._size = arg._size;
        } else if (typeof arg === "number") {
          if (arg === 0) {
            this._data = EMPTY_DATA;
            this._size = 0;
          } else {
            this._data = new Int32Array(arg);
            this._size = 0;
          }
        } else {
          this._data = EMPTY_DATA;
          this._size = 0;
          for (let value2 of arg) {
            this.add(value2);
          }
        }
      }
      add(value2) {
        if (this._data.length === this._size) {
          this.ensureCapacity(this._size + 1);
        }
        this._data[this._size] = value2;
        this._size++;
      }
      addAll(list2) {
        if (Array.isArray(list2)) {
          this.ensureCapacity(this._size + list2.length);
          this._data.subarray(this._size, this._size + list2.length).set(list2);
          this._size += list2.length;
        } else if (list2 instanceof IntegerList) {
          this.ensureCapacity(this._size + list2._size);
          this._data.subarray(this._size, this._size + list2.size).set(list2._data);
          this._size += list2._size;
        } else {
          this.ensureCapacity(this._size + list2.size);
          let current = 0;
          for (let xi of list2) {
            this._data[this._size + current] = xi;
            current++;
          }
          this._size += list2.size;
        }
      }
      get(index2) {
        if (index2 < 0 || index2 >= this._size) {
          throw RangeError();
        }
        return this._data[index2];
      }
      contains(value2) {
        for (let i = 0; i < this._size; i++) {
          if (this._data[i] === value2) {
            return true;
          }
        }
        return false;
      }
      set(index2, value2) {
        if (index2 < 0 || index2 >= this._size) {
          throw RangeError();
        }
        let previous4 = this._data[index2];
        this._data[index2] = value2;
        return previous4;
      }
      removeAt(index2) {
        let value2 = this.get(index2);
        this._data.copyWithin(index2, index2 + 1, this._size);
        this._data[this._size - 1] = 0;
        this._size--;
        return value2;
      }
      removeRange(fromIndex, toIndex) {
        if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
          throw RangeError();
        }
        if (fromIndex > toIndex) {
          throw RangeError();
        }
        this._data.copyWithin(toIndex, fromIndex, this._size);
        this._data.fill(0, this._size - (toIndex - fromIndex), this._size);
        this._size -= toIndex - fromIndex;
      }
      get isEmpty() {
        return this._size === 0;
      }
      get size() {
        return this._size;
      }
      trimToSize() {
        if (this._data.length === this._size) {
          return;
        }
        this._data = this._data.slice(0, this._size);
      }
      clear() {
        this._data.fill(0, 0, this._size);
        this._size = 0;
      }
      toArray() {
        if (this._size === 0) {
          return [];
        }
        return Array.from(this._data.subarray(0, this._size));
      }
      sort() {
        this._data.subarray(0, this._size).sort();
      }
      equals(o) {
        if (o === this) {
          return true;
        }
        if (!(o instanceof IntegerList)) {
          return false;
        }
        if (this._size !== o._size) {
          return false;
        }
        for (let i = 0; i < this._size; i++) {
          if (this._data[i] !== o._data[i]) {
            return false;
          }
        }
        return true;
      }
      hashCode() {
        let hashCode = 1;
        for (let i = 0; i < this._size; i++) {
          hashCode = 31 * hashCode + this._data[i];
        }
        return hashCode;
      }
      toString() {
        return this._data.toString();
      }
      binarySearch(key, fromIndex, toIndex) {
        if (fromIndex === void 0) {
          fromIndex = 0;
        }
        if (toIndex === void 0) {
          toIndex = this._size;
        }
        if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
          throw new RangeError();
        }
        if (fromIndex > toIndex) {
          throw new RangeError();
        }
        return Arrays_1.Arrays.binarySearch(this._data, key, fromIndex, toIndex);
      }
      ensureCapacity(capacity) {
        if (capacity < 0 || capacity > MAX_ARRAY_SIZE) {
          throw new RangeError();
        }
        let newLength;
        if (this._data.length === 0) {
          newLength = INITIAL_SIZE;
        } else {
          newLength = this._data.length;
        }
        while (newLength < capacity) {
          newLength = newLength * 2;
          if (newLength < 0 || newLength > MAX_ARRAY_SIZE) {
            newLength = MAX_ARRAY_SIZE;
          }
        }
        let tmp = new Int32Array(newLength);
        tmp.set(this._data);
        this._data = tmp;
      }
      toCharArray() {
        let resultArray = new Uint16Array(this._size);
        let resultIdx = 0;
        let calculatedPreciseResultSize = false;
        for (let i = 0; i < this._size; i++) {
          let codePoint = this._data[i];
          if (codePoint >= 0 && codePoint < 65536) {
            resultArray[resultIdx] = codePoint;
            resultIdx++;
            continue;
          }
          if (!calculatedPreciseResultSize) {
            let newResultArray = new Uint16Array(this.charArraySize());
            newResultArray.set(resultArray, 0);
            resultArray = newResultArray;
            calculatedPreciseResultSize = true;
          }
          let pair = String.fromCodePoint(codePoint);
          resultArray[resultIdx] = pair.charCodeAt(0);
          resultArray[resultIdx + 1] = pair.charCodeAt(1);
          resultIdx += 2;
        }
        return resultArray;
      }
      charArraySize() {
        let result = 0;
        for (let i = 0; i < this._size; i++) {
          result += this._data[i] >= 65536 ? 2 : 1;
        }
        return result;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], IntegerList.prototype, "_data", void 0);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "toString", null);
    exports.IntegerList = IntegerList;
  }
});

// node_modules/antlr4ts/misc/Interval.js
var require_Interval = __commonJS({
  "node_modules/antlr4ts/misc/Interval.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Interval = void 0;
    var Decorators_1 = require_Decorators();
    var INTERVAL_POOL_MAX_VALUE = 1e3;
    var Interval = class {
      constructor(a, b) {
        this.a = a;
        this.b = b;
      }
      static get INVALID() {
        return Interval._INVALID;
      }
      static of(a, b) {
        if (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {
          return new Interval(a, b);
        }
        if (Interval.cache[a] == null) {
          Interval.cache[a] = new Interval(a, a);
        }
        return Interval.cache[a];
      }
      get length() {
        if (this.b < this.a) {
          return 0;
        }
        return this.b - this.a + 1;
      }
      equals(o) {
        if (o === this) {
          return true;
        } else if (!(o instanceof Interval)) {
          return false;
        }
        return this.a === o.a && this.b === o.b;
      }
      hashCode() {
        let hash = 23;
        hash = hash * 31 + this.a;
        hash = hash * 31 + this.b;
        return hash;
      }
      startsBeforeDisjoint(other) {
        return this.a < other.a && this.b < other.a;
      }
      startsBeforeNonDisjoint(other) {
        return this.a <= other.a && this.b >= other.a;
      }
      startsAfter(other) {
        return this.a > other.a;
      }
      startsAfterDisjoint(other) {
        return this.a > other.b;
      }
      startsAfterNonDisjoint(other) {
        return this.a > other.a && this.a <= other.b;
      }
      disjoint(other) {
        return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
      }
      adjacent(other) {
        return this.a === other.b + 1 || this.b === other.a - 1;
      }
      properlyContains(other) {
        return other.a >= this.a && other.b <= this.b;
      }
      union(other) {
        return Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));
      }
      intersection(other) {
        return Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));
      }
      differenceNotProperlyContained(other) {
        let diff;
        if (other.startsBeforeNonDisjoint(this)) {
          diff = Interval.of(Math.max(this.a, other.b + 1), this.b);
        } else if (other.startsAfterNonDisjoint(this)) {
          diff = Interval.of(this.a, other.a - 1);
        }
        return diff;
      }
      toString() {
        return this.a + ".." + this.b;
      }
    };
    Interval._INVALID = new Interval(-1, -2);
    Interval.cache = new Array(INTERVAL_POOL_MAX_VALUE + 1);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "toString", null);
    exports.Interval = Interval;
  }
});

// node_modules/antlr4ts/Token.js
var require_Token = __commonJS({
  "node_modules/antlr4ts/Token.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Token = void 0;
    var IntStream_1 = require_IntStream();
    var Token2;
    (function(Token3) {
      Token3.INVALID_TYPE = 0;
      Token3.EPSILON = -2;
      Token3.MIN_USER_TOKEN_TYPE = 1;
      Token3.EOF = IntStream_1.IntStream.EOF;
      Token3.DEFAULT_CHANNEL = 0;
      Token3.HIDDEN_CHANNEL = 1;
      Token3.MIN_USER_CHANNEL_VALUE = 2;
    })(Token2 = exports.Token || (exports.Token = {}));
  }
});

// node_modules/antlr4ts/CommonToken.js
var require_CommonToken = __commonJS({
  "node_modules/antlr4ts/CommonToken.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonToken = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var CommonToken = class CommonToken2 {
      constructor(type, text4, source = CommonToken2.EMPTY_SOURCE, channel = Token_1.Token.DEFAULT_CHANNEL, start = 0, stop = 0) {
        this._line = 0;
        this._charPositionInLine = -1;
        this._channel = Token_1.Token.DEFAULT_CHANNEL;
        this.index = -1;
        this._text = text4;
        this._type = type;
        this.source = source;
        this._channel = channel;
        this.start = start;
        this.stop = stop;
        if (source.source != null) {
          this._line = source.source.line;
          this._charPositionInLine = source.source.charPositionInLine;
        }
      }
      static fromToken(oldToken) {
        let result = new CommonToken2(oldToken.type, void 0, CommonToken2.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);
        result._line = oldToken.line;
        result.index = oldToken.tokenIndex;
        result._charPositionInLine = oldToken.charPositionInLine;
        if (oldToken instanceof CommonToken2) {
          result._text = oldToken._text;
          result.source = oldToken.source;
        } else {
          result._text = oldToken.text;
          result.source = { source: oldToken.tokenSource, stream: oldToken.inputStream };
        }
        return result;
      }
      get type() {
        return this._type;
      }
      set type(type) {
        this._type = type;
      }
      get line() {
        return this._line;
      }
      set line(line) {
        this._line = line;
      }
      get text() {
        if (this._text != null) {
          return this._text;
        }
        let input = this.inputStream;
        if (input == null) {
          return void 0;
        }
        let n = input.size;
        if (this.start < n && this.stop < n) {
          return input.getText(Interval_1.Interval.of(this.start, this.stop));
        } else {
          return "<EOF>";
        }
      }
      set text(text4) {
        this._text = text4;
      }
      get charPositionInLine() {
        return this._charPositionInLine;
      }
      set charPositionInLine(charPositionInLine) {
        this._charPositionInLine = charPositionInLine;
      }
      get channel() {
        return this._channel;
      }
      set channel(channel) {
        this._channel = channel;
      }
      get startIndex() {
        return this.start;
      }
      set startIndex(start) {
        this.start = start;
      }
      get stopIndex() {
        return this.stop;
      }
      set stopIndex(stop) {
        this.stop = stop;
      }
      get tokenIndex() {
        return this.index;
      }
      set tokenIndex(index2) {
        this.index = index2;
      }
      get tokenSource() {
        return this.source.source;
      }
      get inputStream() {
        return this.source.stream;
      }
      toString(recognizer) {
        let channelStr = "";
        if (this._channel > 0) {
          channelStr = ",channel=" + this._channel;
        }
        let txt = this.text;
        if (txt != null) {
          txt = txt.replace(/\n/g, "\\n");
          txt = txt.replace(/\r/g, "\\r");
          txt = txt.replace(/\t/g, "\\t");
        } else {
          txt = "<no text>";
        }
        let typeString = String(this._type);
        if (recognizer) {
          typeString = recognizer.vocabulary.getDisplayName(this._type);
        }
        return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + typeString + ">" + channelStr + "," + this._line + ":" + this.charPositionInLine + "]";
      }
    };
    CommonToken.EMPTY_SOURCE = { source: void 0, stream: void 0 };
    __decorate([
      Decorators_1.NotNull
    ], CommonToken.prototype, "source", void 0);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "type", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "channel", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "startIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "stopIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "tokenIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "toString", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], CommonToken, "fromToken", null);
    CommonToken = __decorate([
      __param(2, Decorators_1.NotNull)
    ], CommonToken);
    exports.CommonToken = CommonToken;
  }
});

// node_modules/antlr4ts/CommonTokenFactory.js
var require_CommonTokenFactory = __commonJS({
  "node_modules/antlr4ts/CommonTokenFactory.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonTokenFactory = void 0;
    var CommonToken_1 = require_CommonToken();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var CommonTokenFactory = class {
      constructor(copyText = false) {
        this.copyText = copyText;
      }
      create(source, type, text4, channel, start, stop, line, charPositionInLine) {
        let t = new CommonToken_1.CommonToken(type, text4, source, channel, start, stop);
        t.line = line;
        t.charPositionInLine = charPositionInLine;
        if (text4 == null && this.copyText && source.stream != null) {
          t.text = source.stream.getText(Interval_1.Interval.of(start, stop));
        }
        return t;
      }
      createSimple(type, text4) {
        return new CommonToken_1.CommonToken(type, text4);
      }
    };
    __decorate([
      Decorators_1.Override
    ], CommonTokenFactory.prototype, "create", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenFactory.prototype, "createSimple", null);
    exports.CommonTokenFactory = CommonTokenFactory;
    (function(CommonTokenFactory2) {
      CommonTokenFactory2.DEFAULT = new CommonTokenFactory2();
    })(CommonTokenFactory = exports.CommonTokenFactory || (exports.CommonTokenFactory = {}));
  }
});

// node_modules/antlr4ts/misc/IntegerStack.js
var require_IntegerStack = __commonJS({
  "node_modules/antlr4ts/misc/IntegerStack.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntegerStack = void 0;
    var IntegerList_1 = require_IntegerList();
    var IntegerStack = class extends IntegerList_1.IntegerList {
      constructor(arg) {
        super(arg);
      }
      push(value2) {
        this.add(value2);
      }
      pop() {
        return this.removeAt(this.size - 1);
      }
      peek() {
        return this.get(this.size - 1);
      }
    };
    exports.IntegerStack = IntegerStack;
  }
});

// node_modules/antlr4ts/dfa/AcceptStateInfo.js
var require_AcceptStateInfo = __commonJS({
  "node_modules/antlr4ts/dfa/AcceptStateInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AcceptStateInfo = void 0;
    var AcceptStateInfo = class {
      constructor(prediction, lexerActionExecutor) {
        this._prediction = prediction;
        this._lexerActionExecutor = lexerActionExecutor;
      }
      get prediction() {
        return this._prediction;
      }
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
    };
    exports.AcceptStateInfo = AcceptStateInfo;
  }
});

// node_modules/antlr4ts/misc/Array2DHashMap.js
var require_Array2DHashMap = __commonJS({
  "node_modules/antlr4ts/misc/Array2DHashMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Array2DHashMap = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var MapKeyEqualityComparator = class {
      constructor(keyComparator) {
        this.keyComparator = keyComparator;
      }
      hashCode(obj) {
        return this.keyComparator.hashCode(obj.key);
      }
      equals(a, b) {
        return this.keyComparator.equals(a.key, b.key);
      }
    };
    var Array2DHashMap = class {
      constructor(keyComparer) {
        if (keyComparer instanceof Array2DHashMap) {
          this.backingStore = new Array2DHashSet_1.Array2DHashSet(keyComparer.backingStore);
        } else {
          this.backingStore = new Array2DHashSet_1.Array2DHashSet(new MapKeyEqualityComparator(keyComparer));
        }
      }
      clear() {
        this.backingStore.clear();
      }
      containsKey(key) {
        return this.backingStore.contains({ key });
      }
      get(key) {
        let bucket = this.backingStore.get({ key });
        if (!bucket) {
          return void 0;
        }
        return bucket.value;
      }
      get isEmpty() {
        return this.backingStore.isEmpty;
      }
      put(key, value2) {
        let element2 = this.backingStore.get({ key, value: value2 });
        let result;
        if (!element2) {
          this.backingStore.add({ key, value: value2 });
        } else {
          result = element2.value;
          element2.value = value2;
        }
        return result;
      }
      putIfAbsent(key, value2) {
        let element2 = this.backingStore.get({ key, value: value2 });
        let result;
        if (!element2) {
          this.backingStore.add({ key, value: value2 });
        } else {
          result = element2.value;
        }
        return result;
      }
      get size() {
        return this.backingStore.size;
      }
      hashCode() {
        return this.backingStore.hashCode();
      }
      equals(o) {
        if (!(o instanceof Array2DHashMap)) {
          return false;
        }
        return this.backingStore.equals(o.backingStore);
      }
    };
    exports.Array2DHashMap = Array2DHashMap;
  }
});

// node_modules/antlr4ts/atn/DecisionState.js
var require_DecisionState = __commonJS({
  "node_modules/antlr4ts/atn/DecisionState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionState = void 0;
    var ATNState_1 = require_ATNState();
    var DecisionState = class extends ATNState_1.ATNState {
      constructor() {
        super(...arguments);
        this.decision = -1;
        this.nonGreedy = false;
        this.sll = false;
      }
    };
    exports.DecisionState = DecisionState;
  }
});

// node_modules/antlr4ts/atn/PredictionContextCache.js
var require_PredictionContextCache = __commonJS({
  "node_modules/antlr4ts/atn/PredictionContextCache.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredictionContextCache = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var assert = require("assert");
    var PredictionContextCache = class {
      constructor(enableCache = true) {
        this.contexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.childContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.joinContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.enableCache = enableCache;
      }
      getAsCached(context) {
        if (!this.enableCache) {
          return context;
        }
        let result = this.contexts.get(context);
        if (!result) {
          result = context;
          this.contexts.put(context, context);
        }
        return result;
      }
      getChild(context, invokingState) {
        if (!this.enableCache) {
          return context.getChild(invokingState);
        }
        let operands = new PredictionContextCache.PredictionContextAndInt(context, invokingState);
        let result = this.childContexts.get(operands);
        if (!result) {
          result = context.getChild(invokingState);
          result = this.getAsCached(result);
          this.childContexts.put(operands, result);
        }
        return result;
      }
      join(x, y) {
        if (!this.enableCache) {
          return PredictionContext_1.PredictionContext.join(x, y, this);
        }
        let operands = new PredictionContextCache.IdentityCommutativePredictionContextOperands(x, y);
        let result = this.joinContexts.get(operands);
        if (result) {
          return result;
        }
        result = PredictionContext_1.PredictionContext.join(x, y, this);
        result = this.getAsCached(result);
        this.joinContexts.put(operands, result);
        return result;
      }
    };
    exports.PredictionContextCache = PredictionContextCache;
    PredictionContextCache.UNCACHED = new PredictionContextCache(false);
    (function(PredictionContextCache2) {
      class PredictionContextAndInt {
        constructor(obj, value2) {
          this.obj = obj;
          this.value = value2;
        }
        equals(obj) {
          if (!(obj instanceof PredictionContextAndInt)) {
            return false;
          } else if (obj === this) {
            return true;
          }
          let other = obj;
          return this.value === other.value && (this.obj === other.obj || this.obj != null && this.obj.equals(other.obj));
        }
        hashCode() {
          let hashCode = 5;
          hashCode = 7 * hashCode + (this.obj != null ? this.obj.hashCode() : 0);
          hashCode = 7 * hashCode + this.value;
          return hashCode;
        }
      }
      __decorate([
        Decorators_1.Override
      ], PredictionContextAndInt.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], PredictionContextAndInt.prototype, "hashCode", null);
      PredictionContextCache2.PredictionContextAndInt = PredictionContextAndInt;
      class IdentityCommutativePredictionContextOperands {
        constructor(x, y) {
          assert(x != null);
          assert(y != null);
          this._x = x;
          this._y = y;
        }
        get x() {
          return this._x;
        }
        get y() {
          return this._y;
        }
        equals(o) {
          if (!(o instanceof IdentityCommutativePredictionContextOperands)) {
            return false;
          } else if (this === o) {
            return true;
          }
          let other = o;
          return this._x === other._x && this._y === other._y || this._x === other._y && this._y === other._x;
        }
        hashCode() {
          return this._x.hashCode() ^ this._y.hashCode();
        }
      }
      __decorate([
        Decorators_1.Override
      ], IdentityCommutativePredictionContextOperands.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], IdentityCommutativePredictionContextOperands.prototype, "hashCode", null);
      PredictionContextCache2.IdentityCommutativePredictionContextOperands = IdentityCommutativePredictionContextOperands;
    })(PredictionContextCache = exports.PredictionContextCache || (exports.PredictionContextCache = {}));
  }
});

// node_modules/antlr4ts/atn/PredictionContext.js
var require_PredictionContext = __commonJS({
  "node_modules/antlr4ts/atn/PredictionContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingletonPredictionContext = exports.PredictionContext = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var Arrays_1 = require_Arrays();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var assert = require("assert");
    var INITIAL_HASH = 1;
    var PredictionContext = class {
      constructor(cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
      }
      static calculateEmptyHashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        hash = MurmurHash_1.MurmurHash.finish(hash, 0);
        return hash;
      }
      static calculateSingleHashCode(parent, returnState) {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        hash = MurmurHash_1.MurmurHash.update(hash, parent);
        hash = MurmurHash_1.MurmurHash.update(hash, returnState);
        hash = MurmurHash_1.MurmurHash.finish(hash, 2);
        return hash;
      }
      static calculateHashCode(parents, returnStates) {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        for (let parent of parents) {
          hash = MurmurHash_1.MurmurHash.update(hash, parent);
        }
        for (let returnState of returnStates) {
          hash = MurmurHash_1.MurmurHash.update(hash, returnState);
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, 2 * parents.length);
        return hash;
      }
      static fromRuleContext(atn, outerContext, fullContext = true) {
        if (outerContext.isEmpty) {
          return fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
        }
        let parent;
        if (outerContext._parent) {
          parent = PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);
        } else {
          parent = fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
        }
        let state = atn.states[outerContext.invokingState];
        let transition = state.transition(0);
        return parent.getChild(transition.followState.stateNumber);
      }
      static addEmptyContext(context) {
        return context.addEmptyContext();
      }
      static removeEmptyContext(context) {
        return context.removeEmptyContext();
      }
      static join(context0, context1, contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED) {
        if (context0 === context1) {
          return context0;
        }
        if (context0.isEmpty) {
          return PredictionContext.isEmptyLocal(context0) ? context0 : PredictionContext.addEmptyContext(context1);
        } else if (context1.isEmpty) {
          return PredictionContext.isEmptyLocal(context1) ? context1 : PredictionContext.addEmptyContext(context0);
        }
        let context0size = context0.size;
        let context1size = context1.size;
        if (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {
          let merged = contextCache.join(context0.getParent(0), context1.getParent(0));
          if (merged === context0.getParent(0)) {
            return context0;
          } else if (merged === context1.getParent(0)) {
            return context1;
          } else {
            return merged.getChild(context0.getReturnState(0));
          }
        }
        let count = 0;
        let parentsList = new Array(context0size + context1size);
        let returnStatesList = new Array(parentsList.length);
        let leftIndex = 0;
        let rightIndex = 0;
        let canReturnLeft = true;
        let canReturnRight = true;
        while (leftIndex < context0size && rightIndex < context1size) {
          if (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {
            parentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));
            returnStatesList[count] = context0.getReturnState(leftIndex);
            canReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);
            canReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);
            leftIndex++;
            rightIndex++;
          } else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {
            parentsList[count] = context0.getParent(leftIndex);
            returnStatesList[count] = context0.getReturnState(leftIndex);
            canReturnRight = false;
            leftIndex++;
          } else {
            assert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));
            parentsList[count] = context1.getParent(rightIndex);
            returnStatesList[count] = context1.getReturnState(rightIndex);
            canReturnLeft = false;
            rightIndex++;
          }
          count++;
        }
        while (leftIndex < context0size) {
          parentsList[count] = context0.getParent(leftIndex);
          returnStatesList[count] = context0.getReturnState(leftIndex);
          leftIndex++;
          canReturnRight = false;
          count++;
        }
        while (rightIndex < context1size) {
          parentsList[count] = context1.getParent(rightIndex);
          returnStatesList[count] = context1.getReturnState(rightIndex);
          rightIndex++;
          canReturnLeft = false;
          count++;
        }
        if (canReturnLeft) {
          return context0;
        } else if (canReturnRight) {
          return context1;
        }
        if (count < parentsList.length) {
          parentsList = parentsList.slice(0, count);
          returnStatesList = returnStatesList.slice(0, count);
        }
        if (parentsList.length === 0) {
          return PredictionContext.EMPTY_FULL;
        } else if (parentsList.length === 1) {
          return new SingletonPredictionContext(parentsList[0], returnStatesList[0]);
        } else {
          return new ArrayPredictionContext(parentsList, returnStatesList);
        }
      }
      static isEmptyLocal(context) {
        return context === PredictionContext.EMPTY_LOCAL;
      }
      static getCachedContext(context, contextCache, visited) {
        if (context.isEmpty) {
          return context;
        }
        let existing = visited.get(context);
        if (existing) {
          return existing;
        }
        existing = contextCache.get(context);
        if (existing) {
          visited.put(context, existing);
          return existing;
        }
        let changed = false;
        let parents = new Array(context.size);
        for (let i = 0; i < parents.length; i++) {
          let parent = PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);
          if (changed || parent !== context.getParent(i)) {
            if (!changed) {
              parents = new Array(context.size);
              for (let j = 0; j < context.size; j++) {
                parents[j] = context.getParent(j);
              }
              changed = true;
            }
            parents[i] = parent;
          }
        }
        if (!changed) {
          existing = contextCache.putIfAbsent(context, context);
          visited.put(context, existing != null ? existing : context);
          return context;
        }
        let updated;
        if (parents.length === 1) {
          updated = new SingletonPredictionContext(parents[0], context.getReturnState(0));
        } else {
          let returnStates = new Array(context.size);
          for (let i = 0; i < context.size; i++) {
            returnStates[i] = context.getReturnState(i);
          }
          updated = new ArrayPredictionContext(parents, returnStates, context.hashCode());
        }
        existing = contextCache.putIfAbsent(updated, updated);
        visited.put(updated, existing || updated);
        visited.put(context, existing || updated);
        return updated;
      }
      appendSingleContext(returnContext, contextCache) {
        return this.appendContext(PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);
      }
      getChild(returnState) {
        return new SingletonPredictionContext(this, returnState);
      }
      hashCode() {
        return this.cachedHashCode;
      }
      toStrings(recognizer, currentState, stop = PredictionContext.EMPTY_FULL) {
        let result = [];
        outer:
          for (let perm = 0; ; perm++) {
            let offset = 0;
            let last = true;
            let p = this;
            let stateNumber = currentState;
            let localBuffer = "";
            localBuffer += "[";
            while (!p.isEmpty && p !== stop) {
              let index2 = 0;
              if (p.size > 0) {
                let bits = 1;
                while (1 << bits >>> 0 < p.size) {
                  bits++;
                }
                let mask = (1 << bits >>> 0) - 1;
                index2 = perm >> offset & mask;
                last = last && index2 >= p.size - 1;
                if (index2 >= p.size) {
                  continue outer;
                }
                offset += bits;
              }
              if (recognizer) {
                if (localBuffer.length > 1) {
                  localBuffer += " ";
                }
                let atn = recognizer.atn;
                let s = atn.states[stateNumber];
                let ruleName = recognizer.ruleNames[s.ruleIndex];
                localBuffer += ruleName;
              } else if (p.getReturnState(index2) !== PredictionContext.EMPTY_FULL_STATE_KEY) {
                if (!p.isEmpty) {
                  if (localBuffer.length > 1) {
                    localBuffer += " ";
                  }
                  localBuffer += p.getReturnState(index2);
                }
              }
              stateNumber = p.getReturnState(index2);
              p = p.getParent(index2);
            }
            localBuffer += "]";
            result.push(localBuffer);
            if (last) {
              break;
            }
          }
        return result;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PredictionContext.prototype, "hashCode", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], PredictionContext, "join", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], PredictionContext, "getCachedContext", null);
    exports.PredictionContext = PredictionContext;
    var EmptyPredictionContext = class extends PredictionContext {
      constructor(fullContext) {
        super(PredictionContext.calculateEmptyHashCode());
        this.fullContext = fullContext;
      }
      get isFullContext() {
        return this.fullContext;
      }
      addEmptyContext() {
        return this;
      }
      removeEmptyContext() {
        throw new Error("Cannot remove the empty context from itself.");
      }
      getParent(index2) {
        throw new Error("index out of bounds");
      }
      getReturnState(index2) {
        throw new Error("index out of bounds");
      }
      findReturnState(returnState) {
        return -1;
      }
      get size() {
        return 0;
      }
      appendSingleContext(returnContext, contextCache) {
        return contextCache.getChild(this, returnContext);
      }
      appendContext(suffix, contextCache) {
        return suffix;
      }
      get isEmpty() {
        return true;
      }
      get hasEmpty() {
        return true;
      }
      equals(o) {
        return this === o;
      }
      toStrings(recognizer, currentState, stop) {
        return ["[]"];
      }
    };
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "appendSingleContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "toStrings", null);
    var ArrayPredictionContext = class ArrayPredictionContext2 extends PredictionContext {
      constructor(parents, returnStates, hashCode) {
        super(hashCode || PredictionContext.calculateHashCode(parents, returnStates));
        assert(parents.length === returnStates.length);
        assert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, "Should be using PredictionContext.EMPTY instead.");
        this.parents = parents;
        this.returnStates = returnStates;
      }
      getParent(index2) {
        return this.parents[index2];
      }
      getReturnState(index2) {
        return this.returnStates[index2];
      }
      findReturnState(returnState) {
        return Arrays_1.Arrays.binarySearch(this.returnStates, returnState);
      }
      get size() {
        return this.returnStates.length;
      }
      get isEmpty() {
        return false;
      }
      get hasEmpty() {
        return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;
      }
      addEmptyContext() {
        if (this.hasEmpty) {
          return this;
        }
        let parents2 = this.parents.slice(0);
        let returnStates2 = this.returnStates.slice(0);
        parents2.push(PredictionContext.EMPTY_FULL);
        returnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);
        return new ArrayPredictionContext2(parents2, returnStates2);
      }
      removeEmptyContext() {
        if (!this.hasEmpty) {
          return this;
        }
        if (this.returnStates.length === 2) {
          return new SingletonPredictionContext(this.parents[0], this.returnStates[0]);
        } else {
          let parents2 = this.parents.slice(0, this.parents.length - 1);
          let returnStates2 = this.returnStates.slice(0, this.returnStates.length - 1);
          return new ArrayPredictionContext2(parents2, returnStates2);
        }
      }
      appendContext(suffix, contextCache) {
        return ArrayPredictionContext2.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());
      }
      static appendContextImpl(context, suffix, visited) {
        if (suffix.isEmpty) {
          if (PredictionContext.isEmptyLocal(suffix)) {
            if (context.hasEmpty) {
              return PredictionContext.EMPTY_LOCAL;
            }
            throw new Error("what to do here?");
          }
          return context;
        }
        if (suffix.size !== 1) {
          throw new Error("Appending a tree suffix is not yet supported.");
        }
        let result = visited.get(context);
        if (!result) {
          if (context.isEmpty) {
            result = suffix;
          } else {
            let parentCount = context.size;
            if (context.hasEmpty) {
              parentCount--;
            }
            let updatedParents = new Array(parentCount);
            let updatedReturnStates = new Array(parentCount);
            for (let i = 0; i < parentCount; i++) {
              updatedReturnStates[i] = context.getReturnState(i);
            }
            for (let i = 0; i < parentCount; i++) {
              updatedParents[i] = ArrayPredictionContext2.appendContextImpl(context.getParent(i), suffix, visited);
            }
            if (updatedParents.length === 1) {
              result = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);
            } else {
              assert(updatedParents.length > 1);
              result = new ArrayPredictionContext2(updatedParents, updatedReturnStates);
            }
            if (context.hasEmpty) {
              result = PredictionContext.join(result, suffix);
            }
          }
          visited.put(context, result);
        }
        return result;
      }
      equals(o) {
        if (this === o) {
          return true;
        } else if (!(o instanceof ArrayPredictionContext2)) {
          return false;
        }
        if (this.hashCode() !== o.hashCode()) {
          return false;
        }
        let other = o;
        return this.equalsImpl(other, new Array2DHashSet_1.Array2DHashSet());
      }
      equalsImpl(other, visited) {
        let selfWorkList = [];
        let otherWorkList = [];
        selfWorkList.push(this);
        otherWorkList.push(other);
        while (true) {
          let currentSelf = selfWorkList.pop();
          let currentOther = otherWorkList.pop();
          if (!currentSelf || !currentOther) {
            break;
          }
          let operands = new PredictionContextCache_1.PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);
          if (!visited.add(operands)) {
            continue;
          }
          let selfSize = operands.x.size;
          if (selfSize === 0) {
            if (!operands.x.equals(operands.y)) {
              return false;
            }
            continue;
          }
          let otherSize = operands.y.size;
          if (selfSize !== otherSize) {
            return false;
          }
          for (let i = 0; i < selfSize; i++) {
            if (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {
              return false;
            }
            let selfParent = operands.x.getParent(i);
            let otherParent = operands.y.getParent(i);
            if (selfParent.hashCode() !== otherParent.hashCode()) {
              return false;
            }
            if (selfParent !== otherParent) {
              selfWorkList.push(selfParent);
              otherWorkList.push(otherParent);
            }
          }
        }
        return true;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ArrayPredictionContext.prototype, "parents", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ArrayPredictionContext.prototype, "returnStates", void 0);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "equals", null);
    ArrayPredictionContext = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ArrayPredictionContext);
    var SingletonPredictionContext = class SingletonPredictionContext2 extends PredictionContext {
      constructor(parent, returnState) {
        super(PredictionContext.calculateSingleHashCode(parent, returnState));
        this.parent = parent;
        this.returnState = returnState;
      }
      getParent(index2) {
        return this.parent;
      }
      getReturnState(index2) {
        return this.returnState;
      }
      findReturnState(returnState) {
        return this.returnState === returnState ? 0 : -1;
      }
      get size() {
        return 1;
      }
      get isEmpty() {
        return false;
      }
      get hasEmpty() {
        return false;
      }
      appendContext(suffix, contextCache) {
        return contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);
      }
      addEmptyContext() {
        let parents = [this.parent, PredictionContext.EMPTY_FULL];
        let returnStates = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];
        return new ArrayPredictionContext(parents, returnStates);
      }
      removeEmptyContext() {
        return this;
      }
      equals(o) {
        if (o === this) {
          return true;
        } else if (!(o instanceof SingletonPredictionContext2)) {
          return false;
        }
        let other = o;
        if (this.hashCode() !== other.hashCode()) {
          return false;
        }
        return this.returnState === other.returnState && this.parent.equals(other.parent);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SingletonPredictionContext.prototype, "parent", void 0);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "equals", null);
    SingletonPredictionContext = __decorate([
      __param(0, Decorators_1.NotNull)
    ], SingletonPredictionContext);
    exports.SingletonPredictionContext = SingletonPredictionContext;
    (function(PredictionContext2) {
      PredictionContext2.EMPTY_LOCAL = new EmptyPredictionContext(false);
      PredictionContext2.EMPTY_FULL = new EmptyPredictionContext(true);
      PredictionContext2.EMPTY_LOCAL_STATE_KEY = -(1 << 31 >>> 0);
      PredictionContext2.EMPTY_FULL_STATE_KEY = (1 << 31 >>> 0) - 1;
      class IdentityHashMap extends Array2DHashMap_1.Array2DHashMap {
        constructor() {
          super(IdentityEqualityComparator.INSTANCE);
        }
      }
      PredictionContext2.IdentityHashMap = IdentityHashMap;
      class IdentityEqualityComparator {
        IdentityEqualityComparator() {
        }
        hashCode(obj) {
          return obj.hashCode();
        }
        equals(a, b) {
          return a === b;
        }
      }
      IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], IdentityEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], IdentityEqualityComparator.prototype, "equals", null);
      PredictionContext2.IdentityEqualityComparator = IdentityEqualityComparator;
    })(PredictionContext = exports.PredictionContext || (exports.PredictionContext = {}));
  }
});

// node_modules/antlr4ts/atn/ATNConfig.js
var require_ATNConfig = __commonJS({
  "node_modules/antlr4ts/atn/ATNConfig.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNConfig = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var DecisionState_1 = require_DecisionState();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var SemanticContext_1 = require_SemanticContext();
    var assert = require("assert");
    var SUPPRESS_PRECEDENCE_FILTER = 2147483648;
    var ATNConfig = class ATNConfig2 {
      constructor(state, altOrConfig, context) {
        if (typeof altOrConfig === "number") {
          assert((altOrConfig & 16777215) === altOrConfig);
          this._state = state;
          this.altAndOuterContextDepth = altOrConfig;
          this._context = context;
        } else {
          this._state = state;
          this.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;
          this._context = context;
        }
      }
      static create(state, alt, context, semanticContext = SemanticContext_1.SemanticContext.NONE, lexerActionExecutor) {
        if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
          if (lexerActionExecutor != null) {
            return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);
          } else {
            return new SemanticContextATNConfig(semanticContext, state, alt, context);
          }
        } else if (lexerActionExecutor != null) {
          return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);
        } else {
          return new ATNConfig2(state, alt, context);
        }
      }
      get state() {
        return this._state;
      }
      get alt() {
        return this.altAndOuterContextDepth & 16777215;
      }
      get context() {
        return this._context;
      }
      set context(context) {
        this._context = context;
      }
      get reachesIntoOuterContext() {
        return this.outerContextDepth !== 0;
      }
      get outerContextDepth() {
        return this.altAndOuterContextDepth >>> 24 & 127;
      }
      set outerContextDepth(outerContextDepth) {
        assert(outerContextDepth >= 0);
        outerContextDepth = Math.min(outerContextDepth, 127);
        this.altAndOuterContextDepth = outerContextDepth << 24 | (this.altAndOuterContextDepth & ~2130706432) >>> 0;
      }
      get lexerActionExecutor() {
        return void 0;
      }
      get semanticContext() {
        return SemanticContext_1.SemanticContext.NONE;
      }
      get hasPassedThroughNonGreedyDecision() {
        return false;
      }
      clone() {
        return this.transform(this.state, false);
      }
      transform(state, checkNonGreedy, arg2) {
        if (arg2 == null) {
          return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
        } else if (arg2 instanceof PredictionContext_1.PredictionContext) {
          return this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
        } else if (arg2 instanceof SemanticContext_1.SemanticContext) {
          return this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);
        } else {
          return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);
        }
      }
      transformImpl(state, context, semanticContext, checkNonGreedy, lexerActionExecutor) {
        let passedThroughNonGreedy = checkNonGreedy && ATNConfig2.checkNonGreedyDecision(this, state);
        if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
          if (lexerActionExecutor != null || passedThroughNonGreedy) {
            return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);
          } else {
            return new SemanticContextATNConfig(semanticContext, state, this, context);
          }
        } else if (lexerActionExecutor != null || passedThroughNonGreedy) {
          return new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);
        } else {
          return new ATNConfig2(state, this, context);
        }
      }
      static checkNonGreedyDecision(source, target) {
        return source.hasPassedThroughNonGreedyDecision || target instanceof DecisionState_1.DecisionState && target.nonGreedy;
      }
      appendContext(context, contextCache) {
        if (typeof context === "number") {
          let appendedContext = this.context.appendSingleContext(context, contextCache);
          let result = this.transform(this.state, false, appendedContext);
          return result;
        } else {
          let appendedContext = this.context.appendContext(context, contextCache);
          let result = this.transform(this.state, false, appendedContext);
          return result;
        }
      }
      contains(subconfig) {
        if (this.state.stateNumber !== subconfig.state.stateNumber || this.alt !== subconfig.alt || !this.semanticContext.equals(subconfig.semanticContext)) {
          return false;
        }
        let leftWorkList = [];
        let rightWorkList = [];
        leftWorkList.push(this.context);
        rightWorkList.push(subconfig.context);
        while (true) {
          let left = leftWorkList.pop();
          let right = rightWorkList.pop();
          if (!left || !right) {
            break;
          }
          if (left === right) {
            return true;
          }
          if (left.size < right.size) {
            return false;
          }
          if (right.isEmpty) {
            return left.hasEmpty;
          } else {
            for (let i = 0; i < right.size; i++) {
              let index2 = left.findReturnState(right.getReturnState(i));
              if (index2 < 0) {
                return false;
              }
              leftWorkList.push(left.getParent(index2));
              rightWorkList.push(right.getParent(i));
            }
          }
        }
        return false;
      }
      get isPrecedenceFilterSuppressed() {
        return (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;
      }
      set isPrecedenceFilterSuppressed(value2) {
        if (value2) {
          this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;
        } else {
          this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;
        }
      }
      equals(o) {
        if (this === o) {
          return true;
        } else if (!(o instanceof ATNConfig2)) {
          return false;
        }
        return this.state.stateNumber === o.state.stateNumber && this.alt === o.alt && this.reachesIntoOuterContext === o.reachesIntoOuterContext && this.context.equals(o.context) && this.semanticContext.equals(o.semanticContext) && this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed && this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision && ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);
      }
      hashCode() {
        let hashCode = MurmurHash_1.MurmurHash.initialize(7);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.state.stateNumber);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.alt);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.context);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.semanticContext);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.lexerActionExecutor);
        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 7);
        return hashCode;
      }
      toDotString() {
        let builder = "";
        builder += "digraph G {\n";
        builder += "rankdir=LR;\n";
        let visited = new Array2DHashMap_1.Array2DHashMap(PredictionContext_1.PredictionContext.IdentityEqualityComparator.INSTANCE);
        let workList = [];
        function getOrAddContext(context) {
          let newNumber = visited.size;
          let result = visited.putIfAbsent(context, newNumber);
          if (result != null) {
            return result;
          }
          workList.push(context);
          return newNumber;
        }
        workList.push(this.context);
        visited.put(this.context, 0);
        while (true) {
          let current = workList.pop();
          if (!current) {
            break;
          }
          for (let i = 0; i < current.size; i++) {
            builder += "  s" + getOrAddContext(current);
            builder += "->";
            builder += "s" + getOrAddContext(current.getParent(i));
            builder += '[label="' + current.getReturnState(i) + '"];\n';
          }
        }
        builder += "}\n";
        return builder.toString();
      }
      toString(recog, showAlt, showContext) {
        if (showContext == null) {
          showContext = showAlt != null;
        }
        if (showAlt == null) {
          showAlt = true;
        }
        let buf = "";
        let contexts;
        if (showContext) {
          contexts = this.context.toStrings(recog, this.state.stateNumber);
        } else {
          contexts = ["?"];
        }
        let first = true;
        for (let contextDesc of contexts) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          buf += "(";
          buf += this.state;
          if (showAlt) {
            buf += ",";
            buf += this.alt;
          }
          if (this.context) {
            buf += ",";
            buf += contextDesc;
          }
          if (this.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            buf += ",";
            buf += this.semanticContext;
          }
          if (this.reachesIntoOuterContext) {
            buf += ",up=" + this.outerContextDepth;
          }
          buf += ")";
        }
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "_state", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "_context", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "state", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ATNConfig.prototype, "context", null);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "semanticContext", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "clone", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ATNConfig.prototype, "transformImpl", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "hashCode", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ATNConfig, "create", null);
    ATNConfig = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ATNConfig);
    exports.ATNConfig = ATNConfig;
    var SemanticContextATNConfig = class SemanticContextATNConfig extends ATNConfig {
      constructor(semanticContext, state, altOrConfig, context) {
        if (typeof altOrConfig === "number") {
          super(state, altOrConfig, context);
        } else {
          super(state, altOrConfig, context);
        }
        this._semanticContext = semanticContext;
      }
      get semanticContext() {
        return this._semanticContext;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SemanticContextATNConfig.prototype, "_semanticContext", void 0);
    __decorate([
      Decorators_1.Override
    ], SemanticContextATNConfig.prototype, "semanticContext", null);
    SemanticContextATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], SemanticContextATNConfig);
    var ActionATNConfig = class ActionATNConfig extends ATNConfig {
      constructor(lexerActionExecutor, state, altOrConfig, context, passedThroughNonGreedyDecision) {
        if (typeof altOrConfig === "number") {
          super(state, altOrConfig, context);
        } else {
          super(state, altOrConfig, context);
          if (altOrConfig.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            throw new Error("Not supported");
          }
        }
        this._lexerActionExecutor = lexerActionExecutor;
        this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
      }
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
      get hasPassedThroughNonGreedyDecision() {
        return this.passedThroughNonGreedyDecision;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionATNConfig.prototype, "lexerActionExecutor", null);
    __decorate([
      Decorators_1.Override
    ], ActionATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
    ActionATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ActionATNConfig);
    var ActionSemanticContextATNConfig = class ActionSemanticContextATNConfig extends SemanticContextATNConfig {
      constructor(lexerActionExecutor, semanticContext, state, altOrConfig, context, passedThroughNonGreedyDecision) {
        if (typeof altOrConfig === "number") {
          super(semanticContext, state, altOrConfig, context);
        } else {
          super(semanticContext, state, altOrConfig, context);
        }
        this._lexerActionExecutor = lexerActionExecutor;
        this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
      }
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
      get hasPassedThroughNonGreedyDecision() {
        return this.passedThroughNonGreedyDecision;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionSemanticContextATNConfig.prototype, "lexerActionExecutor", null);
    __decorate([
      Decorators_1.Override
    ], ActionSemanticContextATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
    ActionSemanticContextATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ActionSemanticContextATNConfig);
  }
});

// node_modules/antlr4ts/misc/BitSet.js
var require_BitSet = __commonJS({
  "node_modules/antlr4ts/misc/BitSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitSet = void 0;
    var util = require("util");
    var MurmurHash_1 = require_MurmurHash();
    var EMPTY_DATA = new Uint16Array(0);
    function getIndex(bitNumber) {
      return bitNumber >>> 4;
    }
    function unIndex(n) {
      return n * 16;
    }
    function findLSBSet(word) {
      let bit = 1;
      for (let i = 0; i < 16; i++) {
        if ((word & bit) !== 0) {
          return i;
        }
        bit = bit << 1 >>> 0;
      }
      throw new RangeError("No specified bit found");
    }
    function findMSBSet(word) {
      let bit = 1 << 15 >>> 0;
      for (let i = 15; i >= 0; i--) {
        if ((word & bit) !== 0) {
          return i;
        }
        bit = bit >>> 1;
      }
      throw new RangeError("No specified bit found");
    }
    function bitsFor(fromBit, toBit) {
      fromBit &= 15;
      toBit &= 15;
      if (fromBit === toBit) {
        return 1 << fromBit >>> 0;
      }
      return 65535 >>> 15 - toBit ^ 65535 >>> 16 - fromBit;
    }
    var POP_CNT = new Uint8Array(65536);
    for (let i = 0; i < 16; i++) {
      const stride = 1 << i >>> 0;
      let index2 = 0;
      while (index2 < POP_CNT.length) {
        index2 += stride;
        for (let j = 0; j < stride; j++) {
          POP_CNT[index2]++;
          index2++;
        }
      }
    }
    var BitSet = class {
      constructor(arg) {
        if (!arg) {
          this.data = EMPTY_DATA;
        } else if (typeof arg === "number") {
          if (arg < 0) {
            throw new RangeError("nbits cannot be negative");
          } else {
            this.data = new Uint16Array(getIndex(arg - 1) + 1);
          }
        } else {
          if (arg instanceof BitSet) {
            this.data = arg.data.slice(0);
          } else {
            let max = -1;
            for (let v of arg) {
              if (max < v) {
                max = v;
              }
            }
            this.data = new Uint16Array(getIndex(max - 1) + 1);
            for (let v of arg) {
              this.set(v);
            }
          }
        }
      }
      and(set) {
        const data = this.data;
        const other = set.data;
        const words = Math.min(data.length, other.length);
        let lastWord = -1;
        for (let i = 0; i < words; i++) {
          let value2 = data[i] &= other[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        }
        if (lastWord < data.length - 1) {
          this.data = data.slice(0, lastWord + 1);
        }
      }
      andNot(set) {
        const data = this.data;
        const other = set.data;
        const words = Math.min(data.length, other.length);
        let lastWord = -1;
        for (let i = 0; i < words; i++) {
          let value2 = data[i] &= other[i] ^ 65535;
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        }
        if (lastWord < data.length - 1) {
          this.data = data.slice(0, lastWord + 1);
        }
      }
      cardinality() {
        if (this.isEmpty) {
          return 0;
        }
        const data = this.data;
        const length = data.length;
        let result = 0;
        for (let i = 0; i < length; i++) {
          result += POP_CNT[data[i]];
        }
        return result;
      }
      clear(fromIndex, toIndex) {
        if (fromIndex == null) {
          this.data.fill(0);
        } else if (toIndex == null) {
          this.set(fromIndex, false);
        } else {
          this.set(fromIndex, toIndex, false);
        }
      }
      flip(fromIndex, toIndex) {
        if (toIndex == null) {
          toIndex = fromIndex;
        }
        if (fromIndex < 0 || toIndex < fromIndex) {
          throw new RangeError();
        }
        let word = getIndex(fromIndex);
        const lastWord = getIndex(toIndex);
        if (word === lastWord) {
          this.data[word] ^= bitsFor(fromIndex, toIndex);
        } else {
          this.data[word++] ^= bitsFor(fromIndex, 15);
          while (word < lastWord) {
            this.data[word++] ^= 65535;
          }
          this.data[word++] ^= bitsFor(0, toIndex);
        }
      }
      get(fromIndex, toIndex) {
        if (toIndex === void 0) {
          return !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));
        } else {
          let result = new BitSet(toIndex + 1);
          for (let i = fromIndex; i <= toIndex; i++) {
            result.set(i, this.get(i));
          }
          return result;
        }
      }
      intersects(set) {
        let smallerLength = Math.min(this.length(), set.length());
        if (smallerLength === 0) {
          return false;
        }
        let bound = getIndex(smallerLength - 1);
        for (let i = 0; i <= bound; i++) {
          if ((this.data[i] & set.data[i]) !== 0) {
            return true;
          }
        }
        return false;
      }
      get isEmpty() {
        return this.length() === 0;
      }
      length() {
        if (!this.data.length) {
          return 0;
        }
        return this.previousSetBit(unIndex(this.data.length) - 1) + 1;
      }
      nextClearBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word > length) {
          return -1;
        }
        let ignore = 65535 ^ bitsFor(fromIndex, 15);
        if ((data[word] | ignore) === 65535) {
          word++;
          ignore = 0;
          for (; word < length; word++) {
            if (data[word] !== 65535) {
              break;
            }
          }
          if (word === length) {
            return -1;
          }
        }
        return unIndex(word) + findLSBSet((data[word] | ignore) ^ 65535);
      }
      nextSetBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word > length) {
          return -1;
        }
        let mask = bitsFor(fromIndex, 15);
        if ((data[word] & mask) === 0) {
          word++;
          mask = 65535;
          for (; word < length; word++) {
            if (data[word] !== 0) {
              break;
            }
          }
          if (word >= length) {
            return -1;
          }
        }
        return unIndex(word) + findLSBSet(data[word] & mask);
      }
      or(set) {
        const data = this.data;
        const other = set.data;
        const minWords = Math.min(data.length, other.length);
        const words = Math.max(data.length, other.length);
        const dest = data.length === words ? data : new Uint16Array(words);
        let lastWord = -1;
        for (let i = 0; i < minWords; i++) {
          let value2 = dest[i] = data[i] | other[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        const longer = data.length > other.length ? data : other;
        for (let i = minWords; i < words; i++) {
          let value2 = dest[i] = longer[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        } else if (dest.length === lastWord + 1) {
          this.data = dest;
        } else {
          this.data = dest.slice(0, lastWord);
        }
      }
      previousClearBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word >= length) {
          word = length - 1;
        }
        let ignore = 65535 ^ bitsFor(0, fromIndex);
        if ((data[word] | ignore) === 65535) {
          ignore = 0;
          word--;
          for (; word >= 0; word--) {
            if (data[word] !== 65535) {
              break;
            }
          }
          if (word < 0) {
            return -1;
          }
        }
        return unIndex(word) + findMSBSet((data[word] | ignore) ^ 65535);
      }
      previousSetBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word >= length) {
          word = length - 1;
        }
        let mask = bitsFor(0, fromIndex);
        if ((data[word] & mask) === 0) {
          word--;
          mask = 65535;
          for (; word >= 0; word--) {
            if (data[word] !== 0) {
              break;
            }
          }
          if (word < 0) {
            return -1;
          }
        }
        return unIndex(word) + findMSBSet(data[word] & mask);
      }
      set(fromIndex, toIndex, value2) {
        if (toIndex === void 0) {
          toIndex = fromIndex;
          value2 = true;
        } else if (typeof toIndex === "boolean") {
          value2 = toIndex;
          toIndex = fromIndex;
        }
        if (value2 === void 0) {
          value2 = true;
        }
        if (fromIndex < 0 || fromIndex > toIndex) {
          throw new RangeError();
        }
        let word = getIndex(fromIndex);
        let lastWord = getIndex(toIndex);
        if (value2 && lastWord >= this.data.length) {
          let temp = new Uint16Array(lastWord + 1);
          this.data.forEach((value3, index2) => temp[index2] = value3);
          this.data = temp;
        } else if (!value2) {
          if (word >= this.data.length) {
            return;
          }
          if (lastWord >= this.data.length) {
            lastWord = this.data.length - 1;
            toIndex = this.data.length * 16 - 1;
          }
        }
        if (word === lastWord) {
          this._setBits(word, value2, bitsFor(fromIndex, toIndex));
        } else {
          this._setBits(word++, value2, bitsFor(fromIndex, 15));
          while (word < lastWord) {
            this.data[word++] = value2 ? 65535 : 0;
          }
          this._setBits(word, value2, bitsFor(0, toIndex));
        }
      }
      _setBits(word, value2, mask) {
        if (value2) {
          this.data[word] |= mask;
        } else {
          this.data[word] &= 65535 ^ mask;
        }
      }
      get size() {
        return this.data.byteLength * 8;
      }
      hashCode() {
        return MurmurHash_1.MurmurHash.hashCode(this.data, 22);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof BitSet)) {
          return false;
        }
        const len = this.length();
        if (len !== obj.length()) {
          return false;
        }
        if (len === 0) {
          return true;
        }
        let bound = getIndex(len - 1);
        for (let i = 0; i <= bound; i++) {
          if (this.data[i] !== obj.data[i]) {
            return false;
          }
        }
        return true;
      }
      toString() {
        let result = "{";
        let first = true;
        for (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {
          if (first) {
            first = false;
          } else {
            result += ", ";
          }
          result += i;
        }
        result += "}";
        return result;
      }
      xor(set) {
        const data = this.data;
        const other = set.data;
        const minWords = Math.min(data.length, other.length);
        const words = Math.max(data.length, other.length);
        const dest = data.length === words ? data : new Uint16Array(words);
        let lastWord = -1;
        for (let i = 0; i < minWords; i++) {
          let value2 = dest[i] = data[i] ^ other[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        const longer = data.length > other.length ? data : other;
        for (let i = minWords; i < words; i++) {
          let value2 = dest[i] = longer[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        } else if (dest.length === lastWord + 1) {
          this.data = dest;
        } else {
          this.data = dest.slice(0, lastWord + 1);
        }
      }
      clone() {
        return new BitSet(this);
      }
      [Symbol.iterator]() {
        return new BitSetIterator(this.data);
      }
      [util.inspect.custom]() {
        return "BitSet " + this.toString();
      }
    };
    exports.BitSet = BitSet;
    var BitSetIterator = class {
      constructor(data) {
        this.data = data;
        this.index = 0;
        this.mask = 65535;
      }
      next() {
        while (this.index < this.data.length) {
          const bits = this.data[this.index] & this.mask;
          if (bits !== 0) {
            const bitNumber = unIndex(this.index) + findLSBSet(bits);
            this.mask = bitsFor(bitNumber + 1, 15);
            return { done: false, value: bitNumber };
          }
          this.index++;
          this.mask = 65535;
        }
        return { done: true, value: -1 };
      }
      [Symbol.iterator]() {
        return this;
      }
    };
  }
});

// node_modules/antlr4ts/atn/ATNConfigSet.js
var require_ATNConfigSet = __commonJS({
  "node_modules/antlr4ts/atn/ATNConfigSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNConfigSet = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var BitSet_1 = require_BitSet();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var SemanticContext_1 = require_SemanticContext();
    var assert = require("assert");
    var Utils3 = require_Utils();
    var KeyTypeEqualityComparer = class {
      hashCode(key) {
        return key.state ^ key.alt;
      }
      equals(a, b) {
        return a.state === b.state && a.alt === b.alt;
      }
    };
    KeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer();
    function NewKeyedConfigMap(map) {
      if (map) {
        return new Array2DHashMap_1.Array2DHashMap(map);
      } else {
        return new Array2DHashMap_1.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE);
      }
    }
    var ATNConfigSet = class {
      constructor(set, readonly) {
        this._uniqueAlt = 0;
        this._hasSemanticContext = false;
        this._dipsIntoOuterContext = false;
        this.outermostConfigSet = false;
        this.cachedHashCode = -1;
        if (!set) {
          this.mergedConfigs = NewKeyedConfigMap();
          this.unmerged = [];
          this.configs = [];
          this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        } else {
          if (readonly) {
            this.mergedConfigs = void 0;
            this.unmerged = void 0;
          } else if (!set.isReadOnly) {
            this.mergedConfigs = NewKeyedConfigMap(set.mergedConfigs);
            this.unmerged = set.unmerged.slice(0);
          } else {
            this.mergedConfigs = NewKeyedConfigMap();
            this.unmerged = [];
          }
          this.configs = set.configs.slice(0);
          this._dipsIntoOuterContext = set._dipsIntoOuterContext;
          this._hasSemanticContext = set._hasSemanticContext;
          this.outermostConfigSet = set.outermostConfigSet;
          if (readonly || !set.isReadOnly) {
            this._uniqueAlt = set._uniqueAlt;
            this._conflictInfo = set._conflictInfo;
          }
        }
      }
      getRepresentedAlternatives() {
        if (this._conflictInfo != null) {
          return this._conflictInfo.conflictedAlts.clone();
        }
        let alts = new BitSet_1.BitSet();
        for (let config of this) {
          alts.set(config.alt);
        }
        return alts;
      }
      get isReadOnly() {
        return this.mergedConfigs == null;
      }
      get isOutermostConfigSet() {
        return this.outermostConfigSet;
      }
      set isOutermostConfigSet(outermostConfigSet) {
        if (this.outermostConfigSet && !outermostConfigSet) {
          throw new Error("IllegalStateException");
        }
        assert(!outermostConfigSet || !this._dipsIntoOuterContext);
        this.outermostConfigSet = outermostConfigSet;
      }
      getStates() {
        let states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        for (let c of this.configs) {
          states.add(c.state);
        }
        return states;
      }
      optimizeConfigs(interpreter) {
        if (this.configs.length === 0) {
          return;
        }
        for (let config of this.configs) {
          config.context = interpreter.atn.getCachedContext(config.context);
        }
      }
      clone(readonly) {
        let copy = new ATNConfigSet(this, readonly);
        if (!readonly && this.isReadOnly) {
          copy.addAll(this.configs);
        }
        return copy;
      }
      get size() {
        return this.configs.length;
      }
      get isEmpty() {
        return this.configs.length === 0;
      }
      contains(o) {
        if (!(o instanceof ATNConfig_1.ATNConfig)) {
          return false;
        }
        if (this.mergedConfigs && this.unmerged) {
          let config = o;
          let configKey = this.getKey(config);
          let mergedConfig = this.mergedConfigs.get(configKey);
          if (mergedConfig != null && this.canMerge(config, configKey, mergedConfig)) {
            return mergedConfig.contains(config);
          }
          for (let c of this.unmerged) {
            if (c.contains(o)) {
              return true;
            }
          }
        } else {
          for (let c of this.configs) {
            if (c.contains(o)) {
              return true;
            }
          }
        }
        return false;
      }
      *[Symbol.iterator]() {
        yield* this.configs;
      }
      toArray() {
        return this.configs;
      }
      add(e, contextCache) {
        this.ensureWritable();
        if (!this.mergedConfigs || !this.unmerged) {
          throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
        }
        assert(!this.outermostConfigSet || !e.reachesIntoOuterContext);
        if (contextCache == null) {
          contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
        }
        let addKey;
        let key = this.getKey(e);
        let mergedConfig = this.mergedConfigs.get(key);
        addKey = mergedConfig == null;
        if (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {
          mergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);
          if (e.isPrecedenceFilterSuppressed) {
            mergedConfig.isPrecedenceFilterSuppressed = true;
          }
          let joined = PredictionContext_1.PredictionContext.join(mergedConfig.context, e.context, contextCache);
          this.updatePropertiesForMergedConfig(e);
          if (mergedConfig.context === joined) {
            return false;
          }
          mergedConfig.context = joined;
          return true;
        }
        for (let i = 0; i < this.unmerged.length; i++) {
          let unmergedConfig = this.unmerged[i];
          if (this.canMerge(e, key, unmergedConfig)) {
            unmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);
            if (e.isPrecedenceFilterSuppressed) {
              unmergedConfig.isPrecedenceFilterSuppressed = true;
            }
            let joined = PredictionContext_1.PredictionContext.join(unmergedConfig.context, e.context, contextCache);
            this.updatePropertiesForMergedConfig(e);
            if (unmergedConfig.context === joined) {
              return false;
            }
            unmergedConfig.context = joined;
            if (addKey) {
              this.mergedConfigs.put(key, unmergedConfig);
              this.unmerged.splice(i, 1);
            }
            return true;
          }
        }
        this.configs.push(e);
        if (addKey) {
          this.mergedConfigs.put(key, e);
        } else {
          this.unmerged.push(e);
        }
        this.updatePropertiesForAddedConfig(e);
        return true;
      }
      updatePropertiesForMergedConfig(config) {
        this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
        assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
      }
      updatePropertiesForAddedConfig(config) {
        if (this.configs.length === 1) {
          this._uniqueAlt = config.alt;
        } else if (this._uniqueAlt !== config.alt) {
          this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        this._hasSemanticContext = this._hasSemanticContext || !SemanticContext_1.SemanticContext.NONE.equals(config.semanticContext);
        this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
        assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
      }
      canMerge(left, leftKey, right) {
        if (left.state.stateNumber !== right.state.stateNumber) {
          return false;
        }
        if (leftKey.alt !== right.alt) {
          return false;
        }
        return left.semanticContext.equals(right.semanticContext);
      }
      getKey(e) {
        return { state: e.state.stateNumber, alt: e.alt };
      }
      containsAll(c) {
        for (let o of c) {
          if (!(o instanceof ATNConfig_1.ATNConfig)) {
            return false;
          }
          if (!this.contains(o)) {
            return false;
          }
        }
        return true;
      }
      addAll(c, contextCache) {
        this.ensureWritable();
        let changed = false;
        for (let group of c) {
          if (this.add(group, contextCache)) {
            changed = true;
          }
        }
        return changed;
      }
      clear() {
        this.ensureWritable();
        if (!this.mergedConfigs || !this.unmerged) {
          throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
        }
        this.mergedConfigs.clear();
        this.unmerged.length = 0;
        this.configs.length = 0;
        this._dipsIntoOuterContext = false;
        this._hasSemanticContext = false;
        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        this._conflictInfo = void 0;
      }
      equals(obj) {
        if (this === obj) {
          return true;
        }
        if (!(obj instanceof ATNConfigSet)) {
          return false;
        }
        return this.outermostConfigSet === obj.outermostConfigSet && Utils3.equals(this._conflictInfo, obj._conflictInfo) && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);
      }
      hashCode() {
        if (this.isReadOnly && this.cachedHashCode !== -1) {
          return this.cachedHashCode;
        }
        let hashCode = 1;
        hashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);
        hashCode = 5 * hashCode ^ ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);
        if (this.isReadOnly) {
          this.cachedHashCode = hashCode;
        }
        return hashCode;
      }
      toString(showContext) {
        if (showContext == null) {
          showContext = false;
        }
        let buf = "";
        let sortedConfigs = this.configs.slice(0);
        sortedConfigs.sort((o1, o2) => {
          if (o1.alt !== o2.alt) {
            return o1.alt - o2.alt;
          } else if (o1.state.stateNumber !== o2.state.stateNumber) {
            return o1.state.stateNumber - o2.state.stateNumber;
          } else {
            return o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());
          }
        });
        buf += "[";
        for (let i = 0; i < sortedConfigs.length; i++) {
          if (i > 0) {
            buf += ", ";
          }
          buf += sortedConfigs[i].toString(void 0, true, showContext);
        }
        buf += "]";
        if (this._hasSemanticContext) {
          buf += ",hasSemanticContext=" + this._hasSemanticContext;
        }
        if (this._uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          buf += ",uniqueAlt=" + this._uniqueAlt;
        }
        if (this._conflictInfo != null) {
          buf += ",conflictingAlts=" + this._conflictInfo.conflictedAlts;
          if (!this._conflictInfo.isExact) {
            buf += "*";
          }
        }
        if (this._dipsIntoOuterContext) {
          buf += ",dipsIntoOuterContext";
        }
        return buf.toString();
      }
      get uniqueAlt() {
        return this._uniqueAlt;
      }
      get hasSemanticContext() {
        return this._hasSemanticContext;
      }
      set hasSemanticContext(value2) {
        this.ensureWritable();
        this._hasSemanticContext = value2;
      }
      get conflictInfo() {
        return this._conflictInfo;
      }
      set conflictInfo(conflictInfo) {
        this.ensureWritable();
        this._conflictInfo = conflictInfo;
      }
      get conflictingAlts() {
        if (this._conflictInfo == null) {
          return void 0;
        }
        return this._conflictInfo.conflictedAlts;
      }
      get isExactConflict() {
        if (this._conflictInfo == null) {
          return false;
        }
        return this._conflictInfo.isExact;
      }
      get dipsIntoOuterContext() {
        return this._dipsIntoOuterContext;
      }
      get(index2) {
        return this.configs[index2];
      }
      ensureWritable() {
        if (this.isReadOnly) {
          throw new Error("This ATNConfigSet is read only.");
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNConfigSet.prototype, "getRepresentedAlternatives", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "contains", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, Symbol.iterator, null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "toArray", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "containsAll", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "clear", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "hashCode", null);
    exports.ATNConfigSet = ATNConfigSet;
  }
});

// node_modules/antlr4ts/dfa/DFAState.js
var require_DFAState = __commonJS({
  "node_modules/antlr4ts/dfa/DFAState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DFAState = void 0;
    var ATN_1 = require_ATN();
    var BitSet_1 = require_BitSet();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var assert = require("assert");
    var DFAState = class {
      constructor(configs) {
        this.stateNumber = -1;
        this.configs = configs;
        this.edges = /* @__PURE__ */ new Map();
        this.contextEdges = /* @__PURE__ */ new Map();
      }
      get isContextSensitive() {
        return !!this.contextSymbols;
      }
      isContextSymbol(symbol) {
        if (!this.isContextSensitive) {
          return false;
        }
        return this.contextSymbols.get(symbol);
      }
      setContextSymbol(symbol) {
        assert(this.isContextSensitive);
        this.contextSymbols.set(symbol);
      }
      setContextSensitive(atn) {
        assert(!this.configs.isOutermostConfigSet);
        if (this.isContextSensitive) {
          return;
        }
        if (!this.contextSymbols) {
          this.contextSymbols = new BitSet_1.BitSet();
        }
      }
      get acceptStateInfo() {
        return this._acceptStateInfo;
      }
      set acceptStateInfo(acceptStateInfo) {
        this._acceptStateInfo = acceptStateInfo;
      }
      get isAcceptState() {
        return !!this._acceptStateInfo;
      }
      get prediction() {
        if (!this._acceptStateInfo) {
          return ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        return this._acceptStateInfo.prediction;
      }
      get lexerActionExecutor() {
        if (!this._acceptStateInfo) {
          return void 0;
        }
        return this._acceptStateInfo.lexerActionExecutor;
      }
      getTarget(symbol) {
        return this.edges.get(symbol);
      }
      setTarget(symbol, target) {
        this.edges.set(symbol, target);
      }
      getEdgeMap() {
        return this.edges;
      }
      getContextTarget(invokingState) {
        if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          invokingState = -1;
        }
        return this.contextEdges.get(invokingState);
      }
      setContextTarget(invokingState, target) {
        if (!this.isContextSensitive) {
          throw new Error("The state is not context sensitive.");
        }
        if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          invokingState = -1;
        }
        this.contextEdges.set(invokingState, target);
      }
      getContextEdgeMap() {
        let map = new Map(this.contextEdges);
        let existing = map.get(-1);
        if (existing !== void 0) {
          if (map.size === 1) {
            let result = /* @__PURE__ */ new Map();
            result.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
            return result;
          } else {
            map.delete(-1);
            map.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
          }
        }
        return map;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize(7);
        hash = MurmurHash_1.MurmurHash.update(hash, this.configs.hashCode());
        hash = MurmurHash_1.MurmurHash.finish(hash, 1);
        return hash;
      }
      equals(o) {
        if (this === o) {
          return true;
        }
        if (!(o instanceof DFAState)) {
          return false;
        }
        let other = o;
        let sameSet = this.configs.equals(other.configs);
        return sameSet;
      }
      toString() {
        let buf = "";
        buf += this.stateNumber + ":" + this.configs;
        if (this.isAcceptState) {
          buf += "=>";
          if (this.predicates) {
            buf += this.predicates;
          } else {
            buf += this.prediction;
          }
        }
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "configs", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "edges", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "contextEdges", void 0);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "toString", null);
    exports.DFAState = DFAState;
    (function(DFAState2) {
      let PredPrediction = class PredPrediction {
        constructor(pred, alt) {
          this.alt = alt;
          this.pred = pred;
        }
        toString() {
          return "(" + this.pred + ", " + this.alt + ")";
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], PredPrediction.prototype, "pred", void 0);
      __decorate([
        Decorators_1.Override
      ], PredPrediction.prototype, "toString", null);
      PredPrediction = __decorate([
        __param(0, Decorators_1.NotNull)
      ], PredPrediction);
      DFAState2.PredPrediction = PredPrediction;
    })(DFAState = exports.DFAState || (exports.DFAState = {}));
  }
});

// node_modules/antlr4ts/atn/ATNSimulator.js
var require_ATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNSimulator = void 0;
    var ATNConfigSet_1 = require_ATNConfigSet();
    var DFAState_1 = require_DFAState();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var ATNSimulator = class ATNSimulator2 {
      constructor(atn) {
        this.atn = atn;
      }
      static get ERROR() {
        if (!ATNSimulator2._ERROR) {
          ATNSimulator2._ERROR = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
          ATNSimulator2._ERROR.stateNumber = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
        }
        return ATNSimulator2._ERROR;
      }
      clearDFA() {
        this.atn.clearDFA();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNSimulator.prototype, "atn", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNSimulator, "ERROR", null);
    ATNSimulator = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNSimulator);
    exports.ATNSimulator = ATNSimulator;
    (function(ATNSimulator2) {
      const RULE_VARIANT_DELIMITER = "$";
      const RULE_LF_VARIANT_MARKER = "$lf$";
      const RULE_NOLF_VARIANT_MARKER = "$nolf$";
    })(ATNSimulator = exports.ATNSimulator || (exports.ATNSimulator = {}));
    exports.ATNSimulator = ATNSimulator;
  }
});

// node_modules/antlr4ts/ConsoleErrorListener.js
var require_ConsoleErrorListener = __commonJS({
  "node_modules/antlr4ts/ConsoleErrorListener.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConsoleErrorListener = void 0;
    var ConsoleErrorListener = class {
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        console.error(`line ${line}:${charPositionInLine} ${msg}`);
      }
    };
    exports.ConsoleErrorListener = ConsoleErrorListener;
    ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
  }
});

// node_modules/antlr4ts/ProxyErrorListener.js
var require_ProxyErrorListener = __commonJS({
  "node_modules/antlr4ts/ProxyErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyErrorListener = void 0;
    var Decorators_1 = require_Decorators();
    var ProxyErrorListener = class {
      constructor(delegates) {
        this.delegates = delegates;
        if (!delegates) {
          throw new Error("Invalid delegates");
        }
      }
      getDelegates() {
        return this.delegates;
      }
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        this.delegates.forEach((listener) => {
          if (listener.syntaxError) {
            listener.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e);
          }
        });
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull)
    ], ProxyErrorListener.prototype, "syntaxError", null);
    exports.ProxyErrorListener = ProxyErrorListener;
  }
});

// node_modules/antlr4ts/Recognizer.js
var require_Recognizer = __commonJS({
  "node_modules/antlr4ts/Recognizer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Recognizer = void 0;
    var ConsoleErrorListener_1 = require_ConsoleErrorListener();
    var ProxyErrorListener_1 = require_ProxyErrorListener();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var Utils3 = require_Utils();
    var Recognizer = class {
      constructor() {
        this._listeners = [ConsoleErrorListener_1.ConsoleErrorListener.INSTANCE];
        this._stateNumber = -1;
      }
      getTokenTypeMap() {
        let vocabulary = this.vocabulary;
        let result = Recognizer.tokenTypeMapCache.get(vocabulary);
        if (result == null) {
          let intermediateResult = /* @__PURE__ */ new Map();
          for (let i = 0; i <= this.atn.maxTokenType; i++) {
            let literalName = vocabulary.getLiteralName(i);
            if (literalName != null) {
              intermediateResult.set(literalName, i);
            }
            let symbolicName = vocabulary.getSymbolicName(i);
            if (symbolicName != null) {
              intermediateResult.set(symbolicName, i);
            }
          }
          intermediateResult.set("EOF", Token_1.Token.EOF);
          result = intermediateResult;
          Recognizer.tokenTypeMapCache.set(vocabulary, result);
        }
        return result;
      }
      getRuleIndexMap() {
        let ruleNames = this.ruleNames;
        if (ruleNames == null) {
          throw new Error("The current recognizer does not provide a list of rule names.");
        }
        let result = Recognizer.ruleIndexMapCache.get(ruleNames);
        if (result == null) {
          result = Utils3.toMap(ruleNames);
          Recognizer.ruleIndexMapCache.set(ruleNames, result);
        }
        return result;
      }
      getTokenType(tokenName) {
        let ttype = this.getTokenTypeMap().get(tokenName);
        if (ttype != null) {
          return ttype;
        }
        return Token_1.Token.INVALID_TYPE;
      }
      get serializedATN() {
        throw new Error("there is no serialized ATN");
      }
      get atn() {
        return this._interp.atn;
      }
      get interpreter() {
        return this._interp;
      }
      set interpreter(interpreter) {
        this._interp = interpreter;
      }
      get parseInfo() {
        return Promise.resolve(void 0);
      }
      getErrorHeader(e) {
        let token = e.getOffendingToken();
        if (!token) {
          return "";
        }
        let line = token.line;
        let charPositionInLine = token.charPositionInLine;
        return "line " + line + ":" + charPositionInLine;
      }
      addErrorListener(listener) {
        if (!listener) {
          throw new TypeError("listener must not be null");
        }
        this._listeners.push(listener);
      }
      removeErrorListener(listener) {
        let position2 = this._listeners.indexOf(listener);
        if (position2 !== -1) {
          this._listeners.splice(position2, 1);
        }
      }
      removeErrorListeners() {
        this._listeners.length = 0;
      }
      getErrorListeners() {
        return this._listeners.slice(0);
      }
      getErrorListenerDispatch() {
        return new ProxyErrorListener_1.ProxyErrorListener(this.getErrorListeners());
      }
      sempred(_localctx, ruleIndex, actionIndex) {
        return true;
      }
      precpred(localctx, precedence) {
        return true;
      }
      action(_localctx, ruleIndex, actionIndex) {
      }
      get state() {
        return this._stateNumber;
      }
      set state(atnState) {
        this._stateNumber = atnState;
      }
    };
    Recognizer.EOF = -1;
    Recognizer.tokenTypeMapCache = /* @__PURE__ */ new WeakMap();
    Recognizer.ruleIndexMapCache = /* @__PURE__ */ new WeakMap();
    __decorate([
      Decorators_1.SuppressWarnings("serial"),
      Decorators_1.NotNull
    ], Recognizer.prototype, "_listeners", void 0);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getTokenTypeMap", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getRuleIndexMap", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "serializedATN", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "atn", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "interpreter", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "getErrorHeader", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "addErrorListener", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "removeErrorListener", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getErrorListeners", null);
    exports.Recognizer = Recognizer;
  }
});

// node_modules/antlr4ts/VocabularyImpl.js
var require_VocabularyImpl = __commonJS({
  "node_modules/antlr4ts/VocabularyImpl.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VocabularyImpl = void 0;
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var VocabularyImpl3 = class {
      constructor(literalNames, symbolicNames, displayNames) {
        this.literalNames = literalNames;
        this.symbolicNames = symbolicNames;
        this.displayNames = displayNames;
        this._maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
      }
      get maxTokenType() {
        return this._maxTokenType;
      }
      getLiteralName(tokenType) {
        if (tokenType >= 0 && tokenType < this.literalNames.length) {
          return this.literalNames[tokenType];
        }
        return void 0;
      }
      getSymbolicName(tokenType) {
        if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
          return this.symbolicNames[tokenType];
        }
        if (tokenType === Token_1.Token.EOF) {
          return "EOF";
        }
        return void 0;
      }
      getDisplayName(tokenType) {
        if (tokenType >= 0 && tokenType < this.displayNames.length) {
          let displayName = this.displayNames[tokenType];
          if (displayName) {
            return displayName;
          }
        }
        let literalName = this.getLiteralName(tokenType);
        if (literalName) {
          return literalName;
        }
        let symbolicName = this.getSymbolicName(tokenType);
        if (symbolicName) {
          return symbolicName;
        }
        return String(tokenType);
      }
    };
    VocabularyImpl3.EMPTY_VOCABULARY = new VocabularyImpl3([], [], []);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "literalNames", void 0);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "symbolicNames", void 0);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "displayNames", void 0);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl3.prototype, "maxTokenType", null);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl3.prototype, "getLiteralName", null);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl3.prototype, "getSymbolicName", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "getDisplayName", null);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3, "EMPTY_VOCABULARY", void 0);
    exports.VocabularyImpl = VocabularyImpl3;
  }
});

// node_modules/antlr4ts/dfa/DFASerializer.js
var require_DFASerializer = __commonJS({
  "node_modules/antlr4ts/dfa/DFASerializer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DFASerializer = void 0;
    var ATNSimulator_1 = require_ATNSimulator();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var Recognizer_1 = require_Recognizer();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var DFASerializer = class {
      constructor(dfa, vocabulary, ruleNames, atn) {
        if (vocabulary instanceof Recognizer_1.Recognizer) {
          ruleNames = vocabulary.ruleNames;
          atn = vocabulary.atn;
          vocabulary = vocabulary.vocabulary;
        } else if (!vocabulary) {
          vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        }
        this.dfa = dfa;
        this.vocabulary = vocabulary;
        this.ruleNames = ruleNames;
        this.atn = atn;
      }
      toString() {
        if (!this.dfa.s0) {
          return "";
        }
        let buf = "";
        if (this.dfa.states) {
          let states = new Array(...this.dfa.states.toArray());
          states.sort((o1, o2) => o1.stateNumber - o2.stateNumber);
          for (let s of states) {
            let edges = s.getEdgeMap();
            let edgeKeys = [...edges.keys()].sort((a, b) => a - b);
            let contextEdges = s.getContextEdgeMap();
            let contextEdgeKeys = [...contextEdges.keys()].sort((a, b) => a - b);
            for (let entry of edgeKeys) {
              let value2 = edges.get(entry);
              if ((value2 == null || value2 === ATNSimulator_1.ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {
                continue;
              }
              let contextSymbol = false;
              buf += this.getStateString(s) + "-" + this.getEdgeLabel(entry) + "->";
              if (s.isContextSymbol(entry)) {
                buf += "!";
                contextSymbol = true;
              }
              let t = value2;
              if (t && t.stateNumber !== ATNSimulator_1.ATNSimulator.ERROR.stateNumber) {
                buf += this.getStateString(t) + "\n";
              } else if (contextSymbol) {
                buf += "ctx\n";
              }
            }
            if (s.isContextSensitive) {
              for (let entry of contextEdgeKeys) {
                buf += this.getStateString(s) + "-" + this.getContextLabel(entry) + "->" + this.getStateString(contextEdges.get(entry)) + "\n";
              }
            }
          }
        }
        let output = buf;
        if (output.length === 0) {
          return "";
        }
        return output;
      }
      getContextLabel(i) {
        if (i === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          return "ctx:EMPTY_FULL";
        } else if (i === PredictionContext_1.PredictionContext.EMPTY_LOCAL_STATE_KEY) {
          return "ctx:EMPTY_LOCAL";
        }
        if (this.atn && i > 0 && i <= this.atn.states.length) {
          let state = this.atn.states[i];
          let ruleIndex = state.ruleIndex;
          if (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {
            return "ctx:" + String(i) + "(" + this.ruleNames[ruleIndex] + ")";
          }
        }
        return "ctx:" + String(i);
      }
      getEdgeLabel(i) {
        return this.vocabulary.getDisplayName(i);
      }
      getStateString(s) {
        if (s === ATNSimulator_1.ATNSimulator.ERROR) {
          return "ERROR";
        }
        let n = s.stateNumber;
        let stateStr = "s" + n;
        if (s.isAcceptState) {
          if (s.predicates) {
            stateStr = ":s" + n + "=>" + s.predicates;
          } else {
            stateStr = ":s" + n + "=>" + s.prediction;
          }
        }
        if (s.isContextSensitive) {
          stateStr += "*";
          for (let config of s.configs) {
            if (config.reachesIntoOuterContext) {
              stateStr += "*";
              break;
            }
          }
        }
        return stateStr;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFASerializer.prototype, "dfa", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFASerializer.prototype, "vocabulary", void 0);
    __decorate([
      Decorators_1.Override
    ], DFASerializer.prototype, "toString", null);
    exports.DFASerializer = DFASerializer;
  }
});

// node_modules/antlr4ts/dfa/LexerDFASerializer.js
var require_LexerDFASerializer = __commonJS({
  "node_modules/antlr4ts/dfa/LexerDFASerializer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerDFASerializer = void 0;
    var DFASerializer_1 = require_DFASerializer();
    var Decorators_1 = require_Decorators();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var LexerDFASerializer = class LexerDFASerializer extends DFASerializer_1.DFASerializer {
      constructor(dfa) {
        super(dfa, VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY);
      }
      getEdgeLabel(i) {
        return "'" + String.fromCodePoint(i) + "'";
      }
    };
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], LexerDFASerializer.prototype, "getEdgeLabel", null);
    LexerDFASerializer = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerDFASerializer);
    exports.LexerDFASerializer = LexerDFASerializer;
  }
});

// node_modules/antlr4ts/atn/StarLoopEntryState.js
var require_StarLoopEntryState = __commonJS({
  "node_modules/antlr4ts/atn/StarLoopEntryState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarLoopEntryState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BitSet_1 = require_BitSet();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var StarLoopEntryState = class extends DecisionState_1.DecisionState {
      constructor() {
        super(...arguments);
        this.precedenceRuleDecision = false;
        this.precedenceLoopbackStates = new BitSet_1.BitSet();
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarLoopEntryState.prototype, "stateType", null);
    exports.StarLoopEntryState = StarLoopEntryState;
  }
});

// node_modules/antlr4ts/dfa/DFA.js
var require_DFA = __commonJS({
  "node_modules/antlr4ts/dfa/DFA.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DFA = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var DFASerializer_1 = require_DFASerializer();
    var DFAState_1 = require_DFAState();
    var LexerDFASerializer_1 = require_LexerDFASerializer();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var DFA = class DFA {
      constructor(atnStartState, decision = 0) {
        this.states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.nextStateNumber = 0;
        if (!atnStartState.atn) {
          throw new Error("The ATNState must be associated with an ATN");
        }
        this.atnStartState = atnStartState;
        this.atn = atnStartState.atn;
        this.decision = decision;
        let isPrecedenceDfa = false;
        if (atnStartState instanceof StarLoopEntryState_1.StarLoopEntryState) {
          if (atnStartState.precedenceRuleDecision) {
            isPrecedenceDfa = true;
            this.s0 = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
            this.s0full = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
          }
        }
        this.precedenceDfa = isPrecedenceDfa;
      }
      get isPrecedenceDfa() {
        return this.precedenceDfa;
      }
      getPrecedenceStartState(precedence, fullContext) {
        if (!this.isPrecedenceDfa) {
          throw new Error("Only precedence DFAs may contain a precedence start state.");
        }
        if (fullContext) {
          return this.s0full.getTarget(precedence);
        } else {
          return this.s0.getTarget(precedence);
        }
      }
      setPrecedenceStartState(precedence, fullContext, startState) {
        if (!this.isPrecedenceDfa) {
          throw new Error("Only precedence DFAs may contain a precedence start state.");
        }
        if (precedence < 0) {
          return;
        }
        if (fullContext) {
          this.s0full.setTarget(precedence, startState);
        } else {
          this.s0.setTarget(precedence, startState);
        }
      }
      get isEmpty() {
        if (this.isPrecedenceDfa) {
          return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0;
        }
        return this.s0 == null && this.s0full == null;
      }
      get isContextSensitive() {
        if (this.isPrecedenceDfa) {
          return this.s0full.getEdgeMap().size > 0;
        }
        return this.s0full != null;
      }
      addState(state) {
        state.stateNumber = this.nextStateNumber++;
        return this.states.getOrAdd(state);
      }
      toString(vocabulary, ruleNames) {
        if (!vocabulary) {
          vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        }
        if (!this.s0) {
          return "";
        }
        let serializer;
        if (ruleNames) {
          serializer = new DFASerializer_1.DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);
        } else {
          serializer = new DFASerializer_1.DFASerializer(this, vocabulary);
        }
        return serializer.toString();
      }
      toLexerString() {
        if (!this.s0) {
          return "";
        }
        let serializer = new LexerDFASerializer_1.LexerDFASerializer(this);
        return serializer.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "states", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "atnStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "atn", void 0);
    DFA = __decorate([
      __param(0, Decorators_1.NotNull)
    ], DFA);
    exports.DFA = DFA;
  }
});

// node_modules/antlr4ts/atn/BasicState.js
var require_BasicState = __commonJS({
  "node_modules/antlr4ts/atn/BasicState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var BasicState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BASIC;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BasicState.prototype, "stateType", null);
    exports.BasicState = BasicState;
  }
});

// node_modules/antlr4ts/atn/InvalidState.js
var require_InvalidState = __commonJS({
  "node_modules/antlr4ts/atn/InvalidState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BasicState_1 = require_BasicState();
    var Decorators_1 = require_Decorators();
    var InvalidState = class extends BasicState_1.BasicState {
      get stateType() {
        return ATNStateType_1.ATNStateType.INVALID_TYPE;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InvalidState.prototype, "stateType", null);
    exports.InvalidState = InvalidState;
  }
});

// node_modules/antlr4ts/atn/SetTransition.js
var require_SetTransition = __commonJS({
  "node_modules/antlr4ts/atn/SetTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var Transition_1 = require_Transition();
    var SetTransition = class SetTransition extends Transition_1.Transition {
      constructor(target, set) {
        super(target);
        if (set == null) {
          set = IntervalSet_1.IntervalSet.of(Token_1.Token.INVALID_TYPE);
        }
        this.set = set;
      }
      get serializationType() {
        return 7;
      }
      get label() {
        return this.set;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this.set.contains(symbol);
      }
      toString() {
        return this.set.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SetTransition.prototype, "set", void 0);
    __decorate([
      Decorators_1.Override
    ], SetTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], SetTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], SetTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], SetTransition.prototype, "toString", null);
    SetTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.Nullable)
    ], SetTransition);
    exports.SetTransition = SetTransition;
  }
});

// node_modules/antlr4ts/atn/NotSetTransition.js
var require_NotSetTransition = __commonJS({
  "node_modules/antlr4ts/atn/NotSetTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotSetTransition = void 0;
    var Decorators_1 = require_Decorators();
    var SetTransition_1 = require_SetTransition();
    var NotSetTransition = class NotSetTransition extends SetTransition_1.SetTransition {
      constructor(target, set) {
        super(target, set);
      }
      get serializationType() {
        return 8;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
      }
      toString() {
        return "~" + super.toString();
      }
    };
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "toString", null);
    NotSetTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.Nullable)
    ], NotSetTransition);
    exports.NotSetTransition = NotSetTransition;
  }
});

// node_modules/antlr4ts/atn/RuleStopState.js
var require_RuleStopState = __commonJS({
  "node_modules/antlr4ts/atn/RuleStopState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleStopState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var RuleStopState = class extends ATNState_1.ATNState {
      get nonStopStateNumber() {
        return -1;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.RULE_STOP;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleStopState.prototype, "nonStopStateNumber", null);
    __decorate([
      Decorators_1.Override
    ], RuleStopState.prototype, "stateType", null);
    exports.RuleStopState = RuleStopState;
  }
});

// node_modules/antlr4ts/atn/RuleTransition.js
var require_RuleTransition = __commonJS({
  "node_modules/antlr4ts/atn/RuleTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var RuleTransition = class RuleTransition extends Transition_1.Transition {
      constructor(ruleStart, ruleIndex, precedence, followState) {
        super(ruleStart);
        this.tailCall = false;
        this.optimizedTailCall = false;
        this.ruleIndex = ruleIndex;
        this.precedence = precedence;
        this.followState = followState;
      }
      get serializationType() {
        return 3;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], RuleTransition.prototype, "followState", void 0);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "matches", null);
    RuleTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], RuleTransition);
    exports.RuleTransition = RuleTransition;
  }
});

// node_modules/antlr4ts/atn/WildcardTransition.js
var require_WildcardTransition = __commonJS({
  "node_modules/antlr4ts/atn/WildcardTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WildcardTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var WildcardTransition = class WildcardTransition extends Transition_1.Transition {
      constructor(target) {
        super(target);
      }
      get serializationType() {
        return 9;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
      }
      toString() {
        return ".";
      }
    };
    __decorate([
      Decorators_1.Override
    ], WildcardTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], WildcardTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], WildcardTransition.prototype, "toString", null);
    WildcardTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], WildcardTransition);
    exports.WildcardTransition = WildcardTransition;
  }
});

// node_modules/antlr4ts/atn/LL1Analyzer.js
var require_LL1Analyzer = __commonJS({
  "node_modules/antlr4ts/atn/LL1Analyzer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LL1Analyzer = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATNConfig_1 = require_ATNConfig();
    var BitSet_1 = require_BitSet();
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var Token_1 = require_Token();
    var WildcardTransition_1 = require_WildcardTransition();
    var LL1Analyzer = class LL1Analyzer2 {
      constructor(atn) {
        this.atn = atn;
      }
      getDecisionLookahead(s) {
        if (s == null) {
          return void 0;
        }
        let look = new Array(s.numberOfTransitions);
        for (let alt = 0; alt < s.numberOfTransitions; alt++) {
          let current = new IntervalSet_1.IntervalSet();
          look[alt] = current;
          let lookBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          let seeThruPreds = false;
          this._LOOK(s.transition(alt).target, void 0, PredictionContext_1.PredictionContext.EMPTY_LOCAL, current, lookBusy, new BitSet_1.BitSet(), seeThruPreds, false);
          if (current.size === 0 || current.contains(LL1Analyzer2.HIT_PRED)) {
            current = void 0;
            look[alt] = current;
          }
        }
        return look;
      }
      LOOK(s, ctx, stopState) {
        if (stopState === void 0) {
          if (s.atn == null) {
            throw new Error("Illegal state");
          }
          stopState = s.atn.ruleToStopState[s.ruleIndex];
        } else if (stopState === null) {
          stopState = void 0;
        }
        let r = new IntervalSet_1.IntervalSet();
        let seeThruPreds = true;
        let addEOF = true;
        this._LOOK(s, stopState, ctx, r, new Array2DHashSet_1.Array2DHashSet(), new BitSet_1.BitSet(), seeThruPreds, addEOF);
        return r;
      }
      _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
        let c = ATNConfig_1.ATNConfig.create(s, 0, ctx);
        if (!lookBusy.add(c)) {
          return;
        }
        if (s === stopState) {
          if (PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
            look.add(Token_1.Token.EPSILON);
            return;
          } else if (ctx.isEmpty) {
            if (addEOF) {
              look.add(Token_1.Token.EOF);
            }
            return;
          }
        }
        if (s instanceof RuleStopState_1.RuleStopState) {
          if (ctx.isEmpty && !PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
            if (addEOF) {
              look.add(Token_1.Token.EOF);
            }
            return;
          }
          let removed = calledRuleStack.get(s.ruleIndex);
          try {
            calledRuleStack.clear(s.ruleIndex);
            for (let i = 0; i < ctx.size; i++) {
              if (ctx.getReturnState(i) === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                continue;
              }
              let returnState = this.atn.states[ctx.getReturnState(i)];
              this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            }
          } finally {
            if (removed) {
              calledRuleStack.set(s.ruleIndex);
            }
          }
        }
        let n = s.numberOfTransitions;
        for (let i = 0; i < n; i++) {
          let t = s.transition(i);
          if (t instanceof RuleTransition_1.RuleTransition) {
            if (calledRuleStack.get(t.ruleIndex)) {
              continue;
            }
            let newContext = ctx.getChild(t.followState.stateNumber);
            try {
              calledRuleStack.set(t.ruleIndex);
              this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } finally {
              calledRuleStack.clear(t.ruleIndex);
            }
          } else if (t instanceof AbstractPredicateTransition_1.AbstractPredicateTransition) {
            if (seeThruPreds) {
              this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else {
              look.add(LL1Analyzer2.HIT_PRED);
            }
          } else if (t.isEpsilon) {
            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } else if (t instanceof WildcardTransition_1.WildcardTransition) {
            look.addAll(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
          } else {
            let set = t.label;
            if (set != null) {
              if (t instanceof NotSetTransition_1.NotSetTransition) {
                set = set.complement(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
              }
              look.addAll(set);
            }
          }
        }
      }
    };
    LL1Analyzer.HIT_PRED = Token_1.Token.INVALID_TYPE;
    __decorate([
      Decorators_1.NotNull
    ], LL1Analyzer.prototype, "atn", void 0);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LL1Analyzer.prototype, "LOOK", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], LL1Analyzer.prototype, "_LOOK", null);
    LL1Analyzer = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LL1Analyzer);
    exports.LL1Analyzer = LL1Analyzer;
  }
});

// node_modules/antlr4ts/atn/ATN.js
var require_ATN = __commonJS({
  "node_modules/antlr4ts/atn/ATN.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATN = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var DFA_1 = require_DFA();
    var IntervalSet_1 = require_IntervalSet();
    var InvalidState_1 = require_InvalidState();
    var LL1Analyzer_1 = require_LL1Analyzer();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var Token_1 = require_Token();
    var assert = require("assert");
    var ATN2 = class ATN {
      constructor(grammarType, maxTokenType) {
        this.states = [];
        this.decisionToState = [];
        this.modeNameToStartState = /* @__PURE__ */ new Map();
        this.modeToStartState = [];
        this.contextCache = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.decisionToDFA = [];
        this.modeToDFA = [];
        this.LL1Table = /* @__PURE__ */ new Map();
        this.grammarType = grammarType;
        this.maxTokenType = maxTokenType;
      }
      clearDFA() {
        this.decisionToDFA = new Array(this.decisionToState.length);
        for (let i = 0; i < this.decisionToDFA.length; i++) {
          this.decisionToDFA[i] = new DFA_1.DFA(this.decisionToState[i], i);
        }
        this.modeToDFA = new Array(this.modeToStartState.length);
        for (let i = 0; i < this.modeToDFA.length; i++) {
          this.modeToDFA[i] = new DFA_1.DFA(this.modeToStartState[i]);
        }
        this.contextCache.clear();
        this.LL1Table.clear();
      }
      get contextCacheSize() {
        return this.contextCache.size;
      }
      getCachedContext(context) {
        return PredictionContext_1.PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext_1.PredictionContext.IdentityHashMap());
      }
      getDecisionToDFA() {
        assert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);
        return this.decisionToDFA;
      }
      nextTokens(s, ctx) {
        if (ctx) {
          let anal = new LL1Analyzer_1.LL1Analyzer(this);
          let next = anal.LOOK(s, ctx);
          return next;
        } else {
          if (s.nextTokenWithinRule) {
            return s.nextTokenWithinRule;
          }
          s.nextTokenWithinRule = this.nextTokens(s, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
          s.nextTokenWithinRule.setReadonly(true);
          return s.nextTokenWithinRule;
        }
      }
      addState(state) {
        state.atn = this;
        state.stateNumber = this.states.length;
        this.states.push(state);
      }
      removeState(state) {
        let invalidState = new InvalidState_1.InvalidState();
        invalidState.atn = this;
        invalidState.stateNumber = state.stateNumber;
        this.states[state.stateNumber] = invalidState;
      }
      defineMode(name, s) {
        this.modeNameToStartState.set(name, s);
        this.modeToStartState.push(s);
        this.modeToDFA.push(new DFA_1.DFA(s));
        this.defineDecisionState(s);
      }
      defineDecisionState(s) {
        this.decisionToState.push(s);
        s.decision = this.decisionToState.length - 1;
        this.decisionToDFA.push(new DFA_1.DFA(s, s.decision));
        return s.decision;
      }
      getDecisionState(decision) {
        if (this.decisionToState.length > 0) {
          return this.decisionToState[decision];
        }
        return void 0;
      }
      get numberOfDecisions() {
        return this.decisionToState.length;
      }
      getExpectedTokens(stateNumber, context) {
        if (stateNumber < 0 || stateNumber >= this.states.length) {
          throw new RangeError("Invalid state number.");
        }
        let ctx = context;
        let s = this.states[stateNumber];
        let following = this.nextTokens(s);
        if (!following.contains(Token_1.Token.EPSILON)) {
          return following;
        }
        let expected = new IntervalSet_1.IntervalSet();
        expected.addAll(following);
        expected.remove(Token_1.Token.EPSILON);
        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
          let invokingState = this.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          following = this.nextTokens(rt.followState);
          expected.addAll(following);
          expected.remove(Token_1.Token.EPSILON);
          ctx = ctx._parent;
        }
        if (following.contains(Token_1.Token.EPSILON)) {
          expected.add(Token_1.Token.EOF);
        }
        return expected;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "states", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "decisionToState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "modeNameToStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "modeToStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "decisionToDFA", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "modeToDFA", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "nextTokens", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN2.prototype, "removeState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ATN2.prototype, "defineMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN2.prototype, "defineDecisionState", null);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "getExpectedTokens", null);
    ATN2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN2);
    exports.ATN = ATN2;
    (function(ATN3) {
      ATN3.INVALID_ALT_NUMBER = 0;
    })(ATN2 = exports.ATN || (exports.ATN = {}));
    exports.ATN = ATN2;
  }
});

// node_modules/antlr4ts/atn/LexerIndexedCustomAction.js
var require_LexerIndexedCustomAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerIndexedCustomAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerIndexedCustomAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerIndexedCustomAction = class LexerIndexedCustomAction2 {
      constructor(offset, action) {
        this._offset = offset;
        this._action = action;
      }
      get offset() {
        return this._offset;
      }
      get action() {
        return this._action;
      }
      get actionType() {
        return this._action.actionType;
      }
      get isPositionDependent() {
        return true;
      }
      execute(lexer) {
        this._action.execute(lexer);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this._offset);
        hash = MurmurHash_1.MurmurHash.update(hash, this._action);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerIndexedCustomAction2)) {
          return false;
        }
        return this._offset === obj._offset && this._action.equals(obj._action);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerIndexedCustomAction.prototype, "action", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "equals", null);
    LexerIndexedCustomAction = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerIndexedCustomAction);
    exports.LexerIndexedCustomAction = LexerIndexedCustomAction;
  }
});

// node_modules/antlr4ts/atn/LexerActionExecutor.js
var require_LexerActionExecutor = __commonJS({
  "node_modules/antlr4ts/atn/LexerActionExecutor.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerActionExecutor = void 0;
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var LexerIndexedCustomAction_1 = require_LexerIndexedCustomAction();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerActionExecutor = class LexerActionExecutor2 {
      constructor(lexerActions) {
        this._lexerActions = lexerActions;
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let lexerAction of lexerActions) {
          hash = MurmurHash_1.MurmurHash.update(hash, lexerAction);
        }
        this.cachedHashCode = MurmurHash_1.MurmurHash.finish(hash, lexerActions.length);
      }
      static append(lexerActionExecutor, lexerAction) {
        if (!lexerActionExecutor) {
          return new LexerActionExecutor2([lexerAction]);
        }
        let lexerActions = lexerActionExecutor._lexerActions.slice(0);
        lexerActions.push(lexerAction);
        return new LexerActionExecutor2(lexerActions);
      }
      fixOffsetBeforeMatch(offset) {
        let updatedLexerActions;
        for (let i = 0; i < this._lexerActions.length; i++) {
          if (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction)) {
            if (!updatedLexerActions) {
              updatedLexerActions = this._lexerActions.slice(0);
            }
            updatedLexerActions[i] = new LexerIndexedCustomAction_1.LexerIndexedCustomAction(offset, this._lexerActions[i]);
          }
        }
        if (!updatedLexerActions) {
          return this;
        }
        return new LexerActionExecutor2(updatedLexerActions);
      }
      get lexerActions() {
        return this._lexerActions;
      }
      execute(lexer, input, startIndex) {
        let requiresSeek = false;
        let stopIndex = input.index;
        try {
          for (let lexerAction of this._lexerActions) {
            if (lexerAction instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction) {
              let offset = lexerAction.offset;
              input.seek(startIndex + offset);
              lexerAction = lexerAction.action;
              requiresSeek = startIndex + offset !== stopIndex;
            } else if (lexerAction.isPositionDependent) {
              input.seek(stopIndex);
              requiresSeek = false;
            }
            lexerAction.execute(lexer);
          }
        } finally {
          if (requiresSeek) {
            input.seek(stopIndex);
          }
        }
      }
      hashCode() {
        return this.cachedHashCode;
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerActionExecutor2)) {
          return false;
        }
        return this.cachedHashCode === obj.cachedHashCode && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerActionExecutor.prototype, "_lexerActions", void 0);
    __decorate([
      Decorators_1.NotNull
    ], LexerActionExecutor.prototype, "lexerActions", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerActionExecutor.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerActionExecutor.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerActionExecutor.prototype, "equals", null);
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], LexerActionExecutor, "append", null);
    LexerActionExecutor = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerActionExecutor);
    exports.LexerActionExecutor = LexerActionExecutor;
  }
});

// node_modules/antlr4ts/LexerNoViableAltException.js
var require_LexerNoViableAltException = __commonJS({
  "node_modules/antlr4ts/LexerNoViableAltException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerNoViableAltException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var Interval_1 = require_Interval();
    var Utils3 = require_Utils();
    var LexerNoViableAltException = class LexerNoViableAltException extends RecognitionException_1.RecognitionException {
      constructor(lexer, input, startIndex, deadEndConfigs) {
        super(lexer, input);
        this._startIndex = startIndex;
        this._deadEndConfigs = deadEndConfigs;
      }
      get startIndex() {
        return this._startIndex;
      }
      get deadEndConfigs() {
        return this._deadEndConfigs;
      }
      get inputStream() {
        return super.inputStream;
      }
      toString() {
        let symbol = "";
        if (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {
          symbol = this.inputStream.getText(Interval_1.Interval.of(this._startIndex, this._startIndex));
          symbol = Utils3.escapeWhitespace(symbol, false);
        }
        return `LexerNoViableAltException('${symbol}')`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerNoViableAltException.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], LexerNoViableAltException.prototype, "toString", null);
    LexerNoViableAltException = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerNoViableAltException);
    exports.LexerNoViableAltException = LexerNoViableAltException;
  }
});

// node_modules/antlr4ts/atn/OrderedATNConfigSet.js
var require_OrderedATNConfigSet = __commonJS({
  "node_modules/antlr4ts/atn/OrderedATNConfigSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OrderedATNConfigSet = void 0;
    var ATNConfigSet_1 = require_ATNConfigSet();
    var Decorators_1 = require_Decorators();
    var OrderedATNConfigSet = class extends ATNConfigSet_1.ATNConfigSet {
      constructor(set, readonly) {
        if (set != null && readonly != null) {
          super(set, readonly);
        } else {
          super();
        }
      }
      clone(readonly) {
        let copy = new OrderedATNConfigSet(this, readonly);
        if (!readonly && this.isReadOnly) {
          copy.addAll(this);
        }
        return copy;
      }
      getKey(e) {
        return { state: 0, alt: e.hashCode() };
      }
      canMerge(left, leftKey, right) {
        return left.equals(right);
      }
    };
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "clone", null);
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "getKey", null);
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "canMerge", null);
    exports.OrderedATNConfigSet = OrderedATNConfigSet;
  }
});

// node_modules/antlr4ts/atn/LexerATNSimulator.js
var require_LexerATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/LexerATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerATNSimulator = void 0;
    var AcceptStateInfo_1 = require_AcceptStateInfo();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var ATNSimulator_1 = require_ATNSimulator();
    var DFAState_1 = require_DFAState();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var Lexer_1 = require_Lexer();
    var LexerActionExecutor_1 = require_LexerActionExecutor();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var Decorators_1 = require_Decorators();
    var OrderedATNConfigSet_1 = require_OrderedATNConfigSet();
    var PredictionContext_1 = require_PredictionContext();
    var RuleStopState_1 = require_RuleStopState();
    var Token_1 = require_Token();
    var assert = require("assert");
    var LexerATNSimulator2 = class LexerATNSimulator3 extends ATNSimulator_1.ATNSimulator {
      constructor(atn, recog) {
        super(atn);
        this.optimize_tail_calls = true;
        this.startIndex = -1;
        this._line = 1;
        this._charPositionInLine = 0;
        this.mode = Lexer_1.Lexer.DEFAULT_MODE;
        this.prevAccept = new LexerATNSimulator3.SimState();
        this.recog = recog;
      }
      copyState(simulator) {
        this._charPositionInLine = simulator.charPositionInLine;
        this._line = simulator._line;
        this.mode = simulator.mode;
        this.startIndex = simulator.startIndex;
      }
      match(input, mode) {
        this.mode = mode;
        let mark = input.mark();
        try {
          this.startIndex = input.index;
          this.prevAccept.reset();
          let s0 = this.atn.modeToDFA[mode].s0;
          if (s0 == null) {
            return this.matchATN(input);
          } else {
            return this.execATN(input, s0);
          }
        } finally {
          input.release(mark);
        }
      }
      reset() {
        this.prevAccept.reset();
        this.startIndex = -1;
        this._line = 1;
        this._charPositionInLine = 0;
        this.mode = Lexer_1.Lexer.DEFAULT_MODE;
      }
      matchATN(input) {
        let startState = this.atn.modeToStartState[this.mode];
        if (LexerATNSimulator3.debug) {
          console.log(`matchATN mode ${this.mode} start: ${startState}`);
        }
        let old_mode = this.mode;
        let s0_closure = this.computeStartState(input, startState);
        let suppressEdge = s0_closure.hasSemanticContext;
        if (suppressEdge) {
          s0_closure.hasSemanticContext = false;
        }
        let next = this.addDFAState(s0_closure);
        if (!suppressEdge) {
          let dfa = this.atn.modeToDFA[this.mode];
          if (!dfa.s0) {
            dfa.s0 = next;
          } else {
            next = dfa.s0;
          }
        }
        let predict = this.execATN(input, next);
        if (LexerATNSimulator3.debug) {
          console.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);
        }
        return predict;
      }
      execATN(input, ds0) {
        if (LexerATNSimulator3.debug) {
          console.log(`start state closure=${ds0.configs}`);
        }
        if (ds0.isAcceptState) {
          this.captureSimState(this.prevAccept, input, ds0);
        }
        let t = input.LA(1);
        let s = ds0;
        while (true) {
          if (LexerATNSimulator3.debug) {
            console.log(`execATN loop starting closure: ${s.configs}`);
          }
          let target = this.getExistingTargetState(s, t);
          if (target == null) {
            target = this.computeTargetState(input, s, t);
          }
          if (target === ATNSimulator_1.ATNSimulator.ERROR) {
            break;
          }
          if (t !== IntStream_1.IntStream.EOF) {
            this.consume(input);
          }
          if (target.isAcceptState) {
            this.captureSimState(this.prevAccept, input, target);
            if (t === IntStream_1.IntStream.EOF) {
              break;
            }
          }
          t = input.LA(1);
          s = target;
        }
        return this.failOrAccept(this.prevAccept, input, s.configs, t);
      }
      getExistingTargetState(s, t) {
        let target = s.getTarget(t);
        if (LexerATNSimulator3.debug && target != null) {
          console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
        }
        return target;
      }
      computeTargetState(input, s, t) {
        let reach = new OrderedATNConfigSet_1.OrderedATNConfigSet();
        this.getReachableConfigSet(input, s.configs, reach, t);
        if (reach.isEmpty) {
          if (!reach.hasSemanticContext) {
            this.addDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
          }
          return ATNSimulator_1.ATNSimulator.ERROR;
        }
        return this.addDFAEdge(s, t, reach);
      }
      failOrAccept(prevAccept, input, reach, t) {
        if (prevAccept.dfaState != null) {
          let lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
          this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.charPos);
          return prevAccept.dfaState.prediction;
        } else {
          if (t === IntStream_1.IntStream.EOF && input.index === this.startIndex) {
            return Token_1.Token.EOF;
          }
          throw new LexerNoViableAltException_1.LexerNoViableAltException(this.recog, input, this.startIndex, reach);
        }
      }
      getReachableConfigSet(input, closure, reach, t) {
        let skipAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        for (let c of closure) {
          let currentAltReachedAcceptState = c.alt === skipAlt;
          if (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {
            continue;
          }
          if (LexerATNSimulator3.debug) {
            console.log(`testing ${this.getTokenName(t)} at ${c.toString(this.recog, true)}`);
          }
          let n = c.state.numberOfOptimizedTransitions;
          for (let ti = 0; ti < n; ti++) {
            let trans = c.state.getOptimizedTransition(ti);
            let target = this.getReachableTarget(trans, t);
            if (target != null) {
              let lexerActionExecutor = c.lexerActionExecutor;
              let config;
              if (lexerActionExecutor != null) {
                lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
                config = c.transform(target, true, lexerActionExecutor);
              } else {
                assert(c.lexerActionExecutor == null);
                config = c.transform(target, true);
              }
              let treatEofAsEpsilon = t === IntStream_1.IntStream.EOF;
              if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
                skipAlt = c.alt;
                break;
              }
            }
          }
        }
      }
      accept(input, lexerActionExecutor, startIndex, index2, line, charPos) {
        if (LexerATNSimulator3.debug) {
          console.log(`ACTION ${lexerActionExecutor}`);
        }
        input.seek(index2);
        this._line = line;
        this._charPositionInLine = charPos;
        if (lexerActionExecutor != null && this.recog != null) {
          lexerActionExecutor.execute(this.recog, input, startIndex);
        }
      }
      getReachableTarget(trans, t) {
        if (trans.matches(t, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
          return trans.target;
        }
        return void 0;
      }
      computeStartState(input, p) {
        let initialContext = PredictionContext_1.PredictionContext.EMPTY_FULL;
        let configs = new OrderedATNConfigSet_1.OrderedATNConfigSet();
        for (let i = 0; i < p.numberOfTransitions; i++) {
          let target = p.transition(i).target;
          let c = ATNConfig_1.ATNConfig.create(target, i + 1, initialContext);
          this.closure(input, c, configs, false, false, false);
        }
        return configs;
      }
      closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
        if (LexerATNSimulator3.debug) {
          console.log("closure(" + config.toString(this.recog, true) + ")");
        }
        if (config.state instanceof RuleStopState_1.RuleStopState) {
          if (LexerATNSimulator3.debug) {
            if (this.recog != null) {
              console.log(`closure at ${this.recog.ruleNames[config.state.ruleIndex]} rule stop ${config}`);
            } else {
              console.log(`closure at rule stop ${config}`);
            }
          }
          let context = config.context;
          if (context.isEmpty) {
            configs.add(config);
            return true;
          } else if (context.hasEmpty) {
            configs.add(config.transform(config.state, true, PredictionContext_1.PredictionContext.EMPTY_FULL));
            currentAltReachedAcceptState = true;
          }
          for (let i = 0; i < context.size; i++) {
            let returnStateNumber = context.getReturnState(i);
            if (returnStateNumber === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              continue;
            }
            let newContext = context.getParent(i);
            let returnState = this.atn.states[returnStateNumber];
            let c = config.transform(returnState, false, newContext);
            currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
          }
          return currentAltReachedAcceptState;
        }
        if (!config.state.onlyHasEpsilonTransitions) {
          if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision) {
            configs.add(config);
          }
        }
        let p = config.state;
        for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
          let t = p.getOptimizedTransition(i);
          let c = this.getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon);
          if (c != null) {
            currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
          }
        }
        return currentAltReachedAcceptState;
      }
      getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon) {
        let c;
        switch (t.serializationType) {
          case 3:
            let ruleTransition = t;
            if (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config.context.hasEmpty) {
              c = config.transform(t.target, true);
            } else {
              let newContext = config.context.getChild(ruleTransition.followState.stateNumber);
              c = config.transform(t.target, true, newContext);
            }
            break;
          case 10:
            throw new Error("Precedence predicates are not supported in lexers.");
          case 4:
            let pt = t;
            if (LexerATNSimulator3.debug) {
              console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
            }
            configs.hasSemanticContext = true;
            if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
              c = config.transform(t.target, true);
            } else {
              c = void 0;
            }
            break;
          case 6:
            if (config.context.hasEmpty) {
              let lexerActionExecutor = LexerActionExecutor_1.LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[t.actionIndex]);
              c = config.transform(t.target, true, lexerActionExecutor);
              break;
            } else {
              c = config.transform(t.target, true);
              break;
            }
          case 1:
            c = config.transform(t.target, true);
            break;
          case 5:
          case 2:
          case 7:
            if (treatEofAsEpsilon) {
              if (t.matches(IntStream_1.IntStream.EOF, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
                c = config.transform(t.target, false);
                break;
              }
            }
            c = void 0;
            break;
          default:
            c = void 0;
            break;
        }
        return c;
      }
      evaluatePredicate(input, ruleIndex, predIndex, speculative) {
        if (this.recog == null) {
          return true;
        }
        if (!speculative) {
          return this.recog.sempred(void 0, ruleIndex, predIndex);
        }
        let savedCharPositionInLine = this._charPositionInLine;
        let savedLine = this._line;
        let index2 = input.index;
        let marker = input.mark();
        try {
          this.consume(input);
          return this.recog.sempred(void 0, ruleIndex, predIndex);
        } finally {
          this._charPositionInLine = savedCharPositionInLine;
          this._line = savedLine;
          input.seek(index2);
          input.release(marker);
        }
      }
      captureSimState(settings, input, dfaState) {
        settings.index = input.index;
        settings.line = this._line;
        settings.charPos = this._charPositionInLine;
        settings.dfaState = dfaState;
      }
      addDFAEdge(p, t, q) {
        if (q instanceof ATNConfigSet_1.ATNConfigSet) {
          let suppressEdge = q.hasSemanticContext;
          if (suppressEdge) {
            q.hasSemanticContext = false;
          }
          let to = this.addDFAState(q);
          if (suppressEdge) {
            return to;
          }
          this.addDFAEdge(p, t, to);
          return to;
        } else {
          if (LexerATNSimulator3.debug) {
            console.log("EDGE " + p + " -> " + q + " upon " + String.fromCharCode(t));
          }
          if (p != null) {
            p.setTarget(t, q);
          }
        }
      }
      addDFAState(configs) {
        assert(!configs.hasSemanticContext);
        let proposed = new DFAState_1.DFAState(configs);
        let existing = this.atn.modeToDFA[this.mode].states.get(proposed);
        if (existing != null) {
          return existing;
        }
        configs.optimizeConfigs(this);
        let newState = new DFAState_1.DFAState(configs.clone(true));
        let firstConfigWithRuleStopState;
        for (let c of configs) {
          if (c.state instanceof RuleStopState_1.RuleStopState) {
            firstConfigWithRuleStopState = c;
            break;
          }
        }
        if (firstConfigWithRuleStopState != null) {
          let prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
          let lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(prediction, lexerActionExecutor);
        }
        return this.atn.modeToDFA[this.mode].addState(newState);
      }
      getDFA(mode) {
        return this.atn.modeToDFA[mode];
      }
      getText(input) {
        return input.getText(Interval_1.Interval.of(this.startIndex, input.index - 1));
      }
      get line() {
        return this._line;
      }
      set line(line) {
        this._line = line;
      }
      get charPositionInLine() {
        return this._charPositionInLine;
      }
      set charPositionInLine(charPositionInLine) {
        this._charPositionInLine = charPositionInLine;
      }
      consume(input) {
        let curChar = input.LA(1);
        if (curChar === "\n".charCodeAt(0)) {
          this._line++;
          this._charPositionInLine = 0;
        } else {
          this._charPositionInLine++;
        }
        input.consume();
      }
      getTokenName(t) {
        if (t === -1) {
          return "EOF";
        }
        return "'" + String.fromCharCode(t) + "'";
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator2.prototype, "prevAccept", void 0);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "copyState", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "match", null);
    __decorate([
      Decorators_1.Override
    ], LexerATNSimulator2.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "matchATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "execATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "computeTargetState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getReachableConfigSet", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "accept", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "computeStartState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "closure", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getEpsilonTarget", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "evaluatePredicate", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "captureSimState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "addDFAState", null);
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator2.prototype, "getDFA", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getText", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "consume", null);
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator2.prototype, "getTokenName", null);
    LexerATNSimulator2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2);
    exports.LexerATNSimulator = LexerATNSimulator2;
    (function(LexerATNSimulator3) {
      LexerATNSimulator3.debug = false;
      LexerATNSimulator3.dfa_debug = false;
      class SimState {
        constructor() {
          this.index = -1;
          this.line = 0;
          this.charPos = -1;
        }
        reset() {
          this.index = -1;
          this.line = 0;
          this.charPos = -1;
          this.dfaState = void 0;
        }
      }
      LexerATNSimulator3.SimState = SimState;
    })(LexerATNSimulator2 = exports.LexerATNSimulator || (exports.LexerATNSimulator = {}));
    exports.LexerATNSimulator = LexerATNSimulator2;
  }
});

// node_modules/antlr4ts/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/antlr4ts/Lexer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lexer = void 0;
    var CommonTokenFactory_1 = require_CommonTokenFactory();
    var IntegerStack_1 = require_IntegerStack();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var Decorators_1 = require_Decorators();
    var Recognizer_1 = require_Recognizer();
    var Token_1 = require_Token();
    var Lexer2 = class extends Recognizer_1.Recognizer {
      constructor(input) {
        super();
        this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
        this._tokenStartCharIndex = -1;
        this._tokenStartLine = 0;
        this._tokenStartCharPositionInLine = 0;
        this._hitEOF = false;
        this._channel = 0;
        this._type = 0;
        this._modeStack = new IntegerStack_1.IntegerStack();
        this._mode = Lexer2.DEFAULT_MODE;
        this._input = input;
        this._tokenFactorySourcePair = { source: this, stream: input };
      }
      static get DEFAULT_TOKEN_CHANNEL() {
        return Token_1.Token.DEFAULT_CHANNEL;
      }
      static get HIDDEN() {
        return Token_1.Token.HIDDEN_CHANNEL;
      }
      reset(resetInput) {
        if (resetInput === void 0 || resetInput) {
          this._input.seek(0);
        }
        this._token = void 0;
        this._type = Token_1.Token.INVALID_TYPE;
        this._channel = Token_1.Token.DEFAULT_CHANNEL;
        this._tokenStartCharIndex = -1;
        this._tokenStartCharPositionInLine = -1;
        this._tokenStartLine = -1;
        this._text = void 0;
        this._hitEOF = false;
        this._mode = Lexer2.DEFAULT_MODE;
        this._modeStack.clear();
        this.interpreter.reset();
      }
      nextToken() {
        if (this._input == null) {
          throw new Error("nextToken requires a non-null input stream.");
        }
        let tokenStartMarker = this._input.mark();
        try {
          outer:
            while (true) {
              if (this._hitEOF) {
                return this.emitEOF();
              }
              this._token = void 0;
              this._channel = Token_1.Token.DEFAULT_CHANNEL;
              this._tokenStartCharIndex = this._input.index;
              this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;
              this._tokenStartLine = this.interpreter.line;
              this._text = void 0;
              do {
                this._type = Token_1.Token.INVALID_TYPE;
                let ttype;
                try {
                  ttype = this.interpreter.match(this._input, this._mode);
                } catch (e) {
                  if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
                    this.notifyListeners(e);
                    this.recover(e);
                    ttype = Lexer2.SKIP;
                  } else {
                    throw e;
                  }
                }
                if (this._input.LA(1) === IntStream_1.IntStream.EOF) {
                  this._hitEOF = true;
                }
                if (this._type === Token_1.Token.INVALID_TYPE) {
                  this._type = ttype;
                }
                if (this._type === Lexer2.SKIP) {
                  continue outer;
                }
              } while (this._type === Lexer2.MORE);
              if (this._token == null) {
                return this.emit();
              }
              return this._token;
            }
        } finally {
          this._input.release(tokenStartMarker);
        }
      }
      skip() {
        this._type = Lexer2.SKIP;
      }
      more() {
        this._type = Lexer2.MORE;
      }
      mode(m) {
        this._mode = m;
      }
      pushMode(m) {
        if (LexerATNSimulator_1.LexerATNSimulator.debug) {
          console.log("pushMode " + m);
        }
        this._modeStack.push(this._mode);
        this.mode(m);
      }
      popMode() {
        if (this._modeStack.isEmpty) {
          throw new Error("EmptyStackException");
        }
        if (LexerATNSimulator_1.LexerATNSimulator.debug) {
          console.log("popMode back to " + this._modeStack.peek());
        }
        this.mode(this._modeStack.pop());
        return this._mode;
      }
      get tokenFactory() {
        return this._factory;
      }
      set tokenFactory(factory) {
        this._factory = factory;
      }
      get inputStream() {
        return this._input;
      }
      set inputStream(input) {
        this.reset(false);
        this._input = input;
        this._tokenFactorySourcePair = { source: this, stream: this._input };
      }
      get sourceName() {
        return this._input.sourceName;
      }
      emit(token) {
        if (!token) {
          token = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine);
        }
        this._token = token;
        return token;
      }
      emitEOF() {
        let cpos = this.charPositionInLine;
        let line = this.line;
        let eof = this._factory.create(this._tokenFactorySourcePair, Token_1.Token.EOF, void 0, Token_1.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, line, cpos);
        this.emit(eof);
        return eof;
      }
      get line() {
        return this.interpreter.line;
      }
      set line(line) {
        this.interpreter.line = line;
      }
      get charPositionInLine() {
        return this.interpreter.charPositionInLine;
      }
      set charPositionInLine(charPositionInLine) {
        this.interpreter.charPositionInLine = charPositionInLine;
      }
      get charIndex() {
        return this._input.index;
      }
      get text() {
        if (this._text != null) {
          return this._text;
        }
        return this.interpreter.getText(this._input);
      }
      set text(text4) {
        this._text = text4;
      }
      get token() {
        return this._token;
      }
      set token(_token) {
        this._token = _token;
      }
      set type(ttype) {
        this._type = ttype;
      }
      get type() {
        return this._type;
      }
      set channel(channel) {
        this._channel = channel;
      }
      get channel() {
        return this._channel;
      }
      getAllTokens() {
        let tokens = [];
        let t = this.nextToken();
        while (t.type !== Token_1.Token.EOF) {
          tokens.push(t);
          t = this.nextToken();
        }
        return tokens;
      }
      notifyListeners(e) {
        let text4 = this._input.getText(Interval_1.Interval.of(this._tokenStartCharIndex, this._input.index));
        let msg = "token recognition error at: '" + this.getErrorDisplay(text4) + "'";
        let listener = this.getErrorListenerDispatch();
        if (listener.syntaxError) {
          listener.syntaxError(this, void 0, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);
        }
      }
      getErrorDisplay(s) {
        if (typeof s === "number") {
          switch (s) {
            case Token_1.Token.EOF:
              return "<EOF>";
            case 10:
              return "\\n";
            case 9:
              return "\\t";
            case 13:
              return "\\r";
          }
          return String.fromCharCode(s);
        }
        return s.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
      }
      getCharErrorDisplay(c) {
        let s = this.getErrorDisplay(c);
        return "'" + s + "'";
      }
      recover(re) {
        if (re instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
          if (this._input.LA(1) !== IntStream_1.IntStream.EOF) {
            this.interpreter.consume(this._input);
          }
        } else {
          this._input.consume();
        }
      }
    };
    Lexer2.DEFAULT_MODE = 0;
    Lexer2.MORE = -2;
    Lexer2.SKIP = -3;
    Lexer2.MIN_CHAR_VALUE = 0;
    Lexer2.MAX_CHAR_VALUE = 1114111;
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "nextToken", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "tokenFactory", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "charPositionInLine", null);
    exports.Lexer = Lexer2;
  }
});

// node_modules/antlr4ts/misc/IntervalSet.js
var require_IntervalSet = __commonJS({
  "node_modules/antlr4ts/misc/IntervalSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntervalSet = void 0;
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var IntegerList_1 = require_IntegerList();
    var Interval_1 = require_Interval();
    var Lexer_1 = require_Lexer();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var IntervalSet = class {
      constructor(intervals) {
        this.readonly = false;
        if (intervals != null) {
          this._intervals = intervals.slice(0);
        } else {
          this._intervals = [];
        }
      }
      static get COMPLETE_CHAR_SET() {
        if (IntervalSet._COMPLETE_CHAR_SET === void 0) {
          IntervalSet._COMPLETE_CHAR_SET = IntervalSet.of(Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE);
          IntervalSet._COMPLETE_CHAR_SET.setReadonly(true);
        }
        return IntervalSet._COMPLETE_CHAR_SET;
      }
      static get EMPTY_SET() {
        if (IntervalSet._EMPTY_SET == null) {
          IntervalSet._EMPTY_SET = new IntervalSet();
          IntervalSet._EMPTY_SET.setReadonly(true);
        }
        return IntervalSet._EMPTY_SET;
      }
      static of(a, b = a) {
        let s = new IntervalSet();
        s.add(a, b);
        return s;
      }
      clear() {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        this._intervals.length = 0;
      }
      add(a, b = a) {
        this.addRange(Interval_1.Interval.of(a, b));
      }
      addRange(addition) {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        if (addition.b < addition.a) {
          return;
        }
        for (let i = 0; i < this._intervals.length; i++) {
          let r = this._intervals[i];
          if (addition.equals(r)) {
            return;
          }
          if (addition.adjacent(r) || !addition.disjoint(r)) {
            let bigger = addition.union(r);
            this._intervals[i] = bigger;
            while (i < this._intervals.length - 1) {
              i++;
              let next = this._intervals[i];
              if (!bigger.adjacent(next) && bigger.disjoint(next)) {
                break;
              }
              this._intervals.splice(i, 1);
              i--;
              this._intervals[i] = bigger.union(next);
            }
            return;
          }
          if (addition.startsBeforeDisjoint(r)) {
            this._intervals.splice(i, 0, addition);
            return;
          }
        }
        this._intervals.push(addition);
      }
      static or(sets) {
        let r = new IntervalSet();
        for (let s of sets) {
          r.addAll(s);
        }
        return r;
      }
      addAll(set) {
        if (set == null) {
          return this;
        }
        if (set instanceof IntervalSet) {
          let other = set;
          let n = other._intervals.length;
          for (let i = 0; i < n; i++) {
            let I = other._intervals[i];
            this.add(I.a, I.b);
          }
        } else {
          for (let value2 of set.toArray()) {
            this.add(value2);
          }
        }
        return this;
      }
      complementRange(minElement, maxElement) {
        return this.complement(IntervalSet.of(minElement, maxElement));
      }
      complement(vocabulary) {
        if (vocabulary.isNil) {
          return IntervalSet.EMPTY_SET;
        }
        let vocabularyIS;
        if (vocabulary instanceof IntervalSet) {
          vocabularyIS = vocabulary;
        } else {
          vocabularyIS = new IntervalSet();
          vocabularyIS.addAll(vocabulary);
        }
        return vocabularyIS.subtract(this);
      }
      subtract(a) {
        if (a == null || a.isNil) {
          return new IntervalSet(this._intervals);
        }
        if (a instanceof IntervalSet) {
          return IntervalSet.subtract(this, a);
        }
        let other = new IntervalSet();
        other.addAll(a);
        return IntervalSet.subtract(this, other);
      }
      static subtract(left, right) {
        if (left.isNil) {
          return new IntervalSet();
        }
        let result = new IntervalSet(left._intervals);
        if (right.isNil) {
          return result;
        }
        let resultI = 0;
        let rightI = 0;
        while (resultI < result._intervals.length && rightI < right._intervals.length) {
          let resultInterval = result._intervals[resultI];
          let rightInterval = right._intervals[rightI];
          if (rightInterval.b < resultInterval.a) {
            rightI++;
            continue;
          }
          if (rightInterval.a > resultInterval.b) {
            resultI++;
            continue;
          }
          let beforeCurrent;
          let afterCurrent;
          if (rightInterval.a > resultInterval.a) {
            beforeCurrent = new Interval_1.Interval(resultInterval.a, rightInterval.a - 1);
          }
          if (rightInterval.b < resultInterval.b) {
            afterCurrent = new Interval_1.Interval(rightInterval.b + 1, resultInterval.b);
          }
          if (beforeCurrent) {
            if (afterCurrent) {
              result._intervals[resultI] = beforeCurrent;
              result._intervals.splice(resultI + 1, 0, afterCurrent);
              resultI++;
              rightI++;
              continue;
            } else {
              result._intervals[resultI] = beforeCurrent;
              resultI++;
              continue;
            }
          } else {
            if (afterCurrent) {
              result._intervals[resultI] = afterCurrent;
              rightI++;
              continue;
            } else {
              result._intervals.splice(resultI, 1);
              continue;
            }
          }
        }
        return result;
      }
      or(a) {
        let o = new IntervalSet();
        o.addAll(this);
        o.addAll(a);
        return o;
      }
      and(other) {
        if (other.isNil) {
          return new IntervalSet();
        }
        let myIntervals = this._intervals;
        let theirIntervals = other._intervals;
        let intersection;
        let mySize = myIntervals.length;
        let theirSize = theirIntervals.length;
        let i = 0;
        let j = 0;
        while (i < mySize && j < theirSize) {
          let mine = myIntervals[i];
          let theirs = theirIntervals[j];
          if (mine.startsBeforeDisjoint(theirs)) {
            i++;
          } else if (theirs.startsBeforeDisjoint(mine)) {
            j++;
          } else if (mine.properlyContains(theirs)) {
            if (!intersection) {
              intersection = new IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            j++;
          } else if (theirs.properlyContains(mine)) {
            if (!intersection) {
              intersection = new IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            i++;
          } else if (!mine.disjoint(theirs)) {
            if (!intersection) {
              intersection = new IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            if (mine.startsAfterNonDisjoint(theirs)) {
              j++;
            } else if (theirs.startsAfterNonDisjoint(mine)) {
              i++;
            }
          }
        }
        if (!intersection) {
          return new IntervalSet();
        }
        return intersection;
      }
      contains(el) {
        let n = this._intervals.length;
        let l = 0;
        let r = n - 1;
        while (l <= r) {
          let m = l + r >> 1;
          let I = this._intervals[m];
          let a = I.a;
          let b = I.b;
          if (b < el) {
            l = m + 1;
          } else if (a > el) {
            r = m - 1;
          } else {
            return true;
          }
        }
        return false;
      }
      get isNil() {
        return this._intervals == null || this._intervals.length === 0;
      }
      get maxElement() {
        if (this.isNil) {
          throw new RangeError("set is empty");
        }
        let last = this._intervals[this._intervals.length - 1];
        return last.b;
      }
      get minElement() {
        if (this.isNil) {
          throw new RangeError("set is empty");
        }
        return this._intervals[0].a;
      }
      get intervals() {
        return this._intervals;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let I of this._intervals) {
          hash = MurmurHash_1.MurmurHash.update(hash, I.a);
          hash = MurmurHash_1.MurmurHash.update(hash, I.b);
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, this._intervals.length * 2);
        return hash;
      }
      equals(o) {
        if (o == null || !(o instanceof IntervalSet)) {
          return false;
        }
        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);
      }
      toString(elemAreChar = false) {
        let buf = "";
        if (this._intervals == null || this._intervals.length === 0) {
          return "{}";
        }
        if (this.size > 1) {
          buf += "{";
        }
        let first = true;
        for (let I of this._intervals) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          let a = I.a;
          let b = I.b;
          if (a === b) {
            if (a === Token_1.Token.EOF) {
              buf += "<EOF>";
            } else if (elemAreChar) {
              buf += "'" + String.fromCodePoint(a) + "'";
            } else {
              buf += a;
            }
          } else {
            if (elemAreChar) {
              buf += "'" + String.fromCodePoint(a) + "'..'" + String.fromCodePoint(b) + "'";
            } else {
              buf += a + ".." + b;
            }
          }
        }
        if (this.size > 1) {
          buf += "}";
        }
        return buf;
      }
      toStringVocabulary(vocabulary) {
        if (this._intervals == null || this._intervals.length === 0) {
          return "{}";
        }
        let buf = "";
        if (this.size > 1) {
          buf += "{";
        }
        let first = true;
        for (let I of this._intervals) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          let a = I.a;
          let b = I.b;
          if (a === b) {
            buf += this.elementName(vocabulary, a);
          } else {
            for (let i = a; i <= b; i++) {
              if (i > a) {
                buf += ", ";
              }
              buf += this.elementName(vocabulary, i);
            }
          }
        }
        if (this.size > 1) {
          buf += "}";
        }
        return buf;
      }
      elementName(vocabulary, a) {
        if (a === Token_1.Token.EOF) {
          return "<EOF>";
        } else if (a === Token_1.Token.EPSILON) {
          return "<EPSILON>";
        } else {
          return vocabulary.getDisplayName(a);
        }
      }
      get size() {
        let n = 0;
        let numIntervals = this._intervals.length;
        if (numIntervals === 1) {
          let firstInterval = this._intervals[0];
          return firstInterval.b - firstInterval.a + 1;
        }
        for (let i = 0; i < numIntervals; i++) {
          let I = this._intervals[i];
          n += I.b - I.a + 1;
        }
        return n;
      }
      toIntegerList() {
        let values = new IntegerList_1.IntegerList(this.size);
        let n = this._intervals.length;
        for (let i = 0; i < n; i++) {
          let I = this._intervals[i];
          let a = I.a;
          let b = I.b;
          for (let v = a; v <= b; v++) {
            values.add(v);
          }
        }
        return values;
      }
      toSet() {
        let s = /* @__PURE__ */ new Set();
        for (let I of this._intervals) {
          let a = I.a;
          let b = I.b;
          for (let v = a; v <= b; v++) {
            s.add(v);
          }
        }
        return s;
      }
      toArray() {
        let values = new Array();
        let n = this._intervals.length;
        for (let i = 0; i < n; i++) {
          let I = this._intervals[i];
          let a = I.a;
          let b = I.b;
          for (let v = a; v <= b; v++) {
            values.push(v);
          }
        }
        return values;
      }
      remove(el) {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        let n = this._intervals.length;
        for (let i = 0; i < n; i++) {
          let I = this._intervals[i];
          let a = I.a;
          let b = I.b;
          if (el < a) {
            break;
          }
          if (el === a && el === b) {
            this._intervals.splice(i, 1);
            break;
          }
          if (el === a) {
            this._intervals[i] = Interval_1.Interval.of(I.a + 1, I.b);
            break;
          }
          if (el === b) {
            this._intervals[i] = Interval_1.Interval.of(I.a, I.b - 1);
            break;
          }
          if (el > a && el < b) {
            let oldb = I.b;
            this._intervals[i] = Interval_1.Interval.of(I.a, el - 1);
            this.add(el + 1, oldb);
          }
        }
      }
      get isReadonly() {
        return this.readonly;
      }
      setReadonly(readonly) {
        if (this.readonly && !readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        this.readonly = readonly;
      }
    };
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "addAll", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "complement", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "subtract", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "or", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "and", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "contains", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "isNil", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "equals", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], IntervalSet.prototype, "toStringVocabulary", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], IntervalSet.prototype, "elementName", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "remove", null);
    __decorate([
      Decorators_1.NotNull
    ], IntervalSet, "of", null);
    __decorate([
      Decorators_1.NotNull
    ], IntervalSet, "subtract", null);
    exports.IntervalSet = IntervalSet;
  }
});

// node_modules/antlr4ts/atn/ATNDeserializationOptions.js
var require_ATNDeserializationOptions = __commonJS({
  "node_modules/antlr4ts/atn/ATNDeserializationOptions.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNDeserializationOptions = void 0;
    var Decorators_1 = require_Decorators();
    var ATNDeserializationOptions = class {
      constructor(options) {
        this.readOnly = false;
        if (options) {
          this.verifyATN = options.verifyATN;
          this.generateRuleBypassTransitions = options.generateRuleBypassTransitions;
          this.optimize = options.optimize;
        } else {
          this.verifyATN = true;
          this.generateRuleBypassTransitions = false;
          this.optimize = true;
        }
      }
      static get defaultOptions() {
        if (ATNDeserializationOptions._defaultOptions == null) {
          ATNDeserializationOptions._defaultOptions = new ATNDeserializationOptions();
          ATNDeserializationOptions._defaultOptions.makeReadOnly();
        }
        return ATNDeserializationOptions._defaultOptions;
      }
      get isReadOnly() {
        return this.readOnly;
      }
      makeReadOnly() {
        this.readOnly = true;
      }
      get isVerifyATN() {
        return this.verifyATN;
      }
      set isVerifyATN(verifyATN) {
        this.throwIfReadOnly();
        this.verifyATN = verifyATN;
      }
      get isGenerateRuleBypassTransitions() {
        return this.generateRuleBypassTransitions;
      }
      set isGenerateRuleBypassTransitions(generateRuleBypassTransitions) {
        this.throwIfReadOnly();
        this.generateRuleBypassTransitions = generateRuleBypassTransitions;
      }
      get isOptimize() {
        return this.optimize;
      }
      set isOptimize(optimize) {
        this.throwIfReadOnly();
        this.optimize = optimize;
      }
      throwIfReadOnly() {
        if (this.isReadOnly) {
          throw new Error("The object is read only.");
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNDeserializationOptions, "defaultOptions", null);
    exports.ATNDeserializationOptions = ATNDeserializationOptions;
  }
});

// node_modules/antlr4ts/atn/ActionTransition.js
var require_ActionTransition = __commonJS({
  "node_modules/antlr4ts/atn/ActionTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var ActionTransition = class ActionTransition extends Transition_1.Transition {
      constructor(target, ruleIndex, actionIndex = -1, isCtxDependent = false) {
        super(target);
        this.ruleIndex = ruleIndex;
        this.actionIndex = actionIndex;
        this.isCtxDependent = isCtxDependent;
      }
      get serializationType() {
        return 6;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      toString() {
        return "action_" + this.ruleIndex + ":" + this.actionIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "toString", null);
    ActionTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ActionTransition);
    exports.ActionTransition = ActionTransition;
  }
});

// node_modules/antlr4ts/atn/AtomTransition.js
var require_AtomTransition = __commonJS({
  "node_modules/antlr4ts/atn/AtomTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AtomTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var AtomTransition = class AtomTransition extends Transition_1.Transition {
      constructor(target, label) {
        super(target);
        this._label = label;
      }
      get serializationType() {
        return 5;
      }
      get label() {
        return IntervalSet_1.IntervalSet.of(this._label);
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this._label === symbol;
      }
      toString() {
        return String(this.label);
      }
    };
    __decorate([
      Decorators_1.Override
    ], AtomTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], AtomTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], AtomTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], AtomTransition.prototype, "toString", null);
    AtomTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], AtomTransition);
    exports.AtomTransition = AtomTransition;
  }
});

// node_modules/antlr4ts/atn/BlockStartState.js
var require_BlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/BlockStartState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockStartState = void 0;
    var DecisionState_1 = require_DecisionState();
    var BlockStartState = class extends DecisionState_1.DecisionState {
    };
    exports.BlockStartState = BlockStartState;
  }
});

// node_modules/antlr4ts/atn/BasicBlockStartState.js
var require_BasicBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/BasicBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var BasicBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BasicBlockStartState.prototype, "stateType", null);
    exports.BasicBlockStartState = BasicBlockStartState;
  }
});

// node_modules/antlr4ts/atn/BlockEndState.js
var require_BlockEndState = __commonJS({
  "node_modules/antlr4ts/atn/BlockEndState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockEndState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var BlockEndState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BLOCK_END;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BlockEndState.prototype, "stateType", null);
    exports.BlockEndState = BlockEndState;
  }
});

// node_modules/antlr4ts/atn/EpsilonTransition.js
var require_EpsilonTransition = __commonJS({
  "node_modules/antlr4ts/atn/EpsilonTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EpsilonTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var EpsilonTransition = class EpsilonTransition extends Transition_1.Transition {
      constructor(target, outermostPrecedenceReturn = -1) {
        super(target);
        this._outermostPrecedenceReturn = outermostPrecedenceReturn;
      }
      get outermostPrecedenceReturn() {
        return this._outermostPrecedenceReturn;
      }
      get serializationType() {
        return 1;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      toString() {
        return "epsilon";
      }
    };
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], EpsilonTransition.prototype, "toString", null);
    EpsilonTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], EpsilonTransition);
    exports.EpsilonTransition = EpsilonTransition;
  }
});

// node_modules/antlr4ts/atn/LexerChannelAction.js
var require_LexerChannelAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerChannelAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerChannelAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerChannelAction = class {
      constructor(channel) {
        this._channel = channel;
      }
      get channel() {
        return this._channel;
      }
      get actionType() {
        return 0;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.channel = this._channel;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._channel);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerChannelAction)) {
          return false;
        }
        return this._channel === obj._channel;
      }
      toString() {
        return `channel(${this._channel})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerChannelAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "toString", null);
    exports.LexerChannelAction = LexerChannelAction;
  }
});

// node_modules/antlr4ts/atn/LexerCustomAction.js
var require_LexerCustomAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerCustomAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerCustomAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerCustomAction = class {
      constructor(ruleIndex, actionIndex) {
        this._ruleIndex = ruleIndex;
        this._actionIndex = actionIndex;
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
      get actionIndex() {
        return this._actionIndex;
      }
      get actionType() {
        return 1;
      }
      get isPositionDependent() {
        return true;
      }
      execute(lexer) {
        lexer.action(void 0, this._ruleIndex, this._actionIndex);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._ruleIndex);
        hash = MurmurHash_1.MurmurHash.update(hash, this._actionIndex);
        return MurmurHash_1.MurmurHash.finish(hash, 3);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerCustomAction)) {
          return false;
        }
        return this._ruleIndex === obj._ruleIndex && this._actionIndex === obj._actionIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerCustomAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "equals", null);
    exports.LexerCustomAction = LexerCustomAction;
  }
});

// node_modules/antlr4ts/atn/LexerModeAction.js
var require_LexerModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerModeAction = class {
      constructor(mode) {
        this._mode = mode;
      }
      get mode() {
        return this._mode;
      }
      get actionType() {
        return 2;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.mode(this._mode);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerModeAction)) {
          return false;
        }
        return this._mode === obj._mode;
      }
      toString() {
        return `mode(${this._mode})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "toString", null);
    exports.LexerModeAction = LexerModeAction;
  }
});

// node_modules/antlr4ts/atn/LexerMoreAction.js
var require_LexerMoreAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerMoreAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerMoreAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerMoreAction = class {
      constructor() {
      }
      get actionType() {
        return 3;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.more();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "more";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerMoreAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "toString", null);
    exports.LexerMoreAction = LexerMoreAction;
    (function(LexerMoreAction2) {
      LexerMoreAction2.INSTANCE = new LexerMoreAction2();
    })(LexerMoreAction = exports.LexerMoreAction || (exports.LexerMoreAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerPopModeAction.js
var require_LexerPopModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerPopModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerPopModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerPopModeAction = class {
      constructor() {
      }
      get actionType() {
        return 4;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.popMode();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "popMode";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerPopModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "toString", null);
    exports.LexerPopModeAction = LexerPopModeAction;
    (function(LexerPopModeAction2) {
      LexerPopModeAction2.INSTANCE = new LexerPopModeAction2();
    })(LexerPopModeAction = exports.LexerPopModeAction || (exports.LexerPopModeAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerPushModeAction.js
var require_LexerPushModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerPushModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerPushModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerPushModeAction = class {
      constructor(mode) {
        this._mode = mode;
      }
      get mode() {
        return this._mode;
      }
      get actionType() {
        return 5;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.pushMode(this._mode);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerPushModeAction)) {
          return false;
        }
        return this._mode === obj._mode;
      }
      toString() {
        return `pushMode(${this._mode})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerPushModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "toString", null);
    exports.LexerPushModeAction = LexerPushModeAction;
  }
});

// node_modules/antlr4ts/atn/LexerSkipAction.js
var require_LexerSkipAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerSkipAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerSkipAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerSkipAction = class {
      constructor() {
      }
      get actionType() {
        return 6;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.skip();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "skip";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerSkipAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "toString", null);
    exports.LexerSkipAction = LexerSkipAction;
    (function(LexerSkipAction2) {
      LexerSkipAction2.INSTANCE = new LexerSkipAction2();
    })(LexerSkipAction = exports.LexerSkipAction || (exports.LexerSkipAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerTypeAction.js
var require_LexerTypeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerTypeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerTypeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerTypeAction = class {
      constructor(type) {
        this._type = type;
      }
      get type() {
        return this._type;
      }
      get actionType() {
        return 7;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.type = this._type;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._type);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerTypeAction)) {
          return false;
        }
        return this._type === obj._type;
      }
      toString() {
        return `type(${this._type})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerTypeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "toString", null);
    exports.LexerTypeAction = LexerTypeAction;
  }
});

// node_modules/antlr4ts/atn/LoopEndState.js
var require_LoopEndState = __commonJS({
  "node_modules/antlr4ts/atn/LoopEndState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoopEndState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var LoopEndState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.LOOP_END;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LoopEndState.prototype, "stateType", null);
    exports.LoopEndState = LoopEndState;
  }
});

// node_modules/antlr4ts/atn/ConflictInfo.js
var require_ConflictInfo = __commonJS({
  "node_modules/antlr4ts/atn/ConflictInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConflictInfo = void 0;
    var Decorators_1 = require_Decorators();
    var Utils3 = require_Utils();
    var ConflictInfo = class {
      constructor(conflictedAlts, exact) {
        this._conflictedAlts = conflictedAlts;
        this.exact = exact;
      }
      get conflictedAlts() {
        return this._conflictedAlts;
      }
      get isExact() {
        return this.exact;
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof ConflictInfo)) {
          return false;
        }
        return this.isExact === obj.isExact && Utils3.equals(this.conflictedAlts, obj.conflictedAlts);
      }
      hashCode() {
        return this.conflictedAlts.hashCode();
      }
    };
    __decorate([
      Decorators_1.Override
    ], ConflictInfo.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ConflictInfo.prototype, "hashCode", null);
    exports.ConflictInfo = ConflictInfo;
  }
});

// node_modules/antlr4ts/tree/TerminalNode.js
var require_TerminalNode = __commonJS({
  "node_modules/antlr4ts/tree/TerminalNode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TerminalNode = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var TerminalNode = class {
      constructor(symbol) {
        this._symbol = symbol;
      }
      getChild(i) {
        throw new RangeError("Terminal Node has no children.");
      }
      get symbol() {
        return this._symbol;
      }
      get parent() {
        return this._parent;
      }
      setParent(parent) {
        this._parent = parent;
      }
      get payload() {
        return this._symbol;
      }
      get sourceInterval() {
        let tokenIndex = this._symbol.tokenIndex;
        return new Interval_1.Interval(tokenIndex, tokenIndex);
      }
      get childCount() {
        return 0;
      }
      accept(visitor) {
        return visitor.visitTerminal(this);
      }
      get text() {
        return this._symbol.text || "";
      }
      toStringTree(parser) {
        return this.toString();
      }
      toString() {
        if (this._symbol.type === Token_1.Token.EOF) {
          return "<EOF>";
        }
        return this._symbol.text || "";
      }
    };
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "getChild", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "setParent", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "payload", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "sourceInterval", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "accept", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "toStringTree", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "toString", null);
    exports.TerminalNode = TerminalNode;
  }
});

// node_modules/antlr4ts/tree/ErrorNode.js
var require_ErrorNode = __commonJS({
  "node_modules/antlr4ts/tree/ErrorNode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorNode = void 0;
    var Decorators_1 = require_Decorators();
    var TerminalNode_1 = require_TerminalNode();
    var ErrorNode = class extends TerminalNode_1.TerminalNode {
      constructor(token) {
        super(token);
      }
      accept(visitor) {
        return visitor.visitErrorNode(this);
      }
    };
    __decorate([
      Decorators_1.Override
    ], ErrorNode.prototype, "accept", null);
    exports.ErrorNode = ErrorNode;
  }
});

// node_modules/antlr4ts/tree/RuleNode.js
var require_RuleNode = __commonJS({
  "node_modules/antlr4ts/tree/RuleNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleNode = void 0;
    var RuleNode = class {
    };
    exports.RuleNode = RuleNode;
  }
});

// node_modules/antlr4ts/tree/Trees.js
var require_Trees = __commonJS({
  "node_modules/antlr4ts/tree/Trees.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Trees = void 0;
    var ATN_1 = require_ATN();
    var CommonToken_1 = require_CommonToken();
    var ErrorNode_1 = require_ErrorNode();
    var Decorators_1 = require_Decorators();
    var Parser_1 = require_Parser();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleNode_1 = require_RuleNode();
    var TerminalNode_1 = require_TerminalNode();
    var Token_1 = require_Token();
    var Utils3 = require_Utils();
    var Trees = class {
      static toStringTree(t, arg2) {
        let ruleNames;
        if (arg2 instanceof Parser_1.Parser) {
          ruleNames = arg2.ruleNames;
        } else {
          ruleNames = arg2;
        }
        let s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
        if (t.childCount === 0) {
          return s;
        }
        let buf = "";
        buf += "(";
        s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
        buf += s;
        buf += " ";
        for (let i = 0; i < t.childCount; i++) {
          if (i > 0) {
            buf += " ";
          }
          buf += this.toStringTree(t.getChild(i), ruleNames);
        }
        buf += ")";
        return buf;
      }
      static getNodeText(t, arg2) {
        let ruleNames;
        if (arg2 instanceof Parser_1.Parser) {
          ruleNames = arg2.ruleNames;
        } else if (arg2) {
          ruleNames = arg2;
        } else {
          let payload = t.payload;
          if (typeof payload.text === "string") {
            return payload.text;
          }
          return t.payload.toString();
        }
        if (t instanceof RuleNode_1.RuleNode) {
          let ruleContext = t.ruleContext;
          let ruleIndex = ruleContext.ruleIndex;
          let ruleName = ruleNames[ruleIndex];
          let altNumber = ruleContext.altNumber;
          if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            return ruleName + ":" + altNumber;
          }
          return ruleName;
        } else if (t instanceof ErrorNode_1.ErrorNode) {
          return t.toString();
        } else if (t instanceof TerminalNode_1.TerminalNode) {
          let symbol = t.symbol;
          return symbol.text || "";
        }
        throw new TypeError("Unexpected node type");
      }
      static getChildren(t) {
        let kids = [];
        for (let i = 0; i < t.childCount; i++) {
          kids.push(t.getChild(i));
        }
        return kids;
      }
      static getAncestors(t) {
        let ancestors = [];
        let p = t.parent;
        while (p) {
          ancestors.unshift(p);
          p = p.parent;
        }
        return ancestors;
      }
      static isAncestorOf(t, u) {
        if (!t || !u || !t.parent) {
          return false;
        }
        let p = u.parent;
        while (p) {
          if (t === p) {
            return true;
          }
          p = p.parent;
        }
        return false;
      }
      static findAllTokenNodes(t, ttype) {
        return Trees.findAllNodes(t, ttype, true);
      }
      static findAllRuleNodes(t, ruleIndex) {
        return Trees.findAllNodes(t, ruleIndex, false);
      }
      static findAllNodes(t, index2, findTokens) {
        let nodes = [];
        Trees._findAllNodes(t, index2, findTokens, nodes);
        return nodes;
      }
      static _findAllNodes(t, index2, findTokens, nodes) {
        if (findTokens && t instanceof TerminalNode_1.TerminalNode) {
          if (t.symbol.type === index2) {
            nodes.push(t);
          }
        } else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {
          if (t.ruleIndex === index2) {
            nodes.push(t);
          }
        }
        for (let i = 0; i < t.childCount; i++) {
          Trees._findAllNodes(t.getChild(i), index2, findTokens, nodes);
        }
      }
      static getDescendants(t) {
        let nodes = [];
        function recurse(e) {
          nodes.push(e);
          const n = e.childCount;
          for (let i = 0; i < n; i++) {
            recurse(e.getChild(i));
          }
        }
        recurse(t);
        return nodes;
      }
      static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
        let n = t.childCount;
        for (let i = 0; i < n; i++) {
          let child = t.getChild(i);
          let r = Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
          if (r) {
            return r;
          }
        }
        if (t instanceof ParserRuleContext_1.ParserRuleContext) {
          let stopToken = t.stop;
          if (startTokenIndex >= t.start.tokenIndex && (stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {
            return t;
          }
        }
        return void 0;
      }
      static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
        if (!t) {
          return;
        }
        let count = t.childCount;
        for (let i = 0; i < count; i++) {
          let child = t.getChild(i);
          let range = child.sourceInterval;
          if (child instanceof ParserRuleContext_1.ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {
            if (Trees.isAncestorOf(child, root)) {
              let abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, "...");
              t.children[i] = new TerminalNode_1.TerminalNode(abbrev);
            }
          }
        }
      }
      static findNodeSuchThat(t, pred) {
        if (pred(t)) {
          return t;
        }
        let n = t.childCount;
        for (let i = 0; i < n; i++) {
          let u = Trees.findNodeSuchThat(t.getChild(i), pred);
          if (u !== void 0) {
            return u;
          }
        }
        return void 0;
      }
    };
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Trees, "toStringTree", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Trees, "getAncestors", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Trees, "getRootOfSubtreeEnclosingRegion", null);
    exports.Trees = Trees;
  }
});

// node_modules/antlr4ts/RuleContext.js
var require_RuleContext = __commonJS({
  "node_modules/antlr4ts/RuleContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleContext = void 0;
    var ATN_1 = require_ATN();
    var Recognizer_1 = require_Recognizer();
    var RuleNode_1 = require_RuleNode();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleContext = class extends RuleNode_1.RuleNode {
      constructor(parent, invokingState) {
        super();
        this._parent = parent;
        this.invokingState = invokingState != null ? invokingState : -1;
      }
      static getChildContext(parent, invokingState) {
        return new RuleContext(parent, invokingState);
      }
      depth() {
        let n = 0;
        let p = this;
        while (p) {
          p = p._parent;
          n++;
        }
        return n;
      }
      get isEmpty() {
        return this.invokingState === -1;
      }
      get sourceInterval() {
        return Interval_1.Interval.INVALID;
      }
      get ruleContext() {
        return this;
      }
      get parent() {
        return this._parent;
      }
      setParent(parent) {
        this._parent = parent;
      }
      get payload() {
        return this;
      }
      get text() {
        if (this.childCount === 0) {
          return "";
        }
        let builder = "";
        for (let i = 0; i < this.childCount; i++) {
          builder += this.getChild(i).text;
        }
        return builder.toString();
      }
      get ruleIndex() {
        return -1;
      }
      get altNumber() {
        return ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      set altNumber(altNumber) {
      }
      getChild(i) {
        throw new RangeError("i must be greater than or equal to 0 and less than childCount");
      }
      get childCount() {
        return 0;
      }
      accept(visitor) {
        return visitor.visitChildren(this);
      }
      toStringTree(recog) {
        return Trees_1.Trees.toStringTree(this, recog);
      }
      toString(arg1, stop) {
        const ruleNames = arg1 instanceof Recognizer_1.Recognizer ? arg1.ruleNames : arg1;
        stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();
        let buf = "";
        let p = this;
        buf += "[";
        while (p && p !== stop) {
          if (!ruleNames) {
            if (!p.isEmpty) {
              buf += p.invokingState;
            }
          } else {
            let ruleIndex = p.ruleIndex;
            let ruleName = ruleIndex >= 0 && ruleIndex < ruleNames.length ? ruleNames[ruleIndex] : ruleIndex.toString();
            buf += ruleName;
          }
          if (p._parent && (ruleNames || !p._parent.isEmpty)) {
            buf += " ";
          }
          p = p._parent;
        }
        buf += "]";
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "sourceInterval", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "ruleContext", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "setParent", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "payload", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "getChild", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "accept", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "toStringTree", null);
    exports.RuleContext = RuleContext;
  }
});

// node_modules/antlr4ts/ParserRuleContext.js
var require_ParserRuleContext = __commonJS({
  "node_modules/antlr4ts/ParserRuleContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserRuleContext = void 0;
    var ErrorNode_1 = require_ErrorNode();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var RuleContext_1 = require_RuleContext();
    var TerminalNode_1 = require_TerminalNode();
    var ParserRuleContext3 = class extends RuleContext_1.RuleContext {
      constructor(parent, invokingStateNumber) {
        if (invokingStateNumber == null) {
          super();
        } else {
          super(parent, invokingStateNumber);
        }
      }
      static emptyContext() {
        return ParserRuleContext3.EMPTY;
      }
      copyFrom(ctx) {
        this._parent = ctx._parent;
        this.invokingState = ctx.invokingState;
        this._start = ctx._start;
        this._stop = ctx._stop;
        if (ctx.children) {
          this.children = [];
          for (let child of ctx.children) {
            if (child instanceof ErrorNode_1.ErrorNode) {
              this.addChild(child);
            }
          }
        }
      }
      enterRule(listener) {
      }
      exitRule(listener) {
      }
      addAnyChild(t) {
        if (!this.children) {
          this.children = [t];
        } else {
          this.children.push(t);
        }
        return t;
      }
      addChild(t) {
        let result;
        if (t instanceof TerminalNode_1.TerminalNode) {
          t.setParent(this);
          this.addAnyChild(t);
          return;
        } else if (t instanceof RuleContext_1.RuleContext) {
          this.addAnyChild(t);
          return;
        } else {
          t = new TerminalNode_1.TerminalNode(t);
          this.addAnyChild(t);
          t.setParent(this);
          return t;
        }
      }
      addErrorNode(node) {
        if (node instanceof ErrorNode_1.ErrorNode) {
          const errorNode = node;
          errorNode.setParent(this);
          return this.addAnyChild(errorNode);
        } else {
          const badToken = node;
          let t = new ErrorNode_1.ErrorNode(badToken);
          this.addAnyChild(t);
          t.setParent(this);
          return t;
        }
      }
      removeLastChild() {
        if (this.children) {
          this.children.pop();
        }
      }
      get parent() {
        let parent = super.parent;
        if (parent === void 0 || parent instanceof ParserRuleContext3) {
          return parent;
        }
        throw new TypeError("Invalid parent type for ParserRuleContext");
      }
      getChild(i, ctxType) {
        if (!this.children || i < 0 || i >= this.children.length) {
          throw new RangeError("index parameter must be between >= 0 and <= number of children.");
        }
        if (ctxType == null) {
          return this.children[i];
        }
        let result = this.tryGetChild(i, ctxType);
        if (result === void 0) {
          throw new Error("The specified node does not exist");
        }
        return result;
      }
      tryGetChild(i, ctxType) {
        if (!this.children || i < 0 || i >= this.children.length) {
          return void 0;
        }
        let j = -1;
        for (let o of this.children) {
          if (o instanceof ctxType) {
            j++;
            if (j === i) {
              return o;
            }
          }
        }
        return void 0;
      }
      getToken(ttype, i) {
        let result = this.tryGetToken(ttype, i);
        if (result === void 0) {
          throw new Error("The specified token does not exist");
        }
        return result;
      }
      tryGetToken(ttype, i) {
        if (!this.children || i < 0 || i >= this.children.length) {
          return void 0;
        }
        let j = -1;
        for (let o of this.children) {
          if (o instanceof TerminalNode_1.TerminalNode) {
            let symbol = o.symbol;
            if (symbol.type === ttype) {
              j++;
              if (j === i) {
                return o;
              }
            }
          }
        }
        return void 0;
      }
      getTokens(ttype) {
        let tokens = [];
        if (!this.children) {
          return tokens;
        }
        for (let o of this.children) {
          if (o instanceof TerminalNode_1.TerminalNode) {
            let symbol = o.symbol;
            if (symbol.type === ttype) {
              tokens.push(o);
            }
          }
        }
        return tokens;
      }
      get ruleContext() {
        return this;
      }
      getRuleContext(i, ctxType) {
        return this.getChild(i, ctxType);
      }
      tryGetRuleContext(i, ctxType) {
        return this.tryGetChild(i, ctxType);
      }
      getRuleContexts(ctxType) {
        let contexts = [];
        if (!this.children) {
          return contexts;
        }
        for (let o of this.children) {
          if (o instanceof ctxType) {
            contexts.push(o);
          }
        }
        return contexts;
      }
      get childCount() {
        return this.children ? this.children.length : 0;
      }
      get sourceInterval() {
        if (!this._start) {
          return Interval_1.Interval.INVALID;
        }
        if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {
          return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1);
        }
        return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);
      }
      get start() {
        return this._start;
      }
      get stop() {
        return this._stop;
      }
      toInfoString(recognizer) {
        let rules = recognizer.getRuleInvocationStack(this).reverse();
        return "ParserRuleContext" + rules + "{start=" + this._start + ", stop=" + this._stop + "}";
      }
    };
    ParserRuleContext3.EMPTY = new ParserRuleContext3();
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext3.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext3.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext3.prototype, "sourceInterval", null);
    exports.ParserRuleContext = ParserRuleContext3;
  }
});

// node_modules/antlr4ts/atn/PredictionMode.js
var require_PredictionMode = __commonJS({
  "node_modules/antlr4ts/atn/PredictionMode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredictionMode = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var RuleStopState_1 = require_RuleStopState();
    var PredictionMode;
    (function(PredictionMode2) {
      PredictionMode2[PredictionMode2["SLL"] = 0] = "SLL";
      PredictionMode2[PredictionMode2["LL"] = 1] = "LL";
      PredictionMode2[PredictionMode2["LL_EXACT_AMBIG_DETECTION"] = 2] = "LL_EXACT_AMBIG_DETECTION";
    })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
    (function(PredictionMode2) {
      class AltAndContextMap extends Array2DHashMap_1.Array2DHashMap {
        constructor() {
          super(AltAndContextConfigEqualityComparator.INSTANCE);
        }
      }
      class AltAndContextConfigEqualityComparator {
        AltAndContextConfigEqualityComparator() {
        }
        hashCode(o) {
          let hashCode = MurmurHash_1.MurmurHash.initialize(7);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.state.stateNumber);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.context);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 2);
          return hashCode;
        }
        equals(a, b) {
          if (a === b) {
            return true;
          }
          if (a == null || b == null) {
            return false;
          }
          return a.state.stateNumber === b.state.stateNumber && a.context.equals(b.context);
        }
      }
      AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], AltAndContextConfigEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], AltAndContextConfigEqualityComparator.prototype, "equals", null);
      function hasConfigInRuleStopState(configs) {
        for (let c of configs) {
          if (c.state instanceof RuleStopState_1.RuleStopState) {
            return true;
          }
        }
        return false;
      }
      PredictionMode2.hasConfigInRuleStopState = hasConfigInRuleStopState;
      function allConfigsInRuleStopStates(configs) {
        for (let config of configs) {
          if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
            return false;
          }
        }
        return true;
      }
      PredictionMode2.allConfigsInRuleStopStates = allConfigsInRuleStopStates;
    })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
  }
});

// node_modules/antlr4ts/atn/SimulatorState.js
var require_SimulatorState = __commonJS({
  "node_modules/antlr4ts/atn/SimulatorState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimulatorState = void 0;
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var SimulatorState = class SimulatorState {
      constructor(outerContext, s0, useContext, remainingOuterContext) {
        this.outerContext = outerContext != null ? outerContext : ParserRuleContext_1.ParserRuleContext.emptyContext();
        this.s0 = s0;
        this.useContext = useContext;
        this.remainingOuterContext = remainingOuterContext;
      }
    };
    SimulatorState = __decorate([
      __param(1, Decorators_1.NotNull)
    ], SimulatorState);
    exports.SimulatorState = SimulatorState;
  }
});

// node_modules/antlr4ts/atn/ParserATNSimulator.js
var require_ParserATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ParserATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserATNSimulator = void 0;
    var AcceptStateInfo_1 = require_AcceptStateInfo();
    var ActionTransition_1 = require_ActionTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var Arrays_1 = require_Arrays();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var ATNSimulator_1 = require_ATNSimulator();
    var ATNStateType_1 = require_ATNStateType();
    var AtomTransition_1 = require_AtomTransition();
    var BitSet_1 = require_BitSet();
    var ConflictInfo_1 = require_ConflictInfo();
    var DecisionState_1 = require_DecisionState();
    var DFAState_1 = require_DFAState();
    var IntegerList_1 = require_IntegerList();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var NoViableAltException_1 = require_NoViableAltException();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var PredictionContext_1 = require_PredictionContext();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var PredictionMode_1 = require_PredictionMode();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var SemanticContext_1 = require_SemanticContext();
    var SetTransition_1 = require_SetTransition();
    var SimulatorState_1 = require_SimulatorState();
    var Token_1 = require_Token();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var assert = require("assert");
    var MAX_SHORT_VALUE = 65535;
    var MIN_INTEGER_VALUE = -(1 << 31 >>> 0);
    var ParserATNSimulator2 = class ParserATNSimulator3 extends ATNSimulator_1.ATNSimulator {
      constructor(atn, parser) {
        super(atn);
        this.predictionMode = PredictionMode_1.PredictionMode.LL;
        this.force_global_context = false;
        this.always_try_local_context = true;
        this.enable_global_context_dfa = false;
        this.optimize_unique_closure = true;
        this.optimize_ll1 = true;
        this.optimize_tail_calls = true;
        this.tail_call_preserves_sll = true;
        this.treat_sllk1_conflict_as_ambiguity = false;
        this.reportAmbiguities = false;
        this.userWantsCtxSensitive = true;
        this._parser = parser;
      }
      getPredictionMode() {
        return this.predictionMode;
      }
      setPredictionMode(predictionMode) {
        this.predictionMode = predictionMode;
      }
      reset() {
      }
      adaptivePredict(input, decision, outerContext, useContext) {
        if (useContext === void 0) {
          useContext = false;
        }
        let dfa = this.atn.decisionToDFA[decision];
        assert(dfa != null);
        if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {
          let ll_1 = input.LA(1);
          if (ll_1 >= 0 && ll_1 <= 65535) {
            let key = (decision << 16 >>> 0) + ll_1;
            let alt = this.atn.LL1Table.get(key);
            if (alt != null) {
              return alt;
            }
          }
        }
        this.dfa = dfa;
        if (this.force_global_context) {
          useContext = true;
        } else if (!this.always_try_local_context) {
          useContext = useContext || dfa.isContextSensitive;
        }
        this.userWantsCtxSensitive = useContext || this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll;
        if (outerContext == null) {
          outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
        }
        let state;
        if (!dfa.isEmpty) {
          state = this.getStartState(dfa, input, outerContext, useContext);
        }
        if (state == null) {
          if (outerContext == null) {
            outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
          }
          if (ParserATNSimulator3.debug) {
            console.log("ATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
          }
          state = this.computeStartState(dfa, outerContext, useContext);
        }
        let m = input.mark();
        let index2 = input.index;
        try {
          let alt = this.execDFA(dfa, input, index2, state);
          if (ParserATNSimulator3.debug) {
            console.log("DFA after predictATN: " + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
          }
          return alt;
        } finally {
          this.dfa = void 0;
          input.seek(index2);
          input.release(m);
        }
      }
      getStartState(dfa, input, outerContext, useContext) {
        if (!useContext) {
          if (dfa.isPrecedenceDfa) {
            let state = dfa.getPrecedenceStartState(this._parser.precedence, false);
            if (state == null) {
              return void 0;
            }
            return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);
          } else {
            if (dfa.s0 == null) {
              return void 0;
            }
            return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);
          }
        }
        if (!this.enable_global_context_dfa) {
          return void 0;
        }
        let remainingContext = outerContext;
        assert(outerContext != null);
        let s0;
        if (dfa.isPrecedenceDfa) {
          s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);
        } else {
          s0 = dfa.s0full;
        }
        while (remainingContext != null && s0 != null && s0.isContextSensitive) {
          remainingContext = this.skipTailCalls(remainingContext);
          s0 = s0.getContextTarget(this.getReturnState(remainingContext));
          if (remainingContext.isEmpty) {
            assert(s0 == null || !s0.isContextSensitive);
          } else {
            remainingContext = remainingContext.parent;
          }
        }
        if (s0 == null) {
          return void 0;
        }
        return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);
      }
      execDFA(dfa, input, startIndex, state) {
        let outerContext = state.outerContext;
        if (ParserATNSimulator3.dfa_debug) {
          console.log("DFA decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
        }
        if (ParserATNSimulator3.dfa_debug) {
          console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
        }
        let s = state.s0;
        let t = input.LA(1);
        let remainingOuterContext = state.remainingOuterContext;
        while (true) {
          if (ParserATNSimulator3.dfa_debug) {
            console.log("DFA state " + s.stateNumber + " LA(1)==" + this.getLookaheadName(input));
          }
          if (state.useContext) {
            while (s.isContextSymbol(t)) {
              let next;
              if (remainingOuterContext != null) {
                remainingOuterContext = this.skipTailCalls(remainingOuterContext);
                next = s.getContextTarget(this.getReturnState(remainingOuterContext));
              }
              if (next == null) {
                let initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);
                return this.execATN(dfa, input, startIndex, initialState);
              }
              assert(remainingOuterContext != null);
              remainingOuterContext = remainingOuterContext.parent;
              s = next;
            }
          }
          if (this.isAcceptState(s, state.useContext)) {
            if (s.predicates != null) {
              if (ParserATNSimulator3.dfa_debug) {
                console.log("accept " + s);
              }
            } else {
              if (ParserATNSimulator3.dfa_debug) {
                console.log("accept; predict " + s.prediction + " in state " + s.stateNumber);
              }
            }
            break;
          }
          assert(!this.isAcceptState(s, state.useContext));
          let target = this.getExistingTargetState(s, t);
          if (target == null) {
            if (ParserATNSimulator3.dfa_debug && t >= 0) {
              console.log("no edge for " + this._parser.vocabulary.getDisplayName(t));
            }
            let alt;
            if (ParserATNSimulator3.dfa_debug) {
              let interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);
              console.log("ATN exec upon " + this._parser.inputStream.getText(interval) + " at DFA state " + s.stateNumber);
            }
            let initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
            alt = this.execATN(dfa, input, startIndex, initialState);
            if (ParserATNSimulator3.dfa_debug) {
              console.log("back from DFA update, alt=" + alt + ", dfa=\n" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
            }
            if (ParserATNSimulator3.dfa_debug) {
              console.log("DFA decision " + dfa.decision + " predicts " + alt);
            }
            return alt;
          } else if (target === ATNSimulator_1.ATNSimulator.ERROR) {
            let errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
            return this.handleNoViableAlt(input, startIndex, errorState);
          }
          s = target;
          if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
        if (!state.useContext && s.configs.conflictInfo != null) {
          if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {
            if (!this.userWantsCtxSensitive || !s.configs.dipsIntoOuterContext && s.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex) {
            } else {
              assert(!state.useContext);
              let conflictingAlts;
              let predicates2 = s.predicates;
              if (predicates2 != null) {
                let conflictIndex = input.index;
                if (conflictIndex !== startIndex) {
                  input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(predicates2, outerContext, true);
                if (conflictingAlts.cardinality() === 1) {
                  return conflictingAlts.nextSetBit(0);
                }
                if (conflictIndex !== startIndex) {
                  input.seek(conflictIndex);
                }
              }
              if (this.reportAmbiguities) {
                let conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
                this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);
              }
              input.seek(startIndex);
              return this.adaptivePredict(input, dfa.decision, outerContext, true);
            }
          }
        }
        let predicates = s.predicates;
        if (predicates != null) {
          let stopIndex = input.index;
          if (startIndex !== stopIndex) {
            input.seek(startIndex);
          }
          let alts = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);
          switch (alts.cardinality()) {
            case 0:
              throw this.noViableAlt(input, outerContext, s.configs, startIndex);
            case 1:
              return alts.nextSetBit(0);
            default:
              if (startIndex !== stopIndex) {
                input.seek(stopIndex);
              }
              this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);
              return alts.nextSetBit(0);
          }
        }
        if (ParserATNSimulator3.dfa_debug) {
          console.log("DFA decision " + dfa.decision + " predicts " + s.prediction);
        }
        return s.prediction;
      }
      isAcceptState(state, useContext) {
        if (!state.isAcceptState) {
          return false;
        }
        if (state.configs.conflictingAlts == null) {
          return true;
        }
        if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {
          return state.configs.isExactConflict;
        }
        return true;
      }
      execATN(dfa, input, startIndex, initialState) {
        if (ParserATNSimulator3.debug) {
          console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input));
        }
        let outerContext = initialState.outerContext;
        let useContext = initialState.useContext;
        let t = input.LA(1);
        let previous4 = initialState;
        let contextCache = new PredictionContextCache_1.PredictionContextCache();
        while (true) {
          let nextState = this.computeReachSet(dfa, previous4, t, contextCache);
          if (nextState == null) {
            this.setDFAEdge(previous4.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);
            return this.handleNoViableAlt(input, startIndex, previous4);
          }
          let D = nextState.s0;
          assert(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);
          assert(D.isAcceptState || D.configs.conflictInfo == null);
          if (this.isAcceptState(D, useContext)) {
            let conflictingAlts = D.configs.conflictingAlts;
            let predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;
            if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (this.optimize_ll1 && input.index === startIndex && !dfa.isPrecedenceDfa && nextState.outerContext === nextState.remainingOuterContext && dfa.decision >= 0 && !D.configs.hasSemanticContext) {
                if (t >= 0 && t <= MAX_SHORT_VALUE) {
                  let key = (dfa.decision << 16 >>> 0) + t;
                  this.atn.LL1Table.set(key, predictedAlt);
                }
              }
              if (useContext && this.always_try_local_context) {
                this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);
              }
            }
            predictedAlt = D.prediction;
            let attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;
            if (attemptFullContext) {
              attemptFullContext = !useContext && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);
            }
            if (D.configs.hasSemanticContext) {
              let predPredictions = D.predicates;
              if (predPredictions != null) {
                let conflictIndex = input.index;
                if (conflictIndex !== startIndex) {
                  input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);
                switch (conflictingAlts.cardinality()) {
                  case 0:
                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                  case 1:
                    return conflictingAlts.nextSetBit(0);
                  default:
                    break;
                }
                if (conflictIndex !== startIndex) {
                  input.seek(conflictIndex);
                }
              }
            }
            if (!attemptFullContext) {
              if (conflictingAlts != null) {
                if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {
                  this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);
                }
                predictedAlt = conflictingAlts.nextSetBit(0);
              }
              return predictedAlt;
            } else {
              assert(!useContext);
              assert(this.isAcceptState(D, false));
              if (ParserATNSimulator3.debug) {
                console.log("RETRY with outerContext=" + outerContext);
              }
              let fullContextState = this.computeStartState(dfa, outerContext, true);
              if (this.reportAmbiguities) {
                this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);
              }
              input.seek(startIndex);
              return this.execATN(dfa, input, startIndex, fullContextState);
            }
          }
          previous4 = nextState;
          if (t !== IntStream_1.IntStream.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
      }
      handleNoViableAlt(input, startIndex, previous4) {
        if (previous4.s0 != null) {
          let alts = new BitSet_1.BitSet();
          let maxAlt = 0;
          for (let config of previous4.s0.configs) {
            if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
              alts.set(config.alt);
              maxAlt = Math.max(maxAlt, config.alt);
            }
          }
          switch (alts.cardinality()) {
            case 0:
              break;
            case 1:
              return alts.nextSetBit(0);
            default:
              if (!previous4.s0.configs.hasSemanticContext) {
                return alts.nextSetBit(0);
              }
              let filteredConfigs = new ATNConfigSet_1.ATNConfigSet();
              for (let config of previous4.s0.configs) {
                if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
                  filteredConfigs.add(config);
                }
              }
              let altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);
              if (altToPred != null) {
                let predicates = this.getPredicatePredictions(alts, altToPred);
                if (predicates != null) {
                  let stopIndex = input.index;
                  try {
                    input.seek(startIndex);
                    let filteredAlts = this.evalSemanticContext(predicates, previous4.outerContext, false);
                    if (!filteredAlts.isEmpty) {
                      return filteredAlts.nextSetBit(0);
                    }
                  } finally {
                    input.seek(stopIndex);
                  }
                }
              }
              return alts.nextSetBit(0);
          }
        }
        throw this.noViableAlt(input, previous4.outerContext, previous4.s0.configs, startIndex);
      }
      computeReachSet(dfa, previous4, t, contextCache) {
        let useContext = previous4.useContext;
        let remainingGlobalContext = previous4.remainingOuterContext;
        let s = previous4.s0;
        if (useContext) {
          while (s.isContextSymbol(t)) {
            let next;
            if (remainingGlobalContext != null) {
              remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
              next = s.getContextTarget(this.getReturnState(remainingGlobalContext));
            }
            if (next == null) {
              break;
            }
            assert(remainingGlobalContext != null);
            remainingGlobalContext = remainingGlobalContext.parent;
            s = next;
          }
        }
        assert(!this.isAcceptState(s, useContext));
        if (this.isAcceptState(s, useContext)) {
          return new SimulatorState_1.SimulatorState(previous4.outerContext, s, useContext, remainingGlobalContext);
        }
        let s0 = s;
        let target = this.getExistingTargetState(s0, t);
        if (target == null) {
          let result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);
          target = result[0];
          remainingGlobalContext = result[1];
        }
        if (target === ATNSimulator_1.ATNSimulator.ERROR) {
          return void 0;
        }
        assert(!useContext || !target.configs.dipsIntoOuterContext);
        return new SimulatorState_1.SimulatorState(previous4.outerContext, target, useContext, remainingGlobalContext);
      }
      getExistingTargetState(s, t) {
        return s.getTarget(t);
      }
      computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
        let closureConfigs = s.configs.toArray();
        let contextElements;
        let reach = new ATNConfigSet_1.ATNConfigSet();
        let stepIntoGlobal;
        do {
          let hasMoreContext = !useContext || remainingGlobalContext != null;
          if (!hasMoreContext) {
            reach.isOutermostConfigSet = true;
          }
          let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
          let skippedStopStates;
          for (let c of closureConfigs) {
            if (ParserATNSimulator3.debug) {
              console.log("testing " + this.getTokenName(t) + " at " + c.toString());
            }
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              assert(c.context.isEmpty);
              if (useContext && !c.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {
                if (skippedStopStates == null) {
                  skippedStopStates = [];
                }
                skippedStopStates.push(c);
              }
              continue;
            }
            let n = c.state.numberOfOptimizedTransitions;
            for (let ti = 0; ti < n; ti++) {
              let trans = c.state.getOptimizedTransition(ti);
              let target = this.getReachableTarget(c, trans, t);
              if (target != null) {
                reachIntermediate.add(c.transform(target, false), contextCache);
              }
            }
          }
          if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;
            reach = reachIntermediate;
            break;
          }
          let collectPredicates = false;
          let treatEofAsEpsilon = t === Token_1.Token.EOF;
          this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);
          stepIntoGlobal = reach.dipsIntoOuterContext;
          if (t === IntStream_1.IntStream.EOF) {
            reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);
          }
          if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {
            assert(skippedStopStates.length > 0);
            for (let c of skippedStopStates) {
              reach.add(c, contextCache);
            }
          }
          if (useContext && stepIntoGlobal) {
            reach.clear();
            remainingGlobalContext = remainingGlobalContext;
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            let nextContextElement = this.getReturnState(remainingGlobalContext);
            if (contextElements == null) {
              contextElements = new IntegerList_1.IntegerList();
            }
            if (remainingGlobalContext.isEmpty) {
              remainingGlobalContext = void 0;
            } else {
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            contextElements.add(nextContextElement);
            if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              for (let i = 0; i < closureConfigs.length; i++) {
                closureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);
              }
            }
          }
        } while (useContext && stepIntoGlobal);
        if (reach.isEmpty) {
          this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
          return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];
        }
        let result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);
        return [result, remainingGlobalContext];
      }
      removeAllConfigsNotInRuleStopState(configs, contextCache) {
        if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {
          return configs;
        }
        let result = new ATNConfigSet_1.ATNConfigSet();
        for (let config of configs) {
          if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          result.add(config, contextCache);
        }
        return result;
      }
      computeStartState(dfa, globalContext, useContext) {
        let s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) : useContext ? dfa.s0full : dfa.s0;
        if (s0 != null) {
          if (!useContext) {
            return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);
          }
          s0.setContextSensitive(this.atn);
        }
        let decision = dfa.decision;
        let p = dfa.atnStartState;
        let previousContext = 0;
        let remainingGlobalContext = globalContext;
        let initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL;
        let contextCache = new PredictionContextCache_1.PredictionContextCache();
        if (useContext) {
          if (!this.enable_global_context_dfa) {
            while (remainingGlobalContext != null) {
              if (remainingGlobalContext.isEmpty) {
                previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                remainingGlobalContext = void 0;
              } else {
                previousContext = this.getReturnState(remainingGlobalContext);
                initialContext = initialContext.appendSingleContext(previousContext, contextCache);
                remainingGlobalContext = remainingGlobalContext.parent;
              }
            }
          }
          while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {
            let next;
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            if (remainingGlobalContext.isEmpty) {
              next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);
              previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
              remainingGlobalContext = void 0;
            } else {
              previousContext = this.getReturnState(remainingGlobalContext);
              next = s0.getContextTarget(previousContext);
              initialContext = initialContext.appendSingleContext(previousContext, contextCache);
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            if (next == null) {
              break;
            }
            s0 = next;
          }
        }
        if (s0 != null && !s0.isContextSensitive) {
          return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
        }
        let configs = new ATNConfigSet_1.ATNConfigSet();
        while (true) {
          let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
          let n = p.numberOfTransitions;
          for (let ti = 0; ti < n; ti++) {
            let target = p.transition(ti).target;
            reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));
          }
          let hasMoreContext = remainingGlobalContext != null;
          if (!hasMoreContext) {
            configs.isOutermostConfigSet = true;
          }
          let collectPredicates = true;
          this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);
          let stepIntoGlobal = configs.dipsIntoOuterContext;
          let next;
          if (useContext && !this.enable_global_context_dfa) {
            s0 = this.addDFAState(dfa, configs, contextCache);
            break;
          } else if (s0 == null) {
            if (!dfa.isPrecedenceDfa) {
              next = this.addDFAState(dfa, configs, contextCache);
              if (useContext) {
                if (!dfa.s0full) {
                  dfa.s0full = next;
                } else {
                  next = dfa.s0full;
                }
              } else {
                if (!dfa.s0) {
                  dfa.s0 = next;
                } else {
                  next = dfa.s0;
                }
              }
            } else {
              configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
              next = this.addDFAState(dfa, configs, contextCache);
              dfa.setPrecedenceStartState(this._parser.precedence, useContext, next);
            }
          } else {
            if (dfa.isPrecedenceDfa) {
              configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
            }
            next = this.addDFAState(dfa, configs, contextCache);
            s0.setContextTarget(previousContext, next);
          }
          s0 = next;
          if (!useContext || !stepIntoGlobal) {
            break;
          }
          next.setContextSensitive(this.atn);
          remainingGlobalContext = remainingGlobalContext;
          configs.clear();
          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
          let nextContextElement = this.getReturnState(remainingGlobalContext);
          if (remainingGlobalContext.isEmpty) {
            remainingGlobalContext = void 0;
          } else {
            remainingGlobalContext = remainingGlobalContext.parent;
          }
          if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);
          }
          previousContext = nextContextElement;
        }
        return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
      }
      applyPrecedenceFilter(configs, globalContext, contextCache) {
        let statesFromAlt1 = /* @__PURE__ */ new Map();
        let configSet = new ATNConfigSet_1.ATNConfigSet();
        for (let config of configs) {
          if (config.alt !== 1) {
            continue;
          }
          let updatedContext = config.semanticContext.evalPrecedence(this._parser, globalContext);
          if (updatedContext == null) {
            continue;
          }
          statesFromAlt1.set(config.state.stateNumber, config.context);
          if (updatedContext !== config.semanticContext) {
            configSet.add(config.transform(config.state, false, updatedContext), contextCache);
          } else {
            configSet.add(config, contextCache);
          }
        }
        for (let config of configs) {
          if (config.alt === 1) {
            continue;
          }
          if (!config.isPrecedenceFilterSuppressed) {
            let context = statesFromAlt1.get(config.state.stateNumber);
            if (context != null && context.equals(config.context)) {
              continue;
            }
          }
          configSet.add(config, contextCache);
        }
        return configSet;
      }
      getReachableTarget(source, trans, ttype) {
        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
          return trans.target;
        }
        return void 0;
      }
      predicateDFAState(D, configs, nalts) {
        let conflictingAlts = this.getConflictingAltsFromConfigSet(configs);
        if (!conflictingAlts) {
          throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");
        }
        if (ParserATNSimulator3.debug) {
          console.log("predicateDFAState " + D);
        }
        let altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);
        let predPredictions;
        if (altToPred != null) {
          predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);
          D.predicates = predPredictions;
        }
        return predPredictions;
      }
      getPredsForAmbigAlts(ambigAlts, configs, nalts) {
        let altToPred = new Array(nalts + 1);
        let n = altToPred.length;
        for (let c of configs) {
          if (ambigAlts.get(c.alt)) {
            altToPred[c.alt] = SemanticContext_1.SemanticContext.or(altToPred[c.alt], c.semanticContext);
          }
        }
        let nPredAlts = 0;
        for (let i = 0; i < n; i++) {
          if (altToPred[i] == null) {
            altToPred[i] = SemanticContext_1.SemanticContext.NONE;
          } else if (altToPred[i] !== SemanticContext_1.SemanticContext.NONE) {
            nPredAlts++;
          }
        }
        let result = altToPred;
        if (nPredAlts === 0) {
          result = void 0;
        }
        if (ParserATNSimulator3.debug) {
          console.log("getPredsForAmbigAlts result " + (result ? Arrays_1.Arrays.toString(result) : "undefined"));
        }
        return result;
      }
      getPredicatePredictions(ambigAlts, altToPred) {
        let pairs = [];
        let containsPredicate = false;
        for (let i = 1; i < altToPred.length; i++) {
          let pred = altToPred[i];
          assert(pred != null);
          if (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext_1.SemanticContext.NONE) {
            pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
          } else if (pred !== SemanticContext_1.SemanticContext.NONE) {
            containsPredicate = true;
            pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
          }
        }
        if (!containsPredicate) {
          return void 0;
        }
        return pairs;
      }
      evalSemanticContext(predPredictions, outerContext, complete) {
        let predictions = new BitSet_1.BitSet();
        for (let pair of predPredictions) {
          if (pair.pred === SemanticContext_1.SemanticContext.NONE) {
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
            continue;
          }
          let evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);
          if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
            console.log("eval pred " + pair + "=" + evaluatedResult);
          }
          if (evaluatedResult) {
            if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
              console.log("PREDICT " + pair.alt);
            }
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
          }
        }
        return predictions;
      }
      evalSemanticContextImpl(pred, parserCallStack, alt) {
        return pred.eval(this._parser, parserCallStack);
      }
      closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {
        if (contextCache == null) {
          contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
        }
        let currentConfigs = sourceConfigs;
        let closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        while (currentConfigs.size > 0) {
          let intermediate = new ATNConfigSet_1.ATNConfigSet();
          for (let config of currentConfigs) {
            this.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);
          }
          currentConfigs = intermediate;
        }
      }
      closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {
        if (ParserATNSimulator3.debug) {
          console.log("closure(" + config.toString(this._parser, true) + ")");
        }
        if (config.state instanceof RuleStopState_1.RuleStopState) {
          if (!config.context.isEmpty) {
            let hasEmpty = config.context.hasEmpty;
            let nonEmptySize = config.context.size - (hasEmpty ? 1 : 0);
            for (let i = 0; i < nonEmptySize; i++) {
              let newContext = config.context.getParent(i);
              let returnState = this.atn.states[config.context.getReturnState(i)];
              let c = ATNConfig_1.ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);
              c.outerContextDepth = config.outerContextDepth;
              c.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;
              assert(depth > MIN_INTEGER_VALUE);
              this.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);
            }
            if (!hasEmpty || !hasMoreContexts) {
              return;
            }
            config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
          } else if (!hasMoreContexts) {
            configs.add(config, contextCache);
            return;
          } else {
            if (ParserATNSimulator3.debug) {
              console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
            }
            if (config.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {
              config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
            } else if (!config.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
              configs.add(config, contextCache);
            }
          }
        }
        let p = config.state;
        if (!p.onlyHasEpsilonTransitions) {
          configs.add(config, contextCache);
          if (ParserATNSimulator3.debug) {
            console.log("added config " + configs);
          }
        }
        for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
          if (i === 0 && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY && p.precedenceRuleDecision && !config.context.hasEmpty) {
            let precedenceDecision = p;
            let suppress = true;
            for (let j = 0; j < config.context.size; j++) {
              if (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {
                suppress = false;
                break;
              }
            }
            if (suppress) {
              continue;
            }
          }
          let t = p.getOptimizedTransition(i);
          let continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;
          let c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);
          if (c != null) {
            if (t instanceof RuleTransition_1.RuleTransition) {
              if (intermediate != null && !collectPredicates) {
                intermediate.add(c, contextCache);
                continue;
              }
            }
            let newDepth = depth;
            if (config.state instanceof RuleStopState_1.RuleStopState) {
              if (this.dfa != null && this.dfa.isPrecedenceDfa) {
                let outermostPrecedenceReturn = t.outermostPrecedenceReturn;
                if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {
                  c.isPrecedenceFilterSuppressed = true;
                }
              }
              c.outerContextDepth = c.outerContextDepth + 1;
              if (!closureBusy.add(c)) {
                continue;
              }
              assert(newDepth > MIN_INTEGER_VALUE);
              newDepth--;
              if (ParserATNSimulator3.debug) {
                console.log("dips into outer ctx: " + c);
              }
            } else if (t instanceof RuleTransition_1.RuleTransition) {
              if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
                assert(c.context === config.context);
                if (newDepth === 0) {
                  newDepth--;
                  if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
                    c.outerContextDepth = c.outerContextDepth + 1;
                  }
                }
              } else {
                if (newDepth >= 0) {
                  newDepth++;
                }
              }
            } else {
              if (!t.isEpsilon && !closureBusy.add(c)) {
                continue;
              }
            }
            this.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);
          }
        }
      }
      getRuleName(index2) {
        if (this._parser != null && index2 >= 0) {
          return this._parser.ruleNames[index2];
        }
        return "<rule " + index2 + ">";
      }
      getEpsilonTarget(config, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {
        switch (t.serializationType) {
          case 3:
            return this.ruleTransition(config, t, contextCache);
          case 10:
            return this.precedenceTransition(config, t, collectPredicates, inContext);
          case 4:
            return this.predTransition(config, t, collectPredicates, inContext);
          case 6:
            return this.actionTransition(config, t);
          case 1:
            return config.transform(t.target, false);
          case 5:
          case 2:
          case 7:
            if (treatEofAsEpsilon) {
              if (t.matches(Token_1.Token.EOF, 0, 1)) {
                return config.transform(t.target, false);
              }
            }
            return void 0;
          default:
            return void 0;
        }
      }
      actionTransition(config, t) {
        if (ParserATNSimulator3.debug) {
          console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
        }
        return config.transform(t.target, false);
      }
      precedenceTransition(config, pt, collectPredicates, inContext) {
        if (ParserATNSimulator3.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
          if (this._parser != null) {
            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
          }
        }
        let c;
        if (collectPredicates && inContext) {
          let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
          c = config.transform(pt.target, false, newSemCtx);
        } else {
          c = config.transform(pt.target, false);
        }
        if (ParserATNSimulator3.debug) {
          console.log("config from pred transition=" + c);
        }
        return c;
      }
      predTransition(config, pt, collectPredicates, inContext) {
        if (ParserATNSimulator3.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
          if (this._parser != null) {
            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
          }
        }
        let c;
        if (collectPredicates && (!pt.isCtxDependent || pt.isCtxDependent && inContext)) {
          let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
          c = config.transform(pt.target, false, newSemCtx);
        } else {
          c = config.transform(pt.target, false);
        }
        if (ParserATNSimulator3.debug) {
          console.log("config from pred transition=" + c);
        }
        return c;
      }
      ruleTransition(config, t, contextCache) {
        if (ParserATNSimulator3.debug) {
          console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
        }
        let returnState = t.followState;
        let newContext;
        if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
          newContext = config.context;
        } else if (contextCache != null) {
          newContext = contextCache.getChild(config.context, returnState.stateNumber);
        } else {
          newContext = config.context.getChild(returnState.stateNumber);
        }
        return config.transform(t.target, false, newContext);
      }
      isConflicted(configset, contextCache) {
        if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {
          return void 0;
        }
        let configs = configset.toArray();
        configs.sort(ParserATNSimulator3.STATE_ALT_SORT_COMPARATOR);
        let exact = !configset.dipsIntoOuterContext;
        let alts = new BitSet_1.BitSet();
        let minAlt = configs[0].alt;
        alts.set(minAlt);
        let currentState = configs[0].state.nonStopStateNumber;
        for (let config of configs) {
          let stateNumber = config.state.nonStopStateNumber;
          if (stateNumber !== currentState) {
            if (config.alt !== minAlt) {
              return void 0;
            }
            currentState = stateNumber;
          }
        }
        let representedAlts;
        if (exact) {
          currentState = configs[0].state.nonStopStateNumber;
          representedAlts = new BitSet_1.BitSet();
          let maxAlt = minAlt;
          for (let config of configs) {
            if (config.state.nonStopStateNumber !== currentState) {
              break;
            }
            let alt = config.alt;
            representedAlts.set(alt);
            maxAlt = alt;
          }
          currentState = configs[0].state.nonStopStateNumber;
          let currentAlt = minAlt;
          for (let config of configs) {
            let stateNumber = config.state.nonStopStateNumber;
            let alt = config.alt;
            if (stateNumber !== currentState) {
              if (currentAlt !== maxAlt) {
                exact = false;
                break;
              }
              currentState = stateNumber;
              currentAlt = minAlt;
            } else if (alt !== currentAlt) {
              if (alt !== representedAlts.nextSetBit(currentAlt + 1)) {
                exact = false;
                break;
              }
              currentAlt = alt;
            }
          }
        }
        currentState = configs[0].state.nonStopStateNumber;
        let firstIndexCurrentState = 0;
        let lastIndexCurrentStateMinAlt = 0;
        let joinedCheckContext = configs[0].context;
        for (let i = 1; i < configs.length; i++) {
          let config = configs[i];
          if (config.alt !== minAlt) {
            break;
          }
          if (config.state.nonStopStateNumber !== currentState) {
            break;
          }
          lastIndexCurrentStateMinAlt = i;
          joinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);
        }
        for (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {
          let config = configs[i];
          let state = config.state;
          alts.set(config.alt);
          if (state.nonStopStateNumber !== currentState) {
            currentState = state.nonStopStateNumber;
            firstIndexCurrentState = i;
            lastIndexCurrentStateMinAlt = i;
            joinedCheckContext = config.context;
            for (let j = firstIndexCurrentState + 1; j < configs.length; j++) {
              let config2 = configs[j];
              if (config2.alt !== minAlt) {
                break;
              }
              if (config2.state.nonStopStateNumber !== currentState) {
                break;
              }
              lastIndexCurrentStateMinAlt = j;
              joinedCheckContext = contextCache.join(joinedCheckContext, config2.context);
            }
            i = lastIndexCurrentStateMinAlt;
            continue;
          }
          let joinedCheckContext2 = config.context;
          let currentAlt = config.alt;
          let lastIndexCurrentStateCurrentAlt = i;
          for (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {
            let config2 = configs[j];
            if (config2.alt !== currentAlt) {
              break;
            }
            if (config2.state.nonStopStateNumber !== currentState) {
              break;
            }
            lastIndexCurrentStateCurrentAlt = j;
            joinedCheckContext2 = contextCache.join(joinedCheckContext2, config2.context);
          }
          i = lastIndexCurrentStateCurrentAlt;
          let check = contextCache.join(joinedCheckContext, joinedCheckContext2);
          if (!joinedCheckContext.equals(check)) {
            return void 0;
          }
          exact = exact && joinedCheckContext.equals(joinedCheckContext2);
        }
        return new ConflictInfo_1.ConflictInfo(alts, exact);
      }
      getConflictingAltsFromConfigSet(configs) {
        let conflictingAlts = configs.conflictingAlts;
        if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          conflictingAlts = new BitSet_1.BitSet();
          conflictingAlts.set(configs.uniqueAlt);
        }
        return conflictingAlts;
      }
      getTokenName(t) {
        if (t === Token_1.Token.EOF) {
          return "EOF";
        }
        let vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        let displayName = vocabulary.getDisplayName(t);
        if (displayName === String(t)) {
          return displayName;
        }
        return displayName + "<" + t + ">";
      }
      getLookaheadName(input) {
        return this.getTokenName(input.LA(1));
      }
      dumpDeadEndConfigs(nvae) {
        console.log("dead end configs: ");
        let deadEndConfigs = nvae.deadEndConfigs;
        if (!deadEndConfigs) {
          return;
        }
        for (let c of deadEndConfigs) {
          let trans = "no edges";
          if (c.state.numberOfOptimizedTransitions > 0) {
            let t = c.state.getOptimizedTransition(0);
            if (t instanceof AtomTransition_1.AtomTransition) {
              trans = "Atom " + this.getTokenName(t._label);
            } else if (t instanceof SetTransition_1.SetTransition) {
              let not = t instanceof NotSetTransition_1.NotSetTransition;
              trans = (not ? "~" : "") + "Set " + t.set.toString();
            }
          }
          console.log(c.toString(this._parser, true) + ":" + trans);
        }
      }
      noViableAlt(input, outerContext, configs, startIndex) {
        return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
      }
      getUniqueAlt(configs) {
        let alt = ATN_1.ATN.INVALID_ALT_NUMBER;
        for (let c of configs) {
          if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {
            alt = c.alt;
          } else if (c.alt !== alt) {
            return ATN_1.ATN.INVALID_ALT_NUMBER;
          }
        }
        return alt;
      }
      configWithAltAtStopState(configs, alt) {
        for (let c of configs) {
          if (c.alt === alt) {
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              return true;
            }
          }
        }
        return false;
      }
      addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {
        assert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);
        let from = fromState;
        let to = this.addDFAState(dfa, toConfigs, contextCache);
        if (contextTransitions != null) {
          for (let context of contextTransitions.toArray()) {
            if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              if (from.configs.isOutermostConfigSet) {
                continue;
              }
            }
            from.setContextSensitive(this.atn);
            from.setContextSymbol(t);
            let next = from.getContextTarget(context);
            if (next != null) {
              from = next;
              continue;
            }
            next = this.addDFAContextState(dfa, from.configs, context, contextCache);
            assert(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);
            from.setContextTarget(context, next);
            from = next;
          }
        }
        if (ParserATNSimulator3.debug) {
          console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
        }
        this.setDFAEdge(from, t, to);
        if (ParserATNSimulator3.debug) {
          console.log("DFA=\n" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : void 0));
        }
        return to;
      }
      setDFAEdge(p, t, q) {
        if (p != null) {
          p.setTarget(t, q);
        }
      }
      addDFAContextState(dfa, configs, returnContext, contextCache) {
        if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          let contextConfigs = new ATNConfigSet_1.ATNConfigSet();
          for (let config of configs) {
            contextConfigs.add(config.appendContext(returnContext, contextCache));
          }
          return this.addDFAState(dfa, contextConfigs, contextCache);
        } else {
          assert(!configs.isOutermostConfigSet, "Shouldn't be adding a duplicate edge.");
          configs = configs.clone(true);
          configs.isOutermostConfigSet = true;
          return this.addDFAState(dfa, configs, contextCache);
        }
      }
      addDFAState(dfa, configs, contextCache) {
        let enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;
        if (enableDfa) {
          if (!configs.isReadOnly) {
            configs.optimizeConfigs(this);
          }
          let proposed = this.createDFAState(dfa, configs);
          let existing = dfa.states.get(proposed);
          if (existing != null) {
            return existing;
          }
        }
        if (!configs.isReadOnly) {
          if (configs.conflictInfo == null) {
            configs.conflictInfo = this.isConflicted(configs, contextCache);
          }
        }
        let newState = this.createDFAState(dfa, configs.clone(true));
        let decisionState = this.atn.getDecisionState(dfa.decision);
        let predictedAlt = this.getUniqueAlt(configs);
        if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);
        } else if (configs.conflictingAlts != null) {
          let conflictingAlts = configs.conflictingAlts;
          if (conflictingAlts) {
            newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));
          }
        }
        if (newState.isAcceptState && configs.hasSemanticContext) {
          this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);
        }
        if (!enableDfa) {
          return newState;
        }
        let added = dfa.addState(newState);
        if (ParserATNSimulator3.debug && added === newState) {
          console.log("adding new DFA state: " + newState);
        }
        return added;
      }
      createDFAState(dfa, configs) {
        return new DFAState_1.DFAState(configs);
      }
      reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
        if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + conflictState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportAttemptingFullContext) {
            listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
          }
        }
      }
      reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
        if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportContextSensitivity decision=" + dfa.decision + ":" + acceptState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportContextSensitivity) {
            listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);
          }
        }
      }
      reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportAmbiguity) {
            listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
          }
        }
      }
      getReturnState(context) {
        if (context.isEmpty) {
          return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
        }
        let state = this.atn.states[context.invokingState];
        let transition = state.transition(0);
        return transition.followState.stateNumber;
      }
      skipTailCalls(context) {
        if (!this.optimize_tail_calls) {
          return context;
        }
        while (!context.isEmpty) {
          let state = this.atn.states[context.invokingState];
          assert(state.numberOfTransitions === 1 && state.transition(0).serializationType === 3);
          let transition = state.transition(0);
          if (!transition.tailCall) {
            break;
          }
          context = context.parent;
        }
        return context;
      }
      get parser() {
        return this._parser;
      }
    };
    ParserATNSimulator2.debug = false;
    ParserATNSimulator2.dfa_debug = false;
    ParserATNSimulator2.retry_debug = false;
    ParserATNSimulator2.STATE_ALT_SORT_COMPARATOR = (o1, o2) => {
      let diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;
      if (diff !== 0) {
        return diff;
      }
      diff = o1.alt - o2.alt;
      if (diff !== 0) {
        return diff;
      }
      return 0;
    };
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "predictionMode", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "getPredictionMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "setPredictionMode", null);
    __decorate([
      Decorators_1.Override
    ], ParserATNSimulator2.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "adaptivePredict", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getStartState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "execDFA", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "execATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "handleNoViableAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "computeTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "removeAllConfigsNotInRuleStopState", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "computeStartState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "applyPrecedenceFilter", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getReachableTarget", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getPredsForAmbigAlts", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "evalSemanticContext", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "evalSemanticContextImpl", null);
    __decorate([
      __param(1, Decorators_1.NotNull),
      __param(4, Decorators_1.Nullable)
    ], ParserATNSimulator2.prototype, "closure", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.Nullable),
      __param(3, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "closureImpl", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "getRuleName", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getEpsilonTarget", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "actionTransition", null);
    __decorate([
      Decorators_1.Nullable,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "precedenceTransition", null);
    __decorate([
      Decorators_1.Nullable,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "predTransition", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.Nullable)
    ], ParserATNSimulator2.prototype, "ruleTransition", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "isConflicted", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "getTokenName", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "dumpDeadEndConfigs", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "noViableAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getUniqueAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "configWithAltAtStopState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "addDFAEdge", null);
    __decorate([
      __param(0, Decorators_1.Nullable),
      __param(2, Decorators_1.Nullable)
    ], ParserATNSimulator2.prototype, "setDFAEdge", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "addDFAContextState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "addDFAState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "createDFAState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "reportAttemptingFullContext", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "reportContextSensitivity", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "reportAmbiguity", null);
    ParserATNSimulator2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2);
    exports.ParserATNSimulator = ParserATNSimulator2;
  }
});

// node_modules/antlr4ts/atn/PlusBlockStartState.js
var require_PlusBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/PlusBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlusBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var PlusBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.PLUS_BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PlusBlockStartState.prototype, "stateType", null);
    exports.PlusBlockStartState = PlusBlockStartState;
  }
});

// node_modules/antlr4ts/atn/PlusLoopbackState.js
var require_PlusLoopbackState = __commonJS({
  "node_modules/antlr4ts/atn/PlusLoopbackState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlusLoopbackState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var PlusLoopbackState = class extends DecisionState_1.DecisionState {
      get stateType() {
        return ATNStateType_1.ATNStateType.PLUS_LOOP_BACK;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PlusLoopbackState.prototype, "stateType", null);
    exports.PlusLoopbackState = PlusLoopbackState;
  }
});

// node_modules/antlr4ts/atn/PrecedencePredicateTransition.js
var require_PrecedencePredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/PrecedencePredicateTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrecedencePredicateTransition = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Decorators_1 = require_Decorators();
    var SemanticContext_1 = require_SemanticContext();
    var PrecedencePredicateTransition = class PrecedencePredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
      constructor(target, precedence) {
        super(target);
        this.precedence = precedence;
      }
      get serializationType() {
        return 10;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      get predicate() {
        return new SemanticContext_1.SemanticContext.PrecedencePredicate(this.precedence);
      }
      toString() {
        return this.precedence + " >= _p";
      }
    };
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "toString", null);
    PrecedencePredicateTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], PrecedencePredicateTransition);
    exports.PrecedencePredicateTransition = PrecedencePredicateTransition;
  }
});

// node_modules/antlr4ts/atn/RangeTransition.js
var require_RangeTransition = __commonJS({
  "node_modules/antlr4ts/atn/RangeTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RangeTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var RangeTransition = class RangeTransition extends Transition_1.Transition {
      constructor(target, from, to) {
        super(target);
        this.from = from;
        this.to = to;
      }
      get serializationType() {
        return 2;
      }
      get label() {
        return IntervalSet_1.IntervalSet.of(this.from, this.to);
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= this.from && symbol <= this.to;
      }
      toString() {
        return "'" + String.fromCodePoint(this.from) + "'..'" + String.fromCodePoint(this.to) + "'";
      }
    };
    __decorate([
      Decorators_1.Override
    ], RangeTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], RangeTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], RangeTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], RangeTransition.prototype, "toString", null);
    RangeTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], RangeTransition);
    exports.RangeTransition = RangeTransition;
  }
});

// node_modules/antlr4ts/atn/RuleStartState.js
var require_RuleStartState = __commonJS({
  "node_modules/antlr4ts/atn/RuleStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleStartState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var RuleStartState = class extends ATNState_1.ATNState {
      constructor() {
        super(...arguments);
        this.isPrecedenceRule = false;
        this.leftFactored = false;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.RULE_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleStartState.prototype, "stateType", null);
    exports.RuleStartState = RuleStartState;
  }
});

// node_modules/antlr4ts/atn/StarBlockStartState.js
var require_StarBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/StarBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var StarBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarBlockStartState.prototype, "stateType", null);
    exports.StarBlockStartState = StarBlockStartState;
  }
});

// node_modules/antlr4ts/atn/StarLoopbackState.js
var require_StarLoopbackState = __commonJS({
  "node_modules/antlr4ts/atn/StarLoopbackState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarLoopbackState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var StarLoopbackState = class extends ATNState_1.ATNState {
      get loopEntryState() {
        return this.transition(0).target;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_LOOP_BACK;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarLoopbackState.prototype, "stateType", null);
    exports.StarLoopbackState = StarLoopbackState;
  }
});

// node_modules/antlr4ts/atn/TokensStartState.js
var require_TokensStartState = __commonJS({
  "node_modules/antlr4ts/atn/TokensStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokensStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var TokensStartState = class extends DecisionState_1.DecisionState {
      get stateType() {
        return ATNStateType_1.ATNStateType.TOKEN_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], TokensStartState.prototype, "stateType", null);
    exports.TokensStartState = TokensStartState;
  }
});

// node_modules/antlr4ts/misc/UUID.js
var require_UUID = __commonJS({
  "node_modules/antlr4ts/misc/UUID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UUID = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var UUID = class {
      constructor(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {
        this.data = new Uint32Array(4);
        this.data[0] = mostSigBits;
        this.data[1] = moreSigBits;
        this.data[2] = lessSigBits;
        this.data[3] = leastSigBits;
      }
      static fromString(data) {
        if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {
          throw new Error("Incorrectly formatted UUID");
        }
        let segments = data.split("-");
        let mostSigBits = parseInt(segments[0], 16);
        let moreSigBits = (parseInt(segments[1], 16) << 16 >>> 0) + parseInt(segments[2], 16);
        let lessSigBits = (parseInt(segments[3], 16) << 16 >>> 0) + parseInt(segments[4].substr(0, 4), 16);
        let leastSigBits = parseInt(segments[4].substr(-8), 16);
        return new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
      }
      hashCode() {
        return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof UUID)) {
          return false;
        }
        return this.data[0] === obj.data[0] && this.data[1] === obj.data[1] && this.data[2] === obj.data[2] && this.data[3] === obj.data[3];
      }
      toString() {
        return ("00000000" + this.data[0].toString(16)).substr(-8) + "-" + ("0000" + (this.data[1] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[1].toString(16)).substr(-4) + "-" + ("0000" + (this.data[2] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[2].toString(16)).substr(-4) + ("00000000" + this.data[3].toString(16)).substr(-8);
      }
    };
    exports.UUID = UUID;
  }
});

// node_modules/antlr4ts/atn/ATNDeserializer.js
var require_ATNDeserializer = __commonJS({
  "node_modules/antlr4ts/atn/ATNDeserializer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNDeserializer = void 0;
    var ActionTransition_1 = require_ActionTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATN_1 = require_ATN();
    var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
    var ATNStateType_1 = require_ATNStateType();
    var AtomTransition_1 = require_AtomTransition();
    var BasicBlockStartState_1 = require_BasicBlockStartState();
    var BasicState_1 = require_BasicState();
    var BitSet_1 = require_BitSet();
    var BlockEndState_1 = require_BlockEndState();
    var BlockStartState_1 = require_BlockStartState();
    var DecisionState_1 = require_DecisionState();
    var DFA_1 = require_DFA();
    var EpsilonTransition_1 = require_EpsilonTransition();
    var IntervalSet_1 = require_IntervalSet();
    var InvalidState_1 = require_InvalidState();
    var LexerChannelAction_1 = require_LexerChannelAction();
    var LexerCustomAction_1 = require_LexerCustomAction();
    var LexerModeAction_1 = require_LexerModeAction();
    var LexerMoreAction_1 = require_LexerMoreAction();
    var LexerPopModeAction_1 = require_LexerPopModeAction();
    var LexerPushModeAction_1 = require_LexerPushModeAction();
    var LexerSkipAction_1 = require_LexerSkipAction();
    var LexerTypeAction_1 = require_LexerTypeAction();
    var LoopEndState_1 = require_LoopEndState();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var PlusBlockStartState_1 = require_PlusBlockStartState();
    var PlusLoopbackState_1 = require_PlusLoopbackState();
    var PrecedencePredicateTransition_1 = require_PrecedencePredicateTransition();
    var PredicateTransition_1 = require_PredicateTransition();
    var RangeTransition_1 = require_RangeTransition();
    var RuleStartState_1 = require_RuleStartState();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var SetTransition_1 = require_SetTransition();
    var StarBlockStartState_1 = require_StarBlockStartState();
    var StarLoopbackState_1 = require_StarLoopbackState();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var Token_1 = require_Token();
    var TokensStartState_1 = require_TokensStartState();
    var UUID_1 = require_UUID();
    var WildcardTransition_1 = require_WildcardTransition();
    var UnicodeDeserializingMode;
    (function(UnicodeDeserializingMode2) {
      UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_BMP"] = 0] = "UNICODE_BMP";
      UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_SMP"] = 1] = "UNICODE_SMP";
    })(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));
    var ATNDeserializer3 = class {
      constructor(deserializationOptions) {
        if (deserializationOptions === void 0) {
          deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;
        }
        this.deserializationOptions = deserializationOptions;
      }
      static get SERIALIZED_VERSION() {
        return 3;
      }
      static isFeatureSupported(feature, actualUuid) {
        let featureIndex = ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));
        if (featureIndex < 0) {
          return false;
        }
        return ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;
      }
      static getUnicodeDeserializer(mode) {
        if (mode === 0) {
          return {
            readUnicode: (data, p) => {
              return ATNDeserializer3.toInt(data[p]);
            },
            size: 1
          };
        } else {
          return {
            readUnicode: (data, p) => {
              return ATNDeserializer3.toInt32(data, p);
            },
            size: 2
          };
        }
      }
      deserialize(data) {
        data = data.slice(0);
        for (let i = 1; i < data.length; i++) {
          data[i] = data[i] - 2 & 65535;
        }
        let p = 0;
        let version = ATNDeserializer3.toInt(data[p++]);
        if (version !== ATNDeserializer3.SERIALIZED_VERSION) {
          let reason = `Could not deserialize ATN with version ${version} (expected ${ATNDeserializer3.SERIALIZED_VERSION}).`;
          throw new Error(reason);
        }
        let uuid = ATNDeserializer3.toUUID(data, p);
        p += 8;
        if (ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {
          let reason = `Could not deserialize ATN with UUID ${uuid} (expected ${ATNDeserializer3.SERIALIZED_UUID} or a legacy UUID).`;
          throw new Error(reason);
        }
        let supportsLexerActions = ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_LEXER_ACTIONS, uuid);
        let grammarType = ATNDeserializer3.toInt(data[p++]);
        let maxTokenType = ATNDeserializer3.toInt(data[p++]);
        let atn = new ATN_1.ATN(grammarType, maxTokenType);
        let loopBackStateNumbers = [];
        let endStateNumbers = [];
        let nstates = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nstates; i++) {
          let stype = ATNDeserializer3.toInt(data[p++]);
          if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {
            atn.addState(new InvalidState_1.InvalidState());
            continue;
          }
          let ruleIndex = ATNDeserializer3.toInt(data[p++]);
          if (ruleIndex === 65535) {
            ruleIndex = -1;
          }
          let s = this.stateFactory(stype, ruleIndex);
          if (stype === ATNStateType_1.ATNStateType.LOOP_END) {
            let loopBackStateNumber = ATNDeserializer3.toInt(data[p++]);
            loopBackStateNumbers.push([s, loopBackStateNumber]);
          } else if (s instanceof BlockStartState_1.BlockStartState) {
            let endStateNumber = ATNDeserializer3.toInt(data[p++]);
            endStateNumbers.push([s, endStateNumber]);
          }
          atn.addState(s);
        }
        for (let pair of loopBackStateNumbers) {
          pair[0].loopBackState = atn.states[pair[1]];
        }
        for (let pair of endStateNumbers) {
          pair[0].endState = atn.states[pair[1]];
        }
        let numNonGreedyStates = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < numNonGreedyStates; i++) {
          let stateNumber = ATNDeserializer3.toInt(data[p++]);
          atn.states[stateNumber].nonGreedy = true;
        }
        let numSllDecisions = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < numSllDecisions; i++) {
          let stateNumber = ATNDeserializer3.toInt(data[p++]);
          atn.states[stateNumber].sll = true;
        }
        let numPrecedenceStates = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < numPrecedenceStates; i++) {
          let stateNumber = ATNDeserializer3.toInt(data[p++]);
          atn.states[stateNumber].isPrecedenceRule = true;
        }
        let nrules = ATNDeserializer3.toInt(data[p++]);
        if (atn.grammarType === 0) {
          atn.ruleToTokenType = new Int32Array(nrules);
        }
        atn.ruleToStartState = new Array(nrules);
        for (let i = 0; i < nrules; i++) {
          let s = ATNDeserializer3.toInt(data[p++]);
          let startState = atn.states[s];
          startState.leftFactored = ATNDeserializer3.toInt(data[p++]) !== 0;
          atn.ruleToStartState[i] = startState;
          if (atn.grammarType === 0) {
            let tokenType = ATNDeserializer3.toInt(data[p++]);
            if (tokenType === 65535) {
              tokenType = Token_1.Token.EOF;
            }
            atn.ruleToTokenType[i] = tokenType;
            if (!ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_LEXER_ACTIONS, uuid)) {
              let actionIndexIgnored = ATNDeserializer3.toInt(data[p++]);
              if (actionIndexIgnored === 65535) {
                actionIndexIgnored = -1;
              }
            }
          }
        }
        atn.ruleToStopState = new Array(nrules);
        for (let state of atn.states) {
          if (!(state instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          atn.ruleToStopState[state.ruleIndex] = state;
          atn.ruleToStartState[state.ruleIndex].stopState = state;
        }
        let nmodes = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nmodes; i++) {
          let s = ATNDeserializer3.toInt(data[p++]);
          atn.modeToStartState.push(atn.states[s]);
        }
        atn.modeToDFA = new Array(nmodes);
        for (let i = 0; i < nmodes; i++) {
          atn.modeToDFA[i] = new DFA_1.DFA(atn.modeToStartState[i]);
        }
        let sets = [];
        p = this.deserializeSets(data, p, sets, ATNDeserializer3.getUnicodeDeserializer(0));
        if (ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_UNICODE_SMP, uuid)) {
          p = this.deserializeSets(data, p, sets, ATNDeserializer3.getUnicodeDeserializer(1));
        }
        let nedges = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nedges; i++) {
          let src = ATNDeserializer3.toInt(data[p]);
          let trg = ATNDeserializer3.toInt(data[p + 1]);
          let ttype = ATNDeserializer3.toInt(data[p + 2]);
          let arg1 = ATNDeserializer3.toInt(data[p + 3]);
          let arg2 = ATNDeserializer3.toInt(data[p + 4]);
          let arg3 = ATNDeserializer3.toInt(data[p + 5]);
          let trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
          let srcState = atn.states[src];
          srcState.addTransition(trans);
          p += 6;
        }
        let returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({
          hashCode: (o) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,
          equals: (a, b) => {
            return a.stopState === b.stopState && a.returnState === b.returnState && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;
          }
        });
        let returnTransitions = [];
        for (let state of atn.states) {
          let returningToLeftFactored = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;
          for (let i = 0; i < state.numberOfTransitions; i++) {
            let t = state.transition(i);
            if (!(t instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            let ruleTransition = t;
            let returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;
            if (!returningFromLeftFactored && returningToLeftFactored) {
              continue;
            }
            let outermostPrecedenceReturn = -1;
            if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {
              if (ruleTransition.precedence === 0) {
                outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
              }
            }
            let current = { stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn };
            if (returnTransitionsSet.add(current)) {
              returnTransitions.push(current);
            }
          }
        }
        for (let returnTransition of returnTransitions) {
          let transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);
          atn.ruleToStopState[returnTransition.stopState].addTransition(transition);
        }
        for (let state of atn.states) {
          if (state instanceof BlockStartState_1.BlockStartState) {
            if (state.endState === void 0) {
              throw new Error("IllegalStateException");
            }
            if (state.endState.startState !== void 0) {
              throw new Error("IllegalStateException");
            }
            state.endState.startState = state;
          }
          if (state instanceof PlusLoopbackState_1.PlusLoopbackState) {
            let loopbackState = state;
            for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
              let target = loopbackState.transition(i).target;
              if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {
                target.loopBackState = loopbackState;
              }
            }
          } else if (state instanceof StarLoopbackState_1.StarLoopbackState) {
            let loopbackState = state;
            for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
              let target = loopbackState.transition(i).target;
              if (target instanceof StarLoopEntryState_1.StarLoopEntryState) {
                target.loopBackState = loopbackState;
              }
            }
          }
        }
        let ndecisions = ATNDeserializer3.toInt(data[p++]);
        for (let i = 1; i <= ndecisions; i++) {
          let s = ATNDeserializer3.toInt(data[p++]);
          let decState = atn.states[s];
          atn.decisionToState.push(decState);
          decState.decision = i - 1;
        }
        if (atn.grammarType === 0) {
          if (supportsLexerActions) {
            atn.lexerActions = new Array(ATNDeserializer3.toInt(data[p++]));
            for (let i = 0; i < atn.lexerActions.length; i++) {
              let actionType = ATNDeserializer3.toInt(data[p++]);
              let data1 = ATNDeserializer3.toInt(data[p++]);
              if (data1 === 65535) {
                data1 = -1;
              }
              let data2 = ATNDeserializer3.toInt(data[p++]);
              if (data2 === 65535) {
                data2 = -1;
              }
              let lexerAction = this.lexerActionFactory(actionType, data1, data2);
              atn.lexerActions[i] = lexerAction;
            }
          } else {
            let legacyLexerActions = [];
            for (let state of atn.states) {
              for (let i = 0; i < state.numberOfTransitions; i++) {
                let transition = state.transition(i);
                if (!(transition instanceof ActionTransition_1.ActionTransition)) {
                  continue;
                }
                let ruleIndex = transition.ruleIndex;
                let actionIndex = transition.actionIndex;
                let lexerAction = new LexerCustomAction_1.LexerCustomAction(ruleIndex, actionIndex);
                state.setTransition(i, new ActionTransition_1.ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));
                legacyLexerActions.push(lexerAction);
              }
            }
            atn.lexerActions = legacyLexerActions;
          }
        }
        this.markPrecedenceDecisions(atn);
        atn.decisionToDFA = new Array(ndecisions);
        for (let i = 0; i < ndecisions; i++) {
          atn.decisionToDFA[i] = new DFA_1.DFA(atn.decisionToState[i], i);
        }
        if (this.deserializationOptions.isVerifyATN) {
          this.verifyATN(atn);
        }
        if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1) {
          atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);
          for (let i = 0; i < atn.ruleToStartState.length; i++) {
            atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
          }
          for (let i = 0; i < atn.ruleToStartState.length; i++) {
            let bypassStart = new BasicBlockStartState_1.BasicBlockStartState();
            bypassStart.ruleIndex = i;
            atn.addState(bypassStart);
            let bypassStop = new BlockEndState_1.BlockEndState();
            bypassStop.ruleIndex = i;
            atn.addState(bypassStop);
            bypassStart.endState = bypassStop;
            atn.defineDecisionState(bypassStart);
            bypassStop.startState = bypassStart;
            let endState;
            let excludeTransition;
            if (atn.ruleToStartState[i].isPrecedenceRule) {
              endState = void 0;
              for (let state of atn.states) {
                if (state.ruleIndex !== i) {
                  continue;
                }
                if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                  continue;
                }
                let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
                if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {
                  continue;
                }
                if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                  endState = state;
                  break;
                }
              }
              if (!endState) {
                throw new Error("Couldn't identify final state of the precedence rule prefix section.");
              }
              excludeTransition = endState.loopBackState.transition(0);
            } else {
              endState = atn.ruleToStopState[i];
            }
            for (let state of atn.states) {
              for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {
                let transition = state.transition(i2);
                if (transition === excludeTransition) {
                  continue;
                }
                if (transition.target === endState) {
                  transition.target = bypassStop;
                }
              }
            }
            while (atn.ruleToStartState[i].numberOfTransitions > 0) {
              let transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);
              bypassStart.addTransition(transition);
            }
            atn.ruleToStartState[i].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));
            bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));
            let matchState = new BasicState_1.BasicState();
            atn.addState(matchState);
            matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[i]));
            bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
        }
        if (this.deserializationOptions.isOptimize) {
          while (true) {
            let optimizationCount = 0;
            optimizationCount += ATNDeserializer3.inlineSetRules(atn);
            optimizationCount += ATNDeserializer3.combineChainedEpsilons(atn);
            let preserveOrder = atn.grammarType === 0;
            optimizationCount += ATNDeserializer3.optimizeSets(atn, preserveOrder);
            if (optimizationCount === 0) {
              break;
            }
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
        }
        ATNDeserializer3.identifyTailCalls(atn);
        return atn;
      }
      deserializeSets(data, p, sets, unicodeDeserializer) {
        let nsets = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nsets; i++) {
          let nintervals = ATNDeserializer3.toInt(data[p]);
          p++;
          let set = new IntervalSet_1.IntervalSet();
          sets.push(set);
          let containsEof = ATNDeserializer3.toInt(data[p++]) !== 0;
          if (containsEof) {
            set.add(-1);
          }
          for (let j = 0; j < nintervals; j++) {
            let a = unicodeDeserializer.readUnicode(data, p);
            p += unicodeDeserializer.size;
            let b = unicodeDeserializer.readUnicode(data, p);
            p += unicodeDeserializer.size;
            set.add(a, b);
          }
        }
        return p;
      }
      markPrecedenceDecisions(atn) {
        let rulePrecedenceDecisions = /* @__PURE__ */ new Map();
        for (let state of atn.states) {
          if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
            continue;
          }
          if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
            let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
            if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {
              if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                rulePrecedenceDecisions.set(state.ruleIndex, state);
                state.precedenceRuleDecision = true;
                state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);
              }
            }
          }
        }
        for (let precedenceDecision of rulePrecedenceDecisions) {
          for (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {
            if (transition.serializationType !== 1) {
              continue;
            }
            let epsilonTransition = transition;
            if (epsilonTransition.outermostPrecedenceReturn !== -1) {
              continue;
            }
            precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);
          }
        }
      }
      verifyATN(atn) {
        for (let state of atn.states) {
          this.checkCondition(state !== void 0, "ATN states should not be undefined.");
          if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {
            continue;
          }
          this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);
          if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {
            this.checkCondition(state.loopBackState !== void 0);
          }
          if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {
            let starLoopEntryState = state;
            this.checkCondition(starLoopEntryState.loopBackState !== void 0);
            this.checkCondition(starLoopEntryState.numberOfTransitions === 2);
            if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);
              this.checkCondition(!starLoopEntryState.nonGreedy);
            } else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);
              this.checkCondition(starLoopEntryState.nonGreedy);
            } else {
              throw new Error("IllegalStateException");
            }
          }
          if (state instanceof StarLoopbackState_1.StarLoopbackState) {
            this.checkCondition(state.numberOfTransitions === 1);
            this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);
          }
          if (state instanceof LoopEndState_1.LoopEndState) {
            this.checkCondition(state.loopBackState !== void 0);
          }
          if (state instanceof RuleStartState_1.RuleStartState) {
            this.checkCondition(state.stopState !== void 0);
          }
          if (state instanceof BlockStartState_1.BlockStartState) {
            this.checkCondition(state.endState !== void 0);
          }
          if (state instanceof BlockEndState_1.BlockEndState) {
            this.checkCondition(state.startState !== void 0);
          }
          if (state instanceof DecisionState_1.DecisionState) {
            let decisionState = state;
            this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);
          } else {
            this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);
          }
        }
      }
      checkCondition(condition, message) {
        if (!condition) {
          throw new Error("IllegalStateException: " + message);
        }
      }
      static inlineSetRules(atn) {
        let inlinedCalls = 0;
        let ruleToInlineTransition = new Array(atn.ruleToStartState.length);
        for (let i = 0; i < atn.ruleToStartState.length; i++) {
          let startState = atn.ruleToStartState[i];
          let middleState = startState;
          while (middleState.onlyHasEpsilonTransitions && middleState.numberOfOptimizedTransitions === 1 && middleState.getOptimizedTransition(0).serializationType === 1) {
            middleState = middleState.getOptimizedTransition(0).target;
          }
          if (middleState.numberOfOptimizedTransitions !== 1) {
            continue;
          }
          let matchTransition = middleState.getOptimizedTransition(0);
          let matchTarget = matchTransition.target;
          if (matchTransition.isEpsilon || !matchTarget.onlyHasEpsilonTransitions || matchTarget.numberOfOptimizedTransitions !== 1 || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          switch (matchTransition.serializationType) {
            case 5:
            case 2:
            case 7:
              ruleToInlineTransition[i] = matchTransition;
              break;
            case 8:
            case 9:
              continue;
            default:
              continue;
          }
        }
        for (let state of atn.states) {
          if (state.ruleIndex < 0) {
            continue;
          }
          let optimizedTransitions;
          for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
            let transition = state.getOptimizedTransition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            let ruleTransition = transition;
            let effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
            if (effective === void 0) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            if (optimizedTransitions === void 0) {
              optimizedTransitions = [];
              for (let j = 0; j < i; j++) {
                optimizedTransitions.push(state.getOptimizedTransition(i));
              }
            }
            inlinedCalls++;
            let target = ruleTransition.followState;
            let intermediateState = new BasicState_1.BasicState();
            intermediateState.setRuleIndex(target.ruleIndex);
            atn.addState(intermediateState);
            optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));
            switch (effective.serializationType) {
              case 5:
                intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));
                break;
              case 2:
                intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));
                break;
              case 7:
                intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));
                break;
              default:
                throw new Error("UnsupportedOperationException");
            }
          }
          if (optimizedTransitions !== void 0) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              state.addOptimizedTransition(transition);
            }
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + inlinedCalls + " rule invocations by inlining sets.");
        }
        return inlinedCalls;
      }
      static combineChainedEpsilons(atn) {
        let removedEdges = 0;
        for (let state of atn.states) {
          if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {
            continue;
          }
          let optimizedTransitions;
          nextTransition:
            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
              let transition = state.getOptimizedTransition(i);
              let intermediate = transition.target;
              if (transition.serializationType !== 1 || transition.outermostPrecedenceReturn !== -1 || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC || !intermediate.onlyHasEpsilonTransitions) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue nextTransition;
              }
              for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                if (intermediate.getOptimizedTransition(j).serializationType !== 1 || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {
                  if (optimizedTransitions !== void 0) {
                    optimizedTransitions.push(transition);
                  }
                  continue nextTransition;
                }
              }
              removedEdges++;
              if (optimizedTransitions === void 0) {
                optimizedTransitions = [];
                for (let j = 0; j < i; j++) {
                  optimizedTransitions.push(state.getOptimizedTransition(j));
                }
              }
              for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                let target = intermediate.getOptimizedTransition(j).target;
                optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));
              }
            }
          if (optimizedTransitions !== void 0) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              state.addOptimizedTransition(transition);
            }
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + removedEdges + " transitions by combining chained epsilon transitions.");
        }
        return removedEdges;
      }
      static optimizeSets(atn, preserveOrder) {
        if (preserveOrder) {
          return 0;
        }
        let removedPaths = 0;
        let decisions = atn.decisionToState;
        for (let decision of decisions) {
          let setTransitions = new IntervalSet_1.IntervalSet();
          for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
            let epsTransition = decision.getOptimizedTransition(i);
            if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {
              continue;
            }
            if (epsTransition.target.numberOfOptimizedTransitions !== 1) {
              continue;
            }
            let transition = epsTransition.target.getOptimizedTransition(0);
            if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {
              continue;
            }
            if (transition instanceof NotSetTransition_1.NotSetTransition) {
              continue;
            }
            if (transition instanceof AtomTransition_1.AtomTransition || transition instanceof RangeTransition_1.RangeTransition || transition instanceof SetTransition_1.SetTransition) {
              setTransitions.add(i);
            }
          }
          if (setTransitions.size <= 1) {
            continue;
          }
          let optimizedTransitions = [];
          for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
            if (!setTransitions.contains(i)) {
              optimizedTransitions.push(decision.getOptimizedTransition(i));
            }
          }
          let blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;
          let matchSet = new IntervalSet_1.IntervalSet();
          for (let interval of setTransitions.intervals) {
            for (let j = interval.a; j <= interval.b; j++) {
              let matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);
              if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {
                throw new Error("Not yet implemented.");
              } else {
                matchSet.addAll(matchTransition.label);
              }
            }
          }
          let newTransition;
          if (matchSet.intervals.length === 1) {
            if (matchSet.size === 1) {
              newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);
            } else {
              let matchInterval = matchSet.intervals[0];
              newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
            }
          } else {
            newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);
          }
          let setOptimizedState = new BasicState_1.BasicState();
          setOptimizedState.setRuleIndex(decision.ruleIndex);
          atn.addState(setOptimizedState);
          setOptimizedState.addTransition(newTransition);
          optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));
          removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;
          if (decision.isOptimized) {
            while (decision.numberOfOptimizedTransitions > 0) {
              decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);
            }
          }
          for (let transition of optimizedTransitions) {
            decision.addOptimizedTransition(transition);
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + removedPaths + " paths by collapsing sets.");
        }
        return removedPaths;
      }
      static identifyTailCalls(atn) {
        for (let state of atn.states) {
          for (let i = 0; i < state.numberOfTransitions; i++) {
            let transition = state.transition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            transition.tailCall = this.testTailCall(atn, transition, false);
            transition.optimizedTailCall = this.testTailCall(atn, transition, true);
          }
          if (!state.isOptimized) {
            continue;
          }
          for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
            let transition = state.getOptimizedTransition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            transition.tailCall = this.testTailCall(atn, transition, false);
            transition.optimizedTailCall = this.testTailCall(atn, transition, true);
          }
        }
      }
      static testTailCall(atn, transition, optimizedPath) {
        if (!optimizedPath && transition.tailCall) {
          return true;
        }
        if (optimizedPath && transition.optimizedTailCall) {
          return true;
        }
        let reachable = new BitSet_1.BitSet(atn.states.length);
        let worklist = [];
        worklist.push(transition.followState);
        while (true) {
          let state = worklist.pop();
          if (!state) {
            break;
          }
          if (reachable.get(state.stateNumber)) {
            continue;
          }
          if (state instanceof RuleStopState_1.RuleStopState) {
            continue;
          }
          if (!state.onlyHasEpsilonTransitions) {
            return false;
          }
          let transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;
          for (let i = 0; i < transitionCount; i++) {
            let t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);
            if (t.serializationType !== 1) {
              return false;
            }
            worklist.push(t.target);
          }
        }
        return true;
      }
      static toInt(c) {
        return c;
      }
      static toInt32(data, offset) {
        return (data[offset] | data[offset + 1] << 16) >>> 0;
      }
      static toUUID(data, offset) {
        let leastSigBits = ATNDeserializer3.toInt32(data, offset);
        let lessSigBits = ATNDeserializer3.toInt32(data, offset + 2);
        let moreSigBits = ATNDeserializer3.toInt32(data, offset + 4);
        let mostSigBits = ATNDeserializer3.toInt32(data, offset + 6);
        return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
      }
      edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
        let target = atn.states[trg];
        switch (type) {
          case 1:
            return new EpsilonTransition_1.EpsilonTransition(target);
          case 2:
            if (arg3 !== 0) {
              return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);
            } else {
              return new RangeTransition_1.RangeTransition(target, arg1, arg2);
            }
          case 3:
            let rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);
            return rt;
          case 4:
            let pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);
            return pt;
          case 10:
            return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);
          case 5:
            if (arg3 !== 0) {
              return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);
            } else {
              return new AtomTransition_1.AtomTransition(target, arg1);
            }
          case 6:
            let a = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);
            return a;
          case 7:
            return new SetTransition_1.SetTransition(target, sets[arg1]);
          case 8:
            return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);
          case 9:
            return new WildcardTransition_1.WildcardTransition(target);
        }
        throw new Error("The specified transition type is not valid.");
      }
      stateFactory(type, ruleIndex) {
        let s;
        switch (type) {
          case ATNStateType_1.ATNStateType.INVALID_TYPE:
            return new InvalidState_1.InvalidState();
          case ATNStateType_1.ATNStateType.BASIC:
            s = new BasicState_1.BasicState();
            break;
          case ATNStateType_1.ATNStateType.RULE_START:
            s = new RuleStartState_1.RuleStartState();
            break;
          case ATNStateType_1.ATNStateType.BLOCK_START:
            s = new BasicBlockStartState_1.BasicBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
            s = new PlusBlockStartState_1.PlusBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
            s = new StarBlockStartState_1.StarBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.TOKEN_START:
            s = new TokensStartState_1.TokensStartState();
            break;
          case ATNStateType_1.ATNStateType.RULE_STOP:
            s = new RuleStopState_1.RuleStopState();
            break;
          case ATNStateType_1.ATNStateType.BLOCK_END:
            s = new BlockEndState_1.BlockEndState();
            break;
          case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
            s = new StarLoopbackState_1.StarLoopbackState();
            break;
          case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
            s = new StarLoopEntryState_1.StarLoopEntryState();
            break;
          case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
            s = new PlusLoopbackState_1.PlusLoopbackState();
            break;
          case ATNStateType_1.ATNStateType.LOOP_END:
            s = new LoopEndState_1.LoopEndState();
            break;
          default:
            let message = `The specified state type ${type} is not valid.`;
            throw new Error(message);
        }
        s.ruleIndex = ruleIndex;
        return s;
      }
      lexerActionFactory(type, data1, data2) {
        switch (type) {
          case 0:
            return new LexerChannelAction_1.LexerChannelAction(data1);
          case 1:
            return new LexerCustomAction_1.LexerCustomAction(data1, data2);
          case 2:
            return new LexerModeAction_1.LexerModeAction(data1);
          case 3:
            return LexerMoreAction_1.LexerMoreAction.INSTANCE;
          case 4:
            return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;
          case 5:
            return new LexerPushModeAction_1.LexerPushModeAction(data1);
          case 6:
            return LexerSkipAction_1.LexerSkipAction.INSTANCE;
          case 7:
            return new LexerTypeAction_1.LexerTypeAction(data1);
          default:
            let message = `The specified lexer action type ${type} is not valid.`;
            throw new Error(message);
        }
      }
    };
    ATNDeserializer3.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3");
    ATNDeserializer3.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D");
    ATNDeserializer3.ADDED_UNICODE_SMP = UUID_1.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B");
    ATNDeserializer3.SUPPORTED_UUIDS = [
      ATNDeserializer3.BASE_SERIALIZED_UUID,
      ATNDeserializer3.ADDED_LEXER_ACTIONS,
      ATNDeserializer3.ADDED_UNICODE_SMP
    ];
    ATNDeserializer3.SERIALIZED_UUID = ATNDeserializer3.ADDED_UNICODE_SMP;
    __decorate([
      Decorators_1.NotNull
    ], ATNDeserializer3.prototype, "deserializationOptions", void 0);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer3.prototype, "deserialize", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer3.prototype, "markPrecedenceDecisions", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer3.prototype, "edgeFactory", null);
    exports.ATNDeserializer = ATNDeserializer3;
  }
});

// node_modules/antlr4ts/atn/ParseInfo.js
var require_ParseInfo = __commonJS({
  "node_modules/antlr4ts/atn/ParseInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseInfo = void 0;
    var Decorators_1 = require_Decorators();
    var ParseInfo = class ParseInfo {
      constructor(atnSimulator) {
        this.atnSimulator = atnSimulator;
      }
      getDecisionInfo() {
        return this.atnSimulator.getDecisionInfo();
      }
      getLLDecisions() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let LL = [];
        for (let i = 0; i < decisions.length; i++) {
          let fallBack = decisions[i].LL_Fallback;
          if (fallBack > 0) {
            LL.push(i);
          }
        }
        return LL;
      }
      getTotalTimeInPrediction() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let t = 0;
        for (let decision of decisions) {
          t += decision.timeInPrediction;
        }
        return t;
      }
      getTotalSLLLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_TotalLook;
        }
        return k;
      }
      getTotalLLLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.LL_TotalLook;
        }
        return k;
      }
      getTotalSLLATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_ATNTransitions;
        }
        return k;
      }
      getTotalLLATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.LL_ATNTransitions;
        }
        return k;
      }
      getTotalATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_ATNTransitions;
          k += decision.LL_ATNTransitions;
        }
        return k;
      }
      getDFASize(decision) {
        if (decision) {
          let decisionToDFA = this.atnSimulator.atn.decisionToDFA[decision];
          return decisionToDFA.states.size;
        } else {
          let n = 0;
          let decisionToDFA = this.atnSimulator.atn.decisionToDFA;
          for (let i = 0; i < decisionToDFA.length; i++) {
            n += this.getDFASize(i);
          }
          return n;
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParseInfo.prototype, "getDecisionInfo", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseInfo.prototype, "getLLDecisions", null);
    ParseInfo = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParseInfo);
    exports.ParseInfo = ParseInfo;
  }
});

// node_modules/antlr4ts/ProxyParserErrorListener.js
var require_ProxyParserErrorListener = __commonJS({
  "node_modules/antlr4ts/ProxyParserErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyParserErrorListener = void 0;
    var ProxyErrorListener_1 = require_ProxyErrorListener();
    var Decorators_1 = require_Decorators();
    var ProxyParserErrorListener = class extends ProxyErrorListener_1.ProxyErrorListener {
      constructor(delegates) {
        super(delegates);
      }
      reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportAmbiguity) {
            listener.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
          }
        });
      }
      reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportAttemptingFullContext) {
            listener.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
          }
        });
      }
      reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportContextSensitivity) {
            listener.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState);
          }
        });
      }
    };
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportAmbiguity", null);
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportContextSensitivity", null);
    exports.ProxyParserErrorListener = ProxyParserErrorListener;
  }
});

// node_modules/antlr4ts/misc/Character.js
var require_Character = __commonJS({
  "node_modules/antlr4ts/misc/Character.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSupplementaryCodePoint = exports.isLowSurrogate = exports.isHighSurrogate = void 0;
    function isHighSurrogate(ch) {
      return ch >= 55296 && ch <= 56319;
    }
    exports.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(ch) {
      return ch >= 56320 && ch <= 57343;
    }
    exports.isLowSurrogate = isLowSurrogate;
    function isSupplementaryCodePoint(ch) {
      return ch >= 65536;
    }
    exports.isSupplementaryCodePoint = isSupplementaryCodePoint;
  }
});

// node_modules/antlr4ts/CodePointBuffer.js
var require_CodePointBuffer = __commonJS({
  "node_modules/antlr4ts/CodePointBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodePointBuffer = void 0;
    var assert = require("assert");
    var Character = require_Character();
    var CodePointBuffer = class {
      constructor(buffer, size) {
        this.buffer = buffer;
        this._position = 0;
        this._size = size;
      }
      static withArray(buffer) {
        return new CodePointBuffer(buffer, buffer.length);
      }
      get position() {
        return this._position;
      }
      set position(newPosition) {
        if (newPosition < 0 || newPosition > this._size) {
          throw new RangeError();
        }
        this._position = newPosition;
      }
      get remaining() {
        return this._size - this.position;
      }
      get(offset) {
        return this.buffer[offset];
      }
      array() {
        return this.buffer.slice(0, this._size);
      }
      static builder(initialBufferSize) {
        return new CodePointBuffer.Builder(initialBufferSize);
      }
    };
    exports.CodePointBuffer = CodePointBuffer;
    (function(CodePointBuffer2) {
      let Type;
      (function(Type2) {
        Type2[Type2["BYTE"] = 0] = "BYTE";
        Type2[Type2["CHAR"] = 1] = "CHAR";
        Type2[Type2["INT"] = 2] = "INT";
      })(Type || (Type = {}));
      class Builder {
        constructor(initialBufferSize) {
          this.type = 0;
          this.buffer = new Uint8Array(initialBufferSize);
          this.prevHighSurrogate = -1;
          this.position = 0;
        }
        build() {
          return new CodePointBuffer2(this.buffer, this.position);
        }
        static roundUpToNextPowerOfTwo(i) {
          let nextPowerOfTwo = 32 - Math.clz32(i - 1);
          return Math.pow(2, nextPowerOfTwo);
        }
        ensureRemaining(remainingNeeded) {
          switch (this.type) {
            case 0:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Uint8Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
            case 1:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Uint16Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
            case 2:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Int32Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
          }
        }
        append(utf16In) {
          this.ensureRemaining(utf16In.length);
          this.appendArray(utf16In);
        }
        appendArray(utf16In) {
          switch (this.type) {
            case 0:
              this.appendArrayByte(utf16In);
              break;
            case 1:
              this.appendArrayChar(utf16In);
              break;
            case 2:
              this.appendArrayInt(utf16In);
              break;
          }
        }
        appendArrayByte(utf16In) {
          assert(this.prevHighSurrogate === -1);
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outByte = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            if (c <= 255) {
              outByte[outOffset] = c;
            } else {
              utf16In = utf16In.subarray(inOffset, inLimit);
              this.position = outOffset;
              if (!Character.isHighSurrogate(c)) {
                this.byteToCharBuffer(utf16In.length);
                this.appendArrayChar(utf16In);
                return;
              } else {
                this.byteToIntBuffer(utf16In.length);
                this.appendArrayInt(utf16In);
                return;
              }
            }
            inOffset++;
            outOffset++;
          }
          this.position = outOffset;
        }
        appendArrayChar(utf16In) {
          assert(this.prevHighSurrogate === -1);
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outChar = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            if (!Character.isHighSurrogate(c)) {
              outChar[outOffset] = c;
            } else {
              utf16In = utf16In.subarray(inOffset, inLimit);
              this.position = outOffset;
              this.charToIntBuffer(utf16In.length);
              this.appendArrayInt(utf16In);
              return;
            }
            inOffset++;
            outOffset++;
          }
          this.position = outOffset;
        }
        appendArrayInt(utf16In) {
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outInt = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            inOffset++;
            if (this.prevHighSurrogate !== -1) {
              if (Character.isLowSurrogate(c)) {
                outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0);
                outOffset++;
                this.prevHighSurrogate = -1;
              } else {
                outInt[outOffset] = this.prevHighSurrogate;
                outOffset++;
                if (Character.isHighSurrogate(c)) {
                  this.prevHighSurrogate = c;
                } else {
                  outInt[outOffset] = c;
                  outOffset++;
                  this.prevHighSurrogate = -1;
                }
              }
            } else if (Character.isHighSurrogate(c)) {
              this.prevHighSurrogate = c;
            } else {
              outInt[outOffset] = c;
              outOffset++;
            }
          }
          if (this.prevHighSurrogate !== -1) {
            outInt[outOffset] = this.prevHighSurrogate;
            outOffset++;
          }
          this.position = outOffset;
        }
        byteToCharBuffer(toAppend) {
          let newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 1;
          this.buffer = newBuffer;
        }
        byteToIntBuffer(toAppend) {
          let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 2;
          this.buffer = newBuffer;
        }
        charToIntBuffer(toAppend) {
          let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 2;
          this.buffer = newBuffer;
        }
      }
      CodePointBuffer2.Builder = Builder;
    })(CodePointBuffer = exports.CodePointBuffer || (exports.CodePointBuffer = {}));
  }
});

// node_modules/antlr4ts/CodePointCharStream.js
var require_CodePointCharStream = __commonJS({
  "node_modules/antlr4ts/CodePointCharStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodePointCharStream = void 0;
    var assert = require("assert");
    var IntStream_1 = require_IntStream();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var CodePointCharStream = class {
      constructor(array, position2, remaining, name) {
        assert(position2 === 0);
        this._array = array;
        this._size = remaining;
        this._name = name;
        this._position = 0;
      }
      get internalStorage() {
        return this._array;
      }
      static fromBuffer(codePointBuffer, name) {
        if (name === void 0 || name.length === 0) {
          name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        return new CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);
      }
      consume() {
        if (this._size - this._position === 0) {
          assert(this.LA(1) === IntStream_1.IntStream.EOF);
          throw new RangeError("cannot consume EOF");
        }
        this._position++;
      }
      get index() {
        return this._position;
      }
      get size() {
        return this._size;
      }
      mark() {
        return -1;
      }
      release(marker) {
      }
      seek(index2) {
        this._position = index2;
      }
      get sourceName() {
        return this._name;
      }
      toString() {
        return this.getText(Interval_1.Interval.of(0, this.size - 1));
      }
      LA(i) {
        let offset;
        switch (Math.sign(i)) {
          case -1:
            offset = this.index + i;
            if (offset < 0) {
              return IntStream_1.IntStream.EOF;
            }
            return this._array[offset];
          case 0:
            return 0;
          case 1:
            offset = this.index + i - 1;
            if (offset >= this.size) {
              return IntStream_1.IntStream.EOF;
            }
            return this._array[offset];
        }
        throw new RangeError("Not reached");
      }
      getText(interval) {
        const startIdx = Math.min(interval.a, this.size);
        const len = Math.min(interval.b - interval.a + 1, this.size - startIdx);
        if (this._array instanceof Int32Array) {
          return String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));
        } else {
          return String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));
        }
      }
    };
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "toString", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "LA", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "getText", null);
    exports.CodePointCharStream = CodePointCharStream;
  }
});

// node_modules/antlr4ts/CharStreams.js
var require_CharStreams = __commonJS({
  "node_modules/antlr4ts/CharStreams.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CharStreams = void 0;
    var CodePointBuffer_1 = require_CodePointBuffer();
    var CodePointCharStream_1 = require_CodePointCharStream();
    var IntStream_1 = require_IntStream();
    var CharStreams;
    (function(CharStreams2) {
      function fromString(s, sourceName) {
        if (sourceName === void 0 || sourceName.length === 0) {
          sourceName = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        let codePointBufferBuilder = CodePointBuffer_1.CodePointBuffer.builder(s.length);
        let cb = new Uint16Array(s.length);
        for (let i = 0; i < s.length; i++) {
          cb[i] = s.charCodeAt(i);
        }
        codePointBufferBuilder.append(cb);
        return CodePointCharStream_1.CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);
      }
      CharStreams2.fromString = fromString;
    })(CharStreams = exports.CharStreams || (exports.CharStreams = {}));
  }
});

// node_modules/antlr4ts/BufferedTokenStream.js
var require_BufferedTokenStream = __commonJS({
  "node_modules/antlr4ts/BufferedTokenStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BufferedTokenStream = void 0;
    var assert = require("assert");
    var CommonToken_1 = require_CommonToken();
    var Interval_1 = require_Interval();
    var Lexer_1 = require_Lexer();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var BufferedTokenStream = class BufferedTokenStream {
      constructor(tokenSource) {
        this.tokens = [];
        this.p = -1;
        this.fetchedEOF = false;
        if (tokenSource == null) {
          throw new Error("tokenSource cannot be null");
        }
        this._tokenSource = tokenSource;
      }
      get tokenSource() {
        return this._tokenSource;
      }
      set tokenSource(tokenSource) {
        this._tokenSource = tokenSource;
        this.tokens.length = 0;
        this.p = -1;
        this.fetchedEOF = false;
      }
      get index() {
        return this.p;
      }
      mark() {
        return 0;
      }
      release(marker) {
      }
      seek(index2) {
        this.lazyInit();
        this.p = this.adjustSeekIndex(index2);
      }
      get size() {
        return this.tokens.length;
      }
      consume() {
        let skipEofCheck;
        if (this.p >= 0) {
          if (this.fetchedEOF) {
            skipEofCheck = this.p < this.tokens.length - 1;
          } else {
            skipEofCheck = this.p < this.tokens.length;
          }
        } else {
          skipEofCheck = false;
        }
        if (!skipEofCheck && this.LA(1) === Token_1.Token.EOF) {
          throw new Error("cannot consume EOF");
        }
        if (this.sync(this.p + 1)) {
          this.p = this.adjustSeekIndex(this.p + 1);
        }
      }
      sync(i) {
        assert(i >= 0);
        let n = i - this.tokens.length + 1;
        if (n > 0) {
          let fetched = this.fetch(n);
          return fetched >= n;
        }
        return true;
      }
      fetch(n) {
        if (this.fetchedEOF) {
          return 0;
        }
        for (let i = 0; i < n; i++) {
          let t = this.tokenSource.nextToken();
          if (this.isWritableToken(t)) {
            t.tokenIndex = this.tokens.length;
          }
          this.tokens.push(t);
          if (t.type === Token_1.Token.EOF) {
            this.fetchedEOF = true;
            return i + 1;
          }
        }
        return n;
      }
      get(i) {
        if (i < 0 || i >= this.tokens.length) {
          throw new RangeError("token index " + i + " out of range 0.." + (this.tokens.length - 1));
        }
        return this.tokens[i];
      }
      getRange(start, stop) {
        if (start < 0 || stop < 0) {
          return [];
        }
        this.lazyInit();
        let subset = new Array();
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        for (let i = start; i <= stop; i++) {
          let t = this.tokens[i];
          if (t.type === Token_1.Token.EOF) {
            break;
          }
          subset.push(t);
        }
        return subset;
      }
      LA(i) {
        let token = this.LT(i);
        if (!token) {
          return Token_1.Token.INVALID_TYPE;
        }
        return token.type;
      }
      tryLB(k) {
        if (this.p - k < 0) {
          return void 0;
        }
        return this.tokens[this.p - k];
      }
      LT(k) {
        let result = this.tryLT(k);
        if (result === void 0) {
          throw new RangeError("requested lookback index out of range");
        }
        return result;
      }
      tryLT(k) {
        this.lazyInit();
        if (k === 0) {
          throw new RangeError("0 is not a valid lookahead index");
        }
        if (k < 0) {
          return this.tryLB(-k);
        }
        let i = this.p + k - 1;
        this.sync(i);
        if (i >= this.tokens.length) {
          return this.tokens[this.tokens.length - 1];
        }
        return this.tokens[i];
      }
      adjustSeekIndex(i) {
        return i;
      }
      lazyInit() {
        if (this.p === -1) {
          this.setup();
        }
      }
      setup() {
        this.sync(0);
        this.p = this.adjustSeekIndex(0);
      }
      getTokens(start, stop, types) {
        this.lazyInit();
        if (start === void 0) {
          assert(stop === void 0 && types === void 0);
          return this.tokens;
        } else if (stop === void 0) {
          stop = this.tokens.length - 1;
        }
        if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
          throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
        }
        if (start > stop) {
          return [];
        }
        if (types === void 0) {
          return this.tokens.slice(start, stop + 1);
        } else if (typeof types === "number") {
          types = (/* @__PURE__ */ new Set()).add(types);
        }
        let typesSet = types;
        let filteredTokens = this.tokens.slice(start, stop + 1);
        filteredTokens = filteredTokens.filter((value2) => typesSet.has(value2.type));
        return filteredTokens;
      }
      nextTokenOnChannel(i, channel) {
        this.sync(i);
        if (i >= this.size) {
          return this.size - 1;
        }
        let token = this.tokens[i];
        while (token.channel !== channel) {
          if (token.type === Token_1.Token.EOF) {
            return i;
          }
          i++;
          this.sync(i);
          token = this.tokens[i];
        }
        return i;
      }
      previousTokenOnChannel(i, channel) {
        this.sync(i);
        if (i >= this.size) {
          return this.size - 1;
        }
        while (i >= 0) {
          let token = this.tokens[i];
          if (token.type === Token_1.Token.EOF || token.channel === channel) {
            return i;
          }
          i--;
        }
        return i;
      }
      getHiddenTokensToRight(tokenIndex, channel = -1) {
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
        }
        let nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
        let to;
        let from = tokenIndex + 1;
        if (nextOnChannel === -1) {
          to = this.size - 1;
        } else {
          to = nextOnChannel;
        }
        return this.filterForChannel(from, to, channel);
      }
      getHiddenTokensToLeft(tokenIndex, channel = -1) {
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
        }
        if (tokenIndex === 0) {
          return [];
        }
        let prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
        if (prevOnChannel === tokenIndex - 1) {
          return [];
        }
        let from = prevOnChannel + 1;
        let to = tokenIndex - 1;
        return this.filterForChannel(from, to, channel);
      }
      filterForChannel(from, to, channel) {
        let hidden = new Array();
        for (let i = from; i <= to; i++) {
          let t = this.tokens[i];
          if (channel === -1) {
            if (t.channel !== Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL) {
              hidden.push(t);
            }
          } else {
            if (t.channel === channel) {
              hidden.push(t);
            }
          }
        }
        return hidden;
      }
      get sourceName() {
        return this.tokenSource.sourceName;
      }
      getText(interval) {
        if (interval === void 0) {
          interval = Interval_1.Interval.of(0, this.size - 1);
        } else if (!(interval instanceof Interval_1.Interval)) {
          interval = interval.sourceInterval;
        }
        let start = interval.a;
        let stop = interval.b;
        if (start < 0 || stop < 0) {
          return "";
        }
        this.fill();
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        let buf = "";
        for (let i = start; i <= stop; i++) {
          let t = this.tokens[i];
          if (t.type === Token_1.Token.EOF) {
            break;
          }
          buf += t.text;
        }
        return buf.toString();
      }
      getTextFromRange(start, stop) {
        if (this.isToken(start) && this.isToken(stop)) {
          return this.getText(Interval_1.Interval.of(start.tokenIndex, stop.tokenIndex));
        }
        return "";
      }
      fill() {
        this.lazyInit();
        const blockSize = 1e3;
        while (true) {
          let fetched = this.fetch(blockSize);
          if (fetched < blockSize) {
            return;
          }
        }
      }
      isWritableToken(t) {
        return t instanceof CommonToken_1.CommonToken;
      }
      isToken(t) {
        return t instanceof CommonToken_1.CommonToken;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], BufferedTokenStream.prototype, "_tokenSource", void 0);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "get", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "LA", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "LT", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "sourceName", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "getText", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "getTextFromRange", null);
    BufferedTokenStream = __decorate([
      __param(0, Decorators_1.NotNull)
    ], BufferedTokenStream);
    exports.BufferedTokenStream = BufferedTokenStream;
  }
});

// node_modules/antlr4ts/CommonTokenStream.js
var require_CommonTokenStream = __commonJS({
  "node_modules/antlr4ts/CommonTokenStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonTokenStream = void 0;
    var BufferedTokenStream_1 = require_BufferedTokenStream();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var CommonTokenStream2 = class CommonTokenStream extends BufferedTokenStream_1.BufferedTokenStream {
      constructor(tokenSource, channel = Token_1.Token.DEFAULT_CHANNEL) {
        super(tokenSource);
        this.channel = channel;
      }
      adjustSeekIndex(i) {
        return this.nextTokenOnChannel(i, this.channel);
      }
      tryLB(k) {
        if (this.p - k < 0) {
          return void 0;
        }
        let i = this.p;
        let n = 1;
        while (n <= k && i > 0) {
          i = this.previousTokenOnChannel(i - 1, this.channel);
          n++;
        }
        if (i < 0) {
          return void 0;
        }
        return this.tokens[i];
      }
      tryLT(k) {
        this.lazyInit();
        if (k === 0) {
          throw new RangeError("0 is not a valid lookahead index");
        }
        if (k < 0) {
          return this.tryLB(-k);
        }
        let i = this.p;
        let n = 1;
        while (n < k) {
          if (this.sync(i + 1)) {
            i = this.nextTokenOnChannel(i + 1, this.channel);
          }
          n++;
        }
        return this.tokens[i];
      }
      getNumberOfOnChannelTokens() {
        let n = 0;
        this.fill();
        for (let t of this.tokens) {
          if (t.channel === this.channel) {
            n++;
          }
          if (t.type === Token_1.Token.EOF) {
            break;
          }
        }
        return n;
      }
    };
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "adjustSeekIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "tryLB", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "tryLT", null);
    CommonTokenStream2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], CommonTokenStream2);
    exports.CommonTokenStream = CommonTokenStream2;
  }
});

// node_modules/antlr4ts/ListTokenSource.js
var require_ListTokenSource = __commonJS({
  "node_modules/antlr4ts/ListTokenSource.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListTokenSource = void 0;
    var CommonTokenFactory_1 = require_CommonTokenFactory();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var ListTokenSource = class ListTokenSource {
      constructor(tokens, sourceName) {
        this.i = 0;
        this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
        if (tokens == null) {
          throw new Error("tokens cannot be null");
        }
        this.tokens = tokens;
        this._sourceName = sourceName;
      }
      get charPositionInLine() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].charPositionInLine;
        } else if (this.eofToken != null) {
          return this.eofToken.charPositionInLine;
        } else if (this.tokens.length > 0) {
          let lastToken = this.tokens[this.tokens.length - 1];
          let tokenText = lastToken.text;
          if (tokenText != null) {
            let lastNewLine = tokenText.lastIndexOf("\n");
            if (lastNewLine >= 0) {
              return tokenText.length - lastNewLine - 1;
            }
          }
          return lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;
        }
        return 0;
      }
      nextToken() {
        if (this.i >= this.tokens.length) {
          if (this.eofToken == null) {
            let start = -1;
            if (this.tokens.length > 0) {
              let previousStop = this.tokens[this.tokens.length - 1].stopIndex;
              if (previousStop !== -1) {
                start = previousStop + 1;
              }
            }
            let stop = Math.max(-1, start - 1);
            this.eofToken = this._factory.create({ source: this, stream: this.inputStream }, Token_1.Token.EOF, "EOF", Token_1.Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);
          }
          return this.eofToken;
        }
        let t = this.tokens[this.i];
        if (this.i === this.tokens.length - 1 && t.type === Token_1.Token.EOF) {
          this.eofToken = t;
        }
        this.i++;
        return t;
      }
      get line() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].line;
        } else if (this.eofToken != null) {
          return this.eofToken.line;
        } else if (this.tokens.length > 0) {
          let lastToken = this.tokens[this.tokens.length - 1];
          let line = lastToken.line;
          let tokenText = lastToken.text;
          if (tokenText != null) {
            for (let i = 0; i < tokenText.length; i++) {
              if (tokenText.charAt(i) === "\n") {
                line++;
              }
            }
          }
          return line;
        }
        return 1;
      }
      get inputStream() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].inputStream;
        } else if (this.eofToken != null) {
          return this.eofToken.inputStream;
        } else if (this.tokens.length > 0) {
          return this.tokens[this.tokens.length - 1].inputStream;
        }
        return void 0;
      }
      get sourceName() {
        if (this._sourceName) {
          return this._sourceName;
        }
        let inputStream = this.inputStream;
        if (inputStream != null) {
          return inputStream.sourceName;
        }
        return "List";
      }
      set tokenFactory(factory) {
        this._factory = factory;
      }
      get tokenFactory() {
        return this._factory;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "nextToken", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ListTokenSource.prototype, "tokenFactory", null);
    ListTokenSource = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ListTokenSource);
    exports.ListTokenSource = ListTokenSource;
  }
});

// node_modules/antlr4ts/misc/MultiMap.js
var require_MultiMap = __commonJS({
  "node_modules/antlr4ts/misc/MultiMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiMap = void 0;
    var MultiMap = class extends Map {
      constructor() {
        super();
      }
      map(key, value2) {
        let elementsForKey = super.get(key);
        if (!elementsForKey) {
          elementsForKey = [];
          super.set(key, elementsForKey);
        }
        elementsForKey.push(value2);
      }
      getPairs() {
        let pairs = [];
        this.forEach((values, key) => {
          values.forEach((v) => {
            pairs.push([key, v]);
          });
        });
        return pairs;
      }
    };
    exports.MultiMap = MultiMap;
  }
});

// node_modules/antlr4ts/misc/ParseCancellationException.js
var require_ParseCancellationException = __commonJS({
  "node_modules/antlr4ts/misc/ParseCancellationException.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseCancellationException = void 0;
    var ParseCancellationException = class extends Error {
      constructor(cause) {
        super(cause.message);
        this.cause = cause;
        this.stack = cause.stack;
      }
      getCause() {
        return this.cause;
      }
    };
    exports.ParseCancellationException = ParseCancellationException;
  }
});

// node_modules/antlr4ts/InterpreterRuleContext.js
var require_InterpreterRuleContext = __commonJS({
  "node_modules/antlr4ts/InterpreterRuleContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InterpreterRuleContext = void 0;
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var InterpreterRuleContext = class extends ParserRuleContext_1.ParserRuleContext {
      constructor(ruleIndex, parent, invokingStateNumber) {
        if (invokingStateNumber !== void 0) {
          super(parent, invokingStateNumber);
        } else {
          super();
        }
        this._ruleIndex = ruleIndex;
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InterpreterRuleContext.prototype, "ruleIndex", null);
    exports.InterpreterRuleContext = InterpreterRuleContext;
  }
});

// node_modules/antlr4ts/ParserInterpreter.js
var require_ParserInterpreter = __commonJS({
  "node_modules/antlr4ts/ParserInterpreter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserInterpreter = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var BitSet_1 = require_BitSet();
    var FailedPredicateException_1 = require_FailedPredicateException();
    var InputMismatchException_1 = require_InputMismatchException();
    var InterpreterRuleContext_1 = require_InterpreterRuleContext();
    var LoopEndState_1 = require_LoopEndState();
    var Decorators_1 = require_Decorators();
    var Decorators_2 = require_Decorators();
    var Parser_1 = require_Parser();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var RecognitionException_1 = require_RecognitionException();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var Token_1 = require_Token();
    var ParserInterpreter = class ParserInterpreter2 extends Parser_1.Parser {
      constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
        super(grammarFileName instanceof ParserInterpreter2 ? grammarFileName.inputStream : input);
        this._parentContextStack = [];
        this.overrideDecision = -1;
        this.overrideDecisionInputIndex = -1;
        this.overrideDecisionAlt = -1;
        this.overrideDecisionReached = false;
        this._overrideDecisionRoot = void 0;
        if (grammarFileName instanceof ParserInterpreter2) {
          let old = grammarFileName;
          this._grammarFileName = old._grammarFileName;
          this._atn = old._atn;
          this.pushRecursionContextStates = old.pushRecursionContextStates;
          this._ruleNames = old._ruleNames;
          this._vocabulary = old._vocabulary;
          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this._atn, this);
        } else {
          vocabulary = vocabulary;
          ruleNames = ruleNames;
          atn = atn;
          this._grammarFileName = grammarFileName;
          this._atn = atn;
          this._ruleNames = ruleNames.slice(0);
          this._vocabulary = vocabulary;
          this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);
          for (let state of atn.states) {
            if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
              continue;
            }
            if (state.precedenceRuleDecision) {
              this.pushRecursionContextStates.set(state.stateNumber);
            }
          }
          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, this);
        }
      }
      reset(resetInput) {
        if (resetInput === void 0) {
          super.reset();
        } else {
          super.reset(resetInput);
        }
        this.overrideDecisionReached = false;
        this._overrideDecisionRoot = void 0;
      }
      get atn() {
        return this._atn;
      }
      get vocabulary() {
        return this._vocabulary;
      }
      get ruleNames() {
        return this._ruleNames;
      }
      get grammarFileName() {
        return this._grammarFileName;
      }
      parse(startRuleIndex) {
        let startRuleStartState = this._atn.ruleToStartState[startRuleIndex];
        this._rootContext = this.createInterpreterRuleContext(void 0, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);
        if (startRuleStartState.isPrecedenceRule) {
          this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
        } else {
          this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);
        }
        while (true) {
          let p = this.atnState;
          switch (p.stateType) {
            case ATNStateType_1.ATNStateType.RULE_STOP:
              if (this._ctx.isEmpty) {
                if (startRuleStartState.isPrecedenceRule) {
                  let result = this._ctx;
                  let parentContext = this._parentContextStack.pop();
                  this.unrollRecursionContexts(parentContext[0]);
                  return result;
                } else {
                  this.exitRule();
                  return this._rootContext;
                }
              }
              this.visitRuleStopState(p);
              break;
            default:
              try {
                this.visitState(p);
              } catch (e) {
                if (e instanceof RecognitionException_1.RecognitionException) {
                  this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;
                  this.context.exception = e;
                  this.errorHandler.reportError(this, e);
                  this.recover(e);
                } else {
                  throw e;
                }
              }
              break;
          }
        }
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this._parentContextStack.push([this._ctx, localctx.invokingState]);
        super.enterRecursionRule(localctx, state, ruleIndex, precedence);
      }
      get atnState() {
        return this._atn.states[this.state];
      }
      visitState(p) {
        let predictedAlt = 1;
        if (p.numberOfTransitions > 1) {
          predictedAlt = this.visitDecisionState(p);
        }
        let transition = p.transition(predictedAlt - 1);
        switch (transition.serializationType) {
          case 1:
            if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target instanceof LoopEndState_1.LoopEndState)) {
              let parentContext = this._parentContextStack[this._parentContextStack.length - 1];
              let localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);
              this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);
            }
            break;
          case 5:
            this.match(transition._label);
            break;
          case 2:
          case 7:
          case 8:
            if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {
              this.recoverInline();
            }
            this.matchWildcard();
            break;
          case 9:
            this.matchWildcard();
            break;
          case 3:
            let ruleStartState = transition.target;
            let ruleIndex = ruleStartState.ruleIndex;
            let newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);
            if (ruleStartState.isPrecedenceRule) {
              this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);
            } else {
              this.enterRule(newctx, transition.target.stateNumber, ruleIndex);
            }
            break;
          case 4:
            let predicateTransition = transition;
            if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
              throw new FailedPredicateException_1.FailedPredicateException(this);
            }
            break;
          case 6:
            let actionTransition = transition;
            this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);
            break;
          case 10:
            if (!this.precpred(this._ctx, transition.precedence)) {
              let precedence = transition.precedence;
              throw new FailedPredicateException_1.FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
            }
            break;
          default:
            throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
        }
        this.state = transition.target.stateNumber;
      }
      visitDecisionState(p) {
        let predictedAlt;
        this.errorHandler.sync(this);
        let decision = p.decision;
        if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {
          predictedAlt = this.overrideDecisionAlt;
          this.overrideDecisionReached = true;
        } else {
          predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);
        }
        return predictedAlt;
      }
      createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
        return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
      }
      visitRuleStopState(p) {
        let ruleStartState = this._atn.ruleToStartState[p.ruleIndex];
        if (ruleStartState.isPrecedenceRule) {
          let parentContext = this._parentContextStack.pop();
          this.unrollRecursionContexts(parentContext[0]);
          this.state = parentContext[1];
        } else {
          this.exitRule();
        }
        let ruleTransition = this._atn.states[this.state].transition(0);
        this.state = ruleTransition.followState.stateNumber;
      }
      addDecisionOverride(decision, tokenIndex, forcedAlt) {
        this.overrideDecision = decision;
        this.overrideDecisionInputIndex = tokenIndex;
        this.overrideDecisionAlt = forcedAlt;
      }
      get overrideDecisionRoot() {
        return this._overrideDecisionRoot;
      }
      recover(e) {
        let i = this._input.index;
        this.errorHandler.recover(this, e);
        if (this._input.index === i) {
          let tok = e.getOffendingToken();
          if (!tok) {
            throw new Error("Expected exception to have an offending token");
          }
          let source = tok.tokenSource;
          let stream = source !== void 0 ? source.inputStream : void 0;
          let sourcePair = { source, stream };
          if (e instanceof InputMismatchException_1.InputMismatchException) {
            let expectedTokens = e.expectedTokens;
            if (expectedTokens === void 0) {
              throw new Error("Expected the exception to provide expected tokens");
            }
            let expectedTokenType = Token_1.Token.INVALID_TYPE;
            if (!expectedTokens.isNil) {
              expectedTokenType = expectedTokens.minElement;
            }
            let errToken = this.tokenFactory.create(sourcePair, expectedTokenType, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, tok.line, tok.charPositionInLine);
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
          } else {
            let source2 = tok.tokenSource;
            let errToken = this.tokenFactory.create(sourcePair, Token_1.Token.INVALID_TYPE, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, tok.line, tok.charPositionInLine);
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
          }
        }
      }
      recoverInline() {
        return this._errHandler.recoverInline(this);
      }
      get rootContext() {
        return this._rootContext;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParserInterpreter.prototype, "_vocabulary", void 0);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "reset", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "atn", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "vocabulary", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "ruleNames", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "grammarFileName", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "enterRecursionRule", null);
    ParserInterpreter = __decorate([
      __param(1, Decorators_1.NotNull)
    ], ParserInterpreter);
    exports.ParserInterpreter = ParserInterpreter;
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js
var require_ParseTreeMatch = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreeMatch = void 0;
    var Decorators_1 = require_Decorators();
    var ParseTreeMatch = class ParseTreeMatch {
      constructor(tree, pattern, labels, mismatchedNode) {
        if (!tree) {
          throw new Error("tree cannot be null");
        }
        if (!pattern) {
          throw new Error("pattern cannot be null");
        }
        if (!labels) {
          throw new Error("labels cannot be null");
        }
        this._tree = tree;
        this._pattern = pattern;
        this._labels = labels;
        this._mismatchedNode = mismatchedNode;
      }
      get(label) {
        let parseTrees = this._labels.get(label);
        if (!parseTrees || parseTrees.length === 0) {
          return void 0;
        }
        return parseTrees[parseTrees.length - 1];
      }
      getAll(label) {
        const nodes = this._labels.get(label);
        if (!nodes) {
          return [];
        }
        return nodes;
      }
      get labels() {
        return this._labels;
      }
      get mismatchedNode() {
        return this._mismatchedNode;
      }
      get succeeded() {
        return !this._mismatchedNode;
      }
      get pattern() {
        return this._pattern;
      }
      get tree() {
        return this._tree;
      }
      toString() {
        return `Match ${this.succeeded ? "succeeded" : "failed"}; found ${this.labels.size} labels`;
      }
    };
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParseTreeMatch.prototype, "getAll", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "labels", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "pattern", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "tree", null);
    __decorate([
      Decorators_1.Override
    ], ParseTreeMatch.prototype, "toString", null);
    ParseTreeMatch = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParseTreeMatch);
    exports.ParseTreeMatch = ParseTreeMatch;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathLexer.js
var require_XPathLexer = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathLexer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathLexer = void 0;
    var ATNDeserializer_1 = require_ATNDeserializer();
    var Lexer_1 = require_Lexer();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var Utils3 = require_Utils();
    var XPathLexer = class extends Lexer_1.Lexer {
      constructor(input) {
        super(input);
        this._interp = new LexerATNSimulator_1.LexerATNSimulator(XPathLexer._ATN, this);
      }
      get vocabulary() {
        return XPathLexer.VOCABULARY;
      }
      get grammarFileName() {
        return "XPathLexer.g4";
      }
      get ruleNames() {
        return XPathLexer.ruleNames;
      }
      get serializedATN() {
        return XPathLexer._serializedATN;
      }
      get channelNames() {
        return XPathLexer.channelNames;
      }
      get modeNames() {
        return XPathLexer.modeNames;
      }
      action(_localctx, ruleIndex, actionIndex) {
        switch (ruleIndex) {
          case 4:
            this.ID_action(_localctx, actionIndex);
            break;
        }
      }
      ID_action(_localctx, actionIndex) {
        switch (actionIndex) {
          case 0:
            let text4 = this.text;
            if (text4.charAt(0) === text4.charAt(0).toUpperCase()) {
              this.type = XPathLexer.TOKEN_REF;
            } else {
              this.type = XPathLexer.RULE_REF;
            }
            break;
        }
      }
      static get _ATN() {
        if (!XPathLexer.__ATN) {
          XPathLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils3.toCharArray(XPathLexer._serializedATN));
        }
        return XPathLexer.__ATN;
      }
    };
    exports.XPathLexer = XPathLexer;
    XPathLexer.TOKEN_REF = 1;
    XPathLexer.RULE_REF = 2;
    XPathLexer.ANYWHERE = 3;
    XPathLexer.ROOT = 4;
    XPathLexer.WILDCARD = 5;
    XPathLexer.BANG = 6;
    XPathLexer.ID = 7;
    XPathLexer.STRING = 8;
    XPathLexer.channelNames = [
      "DEFAULT_TOKEN_CHANNEL",
      "HIDDEN"
    ];
    XPathLexer.modeNames = [
      "DEFAULT_MODE"
    ];
    XPathLexer.ruleNames = [
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "NameChar",
      "NameStartChar",
      "STRING"
    ];
    XPathLexer._LITERAL_NAMES = [
      void 0,
      void 0,
      void 0,
      "'//'",
      "'/'",
      "'*'",
      "'!'"
    ];
    XPathLexer._SYMBOLIC_NAMES = [
      void 0,
      "TOKEN_REF",
      "RULE_REF",
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "STRING"
    ];
    XPathLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);
    XPathLexer._serializedATNSegments = 2;
    XPathLexer._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\n2\b					\x07	\x07\b	\b			\x07\n\f"\v\x07\x07\b\b		\x07	,\n	\f		/\v			-\n\x07\x07	\b\v	\r\n\u02B6\n2;C\\aac|\x81\xA1\xAC\xAC\xAF\xAF\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0302\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u0485\u0489\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u0593\u05BF\u05C1\u05C1\u05C3\u05C4\u05C6\u05C7\u05C9\u05C9\u05D2\u05EC\u05F2\u05F4\u0602\u0607\u0612\u061C\u061E\u061E\u0622\u066B\u0670\u06D5\u06D7\u06DF\u06E1\u06EA\u06EC\u06FE\u0701\u0701\u0711\u074C\u074F\u07B3\u07C2\u07F7\u07FC\u07FC\u0802\u082F\u0842\u085D\u08A2\u08B6\u08B8\u08BF\u08D6\u0965\u0968\u0971\u0973\u0985\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BE\u09C6\u09C9\u09CA\u09CD\u09D0\u09D9\u09D9\u09DE\u09DF\u09E1\u09E5\u09E8\u09F3\u0A03\u0A05\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A3E\u0A3E\u0A40\u0A44\u0A49\u0A4A\u0A4D\u0A4F\u0A53\u0A53\u0A5B\u0A5E\u0A60\u0A60\u0A68\u0A77\u0A83\u0A85\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABE\u0AC7\u0AC9\u0ACB\u0ACD\u0ACF\u0AD2\u0AD2\u0AE2\u0AE5\u0AE8\u0AF1\u0AFB\u0AFB\u0B03\u0B05\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3E\u0B46\u0B49\u0B4A\u0B4D\u0B4F\u0B58\u0B59\u0B5E\u0B5F\u0B61\u0B65\u0B68\u0B71\u0B73\u0B73\u0B84\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BC0\u0BC4\u0BC8\u0BCA\u0BCC\u0BCF\u0BD2\u0BD2\u0BD9\u0BD9\u0BE8\u0BF1\u0C02\u0C05\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C46\u0C48\u0C4A\u0C4C\u0C4F\u0C57\u0C58\u0C5A\u0C5C\u0C62\u0C65\u0C68\u0C71\u0C82\u0C85\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBE\u0CC6\u0CC8\u0CCA\u0CCC\u0CCF\u0CD7\u0CD8\u0CE0\u0CE0\u0CE2\u0CE5\u0CE8\u0CF1\u0CF3\u0CF4\u0D03\u0D05\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D46\u0D48\u0D4A\u0D4C\u0D50\u0D56\u0D59\u0D61\u0D65\u0D68\u0D71\u0D7C\u0D81\u0D84\u0D85\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0DCC\u0DCC\u0DD1\u0DD6\u0DD8\u0DD8\u0DDA\u0DE1\u0DE8\u0DF1\u0DF4\u0DF5\u0E03\u0E3C\u0E42\u0E50\u0E52\u0E5B\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EBB\u0EBD\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0ECA\u0ECF\u0ED2\u0EDB\u0EDE\u0EE1\u0F02\u0F02\u0F1A\u0F1B\u0F22\u0F2B\u0F37\u0F37\u0F39\u0F39\u0F3B\u0F3B\u0F40\u0F49\u0F4B\u0F6E\u0F73\u0F86\u0F88\u0F99\u0F9B\u0FBE\u0FC8\u0FC8\u1002\u104B\u1052\u109F\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u135F\u1361\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1716\u1722\u1736\u1742\u1755\u1762\u176E\u1770\u1772\u1774\u1775\u1782\u17D5\u17D9\u17D9\u17DE\u17DF\u17E2\u17EB\u180D\u1810\u1812\u181B\u1822\u1879\u1882\u18AC\u18B2\u18F7\u1902\u1920\u1922\u192D\u1932\u193D\u1948\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u19D2\u19DB\u1A02\u1A1D\u1A22\u1A60\u1A62\u1A7E\u1A81\u1A8B\u1A92\u1A9B\u1AA9\u1AA9\u1AB2\u1ABF\u1B02\u1B4D\u1B52\u1B5B\u1B6D\u1B75\u1B82\u1BF5\u1C02\u1C39\u1C42\u1C4B\u1C4F\u1C7F\u1C82\u1C8A\u1CD2\u1CD4\u1CD6\u1CF8\u1CFA\u1CFB\u1D02\u1DF7\u1DFD\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u200D\u2011\u202C\u2030\u2041\u2042\u2056\u2056\u2062\u2066\u2068\u2071\u2073\u2073\u2081\u2081\u2092\u209E\u20D2\u20DE\u20E3\u20E3\u20E7\u20F2\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D81\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2DE2\u2E01\u2E31\u2E31\u3007\u3009\u3023\u3031\u3033\u3037\u303A\u303E\u3043\u3098\u309B\u309C\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA62D\uA642\uA671\uA676\uA67F\uA681\uA6F3\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA829\uA842\uA875\uA882\uA8C7\uA8D2\uA8DB\uA8E2\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA902\uA92F\uA932\uA955\uA962\uA97E\uA982\uA9C2\uA9D1\uA9DB\uA9E2\uAA00\uAA02\uAA38\uAA42\uAA4F\uAA52\uAA5B\uAA62\uAA78\uAA7C\uAAC4\uAADD\uAADF\uAAE2\uAAF1\uAAF4\uAAF8\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABEC\uABEE\uABEF\uABF2\uABFB\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE02\uFE11\uFE22\uFE31\uFE35\uFE36\uFE4F\uFE51\uFE72\uFE76\uFE78\uFEFE\uFF01\uFF01\uFF12\uFF1B\uFF23\uFF3C\uFF41\uFF41\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\uFFFB\uFFFD\r(*<>?AOR_\x82\xFC\u0142\u0176\u01FF\u01FF\u0282\u029E\u02A2\u02D2\u02E2\u02E2\u0302\u0321\u0332\u034C\u0352\u037C\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04A2\u04AB\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A05\u0A07\u0A08\u0A0E\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A3A\u0A3C\u0A41\u0A41\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE8\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1002\u1048\u1068\u1071\u1081\u10BC\u10BF\u10BF\u10D2\u10EA\u10F2\u10FB\u1102\u1136\u1138\u1141\u1152\u1175\u1178\u1178\u1182\u11C6\u11CC\u11CE\u11D2\u11DC\u11DE\u11DE\u1202\u1213\u1215\u1239\u1240\u1240\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12EC\u12F2\u12FB\u1302\u1305\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133E\u1346\u1349\u134A\u134D\u134F\u1352\u1352\u1359\u1359\u135F\u1365\u1368\u136E\u1372\u1376\u1402\u144C\u1452\u145B\u1482\u14C7\u14C9\u14C9\u14D2\u14DB\u1582\u15B7\u15BA\u15C2\u15DA\u15DF\u1602\u1642\u1646\u1646\u1652\u165B\u1682\u16B9\u16C2\u16CB\u1702\u171B\u171F\u172D\u1732\u173B\u18A2\u18EB\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C38\u1C3A\u1C42\u1C52\u1C5B\u1C74\u1C91\u1C94\u1CA9\u1CAB\u1CB8\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6A62\u6A6B\u6AD2\u6AEF\u6AF2\u6AF6\u6B02\u6B38\u6B42\u6B45\u6B52\u6B5B\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F80\u6F91\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uBC9F\uBCA0\uBCA2\uBCA5\uD167\uD16B\uD16F\uD184\uD187\uD18D\uD1AC\uD1AF\uD244\uD246\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uD7D0\uD801\uDA02\uDA38\uDA3D\uDA6E\uDA77\uDA77\uDA86\uDA86\uDA9D\uDAA1\uDAA3\uDAB1\uE002\uE008\uE00A\uE01A\uE01D\uE023\uE025\uE026\uE028\uE02C\uE802\uE8C6\uE8D2\uE8D8\uE902\uE94C\uE952\uE95B\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F"\x81\u0102\u01F1\u0240C\\c|\xAC\xAC\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0372\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u05D2\u05EC\u05F2\u05F4\u0622\u064C\u0670\u0671\u0673\u06D5\u06D7\u06D7\u06E7\u06E8\u06F0\u06F1\u06FC\u06FE\u0701\u0701\u0712\u0712\u0714\u0731\u074F\u07A7\u07B3\u07B3\u07CC\u07EC\u07F6\u07F7\u07FC\u07FC\u0802\u0817\u081C\u081C\u0826\u0826\u082A\u082A\u0842\u085A\u08A2\u08B6\u08B8\u08BF\u0906\u093B\u093F\u093F\u0952\u0952\u095A\u0963\u0973\u0982\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BF\u09BF\u09D0\u09D0\u09DE\u09DF\u09E1\u09E3\u09F2\u09F3\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A5B\u0A5E\u0A60\u0A60\u0A74\u0A76\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABF\u0ABF\u0AD2\u0AD2\u0AE2\u0AE3\u0AFB\u0AFB\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3F\u0B3F\u0B5E\u0B5F\u0B61\u0B63\u0B73\u0B73\u0B85\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BD2\u0BD2\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C3F\u0C5A\u0C5C\u0C62\u0C63\u0C82\u0C82\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBF\u0CBF\u0CE0\u0CE0\u0CE2\u0CE3\u0CF3\u0CF4\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D3F\u0D50\u0D50\u0D56\u0D58\u0D61\u0D63\u0D7C\u0D81\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0E03\u0E32\u0E34\u0E35\u0E42\u0E48\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EB2\u0EB4\u0EB5\u0EBF\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0EDE\u0EE1\u0F02\u0F02\u0F42\u0F49\u0F4B\u0F6E\u0F8A\u0F8E\u1002\u102C\u1041\u1041\u1052\u1057\u105C\u105F\u1063\u1063\u1067\u1068\u1070\u1072\u1077\u1083\u1090\u1090\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1713\u1722\u1733\u1742\u1753\u1762\u176E\u1770\u1772\u1782\u17B5\u17D9\u17D9\u17DE\u17DE\u1822\u1879\u1882\u1886\u1889\u18AA\u18AC\u18AC\u18B2\u18F7\u1902\u1920\u1952\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u1A02\u1A18\u1A22\u1A56\u1AA9\u1AA9\u1B07\u1B35\u1B47\u1B4D\u1B85\u1BA2\u1BB0\u1BB1\u1BBC\u1BE7\u1C02\u1C25\u1C4F\u1C51\u1C5C\u1C7F\u1C82\u1C8A\u1CEB\u1CEE\u1CF0\u1CF3\u1CF7\u1CF8\u1D02\u1DC1\u1E02\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u2073\u2073\u2081\u2081\u2092\u209E\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF0\u2CF4\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D82\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2E31\u2E31\u3007\u3009\u3023\u302B\u3033\u3037\u303A\u303E\u3043\u3098\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA621\uA62C\uA62D\uA642\uA670\uA681\uA69F\uA6A2\uA6F1\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA803\uA805\uA807\uA809\uA80C\uA80E\uA824\uA842\uA875\uA884\uA8B5\uA8F4\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA90C\uA927\uA932\uA948\uA962\uA97E\uA986\uA9B4\uA9D1\uA9D1\uA9E2\uA9E6\uA9E8\uA9F1\uA9FC\uAA00\uAA02\uAA2A\uAA42\uAA44\uAA46\uAA4D\uAA62\uAA78\uAA7C\uAA7C\uAA80\uAAB1\uAAB3\uAAB3\uAAB7\uAAB8\uAABB\uAABF\uAAC2\uAAC2\uAAC4\uAAC4\uAADD\uAADF\uAAE2\uAAEC\uAAF4\uAAF6\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABE4\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB1F\uFB21\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE72\uFE76\uFE78\uFEFE\uFF23\uFF3C\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\r(*<>?AOR_\x82\xFC\u0142\u0176\u0282\u029E\u02A2\u02D2\u0302\u0321\u0332\u034C\u0352\u0377\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A02\u0A12\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE6\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1005\u1039\u1085\u10B1\u10D2\u10EA\u1105\u1128\u1152\u1174\u1178\u1178\u1185\u11B4\u11C3\u11C6\u11DC\u11DC\u11DE\u11DE\u1202\u1213\u1215\u122D\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12E0\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133F\u133F\u1352\u1352\u135F\u1363\u1402\u1436\u1449\u144C\u1482\u14B1\u14C6\u14C7\u14C9\u14C9\u1582\u15B0\u15DA\u15DD\u1602\u1631\u1646\u1646\u1682\u16AC\u1702\u171B\u18A2\u18E1\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C30\u1C42\u1C42\u1C74\u1C91\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6AD2\u6AEF\u6B02\u6B31\u6B42\u6B45\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F52\u6F95\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548';
    XPathLexer._serializedATNSegment1 = `\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uE802\uE8C6\uE902\uE945\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F1\x07	\v\x07	\v\r%')\x071\x071\x071\x07,\b\x1B\x07#\x1B
 \b\r\x07"  !!#" #$\b$\f%&	&'(	()-\x07)*,\v+*,/-.-+.0/-01\x07)1 -`;
    XPathLexer._serializedATN = Utils3.join([
      XPathLexer._serializedATNSegment0,
      XPathLexer._serializedATNSegment1
    ], "");
  }
});

// node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js
var require_XPathLexerErrorListener = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathLexerErrorListener = void 0;
    var Decorators_1 = require_Decorators();
    var XPathLexerErrorListener = class {
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathLexerErrorListener.prototype, "syntaxError", null);
    exports.XPathLexerErrorListener = XPathLexerErrorListener;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathElement.js
var require_XPathElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathElement = void 0;
    var Decorators_1 = require_Decorators();
    var XPathElement = class {
      constructor(nodeName) {
        this.nodeName = nodeName;
        this.invert = false;
      }
      toString() {
        let inv = this.invert ? "!" : "";
        let className = Object.constructor.name;
        return className + "[" + inv + this.nodeName + "]";
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathElement.prototype, "toString", null);
    exports.XPathElement = XPathElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js
var require_XPathRuleAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathRuleAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathRuleAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        return Trees_1.Trees.findAllRuleNodes(t, this.ruleIndex);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathRuleAnywhereElement.prototype, "evaluate", null);
    exports.XPathRuleAnywhereElement = XPathRuleAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathRuleElement.js
var require_XPathRuleElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathRuleElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathRuleElement = void 0;
    var ParserRuleContext_1 = require_ParserRuleContext();
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathRuleElement = class extends XPathElement_1.XPathElement {
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        let nodes = [];
        for (let c of Trees_1.Trees.getChildren(t)) {
          if (c instanceof ParserRuleContext_1.ParserRuleContext) {
            if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
              nodes.push(c);
            }
          }
        }
        return nodes;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathRuleElement.prototype, "evaluate", null);
    exports.XPathRuleElement = XPathRuleElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js
var require_XPathTokenAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathTokenAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathTokenAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        return Trees_1.Trees.findAllTokenNodes(t, this.tokenType);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathTokenAnywhereElement.prototype, "evaluate", null);
    exports.XPathTokenAnywhereElement = XPathTokenAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathTokenElement.js
var require_XPathTokenElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathTokenElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathTokenElement = void 0;
    var Decorators_1 = require_Decorators();
    var TerminalNode_1 = require_TerminalNode();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathTokenElement = class extends XPathElement_1.XPathElement {
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        let nodes = [];
        for (let c of Trees_1.Trees.getChildren(t)) {
          if (c instanceof TerminalNode_1.TerminalNode) {
            if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
              nodes.push(c);
            }
          }
        }
        return nodes;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathTokenElement.prototype, "evaluate", null);
    exports.XPathTokenElement = XPathTokenElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js
var require_XPathWildcardAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathWildcardAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPath_1 = require_XPath();
    var XPathElement_1 = require_XPathElement();
    var XPathWildcardAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor() {
        super(XPath_1.XPath.WILDCARD);
      }
      evaluate(t) {
        if (this.invert) {
          return [];
        }
        return Trees_1.Trees.getDescendants(t);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathWildcardAnywhereElement.prototype, "evaluate", null);
    exports.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js
var require_XPathWildcardElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathWildcardElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPath_1 = require_XPath();
    var XPathElement_1 = require_XPathElement();
    var XPathWildcardElement = class extends XPathElement_1.XPathElement {
      constructor() {
        super(XPath_1.XPath.WILDCARD);
      }
      evaluate(t) {
        let kids = [];
        if (this.invert) {
          return kids;
        }
        for (let c of Trees_1.Trees.getChildren(t)) {
          kids.push(c);
        }
        return kids;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathWildcardElement.prototype, "evaluate", null);
    exports.XPathWildcardElement = XPathWildcardElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPath.js
var require_XPath = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPath = void 0;
    var CharStreams_1 = require_CharStreams();
    var CommonTokenStream_1 = require_CommonTokenStream();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var Token_1 = require_Token();
    var XPathLexer_1 = require_XPathLexer();
    var XPathLexerErrorListener_1 = require_XPathLexerErrorListener();
    var XPathRuleAnywhereElement_1 = require_XPathRuleAnywhereElement();
    var XPathRuleElement_1 = require_XPathRuleElement();
    var XPathTokenAnywhereElement_1 = require_XPathTokenAnywhereElement();
    var XPathTokenElement_1 = require_XPathTokenElement();
    var XPathWildcardAnywhereElement_1 = require_XPathWildcardAnywhereElement();
    var XPathWildcardElement_1 = require_XPathWildcardElement();
    var XPath = class {
      constructor(parser, path2) {
        this.parser = parser;
        this.path = path2;
        this.elements = this.split(path2);
      }
      split(path2) {
        let lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path2));
        lexer.recover = (e) => {
          throw e;
        };
        lexer.removeErrorListeners();
        lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());
        let tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);
        try {
          tokenStream.fill();
        } catch (e) {
          if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
            let pos = lexer.charPositionInLine;
            let msg = "Invalid tokens or characters at index " + pos + " in path '" + path2 + "' -- " + e.message;
            throw new RangeError(msg);
          }
          throw e;
        }
        let tokens = tokenStream.getTokens();
        let elements = [];
        let n = tokens.length;
        let i = 0;
        loop:
          while (i < n) {
            let el = tokens[i];
            let next;
            switch (el.type) {
              case XPathLexer_1.XPathLexer.ROOT:
              case XPathLexer_1.XPathLexer.ANYWHERE:
                let anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;
                i++;
                next = tokens[i];
                let invert = next.type === XPathLexer_1.XPathLexer.BANG;
                if (invert) {
                  i++;
                  next = tokens[i];
                }
                let pathElement = this.getXPathElement(next, anywhere);
                pathElement.invert = invert;
                elements.push(pathElement);
                i++;
                break;
              case XPathLexer_1.XPathLexer.TOKEN_REF:
              case XPathLexer_1.XPathLexer.RULE_REF:
              case XPathLexer_1.XPathLexer.WILDCARD:
                elements.push(this.getXPathElement(el, false));
                i++;
                break;
              case Token_1.Token.EOF:
                break loop;
              default:
                throw new Error("Unknowth path element " + el);
            }
          }
        return elements;
      }
      getXPathElement(wordToken, anywhere) {
        if (wordToken.type === Token_1.Token.EOF) {
          throw new Error("Missing path element at end of path");
        }
        let word = wordToken.text;
        if (word == null) {
          throw new Error("Expected wordToken to have text content.");
        }
        let ttype = this.parser.getTokenType(word);
        let ruleIndex = this.parser.getRuleIndex(word);
        switch (wordToken.type) {
          case XPathLexer_1.XPathLexer.WILDCARD:
            return anywhere ? new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() : new XPathWildcardElement_1.XPathWildcardElement();
          case XPathLexer_1.XPathLexer.TOKEN_REF:
          case XPathLexer_1.XPathLexer.STRING:
            if (ttype === Token_1.Token.INVALID_TYPE) {
              throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid token name");
            }
            return anywhere ? new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement_1.XPathTokenElement(word, ttype);
          default:
            if (ruleIndex === -1) {
              throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid rule name");
            }
            return anywhere ? new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);
        }
      }
      static findAll(tree, xpath, parser) {
        let p = new XPath(parser, xpath);
        return p.evaluate(tree);
      }
      evaluate(t) {
        let dummyRoot = new ParserRuleContext_1.ParserRuleContext();
        dummyRoot.addChild(t);
        let work = /* @__PURE__ */ new Set([dummyRoot]);
        let i = 0;
        while (i < this.elements.length) {
          let next = /* @__PURE__ */ new Set();
          for (let node of work) {
            if (node.childCount > 0) {
              let matching = this.elements[i].evaluate(node);
              matching.forEach(next.add, next);
            }
          }
          i++;
          work = next;
        }
        return work;
      }
    };
    exports.XPath = XPath;
    XPath.WILDCARD = "*";
    XPath.NOT = "!";
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreePattern.js
var require_ParseTreePattern = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreePattern.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreePattern = void 0;
    var Decorators_1 = require_Decorators();
    var XPath_1 = require_XPath();
    var ParseTreePattern = class ParseTreePattern {
      constructor(matcher, pattern, patternRuleIndex, patternTree) {
        this._matcher = matcher;
        this._patternRuleIndex = patternRuleIndex;
        this._pattern = pattern;
        this._patternTree = patternTree;
      }
      match(tree) {
        return this._matcher.match(tree, this);
      }
      matches(tree) {
        return this._matcher.match(tree, this).succeeded;
      }
      findAll(tree, xpath) {
        let subtrees = XPath_1.XPath.findAll(tree, xpath, this._matcher.parser);
        let matches = [];
        for (let t of subtrees) {
          let match = this.match(t);
          if (match.succeeded) {
            matches.push(match);
          }
        }
        return matches;
      }
      get matcher() {
        return this._matcher;
      }
      get pattern() {
        return this._pattern;
      }
      get patternRuleIndex() {
        return this._patternRuleIndex;
      }
      get patternTree() {
        return this._patternTree;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_pattern", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_patternTree", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_matcher", void 0);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "match", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "matches", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "findAll", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "matcher", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "pattern", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "patternTree", null);
    ParseTreePattern = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParseTreePattern);
    exports.ParseTreePattern = ParseTreePattern;
  }
});

// node_modules/antlr4ts/tree/pattern/RuleTagToken.js
var require_RuleTagToken = __commonJS({
  "node_modules/antlr4ts/tree/pattern/RuleTagToken.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleTagToken = void 0;
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var RuleTagToken = class RuleTagToken {
      constructor(ruleName, bypassTokenType, label) {
        if (ruleName == null || ruleName.length === 0) {
          throw new Error("ruleName cannot be null or empty.");
        }
        this._ruleName = ruleName;
        this.bypassTokenType = bypassTokenType;
        this._label = label;
      }
      get ruleName() {
        return this._ruleName;
      }
      get label() {
        return this._label;
      }
      get channel() {
        return Token_1.Token.DEFAULT_CHANNEL;
      }
      get text() {
        if (this._label != null) {
          return "<" + this._label + ":" + this._ruleName + ">";
        }
        return "<" + this._ruleName + ">";
      }
      get type() {
        return this.bypassTokenType;
      }
      get line() {
        return 0;
      }
      get charPositionInLine() {
        return -1;
      }
      get tokenIndex() {
        return -1;
      }
      get startIndex() {
        return -1;
      }
      get stopIndex() {
        return -1;
      }
      get tokenSource() {
        return void 0;
      }
      get inputStream() {
        return void 0;
      }
      toString() {
        return this._ruleName + ":" + this.bypassTokenType;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], RuleTagToken.prototype, "ruleName", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "channel", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "type", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "tokenIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "startIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "stopIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "toString", null);
    RuleTagToken = __decorate([
      __param(0, Decorators_1.NotNull)
    ], RuleTagToken);
    exports.RuleTagToken = RuleTagToken;
  }
});

// node_modules/antlr4ts/tree/pattern/Chunk.js
var require_Chunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/Chunk.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chunk = void 0;
    var Chunk = class {
    };
    exports.Chunk = Chunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TagChunk.js
var require_TagChunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TagChunk.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TagChunk = void 0;
    var Chunk_1 = require_Chunk();
    var Decorators_1 = require_Decorators();
    var TagChunk = class extends Chunk_1.Chunk {
      constructor(tag, label) {
        super();
        if (tag == null || tag.length === 0) {
          throw new Error("tag cannot be null or empty");
        }
        this._tag = tag;
        this._label = label;
      }
      get tag() {
        return this._tag;
      }
      get label() {
        return this._label;
      }
      toString() {
        if (this._label != null) {
          return this._label + ":" + this._tag;
        }
        return this._tag;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TagChunk.prototype, "tag", null);
    __decorate([
      Decorators_1.Override
    ], TagChunk.prototype, "toString", null);
    exports.TagChunk = TagChunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TextChunk.js
var require_TextChunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TextChunk.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextChunk = void 0;
    var Chunk_1 = require_Chunk();
    var Decorators_1 = require_Decorators();
    var TextChunk = class TextChunk extends Chunk_1.Chunk {
      constructor(text4) {
        super();
        if (text4 == null) {
          throw new Error("text cannot be null");
        }
        this._text = text4;
      }
      get text() {
        return this._text;
      }
      toString() {
        return "'" + this._text + "'";
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TextChunk.prototype, "_text", void 0);
    __decorate([
      Decorators_1.NotNull
    ], TextChunk.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TextChunk.prototype, "toString", null);
    TextChunk = __decorate([
      __param(0, Decorators_1.NotNull)
    ], TextChunk);
    exports.TextChunk = TextChunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TokenTagToken.js
var require_TokenTagToken = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TokenTagToken.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenTagToken = void 0;
    var CommonToken_1 = require_CommonToken();
    var Decorators_1 = require_Decorators();
    var TokenTagToken = class TokenTagToken extends CommonToken_1.CommonToken {
      constructor(tokenName, type, label) {
        super(type);
        this._tokenName = tokenName;
        this._label = label;
      }
      get tokenName() {
        return this._tokenName;
      }
      get label() {
        return this._label;
      }
      get text() {
        if (this._label != null) {
          return "<" + this._label + ":" + this._tokenName + ">";
        }
        return "<" + this._tokenName + ">";
      }
      toString() {
        return this._tokenName + ":" + this.type;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TokenTagToken.prototype, "_tokenName", void 0);
    __decorate([
      Decorators_1.NotNull
    ], TokenTagToken.prototype, "tokenName", null);
    __decorate([
      Decorators_1.Override
    ], TokenTagToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TokenTagToken.prototype, "toString", null);
    TokenTagToken = __decorate([
      __param(0, Decorators_1.NotNull)
    ], TokenTagToken);
    exports.TokenTagToken = TokenTagToken;
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js
var require_ParseTreePatternMatcher = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreePatternMatcher = void 0;
    var BailErrorStrategy_1 = require_BailErrorStrategy();
    var CharStreams_1 = require_CharStreams();
    var CommonTokenStream_1 = require_CommonTokenStream();
    var ListTokenSource_1 = require_ListTokenSource();
    var MultiMap_1 = require_MultiMap();
    var Decorators_1 = require_Decorators();
    var ParseCancellationException_1 = require_ParseCancellationException();
    var ParserInterpreter_1 = require_ParserInterpreter();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var ParseTreeMatch_1 = require_ParseTreeMatch();
    var ParseTreePattern_1 = require_ParseTreePattern();
    var RecognitionException_1 = require_RecognitionException();
    var RuleNode_1 = require_RuleNode();
    var RuleTagToken_1 = require_RuleTagToken();
    var TagChunk_1 = require_TagChunk();
    var TerminalNode_1 = require_TerminalNode();
    var TextChunk_1 = require_TextChunk();
    var Token_1 = require_Token();
    var TokenTagToken_1 = require_TokenTagToken();
    var ParseTreePatternMatcher = class {
      constructor(lexer, parser) {
        this.start = "<";
        this.stop = ">";
        this.escape = "\\";
        this.escapeRE = /\\/g;
        this._lexer = lexer;
        this._parser = parser;
      }
      setDelimiters(start, stop, escapeLeft) {
        if (!start) {
          throw new Error("start cannot be null or empty");
        }
        if (!stop) {
          throw new Error("stop cannot be null or empty");
        }
        this.start = start;
        this.stop = stop;
        this.escape = escapeLeft;
        this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
      }
      matches(tree, pattern, patternRuleIndex = 0) {
        if (typeof pattern === "string") {
          let p = this.compile(pattern, patternRuleIndex);
          return this.matches(tree, p);
        } else {
          let labels = new MultiMap_1.MultiMap();
          let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
          return !mismatchedNode;
        }
      }
      match(tree, pattern, patternRuleIndex = 0) {
        if (typeof pattern === "string") {
          let p = this.compile(pattern, patternRuleIndex);
          return this.match(tree, p);
        } else {
          let labels = new MultiMap_1.MultiMap();
          let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
          return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);
        }
      }
      compile(pattern, patternRuleIndex) {
        let tokenList = this.tokenize(pattern);
        let tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);
        let tokens = new CommonTokenStream_1.CommonTokenStream(tokenSrc);
        const parser = this._parser;
        let parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens);
        let tree;
        try {
          parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();
          tree = parserInterp.parse(patternRuleIndex);
        } catch (e) {
          if (e instanceof ParseCancellationException_1.ParseCancellationException) {
            throw e.getCause();
          } else if (e instanceof RecognitionException_1.RecognitionException) {
            throw e;
          } else if (e instanceof Error) {
            throw new ParseTreePatternMatcher.CannotInvokeStartRule(e);
          } else {
            throw e;
          }
        }
        if (tokens.LA(1) !== Token_1.Token.EOF) {
          throw new ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();
        }
        return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);
      }
      get lexer() {
        return this._lexer;
      }
      get parser() {
        return this._parser;
      }
      matchImpl(tree, patternTree, labels) {
        if (!tree) {
          throw new TypeError("tree cannot be null");
        }
        if (!patternTree) {
          throw new TypeError("patternTree cannot be null");
        }
        if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {
          let mismatchedNode;
          if (tree.symbol.type === patternTree.symbol.type) {
            if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) {
              let tokenTagToken = patternTree.symbol;
              labels.map(tokenTagToken.tokenName, tree);
              const l = tokenTagToken.label;
              if (l) {
                labels.map(l, tree);
              }
            } else if (tree.text === patternTree.text) {
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
          } else {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
          }
          return mismatchedNode;
        }
        if (tree instanceof ParserRuleContext_1.ParserRuleContext && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {
          let mismatchedNode;
          let ruleTagToken = this.getRuleTagToken(patternTree);
          if (ruleTagToken) {
            let m;
            if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {
              labels.map(ruleTagToken.ruleName, tree);
              const l = ruleTagToken.label;
              if (l) {
                labels.map(l, tree);
              }
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
            return mismatchedNode;
          }
          if (tree.childCount !== patternTree.childCount) {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
            return mismatchedNode;
          }
          let n = tree.childCount;
          for (let i = 0; i < n; i++) {
            let childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
            if (childMatch) {
              return childMatch;
            }
          }
          return mismatchedNode;
        }
        return tree;
      }
      getRuleTagToken(t) {
        if (t instanceof RuleNode_1.RuleNode) {
          if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {
            let c = t.getChild(0);
            if (c.symbol instanceof RuleTagToken_1.RuleTagToken) {
              return c.symbol;
            }
          }
        }
        return void 0;
      }
      tokenize(pattern) {
        let chunks = this.split(pattern);
        let tokens = [];
        for (let chunk of chunks) {
          if (chunk instanceof TagChunk_1.TagChunk) {
            let tagChunk = chunk;
            const firstChar = tagChunk.tag.substr(0, 1);
            if (firstChar === firstChar.toUpperCase()) {
              let ttype = this._parser.getTokenType(tagChunk.tag);
              if (ttype === Token_1.Token.INVALID_TYPE) {
                throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
              }
              let t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
              tokens.push(t);
            } else if (firstChar === firstChar.toLowerCase()) {
              let ruleIndex = this._parser.getRuleIndex(tagChunk.tag);
              if (ruleIndex === -1) {
                throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
              }
              let ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
              tokens.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
            } else {
              throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
            }
          } else {
            let textChunk = chunk;
            this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);
            let t = this._lexer.nextToken();
            while (t.type !== Token_1.Token.EOF) {
              tokens.push(t);
              t = this._lexer.nextToken();
            }
          }
        }
        return tokens;
      }
      split(pattern) {
        let p = 0;
        let n = pattern.length;
        let chunks = [];
        let buf;
        let starts = [];
        let stops = [];
        while (p < n) {
          if (p === pattern.indexOf(this.escape + this.start, p)) {
            p += this.escape.length + this.start.length;
          } else if (p === pattern.indexOf(this.escape + this.stop, p)) {
            p += this.escape.length + this.stop.length;
          } else if (p === pattern.indexOf(this.start, p)) {
            starts.push(p);
            p += this.start.length;
          } else if (p === pattern.indexOf(this.stop, p)) {
            stops.push(p);
            p += this.stop.length;
          } else {
            p++;
          }
        }
        if (starts.length > stops.length) {
          throw new Error("unterminated tag in pattern: " + pattern);
        }
        if (starts.length < stops.length) {
          throw new Error("missing start tag in pattern: " + pattern);
        }
        let ntags = starts.length;
        for (let i = 0; i < ntags; i++) {
          if (starts[i] >= stops[i]) {
            throw new Error("tag delimiters out of order in pattern: " + pattern);
          }
        }
        if (ntags === 0) {
          let text4 = pattern.substring(0, n);
          chunks.push(new TextChunk_1.TextChunk(text4));
        }
        if (ntags > 0 && starts[0] > 0) {
          let text4 = pattern.substring(0, starts[0]);
          chunks.push(new TextChunk_1.TextChunk(text4));
        }
        for (let i = 0; i < ntags; i++) {
          let tag = pattern.substring(starts[i] + this.start.length, stops[i]);
          let ruleOrToken = tag;
          let label;
          let colon = tag.indexOf(":");
          if (colon >= 0) {
            label = tag.substring(0, colon);
            ruleOrToken = tag.substring(colon + 1, tag.length);
          }
          chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));
          if (i + 1 < ntags) {
            let text4 = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);
            chunks.push(new TextChunk_1.TextChunk(text4));
          }
        }
        if (ntags > 0) {
          let afterLastTag = stops[ntags - 1] + this.stop.length;
          if (afterLastTag < n) {
            let text4 = pattern.substring(afterLastTag, n);
            chunks.push(new TextChunk_1.TextChunk(text4));
          }
        }
        for (let i = 0; i < chunks.length; i++) {
          let c = chunks[i];
          if (c instanceof TextChunk_1.TextChunk) {
            let unescaped = c.text.replace(this.escapeRE, "");
            if (unescaped.length < c.text.length) {
              chunks[i] = new TextChunk_1.TextChunk(unescaped);
            }
          }
        }
        return chunks;
      }
    };
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], ParseTreePatternMatcher.prototype, "match", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePatternMatcher.prototype, "lexer", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePatternMatcher.prototype, "parser", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParseTreePatternMatcher.prototype, "matchImpl", null);
    exports.ParseTreePatternMatcher = ParseTreePatternMatcher;
    (function(ParseTreePatternMatcher2) {
      class CannotInvokeStartRule extends Error {
        constructor(error) {
          super(`CannotInvokeStartRule: ${error}`);
          this.error = error;
        }
      }
      ParseTreePatternMatcher2.CannotInvokeStartRule = CannotInvokeStartRule;
      class StartRuleDoesNotConsumeFullPattern extends Error {
        constructor() {
          super("StartRuleDoesNotConsumeFullPattern");
        }
      }
      ParseTreePatternMatcher2.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;
    })(ParseTreePatternMatcher = exports.ParseTreePatternMatcher || (exports.ParseTreePatternMatcher = {}));
  }
});

// node_modules/antlr4ts/atn/DecisionEventInfo.js
var require_DecisionEventInfo = __commonJS({
  "node_modules/antlr4ts/atn/DecisionEventInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionEventInfo = void 0;
    var Decorators_1 = require_Decorators();
    var DecisionEventInfo = class DecisionEventInfo {
      constructor(decision, state, input, startIndex, stopIndex, fullCtx) {
        this.decision = decision;
        this.fullCtx = fullCtx;
        this.stopIndex = stopIndex;
        this.input = input;
        this.startIndex = startIndex;
        this.state = state;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DecisionEventInfo.prototype, "input", void 0);
    DecisionEventInfo = __decorate([
      __param(2, Decorators_1.NotNull)
    ], DecisionEventInfo);
    exports.DecisionEventInfo = DecisionEventInfo;
  }
});

// node_modules/antlr4ts/atn/AmbiguityInfo.js
var require_AmbiguityInfo = __commonJS({
  "node_modules/antlr4ts/atn/AmbiguityInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AmbiguityInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var AmbiguityInfo = class AmbiguityInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, ambigAlts, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
        this.ambigAlts = ambigAlts;
      }
      get ambiguousAlternatives() {
        return this.ambigAlts;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], AmbiguityInfo.prototype, "ambigAlts", void 0);
    __decorate([
      Decorators_1.NotNull
    ], AmbiguityInfo.prototype, "ambiguousAlternatives", null);
    AmbiguityInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], AmbiguityInfo);
    exports.AmbiguityInfo = AmbiguityInfo;
  }
});

// node_modules/antlr4ts/atn/ContextSensitivityInfo.js
var require_ContextSensitivityInfo = __commonJS({
  "node_modules/antlr4ts/atn/ContextSensitivityInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextSensitivityInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var ContextSensitivityInfo = class ContextSensitivityInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, true);
      }
    };
    ContextSensitivityInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ContextSensitivityInfo);
    exports.ContextSensitivityInfo = ContextSensitivityInfo;
  }
});

// node_modules/antlr4ts/atn/DecisionInfo.js
var require_DecisionInfo = __commonJS({
  "node_modules/antlr4ts/atn/DecisionInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionInfo = void 0;
    var Decorators_1 = require_Decorators();
    var DecisionInfo = class {
      constructor(decision) {
        this.invocations = 0;
        this.timeInPrediction = 0;
        this.SLL_TotalLook = 0;
        this.SLL_MinLook = 0;
        this.SLL_MaxLook = 0;
        this.LL_TotalLook = 0;
        this.LL_MinLook = 0;
        this.LL_MaxLook = 0;
        this.contextSensitivities = [];
        this.errors = [];
        this.ambiguities = [];
        this.predicateEvals = [];
        this.SLL_ATNTransitions = 0;
        this.SLL_DFATransitions = 0;
        this.LL_Fallback = 0;
        this.LL_ATNTransitions = 0;
        this.LL_DFATransitions = 0;
        this.decision = decision;
      }
      toString() {
        return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", SLL_lookahead=" + this.SLL_TotalLook + ", SLL_ATNTransitions=" + this.SLL_ATNTransitions + ", SLL_DFATransitions=" + this.SLL_DFATransitions + ", LL_Fallback=" + this.LL_Fallback + ", LL_lookahead=" + this.LL_TotalLook + ", LL_ATNTransitions=" + this.LL_ATNTransitions + "}";
      }
    };
    __decorate([
      Decorators_1.Override
    ], DecisionInfo.prototype, "toString", null);
    exports.DecisionInfo = DecisionInfo;
  }
});

// node_modules/antlr4ts/atn/ErrorInfo.js
var require_ErrorInfo = __commonJS({
  "node_modules/antlr4ts/atn/ErrorInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var ErrorInfo = class ErrorInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
      }
    };
    ErrorInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ErrorInfo);
    exports.ErrorInfo = ErrorInfo;
  }
});

// node_modules/antlr4ts/atn/LookaheadEventInfo.js
var require_LookaheadEventInfo = __commonJS({
  "node_modules/antlr4ts/atn/LookaheadEventInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LookaheadEventInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var LookaheadEventInfo = class LookaheadEventInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {
        super(decision, state, input, startIndex, stopIndex, fullCtx);
        this.predictedAlt = predictedAlt;
      }
    };
    LookaheadEventInfo = __decorate([
      __param(3, Decorators_1.NotNull)
    ], LookaheadEventInfo);
    exports.LookaheadEventInfo = LookaheadEventInfo;
  }
});

// node_modules/antlr4ts/atn/PredicateEvalInfo.js
var require_PredicateEvalInfo = __commonJS({
  "node_modules/antlr4ts/atn/PredicateEvalInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredicateEvalInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var PredicateEvalInfo = class PredicateEvalInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
        this.semctx = semctx;
        this.evalResult = evalResult;
        this.predictedAlt = predictedAlt;
      }
    };
    PredicateEvalInfo = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], PredicateEvalInfo);
    exports.PredicateEvalInfo = PredicateEvalInfo;
  }
});

// node_modules/antlr4ts/atn/ProfilingATNSimulator.js
var require_ProfilingATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ProfilingATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProfilingATNSimulator = void 0;
    var AmbiguityInfo_1 = require_AmbiguityInfo();
    var ATN_1 = require_ATN();
    var ATNSimulator_1 = require_ATNSimulator();
    var ContextSensitivityInfo_1 = require_ContextSensitivityInfo();
    var DecisionInfo_1 = require_DecisionInfo();
    var ErrorInfo_1 = require_ErrorInfo();
    var Decorators_1 = require_Decorators();
    var LookaheadEventInfo_1 = require_LookaheadEventInfo();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var PredicateEvalInfo_1 = require_PredicateEvalInfo();
    var SemanticContext_1 = require_SemanticContext();
    var SimulatorState_1 = require_SimulatorState();
    var ProfilingATNSimulator = class extends ParserATNSimulator_1.ParserATNSimulator {
      constructor(parser) {
        super(parser.interpreter.atn, parser);
        this._startIndex = 0;
        this._sllStopIndex = 0;
        this._llStopIndex = 0;
        this.currentDecision = 0;
        this.conflictingAltResolvedBySLL = 0;
        this.optimize_ll1 = false;
        this.reportAmbiguities = true;
        this.numDecisions = this.atn.decisionToState.length;
        this.decisions = [];
        for (let i = 0; i < this.numDecisions; i++) {
          this.decisions.push(new DecisionInfo_1.DecisionInfo(i));
        }
      }
      adaptivePredict(input, decision, outerContext, useContext) {
        if (useContext !== void 0) {
          return super.adaptivePredict(input, decision, outerContext, useContext);
        }
        try {
          this._input = input;
          this._startIndex = input.index;
          this._sllStopIndex = this._startIndex - 1;
          this._llStopIndex = -1;
          this.currentDecision = decision;
          this.currentState = void 0;
          this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;
          let start = process.hrtime();
          let alt = super.adaptivePredict(input, decision, outerContext);
          let stop = process.hrtime();
          let nanoseconds = (stop[0] - start[0]) * 1e9;
          if (nanoseconds === 0) {
            nanoseconds = stop[1] - start[1];
          } else {
            nanoseconds += 1e9 - start[1] + stop[1];
          }
          this.decisions[decision].timeInPrediction += nanoseconds;
          this.decisions[decision].invocations++;
          let SLL_k = this._sllStopIndex - this._startIndex + 1;
          this.decisions[decision].SLL_TotalLook += SLL_k;
          this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);
          if (SLL_k > this.decisions[decision].SLL_MaxLook) {
            this.decisions[decision].SLL_MaxLook = SLL_k;
            this.decisions[decision].SLL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._sllStopIndex, false);
          }
          if (this._llStopIndex >= 0) {
            let LL_k = this._llStopIndex - this._startIndex + 1;
            this.decisions[decision].LL_TotalLook += LL_k;
            this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);
            if (LL_k > this.decisions[decision].LL_MaxLook) {
              this.decisions[decision].LL_MaxLook = LL_k;
              this.decisions[decision].LL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._llStopIndex, true);
            }
          }
          return alt;
        } finally {
          this._input = void 0;
          this.currentDecision = -1;
        }
      }
      getStartState(dfa, input, outerContext, useContext) {
        let state = super.getStartState(dfa, input, outerContext, useContext);
        this.currentState = state;
        return state;
      }
      computeStartState(dfa, globalContext, useContext) {
        let state = super.computeStartState(dfa, globalContext, useContext);
        this.currentState = state;
        return state;
      }
      computeReachSet(dfa, previous4, t, contextCache) {
        if (this._input === void 0) {
          throw new Error("Invalid state");
        }
        let reachState = super.computeReachSet(dfa, previous4, t, contextCache);
        if (reachState == null) {
          this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous4, this._input, this._startIndex, this._input.index));
        }
        this.currentState = reachState;
        return reachState;
      }
      getExistingTargetState(previousD, t) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        if (this.currentState.useContext) {
          this._llStopIndex = this._input.index;
        } else {
          this._sllStopIndex = this._input.index;
        }
        let existingTargetState = super.getExistingTargetState(previousD, t);
        if (existingTargetState != null) {
          this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);
          if (this.currentState.useContext) {
            this.decisions[this.currentDecision].LL_DFATransitions++;
          } else {
            this.decisions[this.currentDecision].SLL_DFATransitions++;
          }
          if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {
            let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);
            this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));
          }
        }
        return existingTargetState;
      }
      computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
        let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);
        if (useContext) {
          this.decisions[this.currentDecision].LL_ATNTransitions++;
        } else {
          this.decisions[this.currentDecision].SLL_ATNTransitions++;
        }
        return targetState;
      }
      evalSemanticContextImpl(pred, parserCallStack, alt) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);
        if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {
          let fullContext = this._llStopIndex >= 0;
          let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;
          this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));
        }
        return result;
      }
      reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
        if (this._input === void 0) {
          throw new Error("Invalid state");
        }
        if (prediction !== this.conflictingAltResolvedBySLL) {
          this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));
        }
        super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);
      }
      reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
        if (conflictingAlts != null) {
          this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
        } else {
          this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);
        }
        this.decisions[this.currentDecision].LL_Fallback++;
        super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);
      }
      reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        let prediction;
        if (ambigAlts != null) {
          prediction = ambigAlts.nextSetBit(0);
        } else {
          prediction = configs.getRepresentedAlternatives().nextSetBit(0);
        }
        if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {
          this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));
        }
        this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));
        super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);
      }
      getDecisionInfo() {
        return this.decisions;
      }
      getCurrentState() {
        return this.currentState;
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], ProfilingATNSimulator.prototype, "adaptivePredict", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "getStartState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeStartState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeReachSet", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeTargetState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "evalSemanticContextImpl", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "reportContextSensitivity", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ProfilingATNSimulator.prototype, "reportAmbiguity", null);
    exports.ProfilingATNSimulator = ProfilingATNSimulator;
  }
});

// node_modules/antlr4ts/Parser.js
var require_Parser = __commonJS({
  "node_modules/antlr4ts/Parser.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Utils3 = require_Utils();
    var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
    var ATNDeserializer_1 = require_ATNDeserializer();
    var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
    var ErrorNode_1 = require_ErrorNode();
    var IntegerStack_1 = require_IntegerStack();
    var Lexer_1 = require_Lexer();
    var Decorators_1 = require_Decorators();
    var ParseInfo_1 = require_ParseInfo();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var ProxyParserErrorListener_1 = require_ProxyParserErrorListener();
    var Recognizer_1 = require_Recognizer();
    var TerminalNode_1 = require_TerminalNode();
    var Token_1 = require_Token();
    var TraceListener = class {
      constructor(ruleNames, tokenStream) {
        this.ruleNames = ruleNames;
        this.tokenStream = tokenStream;
      }
      enterEveryRule(ctx) {
        console.log("enter   " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
      }
      exitEveryRule(ctx) {
        console.log("exit    " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
      }
      visitErrorNode(node) {
      }
      visitTerminal(node) {
        let parent = node.parent.ruleContext;
        let token = node.symbol;
        console.log("consume " + token + " rule " + this.ruleNames[parent.ruleIndex]);
      }
    };
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "enterEveryRule", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "exitEveryRule", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "visitErrorNode", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "visitTerminal", null);
    var Parser2 = class extends Recognizer_1.Recognizer {
      constructor(input) {
        super();
        this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();
        this._precedenceStack = new IntegerStack_1.IntegerStack();
        this._buildParseTrees = true;
        this._parseListeners = [];
        this._syntaxErrors = 0;
        this.matchedEOF = false;
        this._precedenceStack.push(0);
        this.inputStream = input;
      }
      reset(resetInput) {
        if (resetInput === void 0 || resetInput) {
          this.inputStream.seek(0);
        }
        this._errHandler.reset(this);
        this._ctx = void 0;
        this._syntaxErrors = 0;
        this.matchedEOF = false;
        this.isTrace = false;
        this._precedenceStack.clear();
        this._precedenceStack.push(0);
        let interpreter = this.interpreter;
        if (interpreter != null) {
          interpreter.reset();
        }
      }
      match(ttype) {
        let t = this.currentToken;
        if (t.type === ttype) {
          if (ttype === Token_1.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        } else {
          t = this._errHandler.recoverInline(this);
          if (this._buildParseTrees && t.tokenIndex === -1) {
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
          }
        }
        return t;
      }
      matchWildcard() {
        let t = this.currentToken;
        if (t.type > 0) {
          this._errHandler.reportMatch(this);
          this.consume();
        } else {
          t = this._errHandler.recoverInline(this);
          if (this._buildParseTrees && t.tokenIndex === -1) {
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
          }
        }
        return t;
      }
      set buildParseTree(buildParseTrees) {
        this._buildParseTrees = buildParseTrees;
      }
      get buildParseTree() {
        return this._buildParseTrees;
      }
      getParseListeners() {
        return this._parseListeners;
      }
      addParseListener(listener) {
        if (listener == null) {
          throw new TypeError("listener cannot be null");
        }
        this._parseListeners.push(listener);
      }
      removeParseListener(listener) {
        let index2 = this._parseListeners.findIndex((l) => l === listener);
        if (index2 !== -1) {
          this._parseListeners.splice(index2, 1);
        }
      }
      removeParseListeners() {
        this._parseListeners.length = 0;
      }
      triggerEnterRuleEvent() {
        for (let listener of this._parseListeners) {
          if (listener.enterEveryRule) {
            listener.enterEveryRule(this._ctx);
          }
          this._ctx.enterRule(listener);
        }
      }
      triggerExitRuleEvent() {
        for (let i = this._parseListeners.length - 1; i >= 0; i--) {
          let listener = this._parseListeners[i];
          this._ctx.exitRule(listener);
          if (listener.exitEveryRule) {
            listener.exitEveryRule(this._ctx);
          }
        }
      }
      get numberOfSyntaxErrors() {
        return this._syntaxErrors;
      }
      get tokenFactory() {
        return this._input.tokenSource.tokenFactory;
      }
      getATNWithBypassAlts() {
        let serializedAtn = this.serializedATN;
        if (serializedAtn == null) {
          throw new Error("The current parser does not support an ATN with bypass alternatives.");
        }
        let result = Parser2.bypassAltsAtnCache.get(serializedAtn);
        if (result == null) {
          let deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();
          deserializationOptions.isGenerateRuleBypassTransitions = true;
          result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils3.toCharArray(serializedAtn));
          Parser2.bypassAltsAtnCache.set(serializedAtn, result);
        }
        return result;
      }
      compileParseTreePattern(pattern, patternRuleIndex, lexer) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!lexer) {
            if (this.inputStream) {
              let tokenSource = this.inputStream.tokenSource;
              if (tokenSource instanceof Lexer_1.Lexer) {
                lexer = tokenSource;
              }
            }
            if (!lexer) {
              throw new Error("Parser can't discover a lexer to use");
            }
          }
          let currentLexer = lexer;
          let m = yield Promise.resolve().then(() => require_ParseTreePatternMatcher());
          let matcher = new m.ParseTreePatternMatcher(currentLexer, this);
          return matcher.compile(pattern, patternRuleIndex);
        });
      }
      get errorHandler() {
        return this._errHandler;
      }
      set errorHandler(handler) {
        this._errHandler = handler;
      }
      get inputStream() {
        return this._input;
      }
      set inputStream(input) {
        this.reset(false);
        this._input = input;
      }
      get currentToken() {
        return this._input.LT(1);
      }
      notifyErrorListeners(msg, offendingToken, e) {
        if (offendingToken === void 0) {
          offendingToken = this.currentToken;
        } else if (offendingToken === null) {
          offendingToken = void 0;
        }
        this._syntaxErrors++;
        let line = -1;
        let charPositionInLine = -1;
        if (offendingToken != null) {
          line = offendingToken.line;
          charPositionInLine = offendingToken.charPositionInLine;
        }
        let listener = this.getErrorListenerDispatch();
        if (listener.syntaxError) {
          listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
        }
      }
      consume() {
        let o = this.currentToken;
        if (o.type !== Parser2.EOF) {
          this.inputStream.consume();
        }
        let hasListener = this._parseListeners.length !== 0;
        if (this._buildParseTrees || hasListener) {
          if (this._errHandler.inErrorRecoveryMode(this)) {
            let node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));
            if (hasListener) {
              for (let listener of this._parseListeners) {
                if (listener.visitErrorNode) {
                  listener.visitErrorNode(node);
                }
              }
            }
          } else {
            let node = this.createTerminalNode(this._ctx, o);
            this._ctx.addChild(node);
            if (hasListener) {
              for (let listener of this._parseListeners) {
                if (listener.visitTerminal) {
                  listener.visitTerminal(node);
                }
              }
            }
          }
        }
        return o;
      }
      createTerminalNode(parent, t) {
        return new TerminalNode_1.TerminalNode(t);
      }
      createErrorNode(parent, t) {
        return new ErrorNode_1.ErrorNode(t);
      }
      addContextToParseTree() {
        let parent = this._ctx._parent;
        if (parent != null) {
          parent.addChild(this._ctx);
        }
      }
      enterRule(localctx, state, ruleIndex) {
        this.state = state;
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        if (this._buildParseTrees) {
          this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
      }
      enterLeftFactoredRule(localctx, state, ruleIndex) {
        this.state = state;
        if (this._buildParseTrees) {
          let factoredContext = this._ctx.getChild(this._ctx.childCount - 1);
          this._ctx.removeLastChild();
          factoredContext._parent = localctx;
          localctx.addChild(factoredContext);
        }
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        if (this._buildParseTrees) {
          this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
      }
      exitRule() {
        if (this.matchedEOF) {
          this._ctx._stop = this._input.LT(1);
        } else {
          this._ctx._stop = this._input.tryLT(-1);
        }
        this.triggerExitRuleEvent();
        this.state = this._ctx.invokingState;
        this._ctx = this._ctx._parent;
      }
      enterOuterAlt(localctx, altNum) {
        localctx.altNumber = altNum;
        if (this._buildParseTrees && this._ctx !== localctx) {
          let parent = this._ctx._parent;
          if (parent != null) {
            parent.removeLastChild();
            parent.addChild(localctx);
          }
        }
        this._ctx = localctx;
      }
      get precedence() {
        if (this._precedenceStack.isEmpty) {
          return -1;
        }
        return this._precedenceStack.peek();
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this.state = state;
        this._precedenceStack.push(precedence);
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        this.triggerEnterRuleEvent();
      }
      pushNewRecursionContext(localctx, state, ruleIndex) {
        let previous4 = this._ctx;
        previous4._parent = localctx;
        previous4.invokingState = state;
        previous4._stop = this._input.tryLT(-1);
        this._ctx = localctx;
        this._ctx._start = previous4._start;
        if (this._buildParseTrees) {
          this._ctx.addChild(previous4);
        }
        this.triggerEnterRuleEvent();
      }
      unrollRecursionContexts(_parentctx) {
        this._precedenceStack.pop();
        this._ctx._stop = this._input.tryLT(-1);
        let retctx = this._ctx;
        if (this._parseListeners.length > 0) {
          while (this._ctx !== _parentctx) {
            this.triggerExitRuleEvent();
            this._ctx = this._ctx._parent;
          }
        } else {
          this._ctx = _parentctx;
        }
        retctx._parent = _parentctx;
        if (this._buildParseTrees && _parentctx != null) {
          _parentctx.addChild(retctx);
        }
      }
      getInvokingContext(ruleIndex) {
        let p = this._ctx;
        while (p && p.ruleIndex !== ruleIndex) {
          p = p._parent;
        }
        return p;
      }
      get context() {
        return this._ctx;
      }
      set context(ctx) {
        this._ctx = ctx;
      }
      precpred(localctx, precedence) {
        return precedence >= this._precedenceStack.peek();
      }
      getErrorListenerDispatch() {
        return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());
      }
      inContext(context) {
        return false;
      }
      isExpectedToken(symbol) {
        let atn = this.interpreter.atn;
        let ctx = this._ctx;
        let s = atn.states[this.state];
        let following = atn.nextTokens(s);
        if (following.contains(symbol)) {
          return true;
        }
        if (!following.contains(Token_1.Token.EPSILON)) {
          return false;
        }
        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
          let invokingState = atn.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          following = atn.nextTokens(rt.followState);
          if (following.contains(symbol)) {
            return true;
          }
          ctx = ctx._parent;
        }
        if (following.contains(Token_1.Token.EPSILON) && symbol === Token_1.Token.EOF) {
          return true;
        }
        return false;
      }
      get isMatchedEOF() {
        return this.matchedEOF;
      }
      getExpectedTokens() {
        return this.atn.getExpectedTokens(this.state, this.context);
      }
      getExpectedTokensWithinCurrentRule() {
        let atn = this.interpreter.atn;
        let s = atn.states[this.state];
        return atn.nextTokens(s);
      }
      getRuleIndex(ruleName) {
        let ruleIndex = this.getRuleIndexMap().get(ruleName);
        if (ruleIndex != null) {
          return ruleIndex;
        }
        return -1;
      }
      get ruleContext() {
        return this._ctx;
      }
      getRuleInvocationStack(ctx = this._ctx) {
        let p = ctx;
        let ruleNames = this.ruleNames;
        let stack = [];
        while (p != null) {
          let ruleIndex = p.ruleIndex;
          if (ruleIndex < 0) {
            stack.push("n/a");
          } else {
            stack.push(ruleNames[ruleIndex]);
          }
          p = p._parent;
        }
        return stack;
      }
      getDFAStrings() {
        let s = [];
        for (let dfa of this._interp.atn.decisionToDFA) {
          s.push(dfa.toString(this.vocabulary, this.ruleNames));
        }
        return s;
      }
      dumpDFA() {
        let seenOne = false;
        for (let dfa of this._interp.atn.decisionToDFA) {
          if (!dfa.isEmpty) {
            if (seenOne) {
              console.log();
            }
            console.log("Decision " + dfa.decision + ":");
            process.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));
            seenOne = true;
          }
        }
      }
      get sourceName() {
        return this._input.sourceName;
      }
      get parseInfo() {
        return Promise.resolve().then(() => require_ProfilingATNSimulator()).then((m) => {
          let interp = this.interpreter;
          if (interp instanceof m.ProfilingATNSimulator) {
            return new ParseInfo_1.ParseInfo(interp);
          }
          return void 0;
        });
      }
      setProfile(profile) {
        return __awaiter(this, void 0, void 0, function* () {
          let m = yield Promise.resolve().then(() => require_ProfilingATNSimulator());
          let interp = this.interpreter;
          if (profile) {
            if (!(interp instanceof m.ProfilingATNSimulator)) {
              this.interpreter = new m.ProfilingATNSimulator(this);
            }
          } else if (interp instanceof m.ProfilingATNSimulator) {
            this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);
          }
          this.interpreter.setPredictionMode(interp.getPredictionMode());
        });
      }
      set isTrace(trace) {
        if (!trace) {
          if (this._tracer) {
            this.removeParseListener(this._tracer);
            this._tracer = void 0;
          }
        } else {
          if (this._tracer) {
            this.removeParseListener(this._tracer);
          } else {
            this._tracer = new TraceListener(this.ruleNames, this._input);
          }
          this.addParseListener(this._tracer);
        }
      }
      get isTrace() {
        return this._tracer != null;
      }
    };
    Parser2.bypassAltsAtnCache = /* @__PURE__ */ new Map();
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "_errHandler", void 0);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "match", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "matchWildcard", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getParseListeners", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Parser2.prototype, "addParseListener", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getATNWithBypassAlts", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Parser2.prototype, "errorHandler", null);
    __decorate([
      Decorators_1.Override
    ], Parser2.prototype, "inputStream", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "currentToken", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Parser2.prototype, "enterRule", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.Nullable)
    ], Parser2.prototype, "precpred", null);
    __decorate([
      Decorators_1.Override
    ], Parser2.prototype, "getErrorListenerDispatch", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getExpectedTokens", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getExpectedTokensWithinCurrentRule", null);
    __decorate([
      Decorators_1.Override
    ], Parser2.prototype, "parseInfo", null);
    exports.Parser = Parser2;
  }
});

// node_modules/antlr4ts/NoViableAltException.js
var require_NoViableAltException = __commonJS({
  "node_modules/antlr4ts/NoViableAltException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoViableAltException = void 0;
    var Parser_1 = require_Parser();
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var NoViableAltException2 = class extends RecognitionException_1.RecognitionException {
      constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
        if (recognizer instanceof Parser_1.Parser) {
          if (input === void 0) {
            input = recognizer.inputStream;
          }
          if (startToken === void 0) {
            startToken = recognizer.currentToken;
          }
          if (offendingToken === void 0) {
            offendingToken = recognizer.currentToken;
          }
          if (ctx === void 0) {
            ctx = recognizer.context;
          }
        }
        super(recognizer, input, ctx);
        this._deadEndConfigs = deadEndConfigs;
        this._startToken = startToken;
        this.setOffendingToken(recognizer, offendingToken);
      }
      get startToken() {
        return this._startToken;
      }
      get deadEndConfigs() {
        return this._deadEndConfigs;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], NoViableAltException2.prototype, "_startToken", void 0);
    exports.NoViableAltException = NoViableAltException2;
  }
});

// node_modules/antlr4ts/DefaultErrorStrategy.js
var require_DefaultErrorStrategy = __commonJS({
  "node_modules/antlr4ts/DefaultErrorStrategy.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultErrorStrategy = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var FailedPredicateException_1 = require_FailedPredicateException();
    var InputMismatchException_1 = require_InputMismatchException();
    var IntervalSet_1 = require_IntervalSet();
    var NoViableAltException_1 = require_NoViableAltException();
    var PredictionContext_1 = require_PredictionContext();
    var Token_1 = require_Token();
    var Decorators_1 = require_Decorators();
    var DefaultErrorStrategy = class {
      constructor() {
        this.errorRecoveryMode = false;
        this.lastErrorIndex = -1;
        this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
      }
      reset(recognizer) {
        this.endErrorCondition(recognizer);
      }
      beginErrorCondition(recognizer) {
        this.errorRecoveryMode = true;
      }
      inErrorRecoveryMode(recognizer) {
        return this.errorRecoveryMode;
      }
      endErrorCondition(recognizer) {
        this.errorRecoveryMode = false;
        this.lastErrorStates = void 0;
        this.lastErrorIndex = -1;
      }
      reportMatch(recognizer) {
        this.endErrorCondition(recognizer);
      }
      reportError(recognizer, e) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        if (e instanceof NoViableAltException_1.NoViableAltException) {
          this.reportNoViableAlternative(recognizer, e);
        } else if (e instanceof InputMismatchException_1.InputMismatchException) {
          this.reportInputMismatch(recognizer, e);
        } else if (e instanceof FailedPredicateException_1.FailedPredicateException) {
          this.reportFailedPredicate(recognizer, e);
        } else {
          console.error(`unknown recognition error type: ${e}`);
          this.notifyErrorListeners(recognizer, e.toString(), e);
        }
      }
      notifyErrorListeners(recognizer, message, e) {
        let offendingToken = e.getOffendingToken(recognizer);
        if (offendingToken === void 0) {
          offendingToken = null;
        }
        recognizer.notifyErrorListeners(message, offendingToken, e);
      }
      recover(recognizer, e) {
        if (this.lastErrorIndex === recognizer.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(recognizer.state)) {
          recognizer.consume();
        }
        this.lastErrorIndex = recognizer.inputStream.index;
        if (!this.lastErrorStates) {
          this.lastErrorStates = new IntervalSet_1.IntervalSet();
        }
        this.lastErrorStates.add(recognizer.state);
        let followSet = this.getErrorRecoverySet(recognizer);
        this.consumeUntil(recognizer, followSet);
      }
      sync(recognizer) {
        let s = recognizer.interpreter.atn.states[recognizer.state];
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        let tokens = recognizer.inputStream;
        let la = tokens.LA(1);
        let nextTokens = recognizer.atn.nextTokens(s);
        if (nextTokens.contains(la)) {
          this.nextTokensContext = void 0;
          this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
          return;
        }
        if (nextTokens.contains(Token_1.Token.EPSILON)) {
          if (this.nextTokensContext === void 0) {
            this.nextTokensContext = recognizer.context;
            this.nextTokensState = recognizer.state;
          }
          return;
        }
        switch (s.stateType) {
          case ATNStateType_1.ATNStateType.BLOCK_START:
          case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
          case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
          case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
            if (this.singleTokenDeletion(recognizer)) {
              return;
            }
            throw new InputMismatchException_1.InputMismatchException(recognizer);
          case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
          case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
            this.reportUnwantedToken(recognizer);
            let expecting = recognizer.getExpectedTokens();
            let whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));
            this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
            break;
          default:
            break;
        }
      }
      reportNoViableAlternative(recognizer, e) {
        let tokens = recognizer.inputStream;
        let input;
        if (tokens) {
          if (e.startToken.type === Token_1.Token.EOF) {
            input = "<EOF>";
          } else {
            input = tokens.getTextFromRange(e.startToken, e.getOffendingToken());
          }
        } else {
          input = "<unknown input>";
        }
        let msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
        this.notifyErrorListeners(recognizer, msg, e);
      }
      reportInputMismatch(recognizer, e) {
        let expected = e.expectedTokens;
        let expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : "";
        let msg = "mismatched input " + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) + " expecting " + expectedString;
        this.notifyErrorListeners(recognizer, msg, e);
      }
      reportFailedPredicate(recognizer, e) {
        let ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
        let msg = "rule " + ruleName + " " + e.message;
        this.notifyErrorListeners(recognizer, msg, e);
      }
      reportUnwantedToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        let t = recognizer.currentToken;
        let tokenName = this.getTokenErrorDisplay(t);
        let expecting = this.getExpectedTokens(recognizer);
        let msg = "extraneous input " + tokenName + " expecting " + expecting.toStringVocabulary(recognizer.vocabulary);
        recognizer.notifyErrorListeners(msg, t, void 0);
      }
      reportMissingToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        let t = recognizer.currentToken;
        let expecting = this.getExpectedTokens(recognizer);
        let msg = "missing " + expecting.toStringVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
        recognizer.notifyErrorListeners(msg, t, void 0);
      }
      recoverInline(recognizer) {
        let matchedSymbol = this.singleTokenDeletion(recognizer);
        if (matchedSymbol) {
          recognizer.consume();
          return matchedSymbol;
        }
        if (this.singleTokenInsertion(recognizer)) {
          return this.getMissingSymbol(recognizer);
        }
        if (this.nextTokensContext === void 0) {
          throw new InputMismatchException_1.InputMismatchException(recognizer);
        } else {
          throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);
        }
      }
      singleTokenInsertion(recognizer) {
        let currentSymbolType = recognizer.inputStream.LA(1);
        let currentState = recognizer.interpreter.atn.states[recognizer.state];
        let next = currentState.transition(0).target;
        let atn = recognizer.interpreter.atn;
        let expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));
        if (expectingAtLL2.contains(currentSymbolType)) {
          this.reportMissingToken(recognizer);
          return true;
        }
        return false;
      }
      singleTokenDeletion(recognizer) {
        let nextTokenType = recognizer.inputStream.LA(2);
        let expecting = this.getExpectedTokens(recognizer);
        if (expecting.contains(nextTokenType)) {
          this.reportUnwantedToken(recognizer);
          recognizer.consume();
          let matchedSymbol = recognizer.currentToken;
          this.reportMatch(recognizer);
          return matchedSymbol;
        }
        return void 0;
      }
      getMissingSymbol(recognizer) {
        let currentSymbol = recognizer.currentToken;
        let expecting = this.getExpectedTokens(recognizer);
        let expectedTokenType = Token_1.Token.INVALID_TYPE;
        if (!expecting.isNil) {
          expectedTokenType = expecting.minElement;
        }
        let tokenText;
        if (expectedTokenType === Token_1.Token.EOF) {
          tokenText = "<missing EOF>";
        } else {
          tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
        }
        let current = currentSymbol;
        let lookback = recognizer.inputStream.tryLT(-1);
        if (current.type === Token_1.Token.EOF && lookback != null) {
          current = lookback;
        }
        return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);
      }
      constructToken(tokenSource, expectedTokenType, tokenText, current) {
        let factory = tokenSource.tokenFactory;
        let x = current.tokenSource;
        let stream = x ? x.inputStream : void 0;
        return factory.create({ source: tokenSource, stream }, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);
      }
      getExpectedTokens(recognizer) {
        return recognizer.getExpectedTokens();
      }
      getTokenErrorDisplay(t) {
        if (!t) {
          return "<no token>";
        }
        let s = this.getSymbolText(t);
        if (!s) {
          if (this.getSymbolType(t) === Token_1.Token.EOF) {
            s = "<EOF>";
          } else {
            s = `<${this.getSymbolType(t)}>`;
          }
        }
        return this.escapeWSAndQuote(s);
      }
      getSymbolText(symbol) {
        return symbol.text;
      }
      getSymbolType(symbol) {
        return symbol.type;
      }
      escapeWSAndQuote(s) {
        s = s.replace("\n", "\\n");
        s = s.replace("\r", "\\r");
        s = s.replace("	", "\\t");
        return "'" + s + "'";
      }
      getErrorRecoverySet(recognizer) {
        let atn = recognizer.interpreter.atn;
        let ctx = recognizer.context;
        let recoverSet = new IntervalSet_1.IntervalSet();
        while (ctx && ctx.invokingState >= 0) {
          let invokingState = atn.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          let follow = atn.nextTokens(rt.followState);
          recoverSet.addAll(follow);
          ctx = ctx._parent;
        }
        recoverSet.remove(Token_1.Token.EPSILON);
        return recoverSet;
      }
      consumeUntil(recognizer, set) {
        let ttype = recognizer.inputStream.LA(1);
        while (ttype !== Token_1.Token.EOF && !set.contains(ttype)) {
          recognizer.consume();
          ttype = recognizer.inputStream.LA(1);
        }
      }
    };
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "beginErrorCondition", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "inErrorRecoveryMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "endErrorCondition", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reportMatch", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reportError", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "notifyErrorListeners", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "recover", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "sync", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportNoViableAlternative", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportInputMismatch", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportFailedPredicate", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportUnwantedToken", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportMissingToken", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "recoverInline", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "singleTokenInsertion", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "singleTokenDeletion", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getMissingSymbol", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getExpectedTokens", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getSymbolText", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getSymbolType", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "escapeWSAndQuote", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getErrorRecoverySet", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "consumeUntil", null);
    exports.DefaultErrorStrategy = DefaultErrorStrategy;
  }
});

// node_modules/antlr4ts/BailErrorStrategy.js
var require_BailErrorStrategy = __commonJS({
  "node_modules/antlr4ts/BailErrorStrategy.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BailErrorStrategy = void 0;
    var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
    var InputMismatchException_1 = require_InputMismatchException();
    var Decorators_1 = require_Decorators();
    var ParseCancellationException_1 = require_ParseCancellationException();
    var BailErrorStrategy = class extends DefaultErrorStrategy_1.DefaultErrorStrategy {
      recover(recognizer, e) {
        for (let context = recognizer.context; context; context = context.parent) {
          context.exception = e;
        }
        throw new ParseCancellationException_1.ParseCancellationException(e);
      }
      recoverInline(recognizer) {
        let e = new InputMismatchException_1.InputMismatchException(recognizer);
        for (let context = recognizer.context; context; context = context.parent) {
          context.exception = e;
        }
        throw new ParseCancellationException_1.ParseCancellationException(e);
      }
      sync(recognizer) {
      }
    };
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "recover", null);
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "recoverInline", null);
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "sync", null);
    exports.BailErrorStrategy = BailErrorStrategy;
  }
});

// node_modules/antlr4ts/CharStream.js
var require_CharStream = __commonJS({
  "node_modules/antlr4ts/CharStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/Dependents.js
var require_Dependents = __commonJS({
  "node_modules/antlr4ts/Dependents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dependents = void 0;
    var Dependents;
    (function(Dependents2) {
      Dependents2[Dependents2["SELF"] = 0] = "SELF";
      Dependents2[Dependents2["PARENTS"] = 1] = "PARENTS";
      Dependents2[Dependents2["CHILDREN"] = 2] = "CHILDREN";
      Dependents2[Dependents2["ANCESTORS"] = 3] = "ANCESTORS";
      Dependents2[Dependents2["DESCENDANTS"] = 4] = "DESCENDANTS";
      Dependents2[Dependents2["SIBLINGS"] = 5] = "SIBLINGS";
      Dependents2[Dependents2["PRECEEDING_SIBLINGS"] = 6] = "PRECEEDING_SIBLINGS";
      Dependents2[Dependents2["FOLLOWING_SIBLINGS"] = 7] = "FOLLOWING_SIBLINGS";
      Dependents2[Dependents2["PRECEEDING"] = 8] = "PRECEEDING";
      Dependents2[Dependents2["FOLLOWING"] = 9] = "FOLLOWING";
    })(Dependents = exports.Dependents || (exports.Dependents = {}));
  }
});

// node_modules/antlr4ts/DiagnosticErrorListener.js
var require_DiagnosticErrorListener = __commonJS({
  "node_modules/antlr4ts/DiagnosticErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticErrorListener = void 0;
    var BitSet_1 = require_BitSet();
    var Decorators_1 = require_Decorators();
    var Interval_1 = require_Interval();
    var DiagnosticErrorListener = class {
      constructor(exactOnly = true) {
        this.exactOnly = exactOnly;
        this.exactOnly = exactOnly;
      }
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      }
      reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (this.exactOnly && !exact) {
          return;
        }
        let decision = this.getDecisionDescription(recognizer, dfa);
        let conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
        let text4 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text4}'`;
        recognizer.notifyErrorListeners(message);
      }
      reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
        let format = "reportAttemptingFullContext d=%s, input='%s'";
        let decision = this.getDecisionDescription(recognizer, dfa);
        let text4 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportAttemptingFullContext d=${decision}, input='${text4}'`;
        recognizer.notifyErrorListeners(message);
      }
      reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
        let format = "reportContextSensitivity d=%s, input='%s'";
        let decision = this.getDecisionDescription(recognizer, dfa);
        let text4 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportContextSensitivity d=${decision}, input='${text4}'`;
        recognizer.notifyErrorListeners(message);
      }
      getDecisionDescription(recognizer, dfa) {
        let decision = dfa.decision;
        let ruleIndex = dfa.atnStartState.ruleIndex;
        let ruleNames = recognizer.ruleNames;
        if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
          return decision.toString();
        }
        let ruleName = ruleNames[ruleIndex];
        if (!ruleName) {
          return decision.toString();
        }
        return `${decision} (${ruleName})`;
      }
      getConflictingAlts(reportedAlts, configs) {
        if (reportedAlts != null) {
          return reportedAlts;
        }
        let result = new BitSet_1.BitSet();
        for (let config of configs) {
          result.set(config.alt);
        }
        return result;
      }
    };
    __decorate([
      Decorators_1.Override
    ], DiagnosticErrorListener.prototype, "syntaxError", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportAmbiguity", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportContextSensitivity", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "getDecisionDescription", null);
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "getConflictingAlts", null);
    exports.DiagnosticErrorListener = DiagnosticErrorListener;
  }
});

// node_modules/antlr4ts/LexerInterpreter.js
var require_LexerInterpreter = __commonJS({
  "node_modules/antlr4ts/LexerInterpreter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerInterpreter = void 0;
    var Lexer_1 = require_Lexer();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var Decorators_1 = require_Decorators();
    var Decorators_2 = require_Decorators();
    var LexerInterpreter = class LexerInterpreter extends Lexer_1.Lexer {
      constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
        super(input);
        if (atn.grammarType !== 0) {
          throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
        }
        this._grammarFileName = grammarFileName;
        this._atn = atn;
        this._ruleNames = ruleNames.slice(0);
        this._channelNames = channelNames.slice(0);
        this._modeNames = modeNames.slice(0);
        this._vocabulary = vocabulary;
        this._interp = new LexerATNSimulator_1.LexerATNSimulator(atn, this);
      }
      get atn() {
        return this._atn;
      }
      get grammarFileName() {
        return this._grammarFileName;
      }
      get ruleNames() {
        return this._ruleNames;
      }
      get channelNames() {
        return this._channelNames;
      }
      get modeNames() {
        return this._modeNames;
      }
      get vocabulary() {
        return this._vocabulary;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerInterpreter.prototype, "_vocabulary", void 0);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "atn", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "grammarFileName", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "ruleNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "channelNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "modeNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "vocabulary", null);
    LexerInterpreter = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerInterpreter);
    exports.LexerInterpreter = LexerInterpreter;
  }
});

// node_modules/antlr4ts/ParserErrorListener.js
var require_ParserErrorListener = __commonJS({
  "node_modules/antlr4ts/ParserErrorListener.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/RuleContextWithAltNum.js
var require_RuleContextWithAltNum = __commonJS({
  "node_modules/antlr4ts/RuleContextWithAltNum.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleContextWithAltNum = void 0;
    var ATN_1 = require_ATN();
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleContextWithAltNum = class extends ParserRuleContext_1.ParserRuleContext {
      constructor(parent, invokingStateNumber) {
        if (invokingStateNumber !== void 0) {
          super(parent, invokingStateNumber);
        } else {
          super();
        }
        this._altNumber = ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      get altNumber() {
        return this._altNumber;
      }
      set altNumber(altNum) {
        this._altNumber = altNum;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleContextWithAltNum.prototype, "altNumber", null);
    exports.RuleContextWithAltNum = RuleContextWithAltNum;
  }
});

// node_modules/antlr4ts/RuleDependency.js
var require_RuleDependency = __commonJS({
  "node_modules/antlr4ts/RuleDependency.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleDependency = void 0;
    function RuleDependency(dependency) {
      return (target, propertyKey, propertyDescriptor) => {
      };
    }
    exports.RuleDependency = RuleDependency;
  }
});

// node_modules/antlr4ts/RuleVersion.js
var require_RuleVersion = __commonJS({
  "node_modules/antlr4ts/RuleVersion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleVersion = void 0;
    function RuleVersion(version) {
      return (target, propertyKey, propertyDescriptor) => {
      };
    }
    exports.RuleVersion = RuleVersion;
  }
});

// node_modules/antlr4ts/TokenFactory.js
var require_TokenFactory = __commonJS({
  "node_modules/antlr4ts/TokenFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenSource.js
var require_TokenSource = __commonJS({
  "node_modules/antlr4ts/TokenSource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenStream.js
var require_TokenStream = __commonJS({
  "node_modules/antlr4ts/TokenStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenStreamRewriter.js
var require_TokenStreamRewriter = __commonJS({
  "node_modules/antlr4ts/TokenStreamRewriter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RewriteOperation = exports.TokenStreamRewriter = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var TokenStreamRewriter = class {
      constructor(tokens) {
        this.tokens = tokens;
        this.programs = /* @__PURE__ */ new Map();
        this.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);
        this.lastRewriteTokenIndexes = /* @__PURE__ */ new Map();
      }
      getTokenStream() {
        return this.tokens;
      }
      rollback(instructionIndex, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let is = this.programs.get(programName);
        if (is != null) {
          this.programs.set(programName, is.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));
        }
      }
      deleteProgram(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        this.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, programName);
      }
      insertAfter(tokenOrIndex, text4, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let index2;
        if (typeof tokenOrIndex === "number") {
          index2 = tokenOrIndex;
        } else {
          index2 = tokenOrIndex.tokenIndex;
        }
        let rewrites = this.getProgram(programName);
        let op = new InsertAfterOp(this.tokens, index2, rewrites.length, text4);
        rewrites.push(op);
      }
      insertBefore(tokenOrIndex, text4, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let index2;
        if (typeof tokenOrIndex === "number") {
          index2 = tokenOrIndex;
        } else {
          index2 = tokenOrIndex.tokenIndex;
        }
        let rewrites = this.getProgram(programName);
        let op = new InsertBeforeOp(this.tokens, index2, rewrites.length, text4);
        rewrites.push(op);
      }
      replaceSingle(index2, text4) {
        if (typeof index2 === "number") {
          this.replace(index2, index2, text4);
        } else {
          this.replace(index2, index2, text4);
        }
      }
      replace(from, to, text4, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        if (typeof from !== "number") {
          from = from.tokenIndex;
        }
        if (typeof to !== "number") {
          to = to.tokenIndex;
        }
        if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
          throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);
        }
        let rewrites = this.getProgram(programName);
        let op = new ReplaceOp(this.tokens, from, to, rewrites.length, text4);
        rewrites.push(op);
      }
      delete(from, to, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        if (to === void 0) {
          to = from;
        }
        if (typeof from === "number") {
          this.replace(from, to, "", programName);
        } else {
          this.replace(from, to, "", programName);
        }
      }
      getLastRewriteTokenIndex(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let I = this.lastRewriteTokenIndexes.get(programName);
        if (I == null) {
          return -1;
        }
        return I;
      }
      setLastRewriteTokenIndex(programName, i) {
        this.lastRewriteTokenIndexes.set(programName, i);
      }
      getProgram(name) {
        let is = this.programs.get(name);
        if (is == null) {
          is = this.initializeProgram(name);
        }
        return is;
      }
      initializeProgram(name) {
        let is = [];
        this.programs.set(name, is);
        return is;
      }
      getText(intervalOrProgram, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let interval;
        if (intervalOrProgram instanceof Interval_1.Interval) {
          interval = intervalOrProgram;
        } else {
          interval = Interval_1.Interval.of(0, this.tokens.size - 1);
        }
        if (typeof intervalOrProgram === "string") {
          programName = intervalOrProgram;
        }
        let rewrites = this.programs.get(programName);
        let start = interval.a;
        let stop = interval.b;
        if (stop > this.tokens.size - 1) {
          stop = this.tokens.size - 1;
        }
        if (start < 0) {
          start = 0;
        }
        if (rewrites == null || rewrites.length === 0) {
          return this.tokens.getText(interval);
        }
        let buf = [];
        let indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
        let i = start;
        while (i <= stop && i < this.tokens.size) {
          let op = indexToOp.get(i);
          indexToOp.delete(i);
          let t = this.tokens.get(i);
          if (op == null) {
            if (t.type !== Token_1.Token.EOF) {
              buf.push(String(t.text));
            }
            i++;
          } else {
            i = op.execute(buf);
          }
        }
        if (stop === this.tokens.size - 1) {
          for (let op of indexToOp.values()) {
            if (op.index >= this.tokens.size - 1) {
              buf.push(op.text.toString());
            }
          }
        }
        return buf.join("");
      }
      reduceToSingleOperationPerIndex(rewrites) {
        for (let i = 0; i < rewrites.length; i++) {
          let op = rewrites[i];
          if (op == null) {
            continue;
          }
          if (!(op instanceof ReplaceOp)) {
            continue;
          }
          let rop = op;
          let inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
          for (let iop of inserts) {
            if (iop.index === rop.index) {
              rewrites[iop.instructionIndex] = void 0;
              rop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : "");
            } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
              rewrites[iop.instructionIndex] = void 0;
            }
          }
          let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
          for (let prevRop of prevReplaces) {
            if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
              rewrites[prevRop.instructionIndex] = void 0;
              continue;
            }
            let disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
            if (prevRop.text == null && rop.text == null && !disjoint) {
              rewrites[prevRop.instructionIndex] = void 0;
              rop.index = Math.min(prevRop.index, rop.index);
              rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
            } else if (!disjoint) {
              throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);
            }
          }
        }
        for (let i = 0; i < rewrites.length; i++) {
          let op = rewrites[i];
          if (op == null) {
            continue;
          }
          if (!(op instanceof InsertBeforeOp)) {
            continue;
          }
          let iop = op;
          let prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
          for (let prevIop of prevInserts) {
            if (prevIop.index === iop.index) {
              if (prevIop instanceof InsertAfterOp) {
                iop.text = this.catOpText(prevIop.text, iop.text);
                rewrites[prevIop.instructionIndex] = void 0;
              } else if (prevIop instanceof InsertBeforeOp) {
                iop.text = this.catOpText(iop.text, prevIop.text);
                rewrites[prevIop.instructionIndex] = void 0;
              }
            }
          }
          let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
          for (let rop of prevReplaces) {
            if (iop.index === rop.index) {
              rop.text = this.catOpText(iop.text, rop.text);
              rewrites[i] = void 0;
              continue;
            }
            if (iop.index >= rop.index && iop.index <= rop.lastIndex) {
              throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);
            }
          }
        }
        let m = /* @__PURE__ */ new Map();
        for (let op of rewrites) {
          if (op == null) {
            continue;
          }
          if (m.get(op.index) != null) {
            throw new Error("should only be one op per index");
          }
          m.set(op.index, op);
        }
        return m;
      }
      catOpText(a, b) {
        let x = "";
        let y = "";
        if (a != null) {
          x = a.toString();
        }
        if (b != null) {
          y = b.toString();
        }
        return x + y;
      }
      getKindOfOps(rewrites, kind, before) {
        let ops = [];
        for (let i = 0; i < before && i < rewrites.length; i++) {
          let op = rewrites[i];
          if (op == null) {
            continue;
          }
          if (op instanceof kind) {
            ops.push(op);
          }
        }
        return ops;
      }
    };
    exports.TokenStreamRewriter = TokenStreamRewriter;
    TokenStreamRewriter.DEFAULT_PROGRAM_NAME = "default";
    TokenStreamRewriter.PROGRAM_INIT_SIZE = 100;
    TokenStreamRewriter.MIN_TOKEN_INDEX = 0;
    var RewriteOperation = class {
      constructor(tokens, index2, instructionIndex, text4) {
        this.tokens = tokens;
        this.instructionIndex = instructionIndex;
        this.index = index2;
        this.text = text4 === void 0 ? "" : text4;
      }
      execute(buf) {
        return this.index;
      }
      toString() {
        let opName = this.constructor.name;
        let $index = opName.indexOf("$");
        opName = opName.substring($index + 1, opName.length);
        return "<" + opName + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
      }
    };
    __decorate([
      Decorators_1.Override
    ], RewriteOperation.prototype, "toString", null);
    exports.RewriteOperation = RewriteOperation;
    var InsertBeforeOp = class extends RewriteOperation {
      constructor(tokens, index2, instructionIndex, text4) {
        super(tokens, index2, instructionIndex, text4);
      }
      execute(buf) {
        buf.push(this.text.toString());
        if (this.tokens.get(this.index).type !== Token_1.Token.EOF) {
          buf.push(String(this.tokens.get(this.index).text));
        }
        return this.index + 1;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InsertBeforeOp.prototype, "execute", null);
    var InsertAfterOp = class extends InsertBeforeOp {
      constructor(tokens, index2, instructionIndex, text4) {
        super(tokens, index2 + 1, instructionIndex, text4);
      }
    };
    var ReplaceOp = class extends RewriteOperation {
      constructor(tokens, from, to, instructionIndex, text4) {
        super(tokens, from, instructionIndex, text4);
        this.lastIndex = to;
      }
      execute(buf) {
        if (this.text != null) {
          buf.push(this.text.toString());
        }
        return this.lastIndex + 1;
      }
      toString() {
        if (this.text == null) {
          return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
        }
        return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
      }
    };
    __decorate([
      Decorators_1.Override
    ], ReplaceOp.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], ReplaceOp.prototype, "toString", null);
  }
});

// node_modules/antlr4ts/Vocabulary.js
var require_Vocabulary = __commonJS({
  "node_modules/antlr4ts/Vocabulary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/WritableToken.js
var require_WritableToken = __commonJS({
  "node_modules/antlr4ts/WritableToken.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/index.js
var require_antlr4ts = __commonJS({
  "node_modules/antlr4ts/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ANTLRErrorListener(), exports);
    __exportStar(require_ANTLRErrorStrategy(), exports);
    __exportStar(require_ANTLRInputStream(), exports);
    __exportStar(require_BailErrorStrategy(), exports);
    __exportStar(require_BufferedTokenStream(), exports);
    __exportStar(require_CharStream(), exports);
    __exportStar(require_CharStreams(), exports);
    __exportStar(require_CodePointBuffer(), exports);
    __exportStar(require_CodePointCharStream(), exports);
    __exportStar(require_CommonToken(), exports);
    __exportStar(require_CommonTokenFactory(), exports);
    __exportStar(require_CommonTokenStream(), exports);
    __exportStar(require_ConsoleErrorListener(), exports);
    __exportStar(require_DefaultErrorStrategy(), exports);
    __exportStar(require_Dependents(), exports);
    __exportStar(require_DiagnosticErrorListener(), exports);
    __exportStar(require_FailedPredicateException(), exports);
    __exportStar(require_InputMismatchException(), exports);
    __exportStar(require_InterpreterRuleContext(), exports);
    __exportStar(require_IntStream(), exports);
    __exportStar(require_Lexer(), exports);
    __exportStar(require_LexerInterpreter(), exports);
    __exportStar(require_LexerNoViableAltException(), exports);
    __exportStar(require_ListTokenSource(), exports);
    __exportStar(require_NoViableAltException(), exports);
    __exportStar(require_Parser(), exports);
    __exportStar(require_ParserErrorListener(), exports);
    __exportStar(require_ParserInterpreter(), exports);
    __exportStar(require_ParserRuleContext(), exports);
    __exportStar(require_ProxyErrorListener(), exports);
    __exportStar(require_ProxyParserErrorListener(), exports);
    __exportStar(require_RecognitionException(), exports);
    __exportStar(require_Recognizer(), exports);
    __exportStar(require_RuleContext(), exports);
    __exportStar(require_RuleContextWithAltNum(), exports);
    __exportStar(require_RuleDependency(), exports);
    __exportStar(require_RuleVersion(), exports);
    __exportStar(require_Token(), exports);
    __exportStar(require_TokenFactory(), exports);
    __exportStar(require_TokenSource(), exports);
    __exportStar(require_TokenStream(), exports);
    __exportStar(require_TokenStreamRewriter(), exports);
    __exportStar(require_Vocabulary(), exports);
    __exportStar(require_VocabularyImpl(), exports);
    __exportStar(require_WritableToken(), exports);
  }
});

// node_modules/format/format.js
var require_format = __commonJS({
  "node_modules/format/format.js"(exports, module2) {
    (function() {
      var namespace;
      if (typeof module2 !== "undefined") {
        namespace = module2.exports = format;
      } else {
        namespace = function() {
          return this || (1, eval)("this");
        }();
      }
      namespace.format = format;
      namespace.vsprintf = vsprintf;
      if (typeof console !== "undefined" && typeof console.log === "function") {
        namespace.printf = printf;
      }
      function printf() {
        console.log(format.apply(null, arguments));
      }
      function vsprintf(fmt, replacements) {
        return format.apply(null, [fmt].concat(replacements));
      }
      function format(fmt) {
        var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
          return args[argIndex++];
        }, slurpNumber = function() {
          var digits = "";
          while (/\d/.test(fmt[i])) {
            digits += fmt[i++];
            c = fmt[i];
          }
          return digits.length > 0 ? parseInt(digits) : null;
        };
        for (; i < n; ++i) {
          c = fmt[i];
          if (escaped) {
            escaped = false;
            if (c == ".") {
              leadingZero = false;
              c = fmt[++i];
            } else if (c == "0" && fmt[i + 1] == ".") {
              leadingZero = true;
              i += 2;
              c = fmt[i];
            } else {
              leadingZero = true;
            }
            precision = slurpNumber();
            switch (c) {
              case "b":
                result += parseInt(nextArg(), 10).toString(2);
                break;
              case "c":
                arg = nextArg();
                if (typeof arg === "string" || arg instanceof String)
                  result += arg;
                else
                  result += String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
                result += parseInt(nextArg(), 10);
                break;
              case "f":
                tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                result += leadingZero ? tmp : tmp.replace(/^0/, "");
                break;
              case "j":
                result += JSON.stringify(nextArg());
                break;
              case "o":
                result += "0" + parseInt(nextArg(), 10).toString(8);
                break;
              case "s":
                result += nextArg();
                break;
              case "x":
                result += "0x" + parseInt(nextArg(), 10).toString(16);
                break;
              case "X":
                result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                break;
              default:
                result += c;
                break;
            }
          } else if (c === "%") {
            escaped = true;
          } else {
            result += c;
          }
        }
        return result;
      }
    })();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StructuralEditPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/SimpleText.ts
var import_AbstractParseTreeVisitor = __toESM(require_AbstractParseTreeVisitor());
var import_antlr4ts = __toESM(require_antlr4ts());

// src/grammar/SimpleTextParser.ts
var import_ATN = __toESM(require_ATN());
var import_ATNDeserializer = __toESM(require_ATNDeserializer());
var import_FailedPredicateException = __toESM(require_FailedPredicateException());
var import_NoViableAltException = __toESM(require_NoViableAltException());
var import_Parser = __toESM(require_Parser());
var import_ParserRuleContext = __toESM(require_ParserRuleContext());
var import_ParserATNSimulator = __toESM(require_ParserATNSimulator());
var import_RecognitionException = __toESM(require_RecognitionException());
var import_Token = __toESM(require_Token());
var import_VocabularyImpl = __toESM(require_VocabularyImpl());
var Utils = __toESM(require_Utils());
var _SimpleTextParser = class extends import_Parser.Parser {
  get vocabulary() {
    return _SimpleTextParser.VOCABULARY;
  }
  get grammarFileName() {
    return "SimpleText.g4";
  }
  get ruleNames() {
    return _SimpleTextParser.ruleNames;
  }
  get serializedATN() {
    return _SimpleTextParser._serializedATN;
  }
  createFailedPredicateException(predicate, message) {
    return new import_FailedPredicateException.FailedPredicateException(this, predicate, message);
  }
  constructor(input) {
    super(input);
    this._interp = new import_ParserATNSimulator.ParserATNSimulator(_SimpleTextParser._ATN, this);
  }
  paragraph() {
    let _localctx = new ParagraphContext(this._ctx, this.state);
    this.enterRule(_localctx, 0, _SimpleTextParser.RULE_paragraph);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 17;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
          {
            {
              this.state = 14;
              this.sentence();
            }
          }
          this.state = 19;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 20;
        this.match(_SimpleTextParser.EOF);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  sentence() {
    let _localctx = new SentenceContext(this._ctx, this.state);
    this.enterRule(_localctx, 2, _SimpleTextParser.RULE_sentence);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 23;
        this._errHandler.sync(this);
        _alt = 1;
        do {
          switch (_alt) {
            case 1:
              {
                {
                  this.state = 22;
                  this.proposition();
                }
              }
              break;
            default:
              throw new import_NoViableAltException.NoViableAltException(this);
          }
          this.state = 25;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 1, this._ctx);
        } while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER);
        this.state = 28;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.DOT | 1 << _SimpleTextParser.QUESTION_MARK | 1 << _SimpleTextParser.EXCLAMATION_MARK)) !== 0) {
          {
            this.state = 27;
            this.endPunctuation();
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  proposition() {
    let _localctx = new PropositionContext(this._ctx, this.state);
    this.enterRule(_localctx, 4, _SimpleTextParser.RULE_proposition);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 32;
        this._errHandler.sync(this);
        _alt = 1;
        do {
          switch (_alt) {
            case 1:
              {
                this.state = 32;
                this._errHandler.sync(this);
                switch (this._input.LA(1)) {
                  case _SimpleTextParser.Word:
                  case _SimpleTextParser.Smiley:
                  case _SimpleTextParser.Url:
                    {
                      this.state = 30;
                      this.word();
                    }
                    break;
                  case _SimpleTextParser.LPAREN:
                  case _SimpleTextParser.LACCOL:
                  case _SimpleTextParser.LBRACK:
                  case _SimpleTextParser.QUOTE:
                  case _SimpleTextParser.DQUOTE:
                    {
                      this.state = 31;
                      this.expression();
                    }
                    break;
                  default:
                    throw new import_NoViableAltException.NoViableAltException(this);
                }
              }
              break;
            default:
              throw new import_NoViableAltException.NoViableAltException(this);
          }
          this.state = 34;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 4, this._ctx);
        } while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER);
        this.state = 37;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.COLON | 1 << _SimpleTextParser.COMMA | 1 << _SimpleTextParser.SEMICOLON)) !== 0) {
          {
            this.state = 36;
            this.midPunctuation();
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  midPunctuation() {
    let _localctx = new MidPunctuationContext(this._ctx, this.state);
    this.enterRule(_localctx, 6, _SimpleTextParser.RULE_midPunctuation);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 39;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.COLON | 1 << _SimpleTextParser.COMMA | 1 << _SimpleTextParser.SEMICOLON)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  endPunctuation() {
    let _localctx = new EndPunctuationContext(this._ctx, this.state);
    this.enterRule(_localctx, 8, _SimpleTextParser.RULE_endPunctuation);
    let _la;
    try {
      this.state = 48;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SimpleTextParser.DOT:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 42;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
              {
                {
                  this.state = 41;
                  this.match(_SimpleTextParser.DOT);
                }
              }
              this.state = 44;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            } while (_la === _SimpleTextParser.DOT);
          }
          break;
        case _SimpleTextParser.QUESTION_MARK:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 46;
            this.match(_SimpleTextParser.QUESTION_MARK);
          }
          break;
        case _SimpleTextParser.EXCLAMATION_MARK:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 47;
            this.match(_SimpleTextParser.EXCLAMATION_MARK);
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  word() {
    let _localctx = new WordContext(this._ctx, this.state);
    this.enterRule(_localctx, 10, _SimpleTextParser.RULE_word);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 50;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  expression() {
    let _localctx = new ExpressionContext(this._ctx, this.state);
    this.enterRule(_localctx, 12, _SimpleTextParser.RULE_expression);
    let _la;
    try {
      let _alt;
      this.state = 92;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SimpleTextParser.LPAREN:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 52;
            this.match(_SimpleTextParser.LPAREN);
            this.state = 56;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
              {
                {
                  this.state = 53;
                  this.sentence();
                }
              }
              this.state = 58;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 59;
            this.match(_SimpleTextParser.RPAREN);
          }
          break;
        case _SimpleTextParser.QUOTE:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 60;
            this.match(_SimpleTextParser.QUOTE);
            this.state = 64;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
            while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 61;
                    this.sentence();
                  }
                }
              }
              this.state = 66;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
            }
            this.state = 67;
            this.match(_SimpleTextParser.QUOTE);
          }
          break;
        case _SimpleTextParser.DQUOTE:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 68;
            this.match(_SimpleTextParser.DQUOTE);
            this.state = 72;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 10, this._ctx);
            while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 69;
                    this.sentence();
                  }
                }
              }
              this.state = 74;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 10, this._ctx);
            }
            this.state = 75;
            this.match(_SimpleTextParser.DQUOTE);
          }
          break;
        case _SimpleTextParser.LBRACK:
          this.enterOuterAlt(_localctx, 4);
          {
            this.state = 76;
            this.match(_SimpleTextParser.LBRACK);
            this.state = 80;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
              {
                {
                  this.state = 77;
                  this.sentence();
                }
              }
              this.state = 82;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 83;
            this.match(_SimpleTextParser.RBRACK);
          }
          break;
        case _SimpleTextParser.LACCOL:
          this.enterOuterAlt(_localctx, 5);
          {
            this.state = 84;
            this.match(_SimpleTextParser.LACCOL);
            this.state = 88;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
              {
                {
                  this.state = 85;
                  this.sentence();
                }
              }
              this.state = 90;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 91;
            this.match(_SimpleTextParser.RACCOL);
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  static get _ATN() {
    if (!_SimpleTextParser.__ATN) {
      _SimpleTextParser.__ATN = new import_ATNDeserializer.ATNDeserializer().deserialize(Utils.toCharArray(_SimpleTextParser._serializedATN));
    }
    return _SimpleTextParser.__ATN;
  }
};
var SimpleTextParser = _SimpleTextParser;
SimpleTextParser.Word = 1;
SimpleTextParser.Smiley = 2;
SimpleTextParser.Url = 3;
SimpleTextParser.DOT = 4;
SimpleTextParser.QUESTION_MARK = 5;
SimpleTextParser.EXCLAMATION_MARK = 6;
SimpleTextParser.LPAREN = 7;
SimpleTextParser.RPAREN = 8;
SimpleTextParser.LACCOL = 9;
SimpleTextParser.RACCOL = 10;
SimpleTextParser.LBRACK = 11;
SimpleTextParser.RBRACK = 12;
SimpleTextParser.QUOTE = 13;
SimpleTextParser.DQUOTE = 14;
SimpleTextParser.COLON = 15;
SimpleTextParser.COMMA = 16;
SimpleTextParser.SEMICOLON = 17;
SimpleTextParser.SMILEY = 18;
SimpleTextParser.WS = 19;
SimpleTextParser.RULE_paragraph = 0;
SimpleTextParser.RULE_sentence = 1;
SimpleTextParser.RULE_proposition = 2;
SimpleTextParser.RULE_midPunctuation = 3;
SimpleTextParser.RULE_endPunctuation = 4;
SimpleTextParser.RULE_word = 5;
SimpleTextParser.RULE_expression = 6;
SimpleTextParser.ruleNames = [
  "paragraph",
  "sentence",
  "proposition",
  "midPunctuation",
  "endPunctuation",
  "word",
  "expression"
];
SimpleTextParser._LITERAL_NAMES = [
  void 0,
  void 0,
  void 0,
  void 0,
  "'.'",
  "'?'",
  "'!'",
  "'('",
  "')'",
  "'{'",
  "'}'",
  "'['",
  "']'",
  void 0,
  `'"'`,
  "':'",
  "','",
  "';'"
];
SimpleTextParser._SYMBOLIC_NAMES = [
  void 0,
  "Word",
  "Smiley",
  "Url",
  "DOT",
  "QUESTION_MARK",
  "EXCLAMATION_MARK",
  "LPAREN",
  "RPAREN",
  "LACCOL",
  "RACCOL",
  "LBRACK",
  "RBRACK",
  "QUOTE",
  "DQUOTE",
  "COLON",
  "COMMA",
  "SEMICOLON",
  "SMILEY",
  "WS"
];
SimpleTextParser.VOCABULARY = new import_VocabularyImpl.VocabularyImpl(_SimpleTextParser._LITERAL_NAMES, _SimpleTextParser._SYMBOLIC_NAMES, []);
SimpleTextParser._serializedATN = `\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241a					\x07	\x07\b	\b\x07
\f\v
\r\x1B
#
\r$(
-
\r.3
\x07\x07\b\b\x07\b9
\b\f\b\b<\v\b\b\b\b\x07\bA
\b\f\b\bD\v\b\b\b\b\x07\bI
\b\f\b\bL\v\b\b\b\b\x07\bQ
\b\f\b\bT\v\b\b\b\b\x07\bY
\b\f\b\b\\\v\b\b\b_
\b\b	\b
\fk"\b)
2\f4^\x07\x1B\x1B\x1B
 #\f\x07!#\b" "!#$$"$%%'&(\b'&'((\x07)*	*	+-\x07,+-..,.//303\x07\x0713\x07\b2,20213\v45	5\r6:\x07	79879<:8:;;=<:=_\x07
>B\x07?A@?ADB@BCCEDBE_\x07FJ\x07GIHGILJHJKKMLJM_\x07NR\x07\rOQPOQTRPRSSUTRU_\x07VZ\x07\vWYXWY\\ZXZ[[]\\Z]_\x07\f^6^>^F^N^V_\x1B"$'.2:BJRZ^`;
var ParagraphContext = class extends import_ParserRuleContext.ParserRuleContext {
  EOF() {
    return this.getToken(SimpleTextParser.EOF, 0);
  }
  sentence(i) {
    if (i === void 0) {
      return this.getRuleContexts(SentenceContext);
    } else {
      return this.getRuleContext(i, SentenceContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_paragraph;
  }
  enterRule(listener) {
    if (listener.enterParagraph) {
      listener.enterParagraph(this);
    }
  }
  exitRule(listener) {
    if (listener.exitParagraph) {
      listener.exitParagraph(this);
    }
  }
  accept(visitor) {
    if (visitor.visitParagraph) {
      return visitor.visitParagraph(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var SentenceContext = class extends import_ParserRuleContext.ParserRuleContext {
  proposition(i) {
    if (i === void 0) {
      return this.getRuleContexts(PropositionContext);
    } else {
      return this.getRuleContext(i, PropositionContext);
    }
  }
  endPunctuation() {
    return this.tryGetRuleContext(0, EndPunctuationContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_sentence;
  }
  enterRule(listener) {
    if (listener.enterSentence) {
      listener.enterSentence(this);
    }
  }
  exitRule(listener) {
    if (listener.exitSentence) {
      listener.exitSentence(this);
    }
  }
  accept(visitor) {
    if (visitor.visitSentence) {
      return visitor.visitSentence(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var PropositionContext = class extends import_ParserRuleContext.ParserRuleContext {
  word(i) {
    if (i === void 0) {
      return this.getRuleContexts(WordContext);
    } else {
      return this.getRuleContext(i, WordContext);
    }
  }
  expression(i) {
    if (i === void 0) {
      return this.getRuleContexts(ExpressionContext);
    } else {
      return this.getRuleContext(i, ExpressionContext);
    }
  }
  midPunctuation() {
    return this.tryGetRuleContext(0, MidPunctuationContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_proposition;
  }
  enterRule(listener) {
    if (listener.enterProposition) {
      listener.enterProposition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitProposition) {
      listener.exitProposition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitProposition) {
      return visitor.visitProposition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var MidPunctuationContext = class extends import_ParserRuleContext.ParserRuleContext {
  COMMA() {
    return this.tryGetToken(SimpleTextParser.COMMA, 0);
  }
  COLON() {
    return this.tryGetToken(SimpleTextParser.COLON, 0);
  }
  SEMICOLON() {
    return this.tryGetToken(SimpleTextParser.SEMICOLON, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_midPunctuation;
  }
  enterRule(listener) {
    if (listener.enterMidPunctuation) {
      listener.enterMidPunctuation(this);
    }
  }
  exitRule(listener) {
    if (listener.exitMidPunctuation) {
      listener.exitMidPunctuation(this);
    }
  }
  accept(visitor) {
    if (visitor.visitMidPunctuation) {
      return visitor.visitMidPunctuation(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var EndPunctuationContext = class extends import_ParserRuleContext.ParserRuleContext {
  DOT(i) {
    if (i === void 0) {
      return this.getTokens(SimpleTextParser.DOT);
    } else {
      return this.getToken(SimpleTextParser.DOT, i);
    }
  }
  QUESTION_MARK() {
    return this.tryGetToken(SimpleTextParser.QUESTION_MARK, 0);
  }
  EXCLAMATION_MARK() {
    return this.tryGetToken(SimpleTextParser.EXCLAMATION_MARK, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_endPunctuation;
  }
  enterRule(listener) {
    if (listener.enterEndPunctuation) {
      listener.enterEndPunctuation(this);
    }
  }
  exitRule(listener) {
    if (listener.exitEndPunctuation) {
      listener.exitEndPunctuation(this);
    }
  }
  accept(visitor) {
    if (visitor.visitEndPunctuation) {
      return visitor.visitEndPunctuation(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var WordContext = class extends import_ParserRuleContext.ParserRuleContext {
  Word() {
    return this.tryGetToken(SimpleTextParser.Word, 0);
  }
  Smiley() {
    return this.tryGetToken(SimpleTextParser.Smiley, 0);
  }
  Url() {
    return this.tryGetToken(SimpleTextParser.Url, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_word;
  }
  enterRule(listener) {
    if (listener.enterWord) {
      listener.enterWord(this);
    }
  }
  exitRule(listener) {
    if (listener.exitWord) {
      listener.exitWord(this);
    }
  }
  accept(visitor) {
    if (visitor.visitWord) {
      return visitor.visitWord(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {
  LPAREN() {
    return this.tryGetToken(SimpleTextParser.LPAREN, 0);
  }
  RPAREN() {
    return this.tryGetToken(SimpleTextParser.RPAREN, 0);
  }
  sentence(i) {
    if (i === void 0) {
      return this.getRuleContexts(SentenceContext);
    } else {
      return this.getRuleContext(i, SentenceContext);
    }
  }
  QUOTE(i) {
    if (i === void 0) {
      return this.getTokens(SimpleTextParser.QUOTE);
    } else {
      return this.getToken(SimpleTextParser.QUOTE, i);
    }
  }
  DQUOTE(i) {
    if (i === void 0) {
      return this.getTokens(SimpleTextParser.DQUOTE);
    } else {
      return this.getToken(SimpleTextParser.DQUOTE, i);
    }
  }
  LBRACK() {
    return this.tryGetToken(SimpleTextParser.LBRACK, 0);
  }
  RBRACK() {
    return this.tryGetToken(SimpleTextParser.RBRACK, 0);
  }
  LACCOL() {
    return this.tryGetToken(SimpleTextParser.LACCOL, 0);
  }
  RACCOL() {
    return this.tryGetToken(SimpleTextParser.RACCOL, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_expression;
  }
  enterRule(listener) {
    if (listener.enterExpression) {
      listener.enterExpression(this);
    }
  }
  exitRule(listener) {
    if (listener.exitExpression) {
      listener.exitExpression(this);
    }
  }
  accept(visitor) {
    if (visitor.visitExpression) {
      return visitor.visitExpression(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};

// src/grammar/SimpleTextLexer.ts
var import_ATNDeserializer2 = __toESM(require_ATNDeserializer());
var import_Lexer = __toESM(require_Lexer());
var import_LexerATNSimulator = __toESM(require_LexerATNSimulator());
var import_VocabularyImpl2 = __toESM(require_VocabularyImpl());
var Utils2 = __toESM(require_Utils());
var _SimpleTextLexer = class extends import_Lexer.Lexer {
  get vocabulary() {
    return _SimpleTextLexer.VOCABULARY;
  }
  constructor(input) {
    super(input);
    this._interp = new import_LexerATNSimulator.LexerATNSimulator(_SimpleTextLexer._ATN, this);
  }
  get grammarFileName() {
    return "SimpleText.g4";
  }
  get ruleNames() {
    return _SimpleTextLexer.ruleNames;
  }
  get serializedATN() {
    return _SimpleTextLexer._serializedATN;
  }
  get channelNames() {
    return _SimpleTextLexer.channelNames;
  }
  get modeNames() {
    return _SimpleTextLexer.modeNames;
  }
  static get _ATN() {
    if (!_SimpleTextLexer.__ATN) {
      _SimpleTextLexer.__ATN = new import_ATNDeserializer2.ATNDeserializer().deserialize(Utils2.toCharArray(_SimpleTextLexer._serializedATN));
    }
    return _SimpleTextLexer.__ATN;
  }
};
var SimpleTextLexer = _SimpleTextLexer;
SimpleTextLexer.Word = 1;
SimpleTextLexer.Smiley = 2;
SimpleTextLexer.Url = 3;
SimpleTextLexer.DOT = 4;
SimpleTextLexer.QUESTION_MARK = 5;
SimpleTextLexer.EXCLAMATION_MARK = 6;
SimpleTextLexer.LPAREN = 7;
SimpleTextLexer.RPAREN = 8;
SimpleTextLexer.LACCOL = 9;
SimpleTextLexer.RACCOL = 10;
SimpleTextLexer.LBRACK = 11;
SimpleTextLexer.RBRACK = 12;
SimpleTextLexer.QUOTE = 13;
SimpleTextLexer.DQUOTE = 14;
SimpleTextLexer.COLON = 15;
SimpleTextLexer.COMMA = 16;
SimpleTextLexer.SEMICOLON = 17;
SimpleTextLexer.SMILEY = 18;
SimpleTextLexer.WS = 19;
SimpleTextLexer.channelNames = [
  "DEFAULT_TOKEN_CHANNEL",
  "HIDDEN"
];
SimpleTextLexer.modeNames = [
  "DEFAULT_MODE"
];
SimpleTextLexer.ruleNames = [
  "Word",
  "Smiley",
  "Url",
  "DOT",
  "QUESTION_MARK",
  "EXCLAMATION_MARK",
  "LPAREN",
  "RPAREN",
  "LACCOL",
  "RACCOL",
  "LBRACK",
  "RBRACK",
  "QUOTE",
  "DQUOTE",
  "COLON",
  "COMMA",
  "SEMICOLON",
  "SMILEY",
  "SPACE",
  "WS"
];
SimpleTextLexer._LITERAL_NAMES = [
  void 0,
  void 0,
  void 0,
  void 0,
  "'.'",
  "'?'",
  "'!'",
  "'('",
  "')'",
  "'{'",
  "'}'",
  "'['",
  "']'",
  void 0,
  `'"'`,
  "':'",
  "','",
  "';'"
];
SimpleTextLexer._SYMBOLIC_NAMES = [
  void 0,
  "Word",
  "Smiley",
  "Url",
  "DOT",
  "QUESTION_MARK",
  "EXCLAMATION_MARK",
  "LPAREN",
  "RPAREN",
  "LACCOL",
  "RACCOL",
  "LBRACK",
  "RBRACK",
  "QUOTE",
  "DQUOTE",
  "COLON",
  "COMMA",
  "SEMICOLON",
  "SMILEY",
  "WS"
];
SimpleTextLexer.VOCABULARY = new import_VocabularyImpl2.VocabularyImpl(_SimpleTextLexer._LITERAL_NAMES, _SimpleTextLexer._SYMBOLIC_NAMES, []);
SimpleTextLexer._serializedATN = `\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\x7F\b					\x07	\x07\b	\b			
	
\v	\v\f	\f\r	\r								\x07-
\f0\v3
\r4?
G
\rH\x07\x07\b\b		

\v\v\f\f\r\r\`
l
u
z
\r{\x07	\v\x07\r\b	
\v\f\r\x1B!#%')	\v\f"$*+..00==AA]]__}}\x7F\x7F\v\f"$)+..00<=AA]]__}}\x7F\x7F2;C\\c|\x07%%''-]__c|<=*+FFrr~~\v\f""\x85\x07	\v\r\x1B!#%).6\x078	J\vL\rNPRTVXZ\x1B_ac!e#g%t'v)y+-
,+-0.,.//20.13
21344245567%789\x07j9:\x07v:;\x07v;<\x07r<>=?\x07u>=>??@@A\x07<AB\x071BC\x071CDDF	EG	FEGHHFHII\bJK\x070K
LM\x07AM\fNO\x07#OPQ\x07*QRS\x07+STU\x07}UVW\x07\x7FWXY\x07]YZ[\x07_[\\]\x07"]\`\x07)^\`\x07)_\\_^\`ab\x07$bcd\x07<d ef\x07.f"gh\x07=h$ik	jl\x07/kjkllmmn	\x07nu'op\x07:pq\x07/qr\x07+rssu'titou&vw	\bw(xz'yxz{{y{||}}~\b~*\v.4>H_kt{\b`;

// src/SimpleText.ts
var BuildASTVisitor = class extends import_AbstractParseTreeVisitor.AbstractParseTreeVisitor {
  defaultResult() {
    return {
      type: "default"
    };
  }
  visitParagraph(ctx) {
    return this.processGroup(ctx, "paragraph");
  }
  visitSentence(ctx) {
    return this.processGroup(ctx, "sentence");
  }
  visitProposition(ctx) {
    return this.processGroup(ctx, "proposition");
  }
  visitExpression(ctx) {
    return this.processGroup(ctx, "expression");
  }
  processGroup(ctx, type) {
    var _a;
    const children = (_a = ctx.children) == null ? void 0 : _a.map((child) => this.visit(child));
    return this.createNode(ctx, type, children != null ? children : []);
  }
  visitWord(ctx) {
    return this.processTerminal(ctx, "word");
  }
  visitEndPunctuation(ctx) {
    return this.processTerminal(ctx, "punctuation");
  }
  visitMidPunctuation(ctx) {
    return this.processTerminal(ctx, "mid-punctuation");
  }
  processTerminal(ctx, type) {
    return {
      type,
      start: {
        line: ctx.start.line,
        column: ctx.start.charPositionInLine + 1
      },
      end: {
        line: ctx.start.line,
        column: ctx.start.charPositionInLine + ctx.text.length
      },
      text: ctx.text,
      children: []
    };
  }
  createNode(ctx, type, children) {
    var _a;
    const endToken = (_a = ctx.stop) != null ? _a : ctx.start;
    return {
      type,
      start: { line: ctx.start.line, column: 1 + ctx.start.charPositionInLine },
      end: { line: endToken.line, column: endToken.charPositionInLine },
      text: ctx.text,
      children
    };
  }
};
function fixupAst(node) {
  var _a, _b;
  (_a = node.children) == null ? void 0 : _a.forEach((child) => fixupAst(child));
  const lastChild = node.children ? node.children[node.children.length - 1] : void 0;
  node.end = (_b = lastChild == null ? void 0 : lastChild.end) != null ? _b : node.end;
}
var SimpleText;
((SimpleText2) => {
  function parse3(text4) {
    const inputStream = new import_antlr4ts.ANTLRInputStream(text4);
    const lexer = new SimpleTextLexer(inputStream);
    const tokenStream = new import_antlr4ts.CommonTokenStream(lexer);
    const parser = new SimpleTextParser(tokenStream);
    const tree = parser.paragraph();
    const builder = new BuildASTVisitor();
    const ast = builder.visit(tree);
    fixupAst(ast);
    return ast;
  }
  SimpleText2.parse = parse3;
})(SimpleText || (SimpleText = {}));

// node_modules/mdast-util-to-string/index.js
function toString(node, options) {
  var { includeImageAlt = true } = options || {};
  return one(node, includeImageAlt);
}
function one(node, includeImageAlt) {
  return node && typeof node === "object" && (node.value || (includeImageAlt ? node.alt : "") || "children" in node && all(node.children, includeImageAlt) || Array.isArray(node) && all(node, includeImageAlt)) || "";
}
function all(values, includeImageAlt) {
  var result = [];
  var index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one(values[index2], includeImageAlt);
  }
  return result.join("");
}

// node_modules/micromark-util-chunked/index.js
function splice(list2, start, remove, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    [].splice.apply(list2, parameters);
  } else {
    if (remove)
      [].splice.apply(list2, [start, remove]);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      [].splice.apply(list2, parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    for (code2 in right) {
      if (!hasOwnProperty.call(left, code2))
        left[code2] = [];
      const value2 = right[code2];
      constructs(left[code2], Array.isArray(value2) ? value2 : value2 ? [value2] : []);
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    ;
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-character/lib/unicode-punctuation-regex.js
var unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

// node_modules/micromark-util-character/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return code2 !== null && (code2 < 32 || code2 === 127);
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
var unicodeWhitespace = regexCheck(/\s/);
var unicodePunctuation = regexCheck(unicodePunctuationRegex);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && regex.test(String.fromCharCode(code2));
  }
}

// node_modules/micromark-factory-space/index.js
function factorySpace(effects, ok2, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok2(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok2(code2);
  }
}

// node_modules/micromark/lib/initialize/content.js
var content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  let previous4;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous4
    });
    if (previous4) {
      previous4.next = token;
    }
    previous4 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/micromark/lib/initialize/document.js
var document2 = {
  tokenize: initializeDocument
};
var containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self.containerState = item[1];
      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self.containerState._closeFlow) {
      self.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
      return checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
    }
    self.containerState = {};
    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self.parser.lazy[self.now().line] = continued !== stack.length;
    lineStartOffset = self.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self.currentConstruct, self.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self.parser.flow(self.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self.interrupt = void 0;
      return start;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
          return;
        }
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point2;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point2 = self.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self.containerState = entry[1];
      entry[0].exit.call(self, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}

// node_modules/micromark-util-classify-character/index.js
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text4;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text4 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text4, context]
          ]);
          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
          nextEvents = push(nextEvents, [
            ["exit", text4, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous4 = this.previous;
  const before = classifyCharacter(previous4);
  let marker;
  return start;
  function start(code2) {
    effects.enter("attentionSequence");
    marker = code2;
    return sequence(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return sequence;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close2 = !before || before === 2 && after || attentionMarkers2.includes(previous4);
    token._open = Boolean(marker === 42 ? open : open && (before || !close2));
    token._close = Boolean(marker === 42 ? close2 : close2 && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point2, offset) {
  point2.column += offset;
  point2.offset += offset;
  point2._bufferIndex += offset;
}

// node_modules/micromark-core-commonmark/lib/autolink.js
var autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 1;
  return start;
  function start(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return asciiAtext(code2) ? emailAtext(code2) : nok(code2);
  }
  function schemeOrEmailAtext(code2) {
    return code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2) ? schemeInsideOrEmailAtext(code2) : emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      return end(code2);
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      return end(code2);
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
      effects.consume(code2);
      return code2 === 45 ? emailValue : emailLabel;
    }
    return nok(code2);
  }
  function end(code2) {
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.exit("autolink");
    return ok2;
  }
}

// node_modules/micromark-core-commonmark/lib/blank-line.js
var blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return factorySpace(effects, afterWhitespace, "linePrefix");
  function afterWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 === 62) {
      const state = self.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(blockQuote, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function exit(effects) {
  effects.exit("blockQuote");
}

// node_modules/micromark-core-commonmark/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return open;
  }
  function open(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value2) {
  const characterReference2 = "&" + value2 + ";";
  element.innerHTML = characterReference2;
  const char = element.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value2 !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}

// node_modules/micromark-core-commonmark/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value2(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value2;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value2(code2);
  }
  function value2(code2) {
    let token;
    if (code2 === 59 && size) {
      token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code2) && size++ < max) {
      effects.consume(code2);
      return value2;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/code-fenced.js
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self = this;
  const closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  };
  const nonLazyLine2 = {
    tokenize: tokenizeNonLazyLine2,
    partial: true
  };
  const tail = this.events[this.events.length - 1];
  const initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    marker = code2;
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeFencedFenceSequence");
    return sizeOpen < 3 ? nok(code2) : factorySpace(effects, infoOpen, "whitespace")(code2);
  }
  function infoOpen(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, infoAfter, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return info;
  }
  function infoAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return openAfter(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return meta;
  }
  function openAfter(code2) {
    effects.exit("codeFencedFence");
    return self.interrupt ? ok2(code2) : contentStart(code2);
  }
  function contentStart(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(nonLazyLine2, effects.attempt(closingFenceConstruct, after, initialPrefix ? factorySpace(effects, contentStart, "linePrefix", initialPrefix + 1) : contentStart), after)(code2);
    }
    effects.enter("codeFlowValue");
    return contentContinue(code2);
  }
  function contentContinue(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return contentStart(code2);
    }
    effects.consume(code2);
    return contentContinue;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeNonLazyLine2(effects2, ok3, nok2) {
    const self2 = this;
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self2.parser.lazy[self2.now().line] ? nok2(code2) : ok3(code2);
    }
  }
  function tokenizeClosingFence(effects2, ok3, nok2) {
    let size = 0;
    return factorySpace(effects2, closingSequenceStart, "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function closingSequenceStart(code2) {
      effects2.enter("codeFencedFence");
      effects2.enter("codeFencedFenceSequence");
      return closingSequence(code2);
    }
    function closingSequence(code2) {
      if (code2 === marker) {
        effects2.consume(code2);
        size++;
        return closingSequence;
      }
      if (size < sizeOpen)
        return nok2(code2);
      effects2.exit("codeFencedFenceSequence");
      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code2);
    }
    function closingSequenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}

// node_modules/micromark-core-commonmark/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var indentedContent = {
  tokenize: tokenizeIndentedContent,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterStartPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterStartPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code2) : nok(code2);
  }
  function afterPrefix(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(indentedContent, afterPrefix, after)(code2);
    }
    effects.enter("codeFlowValue");
    return content3(code2);
  }
  function content3(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return afterPrefix(code2);
    }
    effects.consume(code2);
    return content3;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeIndentedContent(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (self.parser.lazy[self.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return start;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? start(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  const self = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return openingSequence(code2);
  }
  function openingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return openingSequence;
    }
    effects.exit("codeTextSequence");
    return gap(code2);
  }
  function gap(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return closingSequence(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return gap;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return gap;
    }
    effects.enter("codeTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return gap(code2);
    }
    effects.consume(code2);
    return data;
  }
  function closingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size++;
      return closingSequence;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token.type = "codeTextData";
    return data(code2);
  }
}

// node_modules/micromark-util-subtokenize/index.js
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous4;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous4) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous4 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.unshift([start2, start2 + slice.length - 1]);
    splice(events, start2, 2, slice);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/lib/content.js
var content2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous4;
  return start;
  function start(code2) {
    effects.enter("content");
    previous4 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
    }
    effects.consume(code2);
    return data;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous4.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous4
    });
    previous4 = previous4.next;
    return data;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self.events[self.events.length - 1];
    if (!self.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self.parser.constructs.flow, nok, ok2)(code2);
  }
}

// node_modules/micromark-factory-destination/index.js
function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return destinationEnclosedBefore;
    }
    if (code2 === null || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationRaw(code2);
  }
  function destinationEnclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationEnclosed(code2);
  }
  function destinationEnclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return destinationEnclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? destinationEnclosedEscape : destinationEnclosed;
  }
  function destinationEnclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return destinationEnclosed;
    }
    return destinationEnclosed(code2);
  }
  function destinationRaw(code2) {
    if (code2 === 40) {
      if (++balance > limit)
        return nok(code2);
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === 41) {
      if (!balance--) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok2(code2);
      }
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      if (balance)
        return nok(code2);
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code2);
    }
    if (asciiControl(code2))
      return nok(code2);
    effects.consume(code2);
    return code2 === 92 ? destinationRawEscape : destinationRaw;
  }
  function destinationRawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return destinationRaw;
    }
    return destinationRaw(code2);
  }
}

// node_modules/micromark-factory-label/index.js
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
  const self = this;
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 && !data || code2 === 94 && !size && "_hiddenFootnoteSupport" in self.parser.constructs || size > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return label(code2);
  }
  function label(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    data = data || !markdownSpace(code2);
    return code2 === 92 ? labelEscape : label;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return label;
    }
    return label(code2);
  }
}

// node_modules/micromark-factory-title/index.js
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    marker = code2 === 40 ? 41 : code2;
    return atFirstTitleBreak;
  }
  function atFirstTitleBreak(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    return atTitleBreak(code2);
  }
  function atTitleBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return atFirstTitleBreak(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atTitleBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return title(code2);
  }
  function title(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atTitleBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? titleEscape : title;
  }
  function titleEscape(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return title;
    }
    return title(code2);
  }
}

// node_modules/micromark-factory-whitespace/index.js
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code2);
    }
    return ok2(code2);
  }
}

// node_modules/micromark-util-normalize-identifier/index.js
function normalizeIdentifier(value2) {
  return value2.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-core-commonmark/lib/definition.js
var definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleConstruct = {
  tokenize: tokenizeTitle,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self = this;
  let identifier;
  return start;
  function start(code2) {
    effects.enter("definition");
    return factoryLabel.call(self, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return factoryWhitespace(effects, factoryDestination(effects, effects.attempt(titleConstruct, factorySpace(effects, after, "whitespace"), factorySpace(effects, after, "whitespace")), nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString"));
    }
    return nok(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      if (!self.parser.defined.includes(identifier)) {
        self.parser.defined.push(identifier);
      }
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitle(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, before)(code2) : nok(code2);
  }
  function before(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, factorySpace(effects, after, "whitespace"), nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("hardBreakEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("escapeMarker");
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text4;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text4 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text4, context],
      ["exit", text4, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  const self = this;
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("atxHeading");
    effects.enter("atxHeadingSequence");
    return fenceOpenInside(code2);
  }
  function fenceOpenInside(code2) {
    if (code2 === 35 && size++ < 6) {
      effects.consume(code2);
      return fenceOpenInside;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return self.interrupt ? ok2(code2) : headingBreak(code2);
    }
    return nok(code2);
  }
  function headingBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequence(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, headingBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data(code2);
  }
  function sequence(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequence;
    }
    effects.exit("atxHeadingSequence");
    return headingBreak(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return headingBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var nextBlankConstruct = {
  tokenize: tokenizeNextBlank,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self = this;
  let kind;
  let startTag;
  let buffer;
  let index2;
  let marker;
  return start;
  function start(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationStart;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      kind = 3;
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      startTag = true;
      return tagName;
    }
    return nok(code2);
  }
  function declarationStart(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      kind = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      kind = 5;
      buffer = "CDATA[";
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      kind = 4;
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    if (code2 === buffer.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === buffer.length ? self.interrupt ? ok2 : continuation : cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      if (code2 !== 47 && startTag && htmlRawNames.includes(buffer.toLowerCase())) {
        kind = 1;
        return self.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        kind = 6;
        if (code2 === 47) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self.interrupt ? ok2(code2) : continuation(code2);
      }
      kind = 7;
      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code2) : startTag ? completeAttributeNameBefore(code2) : completeClosingTagAfter(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    marker = null;
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    if (code2 === marker) {
      effects.consume(code2);
      return completeAttributeValueQuotedAfter;
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return code2 === null || markdownLineEnding(code2) ? continuation(code2) : nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && kind === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && kind === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && kind === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && kind === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && kind === 5) {
      effects.consume(code2);
      return continuationCharacterDataInside;
    }
    if (markdownLineEnding(code2) && (kind === 6 || kind === 7)) {
      return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationAtLineEnding(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationAtLineEnding(code2) {
    effects.exit("htmlFlowData");
    return htmlContinueStart(code2);
  }
  function htmlContinueStart(code2) {
    if (code2 === null) {
      return done(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt({
        tokenize: htmlLineEnd,
        partial: true
      }, htmlContinueStart, done)(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function htmlLineEnd(effects2, ok3, nok2) {
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self.parser.lazy[self.now().line] ? nok2(code2) : ok3(code2);
    }
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62 && htmlRawNames.includes(buffer.toLowerCase())) {
      effects.consume(code2);
      return continuationClose;
    }
    if (asciiAlpha(code2) && buffer.length < 8) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCharacterDataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 45 && kind === 2) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return done(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function done(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNextBlank(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.exit("htmlFlowData");
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    return effects.attempt(blankLine, ok2, nok);
  }
}

// node_modules/micromark-core-commonmark/lib/html-text.js
var htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self = this;
  let marker;
  let buffer;
  let index2;
  let returnState;
  return start;
  function start(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpen;
    }
    if (code2 === 91) {
      effects.consume(code2);
      buffer = "CDATA[";
      index2 = 0;
      return cdataOpen;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentStart;
    }
    return nok(code2);
  }
  function commentStart(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentStartDash;
    }
    return comment(code2);
  }
  function commentStartDash(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    return comment(code2);
  }
  function comment(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return end;
    }
    return comment(code2);
  }
  function cdataOpen(code2) {
    if (code2 === buffer.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === buffer.length ? cdata : cdataOpen;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === null || code2 === 62) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    marker = void 0;
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 62 || code2 === 47 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function atLineEnding(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, afterPrefix, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
  }
  function afterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
  function end(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var fullReferenceConstruct = {
  tokenize: tokenizeFullReference
};
var collapsedReferenceConstruct = {
  tokenize: tokenizeCollapsedReference
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  let token;
  while (++index2 < events.length) {
    token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close2;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close2) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close2 = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close2][1].end)
  };
  const text4 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close2 - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text4, context]]);
  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close2 - 3), context));
  media = push(media, [
    ["exit", text4, context],
    events[close2 - 2],
    events[close2 - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close2 + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self = this;
  let index2 = self.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self.events[index2][1].type === "labelImage" || self.events[index2][1].type === "labelLink") && !self.events[index2][1]._balanced) {
      labelStart = self.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive)
      return balanced(code2);
    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({
      start: labelStart.end,
      end: self.now()
    })));
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return afterLabelEnd;
  }
  function afterLabelEnd(code2) {
    if (code2 === 40) {
      return effects.attempt(resourceConstruct, ok2, defined ? ok2 : balanced)(code2);
    }
    if (code2 === 91) {
      return effects.attempt(fullReferenceConstruct, ok2, defined ? effects.attempt(collapsedReferenceConstruct, ok2, balanced) : balanced)(code2);
    }
    return defined ? ok2(code2) : balanced(code2);
  }
  function balanced(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return factoryWhitespace(effects, open);
  }
  function open(code2) {
    if (code2 === 41) {
      return end(code2);
    }
    return factoryDestination(effects, destinationAfter, nok, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code2);
  }
  function destinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, between)(code2) : end(code2);
  }
  function between(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, factoryWhitespace(effects, end), nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
    }
    return end(code2);
  }
  function end(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeFullReference(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    return factoryLabel.call(self, effects, afterLabel, nok, "reference", "referenceMarker", "referenceString")(code2);
  }
  function afterLabel(code2) {
    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok2(code2) : nok(code2);
  }
}
function tokenizeCollapsedReference(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/line-ending.js
var lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}

// node_modules/micromark-core-commonmark/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("thematicBreak");
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    if (size < 3 || code2 !== null && !markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.exit("thematicBreak");
    return ok2(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return atBreak(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/list.js
var list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code2) {
    const kind = self.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self.containerState.marker || code2 === self.containerState.marker : asciiDigit(code2)) {
      if (!self.containerState.type) {
        self.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code2 === self.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self.containerState.marker = self.containerState.marker || code2;
    return effects.check(blankLine, self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
  }
  function onBlank(code2) {
    self.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self.containerState.size = initialSize + self.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self = this;
  self.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;
    return factorySpace(effects, ok2, "listItemIndent", self.containerState.size + 1)(code2);
  }
  function notBlank(code2) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self.containerState.furtherBlankLines = void 0;
      self.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self.containerState.furtherBlankLines = void 0;
    self.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self.containerState._closeFlow = true;
    self.interrupt = void 0;
    return factorySpace(effects, effects.attempt(list, ok2, nok), "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self.containerState.size + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text4;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text4 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading = {
    type: "setextHeading",
    start: Object.assign({}, events[text4][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text4][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text4, 0, ["enter", heading, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content3][1] = heading;
  }
  events.push(["exit", heading, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self = this;
  let index2 = self.events.length;
  let marker;
  let paragraph;
  while (index2--) {
    if (self.events[index2][1].type !== "lineEnding" && self.events[index2][1].type !== "linePrefix" && self.events[index2][1].type !== "content") {
      paragraph = self.events[index2][1].type === "paragraph";
      break;
    }
  }
  return start;
  function start(code2) {
    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {
      effects.enter("setextHeadingLine");
      effects.enter("setextHeadingLineSequence");
      marker = code2;
      return closingSequence(code2);
    }
    return nok(code2);
  }
  function closingSequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return closingSequence;
    }
    effects.exit("setextHeadingLineSequence");
    return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code2);
  }
  function closingSequenceEnd(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark/lib/initialize/flow.js
var flow = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self = this;
  const initial = effects.attempt(blankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), "linePrefix")));
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/lib/initialize/text.js
var resolver = {
  resolveAll: createResolver()
};
var string = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0)
  };
  function initializeText(effects) {
    const self = this;
    const constructs2 = this.parser.constructs[field];
    const text4 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text4(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text4(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self, self.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) {
        } else {
          index2++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/lib/create-tokenizer.js
function createTokenizer(parser, initialize, from) {
  let point2 = Object.assign(from ? Object.assign({}, from) : {
    line: 1,
    column: 1,
    offset: 0
  }, {
    _index: 0,
    _bufferIndex: -1
  });
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit3,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    return Object.assign({}, point2);
  }
  function defineSkip(value2) {
    columnStart[value2.line] = value2.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    consumed = void 0;
    expectedCode = code2;
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code2;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit3(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start;
        function start(code2) {
          const def = code2 !== null && map[code2];
          const all2 = code2 !== null && map.null;
          const list2 = [
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code2);
          }
          return construct.tokenize.call(fields ? Object.assign(Object.create(context), fields) : context, effects, ok2, nok)(code2);
        }
      }
      function ok2(code2) {
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      view[0] = view[0].slice(startBufferIndex);
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value2;
    if (typeof chunk === "string") {
      value2 = chunk;
    } else
      switch (chunk) {
        case -5: {
          value2 = "\r";
          break;
        }
        case -4: {
          value2 = "\n";
          break;
        }
        case -3: {
          value2 = "\r\n";
          break;
        }
        case -2: {
          value2 = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value2 = " ";
          break;
        }
        default: {
          value2 = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value2);
  }
  return result.join("");
}

// node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text2
});
var document3 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
var contentInitial = {
  [91]: definition
};
var flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
var flow2 = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
var string2 = {
  [38]: characterReference,
  [92]: characterEscape
};
var text2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
var insideSpan = {
  null: [attention, resolver]
};
var attentionMarkers = {
  null: [42, 95]
};
var disable = {
  null: []
};

// node_modules/micromark/lib/parse.js
function parse(options = {}) {
  const constructs2 = combineExtensions([constructs_exports].concat(options.extensions || []));
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content),
    document: create2(document2),
    flow: create2(flow),
    string: create2(string),
    text: create2(text)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/micromark/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value2, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value2 = buffer + value2.toString(encoding);
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value2.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value2.length) {
      search.lastIndex = startPosition;
      match = search.exec(value2);
      endPosition = match && match.index !== void 0 ? match.index : value2.length;
      code2 = value2.charCodeAt(endPosition);
      if (!match) {
        buffer = value2.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value2.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer)
        chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}

// node_modules/micromark/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark-util-decode-numeric-character-reference/index.js
function decodeNumericCharacterReference(value2, base) {
  const code2 = Number.parseInt(value2, base);
  if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
    return "\uFFFD";
  }
  return String.fromCharCode(code2);
}

// node_modules/micromark-util-decode-string/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value2) {
  return value2.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/unist-util-stringify-position/index.js
function stringifyPosition(value2) {
  if (!value2 || typeof value2 !== "object") {
    return "";
  }
  if ("position" in value2 || "type" in value2) {
    return position(value2.position);
  }
  if ("start" in value2 || "end" in value2) {
    return position(value2);
  }
  if ("line" in value2 || "column" in value2) {
    return point(value2);
  }
  return "";
}
function point(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value2) {
  return value2 && typeof value2 === "number" ? value2 : 1;
}

// node_modules/mdast-util-from-markdown/lib/index.js
var own = {}.hasOwnProperty;
var fromMarkdown = function(value2, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value2, encoding, true))));
};
function compiler(options = {}) {
  const config = configure({
    transforms: [],
    canContainEols: [
      "emphasis",
      "fragment",
      "heading",
      "paragraph",
      "strong"
    ],
    enter: {
      autolink: opener2(link),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener2(heading),
      blockQuote: opener2(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener2(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener2(codeFlow, buffer),
      codeText: opener2(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener2(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener2(emphasis),
      hardBreakEscape: opener2(hardBreak),
      hardBreakTrailing: opener2(hardBreak),
      htmlFlow: opener2(html, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener2(html, buffer),
      htmlTextData: onenterdata,
      image: opener2(image),
      label: buffer,
      link: opener2(link),
      listItem: opener2(listItem),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener2(list2, onenterlistordered),
      listUnordered: opener2(list2),
      paragraph: opener2(paragraph),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener2(heading),
      strong: opener2(strong),
      thematicBreak: opener2(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  }, options.mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const stack = [tree];
    const tokenStack = [];
    const listStack = [];
    const context = {
      stack,
      tokenStack,
      config,
      enter,
      exit: exit3,
      buffer,
      resume,
      setData,
      getData
    };
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(Object.assign({
          sliceSerialize: events[index2][2].sliceSerialize
        }, context), events[index2][1]);
      }
    }
    if (tokenStack.length > 0) {
      const tail = tokenStack[tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point2(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem2;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
      } else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem2) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem2._spread = true;
          }
          listItem2.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem2, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem2 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start)
          };
          events.splice(index2, 0, ["enter", listItem2, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function setData(key, value2) {
    data[key] = value2;
  }
  function getData(key) {
    return data[key];
  }
  function point2(d) {
    return {
      line: d.line,
      column: d.column,
      offset: d.offset
    };
  }
  function opener2(create2, and) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    parent.children.push(node);
    this.stack.push(node);
    this.tokenStack.push([token, errorHandler]);
    node.position = {
      start: point2(token.start)
    };
    return node;
  }
  function closer(and) {
    return close2;
    function close2(token) {
      if (and)
        and.call(this, token);
      exit3.call(this, token);
    }
  }
  function exit3(token, onExitError) {
    const node = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
        start: token.start,
        end: token.end
      }) + "): it\u2019s not open");
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node.position.end = point2(token.end);
    return node;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.meta = data2;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside"))
      return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node = this.stack[this.stack.length - 1];
    if (!node.depth) {
      const depth = this.sliceSerialize(token).length;
      node.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    const node = this.stack[this.stack.length - 1];
    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    const parent = this.stack[this.stack.length - 1];
    let tail = parent.children[parent.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text4();
      tail.position = {
        start: point2(token.start)
      };
      parent.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point2(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexitlink() {
    const context = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context.type += "Reference";
      context.referenceType = getData("referenceType") || "shortcut";
      delete context.url;
      delete context.title;
    } else {
      delete context.identifier;
      delete context.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const context = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context.type += "Reference";
      context.referenceType = getData("referenceType") || "shortcut";
      delete context.url;
      delete context.title;
    } else {
      delete context.identifier;
      delete context.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    const ancestor = this.stack[this.stack.length - 2];
    const string3 = this.sliceSerialize(token);
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    setData("inReference", true);
    if (node.type === "link") {
      node.children = fragment.children;
    } else {
      node.alt = value2;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.title = data2;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = getData("characterReferenceType");
    let value2;
    if (type) {
      value2 = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
      setData("characterReferenceType");
    } else {
      value2 = decodeNamedCharacterReference(data2);
    }
    const tail = this.stack.pop();
    tail.value += value2;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node = this.stack[this.stack.length - 1];
    node.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node = this.stack[this.stack.length - 1];
    node.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function hardBreak() {
    return {
      type: "break"
    };
  }
  function html() {
    return {
      type: "html",
      value: ""
    };
  }
  function image() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong() {
    return {
      type: "strong",
      children: []
    };
  }
  function text4() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value2 = extensions[index2];
    if (Array.isArray(value2)) {
      configure(combined, value2);
    } else {
      extension(combined, value2);
    }
  }
  return combined;
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own.call(extension2, key)) {
      const list2 = key === "canContainEols" || key === "transforms";
      const maybe = own.call(combined, key) ? combined[key] : void 0;
      const left = maybe || (combined[key] = list2 ? [] : {});
      const right = extension2[key];
      if (right) {
        if (list2) {
          combined[key] = [...left, ...right];
        } else {
          Object.assign(left, right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
      start: left.start,
      end: left.end
    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is open");
  } else {
    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is still open");
  }
}

// node_modules/micromark-extension-math/lib/math-flow.js
var mathFlow = {
  tokenize: tokenizeMathFenced,
  concrete: true
};
var nonLazyLine = {
  tokenize: tokenizeNonLazyLine,
  partial: true
};
function tokenizeMathFenced(effects, ok2, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  const initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  return start;
  function start(code2) {
    effects.enter("mathFlow");
    effects.enter("mathFlowFence");
    effects.enter("mathFlowFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 36) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("mathFlowFenceSequence");
    return sizeOpen < 2 ? nok(code2) : factorySpace(effects, metaOpen, "whitespace")(code2);
  }
  function metaOpen(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("mathFlowFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("mathFlowFenceMeta");
      return openAfter(code2);
    }
    if (code2 === 36)
      return nok(code2);
    effects.consume(code2);
    return meta;
  }
  function openAfter(code2) {
    effects.exit("mathFlowFence");
    return self.interrupt ? ok2(code2) : contentStart(code2);
  }
  function contentStart(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(nonLazyLine, effects.attempt({
        tokenize: tokenizeClosingFence,
        partial: true
      }, after, initialSize ? factorySpace(effects, contentStart, "linePrefix", initialSize + 1) : contentStart), after)(code2);
    }
    effects.enter("mathFlowValue");
    return contentContinue(code2);
  }
  function contentContinue(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("mathFlowValue");
      return contentStart(code2);
    }
    effects.consume(code2);
    return contentContinue;
  }
  function after(code2) {
    effects.exit("mathFlow");
    return ok2(code2);
  }
  function tokenizeClosingFence(effects2, ok3, nok2) {
    let size = 0;
    return factorySpace(effects2, closingPrefixAfter, "linePrefix", 4);
    function closingPrefixAfter(code2) {
      effects2.enter("mathFlowFence");
      effects2.enter("mathFlowFenceSequence");
      return closingSequence(code2);
    }
    function closingSequence(code2) {
      if (code2 === 36) {
        effects2.consume(code2);
        size++;
        return closingSequence;
      }
      if (size < sizeOpen)
        return nok2(code2);
      effects2.exit("mathFlowFenceSequence");
      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code2);
    }
    function closingSequenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("mathFlowFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyLine(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self.parser.lazy[self.now().line] ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-extension-math/lib/math-text.js
function mathText(options = {}) {
  let single = options.singleDollarTextMath;
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    tokenize: tokenizeMathText,
    resolve: resolveMathText,
    previous: previous2
  };
  function tokenizeMathText(effects, ok2, nok) {
    const self = this;
    let sizeOpen = 0;
    let size;
    let token;
    return start;
    function start(code2) {
      effects.enter("mathText");
      effects.enter("mathTextSequence");
      return openingSequence(code2);
    }
    function openingSequence(code2) {
      if (code2 === 36) {
        effects.consume(code2);
        sizeOpen++;
        return openingSequence;
      }
      if (sizeOpen < 2 && !single)
        return nok(code2);
      effects.exit("mathTextSequence");
      return gap(code2);
    }
    function gap(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 36) {
        token = effects.enter("mathTextSequence");
        size = 0;
        return closingSequence(code2);
      }
      if (code2 === 32) {
        effects.enter("space");
        effects.consume(code2);
        effects.exit("space");
        return gap;
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return gap;
      }
      effects.enter("mathTextData");
      return data(code2);
    }
    function data(code2) {
      if (code2 === null || code2 === 32 || code2 === 36 || markdownLineEnding(code2)) {
        effects.exit("mathTextData");
        return gap(code2);
      }
      effects.consume(code2);
      return data;
    }
    function closingSequence(code2) {
      if (code2 === 36) {
        effects.consume(code2);
        size++;
        return closingSequence;
      }
      if (size === sizeOpen) {
        effects.exit("mathTextSequence");
        effects.exit("mathText");
        return ok2(code2);
      }
      token.type = "mathTextData";
      return data(code2);
    }
  }
}
function resolveMathText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "mathTextData") {
        events[tailExitIndex][1].type = "mathTextPadding";
        events[headEnterIndex][1].type = "mathTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "mathTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous2(code2) {
  return code2 !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}

// node_modules/micromark-extension-math/lib/syntax.js
function math(options) {
  return {
    flow: {
      [36]: mathFlow
    },
    text: {
      [36]: mathText(options)
    }
  };
}

// node_modules/mdast-util-to-markdown/lib/util/track.js
function track(options_) {
  const options = options_ || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;
  return { move, current, shift };
  function current() {
    return { now: { line, column }, lineShift };
  }
  function shift(value2) {
    lineShift += value2;
  }
  function move(value2 = "") {
    const chunks = value2.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value2;
  }
}

// node_modules/mdast-util-math/index.js
function mathFromMarkdown() {
  return {
    enter: {
      mathFlow: enterMathFlow,
      mathFlowFenceMeta: enterMathFlowMeta,
      mathText: enterMathText
    },
    exit: {
      mathFlow: exitMathFlow,
      mathFlowFence: exitMathFlowFence,
      mathFlowFenceMeta: exitMathFlowMeta,
      mathFlowValue: exitMathData,
      mathText: exitMathText,
      mathTextData: exitMathData
    }
  };
  function enterMathFlow(token) {
    this.enter({
      type: "math",
      meta: null,
      value: "",
      data: {
        hName: "div",
        hProperties: { className: ["math", "math-display"] },
        hChildren: [{ type: "text", value: "" }]
      }
    }, token);
  }
  function enterMathFlowMeta() {
    this.buffer();
  }
  function exitMathFlowMeta() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.meta = data;
  }
  function exitMathFlowFence() {
    if (this.getData("mathFlowInside"))
      return;
    this.buffer();
    this.setData("mathFlowInside", true);
  }
  function exitMathFlow(token) {
    const data = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    const node = this.exit(token);
    node.value = data;
    node.data.hChildren[0].value = data;
    this.setData("mathFlowInside");
  }
  function enterMathText(token) {
    this.enter({
      type: "inlineMath",
      value: "",
      data: {
        hName: "span",
        hProperties: { className: ["math", "math-inline"] },
        hChildren: [{ type: "text", value: "" }]
      }
    }, token);
    this.buffer();
  }
  function exitMathText(token) {
    const data = this.resume();
    const node = this.exit(token);
    node.value = data;
    node.data.hChildren[0].value = data;
  }
  function exitMathData(token) {
    this.config.enter.data.call(this, token);
    this.config.exit.data.call(this, token);
  }
}

// node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
var tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};
var gfmTaskListItem = {
  text: {
    [91]: tasklistCheck
  }
};
function tokenizeTasklistCheck(effects, ok2, nok) {
  const self = this;
  return open;
  function open(code2) {
    if (self.previous !== null || !self._gfmTasklistFirstContentOfListItem) {
      return nok(code2);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code2);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code2) {
    if (markdownLineEndingOrSpace(code2)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueUnchecked");
      return close2;
    }
    if (code2 === 88 || code2 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueChecked");
      return close2;
    }
    return nok(code2);
  }
  function close2(code2) {
    if (code2 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code2);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return effects.check({
        tokenize: spaceThenNonSpace
      }, ok2, nok);
    }
    return nok(code2);
  }
}
function spaceThenNonSpace(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, after, "whitespace");
  function after(code2) {
    const tail = self.events[self.events.length - 1];
    return (tail && tail[1].type === "whitespace" || markdownLineEnding(code2)) && code2 !== null ? ok2(code2) : nok(code2);
  }
}

// node_modules/mdast-util-gfm-task-list-item/index.js
var gfmTaskListItemFromMarkdown = {
  exit: {
    taskListCheckValueChecked: exitCheck,
    taskListCheckValueUnchecked: exitCheck,
    paragraph: exitParagraphWithTaskListItem
  }
};
function exitCheck(token) {
  const node = this.stack[this.stack.length - 2];
  node.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  const node = this.stack[this.stack.length - 1];
  const siblings = parent.children;
  const head = node.children[0];
  let index2 = -1;
  let firstParaghraph;
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean" && head && head.type === "text") {
    while (++index2 < siblings.length) {
      const sibling = siblings[index2];
      if (sibling.type === "paragraph") {
        firstParaghraph = sibling;
        break;
      }
    }
    if (firstParaghraph === node) {
      head.value = head.value.slice(1);
      if (head.value.length === 0) {
        node.children.shift();
      } else if (node.position && head.position && typeof head.position.start.offset === "number") {
        head.position.start.column++;
        head.position.start.offset++;
        node.position.start = Object.assign({}, head.position.start);
      }
    }
  }
  this.exit(token);
}

// node_modules/micromark-extension-gfm-table/lib/syntax.js
var gfmTable = {
  flow: {
    null: {
      tokenize: tokenizeTable,
      resolve: resolveTable
    }
  }
};
var nextPrefixedOrBlank = {
  tokenize: tokenizeNextPrefixedOrBlank,
  partial: true
};
function resolveTable(events, context) {
  let index2 = -1;
  let inHead;
  let inDelimiterRow;
  let inRow;
  let contentStart;
  let contentEnd;
  let cellStart;
  let seenCellInRow;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (inRow) {
      if (token.type === "temporaryTableCellContent") {
        contentStart = contentStart || index2;
        contentEnd = index2;
      }
      if ((token.type === "tableCellDivider" || token.type === "tableRow") && contentEnd) {
        const content3 = {
          type: "tableContent",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        const text4 = {
          type: "chunkText",
          start: content3.start,
          end: content3.end,
          contentType: "text"
        };
        events.splice(contentStart, contentEnd - contentStart + 1, ["enter", content3, context], ["enter", text4, context], ["exit", text4, context], ["exit", content3, context]);
        index2 -= contentEnd - contentStart - 3;
        contentStart = void 0;
        contentEnd = void 0;
      }
    }
    if (events[index2][0] === "exit" && cellStart !== void 0 && cellStart + (seenCellInRow ? 0 : 1) < index2 && (token.type === "tableCellDivider" || token.type === "tableRow" && (cellStart + 3 < index2 || events[cellStart][1].type !== "whitespace"))) {
      const cell = {
        type: inDelimiterRow ? "tableDelimiter" : inHead ? "tableHeader" : "tableData",
        start: events[cellStart][1].start,
        end: events[index2][1].end
      };
      events.splice(index2 + (token.type === "tableCellDivider" ? 1 : 0), 0, [
        "exit",
        cell,
        context
      ]);
      events.splice(cellStart, 0, ["enter", cell, context]);
      index2 += 2;
      cellStart = index2 + 1;
      seenCellInRow = true;
    }
    if (token.type === "tableRow") {
      inRow = events[index2][0] === "enter";
      if (inRow) {
        cellStart = index2 + 1;
        seenCellInRow = false;
      }
    }
    if (token.type === "tableDelimiterRow") {
      inDelimiterRow = events[index2][0] === "enter";
      if (inDelimiterRow) {
        cellStart = index2 + 1;
        seenCellInRow = false;
      }
    }
    if (token.type === "tableHead") {
      inHead = events[index2][0] === "enter";
    }
  }
  return events;
}
function tokenizeTable(effects, ok2, nok) {
  const self = this;
  const align = [];
  let tableHeaderCount = 0;
  let seenDelimiter;
  let hasDash;
  return start;
  function start(code2) {
    effects.enter("table")._align = align;
    effects.enter("tableHead");
    effects.enter("tableRow");
    if (code2 === 124) {
      return cellDividerHead(code2);
    }
    tableHeaderCount++;
    effects.enter("temporaryTableCellContent");
    return inCellContentHead(code2);
  }
  function cellDividerHead(code2) {
    effects.enter("tableCellDivider");
    effects.consume(code2);
    effects.exit("tableCellDivider");
    seenDelimiter = true;
    return cellBreakHead;
  }
  function cellBreakHead(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return atRowEndHead(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceHead;
    }
    if (seenDelimiter) {
      seenDelimiter = void 0;
      tableHeaderCount++;
    }
    if (code2 === 124) {
      return cellDividerHead(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentHead(code2);
  }
  function inWhitespaceHead(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceHead;
    }
    effects.exit("whitespace");
    return cellBreakHead(code2);
  }
  function inCellContentHead(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("temporaryTableCellContent");
      return cellBreakHead(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? inCellContentEscapeHead : inCellContentHead;
  }
  function inCellContentEscapeHead(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return inCellContentHead;
    }
    return inCellContentHead(code2);
  }
  function atRowEndHead(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.exit("tableRow");
    effects.exit("tableHead");
    const originalInterrupt = self.interrupt;
    self.interrupt = true;
    return effects.attempt({
      tokenize: tokenizeRowEnd,
      partial: true
    }, function(code3) {
      self.interrupt = originalInterrupt;
      effects.enter("tableDelimiterRow");
      return atDelimiterRowBreak(code3);
    }, function(code3) {
      self.interrupt = originalInterrupt;
      return nok(code3);
    })(code2);
  }
  function atDelimiterRowBreak(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return rowEndDelimiter(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      effects.consume(code2);
      hasDash = true;
      align.push("none");
      return inFillerDelimiter;
    }
    if (code2 === 58) {
      effects.enter("tableDelimiterAlignment");
      effects.consume(code2);
      effects.exit("tableDelimiterAlignment");
      align.push("left");
      return afterLeftAlignment;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return atDelimiterRowBreak;
    }
    return nok(code2);
  }
  function inWhitespaceDelimiter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    effects.exit("whitespace");
    return atDelimiterRowBreak(code2);
  }
  function inFillerDelimiter(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return inFillerDelimiter;
    }
    effects.exit("tableDelimiterFiller");
    if (code2 === 58) {
      effects.enter("tableDelimiterAlignment");
      effects.consume(code2);
      effects.exit("tableDelimiterAlignment");
      align[align.length - 1] = align[align.length - 1] === "left" ? "center" : "right";
      return afterRightAlignment;
    }
    return atDelimiterRowBreak(code2);
  }
  function afterLeftAlignment(code2) {
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      effects.consume(code2);
      hasDash = true;
      return inFillerDelimiter;
    }
    return nok(code2);
  }
  function afterRightAlignment(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return rowEndDelimiter(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return atDelimiterRowBreak;
    }
    return nok(code2);
  }
  function rowEndDelimiter(code2) {
    effects.exit("tableDelimiterRow");
    if (!hasDash || tableHeaderCount !== align.length) {
      return nok(code2);
    }
    if (code2 === null) {
      return tableClose(code2);
    }
    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({
      tokenize: tokenizeRowEnd,
      partial: true
    }, factorySpace(effects, bodyStart, "linePrefix", 4), tableClose))(code2);
  }
  function tableClose(code2) {
    effects.exit("table");
    return ok2(code2);
  }
  function bodyStart(code2) {
    effects.enter("tableBody");
    return rowStartBody(code2);
  }
  function rowStartBody(code2) {
    effects.enter("tableRow");
    if (code2 === 124) {
      return cellDividerBody(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentBody(code2);
  }
  function cellDividerBody(code2) {
    effects.enter("tableCellDivider");
    effects.consume(code2);
    effects.exit("tableCellDivider");
    return cellBreakBody;
  }
  function cellBreakBody(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return atRowEndBody(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceBody;
    }
    if (code2 === 124) {
      return cellDividerBody(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentBody(code2);
  }
  function inWhitespaceBody(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceBody;
    }
    effects.exit("whitespace");
    return cellBreakBody(code2);
  }
  function inCellContentBody(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("temporaryTableCellContent");
      return cellBreakBody(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? inCellContentEscapeBody : inCellContentBody;
  }
  function inCellContentEscapeBody(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return inCellContentBody;
    }
    return inCellContentBody(code2);
  }
  function atRowEndBody(code2) {
    effects.exit("tableRow");
    if (code2 === null) {
      return tableBodyClose(code2);
    }
    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({
      tokenize: tokenizeRowEnd,
      partial: true
    }, factorySpace(effects, rowStartBody, "linePrefix", 4), tableBodyClose))(code2);
  }
  function tableBodyClose(code2) {
    effects.exit("tableBody");
    return tableClose(code2);
  }
  function tokenizeRowEnd(effects2, ok3, nok2) {
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return factorySpace(effects2, prefixed, "linePrefix");
    }
    function prefixed(code2) {
      if (self.parser.lazy[self.now().line] || code2 === null || markdownLineEnding(code2)) {
        return nok2(code2);
      }
      const tail = self.events[self.events.length - 1];
      if (!self.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
        return nok2(code2);
      }
      self._gfmTableDynamicInterruptHack = true;
      return effects2.check(self.parser.constructs.flow, function(code3) {
        self._gfmTableDynamicInterruptHack = false;
        return nok2(code3);
      }, function(code3) {
        self._gfmTableDynamicInterruptHack = false;
        return ok3(code3);
      })(code2);
    }
  }
}
function tokenizeNextPrefixedOrBlank(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("check");
    effects.consume(code2);
    return whitespace;
  }
  function whitespace(code2) {
    if (code2 === -1 || code2 === 32) {
      effects.consume(code2);
      size++;
      return size === 4 ? ok2 : whitespace;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, context, safeOptions) {
  const indexStack = context.indexStack;
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  let before = safeOptions.before;
  indexStack.push(-1);
  let tracker = track(safeOptions);
  while (++index2 < children.length) {
    const child = children[index2];
    let after;
    indexStack[indexStack.length - 1] = index2;
    if (index2 + 1 < children.length) {
      let handle = context.handle.handlers[children[index2 + 1].type];
      if (handle && handle.peek)
        handle = handle.peek;
      after = handle ? handle(children[index2 + 1], parent, context, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after = safeOptions.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
      before = " ";
      tracker = track(safeOptions);
      tracker.move(results.join(""));
    }
    results.push(tracker.move(context.handle(child, parent, context, {
      ...tracker.current(),
      before,
      after
    })));
    before = results[results.length - 1].slice(-1);
  }
  indexStack.pop();
  return results.join("");
}

// node_modules/mdast-util-gfm-table/lib/index.js
var gfmTableFromMarkdown = {
  enter: {
    table: enterTable,
    tableData: enterCell,
    tableHeader: enterCell,
    tableRow: enterRow
  },
  exit: {
    codeText: exitCodeText,
    table: exitTable,
    tableData: exit2,
    tableHeader: exit2,
    tableRow: exit2
  }
};
function enterTable(token) {
  const align = token._align;
  this.enter({
    type: "table",
    align: align.map((d) => d === "none" ? null : d),
    children: []
  }, token);
  this.setData("inTable", true);
}
function exitTable(token) {
  this.exit(token);
  this.setData("inTable");
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit2(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value2 = this.resume();
  if (this.getData("inTable")) {
    value2 = value2.replace(/\\([\\|])/g, replace);
  }
  const node = this.stack[this.stack.length - 1];
  node.value = value2;
  this.exit(token);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}

// node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
function gfmStrikethrough(options = {}) {
  let single = options.singleTilde;
  const tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text4 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text4, context]
            ];
            splice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text4, context],
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context],
              ["exit", strikethrough, context]
            ]);
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok2, nok) {
    const previous4 = this.previous;
    const events = this.events;
    let size = 0;
    return start;
    function start(code2) {
      if (previous4 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code2);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code2);
    }
    function more(code2) {
      const before = classifyCharacter(previous4);
      if (code2 === 126) {
        if (size > 1)
          return nok(code2);
        effects.consume(code2);
        size++;
        return more;
      }
      if (size < 2 && !single)
        return nok(code2);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code2);
      token._open = !after || after === 2 && Boolean(before);
      token._close = !before || before === 2 && Boolean(after);
      return ok2(code2);
    }
  }
}

// node_modules/mdast-util-gfm-strikethrough/index.js
var gfmStrikethroughFromMarkdown = {
  canContainEols: ["delete"],
  enter: { strikethrough: enterStrikethrough },
  exit: { strikethrough: exitStrikethrough }
};
handleDelete.peek = peekDelete;
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node, _, context, safeOptions) {
  const tracker = track(safeOptions);
  const exit3 = context.enter("emphasis");
  let value2 = tracker.move("~~");
  value2 += containerPhrasing(node, context, {
    ...tracker.current(),
    before: value2,
    after: "~"
  });
  value2 += tracker.move("~~");
  exit3();
  return value2;
}
function peekDelete() {
  return "~";
}

// node_modules/micromark-extension-gfm-footnote/lib/syntax.js
var indent = {
  tokenize: tokenizeIndent2,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
  const self = this;
  let index2 = self.events.length;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token = self.events[index2][1];
    if (token.type === "labelImage") {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code2);
    }
    const id = normalizeIdentifier(self.sliceSerialize({
      start: labelStart.end,
      end: self.now()
    }));
    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {
      return nok(code2);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok2(code2);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  let labelStart;
  while (index2--) {
    if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
      labelStart = events[index2][1];
      break;
    }
  }
  events[index2 + 1][1].type = "data";
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call, context],
    events[index2 + 3],
    events[index2 + 4],
    ["enter", marker, context],
    ["exit", marker, context],
    ["enter", string3, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string3, context],
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok2, nok) {
  const self = this;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code2) {
    if (code2 !== 94)
      return nok(code2);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code2) {
    let token;
    if (code2 === null || code2 === 91 || size++ > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      if (!data) {
        return nok(code2);
      }
      effects.exit("chunkString");
      token = effects.exit("gfmFootnoteCallString");
      return defined.includes(normalizeIdentifier(self.sliceSerialize(token))) ? end(code2) : nok(code2);
    }
    effects.consume(code2);
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    return code2 === 92 ? callEscape : callData;
  }
  function callEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return callData;
    }
    return callData(code2);
  }
  function end(code2) {
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    effects.exit("gfmFootnoteCall");
    return ok2;
  }
}
function tokenizeDefinitionStart(effects, ok2, nok) {
  const self = this;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let identifier;
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelStart;
  }
  function labelStart(code2) {
    if (code2 === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      return atBreak;
    }
    return nok(code2);
  }
  function atBreak(code2) {
    let token;
    if (code2 === null || code2 === 91 || size > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      if (!data) {
        return nok(code2);
      }
      token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      size++;
      return atBreak;
    }
    effects.enter("chunkString").contentType = "string";
    return label(code2);
  }
  function label(code2) {
    if (code2 === null || markdownLineEnding(code2) || code2 === 91 || code2 === 93 || size > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size++;
    effects.consume(code2);
    return code2 === 92 ? labelEscape : label;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return label;
    }
    return label(code2);
  }
  function labelAfter(code2) {
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return factorySpace(effects, done, "gfmFootnoteDefinitionWhitespace");
    }
    return nok(code2);
  }
  function done(code2) {
    if (!defined.includes(identifier)) {
      defined.push(identifier);
    }
    return ok2(code2);
  }
}
function tokenizeDefinitionContinuation(effects, ok2, nok) {
  return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent2(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 4 + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
  }
}

// node_modules/mdast-util-gfm-footnote/index.js
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
  function enterFootnoteDefinition(token) {
    this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, token);
  }
  function enterFootnoteDefinitionLabelString() {
    this.buffer();
  }
  function exitFootnoteDefinitionLabelString(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function exitFootnoteDefinition(token) {
    this.exit(token);
  }
  function enterFootnoteCall(token) {
    this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
  }
  function enterFootnoteCallString() {
    this.buffer();
  }
  function exitFootnoteCallString(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function exitFootnoteCall(token) {
    this.exit(token);
  }
}

// node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
var www = {
  tokenize: tokenizeWww,
  partial: true
};
var domain = {
  tokenize: tokenizeDomain,
  partial: true
};
var path = {
  tokenize: tokenizePath,
  partial: true
};
var punctuation = {
  tokenize: tokenizePunctuation,
  partial: true
};
var namedCharacterReference = {
  tokenize: tokenizeNamedCharacterReference,
  partial: true
};
var wwwAutolink = {
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
var httpAutolink = {
  tokenize: tokenizeHttpAutolink,
  previous: previousHttp
};
var emailAutolink = {
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
var text3 = {};
var gfmAutolinkLiteral = {
  text: text3
};
var code = 48;
while (code < 123) {
  text3[code] = emailAutolink;
  code++;
  if (code === 58)
    code = 65;
  else if (code === 91)
    code = 97;
}
text3[43] = emailAutolink;
text3[45] = emailAutolink;
text3[46] = emailAutolink;
text3[95] = emailAutolink;
text3[72] = [emailAutolink, httpAutolink];
text3[104] = [emailAutolink, httpAutolink];
text3[87] = [emailAutolink, wwwAutolink];
text3[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok2, nok) {
  const self = this;
  let hasDot;
  let hasDigitInLastSegment;
  return start;
  function start(code2) {
    if (!gfmAtext(code2) || !previousEmail(self.previous) || previousUnbalanced(self.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code2);
  }
  function atext(code2) {
    if (gfmAtext(code2)) {
      effects.consume(code2);
      return atext;
    }
    if (code2 === 64) {
      effects.consume(code2);
      return label;
    }
    return nok(code2);
  }
  function label(code2) {
    if (code2 === 46) {
      return effects.check(punctuation, done, dotContinuation)(code2);
    }
    if (code2 === 45 || code2 === 95) {
      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code2);
    }
    if (asciiAlphanumeric(code2)) {
      if (!hasDigitInLastSegment && asciiDigit(code2)) {
        hasDigitInLastSegment = true;
      }
      effects.consume(code2);
      return label;
    }
    return done(code2);
  }
  function dotContinuation(code2) {
    effects.consume(code2);
    hasDot = true;
    hasDigitInLastSegment = void 0;
    return label;
  }
  function dashOrUnderscoreContinuation(code2) {
    effects.consume(code2);
    return afterDashOrUnderscore;
  }
  function afterDashOrUnderscore(code2) {
    if (code2 === 46) {
      return effects.check(punctuation, nok, dotContinuation)(code2);
    }
    return label(code2);
  }
  function done(code2) {
    if (hasDot && !hasDigitInLastSegment) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeWwwAutolink(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 !== 87 && code2 !== 119 || !previousWww(self.previous) || previousUnbalanced(self.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(www, effects.attempt(domain, effects.attempt(path, done), nok), nok)(code2);
  }
  function done(code2) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeHttpAutolink(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 !== 72 && code2 !== 104 || !previousHttp(self.previous) || previousUnbalanced(self.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkHttp");
    effects.consume(code2);
    return t1;
  }
  function t1(code2) {
    if (code2 === 84 || code2 === 116) {
      effects.consume(code2);
      return t2;
    }
    return nok(code2);
  }
  function t2(code2) {
    if (code2 === 84 || code2 === 116) {
      effects.consume(code2);
      return p;
    }
    return nok(code2);
  }
  function p(code2) {
    if (code2 === 80 || code2 === 112) {
      effects.consume(code2);
      return s;
    }
    return nok(code2);
  }
  function s(code2) {
    if (code2 === 83 || code2 === 115) {
      effects.consume(code2);
      return colon;
    }
    return colon(code2);
  }
  function colon(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      return slash1;
    }
    return nok(code2);
  }
  function slash1(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return slash2;
    }
    return nok(code2);
  }
  function slash2(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || asciiControl(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path, done), nok)(code2);
  }
  function done(code2) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeWww(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return w2;
  }
  function w2(code2) {
    if (code2 === 87 || code2 === 119) {
      effects.consume(code2);
      return w3;
    }
    return nok(code2);
  }
  function w3(code2) {
    if (code2 === 87 || code2 === 119) {
      effects.consume(code2);
      return dot;
    }
    return nok(code2);
  }
  function dot(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? nok(code2) : ok2(code2);
  }
}
function tokenizeDomain(effects, ok2, nok) {
  let hasUnderscoreInLastSegment;
  let hasUnderscoreInLastLastSegment;
  return domain2;
  function domain2(code2) {
    if (code2 === 38) {
      return effects.check(namedCharacterReference, done, punctuationContinuation)(code2);
    }
    if (code2 === 46 || code2 === 95) {
      return effects.check(punctuation, done, punctuationContinuation)(code2);
    }
    if (code2 === null || asciiControl(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
      return done(code2);
    }
    effects.consume(code2);
    return domain2;
  }
  function punctuationContinuation(code2) {
    if (code2 === 46) {
      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
      hasUnderscoreInLastSegment = void 0;
      effects.consume(code2);
      return domain2;
    }
    if (code2 === 95)
      hasUnderscoreInLastSegment = true;
    effects.consume(code2);
    return domain2;
  }
  function done(code2) {
    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizePath(effects, ok2) {
  let balance = 0;
  return inPath;
  function inPath(code2) {
    if (code2 === 38) {
      return effects.check(namedCharacterReference, ok2, continuedPunctuation)(code2);
    }
    if (code2 === 40) {
      balance++;
    }
    if (code2 === 41) {
      return effects.check(punctuation, parenAtPathEnd, continuedPunctuation)(code2);
    }
    if (pathEnd(code2)) {
      return ok2(code2);
    }
    if (trailingPunctuation(code2)) {
      return effects.check(punctuation, ok2, continuedPunctuation)(code2);
    }
    effects.consume(code2);
    return inPath;
  }
  function continuedPunctuation(code2) {
    effects.consume(code2);
    return inPath;
  }
  function parenAtPathEnd(code2) {
    balance--;
    return balance < 0 ? ok2(code2) : continuedPunctuation(code2);
  }
}
function tokenizeNamedCharacterReference(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return inside;
  }
  function inside(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return inside;
    }
    if (code2 === 59) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return pathEnd(code2) ? ok2(code2) : nok(code2);
  }
}
function tokenizePunctuation(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (trailingPunctuation(code2)) {
      effects.consume(code2);
      return after;
    }
    return pathEnd(code2) ? ok2(code2) : nok(code2);
  }
}
function trailingPunctuation(code2) {
  return code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 95 || code2 === 126;
}
function pathEnd(code2) {
  return code2 === null || code2 === 60 || markdownLineEndingOrSpace(code2);
}
function gfmAtext(code2) {
  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
}
function previousWww(code2) {
  return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 126 || markdownLineEndingOrSpace(code2);
}
function previousHttp(code2) {
  return code2 === null || !asciiAlpha(code2);
}
function previousEmail(code2) {
  return code2 !== 47 && previousHttp(code2);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token = events[index2][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}

// node_modules/ccount/index.js
function ccount(value2, character) {
  const source = String(value2);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character, index2 + character.length);
  }
  return count;
}

// node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/unist-util-is/index.js
var convert = function(test) {
  if (test === void 0 || test === null) {
    return ok;
  }
  if (typeof test === "string") {
    return typeFactory(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
  }
  if (typeof test === "function") {
    return castFactory(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all2);
  function all2(node) {
    let key;
    for (key in check) {
      if (node[key] !== check[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node) {
    return node && node.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(...parameters) {
    return Boolean(check.call(this, ...parameters));
  }
}
function ok() {
  return true;
}

// node_modules/unist-util-visit-parents/color.browser.js
function color(d) {
  return d;
}

// node_modules/unist-util-visit-parents/index.js
var CONTINUE = true;
var SKIP = "skip";
var EXIT = false;
var visitParents = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  const is = convert(test);
  const step = reverse ? -1 : 1;
  factory(tree, null, [])();
  function factory(node, index2, parents) {
    const value2 = typeof node === "object" && node !== null ? node : {};
    let name;
    if (typeof value2.type === "string") {
      name = typeof value2.tagName === "string" ? value2.tagName : typeof value2.name === "string" ? value2.name : void 0;
      Object.defineProperty(visit, "name", {
        value: "node (" + color(value2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit;
    function visit() {
      let result = [];
      let subresult;
      let offset;
      let grandparents;
      if (!test || is(node, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if (node.children && result[0] !== SKIP) {
        offset = (reverse ? node.children.length : -1) + step;
        grandparents = parents.concat(node);
        while (offset > -1 && offset < node.children.length) {
          subresult = factory(node.children[offset], offset, grandparents)();
          if (subresult[0] === EXIT) {
            return subresult;
          }
          offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
        }
      }
      return result;
    }
  }
};
function toResult(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  if (typeof value2 === "number") {
    return [CONTINUE, value2];
  }
  return [value2];
}

// node_modules/mdast-util-find-and-replace/lib/index.js
var own2 = {}.hasOwnProperty;
var findAndReplace = function(tree, find, replace2, options) {
  let settings;
  let schema;
  if (typeof find === "string" || find instanceof RegExp) {
    schema = [[find, replace2]];
    settings = options;
  } else {
    schema = find;
    settings = replace2;
  }
  if (!settings) {
    settings = {};
  }
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(schema);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  return tree;
  function visitor(node, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      if (ignored(parent, grandparent ? grandparent.children.indexOf(parent) : void 0, grandparent)) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node, parents);
    }
  }
  function handler(node, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace3 = pairs[pairIndex][1];
    let start = 0;
    const index2 = parent.children.indexOf(node);
    let change = false;
    let nodes = [];
    let position2;
    find2.lastIndex = 0;
    let match = find2.exec(node.value);
    while (match) {
      position2 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node]
      };
      let value2 = replace3(...match, matchObject);
      if (typeof value2 === "string") {
        value2 = value2.length > 0 ? { type: "text", value: value2 } : void 0;
      }
      if (value2 !== false) {
        if (start !== position2) {
          nodes.push({
            type: "text",
            value: node.value.slice(start, position2)
          });
        }
        if (Array.isArray(value2)) {
          nodes.push(...value2);
        } else if (value2) {
          nodes.push(value2);
        }
        start = position2 + match[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match = find2.exec(node.value);
    }
    if (change) {
      if (start < node.value.length) {
        nodes.push({ type: "text", value: node.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node];
    }
    return index2 + nodes.length;
  }
};
function toPairs(schema) {
  const result = [];
  if (typeof schema !== "object") {
    throw new TypeError("Expected array or object as schema");
  }
  if (Array.isArray(schema)) {
    let index2 = -1;
    while (++index2 < schema.length) {
      result.push([
        toExpression(schema[index2][0]),
        toFunction(schema[index2][1])
      ]);
    }
  } else {
    let key;
    for (key in schema) {
      if (own2.call(schema, key)) {
        result.push([toExpression(key), toFunction(schema[key])]);
      }
    }
  }
  return result;
}
function toExpression(find) {
  return typeof find === "string" ? new RegExp(escapeStringRegexp(find), "g") : find;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : () => replace2;
}

// node_modules/mdast-util-gfm-autolink-literal/index.js
var gfmAutolinkLiteralFromMarkdown = {
  transforms: [transformGfmAutolinkLiterals],
  enter: {
    literalAutolink: enterLiteralAutolink,
    literalAutolinkEmail: enterLiteralAutolinkValue,
    literalAutolinkHttp: enterLiteralAutolinkValue,
    literalAutolinkWww: enterLiteralAutolinkValue
  },
  exit: {
    literalAutolink: exitLiteralAutolink,
    literalAutolinkEmail: exitLiteralAutolinkEmail,
    literalAutolinkHttp: exitLiteralAutolinkHttp,
    literalAutolinkWww: exitLiteralAutolinkWww
  }
};
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node = this.stack[this.stack.length - 1];
  node.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(tree, [
    [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
    [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
  ], { ignore: ["link", "linkReference"] });
}
function findUrl(_, protocol, domain2, path2, match) {
  let prefix = "";
  if (!previous3(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path2);
  if (!parts[0])
    return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_, atext, label, match) {
  if (!previous3(match, true) || /[_-\d]$/.test(label)) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  let closingParenIndex;
  let openingParens;
  let closingParens;
  let trail;
  if (trailExec) {
    url = url.slice(0, trailExec.index);
    trail = trailExec[0];
    closingParenIndex = trail.indexOf(")");
    openingParens = ccount(url, "(");
    closingParens = ccount(url, ")");
    while (closingParenIndex !== -1 && openingParens > closingParens) {
      url += trail.slice(0, closingParenIndex + 1);
      trail = trail.slice(closingParenIndex + 1);
      closingParenIndex = trail.indexOf(")");
      closingParens++;
    }
  }
  return [url, trail];
}
function previous3(match, email) {
  const code2 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
}

// node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral,
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable,
    gfmTaskListItem
  ]);
}

// node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown,
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown,
    gfmTableFromMarkdown,
    gfmTaskListItemFromMarkdown
  ];
}

// node_modules/fault/index.js
var import_format = __toESM(require_format(), 1);
var fault = Object.assign(create(Error), {
  eval: create(EvalError),
  range: create(RangeError),
  reference: create(ReferenceError),
  syntax: create(SyntaxError),
  type: create(TypeError),
  uri: create(URIError)
});
function create(Constructor) {
  FormattedError.displayName = Constructor.displayName || Constructor.name;
  return FormattedError;
  function FormattedError(format, ...values) {
    const reason = format ? (0, import_format.default)(format, ...values) : format;
    return new Constructor(reason);
  }
}

// node_modules/micromark-extension-frontmatter/matters.js
var own3 = {}.hasOwnProperty;
var markers = {
  yaml: "-",
  toml: "+"
};
function matters(options = "yaml") {
  const results = [];
  let index2 = -1;
  if (!Array.isArray(options)) {
    options = [options];
  }
  while (++index2 < options.length) {
    results[index2] = matter(options[index2]);
  }
  return results;
}
function matter(option) {
  let result = option;
  if (typeof result === "string") {
    if (!own3.call(markers, result)) {
      throw fault("Missing matter definition for `%s`", result);
    }
    result = {
      type: result,
      marker: markers[result]
    };
  } else if (typeof result !== "object") {
    throw fault("Expected matter to be an object, not `%j`", result);
  }
  if (!own3.call(result, "type")) {
    throw fault("Missing `type` in matter `%j`", result);
  }
  if (!own3.call(result, "fence") && !own3.call(result, "marker")) {
    throw fault("Missing `marker` or `fence` in matter `%j`", result);
  }
  return result;
}

// node_modules/micromark-extension-frontmatter/lib/syntax.js
function frontmatter(options) {
  const settings = matters(options);
  const flow3 = {};
  let index2 = -1;
  let matter2;
  let code2;
  while (++index2 < settings.length) {
    matter2 = settings[index2];
    code2 = fence(matter2, "open").charCodeAt(0);
    if (code2 in flow3) {
      flow3[code2].push(parse2(matter2));
    } else {
      flow3[code2] = [parse2(matter2)];
    }
  }
  return {
    flow: flow3
  };
}
function parse2(matter2) {
  const name = matter2.type;
  const anywhere = matter2.anywhere;
  const valueType = name + "Value";
  const fenceType = name + "Fence";
  const sequenceType = fenceType + "Sequence";
  const fenceConstruct = {
    tokenize: tokenizeFence,
    partial: true
  };
  let buffer;
  return {
    tokenize: tokenizeFrontmatter,
    concrete: true
  };
  function tokenizeFrontmatter(effects, ok2, nok) {
    const self = this;
    return start;
    function start(code2) {
      const position2 = self.now();
      if (position2.column !== 1 || !anywhere && position2.line !== 1) {
        return nok(code2);
      }
      effects.enter(name);
      buffer = fence(matter2, "open");
      return effects.attempt(fenceConstruct, afterOpeningFence, nok)(code2);
    }
    function afterOpeningFence(code2) {
      buffer = fence(matter2, "close");
      return lineEnd(code2);
    }
    function lineStart(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return lineEnd(code2);
      }
      effects.enter(valueType);
      return lineData(code2);
    }
    function lineData(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit(valueType);
        return lineEnd(code2);
      }
      effects.consume(code2);
      return lineData;
    }
    function lineEnd(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return effects.attempt(fenceConstruct, after, lineStart);
    }
    function after(code2) {
      effects.exit(name);
      return ok2(code2);
    }
  }
  function tokenizeFence(effects, ok2, nok) {
    let bufferIndex = 0;
    return start;
    function start(code2) {
      if (code2 === buffer.charCodeAt(bufferIndex)) {
        effects.enter(fenceType);
        effects.enter(sequenceType);
        return insideSequence(code2);
      }
      return nok(code2);
    }
    function insideSequence(code2) {
      if (bufferIndex === buffer.length) {
        effects.exit(sequenceType);
        if (markdownSpace(code2)) {
          effects.enter("whitespace");
          return insideWhitespace(code2);
        }
        return fenceEnd(code2);
      }
      if (code2 === buffer.charCodeAt(bufferIndex++)) {
        effects.consume(code2);
        return insideSequence;
      }
      return nok(code2);
    }
    function insideWhitespace(code2) {
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return insideWhitespace;
      }
      effects.exit("whitespace");
      return fenceEnd(code2);
    }
    function fenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit(fenceType);
        return ok2(code2);
      }
      return nok(code2);
    }
  }
}
function fence(matter2, prop) {
  return matter2.marker ? pick(matter2.marker, prop).repeat(3) : pick(matter2.fence, prop);
}
function pick(schema, prop) {
  return typeof schema === "string" ? schema : schema[prop];
}

// node_modules/mdast-util-frontmatter/index.js
function frontmatterFromMarkdown(options) {
  const settings = matters(options);
  const enter = {};
  const exit3 = {};
  let index2 = -1;
  while (++index2 < settings.length) {
    const matter2 = settings[index2];
    enter[matter2.type] = opener(matter2);
    exit3[matter2.type] = close;
    exit3[matter2.type + "Value"] = value;
  }
  return { enter, exit: exit3 };
}
function opener(matter2) {
  return open;
  function open(token) {
    this.enter({ type: matter2.type, value: "" }, token);
    this.buffer();
  }
}
function close(token) {
  const data = this.resume();
  this.exit(token).value = data.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
}
function value(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}

// src/Pos.ts
var Pos = class {
  constructor(line, column) {
    this.line = line;
    this.column = column;
  }
  static fromEditorPosition(pos) {
    return new Pos(pos.line + 1, pos.ch + 1);
  }
  toEditorPosition() {
    return {
      line: this.line - 1,
      ch: this.column - 1
    };
  }
  static fromPoint(pos) {
    return new Pos(pos.line, pos.column);
  }
  compareTo(other) {
    if (this.line < other.line) {
      return -1;
    }
    if (this.line > other.line) {
      return 1;
    }
    if (this.column < other.column) {
      return -1;
    }
    if (this.column > other.column) {
      return 1;
    }
    return 0;
  }
  equals(other) {
    return this.compareTo(other) === 0;
  }
  inRange(start, end) {
    return this.compareTo(start) >= 0 && this.compareTo(end) <= 0;
  }
  static order(a, b) {
    if (a.compareTo(b) <= 0) {
      return {
        start: a,
        end: b
      };
    } else {
      return {
        start: b,
        end: a
      };
    }
  }
  minus(other) {
    return new Pos(this.line - other.line, this.column - other.column);
  }
  plus(other) {
    return new Pos(this.line + other.line, this.column - other.column);
  }
};

// src/Mdast.ts
var Mdast = class {
  static inNode(node, pos) {
    if (!node.position) {
      return false;
    }
    return pos.inRange(Pos.fromPoint(node.position.start), Pos.fromPoint(node.position.end));
  }
  static fillsNode(node, { start, end }) {
    if (!node.position) {
      return false;
    }
    return Pos.fromPoint(node.position.start).compareTo(start) === 0 && Pos.fromPoint(node.position.end).compareTo(end) === 0;
  }
  static logPos(pos) {
    if (pos) {
      const start = pos.start;
      const end = pos.end;
      return `[${start.line}:${start.column}-${end.line}:${end.column}]`;
    } else {
      return "[]";
    }
  }
  static logNode(node) {
    return this.logPos(node.position) + ": " + (node.children ? node.children.map((child) => this.logPos(child.position)) : []);
  }
  static adjustBoundaries(parent) {
    const startPos = parent.position.start;
    if (!parent.children) {
      return;
    }
    console.log("before", this.logNode(parent));
    const children = parent.children.filter((child) => !!child.position);
    if (!children.length) {
      return;
    }
    console.log("after", this.logNode(parent));
  }
  static findNodeWithRange(root, { start, end }) {
    var _a;
    let currentParent = root;
    const nodeStack = [];
    while (true) {
      nodeStack.push(currentParent);
      this.adjustBoundaries(currentParent);
      console.log("looking    in", this.logNode(currentParent));
      const child = (_a = currentParent.children) == null ? void 0 : _a.find((node) => this.inNode(node, start) && this.inNode(node, end));
      if (!child) {
        break;
      }
      if ("children" in child) {
        currentParent = child;
      } else {
        nodeStack.push(child);
        break;
      }
    }
    const lastNode = nodeStack[nodeStack.length - 1];
    let sameNodeIndex;
    for (sameNodeIndex = nodeStack.length - 2; sameNodeIndex >= 0; --sameNodeIndex) {
      const parentNode = nodeStack[sameNodeIndex];
      if (Pos.fromPoint(parentNode.position.start).equals(Pos.fromPoint(lastNode.position.start)) && Pos.fromPoint(parentNode.position.end).equals(Pos.fromPoint(lastNode.position.end))) {
      } else {
        break;
      }
    }
    return {
      node: { ...nodeStack[sameNodeIndex + 1], parent: nodeStack[Math.max(0, sameNodeIndex)] },
      ancestors: nodeStack.slice(0, Math.max(0, sameNodeIndex + 1))
    };
  }
  static isInParagraph(ancestors) {
    for (let i = ancestors.length - 1; i >= 0; --i) {
      if (ancestors[i].type === "paragraph") {
        return true;
      }
      if (ancestors[i].type === "section") {
        return false;
      }
    }
    return false;
  }
  static findParentParagraph(ancestors) {
    for (let i = ancestors.length - 1; i >= 0; --i) {
      if (ancestors[i].type === "paragraph") {
        return ancestors[i];
      }
      if (ancestors[i].type === "section") {
        return void 0;
      }
    }
    return void 0;
  }
};
var MarkdownAST = class {
  constructor(root) {
    this.root = root;
  }
  findNodeWithRange(range) {
    return Mdast.findNodeWithRange(this.root, range);
  }
};
var MarkdownASTBuilder = class {
  static parse(markdown) {
    const tree = fromMarkdown(markdown, {
      extensions: [
        math(),
        gfmTaskListItem,
        gfmTable,
        gfmStrikethrough(),
        gfmFootnote(),
        gfmAutolinkLiteral,
        gfm(),
        frontmatter(["yaml"])
      ],
      mdastExtensions: [
        mathFromMarkdown(),
        gfmTaskListItemFromMarkdown,
        gfmTableFromMarkdown,
        gfmStrikethroughFromMarkdown,
        gfmFootnoteFromMarkdown(),
        gfmAutolinkLiteralFromMarkdown,
        gfmFromMarkdown(),
        frontmatterFromMarkdown(["yaml"])
      ]
    });
    this.nestSections(tree);
    return new MarkdownAST(tree);
  }
  static nestSections(tree) {
    for (let depth = 6; depth >= 1; --depth) {
      let currentSection = void 0;
      for (let i = 0; i < tree.children.length; ++i) {
        if (tree.children[i].type === "heading") {
          const heading = tree.children[i];
          if (heading.depth === depth) {
            const sectionContent = {
              type: "section-content",
              children: [],
              position: {
                start: Pos.fromPoint(heading.position.end),
                end: Pos.fromPoint(heading.position.end)
              }
            };
            const subSections = {
              type: "sub-sections",
              children: [],
              position: {
                start: Pos.fromPoint(heading.position.end),
                end: Pos.fromPoint(heading.position.end)
              }
            };
            currentSection = {
              type: "section",
              children: [heading, sectionContent, subSections],
              position: {
                start: Pos.fromPoint(heading.position.start),
                end: Pos.fromPoint(heading.position.end)
              }
            };
            tree.children[i] = currentSection;
          } else if (heading.depth < depth) {
            currentSection = void 0;
          }
        } else {
          if (currentSection) {
            if (tree.children[i].type === "section") {
              currentSection.children[2].children.push(tree.children[i]);
            } else {
              currentSection.children[1].children.push(tree.children[i]);
            }
            const end = Pos.fromPoint(tree.children[i].position.end);
            currentSection.position.end = end;
            currentSection.children[1].position.end = end;
            tree.children[i] = void 0;
          }
        }
      }
      tree.children = tree.children.filter((node) => !!node);
    }
  }
};

// src/Antlr.ts
var Antlr = class {
  static inNode(node, pos) {
    var _a, _b;
    if (((_a = node.start) == null ? void 0 : _a.line) === void 0 || ((_b = node.end) == null ? void 0 : _b.line) === void 0) {
      return false;
    }
    return pos.inRange(Pos.fromPoint(node.start), Pos.fromPoint(node.end));
  }
  static fillsNode(node, { start, end }) {
    var _a, _b;
    if (((_a = node.start) == null ? void 0 : _a.line) === void 0 || ((_b = node.end) == null ? void 0 : _b.line) === void 0) {
      return false;
    }
    return Pos.fromPoint(node.start).compareTo(start) === 0 && Pos.fromPoint(node.end).compareTo(end) === 0;
  }
  static findNodeWithRange(root, { start, end }) {
    var _a;
    let currentParent = root;
    const nodeStack = [];
    while (true) {
      console.log("trying node", currentParent);
      nodeStack.push(currentParent);
      const child = (_a = currentParent.children) == null ? void 0 : _a.find((node) => this.inNode(node, start) && this.inNode(node, end));
      if (!child) {
        console.log("no matching child");
        break;
      }
      if ("children" in child) {
        console.log("child with children");
        currentParent = child;
      } else {
        console.log("child with no children");
        nodeStack.push(child);
        break;
      }
    }
    const lastNode = nodeStack[nodeStack.length - 1];
    let sameNodeIndex;
    for (sameNodeIndex = nodeStack.length - 2; sameNodeIndex >= 0; --sameNodeIndex) {
      const parentNode = nodeStack[sameNodeIndex];
      if (Pos.fromPoint(parentNode.start).equals(Pos.fromPoint(lastNode.start)) && Pos.fromPoint(parentNode.end).equals(Pos.fromPoint(lastNode.end))) {
      } else {
        break;
      }
    }
    return {
      node: nodeStack[sameNodeIndex + 1],
      ancestors: nodeStack.slice(0, Math.max(0, sameNodeIndex + 1))
    };
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  convertSvgToBitmap: true
};
var StructuralEditPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "grow-selection",
      name: "Grow selection",
      editorCallback: async (editor, view) => {
        const cm = view.editor.getDoc().cm;
        const { head, anchor } = editor.listSelections()[0];
        const range = Pos.order(Pos.fromEditorPosition(head), Pos.fromEditorPosition(anchor));
        console.log("selection start", range.start);
        console.log("selection end", range.end);
        const tree = MarkdownASTBuilder.parse(view.data);
        console.log("tree", tree.root);
        let { node: nodeWithSelection, ancestors } = tree.findNodeWithRange(range);
        console.log(ancestors.map((a) => a.type));
        const parentParagraph = Mdast.findParentParagraph(ancestors);
        if (parentParagraph && !Mdast.fillsNode(parentParagraph, range)) {
          const remappedSelection = this.selectInParagraph(view, parentParagraph, range);
          editor.setSelection(remappedSelection.start, remappedSelection.end);
        } else {
          if (Mdast.fillsNode(nodeWithSelection, range) && nodeWithSelection.parent) {
            console.log("node is filled, selecting parent");
            nodeWithSelection = nodeWithSelection.parent;
          }
          console.log(`filling node of type ${nodeWithSelection.type}`);
          editor.setSelection(Pos.fromPoint(nodeWithSelection.position.start).toEditorPosition(), Pos.fromPoint(nodeWithSelection.position.end).toEditorPosition());
        }
      }
    });
  }
  selectInParagraph(view, parentParagraph, range) {
    const paragraphRange = {
      start: parentParagraph.position.start,
      end: parentParagraph.position.end
    };
    console.log("==================== Using sub-parser ==================== ");
    console.log("paragraph start", paragraphRange.start);
    console.log("paragraph end", paragraphRange.end);
    const text4 = view.data.substring(paragraphRange.start.offset, paragraphRange.end.offset);
    console.log(text4);
    const tree = SimpleText.parse(text4);
    console.log(tree);
    const mappedSelection = {
      start: range.start.minus(Pos.fromPoint(paragraphRange.start)),
      end: range.end.minus(Pos.fromPoint(paragraphRange.start))
    };
    mappedSelection.start.line++;
    mappedSelection.end.line++;
    mappedSelection.start.column++;
    mappedSelection.end.column++;
    console.log("mapped selection:", mappedSelection);
    const { node: nodeWithSelection, ancestors } = Antlr.findNodeWithRange(tree, mappedSelection);
    console.log("antlr result node", nodeWithSelection);
    console.log("ancestors", ancestors);
    let textNode = nodeWithSelection;
    if (Antlr.fillsNode(nodeWithSelection, range)) {
      console.log("selection already fills the node, growing !");
      textNode = ancestors[ancestors.length - 1];
    }
    console.log("selecting", textNode);
    console.log(`selecting text ${textNode.text}`);
    console.log("new selection start", textNode.start);
    console.log("new selection end", textNode.end);
    const remappedSelection = {
      start: {
        line: paragraphRange.start.line - 1 + textNode.start.line - 1,
        ch: paragraphRange.start.column - 1 + textNode.start.column - 1
      },
      end: {
        line: paragraphRange.start.line - 1 + textNode.end.line - 1,
        ch: paragraphRange.start.column - 1 + textNode.end.column
      }
    };
    console.log("mapped selection start", remappedSelection.start);
    console.log("mapped selection end", remappedSelection.end);
    return remappedSelection;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL0RlY29yYXRvcnMudHMiLCAic3JjL3RyZWUvQWJzdHJhY3RQYXJzZVRyZWVWaXNpdG9yLnRzIiwgInNyYy9BTlRMUkVycm9yTGlzdGVuZXIudHMiLCAic3JjL0FOVExSRXJyb3JTdHJhdGVneS50cyIsICJzcmMvSW50U3RyZWFtLnRzIiwgInNyYy9BTlRMUklucHV0U3RyZWFtLnRzIiwgInNyYy9hdG4vQVROU3RhdGUudHMiLCAic3JjL2F0bi9BVE5TdGF0ZVR5cGUudHMiLCAic3JjL1JlY29nbml0aW9uRXhjZXB0aW9uLnRzIiwgInNyYy9hdG4vVHJhbnNpdGlvbi50cyIsICJzcmMvYXRuL0Fic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbi50cyIsICJzcmMvbWlzYy9NdXJtdXJIYXNoLnRzIiwgInNyYy9taXNjL09iamVjdEVxdWFsaXR5Q29tcGFyYXRvci50cyIsICJzcmMvbWlzYy9EZWZhdWx0RXF1YWxpdHlDb21wYXJhdG9yLnRzIiwgInNyYy9taXNjL0FycmF5MkRIYXNoU2V0LnRzIiwgInNyYy9taXNjL0FycmF5RXF1YWxpdHlDb21wYXJhdG9yLnRzIiwgInNyYy9taXNjL1V0aWxzLnRzIiwgInNyYy9hdG4vU2VtYW50aWNDb250ZXh0LnRzIiwgInNyYy9hdG4vUHJlZGljYXRlVHJhbnNpdGlvbi50cyIsICJzcmMvRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uLnRzIiwgInNyYy9JbnB1dE1pc21hdGNoRXhjZXB0aW9uLnRzIiwgInNyYy9taXNjL0FycmF5cy50cyIsICJzcmMvbWlzYy9JbnRlZ2VyTGlzdC50cyIsICJzcmMvbWlzYy9JbnRlcnZhbC50cyIsICJzcmMvVG9rZW4udHMiLCAic3JjL0NvbW1vblRva2VuLnRzIiwgInNyYy9Db21tb25Ub2tlbkZhY3RvcnkudHMiLCAic3JjL21pc2MvSW50ZWdlclN0YWNrLnRzIiwgInNyYy9kZmEvQWNjZXB0U3RhdGVJbmZvLnRzIiwgInNyYy9taXNjL0FycmF5MkRIYXNoTWFwLnRzIiwgInNyYy9hdG4vRGVjaXNpb25TdGF0ZS50cyIsICJzcmMvYXRuL1ByZWRpY3Rpb25Db250ZXh0Q2FjaGUudHMiLCAic3JjL2F0bi9QcmVkaWN0aW9uQ29udGV4dC50cyIsICJzcmMvYXRuL0FUTkNvbmZpZy50cyIsICJzcmMvbWlzYy9CaXRTZXQudHMiLCAic3JjL2F0bi9BVE5Db25maWdTZXQudHMiLCAic3JjL2RmYS9ERkFTdGF0ZS50cyIsICJzcmMvYXRuL0FUTlNpbXVsYXRvci50cyIsICJzcmMvQ29uc29sZUVycm9yTGlzdGVuZXIudHMiLCAic3JjL1Byb3h5RXJyb3JMaXN0ZW5lci50cyIsICJzcmMvUmVjb2duaXplci50cyIsICJzcmMvVm9jYWJ1bGFyeUltcGwudHMiLCAic3JjL2RmYS9ERkFTZXJpYWxpemVyLnRzIiwgInNyYy9kZmEvTGV4ZXJERkFTZXJpYWxpemVyLnRzIiwgInNyYy9hdG4vU3Rhckxvb3BFbnRyeVN0YXRlLnRzIiwgInNyYy9kZmEvREZBLnRzIiwgInNyYy9hdG4vQmFzaWNTdGF0ZS50cyIsICJzcmMvYXRuL0ludmFsaWRTdGF0ZS50cyIsICJzcmMvYXRuL1NldFRyYW5zaXRpb24udHMiLCAic3JjL2F0bi9Ob3RTZXRUcmFuc2l0aW9uLnRzIiwgInNyYy9hdG4vUnVsZVN0b3BTdGF0ZS50cyIsICJzcmMvYXRuL1J1bGVUcmFuc2l0aW9uLnRzIiwgInNyYy9hdG4vV2lsZGNhcmRUcmFuc2l0aW9uLnRzIiwgInNyYy9hdG4vTEwxQW5hbHl6ZXIudHMiLCAic3JjL2F0bi9BVE4udHMiLCAic3JjL2F0bi9MZXhlckluZGV4ZWRDdXN0b21BY3Rpb24udHMiLCAic3JjL2F0bi9MZXhlckFjdGlvbkV4ZWN1dG9yLnRzIiwgInNyYy9MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uLnRzIiwgInNyYy9hdG4vT3JkZXJlZEFUTkNvbmZpZ1NldC50cyIsICJzcmMvYXRuL0xleGVyQVROU2ltdWxhdG9yLnRzIiwgInNyYy9MZXhlci50cyIsICJzcmMvbWlzYy9JbnRlcnZhbFNldC50cyIsICJzcmMvYXRuL0FUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMudHMiLCAic3JjL2F0bi9BY3Rpb25UcmFuc2l0aW9uLnRzIiwgInNyYy9hdG4vQXRvbVRyYW5zaXRpb24udHMiLCAic3JjL2F0bi9CbG9ja1N0YXJ0U3RhdGUudHMiLCAic3JjL2F0bi9CYXNpY0Jsb2NrU3RhcnRTdGF0ZS50cyIsICJzcmMvYXRuL0Jsb2NrRW5kU3RhdGUudHMiLCAic3JjL2F0bi9FcHNpbG9uVHJhbnNpdGlvbi50cyIsICJzcmMvYXRuL0xleGVyQ2hhbm5lbEFjdGlvbi50cyIsICJzcmMvYXRuL0xleGVyQ3VzdG9tQWN0aW9uLnRzIiwgInNyYy9hdG4vTGV4ZXJNb2RlQWN0aW9uLnRzIiwgInNyYy9hdG4vTGV4ZXJNb3JlQWN0aW9uLnRzIiwgInNyYy9hdG4vTGV4ZXJQb3BNb2RlQWN0aW9uLnRzIiwgInNyYy9hdG4vTGV4ZXJQdXNoTW9kZUFjdGlvbi50cyIsICJzcmMvYXRuL0xleGVyU2tpcEFjdGlvbi50cyIsICJzcmMvYXRuL0xleGVyVHlwZUFjdGlvbi50cyIsICJzcmMvYXRuL0xvb3BFbmRTdGF0ZS50cyIsICJzcmMvYXRuL0NvbmZsaWN0SW5mby50cyIsICJzcmMvdHJlZS9UZXJtaW5hbE5vZGUudHMiLCAic3JjL3RyZWUvRXJyb3JOb2RlLnRzIiwgInNyYy90cmVlL1J1bGVOb2RlLnRzIiwgInNyYy90cmVlL1RyZWVzLnRzIiwgInNyYy9SdWxlQ29udGV4dC50cyIsICJzcmMvUGFyc2VyUnVsZUNvbnRleHQudHMiLCAic3JjL2F0bi9QcmVkaWN0aW9uTW9kZS50cyIsICJzcmMvYXRuL1NpbXVsYXRvclN0YXRlLnRzIiwgInNyYy9hdG4vUGFyc2VyQVROU2ltdWxhdG9yLnRzIiwgInNyYy9hdG4vUGx1c0Jsb2NrU3RhcnRTdGF0ZS50cyIsICJzcmMvYXRuL1BsdXNMb29wYmFja1N0YXRlLnRzIiwgInNyYy9hdG4vUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24udHMiLCAic3JjL2F0bi9SYW5nZVRyYW5zaXRpb24udHMiLCAic3JjL2F0bi9SdWxlU3RhcnRTdGF0ZS50cyIsICJzcmMvYXRuL1N0YXJCbG9ja1N0YXJ0U3RhdGUudHMiLCAic3JjL2F0bi9TdGFyTG9vcGJhY2tTdGF0ZS50cyIsICJzcmMvYXRuL1Rva2Vuc1N0YXJ0U3RhdGUudHMiLCAic3JjL21pc2MvVVVJRC50cyIsICJzcmMvYXRuL0FUTkRlc2VyaWFsaXplci50cyIsICJzcmMvYXRuL1BhcnNlSW5mby50cyIsICJzcmMvUHJveHlQYXJzZXJFcnJvckxpc3RlbmVyLnRzIiwgInNyYy9taXNjL0NoYXJhY3Rlci50cyIsICJzcmMvQ29kZVBvaW50QnVmZmVyLnRzIiwgInNyYy9Db2RlUG9pbnRDaGFyU3RyZWFtLnRzIiwgInNyYy9DaGFyU3RyZWFtcy50cyIsICJzcmMvQnVmZmVyZWRUb2tlblN0cmVhbS50cyIsICJzcmMvQ29tbW9uVG9rZW5TdHJlYW0udHMiLCAic3JjL0xpc3RUb2tlblNvdXJjZS50cyIsICJzcmMvbWlzYy9NdWx0aU1hcC50cyIsICJzcmMvbWlzYy9QYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbi50cyIsICJzcmMvSW50ZXJwcmV0ZXJSdWxlQ29udGV4dC50cyIsICJzcmMvUGFyc2VySW50ZXJwcmV0ZXIudHMiLCAic3JjL3RyZWUvcGF0dGVybi9QYXJzZVRyZWVNYXRjaC50cyIsICJzcmMvdHJlZS94cGF0aC9YUGF0aExleGVyLnRzIiwgInNyYy90cmVlL3hwYXRoL1hQYXRoTGV4ZXJFcnJvckxpc3RlbmVyLnRzIiwgInNyYy90cmVlL3hwYXRoL1hQYXRoRWxlbWVudC50cyIsICJzcmMvdHJlZS94cGF0aC9YUGF0aFJ1bGVBbnl3aGVyZUVsZW1lbnQudHMiLCAic3JjL3RyZWUveHBhdGgvWFBhdGhSdWxlRWxlbWVudC50cyIsICJzcmMvdHJlZS94cGF0aC9YUGF0aFRva2VuQW55d2hlcmVFbGVtZW50LnRzIiwgInNyYy90cmVlL3hwYXRoL1hQYXRoVG9rZW5FbGVtZW50LnRzIiwgInNyYy90cmVlL3hwYXRoL1hQYXRoV2lsZGNhcmRBbnl3aGVyZUVsZW1lbnQudHMiLCAic3JjL3RyZWUveHBhdGgvWFBhdGhXaWxkY2FyZEVsZW1lbnQudHMiLCAic3JjL3RyZWUveHBhdGgvWFBhdGgudHMiLCAic3JjL3RyZWUvcGF0dGVybi9QYXJzZVRyZWVQYXR0ZXJuLnRzIiwgInNyYy90cmVlL3BhdHRlcm4vUnVsZVRhZ1Rva2VuLnRzIiwgInNyYy90cmVlL3BhdHRlcm4vQ2h1bmsudHMiLCAic3JjL3RyZWUvcGF0dGVybi9UYWdDaHVuay50cyIsICJzcmMvdHJlZS9wYXR0ZXJuL1RleHRDaHVuay50cyIsICJzcmMvdHJlZS9wYXR0ZXJuL1Rva2VuVGFnVG9rZW4udHMiLCAic3JjL3RyZWUvcGF0dGVybi9QYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlci50cyIsICJzcmMvYXRuL0RlY2lzaW9uRXZlbnRJbmZvLnRzIiwgInNyYy9hdG4vQW1iaWd1aXR5SW5mby50cyIsICJzcmMvYXRuL0NvbnRleHRTZW5zaXRpdml0eUluZm8udHMiLCAic3JjL2F0bi9EZWNpc2lvbkluZm8udHMiLCAic3JjL2F0bi9FcnJvckluZm8udHMiLCAic3JjL2F0bi9Mb29rYWhlYWRFdmVudEluZm8udHMiLCAic3JjL2F0bi9QcmVkaWNhdGVFdmFsSW5mby50cyIsICJzcmMvYXRuL1Byb2ZpbGluZ0FUTlNpbXVsYXRvci50cyIsICJzcmMvUGFyc2VyLnRzIiwgInNyYy9Ob1ZpYWJsZUFsdEV4Y2VwdGlvbi50cyIsICJzcmMvRGVmYXVsdEVycm9yU3RyYXRlZ3kudHMiLCAic3JjL0JhaWxFcnJvclN0cmF0ZWd5LnRzIiwgInNyYy9DaGFyU3RyZWFtLnRzIiwgInNyYy9EZXBlbmRlbnRzLnRzIiwgInNyYy9EaWFnbm9zdGljRXJyb3JMaXN0ZW5lci50cyIsICJzcmMvTGV4ZXJJbnRlcnByZXRlci50cyIsICJzcmMvUGFyc2VyRXJyb3JMaXN0ZW5lci50cyIsICJzcmMvUnVsZUNvbnRleHRXaXRoQWx0TnVtLnRzIiwgInNyYy9SdWxlRGVwZW5kZW5jeS50cyIsICJzcmMvUnVsZVZlcnNpb24udHMiLCAic3JjL1Rva2VuRmFjdG9yeS50cyIsICJzcmMvVG9rZW5Tb3VyY2UudHMiLCAic3JjL1Rva2VuU3RyZWFtLnRzIiwgInNyYy9Ub2tlblN0cmVhbVJld3JpdGVyLnRzIiwgInNyYy9Wb2NhYnVsYXJ5LnRzIiwgInNyYy9Xcml0YWJsZVRva2VuLnRzIiwgInNyYy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvZm9ybWF0L2Zvcm1hdC5qcyIsICJzcmMvbWFpbi50cyIsICJzcmMvU2ltcGxlVGV4dC50cyIsICJzcmMvZ3JhbW1hci9TaW1wbGVUZXh0UGFyc2VyLnRzIiwgInNyYy9ncmFtbWFyL1NpbXBsZVRleHRMZXhlci50cyIsICJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1zdHJpbmcvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWNodW5rZWQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWNvbWJpbmUtZXh0ZW5zaW9ucy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyL2xpYi91bmljb2RlLXB1bmN0dWF0aW9uLXJlZ2V4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1jaGFyYWN0ZXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1mYWN0b3J5LXNwYWNlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmsvbGliL2luaXRpYWxpemUvY29udGVudC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrL2xpYi9pbml0aWFsaXplL2RvY3VtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1jbGFzc2lmeS1jaGFyYWN0ZXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLXJlc29sdmUtYWxsL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9hdHRlbnRpb24uanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2F1dG9saW5rLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9ibGFuay1saW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9ibG9jay1xdW90ZS5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvY2hhcmFjdGVyLWVzY2FwZS5qcyIsICJub2RlX21vZHVsZXMvZGVjb2RlLW5hbWVkLWNoYXJhY3Rlci1yZWZlcmVuY2UvaW5kZXguZG9tLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9jaGFyYWN0ZXItcmVmZXJlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9jb2RlLWZlbmNlZC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvY29kZS1pbmRlbnRlZC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvY29kZS10ZXh0LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1zdWJ0b2tlbml6ZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvY29udGVudC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWZhY3RvcnktZGVzdGluYXRpb24vaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1mYWN0b3J5LWxhYmVsL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZmFjdG9yeS10aXRsZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWZhY3Rvcnktd2hpdGVzcGFjZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtbm9ybWFsaXplLWlkZW50aWZpZXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2RlZmluaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2hhcmQtYnJlYWstZXNjYXBlLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9oZWFkaW5nLWF0eC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtaHRtbC10YWctbmFtZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvaHRtbC1mbG93LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9odG1sLXRleHQuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2xhYmVsLWVuZC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvbGFiZWwtc3RhcnQtaW1hZ2UuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2xhYmVsLXN0YXJ0LWxpbmsuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2xpbmUtZW5kaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi90aGVtYXRpYy1icmVhay5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvbGlzdC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvc2V0ZXh0LXVuZGVybGluZS5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrL2xpYi9pbml0aWFsaXplL2Zsb3cuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay9saWIvaW5pdGlhbGl6ZS90ZXh0LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmsvbGliL2NyZWF0ZS10b2tlbml6ZXIuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay9saWIvY29uc3RydWN0cy5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrL2xpYi9wYXJzZS5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrL2xpYi9wcmVwcm9jZXNzLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmsvbGliL3Bvc3Rwcm9jZXNzLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1kZWNvZGUtbnVtZXJpYy1jaGFyYWN0ZXItcmVmZXJlbmNlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1kZWNvZGUtc3RyaW5nL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLXN0cmluZ2lmeS1wb3NpdGlvbi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1tYXRoL2xpYi9tYXRoLWZsb3cuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tbWF0aC9saWIvbWF0aC10ZXh0LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLW1hdGgvbGliL3N5bnRheC5qcyIsICJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC90cmFjay5qcyIsICJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1tYXRoL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YXNrLWxpc3QtaXRlbS9saWIvc3ludGF4LmpzIiwgIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS10YXNrLWxpc3QtaXRlbS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvbGliL3N5bnRheC5qcyIsICJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9jb250YWluZXItcGhyYXNpbmcuanMiLCAibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZ2ZtLXRhYmxlL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tc3RyaWtldGhyb3VnaC9saWIvc3ludGF4LmpzIiwgIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS1zdHJpa2V0aHJvdWdoL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1mb290bm90ZS9saWIvc3ludGF4LmpzIiwgIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS1mb290bm90ZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tYXV0b2xpbmstbGl0ZXJhbC9saWIvc3ludGF4LmpzIiwgIm5vZGVfbW9kdWxlcy9jY291bnQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZmluZC1hbmQtcmVwbGFjZS9ub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3VuaXN0LXV0aWwtaXMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cy9jb2xvci5icm93c2VyLmpzIiwgIm5vZGVfbW9kdWxlcy91bmlzdC11dGlsLXZpc2l0LXBhcmVudHMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZmluZC1hbmQtcmVwbGFjZS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZ2ZtLWF1dG9saW5rLWxpdGVyYWwvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZ2ZtL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2ZhdWx0L2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWZyb250bWF0dGVyL21hdHRlcnMuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZnJvbnRtYXR0ZXIvbGliL3N5bnRheC5qcyIsICJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1mcm9udG1hdHRlci9pbmRleC5qcyIsICJzcmMvUG9zLnRzIiwgInNyYy9NZGFzdC50cyIsICJzcmMvQW50bHIudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIE5vdE51bGwoXHJcblx0dGFyZ2V0OiBhbnksXHJcblx0cHJvcGVydHlLZXk6IFByb3BlcnR5S2V5LFxyXG5cdHByb3BlcnR5RGVzY3JpcHRvcj86IFByb3BlcnR5RGVzY3JpcHRvciB8IG51bWJlcikge1xyXG5cdC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIE51bGxhYmxlKFxyXG5cdHRhcmdldDogYW55LFxyXG5cdHByb3BlcnR5S2V5OiBQcm9wZXJ0eUtleSxcclxuXHRwcm9wZXJ0eURlc2NyaXB0b3I/OiBQcm9wZXJ0eURlc2NyaXB0b3IgfCBudW1iZXIpIHtcclxuXHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBPdmVycmlkZShcclxuXHR0YXJnZXQ6IGFueSxcclxuXHRwcm9wZXJ0eUtleTogUHJvcGVydHlLZXksXHJcblx0cHJvcGVydHlEZXNjcmlwdG9yPzogUHJvcGVydHlEZXNjcmlwdG9yKSB7XHJcblx0Ly8gZG8gc29tZXRoaW5nIHdpdGggJ3RhcmdldCcgLi4uXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBTdXBwcmVzc1dhcm5pbmdzKG9wdGlvbnM6IHN0cmluZykge1xyXG5cdHJldHVybiAodGFyZ2V0OiBhbnksIHByb3BlcnR5S2V5OiBQcm9wZXJ0eUtleSwgZGVzY3JpcHRvcj86IFByb3BlcnR5RGVzY3JpcHRvcikgPT4ge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH07XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ3LjMwOTIyNzktMDc6MDBcclxuXHJcbmltcG9ydCB7IEVycm9yTm9kZSB9IGZyb20gXCIuL0Vycm9yTm9kZVwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWVWaXNpdG9yIH0gZnJvbSBcIi4vUGFyc2VUcmVlVmlzaXRvclwiO1xyXG5pbXBvcnQgeyBSdWxlTm9kZSB9IGZyb20gXCIuL1J1bGVOb2RlXCI7XHJcbmltcG9ydCB7IFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuL1Rlcm1pbmFsTm9kZVwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0UGFyc2VUcmVlVmlzaXRvcjxSZXN1bHQ+IGltcGxlbWVudHMgUGFyc2VUcmVlVmlzaXRvcjxSZXN1bHQ+IHtcclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBjYWxscyB7QGxpbmsgUGFyc2VUcmVlI2FjY2VwdH0gb24gdGhlXHJcblx0ICogc3BlY2lmaWVkIHRyZWUuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHZpc2l0KEBOb3ROdWxsIHRyZWU6IFBhcnNlVHJlZSk6IFJlc3VsdCB7XHJcblx0XHRyZXR1cm4gdHJlZS5hY2NlcHQodGhpcyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpbml0aWFsaXplcyB0aGUgYWdncmVnYXRlIHJlc3VsdCB0b1xyXG5cdCAqIHtAbGluayAjZGVmYXVsdFJlc3VsdCBkZWZhdWx0UmVzdWx0KCl9LiBCZWZvcmUgdmlzaXRpbmcgZWFjaCBjaGlsZCwgaXRcclxuXHQgKiBjYWxscyB7QGxpbmsgI3Nob3VsZFZpc2l0TmV4dENoaWxkIHNob3VsZFZpc2l0TmV4dENoaWxkfTsgaWYgdGhlIHJlc3VsdFxyXG5cdCAqIGlzIGBmYWxzZWAgbm8gbW9yZSBjaGlsZHJlbiBhcmUgdmlzaXRlZCBhbmQgdGhlIGN1cnJlbnQgYWdncmVnYXRlXHJcblx0ICogcmVzdWx0IGlzIHJldHVybmVkLiBBZnRlciB2aXNpdGluZyBhIGNoaWxkLCB0aGUgYWdncmVnYXRlIHJlc3VsdCBpc1xyXG5cdCAqIHVwZGF0ZWQgYnkgY2FsbGluZyB7QGxpbmsgI2FnZ3JlZ2F0ZVJlc3VsdCBhZ2dyZWdhdGVSZXN1bHR9IHdpdGggdGhlXHJcblx0ICogcHJldmlvdXMgYWdncmVnYXRlIHJlc3VsdCBhbmQgdGhlIHJlc3VsdCBvZiB2aXNpdGluZyB0aGUgY2hpbGQuXHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBub3Qgc2FmZSBmb3IgdXNlIGluIHZpc2l0b3JzIHRoYXQgbW9kaWZ5XHJcblx0ICogdGhlIHRyZWUgc3RydWN0dXJlLiBWaXNpdG9ycyB0aGF0IG1vZGlmeSB0aGUgdHJlZSBzaG91bGQgb3ZlcnJpZGUgdGhpc1xyXG5cdCAqIG1ldGhvZCB0byBiZWhhdmUgcHJvcGVybHkgaW4gcmVzcGVjdCB0byB0aGUgc3BlY2lmaWMgYWxnb3JpdGhtIGluIHVzZS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdmlzaXRDaGlsZHJlbihATm90TnVsbCBub2RlOiBSdWxlTm9kZSk6IFJlc3VsdCB7XHJcblx0XHRsZXQgcmVzdWx0OiBSZXN1bHQgPSB0aGlzLmRlZmF1bHRSZXN1bHQoKTtcclxuXHRcdGxldCBuOiBudW1iZXIgPSBub2RlLmNoaWxkQ291bnQ7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuc2hvdWxkVmlzaXROZXh0Q2hpbGQobm9kZSwgcmVzdWx0KSkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgYzogUGFyc2VUcmVlID0gbm9kZS5nZXRDaGlsZChpKTtcclxuXHRcdFx0bGV0IGNoaWxkUmVzdWx0OiBSZXN1bHQgPSBjLmFjY2VwdCh0aGlzKTtcclxuXHRcdFx0cmVzdWx0ID0gdGhpcy5hZ2dyZWdhdGVSZXN1bHQocmVzdWx0LCBjaGlsZFJlc3VsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdGhlIHJlc3VsdCBvZlxyXG5cdCAqIHtAbGluayAjZGVmYXVsdFJlc3VsdCBkZWZhdWx0UmVzdWx0fS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdmlzaXRUZXJtaW5hbChATm90TnVsbCBub2RlOiBUZXJtaW5hbE5vZGUpOiBSZXN1bHQge1xyXG5cdFx0cmV0dXJuIHRoaXMuZGVmYXVsdFJlc3VsdCgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0aGUgcmVzdWx0IG9mXHJcblx0ICoge0BsaW5rICNkZWZhdWx0UmVzdWx0IGRlZmF1bHRSZXN1bHR9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB2aXNpdEVycm9yTm9kZShATm90TnVsbCBub2RlOiBFcnJvck5vZGUpOiBSZXN1bHQge1xyXG5cdFx0cmV0dXJuIHRoaXMuZGVmYXVsdFJlc3VsdCgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSB2aXNpdG9yIG1ldGhvZHMuIFRoaXMgdmFsdWUgaXNcclxuXHQgKiByZXR1cm5lZCBieSB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbnMgb2ZcclxuXHQgKiB7QGxpbmsgI3Zpc2l0VGVybWluYWwgdmlzaXRUZXJtaW5hbH0sIHtAbGluayAjdmlzaXRFcnJvck5vZGUgdmlzaXRFcnJvck5vZGV9LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjdmlzaXRDaGlsZHJlbiB2aXNpdENoaWxkcmVufVxyXG5cdCAqIGluaXRpYWxpemVzIGl0cyBhZ2dyZWdhdGUgcmVzdWx0IHRvIHRoaXMgdmFsdWUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSB2aXNpdG9yIG1ldGhvZHMuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IGRlZmF1bHRSZXN1bHQoKTogUmVzdWx0O1xyXG5cclxuXHQvKipcclxuXHQgKiBBZ2dyZWdhdGVzIHRoZSByZXN1bHRzIG9mIHZpc2l0aW5nIG11bHRpcGxlIGNoaWxkcmVuIG9mIGEgbm9kZS4gQWZ0ZXJcclxuXHQgKiBlaXRoZXIgYWxsIGNoaWxkcmVuIGFyZSB2aXNpdGVkIG9yIHtAbGluayAjc2hvdWxkVmlzaXROZXh0Q2hpbGR9IHJldHVybnNcclxuXHQgKiBgZmFsc2VgLCB0aGUgYWdncmVnYXRlIHZhbHVlIGlzIHJldHVybmVkIGFzIHRoZSByZXN1bHQgb2ZcclxuXHQgKiB7QGxpbmsgI3Zpc2l0Q2hpbGRyZW59LlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgbmV4dFJlc3VsdGAsIG1lYW5pbmdcclxuXHQgKiB7QGxpbmsgI3Zpc2l0Q2hpbGRyZW59IHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgY2hpbGQgdmlzaXRlZFxyXG5cdCAqIChvciByZXR1cm4gdGhlIGluaXRpYWwgdmFsdWUgaWYgdGhlIG5vZGUgaGFzIG5vIGNoaWxkcmVuKS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBhZ2dyZWdhdGUgVGhlIHByZXZpb3VzIGFnZ3JlZ2F0ZSB2YWx1ZS4gSW4gdGhlIGRlZmF1bHRcclxuXHQgKiBpbXBsZW1lbnRhdGlvbiwgdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBpcyBpbml0aWFsaXplZCB0b1xyXG5cdCAqIHtAbGluayAjZGVmYXVsdFJlc3VsdH0sIHdoaWNoIGlzIHBhc3NlZCBhcyB0aGUgYGFnZ3JlZ2F0ZWAgYXJndW1lbnRcclxuXHQgKiB0byB0aGlzIG1ldGhvZCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgbm9kZSBpcyB2aXNpdGVkLlxyXG5cdCAqIEBwYXJhbSBuZXh0UmVzdWx0IFRoZSByZXN1bHQgb2YgdGhlIGltbWVkaWF0ZWx5IHByZWNlZWRpbmcgY2FsbCB0byB2aXNpdFxyXG5cdCAqIGEgY2hpbGQgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGFnZ3JlZ2F0ZSByZXN1bHQuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGFnZ3JlZ2F0ZVJlc3VsdChhZ2dyZWdhdGU6IFJlc3VsdCwgbmV4dFJlc3VsdDogUmVzdWx0KTogUmVzdWx0IHtcclxuXHRcdHJldHVybiBuZXh0UmVzdWx0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGFmdGVyIHZpc2l0aW5nIGVhY2ggY2hpbGQgaW5cclxuXHQgKiB7QGxpbmsgI3Zpc2l0Q2hpbGRyZW59LiBUaGlzIG1ldGhvZCBpcyBmaXJzdCBjYWxsZWQgYmVmb3JlIHRoZSBmaXJzdFxyXG5cdCAqIGNoaWxkIGlzIHZpc2l0ZWQ7IGF0IHRoYXQgcG9pbnQgYGN1cnJlbnRSZXN1bHRgIHdpbGwgYmUgdGhlIGluaXRpYWxcclxuXHQgKiB2YWx1ZSAoaW4gdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIHRoZSBpbml0aWFsIHZhbHVlIGlzIHJldHVybmVkIGJ5IGFcclxuXHQgKiBjYWxsIHRvIHtAbGluayAjZGVmYXVsdFJlc3VsdH0uIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgYWZ0ZXIgdGhlIGxhc3RcclxuXHQgKiBjaGlsZCBpcyB2aXNpdGVkLlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYWx3YXlzIHJldHVybnMgYHRydWVgLCBpbmRpY2F0aW5nIHRoYXRcclxuXHQgKiBgdmlzaXRDaGlsZHJlbmAgc2hvdWxkIG9ubHkgcmV0dXJuIGFmdGVyIGFsbCBjaGlsZHJlbiBhcmUgdmlzaXRlZC5cclxuXHQgKiBPbmUgcmVhc29uIHRvIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlzIHRvIHByb3ZpZGUgYSBcInNob3J0IGNpcmN1aXRcIlxyXG5cdCAqIGV2YWx1YXRpb24gb3B0aW9uIGZvciBzaXR1YXRpb25zIHdoZXJlIHRoZSByZXN1bHQgb2YgdmlzaXRpbmcgYSBzaW5nbGVcclxuXHQgKiBjaGlsZCBoYXMgdGhlIHBvdGVudGlhbCB0byBkZXRlcm1pbmUgdGhlIHJlc3VsdCBvZiB0aGUgdmlzaXQgb3BlcmF0aW9uIGFzXHJcblx0ICogYSB3aG9sZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSB7QGxpbmsgUnVsZU5vZGV9IHdob3NlIGNoaWxkcmVuIGFyZSBjdXJyZW50bHkgYmVpbmdcclxuXHQgKiB2aXNpdGVkLlxyXG5cdCAqIEBwYXJhbSBjdXJyZW50UmVzdWx0IFRoZSBjdXJyZW50IGFnZ3JlZ2F0ZSByZXN1bHQgb2YgdGhlIGNoaWxkcmVuIHZpc2l0ZWRcclxuXHQgKiB0byB0aGUgY3VycmVudCBwb2ludC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIGB0cnVlYCB0byBjb250aW51ZSB2aXNpdGluZyBjaGlsZHJlbi4gT3RoZXJ3aXNlIHJldHVyblxyXG5cdCAqIGBmYWxzZWAgdG8gc3RvcCB2aXNpdGluZyBjaGlsZHJlbiBhbmQgaW1tZWRpYXRlbHkgcmV0dXJuIHRoZVxyXG5cdCAqIGN1cnJlbnQgYWdncmVnYXRlIHJlc3VsdCBmcm9tIHtAbGluayAjdmlzaXRDaGlsZHJlbn0uXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHNob3VsZFZpc2l0TmV4dENoaWxkKEBOb3ROdWxsIG5vZGU6IFJ1bGVOb2RlLCBjdXJyZW50UmVzdWx0OiBSZXN1bHQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDguNzQ5OTk5Ny0wNzowMFxyXG5cclxuLyoqIEhvdyB0byBlbWl0IHJlY29nbml0aW9uIGVycm9ycy4gKi9cclxuaW1wb3J0IHsgUmVjb2duaXplciB9IGZyb20gXCIuL1JlY29nbml6ZXJcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBTlRMUkVycm9yTGlzdGVuZXI8VFN5bWJvbD4ge1xyXG5cdC8qKlxyXG5cdCAqIFVwb24gc3ludGF4IGVycm9yLCBub3RpZnkgYW55IGludGVyZXN0ZWQgcGFydGllcy4gVGhpcyBpcyBub3QgaG93IHRvXHJcblx0ICogcmVjb3ZlciBmcm9tIGVycm9ycyBvciBjb21wdXRlIGVycm9yIG1lc3NhZ2VzLiB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5fVxyXG5cdCAqIHNwZWNpZmllcyBob3cgdG8gcmVjb3ZlciBmcm9tIHN5bnRheCBlcnJvcnMgYW5kIGhvdyB0byBjb21wdXRlIGVycm9yXHJcblx0ICogbWVzc2FnZXMuIFRoaXMgbGlzdGVuZXIncyBqb2IgaXMgc2ltcGx5IHRvIGVtaXQgYSBjb21wdXRlZCBtZXNzYWdlLFxyXG5cdCAqIHRob3VnaCBpdCBoYXMgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSBpdHMgb3duIG1lc3NhZ2UgaW4gbWFueSBjYXNlcy5cclxuXHQgKlxyXG5cdCAqIFRoZSB7QGxpbmsgUmVjb2duaXRpb25FeGNlcHRpb259IGlzIG5vbi1gdW5kZWZpbmVkYCBmb3IgYWxsIHN5bnRheCBlcnJvcnMgZXhjZXB0XHJcblx0ICogd2hlbiB3ZSBkaXNjb3ZlciBtaXNtYXRjaGVkIHRva2VuIGVycm9ycyB0aGF0IHdlIGNhbiByZWNvdmVyIGZyb21cclxuXHQgKiBpbi1saW5lLCB3aXRob3V0IHJldHVybmluZyBmcm9tIHRoZSBzdXJyb3VuZGluZyBydWxlICh2aWEgdGhlIHNpbmdsZVxyXG5cdCAqIHRva2VuIGluc2VydGlvbiBhbmQgZGVsZXRpb24gbWVjaGFuaXNtKS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyXHJcblx0ICogICAgICAgIFdoYXQgcGFyc2VyIGdvdCB0aGUgZXJyb3IuIEZyb20gdGhpc1xyXG5cdCAqIFx0XHQgIG9iamVjdCwgeW91IGNhbiBhY2Nlc3MgdGhlIGNvbnRleHQgYXMgd2VsbFxyXG5cdCAqIFx0XHQgIGFzIHRoZSBpbnB1dCBzdHJlYW0uXHJcblx0ICogQHBhcmFtIG9mZmVuZGluZ1N5bWJvbFxyXG5cdCAqICAgICAgICBUaGUgb2ZmZW5kaW5nIHRva2VuIGluIHRoZSBpbnB1dCB0b2tlblxyXG5cdCAqIFx0XHQgIHN0cmVhbSwgdW5sZXNzIHJlY29nbml6ZXIgaXMgYSBsZXhlciAodGhlbiBpdCdzIGB1bmRlZmluZWRgKS4gSWZcclxuXHQgKiBcdFx0ICBubyB2aWFibGUgYWx0ZXJuYXRpdmUgZXJyb3IsIGBlYCBoYXMgdG9rZW4gYXQgd2hpY2ggd2VcclxuXHQgKiBcdFx0ICBzdGFydGVkIHByb2R1Y3Rpb24gZm9yIHRoZSBkZWNpc2lvbi5cclxuXHQgKiBAcGFyYW0gbGluZVxyXG5cdCAqIFx0XHQgIFRoZSBsaW5lIG51bWJlciBpbiB0aGUgaW5wdXQgd2hlcmUgdGhlIGVycm9yIG9jY3VycmVkLlxyXG5cdCAqIEBwYXJhbSBjaGFyUG9zaXRpb25JbkxpbmVcclxuXHQgKiBcdFx0ICBUaGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdpdGhpbiB0aGF0IGxpbmUgd2hlcmUgdGhlIGVycm9yIG9jY3VycmVkLlxyXG5cdCAqIEBwYXJhbSBtc2dcclxuXHQgKiBcdFx0ICBUaGUgbWVzc2FnZSB0byBlbWl0LlxyXG5cdCAqIEBwYXJhbSBlXHJcblx0ICogICAgICAgIFRoZSBleGNlcHRpb24gZ2VuZXJhdGVkIGJ5IHRoZSBwYXJzZXIgdGhhdCBsZWQgdG9cclxuXHQgKiAgICAgICAgdGhlIHJlcG9ydGluZyBvZiBhbiBlcnJvci4gSXQgaXMgYHVuZGVmaW5lZGAgaW4gdGhlIGNhc2Ugd2hlcmVcclxuXHQgKiAgICAgICAgdGhlIHBhcnNlciB3YXMgYWJsZSB0byByZWNvdmVyIGluIGxpbmUgd2l0aG91dCBleGl0aW5nIHRoZVxyXG5cdCAqICAgICAgICBzdXJyb3VuZGluZyBydWxlLlxyXG5cdCAqL1xyXG5cdHN5bnRheEVycm9yPzogPFQgZXh0ZW5kcyBUU3ltYm9sPihcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0cmVjb2duaXplcjogUmVjb2duaXplcjxULCBhbnk+LFxyXG5cdFx0b2ZmZW5kaW5nU3ltYm9sOiBUIHwgdW5kZWZpbmVkLFxyXG5cdFx0bGluZTogbnVtYmVyLFxyXG5cdFx0Y2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXIsXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdG1zZzogc3RyaW5nLFxyXG5cdFx0ZTogUmVjb2duaXRpb25FeGNlcHRpb24gfCB1bmRlZmluZWQpID0+IHZvaWQ7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ4LjkxMDIxNzQtMDc6MDBcclxuXHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFJlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4vUmVjb2duaXRpb25FeGNlcHRpb25cIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgaW50ZXJmYWNlIGZvciBkZWZpbmluZyBzdHJhdGVnaWVzIHRvIGRlYWwgd2l0aCBzeW50YXggZXJyb3JzIGVuY291bnRlcmVkXHJcbiAqIGR1cmluZyBhIHBhcnNlIGJ5IEFOVExSLWdlbmVyYXRlZCBwYXJzZXJzLiBXZSBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRocmVlXHJcbiAqIGRpZmZlcmVudCBraW5kcyBvZiBlcnJvcnM6XHJcbiAqXHJcbiAqICogVGhlIHBhcnNlciBjb3VsZCBub3QgZmlndXJlIG91dCB3aGljaCBwYXRoIHRvIHRha2UgaW4gdGhlIEFUTiAobm9uZSBvZlxyXG4gKiAgIHRoZSBhdmFpbGFibGUgYWx0ZXJuYXRpdmVzIGNvdWxkIHBvc3NpYmx5IG1hdGNoKVxyXG4gKiAqIFRoZSBjdXJyZW50IGlucHV0IGRvZXMgbm90IG1hdGNoIHdoYXQgd2Ugd2VyZSBsb29raW5nIGZvclxyXG4gKiAqIEEgcHJlZGljYXRlIGV2YWx1YXRlZCB0byBmYWxzZVxyXG4gKlxyXG4gKiBJbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBpbnRlcmZhY2UgcmVwb3J0IHN5bnRheCBlcnJvcnMgYnkgY2FsbGluZ1xyXG4gKiB7QGxpbmsgUGFyc2VyI25vdGlmeUVycm9yTGlzdGVuZXJzfS5cclxuICpcclxuICogVE9ETzogd2hhdCB0byBkbyBhYm91dCBsZXhlcnNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQU5UTFJFcnJvclN0cmF0ZWd5IHtcclxuXHQvKipcclxuXHQgKiBSZXNldCB0aGUgZXJyb3IgaGFuZGxlciBzdGF0ZSBmb3IgdGhlIHNwZWNpZmllZCBgcmVjb2duaXplcmAuXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxyXG5cdCAqL1xyXG5cdHJlc2V0KC8qQE5vdE51bGwqLyByZWNvZ25pemVyOiBQYXJzZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiBhbiB1bmV4cGVjdGVkIHN5bWJvbCBpcyBlbmNvdW50ZXJlZCBkdXJpbmcgYW5cclxuXHQgKiBpbmxpbmUgbWF0Y2ggb3BlcmF0aW9uLCBzdWNoIGFzIHtAbGluayBQYXJzZXIjbWF0Y2h9LiBJZiB0aGUgZXJyb3JcclxuXHQgKiBzdHJhdGVneSBzdWNjZXNzZnVsbHkgcmVjb3ZlcnMgZnJvbSB0aGUgbWF0Y2ggZmFpbHVyZSwgdGhpcyBtZXRob2RcclxuXHQgKiByZXR1cm5zIHRoZSB7QGxpbmsgVG9rZW59IGluc3RhbmNlIHdoaWNoIHNob3VsZCBiZSB0cmVhdGVkIGFzIHRoZVxyXG5cdCAqIHN1Y2Nlc3NmdWwgcmVzdWx0IG9mIHRoZSBtYXRjaC5cclxuXHQgKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIGNvbnN1bXB0aW9uIG9mIGFueSB0b2tlbnMgLSB0aGUgY2FsbGVyIHNob3VsZFxyXG5cdCAqICpub3QqIGNhbGwge0BsaW5rIFBhcnNlciNjb25zdW1lfSBhZnRlciBhIHN1Y2Nlc3NmdWwgcmVjb3ZlcnkuXHJcblx0ICpcclxuXHQgKiBOb3RlIHRoYXQgdGhlIGNhbGxpbmcgY29kZSB3aWxsIG5vdCByZXBvcnQgYW4gZXJyb3IgaWYgdGhpcyBtZXRob2RcclxuXHQgKiByZXR1cm5zIHN1Y2Nlc3NmdWxseS4gVGhlIGVycm9yIHN0cmF0ZWd5IGltcGxlbWVudGF0aW9uIGlzIHJlc3BvbnNpYmxlXHJcblx0ICogZm9yIGNhbGxpbmcge0BsaW5rIFBhcnNlciNub3RpZnlFcnJvckxpc3RlbmVyc30gYXMgYXBwcm9wcmlhdGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICogQCBpZiB0aGUgZXJyb3Igc3RyYXRlZ3kgd2FzIG5vdCBhYmxlIHRvXHJcblx0ICogcmVjb3ZlciBmcm9tIHRoZSB1bmV4cGVjdGVkIGlucHV0IHN5bWJvbFxyXG5cdCAqL1xyXG5cdHJlY292ZXJJbmxpbmUoLypATm90TnVsbCovIHJlY29nbml6ZXI6IFBhcnNlcik6IFRva2VuO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdG8gcmVjb3ZlciBmcm9tIGV4Y2VwdGlvbiBgZWAuIFRoaXMgbWV0aG9kIGlzXHJcblx0ICogY2FsbGVkIGFmdGVyIHtAbGluayAjcmVwb3J0RXJyb3J9IGJ5IHRoZSBkZWZhdWx0IGV4Y2VwdGlvbiBoYW5kbGVyXHJcblx0ICogZ2VuZXJhdGVkIGZvciBhIHJ1bGUgbWV0aG9kLlxyXG5cdCAqXHJcblx0ICogQHNlZSAjcmVwb3J0RXJyb3JcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKiBAcGFyYW0gZSB0aGUgcmVjb2duaXRpb24gZXhjZXB0aW9uIHRvIHJlY292ZXIgZnJvbVxyXG5cdCAqIEAgaWYgdGhlIGVycm9yIHN0cmF0ZWd5IGNvdWxkIG5vdCByZWNvdmVyIGZyb21cclxuXHQgKiB0aGUgcmVjb2duaXRpb24gZXhjZXB0aW9uXHJcblx0ICovXHJcblx0cmVjb3ZlcigvKkBOb3ROdWxsKi8gcmVjb2duaXplcjogUGFyc2VyLCAvKkBOb3ROdWxsKi8gZTogUmVjb2duaXRpb25FeGNlcHRpb24pOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBwcm92aWRlcyB0aGUgZXJyb3IgaGFuZGxlciB3aXRoIGFuIG9wcG9ydHVuaXR5IHRvIGhhbmRsZVxyXG5cdCAqIHN5bnRhY3RpYyBvciBzZW1hbnRpYyBlcnJvcnMgaW4gdGhlIGlucHV0IHN0cmVhbSBiZWZvcmUgdGhleSByZXN1bHQgaW4gYVxyXG5cdCAqIHtAbGluayBSZWNvZ25pdGlvbkV4Y2VwdGlvbn0uXHJcblx0ICpcclxuXHQgKiBUaGUgZ2VuZXJhdGVkIGNvZGUgY3VycmVudGx5IGNvbnRhaW5zIGNhbGxzIHRvIHtAbGluayAjc3luY30gYWZ0ZXJcclxuXHQgKiBlbnRlcmluZyB0aGUgZGVjaXNpb24gc3RhdGUgb2YgYSBjbG9zdXJlIGJsb2NrIChgKC4uLikqYCBvclxyXG5cdCAqIGAoLi4uKStgKS5cclxuXHQgKlxyXG5cdCAqIEZvciBhbiBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBKaW0gSWRsZSdzIFwibWFnaWMgc3luY1wiIG1lY2hhbmlzbSwgc2VlXHJcblx0ICoge0BsaW5rIERlZmF1bHRFcnJvclN0cmF0ZWd5I3N5bmN9LlxyXG5cdCAqXHJcblx0ICogQHNlZSBEZWZhdWx0RXJyb3JTdHJhdGVneSNzeW5jXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICogQCBpZiBhbiBlcnJvciBpcyBkZXRlY3RlZCBieSB0aGUgZXJyb3JcclxuXHQgKiBzdHJhdGVneSBidXQgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgcmVjb3ZlcmVkIGF0IHRoZSBjdXJyZW50IHN0YXRlIGluXHJcblx0ICogdGhlIHBhcnNpbmcgcHJvY2Vzc1xyXG5cdCAqL1xyXG5cdHN5bmMoLypATm90TnVsbCovIHJlY29nbml6ZXI6IFBhcnNlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IGByZWNvZ25pemVyYCBpcyBpbiB0aGUgcHJvY2VzcyBvZiByZWNvdmVyaW5nXHJcblx0ICogZnJvbSBhbiBlcnJvci4gSW4gZXJyb3IgcmVjb3ZlcnkgbW9kZSwge0BsaW5rIFBhcnNlciNjb25zdW1lfSBhZGRzXHJcblx0ICogc3ltYm9scyB0byB0aGUgcGFyc2UgdHJlZSBieSBjYWxsaW5nXHJcblx0ICoge0BsaW5rIFBhcnNlciNjcmVhdGVFcnJvck5vZGUoUGFyc2VyUnVsZUNvbnRleHQsIFRva2VuKX0gdGhlblxyXG5cdCAqIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dCNhZGRFcnJvck5vZGUoRXJyb3JOb2RlKX0gaW5zdGVhZCBvZlxyXG5cdCAqIHtAbGluayBQYXJzZXIjY3JlYXRlVGVybWluYWxOb2RlKFBhcnNlclJ1bGVDb250ZXh0LCBUb2tlbil9LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxyXG5cdCAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgcGFyc2VyIGlzIGN1cnJlbnRseSByZWNvdmVyaW5nIGZyb20gYSBwYXJzZVxyXG5cdCAqIGVycm9yLCBvdGhlcndpc2UgYGZhbHNlYFxyXG5cdCAqL1xyXG5cdGluRXJyb3JSZWNvdmVyeU1vZGUoLypATm90TnVsbCovIHJlY29nbml6ZXI6IFBhcnNlcik6IGJvb2xlYW47XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB3aGVuIHRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IG1hdGNoZXMgYW4gaW5wdXRcclxuXHQgKiBzeW1ib2wuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICovXHJcblx0cmVwb3J0TWF0Y2goLypATm90TnVsbCovIHJlY29nbml6ZXI6IFBhcnNlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlcG9ydCBhbnkga2luZCBvZiB7QGxpbmsgUmVjb2duaXRpb25FeGNlcHRpb259LiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnlcclxuXHQgKiB0aGUgZGVmYXVsdCBleGNlcHRpb24gaGFuZGxlciBnZW5lcmF0ZWQgZm9yIGEgcnVsZSBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICogQHBhcmFtIGUgdGhlIHJlY29nbml0aW9uIGV4Y2VwdGlvbiB0byByZXBvcnRcclxuXHQgKi9cclxuXHRyZXBvcnRFcnJvcihcclxuXHRcdC8qQE5vdE51bGwqLyByZWNvZ25pemVyOiBQYXJzZXIsXHJcblx0XHQvKkBOb3ROdWxsKi8gZTogUmVjb2duaXRpb25FeGNlcHRpb24pOiB2b2lkO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1MS42OTM0Mzc2LTA3OjAwXHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIEludFN0cmVhbSB7XHJcblx0LyoqXHJcblx0ICogVGhlIHZhbHVlIHJldHVybmVkIGJ5IHtAbGluayAjTEEgTEEoKX0gd2hlbiB0aGUgZW5kIG9mIHRoZSBzdHJlYW0gaXNcclxuXHQgKiByZWFjaGVkLlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBjb25zdCBFT0Y6IG51bWJlciA9IC0xO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgdmFsdWUgcmV0dXJuZWQgYnkge0BsaW5rICNnZXRTb3VyY2VOYW1lfSB3aGVuIHRoZSBhY3R1YWwgbmFtZSBvZiB0aGVcclxuXHQgKiB1bmRlcmx5aW5nIHNvdXJjZSBpcyBub3Qga25vd24uXHJcblx0ICovXHJcblx0ZXhwb3J0IGNvbnN0IFVOS05PV05fU09VUkNFX05BTUU6IHN0cmluZyA9IFwiPHVua25vd24+XCI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHNpbXBsZSBzdHJlYW0gb2Ygc3ltYm9scyB3aG9zZSB2YWx1ZXMgYXJlIHJlcHJlc2VudGVkIGFzIGludGVnZXJzLiBUaGlzXHJcbiAqIGludGVyZmFjZSBwcm92aWRlcyAqbWFya2VkIHJhbmdlcyogd2l0aCBzdXBwb3J0IGZvciBhIG1pbmltdW0gbGV2ZWxcclxuICogb2YgYnVmZmVyaW5nIG5lY2Vzc2FyeSB0byBpbXBsZW1lbnQgYXJiaXRyYXJ5IGxvb2thaGVhZCBkdXJpbmcgcHJlZGljdGlvbi5cclxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gbWFya2VkIHJhbmdlcywgc2VlIHtAbGluayAjbWFya30uXHJcbiAqXHJcbiAqICoqSW5pdGlhbGl6aW5nIE1ldGhvZHM6KiogU29tZSBtZXRob2RzIGluIHRoaXMgaW50ZXJmYWNlIGhhdmVcclxuICogdW5zcGVjaWZpZWQgYmVoYXZpb3IgaWYgbm8gY2FsbCB0byBhbiBpbml0aWFsaXppbmcgbWV0aG9kIGhhcyBvY2N1cnJlZCBhZnRlclxyXG4gKiB0aGUgc3RyZWFtIHdhcyBjb25zdHJ1Y3RlZC4gVGhlIGZvbGxvd2luZyBpcyBhIGxpc3Qgb2YgaW5pdGlhbGl6aW5nIG1ldGhvZHM6XHJcbiAqXHJcbiAqICoge0BsaW5rICNMQX1cclxuICogKiB7QGxpbmsgI2NvbnN1bWV9XHJcbiAqICoge0BsaW5rICNzaXplfVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJbnRTdHJlYW0ge1xyXG5cdC8qKlxyXG5cdCAqIENvbnN1bWVzIHRoZSBjdXJyZW50IHN5bWJvbCBpbiB0aGUgc3RyZWFtLiBUaGlzIG1ldGhvZCBoYXMgdGhlIGZvbGxvd2luZ1xyXG5cdCAqIGVmZmVjdHM6XHJcblx0ICpcclxuXHQgKiAqICoqRm9yd2FyZCBtb3ZlbWVudDoqKiBUaGUgdmFsdWUgb2YgYGluZGV4YFxyXG5cdCAqICAgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBgaW5kZXhgXHJcblx0ICogICBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLlxyXG5cdCAqICogKipPcmRlcmVkIGxvb2thaGVhZDoqKiBUaGUgdmFsdWUgb2YgYExBKDEpYCBiZWZvcmVcclxuXHQgKiAgIGNhbGxpbmcgdGhpcyBtZXRob2QgYmVjb21lcyB0aGUgdmFsdWUgb2YgYExBKC0xKWAgYWZ0ZXIgY2FsbGluZ1xyXG5cdCAqICAgdGhpcyBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBOb3RlIHRoYXQgY2FsbGluZyB0aGlzIG1ldGhvZCBkb2VzIG5vdCBndWFyYW50ZWUgdGhhdCBgaW5kZXhgIGlzXHJcblx0ICogaW5jcmVtZW50ZWQgYnkgZXhhY3RseSAxLCBhcyB0aGF0IHdvdWxkIHByZWNsdWRlIHRoZSBhYmlsaXR5IHRvIGltcGxlbWVudFxyXG5cdCAqIGZpbHRlcmluZyBzdHJlYW1zIChlLmcuIHtAbGluayBDb21tb25Ub2tlblN0cmVhbX0gd2hpY2ggZGlzdGluZ3Vpc2hlc1xyXG5cdCAqIGJldHdlZW4gXCJvbi1jaGFubmVsXCIgYW5kIFwib2ZmLWNoYW5uZWxcIiB0b2tlbnMpLlxyXG5cdCAqXHJcblx0ICogQHRocm93cyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24gaWYgYW4gYXR0ZW1wdCBpcyBtYWRlIHRvIGNvbnN1bWUgdGhlXHJcblx0ICogZW5kIG9mIHRoZSBzdHJlYW0gKGkuZS4gaWYgYExBKDEpPT1ge0BsaW5rICNFT0YgRU9GfSBiZWZvcmUgY2FsbGluZ1xyXG5cdCAqIGBjb25zdW1lYCkuXHJcblx0ICovXHJcblx0Y29uc3VtZSgpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgc3ltYm9sIGF0IG9mZnNldCBgaWAgZnJvbSB0aGUgY3VycmVudFxyXG5cdCAqIHBvc2l0aW9uLiBXaGVuIGBpPT0xYCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnRcclxuXHQgKiBzeW1ib2wgaW4gdGhlIHN0cmVhbSAod2hpY2ggaXMgdGhlIG5leHQgc3ltYm9sIHRvIGJlIGNvbnN1bWVkKS4gV2hlblxyXG5cdCAqIGBpPT0tMWAsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBwcmV2aW91c2x5IHJlYWRcclxuXHQgKiBzeW1ib2wgaW4gdGhlIHN0cmVhbS4gSXQgaXMgbm90IHZhbGlkIHRvIGNhbGwgdGhpcyBtZXRob2Qgd2l0aFxyXG5cdCAqIGBpPT0wYCwgYnV0IHRoZSBzcGVjaWZpYyBiZWhhdmlvciBpcyB1bnNwZWNpZmllZCBiZWNhdXNlIHRoaXNcclxuXHQgKiBtZXRob2QgaXMgZnJlcXVlbnRseSBjYWxsZWQgZnJvbSBwZXJmb3JtYW5jZS1jcml0aWNhbCBjb2RlLlxyXG5cdCAqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgZ3VhcmFudGVlZCB0byBzdWNjZWVkIGlmIGFueSBvZiB0aGUgZm9sbG93aW5nIGFyZSB0cnVlOlxyXG5cdCAqXHJcblx0ICogKiBgaT4wYFxyXG5cdCAqICogYGk9PS0xYCBhbmQgYGluZGV4YCByZXR1cm5zIGEgdmFsdWUgZ3JlYXRlclxyXG5cdCAqICAgdGhhbiB0aGUgdmFsdWUgb2YgYGluZGV4YCBhZnRlciB0aGUgc3RyZWFtIHdhcyBjb25zdHJ1Y3RlZFxyXG5cdCAqICAgYW5kIGBMQSgxKWAgd2FzIGNhbGxlZCBpbiB0aGF0IG9yZGVyLiBTcGVjaWZ5aW5nIHRoZSBjdXJyZW50XHJcblx0ICogICBgaW5kZXhgIHJlbGF0aXZlIHRvIHRoZSBpbmRleCBhZnRlciB0aGUgc3RyZWFtIHdhcyBjcmVhdGVkXHJcblx0ICogICBhbGxvd3MgZm9yIGZpbHRlcmluZyBpbXBsZW1lbnRhdGlvbnMgdGhhdCBkbyBub3QgcmV0dXJuIGV2ZXJ5IHN5bWJvbFxyXG5cdCAqICAgZnJvbSB0aGUgdW5kZXJseWluZyBzb3VyY2UuIFNwZWNpZnlpbmcgdGhlIGNhbGwgdG8gYExBKDEpYFxyXG5cdCAqICAgYWxsb3dzIGZvciBsYXppbHkgaW5pdGlhbGl6ZWQgc3RyZWFtcy5cclxuXHQgKiAqIGBMQShpKWAgcmVmZXJzIHRvIGEgc3ltYm9sIGNvbnN1bWVkIHdpdGhpbiBhIG1hcmtlZCByZWdpb25cclxuXHQgKiAgIHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiByZWxlYXNlZC5cclxuXHQgKlxyXG5cdCAqIElmIGBpYCByZXByZXNlbnRzIGEgcG9zaXRpb24gYXQgb3IgYmV5b25kIHRoZSBlbmQgb2YgdGhlIHN0cmVhbSxcclxuXHQgKiB0aGlzIG1ldGhvZCByZXR1cm5zIHtAbGluayAjRU9GfS5cclxuXHQgKlxyXG5cdCAqIFRoZSByZXR1cm4gdmFsdWUgaXMgdW5zcGVjaWZpZWQgaWYgYGk8MGAgYW5kIGZld2VyIHRoYW4gYC1pYFxyXG5cdCAqIGNhbGxzIHRvIHtAbGluayAjY29uc3VtZSBjb25zdW1lKCl9IGhhdmUgb2NjdXJyZWQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mXHJcblx0ICogdGhlIHN0cmVhbSBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gaWYgdGhlIHN0cmVhbSBkb2VzIG5vdCBzdXBwb3J0XHJcblx0ICogcmV0cmlldmluZyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBzeW1ib2xcclxuXHQgKi9cclxuXHRMQShpOiBudW1iZXIpOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEEgbWFyayBwcm92aWRlcyBhIGd1YXJhbnRlZSB0aGF0IHtAbGluayAjc2VlayBzZWVrKCl9IG9wZXJhdGlvbnMgd2lsbCBiZVxyXG5cdCAqIHZhbGlkIG92ZXIgYSBcIm1hcmtlZCByYW5nZVwiIGV4dGVuZGluZyBmcm9tIHRoZSBpbmRleCB3aGVyZSBgbWFyaygpYFxyXG5cdCAqIHdhcyBjYWxsZWQgdG8gdGhlIGN1cnJlbnQgYGluZGV4YC4gVGhpcyBhbGxvd3MgdGhlIHVzZSBvZlxyXG5cdCAqIHN0cmVhbWluZyBpbnB1dCBzb3VyY2VzIGJ5IHNwZWNpZnlpbmcgdGhlIG1pbmltdW0gYnVmZmVyaW5nIHJlcXVpcmVtZW50c1xyXG5cdCAqIHRvIHN1cHBvcnQgYXJiaXRyYXJ5IGxvb2thaGVhZCBkdXJpbmcgcHJlZGljdGlvbi5cclxuXHQgKlxyXG5cdCAqIFRoZSByZXR1cm5lZCBtYXJrIGlzIGFuIG9wYXF1ZSBoYW5kbGUgKHR5cGUgYGludGApIHdoaWNoIGlzIHBhc3NlZFxyXG5cdCAqIHRvIHtAbGluayAjcmVsZWFzZSByZWxlYXNlKCl9IHdoZW4gdGhlIGd1YXJhbnRlZXMgcHJvdmlkZWQgYnkgdGhlIG1hcmtlZFxyXG5cdCAqIHJhbmdlIGFyZSBubyBsb25nZXIgbmVjZXNzYXJ5LiBXaGVuIGNhbGxzIHRvXHJcblx0ICogYG1hcmsoKWAvYHJlbGVhc2UoKWAgYXJlIG5lc3RlZCwgdGhlIG1hcmtzIG11c3QgYmUgcmVsZWFzZWRcclxuXHQgKiBpbiByZXZlcnNlIG9yZGVyIG9mIHdoaWNoIHRoZXkgd2VyZSBvYnRhaW5lZC4gU2luY2UgbWFya2VkIHJlZ2lvbnMgYXJlXHJcblx0ICogdXNlZCBkdXJpbmcgcGVyZm9ybWFuY2UtY3JpdGljYWwgc2VjdGlvbnMgb2YgcHJlZGljdGlvbiwgdGhlIHNwZWNpZmljXHJcblx0ICogYmVoYXZpb3Igb2YgaW52YWxpZCB1c2FnZSBpcyB1bnNwZWNpZmllZCAoaS5lLiBhIG1hcmsgaXMgbm90IHJlbGVhc2VkLCBvclxyXG5cdCAqIGEgbWFyayBpcyByZWxlYXNlZCB0d2ljZSwgb3IgbWFya3MgYXJlIG5vdCByZWxlYXNlZCBpbiByZXZlcnNlIG9yZGVyIGZyb21cclxuXHQgKiB3aGljaCB0aGV5IHdlcmUgY3JlYXRlZCkuXHJcblx0ICpcclxuXHQgKiBUaGUgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgdW5zcGVjaWZpZWQgaWYgbm8gY2FsbCB0byBhblxyXG5cdCAqIHtAbGluayBJbnRTdHJlYW0gaW5pdGlhbGl6aW5nIG1ldGhvZH0gaGFzIG9jY3VycmVkIGFmdGVyIHRoaXMgc3RyZWFtIHdhc1xyXG5cdCAqIGNvbnN0cnVjdGVkLlxyXG5cdCAqXHJcblx0ICogVGhpcyBtZXRob2QgZG9lcyBub3QgY2hhbmdlIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBpbnB1dCBzdHJlYW0uXHJcblx0ICpcclxuXHQgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgdGhlIHVzZSBvZiB7QGxpbmsgI21hcmsgbWFyaygpfSxcclxuXHQgKiB7QGxpbmsgI3JlbGVhc2UgcmVsZWFzZShtYXJrKX0sIGBpbmRleGAsIGFuZFxyXG5cdCAqIHtAbGluayAjc2VlayBzZWVrKGluZGV4KX0gYXMgcGFydCBvZiBhbiBvcGVyYXRpb24gdG8gc2FmZWx5IHdvcmsgd2l0aGluIGFcclxuXHQgKiBtYXJrZWQgcmVnaW9uLCB0aGVuIHJlc3RvcmUgdGhlIHN0cmVhbSBwb3NpdGlvbiB0byBpdHMgb3JpZ2luYWwgdmFsdWUgYW5kXHJcblx0ICogcmVsZWFzZSB0aGUgbWFyay5cclxuXHQgKlxyXG5cdCAqIGBgYFxyXG5cdCAqIEludFN0cmVhbSBzdHJlYW0gPSAuLi47XHJcblx0ICogaW50IGluZGV4ID0gLTE7XHJcblx0ICogaW50IG1hcmsgPSBzdHJlYW0ubWFyaygpO1xyXG5cdCAqIHRyeSB7XHJcblx0ICogICBpbmRleCA9IHN0cmVhbS5pbmRleDtcclxuXHQgKiAgIC8vIHBlcmZvcm0gd29yayBoZXJlLi4uXHJcblx0ICogfSBmaW5hbGx5IHtcclxuXHQgKiAgIGlmIChpbmRleCAhPSAtMSkge1xyXG5cdCAqICAgICBzdHJlYW0uc2VlayhpbmRleCk7XHJcblx0ICogICB9XHJcblx0ICogICBzdHJlYW0ucmVsZWFzZShtYXJrKTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBBbiBvcGFxdWUgbWFya2VyIHdoaWNoIHNob3VsZCBiZSBwYXNzZWQgdG9cclxuXHQgKiB7QGxpbmsgI3JlbGVhc2UgcmVsZWFzZSgpfSB3aGVuIHRoZSBtYXJrZWQgcmFuZ2UgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkLlxyXG5cdCAqL1xyXG5cdG1hcmsoKTogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCByZWxlYXNlcyBhIG1hcmtlZCByYW5nZSBjcmVhdGVkIGJ5IGEgY2FsbCB0b1xyXG5cdCAqIHtAbGluayAjbWFyayBtYXJrKCl9LiBDYWxscyB0byBgcmVsZWFzZSgpYCBtdXN0IGFwcGVhciBpbiB0aGVcclxuXHQgKiByZXZlcnNlIG9yZGVyIG9mIHRoZSBjb3JyZXNwb25kaW5nIGNhbGxzIHRvIGBtYXJrKClgLiBJZiBhIG1hcmsgaXNcclxuXHQgKiByZWxlYXNlZCB0d2ljZSwgb3IgaWYgbWFya3MgYXJlIG5vdCByZWxlYXNlZCBpbiByZXZlcnNlIG9yZGVyIG9mIHRoZVxyXG5cdCAqIGNvcnJlc3BvbmRpbmcgY2FsbHMgdG8gYG1hcmsoKWAsIHRoZSBiZWhhdmlvciBpcyB1bnNwZWNpZmllZC5cclxuXHQgKlxyXG5cdCAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBhbiBleGFtcGxlLCBzZWUge0BsaW5rICNtYXJrfS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBtYXJrZXIgQSBtYXJrZXIgcmV0dXJuZWQgYnkgYSBjYWxsIHRvIGBtYXJrKClgLlxyXG5cdCAqIEBzZWUgI21hcmtcclxuXHQgKi9cclxuXHRyZWxlYXNlKG1hcmtlcjogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIHRoZSBpbmRleCBpbnRvIHRoZSBzdHJlYW0gb2YgdGhlIGlucHV0IHN5bWJvbCByZWZlcnJlZCB0byBieVxyXG5cdCAqIGBMQSgxKWAuXHJcblx0ICpcclxuXHQgKiBUaGUgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgdW5zcGVjaWZpZWQgaWYgbm8gY2FsbCB0byBhblxyXG5cdCAqIHtAbGluayBJbnRTdHJlYW0gaW5pdGlhbGl6aW5nIG1ldGhvZH0gaGFzIG9jY3VycmVkIGFmdGVyIHRoaXMgc3RyZWFtIHdhc1xyXG5cdCAqIGNvbnN0cnVjdGVkLlxyXG5cdCAqL1xyXG5cdHJlYWRvbmx5IGluZGV4OiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgaW5wdXQgY3Vyc29yIHRvIHRoZSBwb3NpdGlvbiBpbmRpY2F0ZWQgYnkgYGluZGV4YC4gSWYgdGhlXHJcblx0ICogc3BlY2lmaWVkIGluZGV4IGxpZXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJlYW0sIHRoZSBvcGVyYXRpb24gYmVoYXZlcyBhc1xyXG5cdCAqIHRob3VnaCBgaW5kZXhgIHdhcyB0aGUgaW5kZXggb2YgdGhlIEVPRiBzeW1ib2wuIEFmdGVyIHRoaXMgbWV0aG9kXHJcblx0ICogcmV0dXJucyB3aXRob3V0IHRocm93aW5nIGFuIGV4Y2VwdGlvbiwgdGhlbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZ1xyXG5cdCAqIHdpbGwgYmUgdHJ1ZS5cclxuXHQgKlxyXG5cdCAqICogYGluZGV4YCB3aWxsIHJldHVybiB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN5bWJvbFxyXG5cdCAqICAgYXBwZWFyaW5nIGF0IG9yIGFmdGVyIHRoZSBzcGVjaWZpZWQgYGluZGV4YC4gU3BlY2lmaWNhbGx5LFxyXG5cdCAqICAgaW1wbGVtZW50YXRpb25zIHdoaWNoIGZpbHRlciB0aGVpciBzb3VyY2VzIHNob3VsZCBhdXRvbWF0aWNhbGx5XHJcblx0ICogICBhZGp1c3QgYGluZGV4YCBmb3J3YXJkIHRoZSBtaW5pbXVtIGFtb3VudCByZXF1aXJlZCBmb3IgdGhlXHJcblx0ICogICBvcGVyYXRpb24gdG8gdGFyZ2V0IGEgbm9uLWlnbm9yZWQgc3ltYm9sLlxyXG5cdCAqICogYExBKDEpYCByZXR1cm5zIHtAbGluayAjRU9GfVxyXG5cdCAqXHJcblx0ICogVGhpcyBvcGVyYXRpb24gaXMgZ3VhcmFudGVlZCB0byBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGBpbmRleGBcclxuXHQgKiBsaWVzIHdpdGhpbiBhIG1hcmtlZCByZWdpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIG1hcmtlZCByZWdpb25zLCBzZWVcclxuXHQgKiB7QGxpbmsgI21hcmt9LiBUaGUgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgdW5zcGVjaWZpZWQgaWYgbm8gY2FsbCB0b1xyXG5cdCAqIGFuIHtAbGluayBJbnRTdHJlYW0gaW5pdGlhbGl6aW5nIG1ldGhvZH0gaGFzIG9jY3VycmVkIGFmdGVyIHRoaXMgc3RyZWFtXHJcblx0ICogd2FzIGNvbnN0cnVjdGVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGluZGV4IFRoZSBhYnNvbHV0ZSBpbmRleCB0byBzZWVrIHRvLlxyXG5cdCAqXHJcblx0ICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYGluZGV4YCBpcyBsZXNzIHRoYW4gMFxyXG5cdCAqIEB0aHJvd3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gaWYgdGhlIHN0cmVhbSBkb2VzIG5vdCBzdXBwb3J0XHJcblx0ICogc2Vla2luZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4XHJcblx0ICovXHJcblx0c2VlayhpbmRleDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIHN5bWJvbHMgaW4gdGhlIHN0cmVhbSwgaW5jbHVkaW5nIGEgc2luZ2xlIEVPRlxyXG5cdCAqIHN5bWJvbC5cclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gaWYgdGhlIHNpemUgb2YgdGhlIHN0cmVhbSBpc1xyXG5cdCAqIHVua25vd24uXHJcblx0ICovXHJcblx0cmVhZG9ubHkgc2l6ZTogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSB1bmRlcmx5aW5nIHN5bWJvbCBzb3VyY2UuIFRoaXMgbWV0aG9kIHJldHVybnMgYVxyXG5cdCAqIG5vbi11bmRlZmluZWQsIG5vbi1lbXB0eSBzdHJpbmcuIElmIHN1Y2ggYSBuYW1lIGlzIG5vdCBrbm93biwgdGhpcyBtZXRob2RcclxuXHQgKiByZXR1cm5zIHtAbGluayAjVU5LTk9XTl9TT1VSQ0VfTkFNRX0uXHJcblx0ICovXHJcblx0Ly9ATm90TnVsbFxyXG5cdHJlYWRvbmx5IHNvdXJjZU5hbWU6IHN0cmluZztcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0OS4wODI4NzQ4LTA3OjAwXHJcblxyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5pbXBvcnQgeyBDaGFyU3RyZWFtIH0gZnJvbSBcIi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBBcnJheXMgfSBmcm9tIFwiLi9taXNjL0FycmF5c1wiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgSW50U3RyZWFtIH0gZnJvbSBcIi4vSW50U3RyZWFtXCI7XHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5cclxuY29uc3QgUkVBRF9CVUZGRVJfU0laRTogbnVtYmVyID0gMTAyNDtcclxuY29uc3QgSU5JVElBTF9CVUZGRVJfU0laRTogbnVtYmVyID0gMTAyNDtcclxuXHJcbi8qKlxyXG4gKiBWYWN1dW0gYWxsIGlucHV0IGZyb20gYSB7QGxpbmsgUmVhZGVyfS97QGxpbmsgSW5wdXRTdHJlYW19IGFuZCB0aGVuIHRyZWF0IGl0XHJcbiAqIGxpa2UgYSBgY2hhcltdYCBidWZmZXIuIENhbiBhbHNvIHBhc3MgaW4gYSB7QGxpbmsgU3RyaW5nfSBvclxyXG4gKiBgY2hhcltdYCB0byB1c2UuXHJcbiAqXHJcbiAqIElmIHlvdSBuZWVkIGVuY29kaW5nLCBwYXNzIGluIHN0cmVhbS9yZWFkZXIgd2l0aCBjb3JyZWN0IGVuY29kaW5nLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBhcyBvZiA0LjcsIHBsZWFzZSB1c2UgYENoYXJTdHJlYW1zYCBpbnRlcmZhY2UuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQU5UTFJJbnB1dFN0cmVhbSBpbXBsZW1lbnRzIENoYXJTdHJlYW0ge1xyXG5cdC8qKiBUaGUgZGF0YSBiZWluZyBzY2FubmVkICovXHJcblx0cHJvdGVjdGVkIGRhdGE6IHN0cmluZztcclxuXHJcblx0LyoqIEhvdyBtYW55IGNoYXJhY3RlcnMgYXJlIGFjdHVhbGx5IGluIHRoZSBidWZmZXIgKi9cclxuXHRwcm90ZWN0ZWQgbjogbnVtYmVyO1xyXG5cclxuXHQvKiogMC4ubi0xIGluZGV4IGludG8gc3RyaW5nIG9mIG5leHQgY2hhciAqL1xyXG5cdHByb3RlY3RlZCBwOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKiogV2hhdCBpcyBuYW1lIG9yIHNvdXJjZSBvZiB0aGlzIGNoYXIgc3RyZWFtPyAqL1xyXG5cdHB1YmxpYyBuYW1lPzogc3RyaW5nO1xyXG5cclxuXHQvKiogQ29weSBkYXRhIGluIHN0cmluZyB0byBhIGxvY2FsIGNoYXIgYXJyYXkgKi9cclxuXHRjb25zdHJ1Y3RvcihpbnB1dDogc3RyaW5nKSB7XHJcblx0XHR0aGlzLmRhdGEgPSBpbnB1dDtcclxuXHRcdHRoaXMubiA9IGlucHV0Lmxlbmd0aDtcclxuXHR9XHJcblxyXG5cdC8qKiBSZXNldCB0aGUgc3RyZWFtIHNvIHRoYXQgaXQncyBpbiB0aGUgc2FtZSBzdGF0ZSBpdCB3YXNcclxuXHQgKiAgd2hlbiB0aGUgb2JqZWN0IHdhcyBjcmVhdGVkICpleGNlcHQqIHRoZSBkYXRhIGFycmF5IGlzIG5vdFxyXG5cdCAqICB0b3VjaGVkLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuXHRcdHRoaXMucCA9IDA7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgY29uc3VtZSgpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLnAgPj0gdGhpcy5uKSB7XHJcblx0XHRcdGFzc2VydCh0aGlzLkxBKDEpID09PSBJbnRTdHJlYW0uRU9GKTtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnN1bWUgRU9GXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vU3lzdGVtLm91dC5wcmludGxuKFwicHJldiBwPVwiK3ArXCIsIGM9XCIrKGNoYXIpZGF0YVtwXSk7XHJcblx0XHRpZiAodGhpcy5wIDwgdGhpcy5uKSB7XHJcblx0XHRcdHRoaXMucCsrO1xyXG5cdFx0XHQvL1N5c3RlbS5vdXQucHJpbnRsbihcInAgbW92ZXMgdG8gXCIrcCtcIiAoYz0nXCIrKGNoYXIpZGF0YVtwXStcIicpXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIExBKGk6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRpZiAoaSA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gMDsgLy8gdW5kZWZpbmVkXHJcblx0XHR9XHJcblx0XHRpZiAoaSA8IDApIHtcclxuXHRcdFx0aSsrOyAvLyBlLmcuLCB0cmFuc2xhdGUgTEEoLTEpIHRvIHVzZSBvZmZzZXQgaT0wOyB0aGVuIGRhdGFbcCswLTFdXHJcblx0XHRcdGlmICgodGhpcy5wICsgaSAtIDEpIDwgMCkge1xyXG5cdFx0XHRcdHJldHVybiBJbnRTdHJlYW0uRU9GOyAvLyBpbnZhbGlkOyBubyBjaGFyIGJlZm9yZSBmaXJzdCBjaGFyXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoKHRoaXMucCArIGkgLSAxKSA+PSB0aGlzLm4pIHtcclxuXHRcdFx0Ly9TeXN0ZW0ub3V0LnByaW50bG4oXCJjaGFyIExBKFwiK2krXCIpPUVPRjsgcD1cIitwKTtcclxuXHRcdFx0cmV0dXJuIEludFN0cmVhbS5FT0Y7XHJcblx0XHR9XHJcblx0XHQvL1N5c3RlbS5vdXQucHJpbnRsbihcImNoYXIgTEEoXCIraStcIik9XCIrKGNoYXIpZGF0YVtwK2ktMV0rXCI7IHA9XCIrcCk7XHJcblx0XHQvL1N5c3RlbS5vdXQucHJpbnRsbihcIkxBKFwiK2krXCIpOyBwPVwiK3ArXCIgbj1cIituK1wiIGRhdGEubGVuZ3RoPVwiK2RhdGEubGVuZ3RoKTtcclxuXHRcdHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnAgKyBpIC0gMSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgTFQoaTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLkxBKGkpO1xyXG5cdH1cclxuXHJcblx0LyoqIFJldHVybiB0aGUgY3VycmVudCBpbnB1dCBzeW1ib2wgaW5kZXggMC4ubiB3aGVyZSBuIGluZGljYXRlcyB0aGVcclxuXHQgKiAgbGFzdCBzeW1ib2wgaGFzIGJlZW4gcmVhZC4gIFRoZSBpbmRleCBpcyB0aGUgaW5kZXggb2YgY2hhciB0b1xyXG5cdCAqICBiZSByZXR1cm5lZCBmcm9tIExBKDEpLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpbmRleCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMucDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzaXplKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5uO1xyXG5cdH1cclxuXHJcblx0LyoqIG1hcmsvcmVsZWFzZSBkbyBub3RoaW5nOyB3ZSBoYXZlIGVudGlyZSBidWZmZXIgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgbWFyaygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlbGVhc2UobWFya2VyOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdC8vIE5vIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2luY2UgdGhpcyBzdHJlYW0gYnVmZmVycyB0aGUgZW50aXJlIGlucHV0XHJcblx0fVxyXG5cclxuXHQvKiogY29uc3VtZSgpIGFoZWFkIHVudGlsIHA9PWluZGV4OyBjYW4ndCBqdXN0IHNldCBwPWluZGV4IGFzIHdlIG11c3RcclxuXHQgKiAgdXBkYXRlIGxpbmUgYW5kIGNoYXJQb3NpdGlvbkluTGluZS4gSWYgd2Ugc2VlayBiYWNrd2FyZHMsIGp1c3Qgc2V0IHBcclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgc2VlayhpbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAoaW5kZXggPD0gdGhpcy5wKSB7XHJcblx0XHRcdHRoaXMucCA9IGluZGV4OyAvLyBqdXN0IGp1bXA7IGRvbid0IHVwZGF0ZSBzdHJlYW0gc3RhdGUgKGxpbmUsIC4uLilcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0Ly8gc2VlayBmb3J3YXJkLCBjb25zdW1lIHVudGlsIHAgaGl0cyBpbmRleCBvciBuICh3aGljaGV2ZXIgY29tZXMgZmlyc3QpXHJcblx0XHRpbmRleCA9IE1hdGgubWluKGluZGV4LCB0aGlzLm4pO1xyXG5cdFx0d2hpbGUgKHRoaXMucCA8IGluZGV4KSB7XHJcblx0XHRcdHRoaXMuY29uc3VtZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGdldFRleHQoaW50ZXJ2YWw6IEludGVydmFsKTogc3RyaW5nIHtcclxuXHRcdGxldCBzdGFydDogbnVtYmVyID0gaW50ZXJ2YWwuYTtcclxuXHRcdGxldCBzdG9wOiBudW1iZXIgPSBpbnRlcnZhbC5iO1xyXG5cdFx0aWYgKHN0b3AgPj0gdGhpcy5uKSB7XHJcblx0XHRcdHN0b3AgPSB0aGlzLm4gLSAxO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGNvdW50OiBudW1iZXIgPSBzdG9wIC0gc3RhcnQgKyAxO1xyXG5cdFx0aWYgKHN0YXJ0ID49IHRoaXMubikge1xyXG5cdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdH1cclxuXHRcdC8vIFN5c3RlbS5lcnIucHJpbnRsbihcImRhdGE6IFwiK0FycmF5cy50b1N0cmluZyhkYXRhKStcIiwgbj1cIituK1xyXG5cdFx0Ly8gXHRcdFx0XHQgICBcIiwgc3RhcnQ9XCIrc3RhcnQrXHJcblx0XHQvLyBcdFx0XHRcdCAgIFwiLCBzdG9wPVwiK3N0b3ApO1xyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5zdWJzdHIoc3RhcnQsIGNvdW50KTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzb3VyY2VOYW1lKCk6IHN0cmluZyB7XHJcblx0XHRpZiAoIXRoaXMubmFtZSkge1xyXG5cdFx0XHRyZXR1cm4gSW50U3RyZWFtLlVOS05PV05fU09VUkNFX05BTUU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5uYW1lO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5kYXRhOyB9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI3LjQ3MzQzMjgtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZVR5cGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVR5cGVcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWxTZXQgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFNldFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tIFwiLi9UcmFuc2l0aW9uXCI7XHJcblxyXG5jb25zdCBJTklUSUFMX05VTV9UUkFOU0lUSU9OUzogbnVtYmVyID0gNDtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZm9sbG93aW5nIGltYWdlcyBzaG93IHRoZSByZWxhdGlvbiBvZiBzdGF0ZXMgYW5kXHJcbiAqIHtAbGluayBBVE5TdGF0ZSN0cmFuc2l0aW9uc30gZm9yIHZhcmlvdXMgZ3JhbW1hciBjb25zdHJ1Y3RzLlxyXG4gKlxyXG4gKiAqIFNvbGlkIGVkZ2VzIG1hcmtlZCB3aXRoIGFuICYjMDk0OTsgaW5kaWNhdGUgYSByZXF1aXJlZFxyXG4gKiAgIHtAbGluayBFcHNpbG9uVHJhbnNpdGlvbn0uXHJcbiAqXHJcbiAqICogRGFzaGVkIGVkZ2VzIGluZGljYXRlIGxvY2F0aW9ucyB3aGVyZSBhbnkgdHJhbnNpdGlvbiBkZXJpdmVkIGZyb21cclxuICogICB7QGxpbmsgVHJhbnNpdGlvbn0gbWlnaHQgYXBwZWFyLlxyXG4gKlxyXG4gKiAqIERhc2hlZCBub2RlcyBhcmUgcGxhY2UgaG9sZGVycyBmb3IgZWl0aGVyIGEgc2VxdWVuY2Ugb2YgbGlua2VkXHJcbiAqICAge0BsaW5rIEJhc2ljU3RhdGV9IHN0YXRlcyBvciB0aGUgaW5jbHVzaW9uIG9mIGEgYmxvY2sgcmVwcmVzZW50aW5nIGEgbmVzdGVkXHJcbiAqICAgY29uc3RydWN0IGluIG9uZSBvZiB0aGUgZm9ybXMgYmVsb3cuXHJcbiAqXHJcbiAqICogTm9kZXMgc2hvd2luZyBtdWx0aXBsZSBvdXRnb2luZyBhbHRlcm5hdGl2ZXMgd2l0aCBhIGAuLi5gIHN1cHBvcnRcclxuICogICBhbnkgbnVtYmVyIG9mIGFsdGVybmF0aXZlcyAob25lIG9yIG1vcmUpLiBOb2RlcyB3aXRob3V0IHRoZSBgLi4uYCBvbmx5XHJcbiAqICAgc3VwcG9ydCB0aGUgZXhhY3QgbnVtYmVyIG9mIGFsdGVybmF0aXZlcyBzaG93biBpbiB0aGUgZGlhZ3JhbS5cclxuICpcclxuICogPGgyPkJhc2ljIEJsb2NrczwvaDI+XHJcbiAqXHJcbiAqIDxoMz5SdWxlPC9oMz5cclxuICpcclxuICogPGVtYmVkIHNyYz1cImltYWdlcy9SdWxlLnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxyXG4gKlxyXG4gKiA8aDM+QmxvY2sgb2YgMSBvciBtb3JlIGFsdGVybmF0aXZlczwvaDM+XHJcbiAqXHJcbiAqIDxlbWJlZCBzcmM9XCJpbWFnZXMvQmxvY2suc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+XHJcbiAqXHJcbiAqIDxoMj5HcmVlZHkgTG9vcHM8L2gyPlxyXG4gKlxyXG4gKiA8aDM+R3JlZWR5IENsb3N1cmU6IGAoLi4uKSpgPC9oMz5cclxuICpcclxuICogPGVtYmVkIHNyYz1cImltYWdlcy9DbG9zdXJlR3JlZWR5LnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxyXG4gKlxyXG4gKiA8aDM+R3JlZWR5IFBvc2l0aXZlIENsb3N1cmU6IGAoLi4uKStgPC9oMz5cclxuICpcclxuICogPGVtYmVkIHNyYz1cImltYWdlcy9Qb3NpdGl2ZUNsb3N1cmVHcmVlZHkuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+XHJcbiAqXHJcbiAqIDxoMz5HcmVlZHkgT3B0aW9uYWw6IGAoLi4uKT9gPC9oMz5cclxuICpcclxuICogPGVtYmVkIHNyYz1cImltYWdlcy9PcHRpb25hbEdyZWVkeS5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz5cclxuICpcclxuICogPGgyPk5vbi1HcmVlZHkgTG9vcHM8L2gyPlxyXG4gKlxyXG4gKiA8aDM+Tm9uLUdyZWVkeSBDbG9zdXJlOiBgKC4uLikqP2A8L2gzPlxyXG4gKlxyXG4gKiA8ZW1iZWQgc3JjPVwiaW1hZ2VzL0Nsb3N1cmVOb25HcmVlZHkuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+XHJcbiAqXHJcbiAqIDxoMz5Ob24tR3JlZWR5IFBvc2l0aXZlIENsb3N1cmU6IGAoLi4uKSs/YDwvaDM+XHJcbiAqXHJcbiAqIDxlbWJlZCBzcmM9XCJpbWFnZXMvUG9zaXRpdmVDbG9zdXJlTm9uR3JlZWR5LnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxyXG4gKlxyXG4gKiA8aDM+Tm9uLUdyZWVkeSBPcHRpb25hbDogYCguLi4pPz9gPC9oMz5cclxuICpcclxuICogPGVtYmVkIHNyYz1cImltYWdlcy9PcHRpb25hbE5vbkdyZWVkeS5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBVE5TdGF0ZSB7XHJcblxyXG5cdC8qKiBXaGljaCBBVE4gYXJlIHdlIGluPyAqL1xyXG5cdHB1YmxpYyBhdG4/OiBBVE47XHJcblxyXG5cdHB1YmxpYyBzdGF0ZU51bWJlcjogbnVtYmVyID0gQVROU3RhdGUuSU5WQUxJRF9TVEFURV9OVU1CRVI7XHJcblxyXG5cdHB1YmxpYyBydWxlSW5kZXg6IG51bWJlciA9IDA7ICAvLyBhdCBydW50aW1lLCB3ZSBkb24ndCBoYXZlIFJ1bGUgb2JqZWN0c1xyXG5cclxuXHRwdWJsaWMgZXBzaWxvbk9ubHlUcmFuc2l0aW9uczogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHQvKiogVHJhY2sgdGhlIHRyYW5zaXRpb25zIGVtYW5hdGluZyBmcm9tIHRoaXMgQVROIHN0YXRlLiAqL1xyXG5cdHByb3RlY3RlZCB0cmFuc2l0aW9uczogVHJhbnNpdGlvbltdID0gW107XHJcblxyXG5cdHByb3RlY3RlZCBvcHRpbWl6ZWRUcmFuc2l0aW9uczogVHJhbnNpdGlvbltdID0gdGhpcy50cmFuc2l0aW9ucztcclxuXHJcblx0LyoqIFVzZWQgdG8gY2FjaGUgbG9va2FoZWFkIGR1cmluZyBwYXJzaW5nLCBub3QgdXNlZCBkdXJpbmcgY29uc3RydWN0aW9uICovXHJcblx0cHVibGljIG5leHRUb2tlbldpdGhpblJ1bGU/OiBJbnRlcnZhbFNldDtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgc3RhdGUgbnVtYmVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgdGhlIHN0YXRlIG51bWJlclxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRTdGF0ZU51bWJlcigpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhdGVOdW1iZXI7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBGb3IgYWxsIHN0YXRlcyBleGNlcHQge0BsaW5rIFJ1bGVTdG9wU3RhdGV9LCB0aGlzIHJldHVybnMgdGhlIHN0YXRlXHJcblx0ICogbnVtYmVyLiBSZXR1cm5zIC0xIGZvciBzdG9wIHN0YXRlcy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIC0xIGZvciB7QGxpbmsgUnVsZVN0b3BTdGF0ZX0sIG90aGVyd2lzZSB0aGUgc3RhdGUgbnVtYmVyXHJcblx0ICovXHJcblx0Z2V0IG5vblN0b3BTdGF0ZU51bWJlcigpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3RhdGVOdW1iZXIoKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhdGVOdW1iZXI7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG86IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0Ly8gYXJlIHRoZXNlIHN0YXRlcyBzYW1lIG9iamVjdD9cclxuXHRcdGlmIChvIGluc3RhbmNlb2YgQVROU3RhdGUpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVOdW1iZXIgPT09IG8uc3RhdGVOdW1iZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Z2V0IGlzTm9uR3JlZWR5RXhpdFN0YXRlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gU3RyaW5nKHRoaXMuc3RhdGVOdW1iZXIpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldFRyYW5zaXRpb25zKCk6IFRyYW5zaXRpb25bXSB7XHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5zbGljZSgwKTtcclxuXHR9XHJcblxyXG5cdGdldCBudW1iZXJPZlRyYW5zaXRpb25zKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5sZW5ndGg7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWRkVHJhbnNpdGlvbihlOiBUcmFuc2l0aW9uLCBpbmRleD86IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMudHJhbnNpdGlvbnMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHRoaXMuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyA9IGUuaXNFcHNpbG9uO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAodGhpcy5lcHNpbG9uT25seVRyYW5zaXRpb25zICE9PSBlLmlzRXBzaWxvbikge1xyXG5cdFx0XHR0aGlzLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgPSBmYWxzZTtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQVROIHN0YXRlIFwiICsgdGhpcy5zdGF0ZU51bWJlciArIFwiIGhhcyBib3RoIGVwc2lsb24gYW5kIG5vbi1lcHNpbG9uIHRyYW5zaXRpb25zLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnRyYW5zaXRpb25zLnNwbGljZShpbmRleCAhPT0gdW5kZWZpbmVkID8gaW5kZXggOiB0aGlzLnRyYW5zaXRpb25zLmxlbmd0aCwgMCwgZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdHJhbnNpdGlvbihpOiBudW1iZXIpOiBUcmFuc2l0aW9uIHtcclxuXHRcdHJldHVybiB0aGlzLnRyYW5zaXRpb25zW2ldO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldFRyYW5zaXRpb24oaTogbnVtYmVyLCBlOiBUcmFuc2l0aW9uKTogdm9pZCB7XHJcblx0XHR0aGlzLnRyYW5zaXRpb25zW2ldID0gZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyByZW1vdmVUcmFuc2l0aW9uKGluZGV4OiBudW1iZXIpOiBUcmFuc2l0aW9uIHtcclxuXHRcdHJldHVybiB0aGlzLnRyYW5zaXRpb25zLnNwbGljZShpbmRleCwgMSlbMF07XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgc3RhdGVUeXBlOiBBVE5TdGF0ZVR5cGU7XHJcblxyXG5cdGdldCBvbmx5SGFzRXBzaWxvblRyYW5zaXRpb25zKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXRSdWxlSW5kZXgocnVsZUluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4O1xyXG5cdH1cclxuXHJcblx0Z2V0IGlzT3B0aW1pemVkKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW1pemVkVHJhbnNpdGlvbnMgIT09IHRoaXMudHJhbnNpdGlvbnM7XHJcblx0fVxyXG5cclxuXHRnZXQgbnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW1pemVkVHJhbnNpdGlvbnMubGVuZ3RoO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldE9wdGltaXplZFRyYW5zaXRpb24oaTogbnVtYmVyKTogVHJhbnNpdGlvbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpbWl6ZWRUcmFuc2l0aW9uc1tpXTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhZGRPcHRpbWl6ZWRUcmFuc2l0aW9uKGU6IFRyYW5zaXRpb24pOiB2b2lkIHtcclxuXHRcdGlmICghdGhpcy5pc09wdGltaXplZCkge1xyXG5cdFx0XHR0aGlzLm9wdGltaXplZFRyYW5zaXRpb25zID0gbmV3IEFycmF5PFRyYW5zaXRpb24+KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKGUpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldE9wdGltaXplZFRyYW5zaXRpb24oaTogbnVtYmVyLCBlOiBUcmFuc2l0aW9uKTogdm9pZCB7XHJcblx0XHRpZiAoIXRoaXMuaXNPcHRpbWl6ZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhpcyBBVE5TdGF0ZSBpcyBub3Qgb3B0aW1pemVkLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGltaXplZFRyYW5zaXRpb25zW2ldID0gZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyByZW1vdmVPcHRpbWl6ZWRUcmFuc2l0aW9uKGk6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKCF0aGlzLmlzT3B0aW1pemVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRoaXMgQVROU3RhdGUgaXMgbm90IG9wdGltaXplZC5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpbWl6ZWRUcmFuc2l0aW9ucy5zcGxpY2UoaSwgMSk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIEFUTlN0YXRlIHtcclxuXHRleHBvcnQgY29uc3QgSU5WQUxJRF9TVEFURV9OVU1CRVI6IG51bWJlciA9IC0xO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyNy40NzM0MzI4LTA3OjAwXHJcblxyXG5leHBvcnQgZW51bSBBVE5TdGF0ZVR5cGUge1xyXG5cdElOVkFMSURfVFlQRSA9IDAsXHJcblx0QkFTSUMgPSAxLFxyXG5cdFJVTEVfU1RBUlQgPSAyLFxyXG5cdEJMT0NLX1NUQVJUID0gMyxcclxuXHRQTFVTX0JMT0NLX1NUQVJUID0gNCxcclxuXHRTVEFSX0JMT0NLX1NUQVJUID0gNSxcclxuXHRUT0tFTl9TVEFSVCA9IDYsXHJcblx0UlVMRV9TVE9QID0gNyxcclxuXHRCTE9DS19FTkQgPSA4LFxyXG5cdFNUQVJfTE9PUF9CQUNLID0gOSxcclxuXHRTVEFSX0xPT1BfRU5UUlkgPSAxMCxcclxuXHRQTFVTX0xPT1BfQkFDSyA9IDExLFxyXG5cdExPT1BfRU5EID0gMTIsXHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU3LjA2OTc2NzQtMDc6MDBcclxuaW1wb3J0IHsgQ2hhclN0cmVhbSB9IGZyb20gXCIuL0NoYXJTdHJlYW1cIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWxTZXQgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsU2V0XCI7XHJcbmltcG9ydCB7IEludFN0cmVhbSB9IGZyb20gXCIuL0ludFN0cmVhbVwiO1xyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuL0xleGVyXCI7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuL1BhcnNlclJ1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblwiO1xyXG5cclxuXHJcbi8qKiBUaGUgcm9vdCBvZiB0aGUgQU5UTFIgZXhjZXB0aW9uIGhpZXJhcmNoeS4gSW4gZ2VuZXJhbCwgQU5UTFIgdHJhY2tzIGp1c3RcclxuICogIDMga2luZHMgb2YgZXJyb3JzOiBwcmVkaWN0aW9uIGVycm9ycywgZmFpbGVkIHByZWRpY2F0ZSBlcnJvcnMsIGFuZFxyXG4gKiAgbWlzbWF0Y2hlZCBpbnB1dCBlcnJvcnMuIEluIGVhY2ggY2FzZSwgdGhlIHBhcnNlciBrbm93cyB3aGVyZSBpdCBpc1xyXG4gKiAgaW4gdGhlIGlucHV0LCB3aGVyZSBpdCBpcyBpbiB0aGUgQVROLCB0aGUgcnVsZSBpbnZvY2F0aW9uIHN0YWNrLFxyXG4gKiAgYW5kIHdoYXQga2luZCBvZiBwcm9ibGVtIG9jY3VycmVkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJlY29nbml0aW9uRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xyXG5cdC8vIHByaXZhdGUgc3RhdGljIHNlcmlhbFZlcnNpb25VSUQ6IG51bWJlciA9ICAtMzg2MTgyNjk1NDc1MDAyMjM3NEw7XHJcblxyXG5cdC8qKiBUaGUge0BsaW5rIFJlY29nbml6ZXJ9IHdoZXJlIHRoaXMgZXhjZXB0aW9uIG9yaWdpbmF0ZWQuICovXHJcblx0cHJpdmF0ZSBfcmVjb2duaXplcj86IFJlY29nbml6ZXI8YW55LCBhbnk+O1xyXG5cclxuXHRwcml2YXRlIGN0eD86IFJ1bGVDb250ZXh0O1xyXG5cclxuXHRwcml2YXRlIGlucHV0PzogSW50U3RyZWFtO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgY3VycmVudCB7QGxpbmsgVG9rZW59IHdoZW4gYW4gZXJyb3Igb2NjdXJyZWQuIFNpbmNlIG5vdCBhbGwgc3RyZWFtc1xyXG5cdCAqIHN1cHBvcnQgYWNjZXNzaW5nIHN5bWJvbHMgYnkgaW5kZXgsIHdlIGhhdmUgdG8gdHJhY2sgdGhlIHtAbGluayBUb2tlbn1cclxuXHQgKiBpbnN0YW5jZSBpdHNlbGYuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBvZmZlbmRpbmdUb2tlbj86IFRva2VuO1xyXG5cclxuXHRwcml2YXRlIF9vZmZlbmRpbmdTdGF0ZTogbnVtYmVyID0gLTE7XHJcblxyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0bGV4ZXI6IExleGVyIHwgdW5kZWZpbmVkLFxyXG5cdFx0aW5wdXQ6IENoYXJTdHJlYW0pO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdHJlY29nbml6ZXI6IFJlY29nbml6ZXI8VG9rZW4sIGFueT4gfCB1bmRlZmluZWQsXHJcblx0XHRpbnB1dDogSW50U3RyZWFtIHwgdW5kZWZpbmVkLFxyXG5cdFx0Y3R4OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCk7XHJcblxyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0cmVjb2duaXplcjogUmVjb2duaXplcjxUb2tlbiwgYW55PiB8IHVuZGVmaW5lZCxcclxuXHRcdGlucHV0OiBJbnRTdHJlYW0gfCB1bmRlZmluZWQsXHJcblx0XHRjdHg6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLFxyXG5cdFx0bWVzc2FnZTogc3RyaW5nKTtcclxuXHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRyZWNvZ25pemVyOiBMZXhlciB8IFJlY29nbml6ZXI8VG9rZW4sIGFueT4gfCB1bmRlZmluZWQsXHJcblx0XHRpbnB1dDogQ2hhclN0cmVhbSB8IEludFN0cmVhbSB8IHVuZGVmaW5lZCxcclxuXHRcdGN0eD86IFBhcnNlclJ1bGVDb250ZXh0LFxyXG5cdFx0bWVzc2FnZT86IHN0cmluZykge1xyXG5cdFx0c3VwZXIobWVzc2FnZSk7XHJcblxyXG5cdFx0dGhpcy5fcmVjb2duaXplciA9IHJlY29nbml6ZXI7XHJcblx0XHR0aGlzLmlucHV0ID0gaW5wdXQ7XHJcblx0XHR0aGlzLmN0eCA9IGN0eDtcclxuXHRcdGlmIChyZWNvZ25pemVyKSB7XHJcblx0XHRcdHRoaXMuX29mZmVuZGluZ1N0YXRlID0gcmVjb2duaXplci5zdGF0ZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgQVROIHN0YXRlIG51bWJlciB0aGUgcGFyc2VyIHdhcyBpbiBhdCB0aGUgdGltZSB0aGUgZXJyb3JcclxuXHQgKiBvY2N1cnJlZC4gRm9yIHtAbGluayBOb1ZpYWJsZUFsdEV4Y2VwdGlvbn0gYW5kXHJcblx0ICoge0BsaW5rIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb259IGV4Y2VwdGlvbnMsIHRoaXMgaXMgdGhlXHJcblx0ICoge0BsaW5rIERlY2lzaW9uU3RhdGV9IG51bWJlci4gRm9yIG90aGVycywgaXQgaXMgdGhlIHN0YXRlIHdob3NlIG91dGdvaW5nXHJcblx0ICogZWRnZSB3ZSBjb3VsZG4ndCBtYXRjaC5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSBzdGF0ZSBudW1iZXIgaXMgbm90IGtub3duLCB0aGlzIG1ldGhvZCByZXR1cm5zIC0xLlxyXG5cdCAqL1xyXG5cdGdldCBvZmZlbmRpbmdTdGF0ZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX29mZmVuZGluZ1N0YXRlO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHNldE9mZmVuZGluZ1N0YXRlKG9mZmVuZGluZ1N0YXRlOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMuX29mZmVuZGluZ1N0YXRlID0gb2ZmZW5kaW5nU3RhdGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBzZXQgb2YgaW5wdXQgc3ltYm9scyB3aGljaCBjb3VsZCBwb3RlbnRpYWxseSBmb2xsb3cgdGhlXHJcblx0ICogcHJldmlvdXNseSBtYXRjaGVkIHN5bWJvbCBhdCB0aGUgdGltZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxyXG5cdCAqXHJcblx0ICogSWYgdGhlIHNldCBvZiBleHBlY3RlZCB0b2tlbnMgaXMgbm90IGtub3duIGFuZCBjb3VsZCBub3QgYmUgY29tcHV0ZWQsXHJcblx0ICogdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBzZXQgb2YgdG9rZW4gdHlwZXMgdGhhdCBjb3VsZCBwb3RlbnRpYWxseSBmb2xsb3cgdGhlIGN1cnJlbnRcclxuXHQgKiBzdGF0ZSBpbiB0aGUgQVROLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgaW5mb3JtYXRpb24gaXMgbm90IGF2YWlsYWJsZS5cclxuXHQgKi9cclxuXHRnZXQgZXhwZWN0ZWRUb2tlbnMoKTogSW50ZXJ2YWxTZXQgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKHRoaXMuX3JlY29nbml6ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX3JlY29nbml6ZXIuYXRuLmdldEV4cGVjdGVkVG9rZW5zKHRoaXMuX29mZmVuZGluZ1N0YXRlLCB0aGlzLmN0eCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUge0BsaW5rIFJ1bGVDb250ZXh0fSBhdCB0aGUgdGltZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxyXG5cdCAqXHJcblx0ICogSWYgdGhlIGNvbnRleHQgaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSB7QGxpbmsgUnVsZUNvbnRleHR9IGF0IHRoZSB0aW1lIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24uXHJcblx0ICogSWYgdGhlIGNvbnRleHQgaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuXHQgKi9cclxuXHRnZXQgY29udGV4dCgpOiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5jdHg7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBpbnB1dCBzdHJlYW0gd2hpY2ggaXMgdGhlIHN5bWJvbCBzb3VyY2UgZm9yIHRoZSByZWNvZ25pemVyIHdoZXJlXHJcblx0ICogdGhpcyBleGNlcHRpb24gd2FzIHRocm93bi5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSBpbnB1dCBzdHJlYW0gaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBpbnB1dCBzdHJlYW0gd2hpY2ggaXMgdGhlIHN5bWJvbCBzb3VyY2UgZm9yIHRoZSByZWNvZ25pemVyXHJcblx0ICogd2hlcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHN0cmVhbSBpcyBub3RcclxuXHQgKiBhdmFpbGFibGUuXHJcblx0ICovXHJcblxyXG5cdGdldCBpbnB1dFN0cmVhbSgpOiBJbnRTdHJlYW0gfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW5wdXQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0T2ZmZW5kaW5nVG9rZW4ocmVjb2duaXplcj86IFJlY29nbml6ZXI8VG9rZW4sIGFueT4pOiBUb2tlbiB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAocmVjb2duaXplciAmJiByZWNvZ25pemVyICE9PSB0aGlzLl9yZWNvZ25pemVyKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5vZmZlbmRpbmdUb2tlbjtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBzZXRPZmZlbmRpbmdUb2tlbjxUU3ltYm9sIGV4dGVuZHMgVG9rZW4+KFxyXG5cdFx0cmVjb2duaXplcjogUmVjb2duaXplcjxUU3ltYm9sLCBhbnk+LFxyXG5cdFx0b2ZmZW5kaW5nVG9rZW4/OiBUU3ltYm9sKTogdm9pZCB7XHJcblx0XHRpZiAocmVjb2duaXplciA9PT0gdGhpcy5fcmVjb2duaXplcikge1xyXG5cdFx0XHR0aGlzLm9mZmVuZGluZ1Rva2VuID0gb2ZmZW5kaW5nVG9rZW47XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB7QGxpbmsgUmVjb2duaXplcn0gd2hlcmUgdGhpcyBleGNlcHRpb24gb2NjdXJyZWQuXHJcblx0ICpcclxuXHQgKiBJZiB0aGUgcmVjb2duaXplciBpcyBub3QgYXZhaWxhYmxlLCB0aGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIHJlY29nbml6ZXIgd2hlcmUgdGhpcyBleGNlcHRpb24gb2NjdXJyZWQsIG9yIGB1bmRlZmluZWRgIGlmXHJcblx0ICogdGhlIHJlY29nbml6ZXIgaXMgbm90IGF2YWlsYWJsZS5cclxuXHQgKi9cclxuXHRnZXQgcmVjb2duaXplcigpOiBSZWNvZ25pemVyPGFueSwgYW55PiB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcmVjb2duaXplcjtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM3Ljg1MzA0OTYtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWxTZXQgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFNldFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvblR5cGUgfSBmcm9tIFwiLi9UcmFuc2l0aW9uVHlwZVwiO1xyXG5cclxuLyoqIEFuIEFUTiB0cmFuc2l0aW9uIGJldHdlZW4gYW55IHR3byBBVE4gc3RhdGVzLiAgU3ViY2xhc3NlcyBkZWZpbmVcclxuICogIGF0b20sIHNldCwgZXBzaWxvbiwgYWN0aW9uLCBwcmVkaWNhdGUsIHJ1bGUgdHJhbnNpdGlvbnMuXHJcbiAqXHJcbiAqICBUaGlzIGlzIGEgb25lIHdheSBsaW5rLiAgSXQgZW1hbmF0ZXMgZnJvbSBhIHN0YXRlICh1c3VhbGx5IHZpYSBhIGxpc3Qgb2ZcclxuICogIHRyYW5zaXRpb25zKSBhbmQgaGFzIGEgdGFyZ2V0IHN0YXRlLlxyXG4gKlxyXG4gKiAgU2luY2Ugd2UgbmV2ZXIgaGF2ZSB0byBjaGFuZ2UgdGhlIEFUTiB0cmFuc2l0aW9ucyBvbmNlIHdlIGNvbnN0cnVjdCBpdCxcclxuICogIHdlIGNhbiBmaXggdGhlc2UgdHJhbnNpdGlvbnMgYXMgc3BlY2lmaWMgY2xhc3Nlcy4gVGhlIERGQSB0cmFuc2l0aW9uc1xyXG4gKiAgb24gdGhlIG90aGVyIGhhbmQgbmVlZCB0byB1cGRhdGUgdGhlIGxhYmVscyBhcyBpdCBhZGRzIHRyYW5zaXRpb25zIHRvXHJcbiAqICB0aGUgc3RhdGVzLiBXZSdsbCB1c2UgdGhlIHRlcm0gRWRnZSBmb3IgdGhlIERGQSB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb21cclxuICogIEFUTiB0cmFuc2l0aW9ucy5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUcmFuc2l0aW9uIHtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHNlcmlhbGl6YXRpb25OYW1lczogc3RyaW5nW10gPSBbXHJcblx0XHRcIklOVkFMSURcIixcclxuXHRcdFwiRVBTSUxPTlwiLFxyXG5cdFx0XCJSQU5HRVwiLFxyXG5cdFx0XCJSVUxFXCIsXHJcblx0XHRcIlBSRURJQ0FURVwiLFxyXG5cdFx0XCJBVE9NXCIsXHJcblx0XHRcIkFDVElPTlwiLFxyXG5cdFx0XCJTRVRcIixcclxuXHRcdFwiTk9UX1NFVFwiLFxyXG5cdFx0XCJXSUxEQ0FSRFwiLFxyXG5cdFx0XCJQUkVDRURFTkNFXCIsXHJcblx0XTtcclxuXHJcblx0Ly8gQFN1cHByZXNzV2FybmluZ3MoXCJzZXJpYWxcIilcclxuXHQvLyBzdGF0aWMgc2VyaWFsaXphdGlvblR5cGVzOiBNYXA8Q2xhc3M8PyBleHRlbmRzIFRyYW5zaXRpb24+LCBudW1iZXI+ID1cclxuXHQvLyBcdENvbGxlY3Rpb25zLnVubW9kaWZpYWJsZU1hcChuZXcgSGFzaE1hcDxDbGFzczw/IGV4dGVuZHMgVHJhbnNpdGlvbj4sIEludGVnZXI+KCkge3tcclxuXHQvLyBcdFx0cHV0KEVwc2lsb25UcmFuc2l0aW9uLmNsYXNzLCBFUFNJTE9OKTtcclxuXHQvLyBcdFx0cHV0KFJhbmdlVHJhbnNpdGlvbi5jbGFzcywgUkFOR0UpO1xyXG5cdC8vIFx0XHRwdXQoUnVsZVRyYW5zaXRpb24uY2xhc3MsIFJVTEUpO1xyXG5cdC8vIFx0XHRwdXQoUHJlZGljYXRlVHJhbnNpdGlvbi5jbGFzcywgUFJFRElDQVRFKTtcclxuXHQvLyBcdFx0cHV0KEF0b21UcmFuc2l0aW9uLmNsYXNzLCBBVE9NKTtcclxuXHQvLyBcdFx0cHV0KEFjdGlvblRyYW5zaXRpb24uY2xhc3MsIEFDVElPTik7XHJcblx0Ly8gXHRcdHB1dChTZXRUcmFuc2l0aW9uLmNsYXNzLCBTRVQpO1xyXG5cdC8vIFx0XHRwdXQoTm90U2V0VHJhbnNpdGlvbi5jbGFzcywgTk9UX1NFVCk7XHJcblx0Ly8gXHRcdHB1dChXaWxkY2FyZFRyYW5zaXRpb24uY2xhc3MsIFdJTERDQVJEKTtcclxuXHQvLyBcdFx0cHV0KFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uLmNsYXNzLCBQUkVDRURFTkNFKTtcclxuXHQvLyBcdH19KTtcclxuXHJcblx0LyoqIFRoZSB0YXJnZXQgb2YgdGhpcyB0cmFuc2l0aW9uLiAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHRhcmdldDogQVROU3RhdGU7XHJcblxyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHRhcmdldDogQVROU3RhdGUpIHtcclxuXHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgY2Fubm90IGJlIG51bGwuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHNlcmlhbGl6YXRpb25UeXBlOiBUcmFuc2l0aW9uVHlwZTtcclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgdHJhbnNpdGlvbiBpcyBhbiBcImVwc2lsb25cIiB0cmFuc2l0aW9uLlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIHRyYXZlcnNpbmcgdGhpcyB0cmFuc2l0aW9uIGluIHRoZSBBVE4gZG9lcyBub3RcclxuXHQgKiBjb25zdW1lIGFuIGlucHV0IHN5bWJvbDsgb3RoZXJ3aXNlLCBgZmFsc2VgIGlmIHRyYXZlcnNpbmcgdGhpc1xyXG5cdCAqIHRyYW5zaXRpb24gY29uc3VtZXMgKG1hdGNoZXMpIGFuIGlucHV0IHN5bWJvbC5cclxuXHQgKi9cclxuXHRnZXQgaXNFcHNpbG9uKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Z2V0IGxhYmVsKCk6IEludGVydmFsU2V0IHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgbWF0Y2hlcyhzeW1ib2w6IG51bWJlciwgbWluVm9jYWJTeW1ib2w6IG51bWJlciwgbWF4Vm9jYWJTeW1ib2w6IG51bWJlcik6IGJvb2xlYW47XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI0LjY1OTYxNzctMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCIuL1RyYW5zaXRpb25cIjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uIGV4dGVuZHMgVHJhbnNpdGlvbiB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHRhcmdldDogQVROU3RhdGUpIHtcclxuXHRcdHN1cGVyKHRhcmdldCk7XHJcblx0fVxyXG5cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDNUMDI6MDk6NDIuMTIzOTY2MC0wNzowMFxyXG5pbXBvcnQgeyBFcXVhdGFibGUgfSBmcm9tIFwiLi9TdHVic1wiO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBuYW1lc3BhY2UgTXVybXVySGFzaCB7XHJcblxyXG5cdGNvbnN0IERFRkFVTFRfU0VFRDogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgaGFzaCB1c2luZyB0aGUgc3BlY2lmaWVkIGBzZWVkYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBzZWVkIHRoZSBzZWVkIChvcHRpb25hbClcclxuXHQgKiBAcmV0dXJucyB0aGUgaW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcclxuXHQgKi9cclxuXHRleHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZShzZWVkOiBudW1iZXIgPSBERUZBVUxUX1NFRUQpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHNlZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIGludGVybWVkaWF0ZSBoYXNoIHZhbHVlIGZvciB0aGUgbmV4dCBpbnB1dCBgdmFsdWVgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGhhc2ggdGhlIGludGVybWVkaWF0ZSBoYXNoIHZhbHVlXHJcblx0ICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBhZGQgdG8gdGhlIGN1cnJlbnQgaGFzaFxyXG5cdCAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIGludGVybWVkaWF0ZSBoYXNoIHZhbHVlXHJcblx0ICovXHJcblx0ZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZShoYXNoOiBudW1iZXIsIHZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfCBFcXVhdGFibGUgfCBudWxsIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0IGMxOiBudW1iZXIgPSAweENDOUUyRDUxO1xyXG5cdFx0Y29uc3QgYzI6IG51bWJlciA9IDB4MUI4NzM1OTM7XHJcblx0XHRjb25zdCByMTogbnVtYmVyID0gMTU7XHJcblx0XHRjb25zdCByMjogbnVtYmVyID0gMTM7XHJcblx0XHRjb25zdCBtOiBudW1iZXIgPSA1O1xyXG5cdFx0Y29uc3QgbjogbnVtYmVyID0gMHhFNjU0NkI2NDtcclxuXHJcblx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xyXG5cdFx0XHR2YWx1ZSA9IDA7XHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHR2YWx1ZSA9IGhhc2hTdHJpbmcodmFsdWUpO1xyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcclxuXHRcdFx0dmFsdWUgPSB2YWx1ZS5oYXNoQ29kZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBrOiBudW1iZXIgPSB2YWx1ZTtcclxuXHRcdGsgPSBNYXRoLmltdWwoaywgYzEpO1xyXG5cdFx0ayA9IChrIDw8IHIxKSB8IChrID4+PiAoMzIgLSByMSkpO1xyXG5cdFx0ayA9IE1hdGguaW11bChrLCBjMik7XHJcblxyXG5cdFx0aGFzaCA9IGhhc2ggXiBrO1xyXG5cdFx0aGFzaCA9IChoYXNoIDw8IHIyKSB8IChoYXNoID4+PiAoMzIgLSByMikpO1xyXG5cdFx0aGFzaCA9IE1hdGguaW11bChoYXNoLCBtKSArIG47XHJcblxyXG5cdFx0cmV0dXJuIGhhc2ggJiAweEZGRkZGRkZGO1xyXG5cdH1cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEFwcGx5IHRoZSBmaW5hbCBjb21wdXRhdGlvbiBzdGVwcyB0byB0aGUgaW50ZXJtZWRpYXRlIHZhbHVlIGBoYXNoYFxyXG5cdCAqIHRvIGZvcm0gdGhlIGZpbmFsIHJlc3VsdCBvZiB0aGUgTXVybXVySGFzaCAzIGhhc2ggZnVuY3Rpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gaGFzaCB0aGUgaW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcclxuXHQgKiBAcGFyYW0gbnVtYmVyT2ZXb3JkcyB0aGUgbnVtYmVyIG9mIGludGVnZXIgdmFsdWVzIGFkZGVkIHRvIHRoZSBoYXNoXHJcblx0ICogQHJldHVybnMgdGhlIGZpbmFsIGhhc2ggcmVzdWx0XHJcblx0ICovXHJcblx0ZXhwb3J0IGZ1bmN0aW9uIGZpbmlzaChoYXNoOiBudW1iZXIsIG51bWJlck9mV29yZHM6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRoYXNoID0gaGFzaCBeIChudW1iZXJPZldvcmRzICogNCk7XHJcblx0XHRoYXNoID0gaGFzaCBeIChoYXNoID4+PiAxNik7XHJcblx0XHRoYXNoID0gTWF0aC5pbXVsKGhhc2gsIDB4ODVFQkNBNkIpO1xyXG5cdFx0aGFzaCA9IGhhc2ggXiAoaGFzaCA+Pj4gMTMpO1xyXG5cdFx0aGFzaCA9IE1hdGguaW11bChoYXNoLCAweEMyQjJBRTM1KTtcclxuXHRcdGhhc2ggPSBoYXNoIF4gKGhhc2ggPj4+IDE2KTtcclxuXHRcdHJldHVybiBoYXNoO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXRpbGl0eSBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBoYXNoIGNvZGUgb2YgYW4gYXJyYXkgdXNpbmcgdGhlXHJcblx0ICogTXVybXVySGFzaCBhbGdvcml0aG0uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gPFQ+IHRoZSBhcnJheSBlbGVtZW50IHR5cGVcclxuXHQgKiBAcGFyYW0gZGF0YSB0aGUgYXJyYXkgZGF0YVxyXG5cdCAqIEBwYXJhbSBzZWVkIHRoZSBzZWVkIGZvciB0aGUgTXVybXVySGFzaCBhbGdvcml0aG1cclxuXHQgKiBAcmV0dXJucyB0aGUgaGFzaCBjb2RlIG9mIHRoZSBkYXRhXHJcblx0ICovXHJcblx0ZXhwb3J0IGZ1bmN0aW9uIGhhc2hDb2RlPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcgfCBFcXVhdGFibGU+KGRhdGE6IEl0ZXJhYmxlPFQ+LCBzZWVkOiBudW1iZXIgPSBERUZBVUxUX1NFRUQpOiBudW1iZXIge1xyXG5cdFx0bGV0IGhhc2g6IG51bWJlciA9IGluaXRpYWxpemUoc2VlZCk7XHJcblx0XHRsZXQgbGVuZ3RoID0gMDtcclxuXHRcdGZvciAobGV0IHZhbHVlIG9mIGRhdGEpIHtcclxuXHRcdFx0aGFzaCA9IHVwZGF0ZShoYXNoLCB2YWx1ZSk7XHJcblx0XHRcdGxlbmd0aCsrO1xyXG5cdFx0fVxyXG5cclxuXHRcdGhhc2ggPSBmaW5pc2goaGFzaCwgbGVuZ3RoKTtcclxuXHRcdHJldHVybiBoYXNoO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRnVuY3Rpb24gdG8gaGFzaCBhIHN0cmluZy4gQmFzZWQgb24gdGhlIGltcGxlbWVudGF0aW9uIGZvdW5kIGhlcmU6XHJcblx0ICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzYxNjQ4NFxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xyXG5cdFx0bGV0IGxlbiA9IHN0ci5sZW5ndGg7XHJcblx0XHRpZiAobGVuID09PSAwKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBoYXNoID0gMDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0bGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuXHRcdFx0aGFzaCA9ICgoKGhhc2ggPDwgNSkgPj4+IDApIC0gaGFzaCkgKyBjO1xyXG5cdFx0XHRoYXNoIHw9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGhhc2g7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wM1QwMjowOTo0Mi4yMTI3MjYwLTA3OjAwXHJcbmltcG9ydCB7IEVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuL0VxdWFsaXR5Q29tcGFyYXRvclwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IEVxdWF0YWJsZSB9IGZyb20gXCIuL1N0dWJzXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBFcXVhbGl0eUNvbXBhcmF0b3J9IHVzZXMgb2JqZWN0IGVxdWFsaXR5XHJcbiAqIGZvciBjb21wYXJpc29ucyBieSBjYWxsaW5nIHtAbGluayBPYmplY3QjaGFzaENvZGV9IGFuZCB7QGxpbmsgT2JqZWN0I2VxdWFsc30uXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgaW1wbGVtZW50cyBFcXVhbGl0eUNvbXBhcmF0b3I8RXF1YXRhYmxlIHwgbnVsbCB8IHVuZGVmaW5lZD4ge1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSU5TVEFOQ0U6IE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvciA9IG5ldyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IoKTtcclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhpcyBpbXBsZW1lbnRhdGlvbiByZXR1cm5zXHJcblx0ICogYG9iai5ge0BsaW5rIE9iamVjdCNoYXNoQ29kZSBoYXNoQ29kZSgpfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUob2JqOiBFcXVhdGFibGUgfCBudWxsIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcclxuXHRcdGlmIChvYmogPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb2JqLmhhc2hDb2RlKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGltcGxlbWVudGF0aW9uIHJlbGllcyBvbiBvYmplY3QgZXF1YWxpdHkuIElmIGJvdGggb2JqZWN0cyBhcmVcclxuXHQgKiBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLiBPdGhlcndpc2UgaWYgb25seVxyXG5cdCAqIGBhYCBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC4gT3RoZXJ3aXNlLFxyXG5cdCAqIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHJlc3VsdCBvZlxyXG5cdCAqIGBhLmB7QGxpbmsgT2JqZWN0I2VxdWFscyBlcXVhbHN9YChiKWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhhOiBFcXVhdGFibGUgfCBudWxsIHwgdW5kZWZpbmVkLCBiOiBFcXVhdGFibGUgfCBudWxsIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XHJcblx0XHRpZiAoYSA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBiID09IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGEuZXF1YWxzKGIpO1xyXG5cdH1cclxuXHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgRXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4vRXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgRXF1YXRhYmxlIH0gZnJvbSBcIi4vU3R1YnNcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuL011cm11ckhhc2hcIjtcclxuaW1wb3J0IHsgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4vT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBFcXVhbGl0eUNvbXBhcmF0b3J9IHVzZXMgb2JqZWN0IGVxdWFsaXR5XHJcbiAqIGZvciBjb21wYXJpc29ucyBieSBjYWxsaW5nIHtAbGluayBPYmplY3QjaGFzaENvZGV9IGFuZCB7QGxpbmsgT2JqZWN0I2VxdWFsc30uXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0RXF1YWxpdHlDb21wYXJhdG9yIGltcGxlbWVudHMgRXF1YWxpdHlDb21wYXJhdG9yPGFueT4ge1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSU5TVEFOQ0U6IERlZmF1bHRFcXVhbGl0eUNvbXBhcmF0b3IgPSBuZXcgRGVmYXVsdEVxdWFsaXR5Q29tcGFyYXRvcigpO1xyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGltcGxlbWVudGF0aW9uIHJldHVybnNcclxuXHQgKiBgb2JqLmB7QGxpbmsgT2JqZWN0I2hhc2hDb2RlIGhhc2hDb2RlKCl9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZShvYmo6IGFueSk6IG51bWJlciB7XHJcblx0XHRpZiAob2JqID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gTXVybXVySGFzaC5oYXNoQ29kZShbb2JqXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFLmhhc2hDb2RlKG9iaiBhcyBFcXVhdGFibGUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhpcyBpbXBsZW1lbnRhdGlvbiByZWxpZXMgb24gb2JqZWN0IGVxdWFsaXR5LiBJZiBib3RoIG9iamVjdHMgYXJlXHJcblx0ICogYHVuZGVmaW5lZGAgb3IgYG51bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC4gT3RoZXJ3aXNlIGlmIG9ubHlcclxuXHQgKiBgYWAgaXMgYHVuZGVmaW5lZGAgb3IgYG51bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuIE90aGVyd2lzZSxcclxuXHQgKiB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcclxuXHQgKiBgYS5ge0BsaW5rIE9iamVjdCNlcXVhbHMgZXF1YWxzfWAoYilgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMoYTogYW55LCBiOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChhID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIGIgPT0gbnVsbDtcclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGEgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIGEgPT09IGI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFLmVxdWFscyhhIGFzIEVxdWF0YWJsZSwgYiBhcyBFcXVhdGFibGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDNUMDI6MDk6NDEuNzQzNDA4Ni0wNzowMFxyXG5cclxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcclxuaW1wb3J0IHsgRGVmYXVsdEVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuL0RlZmF1bHRFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgRXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4vRXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE51bGxhYmxlLCBPdmVycmlkZSwgU3VwcHJlc3NXYXJuaW5ncyB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IEphdmFDb2xsZWN0aW9uLCBKYXZhU2V0IH0gZnJvbSBcIi4vU3R1YnNcIjtcclxuaW1wb3J0IHsgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4vT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi9NdXJtdXJIYXNoXCI7XHJcblxyXG4vKioge0BsaW5rIFNldH0gaW1wbGVtZW50YXRpb24gd2l0aCBjbG9zZWQgaGFzaGluZyAob3BlbiBhZGRyZXNzaW5nKS4gKi9cclxuXHJcbi8vIE5PVEU6ICBKYXZhU2NyaXB0J3MgU2V0IGludGVyZmFjZSBoYXMgb24gc2lnbmlmaWNhbnQgZGlmZmVyZW50IGRpZmZyZW5jZSBmcm9tIEphdmEnczpcclxuLy8gXHRcdCAgZS5nLiB0aGUgcmV0dXJuIHR5cGUgb2YgYWRkKCkgZGlmZmVycyFcclxuLy8gICAgICAgIEZvciB0aGlzIHJlYXNvbiBJJ3ZlIGNvbW1lbnRlZCB0d2Vha2VkIHRoZSBpbXBsZW1lbnRzIGNsYXVzZVxyXG5cclxuY29uc3QgSU5JVEFMX0NBUEFDSVRZOiBudW1iZXIgPSAxNjsgLy8gbXVzdCBiZSBwb3dlciBvZiAyXHJcbmNvbnN0IExPQURfRkFDVE9SOiBudW1iZXIgPSAwLjc1O1xyXG5cclxuZXhwb3J0IGNsYXNzIEFycmF5MkRIYXNoU2V0PFQgZXh0ZW5kcyB7IHRvU3RyaW5nKCk6IHN0cmluZzsgfT4gaW1wbGVtZW50cyBKYXZhU2V0PFQ+IHtcclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBjb21wYXJhdG9yOiBFcXVhbGl0eUNvbXBhcmF0b3I8VD47XHJcblxyXG5cdHByb3RlY3RlZCBidWNrZXRzOiBBcnJheTxUW10gfCB1bmRlZmluZWQ+O1xyXG5cclxuXHQvKiogSG93IG1hbnkgZWxlbWVudHMgaW4gc2V0ICovXHJcblx0cHJvdGVjdGVkIG46IG51bWJlciA9IDA7XHJcblxyXG5cdHByb3RlY3RlZCB0aHJlc2hvbGQ6IG51bWJlciA9IE1hdGguZmxvb3IoSU5JVEFMX0NBUEFDSVRZICogTE9BRF9GQUNUT1IpOyAvLyB3aGVuIHRvIGV4cGFuZFxyXG5cclxuXHRjb25zdHJ1Y3Rvcihjb21wYXJhdG9yPzogRXF1YWxpdHlDb21wYXJhdG9yPFQ+LCBpbml0aWFsQ2FwYWNpdHk/OiBudW1iZXIpO1xyXG5cdGNvbnN0cnVjdG9yKHNldDogQXJyYXkyREhhc2hTZXQ8VD4pO1xyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0Y29tcGFyYXRvck9yU2V0PzogRXF1YWxpdHlDb21wYXJhdG9yPFQ+IHwgQXJyYXkyREhhc2hTZXQ8VD4sXHJcblx0XHRpbml0aWFsQ2FwYWNpdHk6IG51bWJlciA9IElOSVRBTF9DQVBBQ0lUWSkge1xyXG5cclxuXHRcdGlmIChjb21wYXJhdG9yT3JTZXQgaW5zdGFuY2VvZiBBcnJheTJESGFzaFNldCkge1xyXG5cdFx0XHR0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yT3JTZXQuY29tcGFyYXRvcjtcclxuXHRcdFx0dGhpcy5idWNrZXRzID0gY29tcGFyYXRvck9yU2V0LmJ1Y2tldHMuc2xpY2UoMCk7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5idWNrZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IGJ1Y2tldCA9IHRoaXMuYnVja2V0c1tpXTtcclxuXHRcdFx0XHRpZiAoYnVja2V0KSB7XHJcblx0XHRcdFx0XHR0aGlzLmJ1Y2tldHNbaV0gPSBidWNrZXQuc2xpY2UoMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm4gPSBjb21wYXJhdG9yT3JTZXQubjtcclxuXHRcdFx0dGhpcy50aHJlc2hvbGQgPSBjb21wYXJhdG9yT3JTZXQudGhyZXNob2xkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvck9yU2V0IHx8IERlZmF1bHRFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0U7XHJcblx0XHRcdHRoaXMuYnVja2V0cyA9IHRoaXMuY3JlYXRlQnVja2V0cyhpbml0aWFsQ2FwYWNpdHkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGBvYCB0byBzZXQgaWYgbm90IHRoZXJlOyByZXR1cm4gZXhpc3RpbmcgdmFsdWUgaWYgYWxyZWFkeVxyXG5cdCAqIHRoZXJlLiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgc2FtZSBvcGVyYXRpb24gYXMge0BsaW5rICNhZGR9IGFzaWRlIGZyb21cclxuXHQgKiB0aGUgcmV0dXJuIHZhbHVlLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRPckFkZChvOiBUKTogVCB7XHJcblx0XHRpZiAodGhpcy5uID4gdGhpcy50aHJlc2hvbGQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmdldE9yQWRkSW1wbChvKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRPckFkZEltcGwobzogVCk6IFQge1xyXG5cdFx0bGV0IGI6IG51bWJlciA9IHRoaXMuZ2V0QnVja2V0KG8pO1xyXG5cdFx0bGV0IGJ1Y2tldCA9IHRoaXMuYnVja2V0c1tiXTtcclxuXHJcblx0XHQvLyBORVcgQlVDS0VUXHJcblx0XHRpZiAoIWJ1Y2tldCkge1xyXG5cdFx0XHRidWNrZXQgPSBbb107XHJcblx0XHRcdHRoaXMuYnVja2V0c1tiXSA9IGJ1Y2tldDtcclxuXHRcdFx0dGhpcy5uKys7XHJcblx0XHRcdHJldHVybiBvO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIExPT0sgRk9SIElUIElOIEJVQ0tFVFxyXG5cdFx0Zm9yIChsZXQgZXhpc3Rpbmcgb2YgYnVja2V0KSB7XHJcblx0XHRcdGlmICh0aGlzLmNvbXBhcmF0b3IuZXF1YWxzKGV4aXN0aW5nLCBvKSkge1xyXG5cdFx0XHRcdHJldHVybiBleGlzdGluZzsgLy8gZm91bmQgZXhpc3RpbmcsIHF1aXRcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZVTEwgQlVDS0VULCBleHBhbmQgYW5kIGFkZCB0byBlbmRcclxuXHRcdGJ1Y2tldC5wdXNoKG8pO1xyXG5cdFx0dGhpcy5uKys7XHJcblx0XHRyZXR1cm4gbztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXQobzogVCk6IFQgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKG8gPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gbztcclxuXHRcdH1cclxuXHRcdGxldCBiOiBudW1iZXIgPSB0aGlzLmdldEJ1Y2tldChvKTtcclxuXHRcdGxldCBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbYl07XHJcblx0XHRpZiAoIWJ1Y2tldCkge1xyXG5cdFx0XHQvLyBubyBidWNrZXRcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBlIG9mIGJ1Y2tldCkge1xyXG5cdFx0XHRpZiAodGhpcy5jb21wYXJhdG9yLmVxdWFscyhlLCBvKSkge1xyXG5cdFx0XHRcdHJldHVybiBlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRCdWNrZXQobzogVCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gdGhpcy5jb21wYXJhdG9yLmhhc2hDb2RlKG8pO1xyXG5cdFx0bGV0IGI6IG51bWJlciA9IGhhc2ggJiAodGhpcy5idWNrZXRzLmxlbmd0aCAtIDEpOyAvLyBhc3N1bWVzIGxlbiBpcyBwb3dlciBvZiAyXHJcblx0XHRyZXR1cm4gYjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IGhhc2g6IG51bWJlciA9IE11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xyXG5cdFx0Zm9yIChsZXQgYnVja2V0IG9mIHRoaXMuYnVja2V0cykge1xyXG5cdFx0XHRpZiAoYnVja2V0ID09IG51bGwpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IgKGxldCBvIG9mIGJ1Y2tldCkge1xyXG5cdFx0XHRcdGlmIChvID09IG51bGwpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5jb21wYXJhdG9yLmhhc2hDb2RlKG8pKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLmZpbmlzaChoYXNoLCB0aGlzLnNpemUpO1xyXG5cdFx0cmV0dXJuIGhhc2g7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG86IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG8gPT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHRpZiAoIShvIGluc3RhbmNlb2YgQXJyYXkyREhhc2hTZXQpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGlmIChvLnNpemUgIT09IHRoaXMuc2l6ZSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRsZXQgc2FtZTogYm9vbGVhbiA9IHRoaXMuY29udGFpbnNBbGwobyk7XHJcblx0XHRyZXR1cm4gc2FtZTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBleHBhbmQoKTogdm9pZCB7XHJcblx0XHRsZXQgb2xkID0gdGhpcy5idWNrZXRzO1xyXG5cdFx0bGV0IG5ld0NhcGFjaXR5OiBudW1iZXIgPSB0aGlzLmJ1Y2tldHMubGVuZ3RoICogMjtcclxuXHRcdGxldCBuZXdUYWJsZTogQXJyYXk8VFtdIHwgdW5kZWZpbmVkPiA9IHRoaXMuY3JlYXRlQnVja2V0cyhuZXdDYXBhY2l0eSk7XHJcblx0XHR0aGlzLmJ1Y2tldHMgPSBuZXdUYWJsZTtcclxuXHRcdHRoaXMudGhyZXNob2xkID0gTWF0aC5mbG9vcihuZXdDYXBhY2l0eSAqIExPQURfRkFDVE9SKTtcclxuLy9cdFx0U3lzdGVtLm91dC5wcmludGxuKFwibmV3IHNpemU9XCIrbmV3Q2FwYWNpdHkrXCIsIHRocmVzPVwiK3RocmVzaG9sZCk7XHJcblx0XHQvLyByZWhhc2ggYWxsIGV4aXN0aW5nIGVudHJpZXNcclxuXHRcdGxldCBvbGRTaXplOiBudW1iZXIgPSB0aGlzLnNpemU7XHJcblx0XHRmb3IgKGxldCBidWNrZXQgb2Ygb2xkKSB7XHJcblx0XHRcdGlmICghYnVja2V0KSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAobGV0IG8gb2YgYnVja2V0KSB7XHJcblx0XHRcdFx0bGV0IGI6IG51bWJlciA9IHRoaXMuZ2V0QnVja2V0KG8pO1xyXG5cdFx0XHRcdGxldCBuZXdCdWNrZXQ6IFRbXSB8IHVuZGVmaW5lZCA9IHRoaXMuYnVja2V0c1tiXTtcclxuXHRcdFx0XHRpZiAoIW5ld0J1Y2tldCkge1xyXG5cdFx0XHRcdFx0bmV3QnVja2V0ID0gW107XHJcblx0XHRcdFx0XHR0aGlzLmJ1Y2tldHNbYl0gPSBuZXdCdWNrZXQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRuZXdCdWNrZXQucHVzaChvKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGFzc2VydCh0aGlzLm4gPT09IG9sZFNpemUpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGFkZCh0OiBUKTogYm9vbGVhbiB7XHJcblx0XHRsZXQgZXhpc3Rpbmc6IFQgPSB0aGlzLmdldE9yQWRkKHQpO1xyXG5cdFx0cmV0dXJuIGV4aXN0aW5nID09PSB0O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNpemUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLm47XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLm4gPT09IDA7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgY29udGFpbnMobzogYW55KTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluc0Zhc3QodGhpcy5hc0VsZW1lbnRUeXBlKG8pKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBjb250YWluc0Zhc3QoQE51bGxhYmxlIG9iajogVCk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG9iaiA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXQob2JqKSAhPSBudWxsO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljICpbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYWJsZUl0ZXJhdG9yPFQ+IHtcclxuXHRcdHlpZWxkKiB0aGlzLnRvQXJyYXkoKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b0FycmF5KCk6IFRbXSB7XHJcblx0XHRjb25zdCBhID0gbmV3IEFycmF5PFQ+KHRoaXMuc2l6ZSk7XHJcblxyXG5cdFx0Ly8gQ29weSBlbGVtZW50cyBmcm9tIHRoZSBuZXN0ZWQgYXJyYXlzIGludG8gdGhlIGRlc3RpbmF0aW9uIGFycmF5XHJcblx0XHRsZXQgaTogbnVtYmVyID0gMDsgLy8gUG9zaXRpb24gd2l0aGluIGRlc3RpbmF0aW9uIGFycmF5XHJcblx0XHRmb3IgKGxldCBidWNrZXQgb2YgdGhpcy5idWNrZXRzKSB7XHJcblx0XHRcdGlmIChidWNrZXQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKGxldCBvIG9mIGJ1Y2tldCkge1xyXG5cdFx0XHRcdGlmIChvID09IG51bGwpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRhW2krK10gPSBvO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjb250YWluc0FsbChjb2xsZWN0aW9uOiBKYXZhQ29sbGVjdGlvbjxUPik6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBBcnJheTJESGFzaFNldCkge1xyXG5cdFx0XHRsZXQgcyA9IGNvbGxlY3Rpb24gYXMgYW55IGFzIEFycmF5MkRIYXNoU2V0PFQ+O1xyXG5cdFx0XHRmb3IgKGxldCBidWNrZXQgb2Ygcy5idWNrZXRzKSB7XHJcblx0XHRcdFx0aWYgKGJ1Y2tldCA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Zm9yIChsZXQgbyBvZiBidWNrZXQpIHtcclxuXHRcdFx0XHRcdGlmIChvID09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoIXRoaXMuY29udGFpbnNGYXN0KHRoaXMuYXNFbGVtZW50VHlwZShvKSkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGZvciAobGV0IG8gb2YgY29sbGVjdGlvbikge1xyXG5cdFx0XHRcdGlmICghdGhpcy5jb250YWluc0Zhc3QodGhpcy5hc0VsZW1lbnRUeXBlKG8pKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgYWRkQWxsKGM6IEl0ZXJhYmxlPFQ+KTogYm9vbGVhbiB7XHJcblx0XHRsZXQgY2hhbmdlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAobGV0IG8gb2YgYykge1xyXG5cdFx0XHRsZXQgZXhpc3Rpbmc6IFQgPSB0aGlzLmdldE9yQWRkKG8pO1xyXG5cdFx0XHRpZiAoZXhpc3RpbmcgIT09IG8pIHtcclxuXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgY2xlYXIoKTogdm9pZCB7XHJcblx0XHR0aGlzLmJ1Y2tldHMgPSB0aGlzLmNyZWF0ZUJ1Y2tldHMoSU5JVEFMX0NBUEFDSVRZKTtcclxuXHRcdHRoaXMubiA9IDA7XHJcblx0XHR0aGlzLnRocmVzaG9sZCA9IE1hdGguZmxvb3IoSU5JVEFMX0NBUEFDSVRZICogTE9BRF9GQUNUT1IpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRpZiAodGhpcy5zaXplID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBcInt9XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGJ1ZiA9IFwie1wiO1xyXG5cdFx0bGV0IGZpcnN0OiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdGZvciAobGV0IGJ1Y2tldCBvZiB0aGlzLmJ1Y2tldHMpIHtcclxuXHRcdFx0aWYgKGJ1Y2tldCA9PSBudWxsKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yIChsZXQgbyBvZiBidWNrZXQpIHtcclxuXHRcdFx0XHRpZiAobyA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGZpcnN0KSB7XHJcblx0XHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRidWYgKz0gXCIsIFwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRidWYgKz0gby50b1N0cmluZygpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRidWYgKz0gXCJ9XCI7XHJcblx0XHRyZXR1cm4gYnVmO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvVGFibGVTdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGxldCBidWYgPSBcIlwiO1xyXG5cdFx0Zm9yIChsZXQgYnVja2V0IG9mIHRoaXMuYnVja2V0cykge1xyXG5cdFx0XHRpZiAoYnVja2V0ID09IG51bGwpIHtcclxuXHRcdFx0XHRidWYgKz0gXCJudWxsXFxuXCI7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0YnVmICs9IFwiW1wiO1xyXG5cdFx0XHRsZXQgZmlyc3Q6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdFx0XHRmb3IgKGxldCBvIG9mIGJ1Y2tldCkge1xyXG5cdFx0XHRcdGlmIChmaXJzdCkge1xyXG5cdFx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YnVmICs9IFwiIFwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobyA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRidWYgKz0gXCJfXCI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGJ1ZiArPSBvLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGJ1ZiArPSBcIl1cXG5cIjtcclxuXHRcdH1cclxuXHRcdHJldHVybiBidWY7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gYG9gIGFzIGFuIGluc3RhbmNlIG9mIHRoZSBlbGVtZW50IHR5cGUgYFRgLiBJZlxyXG5cdCAqIGBvYCBpcyBub24tdW5kZWZpbmVkIGJ1dCBrbm93biB0byBub3QgYmUgYW4gaW5zdGFuY2Ugb2YgYFRgLCB0aGlzXHJcblx0ICogbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHBlcmZvcm0gYW55XHJcblx0ICogdHlwZSBjaGVja3M7IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGUgc3Ryb25nIHR5cGUgY2hlY2tzIGZvciB0aGVcclxuXHQgKiB7QGxpbmsgI2NvbnRhaW5zfSBhbmQge0BsaW5rICNyZW1vdmV9IG1ldGhvZHMgdG8gZW5zdXJlIHRoZSBhcmd1bWVudHMgdG9cclxuXHQgKiB0aGUge0BsaW5rIEVxdWFsaXR5Q29tcGFyYXRvcn0gZm9yIHRoZSBzZXQgYWx3YXlzIGhhdmUgdGhlIGV4cGVjdGVkXHJcblx0ICogdHlwZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gbyB0aGUgb2JqZWN0IHRvIHRyeSBhbmQgY2FzdCB0byB0aGUgZWxlbWVudCB0eXBlIG9mIHRoZSBzZXRcclxuXHQgKiBAcmV0dXJucyBgb2AgaWYgaXQgY291bGQgYmUgYW4gaW5zdGFuY2Ugb2YgYFRgLCBvdGhlcndpc2VcclxuXHQgKiBgdW5kZWZpbmVkYC5cclxuXHQgKi9cclxuXHRAU3VwcHJlc3NXYXJuaW5ncyhcInVuY2hlY2tlZFwiKVxyXG5cdHByb3RlY3RlZCBhc0VsZW1lbnRUeXBlKG86IGFueSk6IFQge1xyXG5cdFx0cmV0dXJuIG8gYXMgVDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiBhbiBhcnJheSBvZiBgVFtdYCB3aXRoIGxlbmd0aCBgY2FwYWNpdHlgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGNhcGFjaXR5IHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHRvIHJldHVyblxyXG5cdCAqIEByZXR1cm5zIHRoZSBuZXdseSBjb25zdHJ1Y3RlZCBhcnJheVxyXG5cdCAqL1xyXG5cdEBTdXBwcmVzc1dhcm5pbmdzKFwidW5jaGVja2VkXCIpXHJcblx0cHJvdGVjdGVkIGNyZWF0ZUJ1Y2tldHMoY2FwYWNpdHk6IG51bWJlcik6IEFycmF5PFRbXSB8IHVuZGVmaW5lZD4ge1xyXG5cdFx0cmV0dXJuIG5ldyBBcnJheTxUW10+KGNhcGFjaXR5KTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTAzVDAyOjA5OjQyLjIxMjcyNjAtMDc6MDBcclxuaW1wb3J0IHsgRXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4vRXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgRXF1YXRhYmxlIH0gZnJvbSBcIi4vU3R1YnNcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuL011cm11ckhhc2hcIjtcclxuaW1wb3J0IHsgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4vT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBFcXVhbGl0eUNvbXBhcmF0b3J9IHVzZXMgb2JqZWN0IGVxdWFsaXR5XHJcbiAqIGZvciBjb21wYXJpc29ucyBieSBjYWxsaW5nIHtAbGluayBPYmplY3QjaGFzaENvZGV9IGFuZCB7QGxpbmsgT2JqZWN0I2VxdWFsc30uXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBcnJheUVxdWFsaXR5Q29tcGFyYXRvciBpbXBsZW1lbnRzIEVxdWFsaXR5Q29tcGFyYXRvcjxFcXVhdGFibGVbXT4ge1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSU5TVEFOQ0U6IEFycmF5RXF1YWxpdHlDb21wYXJhdG9yID0gbmV3IEFycmF5RXF1YWxpdHlDb21wYXJhdG9yKCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoaXMgaW1wbGVtZW50YXRpb24gcmV0dXJuc1xyXG5cdCAqIGBvYmouYHtAbGluayBPYmplY3QjaGFzaENvZGUgaGFzaENvZGUoKX0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKG9iajogRXF1YXRhYmxlW10pOiBudW1iZXIge1xyXG5cdFx0aWYgKG9iaiA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNdXJtdXJIYXNoLmhhc2hDb2RlKG9iaiwgMCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGltcGxlbWVudGF0aW9uIHJlbGllcyBvbiBvYmplY3QgZXF1YWxpdHkuIElmIGJvdGggb2JqZWN0cyBhcmVcclxuXHQgKiBgdW5kZWZpbmVkYCwgdGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuIE90aGVyd2lzZSBpZiBvbmx5XHJcblx0ICogYGFgIGlzIGB1bmRlZmluZWRgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuIE90aGVyd2lzZSxcclxuXHQgKiB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcclxuXHQgKiBgYS5ge0BsaW5rIE9iamVjdCNlcXVhbHMgZXF1YWxzfWAoYilgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMoYTogRXF1YXRhYmxlW10sIGI6IEVxdWF0YWJsZVtdKTogYm9vbGVhbiB7XHJcblx0XHRpZiAoYSA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBiID09IG51bGw7XHJcblx0XHR9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFLmVxdWFscyhhW2ldLCBiW2ldKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ1LjA4MzM3NTItMDc6MDBcclxuXHJcbi8vIFRha2luZyBhIGNhc2UtYnktY2FzZSBhcHByb2FjaCB0byBwcG9ydGluZyB0aGlzIGZ1bmN0aW9uYWx0aXlcclxuLy8gYXMgbXVjaCBvZiBpdCBtYXkgYmUgc3VwcG9ydGVkIG5hdGl2ZWx5IGJ5IEphdmFTY3JpcHQuIE9yIG90aGVyd2lzZSBuZWVkXHJcbi8vIHN1YnN0YW50aWFsIHJldGhpbmtcclxuXHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBFcXVhdGFibGUgfSBmcm9tIFwiLi9TdHVic1wiO1xyXG5pbXBvcnQgeyBJbnRlZ2VyTGlzdCB9IGZyb20gXCIuL0ludGVnZXJMaXN0XCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlV2hpdGVzcGFjZShzOiBzdHJpbmcsIGVzY2FwZVNwYWNlczogYm9vbGVhbik6IHN0cmluZyB7XHJcblx0cmV0dXJuIGVzY2FwZVNwYWNlcyA/IHMucmVwbGFjZSgvIC8sIFwiXFx1MDBCN1wiKSA6IHNcclxuXHRcdC5yZXBsYWNlKC9cXHQvLCBcIlxcXFx0XCIpXHJcblx0XHQucmVwbGFjZSgvXFxuLywgXCJcXFxcblwiKVxyXG5cdFx0LnJlcGxhY2UoL1xcci8sIFwiXFxcXHJcIik7XHJcbn1cclxuXHJcbi8vIFNlcmlvdXNseTogd2h5IGlzbid0IHRoaXMgYnVpbHQgaW4gdG8gamF2YT8gdWdoIVxyXG5leHBvcnQgZnVuY3Rpb24gam9pbihjb2xsZWN0aW9uOiBJdGVyYWJsZTxhbnk+LCBzZXBhcmF0b3I6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0bGV0IGJ1ZiA9IFwiXCI7XHJcblx0bGV0IGZpcnN0ID0gdHJ1ZTtcclxuXHRmb3IgKGxldCBjdXJyZW50IG9mIGNvbGxlY3Rpb24pIHtcclxuXHRcdGlmIChmaXJzdCkge1xyXG5cdFx0XHRmaXJzdCA9IGZhbHNlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YnVmICs9IHNlcGFyYXRvcjtcclxuXHRcdH1cclxuXHJcblx0XHRidWYgKz0gY3VycmVudDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBidWY7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoeDogRXF1YXRhYmxlIHwgdW5kZWZpbmVkLCB5OiBFcXVhdGFibGUgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcclxuXHRpZiAoeCA9PT0geSkge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHkgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHguZXF1YWxzKHkpO1xyXG59XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gbnVtTm9ubnVsbChkYXRhOiBhbnlbXSk6IG51bWJlciB7XHJcbi8vIFx0bGV0IG46IG51bWJlciA9ICAwO1xyXG4vLyBcdGlmICggZGF0YSA9PSBudWxsICkgcmV0dXJuIG47XHJcbi8vIFx0Zm9yIChsZXQgbyBvZiBkYXRhKSB7XHJcbi8vIFx0XHRpZiAoIG8hPW51bGwgKSBuKys7XHJcbi8vIFx0fVxyXG4vLyBcdHJldHVybiBuO1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gcmVtb3ZlQWxsRWxlbWVudHM8VD4oZGF0YTogQ29sbGVjdGlvbjxUPiwgdmFsdWU6IFQpOiB2b2lkIHtcclxuLy8gXHRpZiAoIGRhdGE9PW51bGwgKSByZXR1cm47XHJcbi8vIFx0d2hpbGUgKCBkYXRhLmNvbnRhaW5zKHZhbHVlKSApIGRhdGEucmVtb3ZlKHZhbHVlKTtcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIHdyaXRlRmlsZShATm90TnVsbCBmaWxlOiBGaWxlLCBATm90TnVsbCBjb250ZW50OiBVaW50OEFycmF5KTogdm9pZCB7XHJcbi8vIFx0bGV0IGZvczogRmlsZU91dHB1dFN0cmVhbSA9IG5ldyBGaWxlT3V0cHV0U3RyZWFtKGZpbGUpO1xyXG4vLyBcdHRyeSB7XHJcbi8vIFx0XHRmb3Mud3JpdGUoY29udGVudCk7XHJcbi8vIFx0fSBmaW5hbGx5IHtcclxuLy8gXHRcdGZvcy5jbG9zZSgpO1xyXG4vLyBcdH1cclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIHdyaXRlRmlsZShATm90TnVsbCBmaWxlTmFtZTogc3RyaW5nLCBATm90TnVsbCBjb250ZW50OiBzdHJpbmcpOiB2b2lkIHtcclxuLy8gXHR3cml0ZUZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIG51bGwpO1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gd3JpdGVGaWxlKEBOb3ROdWxsIGZpbGVOYW1lOiBzdHJpbmcsIEBOb3ROdWxsIGNvbnRlbnQ6IHN0cmluZywgQE51bGxhYmxlIGVuY29kaW5nOiBzdHJpbmcpOiB2b2lkIHtcclxuLy8gXHRsZXQgZjogRmlsZSA9ICBuZXcgRmlsZShmaWxlTmFtZSk7XHJcbi8vIFx0bGV0IGZvczogRmlsZU91dHB1dFN0cmVhbSA9ICBuZXcgRmlsZU91dHB1dFN0cmVhbShmKTtcclxuLy8gXHRsZXQgb3N3OiBPdXRwdXRTdHJlYW1Xcml0ZXI7XHJcbi8vIFx0aWYgKGVuY29kaW5nICE9IG51bGwpIHtcclxuLy8gXHRcdG9zdyA9IG5ldyBPdXRwdXRTdHJlYW1Xcml0ZXIoZm9zLCBlbmNvZGluZyk7XHJcbi8vIFx0fVxyXG4vLyBcdGVsc2Uge1xyXG4vLyBcdFx0b3N3ID0gbmV3IE91dHB1dFN0cmVhbVdyaXRlcihmb3MpO1xyXG4vLyBcdH1cclxuXHJcbi8vIFx0dHJ5IHtcclxuLy8gXHRcdG9zdy53cml0ZShjb250ZW50KTtcclxuLy8gXHR9XHJcbi8vIFx0ZmluYWxseSB7XHJcbi8vIFx0XHRvc3cuY2xvc2UoKTtcclxuLy8gXHR9XHJcbi8vIH1cclxuXHJcbi8vIEBOb3ROdWxsXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiByZWFkRmlsZShATm90TnVsbCBmaWxlTmFtZTogc3RyaW5nKTogY2hhcltdIHtcclxuLy8gXHRyZXR1cm4gcmVhZEZpbGUoZmlsZU5hbWUsIG51bGwpO1xyXG4vLyB9XHJcblxyXG4vLyBATm90TnVsbFxyXG4vLyBleHBvcnQgZnVuY3Rpb24gcmVhZEZpbGUoQE5vdE51bGwgZmlsZU5hbWU6IHN0cmluZywgQE51bGxhYmxlIGVuY29kaW5nOiBzdHJpbmcpOiBjaGFyW10ge1xyXG4vLyBcdGxldCBmOiBGaWxlID0gIG5ldyBGaWxlKGZpbGVOYW1lKTtcclxuLy8gXHRsZXQgc2l6ZTogbnVtYmVyID0gIChpbnQpZi5sZW5ndGgoKTtcclxuLy8gXHRsZXQgaXNyOiBJbnB1dFN0cmVhbVJlYWRlcjtcclxuLy8gXHRsZXQgZmlzOiBGaWxlSW5wdXRTdHJlYW0gPSAgbmV3IEZpbGVJbnB1dFN0cmVhbShmaWxlTmFtZSk7XHJcbi8vIFx0aWYgKCBlbmNvZGluZyE9bnVsbCApIHtcclxuLy8gXHRcdGlzciA9IG5ldyBJbnB1dFN0cmVhbVJlYWRlcihmaXMsIGVuY29kaW5nKTtcclxuLy8gXHR9XHJcbi8vIFx0ZWxzZSB7XHJcbi8vIFx0XHRpc3IgPSBuZXcgSW5wdXRTdHJlYW1SZWFkZXIoZmlzKTtcclxuLy8gXHR9XHJcbi8vIFx0bGV0IGRhdGE6IGNoYXJbXSA9ICBudWxsO1xyXG4vLyBcdHRyeSB7XHJcbi8vIFx0XHRkYXRhID0gbmV3IGNoYXJbc2l6ZV07XHJcbi8vIFx0XHRsZXQgbjogbnVtYmVyID0gIGlzci5yZWFkKGRhdGEpO1xyXG4vLyBcdFx0aWYgKG4gPCBkYXRhLmxlbmd0aCkge1xyXG4vLyBcdFx0XHRkYXRhID0gQXJyYXlzLmNvcHlPZihkYXRhLCBuKTtcclxuLy8gXHRcdH1cclxuLy8gXHR9XHJcbi8vIFx0ZmluYWxseSB7XHJcbi8vIFx0XHRpc3IuY2xvc2UoKTtcclxuLy8gXHR9XHJcbi8vIFx0cmV0dXJuIGRhdGE7XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGw8VD4oQE5vdE51bGwgcHJlZGljYXRlOiBMaXN0PFQ+IGxpc3QsQE5vdE51bGwgUHJlZGljYXRlPD8gc3VwZXIgVD4pOiB2b2lkIHtcclxuLy8gXHRsZXQgajogbnVtYmVyID0gIDA7XHJcbi8vIFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0LnNpemU7IGkrKykge1xyXG4vLyBcdFx0bGV0IGl0ZW06IFQgPSAgbGlzdC5nZXQoaSk7XHJcbi8vIFx0XHRpZiAoIXByZWRpY2F0ZS5ldmFsKGl0ZW0pKSB7XHJcbi8vIFx0XHRcdGlmIChqICE9IGkpIHtcclxuLy8gXHRcdFx0XHRsaXN0LnNldChqLCBpdGVtKTtcclxuLy8gXHRcdFx0fVxyXG5cclxuLy8gXHRcdFx0aisrO1xyXG4vLyBcdFx0fVxyXG4vLyBcdH1cclxuXHJcbi8vIFx0aWYgKGogPCBsaXN0LnNpemUpIHtcclxuLy8gXHRcdGxpc3Quc3ViTGlzdChqLCBsaXN0LnNpemUpLmNsZWFyKCk7XHJcbi8vIFx0fVxyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gcmVtb3ZlQWxsPFQ+KEBOb3ROdWxsIHByZWRpY2F0ZTogSXRlcmFibGU8VD4gaXRlcmFibGUsQE5vdE51bGwgUHJlZGljYXRlPD8gc3VwZXIgVD4pOiB2b2lkIHtcclxuLy8gXHRpZiAoaXRlcmFibGUgaW5zdGFuY2VvZiBMaXN0PD8+KSB7XHJcbi8vIFx0XHRyZW1vdmVBbGwoKExpc3Q8VD4paXRlcmFibGUsIHByZWRpY2F0ZSk7XHJcbi8vIFx0XHRyZXR1cm47XHJcbi8vIFx0fVxyXG5cclxuLy8gXHRmb3IgKEl0ZXJhdG9yPFQ+IGl0ZXJhdG9yID0gaXRlcmFibGUuaXRlcmF0b3IoKTsgaXRlcmF0b3IuaGFzTmV4dCgpOyApIHtcclxuLy8gXHRcdGxldCBpdGVtOiBUID0gIGl0ZXJhdG9yLm5leHQoKTtcclxuLy8gXHRcdGlmIChwcmVkaWNhdGUuZXZhbChpdGVtKSkge1xyXG4vLyBcdFx0XHRpdGVyYXRvci5yZW1vdmUoKTtcclxuLy8gXHRcdH1cclxuLy8gXHR9XHJcbi8vIH1cclxuXHJcbi8qKiBDb252ZXJ0IGFycmF5IG9mIHN0cmluZ3MgdG8gc3RyaW5nJnJhcnI7aW5kZXggbWFwLiBVc2VmdWwgZm9yXHJcbiAqICBjb252ZXJ0aW5nIHJ1bGVuYW1lcyB0byBuYW1lJnJhcnI7cnVsZWluZGV4IG1hcC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b01hcChrZXlzOiBzdHJpbmdbXSk6IE1hcDxzdHJpbmcsIG51bWJlcj4ge1xyXG5cdGxldCBtOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdG0uc2V0KGtleXNbaV0sIGkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0NoYXJBcnJheShzdHI6IHN0cmluZyk6IFVpbnQxNkFycmF5O1xyXG5leHBvcnQgZnVuY3Rpb24gdG9DaGFyQXJyYXkoZGF0YTogSW50ZWdlckxpc3QpOiBVaW50MTZBcnJheTtcclxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2hhckFycmF5KHN0cjogc3RyaW5nIHwgSW50ZWdlckxpc3QpOiBVaW50MTZBcnJheSB7XHJcblx0aWYgKHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdGxldCByZXN1bHQgPSBuZXcgVWludDE2QXJyYXkoc3RyLmxlbmd0aCk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRyZXN1bHRbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gc3RyLnRvQ2hhckFycmF5KCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyAvKipcclxuLy8gXHQqIEBzaW5jZSA0LjVcclxuLy8gXHQqL1xyXG4vLyBATm90TnVsbFxyXG4vLyBleHBvcnQgZnVuY3Rpb24gdG9TZXQoQE5vdE51bGwgYml0czogQml0U2V0KTogSW50ZXJ2YWxTZXQge1xyXG4vLyBcdGxldCBzOiBJbnRlcnZhbFNldCA9ICBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuLy8gXHRsZXQgaTogbnVtYmVyID0gIGJpdHMubmV4dFNldEJpdCgwKTtcclxuLy8gXHR3aGlsZSAoIGkgPj0gMCApIHtcclxuLy8gXHRcdHMuYWRkKGkpO1xyXG4vLyBcdFx0aSA9IGJpdHMubmV4dFNldEJpdChpKzEpO1xyXG4vLyBcdH1cclxuLy8gXHRyZXR1cm4gcztcclxuLy8gfVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzYuOTUyMTQ3OC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQXJyYXkyREhhc2hTZXQgfSBmcm9tIFwiLi4vbWlzYy9BcnJheTJESGFzaFNldFwiO1xyXG5pbXBvcnQgeyBBcnJheUVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuLi9taXNjL0FycmF5RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IENvbXBhcmFibGUgfSBmcm9tIFwiLi4vbWlzYy9TdHVic1wiO1xyXG5pbXBvcnQgeyBFcXVhdGFibGUgfSBmcm9tIFwiLi4vbWlzYy9TdHVic1wiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4uL21pc2MvTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuLi9taXNjL09iamVjdEVxdWFsaXR5Q29tcGFyYXRvclwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4uL1JlY29nbml6ZXJcIjtcclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4uL21pc2MvVXRpbHNcIjtcclxuXHJcbmZ1bmN0aW9uIG1heDxUIGV4dGVuZHMgQ29tcGFyYWJsZTxUPj4oaXRlbXM6IEl0ZXJhYmxlPFQ+KTogVCB8IHVuZGVmaW5lZCB7XHJcblx0bGV0IHJlc3VsdDogVCB8IHVuZGVmaW5lZDtcclxuXHRmb3IgKGxldCBjdXJyZW50IG9mIGl0ZW1zKSB7XHJcblx0XHRpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmVzdWx0ID0gY3VycmVudDtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGNvbXBhcmlzb24gPSByZXN1bHQuY29tcGFyZVRvKGN1cnJlbnQpO1xyXG5cdFx0aWYgKGNvbXBhcmlzb24gPCAwKSB7XHJcblx0XHRcdHJlc3VsdCA9IGN1cnJlbnQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBtaW48VCBleHRlbmRzIENvbXBhcmFibGU8VD4+KGl0ZW1zOiBJdGVyYWJsZTxUPik6IFQgfCB1bmRlZmluZWQge1xyXG5cdGxldCByZXN1bHQ6IFQgfCB1bmRlZmluZWQ7XHJcblx0Zm9yIChsZXQgY3VycmVudCBvZiBpdGVtcykge1xyXG5cdFx0aWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJlc3VsdCA9IGN1cnJlbnQ7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjb21wYXJpc29uID0gcmVzdWx0LmNvbXBhcmVUbyhjdXJyZW50KTtcclxuXHRcdGlmIChjb21wYXJpc29uID4gMCkge1xyXG5cdFx0XHRyZXN1bHQgPSBjdXJyZW50O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqIEEgdHJlZSBzdHJ1Y3R1cmUgdXNlZCB0byByZWNvcmQgdGhlIHNlbWFudGljIGNvbnRleHQgaW4gd2hpY2hcclxuICogIGFuIEFUTiBjb25maWd1cmF0aW9uIGlzIHZhbGlkLiAgSXQncyBlaXRoZXIgYSBzaW5nbGUgcHJlZGljYXRlLFxyXG4gKiAgYSBjb25qdW5jdGlvbiBgcDEmJnAyYCwgb3IgYSBzdW0gb2YgcHJvZHVjdHMgYHAxfHxwMmAuXHJcbiAqXHJcbiAqICBJIGhhdmUgc2NvcGVkIHRoZSB7QGxpbmsgQU5EfSwge0BsaW5rIE9SfSwgYW5kIHtAbGluayBQcmVkaWNhdGV9IHN1YmNsYXNzZXMgb2ZcclxuICogIHtAbGluayBTZW1hbnRpY0NvbnRleHR9IHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhpcyBvdXRlciBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTZW1hbnRpY0NvbnRleHQgaW1wbGVtZW50cyBFcXVhdGFibGUge1xyXG5cdHByaXZhdGUgc3RhdGljIF9OT05FOiBTZW1hbnRpY0NvbnRleHQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBkZWZhdWx0IHtAbGluayBTZW1hbnRpY0NvbnRleHR9LCB3aGljaCBpcyBzZW1hbnRpY2FsbHkgZXF1aXZhbGVudCB0b1xyXG5cdCAqIGEgcHJlZGljYXRlIG9mIHRoZSBmb3JtIGB7dHJ1ZX0/YC5cclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0IE5PTkUoKTogU2VtYW50aWNDb250ZXh0IHtcclxuXHRcdGlmIChTZW1hbnRpY0NvbnRleHQuX05PTkUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRTZW1hbnRpY0NvbnRleHQuX05PTkUgPSBuZXcgU2VtYW50aWNDb250ZXh0LlByZWRpY2F0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBTZW1hbnRpY0NvbnRleHQuX05PTkU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBGb3IgY29udGV4dCBpbmRlcGVuZGVudCBwcmVkaWNhdGVzLCB3ZSBldmFsdWF0ZSB0aGVtIHdpdGhvdXQgYSBsb2NhbFxyXG5cdCAqIGNvbnRleHQgKGkuZS4sIHVuZWRmaW5lZCBjb250ZXh0KS4gVGhhdCB3YXksIHdlIGNhbiBldmFsdWF0ZSB0aGVtIHdpdGhvdXRcclxuXHQgKiBoYXZpbmcgdG8gY3JlYXRlIHByb3BlciBydWxlLXNwZWNpZmljIGNvbnRleHQgZHVyaW5nIHByZWRpY3Rpb24gKGFzXHJcblx0ICogb3Bwb3NlZCB0byB0aGUgcGFyc2VyLCB3aGljaCBjcmVhdGVzIHRoZW0gbmF0dXJhbGx5KS4gSW4gYSBwcmFjdGljYWxcclxuXHQgKiBzZW5zZSwgdGhpcyBhdm9pZHMgYSBjYXN0IGV4Y2VwdGlvbiBmcm9tIFJ1bGVDb250ZXh0IHRvIG15cnVsZUNvbnRleHQuXHJcblx0ICpcclxuXHQgKiBGb3IgY29udGV4dCBkZXBlbmRlbnQgcHJlZGljYXRlcywgd2UgbXVzdCBwYXNzIGluIGEgbG9jYWwgY29udGV4dCBzbyB0aGF0XHJcblx0ICogcmVmZXJlbmNlcyBzdWNoIGFzICRhcmcgZXZhbHVhdGUgcHJvcGVybHkgYXMgX2xvY2FsY3R4LmFyZy4gV2Ugb25seVxyXG5cdCAqIGNhcHR1cmUgY29udGV4dCBkZXBlbmRlbnQgcHJlZGljYXRlcyBpbiB0aGUgY29udGV4dCBpbiB3aGljaCB3ZSBiZWdpblxyXG5cdCAqIHByZWRpY3Rpb24sIHNvIHdlIHBhc3NlZCBpbiB0aGUgb3V0ZXIgY29udGV4dCBoZXJlIGluIGNhc2Ugb2YgY29udGV4dFxyXG5cdCAqIGRlcGVuZGVudCBwcmVkaWNhdGUgZXZhbHVhdGlvbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgYWJzdHJhY3QgZXZhbDxUPihwYXJzZXI6IFJlY29nbml6ZXI8VCwgYW55PiwgcGFyc2VyQ2FsbFN0YWNrOiBSdWxlQ29udGV4dCk6IGJvb2xlYW47XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV2YWx1YXRlIHRoZSBwcmVjZWRlbmNlIHByZWRpY2F0ZXMgZm9yIHRoZSBjb250ZXh0IGFuZCByZWR1Y2UgdGhlIHJlc3VsdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBwYXJzZXIgVGhlIHBhcnNlciBpbnN0YW5jZS5cclxuXHQgKiBAcGFyYW0gcGFyc2VyQ2FsbFN0YWNrXHJcblx0ICogQHJldHVybnMgVGhlIHNpbXBsaWZpZWQgc2VtYW50aWMgY29udGV4dCBhZnRlciBwcmVjZWRlbmNlIHByZWRpY2F0ZXMgYXJlXHJcblx0ICogZXZhbHVhdGVkLCB3aGljaCB3aWxsIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlcy5cclxuXHQgKlxyXG5cdCAqICoge0BsaW5rICNOT05FfTogaWYgdGhlIHByZWRpY2F0ZSBzaW1wbGlmaWVzIHRvIGB0cnVlYCBhZnRlclxyXG5cdCAqICAgcHJlY2VkZW5jZSBwcmVkaWNhdGVzIGFyZSBldmFsdWF0ZWQuXHJcblx0ICogKiBgdW5kZWZpbmVkYDogaWYgdGhlIHByZWRpY2F0ZSBzaW1wbGlmaWVzIHRvIGBmYWxzZWAgYWZ0ZXJcclxuXHQgKiAgIHByZWNlZGVuY2UgcHJlZGljYXRlcyBhcmUgZXZhbHVhdGVkLlxyXG5cdCAqICogYHRoaXNgOiBpZiB0aGUgc2VtYW50aWMgY29udGV4dCBpcyBub3QgY2hhbmdlZCBhcyBhIHJlc3VsdCBvZlxyXG5cdCAqICAgcHJlY2VkZW5jZSBwcmVkaWNhdGUgZXZhbHVhdGlvbi5cclxuXHQgKiAqIEEgbm9uLWB1bmRlZmluZWRgIHtAbGluayBTZW1hbnRpY0NvbnRleHR9OiB0aGUgbmV3IHNpbXBsaWZpZWRcclxuXHQgKiAgIHNlbWFudGljIGNvbnRleHQgYWZ0ZXIgcHJlY2VkZW5jZSBwcmVkaWNhdGVzIGFyZSBldmFsdWF0ZWQuXHJcblx0ICovXHJcblx0cHVibGljIGV2YWxQcmVjZWRlbmNlKHBhcnNlcjogUmVjb2duaXplcjxhbnksIGFueT4sIHBhcnNlckNhbGxTdGFjazogUnVsZUNvbnRleHQpOiBTZW1hbnRpY0NvbnRleHQgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgaGFzaENvZGUoKTogbnVtYmVyO1xyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbjtcclxuXHJcblx0cHVibGljIHN0YXRpYyBhbmQoYTogU2VtYW50aWNDb250ZXh0IHwgdW5kZWZpbmVkLCBiOiBTZW1hbnRpY0NvbnRleHQpOiBTZW1hbnRpY0NvbnRleHQge1xyXG5cdFx0aWYgKCFhIHx8IGEgPT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XHJcblx0XHRcdHJldHVybiBiO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGIgPT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XHJcblx0XHRcdHJldHVybiBhO1xyXG5cdFx0fVxyXG5cdFx0bGV0IHJlc3VsdDogU2VtYW50aWNDb250ZXh0LkFORCA9IG5ldyBTZW1hbnRpY0NvbnRleHQuQU5EKGEsIGIpO1xyXG5cdFx0aWYgKHJlc3VsdC5vcG5kcy5sZW5ndGggPT09IDEpIHtcclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5vcG5kc1swXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICpcclxuXHQgKiAgQHNlZSBQYXJzZXJBVE5TaW11bGF0b3IjZ2V0UHJlZHNGb3JBbWJpZ0FsdHNcclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIG9yKGE6IFNlbWFudGljQ29udGV4dCB8IHVuZGVmaW5lZCwgYjogU2VtYW50aWNDb250ZXh0KTogU2VtYW50aWNDb250ZXh0IHtcclxuXHRcdGlmICghYSkge1xyXG5cdFx0XHRyZXR1cm4gYjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYSA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUgfHwgYiA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcclxuXHRcdFx0cmV0dXJuIFNlbWFudGljQ29udGV4dC5OT05FO1xyXG5cdFx0fVxyXG5cdFx0bGV0IHJlc3VsdDogU2VtYW50aWNDb250ZXh0Lk9SID0gbmV3IFNlbWFudGljQ29udGV4dC5PUihhLCBiKTtcclxuXHRcdGlmIChyZXN1bHQub3BuZHMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdHJldHVybiByZXN1bHQub3BuZHNbMF07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgU2VtYW50aWNDb250ZXh0IHtcclxuXHQvKipcclxuXHQgKiBUaGlzIHJhbmRvbSAzMC1iaXQgcHJpbWUgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2YgYEFORC5jbGFzcy5oYXNoQ29kZSgpYC5cclxuXHQgKi9cclxuXHRjb25zdCBBTkRfSEFTSENPREUgPSA0MDM2MzYxMztcclxuXHQvKipcclxuXHQgKiBUaGlzIHJhbmRvbSAzMC1iaXQgcHJpbWUgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2YgYE9SLmNsYXNzLmhhc2hDb2RlKClgLlxyXG5cdCAqL1xyXG5cdGNvbnN0IE9SX0hBU0hDT0RFID0gNDg2Mjc5OTczO1xyXG5cclxuXHRmdW5jdGlvbiBmaWx0ZXJQcmVjZWRlbmNlUHJlZGljYXRlcyhjb2xsZWN0aW9uOiBTZW1hbnRpY0NvbnRleHRbXSk6IFNlbWFudGljQ29udGV4dC5QcmVjZWRlbmNlUHJlZGljYXRlW10ge1xyXG5cdFx0bGV0IHJlc3VsdDogU2VtYW50aWNDb250ZXh0LlByZWNlZGVuY2VQcmVkaWNhdGVbXSA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjb250ZXh0OiBTZW1hbnRpY0NvbnRleHQgPSBjb2xsZWN0aW9uW2ldO1xyXG5cdFx0XHRpZiAoY29udGV4dCBpbnN0YW5jZW9mIFNlbWFudGljQ29udGV4dC5QcmVjZWRlbmNlUHJlZGljYXRlKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goY29udGV4dCk7XHJcblxyXG5cdFx0XHRcdC8vIFJlbW92ZSB0aGUgaXRlbSBmcm9tICdjb2xsZWN0aW9uJyBhbmQgbW92ZSBpIGJhY2sgc28gd2UgbG9vayBhdCB0aGUgc2FtZSBpbmRleCBhZ2FpblxyXG5cdFx0XHRcdGNvbGxlY3Rpb24uc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdGktLTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHRleHBvcnQgY2xhc3MgUHJlZGljYXRlIGV4dGVuZHMgU2VtYW50aWNDb250ZXh0IHtcclxuXHRcdHB1YmxpYyBydWxlSW5kZXg6IG51bWJlcjtcclxuXHRcdHB1YmxpYyBwcmVkSW5kZXg6IG51bWJlcjtcclxuXHRcdHB1YmxpYyBpc0N0eERlcGVuZGVudDogYm9vbGVhbjsgICAvLyBlLmcuLCAkaSByZWYgaW4gcHJlZFxyXG5cclxuXHRcdGNvbnN0cnVjdG9yKCk7XHJcblx0XHRjb25zdHJ1Y3RvcihydWxlSW5kZXg6IG51bWJlciwgcHJlZEluZGV4OiBudW1iZXIsIGlzQ3R4RGVwZW5kZW50OiBib29sZWFuKTtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcihydWxlSW5kZXg6IG51bWJlciA9IC0xLCBwcmVkSW5kZXg6IG51bWJlciA9IC0xLCBpc0N0eERlcGVuZGVudDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcblx0XHRcdHN1cGVyKCk7XHJcblx0XHRcdHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4O1xyXG5cdFx0XHR0aGlzLnByZWRJbmRleCA9IHByZWRJbmRleDtcclxuXHRcdFx0dGhpcy5pc0N0eERlcGVuZGVudCA9IGlzQ3R4RGVwZW5kZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGV2YWw8VD4ocGFyc2VyOiBSZWNvZ25pemVyPFQsIGFueT4sIHBhcnNlckNhbGxTdGFjazogUnVsZUNvbnRleHQpOiBib29sZWFuIHtcclxuXHRcdFx0bGV0IGxvY2FsY3R4OiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCA9IHRoaXMuaXNDdHhEZXBlbmRlbnQgPyBwYXJzZXJDYWxsU3RhY2sgOiB1bmRlZmluZWQ7XHJcblx0XHRcdHJldHVybiBwYXJzZXIuc2VtcHJlZChsb2NhbGN0eCwgdGhpcy5ydWxlSW5kZXgsIHRoaXMucHJlZEluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0XHRsZXQgaGFzaENvZGU6IG51bWJlciA9IE11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xyXG5cdFx0XHRoYXNoQ29kZSA9IE11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCB0aGlzLnJ1bGVJbmRleCk7XHJcblx0XHRcdGhhc2hDb2RlID0gTXVybXVySGFzaC51cGRhdGUoaGFzaENvZGUsIHRoaXMucHJlZEluZGV4KTtcclxuXHRcdFx0aGFzaENvZGUgPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5pc0N0eERlcGVuZGVudCA/IDEgOiAwKTtcclxuXHRcdFx0aGFzaENvZGUgPSBNdXJtdXJIYXNoLmZpbmlzaChoYXNoQ29kZSwgMyk7XHJcblx0XHRcdHJldHVybiBoYXNoQ29kZTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdFx0aWYgKCEob2JqIGluc3RhbmNlb2YgUHJlZGljYXRlKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcyA9PT0gb2JqKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXMucnVsZUluZGV4ID09PSBvYmoucnVsZUluZGV4ICYmXHJcblx0XHRcdFx0dGhpcy5wcmVkSW5kZXggPT09IG9iai5wcmVkSW5kZXggJiZcclxuXHRcdFx0XHR0aGlzLmlzQ3R4RGVwZW5kZW50ID09PSBvYmouaXNDdHhEZXBlbmRlbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdFx0cmV0dXJuIFwie1wiICsgdGhpcy5ydWxlSW5kZXggKyBcIjpcIiArIHRoaXMucHJlZEluZGV4ICsgXCJ9P1wiO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZXhwb3J0IGNsYXNzIFByZWNlZGVuY2VQcmVkaWNhdGUgZXh0ZW5kcyBTZW1hbnRpY0NvbnRleHQgaW1wbGVtZW50cyBDb21wYXJhYmxlPFByZWNlZGVuY2VQcmVkaWNhdGU+IHtcclxuXHRcdHB1YmxpYyBwcmVjZWRlbmNlOiBudW1iZXI7XHJcblxyXG5cdFx0Y29uc3RydWN0b3IocHJlY2VkZW5jZTogbnVtYmVyKSB7XHJcblx0XHRcdHN1cGVyKCk7XHJcblx0XHRcdHRoaXMucHJlY2VkZW5jZSA9IHByZWNlZGVuY2U7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgZXZhbDxUPihwYXJzZXI6IFJlY29nbml6ZXI8VCwgYW55PiwgcGFyc2VyQ2FsbFN0YWNrOiBSdWxlQ29udGV4dCk6IGJvb2xlYW4ge1xyXG5cdFx0XHRyZXR1cm4gcGFyc2VyLnByZWNwcmVkKHBhcnNlckNhbGxTdGFjaywgdGhpcy5wcmVjZWRlbmNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBldmFsUHJlY2VkZW5jZShwYXJzZXI6IFJlY29nbml6ZXI8YW55LCBhbnk+LCBwYXJzZXJDYWxsU3RhY2s6IFJ1bGVDb250ZXh0KTogU2VtYW50aWNDb250ZXh0IHwgdW5kZWZpbmVkIHtcclxuXHRcdFx0aWYgKHBhcnNlci5wcmVjcHJlZChwYXJzZXJDYWxsU3RhY2ssIHRoaXMucHJlY2VkZW5jZSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gU2VtYW50aWNDb250ZXh0Lk5PTkU7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGNvbXBhcmVUbyhvOiBQcmVjZWRlbmNlUHJlZGljYXRlKTogbnVtYmVyIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY2VkZW5jZSAtIG8ucHJlY2VkZW5jZTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0XHRsZXQgaGFzaENvZGU6IG51bWJlciA9IDE7XHJcblx0XHRcdGhhc2hDb2RlID0gMzEgKiBoYXNoQ29kZSArIHRoaXMucHJlY2VkZW5jZTtcclxuXHRcdFx0cmV0dXJuIGhhc2hDb2RlO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0XHRpZiAoIShvYmogaW5zdGFuY2VvZiBQcmVjZWRlbmNlUHJlZGljYXRlKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXMgPT09IG9iaikge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjZWRlbmNlID09PSBvYmoucHJlY2VkZW5jZTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdC8vIHByZWNlZGVuY2UgPj0gX3ByZWNlZGVuY2VTdGFjay5wZWVrKClcclxuXHRcdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0XHRyZXR1cm4gXCJ7XCIgKyB0aGlzLnByZWNlZGVuY2UgKyBcIj49cHJlY30/XCI7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBzZW1hbnRpYyBjb250ZXh0IFwib3BlcmF0b3JzXCIsIHdoaWNoIG9wZXJhdGUgb25cclxuXHQgKiBhIGNvbGxlY3Rpb24gb2Ygc2VtYW50aWMgY29udGV4dCBcIm9wZXJhbmRzXCIuXHJcblx0ICpcclxuXHQgKiBAc2luY2UgNC4zXHJcblx0ICovXHJcblx0ZXhwb3J0IGFic3RyYWN0IGNsYXNzIE9wZXJhdG9yIGV4dGVuZHMgU2VtYW50aWNDb250ZXh0IHtcclxuXHRcdC8qKlxyXG5cdFx0ICogR2V0cyB0aGUgb3BlcmFuZHMgZm9yIHRoZSBzZW1hbnRpYyBjb250ZXh0IG9wZXJhdG9yLlxyXG5cdFx0ICpcclxuXHRcdCAqIEByZXR1cm5zIGEgY29sbGVjdGlvbiBvZiB7QGxpbmsgU2VtYW50aWNDb250ZXh0fSBvcGVyYW5kcyBmb3IgdGhlXHJcblx0XHQgKiBvcGVyYXRvci5cclxuXHRcdCAqXHJcblx0XHQgKiBAc2luY2UgNC4zXHJcblx0XHQgKi9cclxuXHRcdC8vIEBOb3ROdWxsXHJcblx0XHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgb3BlcmFuZHM6IEl0ZXJhYmxlPFNlbWFudGljQ29udGV4dD47XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBIHNlbWFudGljIGNvbnRleHQgd2hpY2ggaXMgdHJ1ZSB3aGVuZXZlciBub25lIG9mIHRoZSBjb250YWluZWQgY29udGV4dHNcclxuXHQgKiBpcyBmYWxzZS5cclxuXHQgKi9cclxuXHRleHBvcnQgY2xhc3MgQU5EIGV4dGVuZHMgT3BlcmF0b3Ige1xyXG5cdFx0cHVibGljIG9wbmRzOiBTZW1hbnRpY0NvbnRleHRbXTtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcihATm90TnVsbCBhOiBTZW1hbnRpY0NvbnRleHQsIEBOb3ROdWxsIGI6IFNlbWFudGljQ29udGV4dCkge1xyXG5cdFx0XHRzdXBlcigpO1xyXG5cclxuXHRcdFx0bGV0IG9wZXJhbmRzOiBBcnJheTJESGFzaFNldDxTZW1hbnRpY0NvbnRleHQ+ID0gbmV3IEFycmF5MkRIYXNoU2V0PFNlbWFudGljQ29udGV4dD4oT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcclxuXHRcdFx0aWYgKGEgaW5zdGFuY2VvZiBBTkQpIHtcclxuXHRcdFx0XHRvcGVyYW5kcy5hZGRBbGwoYS5vcG5kcyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3BlcmFuZHMuYWRkKGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoYiBpbnN0YW5jZW9mIEFORCkge1xyXG5cdFx0XHRcdG9wZXJhbmRzLmFkZEFsbChiLm9wbmRzKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcGVyYW5kcy5hZGQoYik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMub3BuZHMgPSBvcGVyYW5kcy50b0FycmF5KCk7XHJcblx0XHRcdGxldCBwcmVjZWRlbmNlUHJlZGljYXRlczogUHJlY2VkZW5jZVByZWRpY2F0ZVtdID0gZmlsdGVyUHJlY2VkZW5jZVByZWRpY2F0ZXModGhpcy5vcG5kcyk7XHJcblxyXG5cdFx0XHQvLyBpbnRlcmVzdGVkIGluIHRoZSB0cmFuc2l0aW9uIHdpdGggdGhlIGxvd2VzdCBwcmVjZWRlbmNlXHJcblx0XHRcdGxldCByZWR1Y2VkID0gbWluKHByZWNlZGVuY2VQcmVkaWNhdGVzKTtcclxuXHRcdFx0aWYgKHJlZHVjZWQpIHtcclxuXHRcdFx0XHR0aGlzLm9wbmRzLnB1c2gocmVkdWNlZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdGdldCBvcGVyYW5kcygpOiBJdGVyYWJsZTxTZW1hbnRpY0NvbnRleHQ+IHtcclxuXHRcdFx0cmV0dXJuIHRoaXMub3BuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbiB7XHJcblx0XHRcdGlmICh0aGlzID09PSBvYmopIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIShvYmogaW5zdGFuY2VvZiBBTkQpKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBBcnJheUVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRS5lcXVhbHModGhpcy5vcG5kcywgb2JqLm9wbmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0XHRyZXR1cm4gTXVybXVySGFzaC5oYXNoQ29kZSh0aGlzLm9wbmRzLCBBTkRfSEFTSENPREUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdFx0ICpcclxuXHRcdCAqIFRoZSBldmFsdWF0aW9uIG9mIHByZWRpY2F0ZXMgYnkgdGhpcyBjb250ZXh0IGlzIHNob3J0LWNpcmN1aXRpbmcsIGJ1dFxyXG5cdFx0ICogdW5vcmRlcmVkLlxyXG5cdFx0ICovXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBldmFsPFQ+KHBhcnNlcjogUmVjb2duaXplcjxULCBhbnk+LCBwYXJzZXJDYWxsU3RhY2s6IFJ1bGVDb250ZXh0KTogYm9vbGVhbiB7XHJcblx0XHRcdGZvciAobGV0IG9wbmQgb2YgdGhpcy5vcG5kcykge1xyXG5cdFx0XHRcdGlmICghb3BuZC5ldmFsKHBhcnNlciwgcGFyc2VyQ2FsbFN0YWNrKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgZXZhbFByZWNlZGVuY2UocGFyc2VyOiBSZWNvZ25pemVyPGFueSwgYW55PiwgcGFyc2VyQ2FsbFN0YWNrOiBSdWxlQ29udGV4dCk6IFNlbWFudGljQ29udGV4dCB8IHVuZGVmaW5lZCB7XHJcblx0XHRcdGxldCBkaWZmZXJzOiBib29sZWFuID0gZmFsc2U7XHJcblx0XHRcdGxldCBvcGVyYW5kczogU2VtYW50aWNDb250ZXh0W10gPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgY29udGV4dCBvZiB0aGlzLm9wbmRzKSB7XHJcblx0XHRcdFx0bGV0IGV2YWx1YXRlZDogU2VtYW50aWNDb250ZXh0IHwgdW5kZWZpbmVkID0gY29udGV4dC5ldmFsUHJlY2VkZW5jZShwYXJzZXIsIHBhcnNlckNhbGxTdGFjayk7XHJcblx0XHRcdFx0ZGlmZmVycyA9IGRpZmZlcnMgfHwgKGV2YWx1YXRlZCAhPT0gY29udGV4dCk7XHJcblx0XHRcdFx0aWYgKGV2YWx1YXRlZCA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHQvLyBUaGUgQU5EIGNvbnRleHQgaXMgZmFsc2UgaWYgYW55IGVsZW1lbnQgaXMgZmFsc2VcclxuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKGV2YWx1YXRlZCAhPT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcclxuXHRcdFx0XHRcdC8vIFJlZHVjZSB0aGUgcmVzdWx0IGJ5IHNraXBwaW5nIHRydWUgZWxlbWVudHNcclxuXHRcdFx0XHRcdG9wZXJhbmRzLnB1c2goZXZhbHVhdGVkKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghZGlmZmVycykge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAob3BlcmFuZHMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0Ly8gYWxsIGVsZW1lbnRzIHdlcmUgdHJ1ZSwgc28gdGhlIEFORCBjb250ZXh0IGlzIHRydWVcclxuXHRcdFx0XHRyZXR1cm4gU2VtYW50aWNDb250ZXh0Lk5PTkU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCByZXN1bHQ6IFNlbWFudGljQ29udGV4dCA9IG9wZXJhbmRzWzBdO1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IG9wZXJhbmRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0cmVzdWx0ID0gU2VtYW50aWNDb250ZXh0LmFuZChyZXN1bHQsIG9wZXJhbmRzW2ldKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0XHRyZXR1cm4gVXRpbHMuam9pbih0aGlzLm9wbmRzLCBcIiYmXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQSBzZW1hbnRpYyBjb250ZXh0IHdoaWNoIGlzIHRydWUgd2hlbmV2ZXIgYXQgbGVhc3Qgb25lIG9mIHRoZSBjb250YWluZWRcclxuXHQgKiBjb250ZXh0cyBpcyB0cnVlLlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBjbGFzcyBPUiBleHRlbmRzIE9wZXJhdG9yIHtcclxuXHRcdHB1YmxpYyBvcG5kczogU2VtYW50aWNDb250ZXh0W107XHJcblxyXG5cdFx0Y29uc3RydWN0b3IoQE5vdE51bGwgYTogU2VtYW50aWNDb250ZXh0LCBATm90TnVsbCBiOiBTZW1hbnRpY0NvbnRleHQpIHtcclxuXHRcdFx0c3VwZXIoKTtcclxuXHJcblx0XHRcdGxldCBvcGVyYW5kczogQXJyYXkyREhhc2hTZXQ8U2VtYW50aWNDb250ZXh0PiA9IG5ldyBBcnJheTJESGFzaFNldDxTZW1hbnRpY0NvbnRleHQ+KE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSk7XHJcblx0XHRcdGlmIChhIGluc3RhbmNlb2YgT1IpIHtcclxuXHRcdFx0XHRvcGVyYW5kcy5hZGRBbGwoYS5vcG5kcyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3BlcmFuZHMuYWRkKGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoYiBpbnN0YW5jZW9mIE9SKSB7XHJcblx0XHRcdFx0b3BlcmFuZHMuYWRkQWxsKGIub3BuZHMpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wZXJhbmRzLmFkZChiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5vcG5kcyA9IG9wZXJhbmRzLnRvQXJyYXkoKTtcclxuXHRcdFx0bGV0IHByZWNlZGVuY2VQcmVkaWNhdGVzOiBQcmVjZWRlbmNlUHJlZGljYXRlW10gPSBmaWx0ZXJQcmVjZWRlbmNlUHJlZGljYXRlcyh0aGlzLm9wbmRzKTtcclxuXHJcblx0XHRcdC8vIGludGVyZXN0ZWQgaW4gdGhlIHRyYW5zaXRpb24gd2l0aCB0aGUgaGlnaGVzdCBwcmVjZWRlbmNlXHJcblx0XHRcdGxldCByZWR1Y2VkID0gbWF4KHByZWNlZGVuY2VQcmVkaWNhdGVzKTtcclxuXHRcdFx0aWYgKHJlZHVjZWQpIHtcclxuXHRcdFx0XHR0aGlzLm9wbmRzLnB1c2gocmVkdWNlZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdGdldCBvcGVyYW5kcygpOiBJdGVyYWJsZTxTZW1hbnRpY0NvbnRleHQ+IHtcclxuXHRcdFx0cmV0dXJuIHRoaXMub3BuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbiB7XHJcblx0XHRcdGlmICh0aGlzID09PSBvYmopIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIShvYmogaW5zdGFuY2VvZiBPUikpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIEFycmF5RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFLmVxdWFscyh0aGlzLm9wbmRzLCBvYmoub3BuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRcdHJldHVybiBNdXJtdXJIYXNoLmhhc2hDb2RlKHRoaXMub3BuZHMsIE9SX0hBU0hDT0RFKTtcclxuXHRcdH1cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIHtAaW5oZXJpdERvY31cclxuXHRcdCAqXHJcblx0XHQgKiBUaGUgZXZhbHVhdGlvbiBvZiBwcmVkaWNhdGVzIGJ5IHRoaXMgY29udGV4dCBpcyBzaG9ydC1jaXJjdWl0aW5nLCBidXRcclxuXHRcdCAqIHVub3JkZXJlZC5cclxuXHRcdCAqL1xyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgZXZhbDxUPihwYXJzZXI6IFJlY29nbml6ZXI8VCwgYW55PiwgcGFyc2VyQ2FsbFN0YWNrOiBSdWxlQ29udGV4dCk6IGJvb2xlYW4ge1xyXG5cdFx0XHRmb3IgKGxldCBvcG5kIG9mIHRoaXMub3BuZHMpIHtcclxuXHRcdFx0XHRpZiAob3BuZC5ldmFsKHBhcnNlciwgcGFyc2VyQ2FsbFN0YWNrKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgZXZhbFByZWNlZGVuY2UocGFyc2VyOiBSZWNvZ25pemVyPGFueSwgYW55PiwgcGFyc2VyQ2FsbFN0YWNrOiBSdWxlQ29udGV4dCk6IFNlbWFudGljQ29udGV4dCB8IHVuZGVmaW5lZCB7XHJcblx0XHRcdGxldCBkaWZmZXJzOiBib29sZWFuID0gZmFsc2U7XHJcblx0XHRcdGxldCBvcGVyYW5kczogU2VtYW50aWNDb250ZXh0W10gPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgY29udGV4dCBvZiB0aGlzLm9wbmRzKSB7XHJcblx0XHRcdFx0bGV0IGV2YWx1YXRlZDogU2VtYW50aWNDb250ZXh0IHwgdW5kZWZpbmVkID0gY29udGV4dC5ldmFsUHJlY2VkZW5jZShwYXJzZXIsIHBhcnNlckNhbGxTdGFjayk7XHJcblx0XHRcdFx0ZGlmZmVycyA9IGRpZmZlcnMgfHwgKGV2YWx1YXRlZCAhPT0gY29udGV4dCk7XHJcblx0XHRcdFx0aWYgKGV2YWx1YXRlZCA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcclxuXHRcdFx0XHRcdC8vIFRoZSBPUiBjb250ZXh0IGlzIHRydWUgaWYgYW55IGVsZW1lbnQgaXMgdHJ1ZVxyXG5cdFx0XHRcdFx0cmV0dXJuIFNlbWFudGljQ29udGV4dC5OT05FO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoZXZhbHVhdGVkKSB7XHJcblx0XHRcdFx0XHQvLyBSZWR1Y2UgdGhlIHJlc3VsdCBieSBza2lwcGluZyBmYWxzZSBlbGVtZW50c1xyXG5cdFx0XHRcdFx0b3BlcmFuZHMucHVzaChldmFsdWF0ZWQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFkaWZmZXJzKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvcGVyYW5kcy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHQvLyBhbGwgZWxlbWVudHMgd2VyZSBmYWxzZSwgc28gdGhlIE9SIGNvbnRleHQgaXMgZmFsc2VcclxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgcmVzdWx0OiBTZW1hbnRpY0NvbnRleHQgPSBvcGVyYW5kc1swXTtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBvcGVyYW5kcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHJlc3VsdCA9IFNlbWFudGljQ29udGV4dC5vcihyZXN1bHQsIG9wZXJhbmRzW2ldKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0XHRyZXR1cm4gVXRpbHMuam9pbih0aGlzLm9wbmRzLCBcInx8XCIpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzUuMjgyNjk2MC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBTZW1hbnRpY0NvbnRleHQgfSBmcm9tIFwiLi9TZW1hbnRpY0NvbnRleHRcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvblR5cGUgfSBmcm9tIFwiLi9UcmFuc2l0aW9uVHlwZVwiO1xyXG5cclxuLyoqIFRPRE86IHRoaXMgaXMgb2xkIGNvbW1lbnQ6XHJcbiAqICBBIHRyZWUgb2Ygc2VtYW50aWMgcHJlZGljYXRlcyBmcm9tIHRoZSBncmFtbWFyIEFTVCBpZiBsYWJlbD09U0VNUFJFRC5cclxuICogIEluIHRoZSBBVE4sIGxhYmVscyB3aWxsIGFsd2F5cyBiZSBleGFjdGx5IG9uZSBwcmVkaWNhdGUsIGJ1dCB0aGUgREZBXHJcbiAqICBtYXkgaGF2ZSB0byBjb21iaW5lIGEgYnVuY2ggb2YgdGhlbSBhcyBpdCBjb2xsZWN0cyBwcmVkaWNhdGVzIGZyb21cclxuICogIG11bHRpcGxlIEFUTiBjb25maWd1cmF0aW9ucyBpbnRvIGEgc2luZ2xlIERGQSBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcmVkaWNhdGVUcmFuc2l0aW9uIGV4dGVuZHMgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uIHtcclxuXHRwdWJsaWMgcnVsZUluZGV4OiBudW1iZXI7XHJcblx0cHVibGljIHByZWRJbmRleDogbnVtYmVyO1xyXG5cdHB1YmxpYyBpc0N0eERlcGVuZGVudDogYm9vbGVhbjsgICAvLyBlLmcuLCAkaSByZWYgaW4gcHJlZFxyXG5cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCB0YXJnZXQ6IEFUTlN0YXRlLCBydWxlSW5kZXg6IG51bWJlciwgcHJlZEluZGV4OiBudW1iZXIsIGlzQ3R4RGVwZW5kZW50OiBib29sZWFuKSB7XHJcblx0XHRzdXBlcih0YXJnZXQpO1xyXG5cdFx0dGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XHJcblx0XHR0aGlzLnByZWRJbmRleCA9IHByZWRJbmRleDtcclxuXHRcdHRoaXMuaXNDdHhEZXBlbmRlbnQgPSBpc0N0eERlcGVuZGVudDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzZXJpYWxpemF0aW9uVHlwZSgpOiBUcmFuc2l0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gVHJhbnNpdGlvblR5cGUuUFJFRElDQVRFO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzRXBzaWxvbigpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG1hdGNoZXMoc3ltYm9sOiBudW1iZXIsIG1pblZvY2FiU3ltYm9sOiBudW1iZXIsIG1heFZvY2FiU3ltYm9sOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdGdldCBwcmVkaWNhdGUoKTogU2VtYW50aWNDb250ZXh0LlByZWRpY2F0ZSB7XHJcblx0XHRyZXR1cm4gbmV3IFNlbWFudGljQ29udGV4dC5QcmVkaWNhdGUodGhpcy5ydWxlSW5kZXgsIHRoaXMucHJlZEluZGV4LCB0aGlzLmlzQ3R4RGVwZW5kZW50KTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCJwcmVkX1wiICsgdGhpcy5ydWxlSW5kZXggKyBcIjpcIiArIHRoaXMucHJlZEluZGV4O1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTEuNDA5OTk0Ni0wNzowMFxyXG5cclxuaW1wb3J0IHsgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vYXRuL0Fic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9hdG4vQVROXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vYXRuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFByZWRpY2F0ZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9hdG4vUHJlZGljYXRlVHJhbnNpdGlvblwiO1xyXG5cclxuLyoqIEEgc2VtYW50aWMgcHJlZGljYXRlIGZhaWxlZCBkdXJpbmcgdmFsaWRhdGlvbi4gIFZhbGlkYXRpb24gb2YgcHJlZGljYXRlc1xyXG4gKiAgb2NjdXJzIHdoZW4gbm9ybWFsbHkgcGFyc2luZyB0aGUgYWx0ZXJuYXRpdmUganVzdCBsaWtlIG1hdGNoaW5nIGEgdG9rZW4uXHJcbiAqICBEaXNhbWJpZ3VhdGluZyBwcmVkaWNhdGUgZXZhbHVhdGlvbiBvY2N1cnMgd2hlbiB3ZSB0ZXN0IGEgcHJlZGljYXRlIGR1cmluZ1xyXG4gKiAgcHJlZGljdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24gZXh0ZW5kcyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB7XHJcblx0Ly9wcml2YXRlIHN0YXRpYyBzZXJpYWxWZXJzaW9uVUlEOiBudW1iZXIgPSAgNTM3OTMzMDg0MTQ5NTc3ODcwOUw7XHJcblxyXG5cdHByaXZhdGUgX3J1bGVJbmRleDogbnVtYmVyO1xyXG5cdHByaXZhdGUgX3ByZWRpY2F0ZUluZGV4OiBudW1iZXI7XHJcblx0cHJpdmF0ZSBfcHJlZGljYXRlPzogc3RyaW5nO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIsIHByZWRpY2F0ZT86IHN0cmluZywgbWVzc2FnZT86IHN0cmluZykge1xyXG5cdFx0c3VwZXIoXHJcblx0XHRcdHJlY29nbml6ZXIsXHJcblx0XHRcdHJlY29nbml6ZXIuaW5wdXRTdHJlYW0sXHJcblx0XHRcdHJlY29nbml6ZXIuY29udGV4dCxcclxuXHRcdFx0RmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uLmZvcm1hdE1lc3NhZ2UocHJlZGljYXRlLCBtZXNzYWdlKSk7XHJcblx0XHRsZXQgczogQVROU3RhdGUgPSByZWNvZ25pemVyLmludGVycHJldGVyLmF0bi5zdGF0ZXNbcmVjb2duaXplci5zdGF0ZV07XHJcblxyXG5cdFx0bGV0IHRyYW5zID0gcy50cmFuc2l0aW9uKDApIGFzIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbjtcclxuXHRcdGlmICh0cmFucyBpbnN0YW5jZW9mIFByZWRpY2F0ZVRyYW5zaXRpb24pIHtcclxuXHRcdFx0dGhpcy5fcnVsZUluZGV4ID0gdHJhbnMucnVsZUluZGV4O1xyXG5cdFx0XHR0aGlzLl9wcmVkaWNhdGVJbmRleCA9IHRyYW5zLnByZWRJbmRleDtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9ydWxlSW5kZXggPSAwO1xyXG5cdFx0XHR0aGlzLl9wcmVkaWNhdGVJbmRleCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcHJlZGljYXRlID0gcHJlZGljYXRlO1xyXG5cdFx0c3VwZXIuc2V0T2ZmZW5kaW5nVG9rZW4ocmVjb2duaXplciwgcmVjb2duaXplci5jdXJyZW50VG9rZW4pO1xyXG5cdH1cclxuXHJcblx0Z2V0IHJ1bGVJbmRleCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3J1bGVJbmRleDtcclxuXHR9XHJcblxyXG5cdGdldCBwcmVkaWNhdGVJbmRleCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3ByZWRpY2F0ZUluZGV4O1xyXG5cdH1cclxuXHJcblx0Z2V0IHByZWRpY2F0ZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3ByZWRpY2F0ZTtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSBzdGF0aWMgZm9ybWF0TWVzc2FnZShwcmVkaWNhdGU6IHN0cmluZyB8IHVuZGVmaW5lZCwgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcclxuXHRcdGlmIChtZXNzYWdlKSB7XHJcblx0XHRcdHJldHVybiBtZXNzYWdlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBgZmFpbGVkIHByZWRpY2F0ZTogeyR7cHJlZGljYXRlfX0/YDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUxLjUxODc2ODItMDc6MDBcclxuXHJcbmltcG9ydCB7IFJlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4vUmVjb2duaXRpb25FeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuXHJcbi8qKiBUaGlzIHNpZ25pZmllcyBhbnkga2luZCBvZiBtaXNtYXRjaGVkIGlucHV0IGV4Y2VwdGlvbnMgc3VjaCBhc1xyXG4gKiAgd2hlbiB0aGUgY3VycmVudCBpbnB1dCBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgdG9rZW4uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbiBleHRlbmRzIFJlY29nbml0aW9uRXhjZXB0aW9uIHtcclxuXHQvL3ByaXZhdGUgc3RhdGljIHNlcmlhbFZlcnNpb25VSUQ6IG51bWJlciA9ICAxNTMyNTY4MzM4NzA3NDQzMDY3TDtcclxuXHJcblx0Y29uc3RydWN0b3IoLypATm90TnVsbCovIHJlY29nbml6ZXI6IFBhcnNlcik7XHJcblx0Y29uc3RydWN0b3IoLypATm90TnVsbCovIHJlY29nbml6ZXI6IFBhcnNlciwgc3RhdGU6IG51bWJlciwgY29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQpO1xyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlciwgc3RhdGU/OiBudW1iZXIsIGNvbnRleHQ/OiBQYXJzZXJSdWxlQ29udGV4dCkge1xyXG5cdFx0aWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRjb250ZXh0ID0gcmVjb2duaXplci5jb250ZXh0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHN1cGVyKHJlY29nbml6ZXIsIHJlY29nbml6ZXIuaW5wdXRTdHJlYW0sIGNvbnRleHQpO1xyXG5cclxuXHRcdGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc2V0T2ZmZW5kaW5nU3RhdGUoc3RhdGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0T2ZmZW5kaW5nVG9rZW4ocmVjb2duaXplciwgcmVjb2duaXplci5jdXJyZW50VG9rZW4pO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIEFycmF5cyB7XHJcblx0LyoqXHJcblx0ICogU2VhcmNoZXMgdGhlIHNwZWNpZmllZCBhcnJheSBvZiBudW1iZXJzIGZvciB0aGUgc3BlY2lmaWVkIHZhbHVlIHVzaW5nIHRoZSBiaW5hcnkgc2VhcmNoIGFsZ29yaXRobS4gVGhlIGFycmF5IG11c3RcclxuXHQgKiBiZSBzb3J0ZWQgcHJpb3IgdG8gbWFraW5nIHRoaXMgY2FsbC4gSWYgaXQgaXMgbm90IHNvcnRlZCwgdGhlIHJlc3VsdHMgYXJlIHVuc3BlY2lmaWVkLiBJZiB0aGUgYXJyYXkgY29udGFpbnNcclxuXHQgKiBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWUsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB3aGljaCBvbmUgd2lsbCBiZSBmb3VuZC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIGluZGV4IG9mIHRoZSBzZWFyY2gga2V5LCBpZiBpdCBpcyBjb250YWluZWQgaW4gdGhlIGFycmF5OyBvdGhlcndpc2UsICgtKGluc2VydGlvbiBwb2ludCkgLSAxKS4gVGhlXHJcblx0ICogaW5zZXJ0aW9uIHBvaW50IGlzIGRlZmluZWQgYXMgdGhlIHBvaW50IGF0IHdoaWNoIHRoZSBrZXkgd291bGQgYmUgaW5zZXJ0ZWQgaW50byB0aGUgYXJyYXk6IHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcclxuXHQgKiBlbGVtZW50IGdyZWF0ZXIgdGhhbiB0aGUga2V5LCBvciBhcnJheS5sZW5ndGggaWYgYWxsIGVsZW1lbnRzIGluIHRoZSBhcnJheSBhcmUgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQga2V5LiBOb3RlXHJcblx0ICogdGhhdCB0aGlzIGd1YXJhbnRlZXMgdGhhdCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgPj0gMCBpZiBhbmQgb25seSBpZiB0aGUga2V5IGlzIGZvdW5kLlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2goYXJyYXk6IEFycmF5TGlrZTxudW1iZXI+LCBrZXk6IG51bWJlciwgZnJvbUluZGV4PzogbnVtYmVyLCB0b0luZGV4PzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBiaW5hcnlTZWFyY2gwKGFycmF5LCBmcm9tSW5kZXggIT09IHVuZGVmaW5lZCA/IGZyb21JbmRleCA6IDAsIHRvSW5kZXggIT09IHVuZGVmaW5lZCA/IHRvSW5kZXggOiBhcnJheS5sZW5ndGgsIGtleSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBiaW5hcnlTZWFyY2gwKGFycmF5OiBBcnJheUxpa2U8bnVtYmVyPiwgZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg6IG51bWJlciwga2V5OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0bGV0IGxvdzogbnVtYmVyID0gZnJvbUluZGV4O1xyXG5cdFx0bGV0IGhpZ2g6IG51bWJlciA9IHRvSW5kZXggLSAxO1xyXG5cclxuXHRcdHdoaWxlIChsb3cgPD0gaGlnaCkge1xyXG5cdFx0XHRsZXQgbWlkOiBudW1iZXIgPSAobG93ICsgaGlnaCkgPj4+IDE7XHJcblx0XHRcdGxldCBtaWRWYWw6IG51bWJlciA9IGFycmF5W21pZF07XHJcblxyXG5cdFx0XHRpZiAobWlkVmFsIDwga2V5KSB7XHJcblx0XHRcdFx0bG93ID0gbWlkICsgMTtcclxuXHRcdFx0fSBlbHNlIGlmIChtaWRWYWwgPiBrZXkpIHtcclxuXHRcdFx0XHRoaWdoID0gbWlkIC0gMTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBrZXkgZm91bmRcclxuXHRcdFx0XHRyZXR1cm4gbWlkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8ga2V5IG5vdCBmb3VuZC5cclxuXHRcdHJldHVybiAtKGxvdyArIDEpO1xyXG5cdH1cclxuXHJcblx0ZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nPFQ+KGFycmF5OiBJdGVyYWJsZTxUPikge1xyXG5cdFx0bGV0IHJlc3VsdCA9IFwiW1wiO1xyXG5cclxuXHRcdGxldCBmaXJzdCA9IHRydWU7XHJcblx0XHRmb3IgKGxldCBlbGVtZW50IG9mIGFycmF5KSB7XHJcblx0XHRcdGlmIChmaXJzdCkge1xyXG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0ICs9IFwiLCBcIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGVsZW1lbnQgPT09IG51bGwpIHtcclxuXHRcdFx0XHRyZXN1bHQgKz0gXCJudWxsXCI7XHJcblx0XHRcdH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0cmVzdWx0ICs9IFwidW5kZWZpbmVkXCI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0ICs9IGVsZW1lbnQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXN1bHQgKz0gXCJdXCI7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDAuNTA5OTQyOS0wNzowMFxyXG5cclxuaW1wb3J0IHsgQXJyYXlzIH0gZnJvbSBcIi4vQXJyYXlzXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgSmF2YUNvbGxlY3Rpb24gfSBmcm9tIFwiLi9TdHVic1wiO1xyXG5cclxuY29uc3QgRU1QVFlfREFUQTogSW50MzJBcnJheSA9IG5ldyBJbnQzMkFycmF5KDApO1xyXG5cclxuY29uc3QgSU5JVElBTF9TSVpFOiBudW1iZXIgPSA0O1xyXG5jb25zdCBNQVhfQVJSQVlfU0laRTogbnVtYmVyID0gKCgoMSA8PCAzMSkgPj4+IDApIC0gMSkgLSA4O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbnRlZ2VyTGlzdCB7XHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIF9kYXRhOiBJbnQzMkFycmF5O1xyXG5cclxuXHRwcml2YXRlIF9zaXplOiBudW1iZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFyZz86IG51bWJlciB8IEludGVnZXJMaXN0IHwgSXRlcmFibGU8bnVtYmVyPikge1xyXG5cdFx0aWYgKCFhcmcpIHtcclxuXHRcdFx0dGhpcy5fZGF0YSA9IEVNUFRZX0RBVEE7XHJcblx0XHRcdHRoaXMuX3NpemUgPSAwO1xyXG5cdFx0fSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBJbnRlZ2VyTGlzdCkge1xyXG5cdFx0XHR0aGlzLl9kYXRhID0gYXJnLl9kYXRhLnNsaWNlKDApO1xyXG5cdFx0XHR0aGlzLl9zaXplID0gYXJnLl9zaXplO1xyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdGlmIChhcmcgPT09IDApIHtcclxuXHRcdFx0XHR0aGlzLl9kYXRhID0gRU1QVFlfREFUQTtcclxuXHRcdFx0XHR0aGlzLl9zaXplID0gMDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLl9kYXRhID0gbmV3IEludDMyQXJyYXkoYXJnKTtcclxuXHRcdFx0XHR0aGlzLl9zaXplID0gMDtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gYXJnIGlzIEl0ZXJhYmxlPG51bWJlcj5cclxuXHRcdFx0dGhpcy5fZGF0YSA9IEVNUFRZX0RBVEE7XHJcblx0XHRcdHRoaXMuX3NpemUgPSAwO1xyXG5cdFx0XHRmb3IgKGxldCB2YWx1ZSBvZiBhcmcpIHtcclxuXHRcdFx0XHR0aGlzLmFkZCh2YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhZGQodmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuX2RhdGEubGVuZ3RoID09PSB0aGlzLl9zaXplKSB7XHJcblx0XHRcdHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5fc2l6ZSArIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2RhdGFbdGhpcy5fc2l6ZV0gPSB2YWx1ZTtcclxuXHRcdHRoaXMuX3NpemUrKztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhZGRBbGwobGlzdDogbnVtYmVyW10gfCBJbnRlZ2VyTGlzdCB8IEphdmFDb2xsZWN0aW9uPG51bWJlcj4pOiB2b2lkIHtcclxuXHRcdGlmIChBcnJheS5pc0FycmF5KGxpc3QpKSB7XHJcblx0XHRcdHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5fc2l6ZSArIGxpc3QubGVuZ3RoKTtcclxuXHRcdFx0dGhpcy5fZGF0YS5zdWJhcnJheSh0aGlzLl9zaXplLCB0aGlzLl9zaXplICsgbGlzdC5sZW5ndGgpLnNldChsaXN0KTtcclxuXHRcdFx0dGhpcy5fc2l6ZSArPSBsaXN0Lmxlbmd0aDtcclxuXHRcdH0gZWxzZSBpZiAobGlzdCBpbnN0YW5jZW9mIEludGVnZXJMaXN0KSB7XHJcblx0XHRcdHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5fc2l6ZSArIGxpc3QuX3NpemUpO1xyXG5cdFx0XHR0aGlzLl9kYXRhLnN1YmFycmF5KHRoaXMuX3NpemUsIHRoaXMuX3NpemUgKyBsaXN0LnNpemUpLnNldChsaXN0Ll9kYXRhKTtcclxuXHRcdFx0dGhpcy5fc2l6ZSArPSBsaXN0Ll9zaXplO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gbGlzdCBpcyBKYXZhQ29sbGVjdGlvbjxudW1iZXI+XHJcblx0XHRcdHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5fc2l6ZSArIGxpc3Quc2l6ZSk7XHJcblx0XHRcdGxldCBjdXJyZW50OiBudW1iZXIgPSAwO1xyXG5cdFx0XHRmb3IgKGxldCB4aSBvZiBsaXN0KSB7XHJcblx0XHRcdFx0dGhpcy5fZGF0YVt0aGlzLl9zaXplICsgY3VycmVudF0gPSB4aTtcclxuXHRcdFx0XHRjdXJyZW50Kys7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX3NpemUgKz0gbGlzdC5zaXplO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGdldChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5fc2l6ZSkge1xyXG5cdFx0XHR0aHJvdyBSYW5nZUVycm9yKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2RhdGFbaW5kZXhdO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGNvbnRhaW5zKHZhbHVlOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9kYXRhW2ldID09PSB2YWx1ZSkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldChpbmRleDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5fc2l6ZSkge1xyXG5cdFx0XHR0aHJvdyBSYW5nZUVycm9yKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHByZXZpb3VzOiBudW1iZXIgPSB0aGlzLl9kYXRhW2luZGV4XTtcclxuXHRcdHRoaXMuX2RhdGFbaW5kZXhdID0gdmFsdWU7XHJcblx0XHRyZXR1cm4gcHJldmlvdXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVtb3ZlQXQoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRsZXQgdmFsdWU6IG51bWJlciA9IHRoaXMuZ2V0KGluZGV4KTtcclxuXHRcdHRoaXMuX2RhdGEuY29weVdpdGhpbihpbmRleCwgaW5kZXggKyAxLCB0aGlzLl9zaXplKTtcclxuXHRcdHRoaXMuX2RhdGFbdGhpcy5fc2l6ZSAtIDFdID0gMDtcclxuXHRcdHRoaXMuX3NpemUtLTtcclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyByZW1vdmVSYW5nZShmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAoZnJvbUluZGV4IDwgMCB8fCB0b0luZGV4IDwgMCB8fCBmcm9tSW5kZXggPiB0aGlzLl9zaXplIHx8IHRvSW5kZXggPiB0aGlzLl9zaXplKSB7XHJcblx0XHRcdHRocm93IFJhbmdlRXJyb3IoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZnJvbUluZGV4ID4gdG9JbmRleCkge1xyXG5cdFx0XHR0aHJvdyBSYW5nZUVycm9yKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZGF0YS5jb3B5V2l0aGluKHRvSW5kZXgsIGZyb21JbmRleCwgdGhpcy5fc2l6ZSk7XHJcblx0XHR0aGlzLl9kYXRhLmZpbGwoMCwgdGhpcy5fc2l6ZSAtICh0b0luZGV4IC0gZnJvbUluZGV4KSwgdGhpcy5fc2l6ZSk7XHJcblx0XHR0aGlzLl9zaXplIC09ICh0b0luZGV4IC0gZnJvbUluZGV4KTtcclxuXHR9XHJcblxyXG5cdGdldCBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUgPT09IDA7XHJcblx0fVxyXG5cclxuXHRnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdHJpbVRvU2l6ZSgpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLl9kYXRhLmxlbmd0aCA9PT0gdGhpcy5fc2l6ZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZGF0YSA9IHRoaXMuX2RhdGEuc2xpY2UoMCwgdGhpcy5fc2l6ZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY2xlYXIoKTogdm9pZCB7XHJcblx0XHR0aGlzLl9kYXRhLmZpbGwoMCwgMCwgdGhpcy5fc2l6ZSk7XHJcblx0XHR0aGlzLl9zaXplID0gMDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b0FycmF5KCk6IG51bWJlcltdIHtcclxuXHRcdGlmICh0aGlzLl9zaXplID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBbXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9kYXRhLnN1YmFycmF5KDAsIHRoaXMuX3NpemUpKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzb3J0KCk6IHZvaWQge1xyXG5cdFx0dGhpcy5fZGF0YS5zdWJhcnJheSgwLCB0aGlzLl9zaXplKS5zb3J0KCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wYXJlcyB0aGUgc3BlY2lmaWVkIG9iamVjdCB3aXRoIHRoaXMgbGlzdCBmb3IgZXF1YWxpdHkuICBSZXR1cm5zXHJcblx0ICogYHRydWVgIGlmIGFuZCBvbmx5IGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGFsc28gYW4ge0BsaW5rIEludGVnZXJMaXN0fSxcclxuXHQgKiBib3RoIGxpc3RzIGhhdmUgdGhlIHNhbWUgc2l6ZSwgYW5kIGFsbCBjb3JyZXNwb25kaW5nIHBhaXJzIG9mIGVsZW1lbnRzIGluXHJcblx0ICogdGhlIHR3byBsaXN0cyBhcmUgZXF1YWwuICBJbiBvdGhlciB3b3JkcywgdHdvIGxpc3RzIGFyZSBkZWZpbmVkIHRvIGJlXHJcblx0ICogZXF1YWwgaWYgdGhleSBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIG9yZGVyLlxyXG5cdCAqXHJcblx0ICogVGhpcyBpbXBsZW1lbnRhdGlvbiBmaXJzdCBjaGVja3MgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgdGhpc1xyXG5cdCAqIGxpc3QuIElmIHNvLCBpdCByZXR1cm5zIGB0cnVlYDsgaWYgbm90LCBpdCBjaGVja3MgaWYgdGhlXHJcblx0ICogc3BlY2lmaWVkIG9iamVjdCBpcyBhbiB7QGxpbmsgSW50ZWdlckxpc3R9LiBJZiBub3QsIGl0IHJldHVybnMgYGZhbHNlYDtcclxuXHQgKiBpZiBzbywgaXQgY2hlY2tzIHRoZSBzaXplIG9mIGJvdGggbGlzdHMuIElmIHRoZSBsaXN0cyBhcmUgbm90IHRoZSBzYW1lIHNpemUsXHJcblx0ICogaXQgcmV0dXJucyBgZmFsc2VgOyBvdGhlcndpc2UgaXQgaXRlcmF0ZXMgb3ZlciBib3RoIGxpc3RzLCBjb21wYXJpbmdcclxuXHQgKiBjb3JyZXNwb25kaW5nIHBhaXJzIG9mIGVsZW1lbnRzLiAgSWYgYW55IGNvbXBhcmlzb24gcmV0dXJucyBgZmFsc2VgLFxyXG5cdCAqIHRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBvIHRoZSBvYmplY3QgdG8gYmUgY29tcGFyZWQgZm9yIGVxdWFsaXR5IHdpdGggdGhpcyBsaXN0XHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGVxdWFsIHRvIHRoaXMgbGlzdFxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMobzogYW55KTogYm9vbGVhbiB7XHJcblx0XHRpZiAobyA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIShvIGluc3RhbmNlb2YgSW50ZWdlckxpc3QpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fc2l6ZSAhPT0gby5fc2l6ZSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX2RhdGFbaV0gIT09IG8uX2RhdGFbaV0pIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGhhc2ggY29kZSB2YWx1ZSBmb3IgdGhpcyBsaXN0LlxyXG5cdCAqXHJcblx0ICogVGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIGV4YWN0bHkgdGhlIGNvZGUgdGhhdCBpcyB1c2VkIHRvIGRlZmluZSB0aGVcclxuXHQgKiBsaXN0IGhhc2ggZnVuY3Rpb24gaW4gdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSB7QGxpbmsgTGlzdCNoYXNoQ29kZX1cclxuXHQgKiBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB0aGUgaGFzaCBjb2RlIHZhbHVlIGZvciB0aGlzIGxpc3RcclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoQ29kZTogbnVtYmVyID0gMTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XHJcblx0XHRcdGhhc2hDb2RlID0gMzEgKiBoYXNoQ29kZSArIHRoaXMuX2RhdGFbaV07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGhhc2hDb2RlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGxpc3QuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZGF0YS50b1N0cmluZygpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGJpbmFyeVNlYXJjaChrZXk6IG51bWJlciwgZnJvbUluZGV4PzogbnVtYmVyLCB0b0luZGV4PzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGlmIChmcm9tSW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRmcm9tSW5kZXggPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0b0luZGV4ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dG9JbmRleCA9IHRoaXMuX3NpemU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGZyb21JbmRleCA8IDAgfHwgdG9JbmRleCA8IDAgfHwgZnJvbUluZGV4ID4gdGhpcy5fc2l6ZSB8fCB0b0luZGV4ID4gdGhpcy5fc2l6ZSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChmcm9tSW5kZXggPiB0b0luZGV4KSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEFycmF5cy5iaW5hcnlTZWFyY2godGhpcy5fZGF0YSwga2V5LCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBlbnN1cmVDYXBhY2l0eShjYXBhY2l0eTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAoY2FwYWNpdHkgPCAwIHx8IGNhcGFjaXR5ID4gTUFYX0FSUkFZX1NJWkUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbmV3TGVuZ3RoOiBudW1iZXI7XHJcblx0XHRpZiAodGhpcy5fZGF0YS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0bmV3TGVuZ3RoID0gSU5JVElBTF9TSVpFO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmV3TGVuZ3RoID0gdGhpcy5fZGF0YS5sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0d2hpbGUgKG5ld0xlbmd0aCA8IGNhcGFjaXR5KSB7XHJcblx0XHRcdG5ld0xlbmd0aCA9IG5ld0xlbmd0aCAqIDI7XHJcblx0XHRcdGlmIChuZXdMZW5ndGggPCAwIHx8IG5ld0xlbmd0aCA+IE1BWF9BUlJBWV9TSVpFKSB7XHJcblx0XHRcdFx0bmV3TGVuZ3RoID0gTUFYX0FSUkFZX1NJWkU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdG1wID0gbmV3IEludDMyQXJyYXkobmV3TGVuZ3RoKTtcclxuXHRcdHRtcC5zZXQodGhpcy5fZGF0YSk7XHJcblx0XHR0aGlzLl9kYXRhID0gdG1wO1xyXG5cdH1cclxuXHJcblx0LyoqIENvbnZlcnQgdGhlIGxpc3QgdG8gYSBVVEYtMTYgZW5jb2RlZCBjaGFyIGFycmF5LiBJZiBhbGwgdmFsdWVzIGFyZSBsZXNzXHJcblx0ICogIHRoYW4gdGhlIDB4RkZGRiAxNi1iaXQgY29kZSBwb2ludCBsaW1pdCB0aGVuIHRoaXMgaXMganVzdCBhIGNoYXIgYXJyYXlcclxuXHQgKiAgb2YgMTYtYml0IGNoYXIgYXMgdXN1YWwuIEZvciB2YWx1ZXMgaW4gdGhlIHN1cHBsZW1lbnRhcnkgcmFuZ2UsIGVuY29kZVxyXG5cdCAqIHRoZW0gYXMgdHdvIFVURi0xNiBjb2RlIHVuaXRzLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyB0b0NoYXJBcnJheSgpOiBVaW50MTZBcnJheSB7XHJcblx0XHQvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIChhbGwgZGF0YSB2YWx1ZXMgYXJlIDwgMHhGRkZGKSB0byBhdm9pZCBhbiBleHRyYSBzY2FuXHJcblx0XHRsZXQgcmVzdWx0QXJyYXk6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuX3NpemUpO1xyXG5cdFx0bGV0IHJlc3VsdElkeCA9IDA7XHJcblx0XHRsZXQgY2FsY3VsYXRlZFByZWNpc2VSZXN1bHRTaXplID0gZmFsc2U7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xyXG5cdFx0XHRsZXQgY29kZVBvaW50ID0gdGhpcy5fZGF0YVtpXTtcclxuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAwICYmIGNvZGVQb2ludCA8IDB4MTAwMDApIHtcclxuXHRcdFx0XHRyZXN1bHRBcnJheVtyZXN1bHRJZHhdID0gY29kZVBvaW50O1xyXG5cdFx0XHRcdHJlc3VsdElkeCsrO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDYWxjdWxhdGUgdGhlIHByZWNpc2UgcmVzdWx0IHNpemUgaWYgd2UgZW5jb3VudGVyIGEgY29kZSBwb2ludCA+IDB4RkZGRlxyXG5cdFx0XHRpZiAoIWNhbGN1bGF0ZWRQcmVjaXNlUmVzdWx0U2l6ZSkge1xyXG5cdFx0XHRcdGxldCBuZXdSZXN1bHRBcnJheSA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmNoYXJBcnJheVNpemUoKSk7XHJcblx0XHRcdFx0bmV3UmVzdWx0QXJyYXkuc2V0KHJlc3VsdEFycmF5LCAwKTtcclxuXHRcdFx0XHRyZXN1bHRBcnJheSA9IG5ld1Jlc3VsdEFycmF5O1xyXG5cdFx0XHRcdGNhbGN1bGF0ZWRQcmVjaXNlUmVzdWx0U2l6ZSA9IHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBSYW5nZUVycm9yIGlmIHRoZSBjb2RlIHBvaW50IGlzIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxyXG5cdFx0XHRsZXQgcGFpciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCk7XHJcblx0XHRcdHJlc3VsdEFycmF5W3Jlc3VsdElkeF0gPSBwYWlyLmNoYXJDb2RlQXQoMCk7XHJcblx0XHRcdHJlc3VsdEFycmF5W3Jlc3VsdElkeCArIDFdID0gcGFpci5jaGFyQ29kZUF0KDEpO1xyXG5cdFx0XHRyZXN1bHRJZHggKz0gMjtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHRBcnJheTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgY2hhckFycmF5U2l6ZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IHJlc3VsdCA9IDA7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xyXG5cdFx0XHRyZXN1bHQgKz0gdGhpcy5fZGF0YVtpXSA+PSAweDEwMDAwID8gMiA6IDE7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDAuNzQwMjIxNC0wNzowMFxyXG5cclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBFcXVhdGFibGUgfSBmcm9tIFwiLi9TdHVic1wiO1xyXG5cclxuY29uc3QgSU5URVJWQUxfUE9PTF9NQVhfVkFMVUU6IG51bWJlciA9IDEwMDA7XHJcblxyXG4vKiogQW4gaW1tdXRhYmxlIGluY2x1c2l2ZSBpbnRlcnZhbCBhLi5iICovXHJcbmV4cG9ydCBjbGFzcyBJbnRlcnZhbCBpbXBsZW1lbnRzIEVxdWF0YWJsZSB7XHJcblx0cHJpdmF0ZSBzdGF0aWMgX0lOVkFMSUQ6IEludGVydmFsID0gbmV3IEludGVydmFsKC0xLCAtMik7XHJcblx0c3RhdGljIGdldCBJTlZBTElEKCk6IEludGVydmFsIHtcclxuXHRcdHJldHVybiBJbnRlcnZhbC5fSU5WQUxJRDtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGNhY2hlOiBJbnRlcnZhbFtdID0gbmV3IEFycmF5PEludGVydmFsPihJTlRFUlZBTF9QT09MX01BWF9WQUxVRSArIDEpO1xyXG5cclxuXHQvKipcclxuXHQgKiBAcGFyYW0gYSBUaGUgc3RhcnQgb2YgdGhlIGludGVydmFsXHJcblx0ICogQHBhcmFtIGIgVGhlIGVuZCBvZiB0aGUgaW50ZXJ2YWwgKGluY2x1c2l2ZSlcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihwdWJsaWMgYTogbnVtYmVyLCBwdWJsaWMgYjogbnVtYmVyKSB7XHJcblx0fVxyXG5cclxuXHQvKiogSW50ZXJ2YWwgb2JqZWN0cyBhcmUgdXNlZCByZWFkb25seSBzbyBzaGFyZSBhbGwgd2l0aCB0aGVcclxuXHQgKiAgc2FtZSBzaW5nbGUgdmFsdWUgYT09YiB1cCB0byBzb21lIG1heCBzaXplLiAgVXNlIGFuIGFycmF5IGFzIGEgcGVyZmVjdCBoYXNoLlxyXG5cdCAqICBSZXR1cm4gc2hhcmVkIG9iamVjdCBmb3IgMC4uSU5URVJWQUxfUE9PTF9NQVhfVkFMVUUgb3IgYSBuZXdcclxuXHQgKiAgSW50ZXJ2YWwgb2JqZWN0IHdpdGggYS4uYSBpbiBpdC4gIE9uIEphdmEuZzQsIDIxODYyMyBJbnRlcnZhbFNldHNcclxuXHQgKiAgaGF2ZSBhLi5hIChzZXQgd2l0aCAxIGVsZW1lbnQpLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgb2YoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBJbnRlcnZhbCB7XHJcblx0XHQvLyBjYWNoZSBqdXN0IGEuLmFcclxuXHRcdGlmIChhICE9PSBiIHx8IGEgPCAwIHx8IGEgPiBJTlRFUlZBTF9QT09MX01BWF9WQUxVRSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEludGVydmFsKGEsIGIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChJbnRlcnZhbC5jYWNoZVthXSA9PSBudWxsKSB7XHJcblx0XHRcdEludGVydmFsLmNhY2hlW2FdID0gbmV3IEludGVydmFsKGEsIGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBJbnRlcnZhbC5jYWNoZVthXTtcclxuXHR9XHJcblxyXG5cdC8qKiByZXR1cm4gbnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gYSBhbmQgYiBpbmNsdXNpdmVseS4geC4ueCBpcyBsZW5ndGggMS5cclxuXHQgKiAgaWYgYiAmbHQ7IGEsIHRoZW4gbGVuZ3RoIGlzIDAuICA5Li4xMCBoYXMgbGVuZ3RoIDIuXHJcblx0ICovXHJcblx0Z2V0IGxlbmd0aCgpOiBudW1iZXIge1xyXG5cdFx0aWYgKHRoaXMuYiA8IHRoaXMuYSkge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5iIC0gdGhpcy5hICsgMTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMobzogYW55KTogYm9vbGVhbiB7XHJcblx0XHRpZiAobyA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKCEobyBpbnN0YW5jZW9mIEludGVydmFsKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYSA9PT0gby5hICYmIHRoaXMuYiA9PT0gby5iO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gMjM7XHJcblx0XHRoYXNoID0gaGFzaCAqIDMxICsgdGhpcy5hO1xyXG5cdFx0aGFzaCA9IGhhc2ggKiAzMSArIHRoaXMuYjtcclxuXHRcdHJldHVybiBoYXNoO1xyXG5cdH1cclxuXHJcblx0LyoqIERvZXMgdGhpcyBzdGFydCBjb21wbGV0ZWx5IGJlZm9yZSBvdGhlcj8gRGlzam9pbnQgKi9cclxuXHRwdWJsaWMgc3RhcnRzQmVmb3JlRGlzam9pbnQob3RoZXI6IEludGVydmFsKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5hIDwgb3RoZXIuYSAmJiB0aGlzLmIgPCBvdGhlci5hO1xyXG5cdH1cclxuXHJcblx0LyoqIERvZXMgdGhpcyBzdGFydCBhdCBvciBiZWZvcmUgb3RoZXI/IE5vbmRpc2pvaW50ICovXHJcblx0cHVibGljIHN0YXJ0c0JlZm9yZU5vbkRpc2pvaW50KG90aGVyOiBJbnRlcnZhbCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuYSA8PSBvdGhlci5hICYmIHRoaXMuYiA+PSBvdGhlci5hO1xyXG5cdH1cclxuXHJcblx0LyoqIERvZXMgdGhpcy5hIHN0YXJ0IGFmdGVyIG90aGVyLmI/IE1heSBvciBtYXkgbm90IGJlIGRpc2pvaW50ICovXHJcblx0cHVibGljIHN0YXJ0c0FmdGVyKG90aGVyOiBJbnRlcnZhbCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuYSA+IG90aGVyLmE7XHJcblx0fVxyXG5cclxuXHQvKiogRG9lcyB0aGlzIHN0YXJ0IGNvbXBsZXRlbHkgYWZ0ZXIgb3RoZXI/IERpc2pvaW50ICovXHJcblx0cHVibGljIHN0YXJ0c0FmdGVyRGlzam9pbnQob3RoZXI6IEludGVydmFsKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5hID4gb3RoZXIuYjtcclxuXHR9XHJcblxyXG5cdC8qKiBEb2VzIHRoaXMgc3RhcnQgYWZ0ZXIgb3RoZXI/IE5vbkRpc2pvaW50ICovXHJcblx0cHVibGljIHN0YXJ0c0FmdGVyTm9uRGlzam9pbnQob3RoZXI6IEludGVydmFsKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5hID4gb3RoZXIuYSAmJiB0aGlzLmEgPD0gb3RoZXIuYjsgLy8gdGhpcy5iPj1vdGhlci5iIGltcGxpZWRcclxuXHR9XHJcblxyXG5cdC8qKiBBcmUgYm90aCByYW5nZXMgZGlzam9pbnQ/IEkuZS4sIG5vIG92ZXJsYXA/ICovXHJcblx0cHVibGljIGRpc2pvaW50KG90aGVyOiBJbnRlcnZhbCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnRzQmVmb3JlRGlzam9pbnQob3RoZXIpIHx8IHRoaXMuc3RhcnRzQWZ0ZXJEaXNqb2ludChvdGhlcik7XHJcblx0fVxyXG5cclxuXHQvKiogQXJlIHR3byBpbnRlcnZhbHMgYWRqYWNlbnQgc3VjaCBhcyAwLi40MSBhbmQgNDIuLjQyPyAqL1xyXG5cdHB1YmxpYyBhZGphY2VudChvdGhlcjogSW50ZXJ2YWwpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmEgPT09IG90aGVyLmIgKyAxIHx8IHRoaXMuYiA9PT0gb3RoZXIuYSAtIDE7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcHJvcGVybHlDb250YWlucyhvdGhlcjogSW50ZXJ2YWwpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBvdGhlci5hID49IHRoaXMuYSAmJiBvdGhlci5iIDw9IHRoaXMuYjtcclxuXHR9XHJcblxyXG5cdC8qKiBSZXR1cm4gdGhlIGludGVydmFsIGNvbXB1dGVkIGZyb20gY29tYmluaW5nIHRoaXMgYW5kIG90aGVyICovXHJcblx0cHVibGljIHVuaW9uKG90aGVyOiBJbnRlcnZhbCk6IEludGVydmFsIHtcclxuXHRcdHJldHVybiBJbnRlcnZhbC5vZihNYXRoLm1pbih0aGlzLmEsIG90aGVyLmEpLCBNYXRoLm1heCh0aGlzLmIsIG90aGVyLmIpKTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZXR1cm4gdGhlIGludGVydmFsIGluIGNvbW1vbiBiZXR3ZWVuIHRoaXMgYW5kIG8gKi9cclxuXHRwdWJsaWMgaW50ZXJzZWN0aW9uKG90aGVyOiBJbnRlcnZhbCk6IEludGVydmFsIHtcclxuXHRcdHJldHVybiBJbnRlcnZhbC5vZihNYXRoLm1heCh0aGlzLmEsIG90aGVyLmEpLCBNYXRoLm1pbih0aGlzLmIsIG90aGVyLmIpKTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZXR1cm4gdGhlIGludGVydmFsIHdpdGggZWxlbWVudHMgZnJvbSBgdGhpc2Agbm90IGluIGBvdGhlcmA7XHJcblx0ICogIGBvdGhlcmAgbXVzdCBub3QgYmUgdG90YWxseSBlbmNsb3NlZCAocHJvcGVybHkgY29udGFpbmVkKVxyXG5cdCAqICB3aXRoaW4gYHRoaXNgLCB3aGljaCB3b3VsZCByZXN1bHQgaW4gdHdvIGRpc2pvaW50IGludGVydmFsc1xyXG5cdCAqICBpbnN0ZWFkIG9mIHRoZSBzaW5nbGUgb25lIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBkaWZmZXJlbmNlTm90UHJvcGVybHlDb250YWluZWQob3RoZXI6IEludGVydmFsKTogSW50ZXJ2YWwgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IGRpZmY6IEludGVydmFsIHwgdW5kZWZpbmVkO1xyXG5cdFx0aWYgKG90aGVyLnN0YXJ0c0JlZm9yZU5vbkRpc2pvaW50KHRoaXMpKSB7XHJcblx0XHRcdC8vIG90aGVyLmEgdG8gbGVmdCBvZiB0aGlzLmEgKG9yIHNhbWUpXHJcblx0XHRcdGRpZmYgPSBJbnRlcnZhbC5vZihNYXRoLm1heCh0aGlzLmEsIG90aGVyLmIgKyAxKSwgdGhpcy5iKTtcclxuXHRcdH0gZWxzZSBpZiAob3RoZXIuc3RhcnRzQWZ0ZXJOb25EaXNqb2ludCh0aGlzKSkge1xyXG5cdFx0XHQvLyBvdGhlci5hIHRvIHJpZ2h0IG9mIHRoaXMuYVxyXG5cdFx0XHRkaWZmID0gSW50ZXJ2YWwub2YodGhpcy5hLCBvdGhlci5hIC0gMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRpZmY7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmEgKyBcIi4uXCIgKyB0aGlzLmI7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Ny43ODYyODAyLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBDaGFyU3RyZWFtIH0gZnJvbSBcIi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBJbnRTdHJlYW0gfSBmcm9tIFwiLi9JbnRTdHJlYW1cIjtcclxuaW1wb3J0IHsgVG9rZW5Tb3VyY2UgfSBmcm9tIFwiLi9Ub2tlblNvdXJjZVwiO1xyXG5pbXBvcnQgeyBUb2tlblN0cmVhbSB9IGZyb20gXCIuL1Rva2VuU3RyZWFtXCI7XHJcblxyXG4vKiogQSB0b2tlbiBoYXMgcHJvcGVydGllczogdGV4dCwgdHlwZSwgbGluZSwgY2hhcmFjdGVyIHBvc2l0aW9uIGluIHRoZSBsaW5lXHJcbiAqICAoc28gd2UgY2FuIGlnbm9yZSB0YWJzKSwgdG9rZW4gY2hhbm5lbCwgaW5kZXgsIGFuZCBzb3VyY2UgZnJvbSB3aGljaFxyXG4gKiAgd2Ugb2J0YWluZWQgdGhpcyB0b2tlbi5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW4ge1xyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdGV4dCBvZiB0aGUgdG9rZW4uXHJcblx0ICovXHJcblx0cmVhZG9ubHkgdGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG5cclxuXHQvKiogR2V0IHRoZSB0b2tlbiB0eXBlIG9mIHRoZSB0b2tlbiAqL1xyXG5cdHJlYWRvbmx5IHR5cGU6IG51bWJlcjtcclxuXHJcblx0LyoqIFRoZSBsaW5lIG51bWJlciBvbiB3aGljaCB0aGUgMXN0IGNoYXJhY3RlciBvZiB0aGlzIHRva2VuIHdhcyBtYXRjaGVkLFxyXG5cdCAqICBsaW5lPTEuLm5cclxuXHQgKi9cclxuXHRyZWFkb25seSBsaW5lOiBudW1iZXI7XHJcblxyXG5cdC8qKiBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGlzIHRva2VuIHJlbGF0aXZlIHRvIHRoZVxyXG5cdCAqICBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgYXQgd2hpY2ggaXQgb2NjdXJzLCAwLi5uLTFcclxuXHQgKi9cclxuXHRyZWFkb25seSBjaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlcjtcclxuXHJcblx0LyoqIFJldHVybiB0aGUgY2hhbm5lbCB0aGlzIHRva2VuLiBFYWNoIHRva2VuIGNhbiBhcnJpdmUgYXQgdGhlIHBhcnNlclxyXG5cdCAqICBvbiBhIGRpZmZlcmVudCBjaGFubmVsLCBidXQgdGhlIHBhcnNlciBvbmx5IFwidHVuZXNcIiB0byBhIHNpbmdsZSBjaGFubmVsLlxyXG5cdCAqICBUaGUgcGFyc2VyIGlnbm9yZXMgZXZlcnl0aGluZyBub3Qgb24gREVGQVVMVF9DSEFOTkVMLlxyXG5cdCAqL1xyXG5cdHJlYWRvbmx5IGNoYW5uZWw6IG51bWJlcjtcclxuXHJcblx0LyoqIEFuIGluZGV4IGZyb20gMC4ubi0xIG9mIHRoZSB0b2tlbiBvYmplY3QgaW4gdGhlIGlucHV0IHN0cmVhbS5cclxuXHQgKiAgVGhpcyBtdXN0IGJlIHZhbGlkIGluIG9yZGVyIHRvIHByaW50IHRva2VuIHN0cmVhbXMgYW5kXHJcblx0ICogIHVzZSBUb2tlblJld3JpdGVTdHJlYW0uXHJcblx0ICpcclxuXHQgKiAgUmV0dXJuIC0xIHRvIGluZGljYXRlIHRoYXQgdGhpcyB0b2tlbiB3YXMgY29uanVyZWQgdXAgc2luY2VcclxuXHQgKiAgaXQgZG9lc24ndCBoYXZlIGEgdmFsaWQgaW5kZXguXHJcblx0ICovXHJcblx0cmVhZG9ubHkgdG9rZW5JbmRleDogbnVtYmVyO1xyXG5cclxuXHQvKiogVGhlIHN0YXJ0aW5nIGNoYXJhY3RlciBpbmRleCBvZiB0aGUgdG9rZW5cclxuXHQgKiAgVGhpcyBtZXRob2QgaXMgb3B0aW9uYWw7IHJldHVybiAtMSBpZiBub3QgaW1wbGVtZW50ZWQuXHJcblx0ICovXHJcblx0cmVhZG9ubHkgc3RhcnRJbmRleDogbnVtYmVyO1xyXG5cclxuXHQvKiogVGhlIGxhc3QgY2hhcmFjdGVyIGluZGV4IG9mIHRoZSB0b2tlbi5cclxuXHQgKiAgVGhpcyBtZXRob2QgaXMgb3B0aW9uYWw7IHJldHVybiAtMSBpZiBub3QgaW1wbGVtZW50ZWQuXHJcblx0ICovXHJcblx0cmVhZG9ubHkgc3RvcEluZGV4OiBudW1iZXI7XHJcblxyXG5cdC8qKiBHZXRzIHRoZSB7QGxpbmsgVG9rZW5Tb3VyY2V9IHdoaWNoIGNyZWF0ZWQgdGhpcyB0b2tlbi5cclxuXHQgKi9cclxuXHRyZWFkb25seSB0b2tlblNvdXJjZTogVG9rZW5Tb3VyY2UgfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHtAbGluayBDaGFyU3RyZWFtfSBmcm9tIHdoaWNoIHRoaXMgdG9rZW4gd2FzIGRlcml2ZWQuXHJcblx0ICovXHJcblx0cmVhZG9ubHkgaW5wdXRTdHJlYW06IENoYXJTdHJlYW0gfCB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgVG9rZW4ge1xyXG5cdGV4cG9ydCBjb25zdCBJTlZBTElEX1RZUEU6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKiBEdXJpbmcgbG9va2FoZWFkIG9wZXJhdGlvbnMsIHRoaXMgXCJ0b2tlblwiIHNpZ25pZmllcyB3ZSBoaXQgcnVsZSBlbmQgQVROIHN0YXRlXHJcblx0ICogIGFuZCBkaWQgbm90IGZvbGxvdyBpdCBkZXNwaXRlIG5lZWRpbmcgdG8uXHJcblx0ICovXHJcblx0ZXhwb3J0IGNvbnN0IEVQU0lMT046IG51bWJlciA9IC0yO1xyXG5cclxuXHRleHBvcnQgY29uc3QgTUlOX1VTRVJfVE9LRU5fVFlQRTogbnVtYmVyID0gMTtcclxuXHJcblx0ZXhwb3J0IGNvbnN0IEVPRjogbnVtYmVyID0gSW50U3RyZWFtLkVPRjtcclxuXHJcblx0LyoqIEFsbCB0b2tlbnMgZ28gdG8gdGhlIHBhcnNlciAodW5sZXNzIHNraXAoKSBpcyBjYWxsZWQgaW4gdGhhdCBydWxlKVxyXG5cdCAqICBvbiBhIHBhcnRpY3VsYXIgXCJjaGFubmVsXCIuICBUaGUgcGFyc2VyIHR1bmVzIHRvIGEgcGFydGljdWxhciBjaGFubmVsXHJcblx0ICogIHNvIHRoYXQgd2hpdGVzcGFjZSBldGMuLi4gY2FuIGdvIHRvIHRoZSBwYXJzZXIgb24gYSBcImhpZGRlblwiIGNoYW5uZWwuXHJcblx0ICovXHJcblx0ZXhwb3J0IGNvbnN0IERFRkFVTFRfQ0hBTk5FTDogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqIEFueXRoaW5nIG9uIGRpZmZlcmVudCBjaGFubmVsIHRoYW4gREVGQVVMVF9DSEFOTkVMIGlzIG5vdCBwYXJzZWRcclxuXHQgKiAgYnkgcGFyc2VyLlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBjb25zdCBISURERU5fQ0hBTk5FTDogbnVtYmVyID0gMTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgbWluaW11bSBjb25zdGFudCB2YWx1ZSB3aGljaCBjYW4gYmUgYXNzaWduZWQgdG8gYVxyXG5cdCAqIHVzZXItZGVmaW5lZCB0b2tlbiBjaGFubmVsLlxyXG5cdCAqXHJcblx0ICogVGhlIG5vbi1uZWdhdGl2ZSBudW1iZXJzIGxlc3MgdGhhbiB7QGxpbmsgI01JTl9VU0VSX0NIQU5ORUxfVkFMVUV9IGFyZVxyXG5cdCAqIGFzc2lnbmVkIHRvIHRoZSBwcmVkZWZpbmVkIGNoYW5uZWxzIHtAbGluayAjREVGQVVMVF9DSEFOTkVMfSBhbmRcclxuXHQgKiB7QGxpbmsgI0hJRERFTl9DSEFOTkVMfS5cclxuXHQgKlxyXG5cdCAqIEBzZWUgYFRva2VuLmNoYW5uZWxgXHJcblx0ICovXHJcblx0ZXhwb3J0IGNvbnN0IE1JTl9VU0VSX0NIQU5ORUxfVkFMVUU6IG51bWJlciA9IDI7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUwLjE2MTQ0MDQtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlNpbXVsYXRvciB9IGZyb20gXCIuL2F0bi9BVE5TaW11bGF0b3JcIjtcclxuaW1wb3J0IHsgQ2hhclN0cmVhbSB9IGZyb20gXCIuL0NoYXJTdHJlYW1cIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4vUmVjb2duaXplclwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuU291cmNlIH0gZnJvbSBcIi4vVG9rZW5Tb3VyY2VcIjtcclxuaW1wb3J0IHsgV3JpdGFibGVUb2tlbiB9IGZyb20gXCIuL1dyaXRhYmxlVG9rZW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBDb21tb25Ub2tlbiBpbXBsZW1lbnRzIFdyaXRhYmxlVG9rZW4ge1xyXG5cdC8qKlxyXG5cdCAqIEFuIGVtcHR5IHtAbGluayBUdXBsZTJ9IHdoaWNoIGlzIHVzZWQgYXMgdGhlIGRlZmF1bHQgdmFsdWUgb2ZcclxuXHQgKiB7QGxpbmsgI3NvdXJjZX0gZm9yIHRva2VucyB0aGF0IGRvIG5vdCBoYXZlIGEgc291cmNlLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgRU1QVFlfU09VUkNFOiB7IHNvdXJjZT86IFRva2VuU291cmNlLCBzdHJlYW0/OiBDaGFyU3RyZWFtIH0gPVxyXG5cdFx0eyBzb3VyY2U6IHVuZGVmaW5lZCwgc3RyZWFtOiB1bmRlZmluZWQgfTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3IgYHR5cGVgLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX3R5cGU6IG51bWJlcjtcclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciB7QGxpbmsgI2dldExpbmV9IGFuZCB7QGxpbmsgI3NldExpbmV9LlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX2xpbmU6IG51bWJlciA9IDA7XHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3Ige0BsaW5rICNnZXRDaGFyUG9zaXRpb25JbkxpbmV9IGFuZFxyXG5cdCAqIHtAbGluayAjc2V0Q2hhclBvc2l0aW9uSW5MaW5lfS5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9jaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlciA9IC0xOyAvLyBzZXQgdG8gaW52YWxpZCBwb3NpdGlvblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIHtAbGluayAjZ2V0Q2hhbm5lbH0gYW5kXHJcblx0ICoge0BsaW5rICNzZXRDaGFubmVsfS5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9jaGFubmVsOiBudW1iZXIgPSBUb2tlbi5ERUZBVUxUX0NIQU5ORUw7XHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3Ige0BsaW5rICNnZXRUb2tlblNvdXJjZX0gYW5kXHJcblx0ICoge0BsaW5rICNnZXRJbnB1dFN0cmVhbX0uXHJcblx0ICpcclxuXHQgKiBUaGVzZSBwcm9wZXJ0aWVzIHNoYXJlIGEgZmllbGQgdG8gcmVkdWNlIHRoZSBtZW1vcnkgZm9vdHByaW50IG9mXHJcblx0ICoge0BsaW5rIENvbW1vblRva2VufS4gVG9rZW5zIGNyZWF0ZWQgYnkgYSB7QGxpbmsgQ29tbW9uVG9rZW5GYWN0b3J5fSBmcm9tXHJcblx0ICogdGhlIHNhbWUgc291cmNlIGFuZCBpbnB1dCBzdHJlYW0gc2hhcmUgYSByZWZlcmVuY2UgdG8gdGhlIHNhbWVcclxuXHQgKiB7QGxpbmsgVHVwbGUyfSBjb250YWluaW5nIHRoZXNlIHZhbHVlcy5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBzb3VyY2U6IHsgc291cmNlPzogVG9rZW5Tb3VyY2UsIHN0cmVhbT86IENoYXJTdHJlYW0gfTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3Ige0BsaW5rICNnZXRUZXh0fSB3aGVuIHRoZSB0b2tlbiB0ZXh0IGlzXHJcblx0ICogZXhwbGljaXRseSBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yIG9yIHZpYSB7QGxpbmsgI3NldFRleHR9LlxyXG5cdCAqXHJcblx0ICogQHNlZSBgdGV4dGBcclxuXHQgKi9cclxuXHRwcml2YXRlIF90ZXh0Pzogc3RyaW5nO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgdG9rZW5JbmRleGAuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGluZGV4OiBudW1iZXIgPSAtMTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3IgYHN0YXJ0SW5kZXhgLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBzdGFydDogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgc3RvcEluZGV4YC5cclxuXHQgKi9cclxuXHRwcml2YXRlIHN0b3A6IG51bWJlcjtcclxuXHJcblx0Y29uc3RydWN0b3IodHlwZTogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nLCBATm90TnVsbCBzb3VyY2U6IHsgc291cmNlPzogVG9rZW5Tb3VyY2UsIHN0cmVhbT86IENoYXJTdHJlYW0gfSA9IENvbW1vblRva2VuLkVNUFRZX1NPVVJDRSwgY2hhbm5lbDogbnVtYmVyID0gVG9rZW4uREVGQVVMVF9DSEFOTkVMLCBzdGFydDogbnVtYmVyID0gMCwgc3RvcDogbnVtYmVyID0gMCkge1xyXG5cdFx0dGhpcy5fdGV4dCA9IHRleHQ7XHJcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcclxuXHRcdHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdFx0dGhpcy5fY2hhbm5lbCA9IGNoYW5uZWw7XHJcblx0XHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcblx0XHR0aGlzLnN0b3AgPSBzdG9wO1xyXG5cdFx0aWYgKHNvdXJjZS5zb3VyY2UgIT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLl9saW5lID0gc291cmNlLnNvdXJjZS5saW5lO1xyXG5cdFx0XHR0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmUgPSBzb3VyY2Uuc291cmNlLmNoYXJQb3NpdGlvbkluTGluZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcge0BsaW5rIENvbW1vblRva2VufSBhcyBhIGNvcHkgb2YgYW5vdGhlciB7QGxpbmsgVG9rZW59LlxyXG5cdCAqXHJcblx0ICogSWYgYG9sZFRva2VuYCBpcyBhbHNvIGEge0BsaW5rIENvbW1vblRva2VufSBpbnN0YW5jZSwgdGhlIG5ld2x5XHJcblx0ICogY29uc3RydWN0ZWQgdG9rZW4gd2lsbCBzaGFyZSBhIHJlZmVyZW5jZSB0byB0aGUge0BsaW5rICN0ZXh0fSBmaWVsZCBhbmRcclxuXHQgKiB0aGUge0BsaW5rIFR1cGxlMn0gc3RvcmVkIGluIHtAbGluayAjc291cmNlfS4gT3RoZXJ3aXNlLCB7QGxpbmsgI3RleHR9IHdpbGxcclxuXHQgKiBiZSBhc3NpZ25lZCB0aGUgcmVzdWx0IG9mIGNhbGxpbmcge0BsaW5rICNnZXRUZXh0fSwgYW5kIHtAbGluayAjc291cmNlfVxyXG5cdCAqIHdpbGwgYmUgY29uc3RydWN0ZWQgZnJvbSB0aGUgcmVzdWx0IG9mIHtAbGluayBUb2tlbiNnZXRUb2tlblNvdXJjZX0gYW5kXHJcblx0ICoge0BsaW5rIFRva2VuI2dldElucHV0U3RyZWFtfS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBvbGRUb2tlbiBUaGUgdG9rZW4gdG8gY29weS5cclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIGZyb21Ub2tlbihATm90TnVsbCBvbGRUb2tlbjogVG9rZW4pOiBDb21tb25Ub2tlbiB7XHJcblx0XHRsZXQgcmVzdWx0OiBDb21tb25Ub2tlbiA9IG5ldyBDb21tb25Ub2tlbihvbGRUb2tlbi50eXBlLCB1bmRlZmluZWQsIENvbW1vblRva2VuLkVNUFRZX1NPVVJDRSwgb2xkVG9rZW4uY2hhbm5lbCwgb2xkVG9rZW4uc3RhcnRJbmRleCwgb2xkVG9rZW4uc3RvcEluZGV4KTtcclxuXHRcdHJlc3VsdC5fbGluZSA9IG9sZFRva2VuLmxpbmU7XHJcblx0XHRyZXN1bHQuaW5kZXggPSBvbGRUb2tlbi50b2tlbkluZGV4O1xyXG5cdFx0cmVzdWx0Ll9jaGFyUG9zaXRpb25JbkxpbmUgPSBvbGRUb2tlbi5jaGFyUG9zaXRpb25JbkxpbmU7XHJcblxyXG5cdFx0aWYgKG9sZFRva2VuIGluc3RhbmNlb2YgQ29tbW9uVG9rZW4pIHtcclxuXHRcdFx0cmVzdWx0Ll90ZXh0ID0gb2xkVG9rZW4uX3RleHQ7XHJcblx0XHRcdHJlc3VsdC5zb3VyY2UgPSBvbGRUb2tlbi5zb3VyY2U7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXN1bHQuX3RleHQgPSBvbGRUb2tlbi50ZXh0O1xyXG5cdFx0XHRyZXN1bHQuc291cmNlID0geyBzb3VyY2U6IG9sZFRva2VuLnRva2VuU291cmNlLCBzdHJlYW06IG9sZFRva2VuLmlucHV0U3RyZWFtIH07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCB0eXBlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcclxuXHR9XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHNldCB0eXBlKHR5cGU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgbGluZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xpbmU7XHJcblx0fVxyXG5cclxuXHQvLyBAT3ZlcnJpZGVcclxuXHRzZXQgbGluZShsaW5lOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuX2xpbmUgPSBsaW5lO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHRleHQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICh0aGlzLl90ZXh0ICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX3RleHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGlucHV0OiBDaGFyU3RyZWFtIHwgdW5kZWZpbmVkID0gdGhpcy5pbnB1dFN0cmVhbTtcclxuXHRcdGlmIChpbnB1dCA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG46IG51bWJlciA9IGlucHV0LnNpemU7XHJcblx0XHRpZiAodGhpcy5zdGFydCA8IG4gJiYgdGhpcy5zdG9wIDwgbikge1xyXG5cdFx0XHRyZXR1cm4gaW5wdXQuZ2V0VGV4dChJbnRlcnZhbC5vZih0aGlzLnN0YXJ0LCB0aGlzLnN0b3ApKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBcIjxFT0Y+XCI7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeHBsaWNpdGx5IHNldCB0aGUgdGV4dCBmb3IgdGhpcyB0b2tlbi4gSWYge2NvZGUgdGV4dH0gaXMgbm90XHJcblx0ICogYHVuZGVmaW5lZGAsIHRoZW4ge0BsaW5rICNnZXRUZXh0fSB3aWxsIHJldHVybiB0aGlzIHZhbHVlIHJhdGhlciB0aGFuXHJcblx0ICogZXh0cmFjdGluZyB0aGUgdGV4dCBmcm9tIHRoZSBpbnB1dC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0ZXh0IFRoZSBleHBsaWNpdCB0ZXh0IG9mIHRoZSB0b2tlbiwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHRleHRcclxuXHQgKiBzaG91bGQgYmUgb2J0YWluZWQgZnJvbSB0aGUgaW5wdXQgYWxvbmcgd2l0aCB0aGUgc3RhcnQgYW5kIHN0b3AgaW5kZXhlc1xyXG5cdCAqIG9mIHRoZSB0b2tlbi5cclxuXHQgKi9cclxuXHQvLyBAT3ZlcnJpZGVcclxuXHRzZXQgdGV4dCh0ZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuX3RleHQgPSB0ZXh0O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGNoYXJQb3NpdGlvbkluTGluZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZTtcclxuXHR9XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHNldCBjaGFyUG9zaXRpb25JbkxpbmUoY2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSA9IGNoYXJQb3NpdGlvbkluTGluZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBjaGFubmVsKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hhbm5lbDtcclxuXHR9XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHNldCBjaGFubmVsKGNoYW5uZWw6IG51bWJlcikge1xyXG5cdFx0dGhpcy5fY2hhbm5lbCA9IGNoYW5uZWw7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhcnRJbmRleCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQ7XHJcblx0fVxyXG5cclxuXHRzZXQgc3RhcnRJbmRleChzdGFydDogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RvcEluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdG9wO1xyXG5cdH1cclxuXHJcblx0c2V0IHN0b3BJbmRleChzdG9wOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuc3RvcCA9IHN0b3A7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgdG9rZW5JbmRleCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW5kZXg7XHJcblx0fVxyXG5cclxuXHQvLyBAT3ZlcnJpZGVcclxuXHRzZXQgdG9rZW5JbmRleChpbmRleDogbnVtYmVyKSB7XHJcblx0XHR0aGlzLmluZGV4ID0gaW5kZXg7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgdG9rZW5Tb3VyY2UoKTogVG9rZW5Tb3VyY2UgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuc291cmNlLnNvdXJjZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpbnB1dFN0cmVhbSgpOiBDaGFyU3RyZWFtIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLnNvdXJjZS5zdHJlYW07XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nO1xyXG5cdHB1YmxpYyB0b1N0cmluZzxUU3ltYm9sLCBBVE5JbnRlcnByZXRlciBleHRlbmRzIEFUTlNpbXVsYXRvcj4ocmVjb2duaXplcjogUmVjb2duaXplcjxUU3ltYm9sLCBBVE5JbnRlcnByZXRlcj4gfCB1bmRlZmluZWQpOiBzdHJpbmc7XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZzxUU3ltYm9sLCBBVE5JbnRlcnByZXRlciBleHRlbmRzIEFUTlNpbXVsYXRvcj4ocmVjb2duaXplcj86IFJlY29nbml6ZXI8VFN5bWJvbCwgQVROSW50ZXJwcmV0ZXI+KTogc3RyaW5nIHtcclxuXHRcdGxldCBjaGFubmVsU3RyOiBzdHJpbmcgPSBcIlwiO1xyXG5cdFx0aWYgKHRoaXMuX2NoYW5uZWwgPiAwKSB7XHJcblx0XHRcdGNoYW5uZWxTdHIgPSBcIixjaGFubmVsPVwiICsgdGhpcy5fY2hhbm5lbDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdHh0OiBzdHJpbmcgfCB1bmRlZmluZWQgPSB0aGlzLnRleHQ7XHJcblx0XHRpZiAodHh0ICE9IG51bGwpIHtcclxuXHRcdFx0dHh0ID0gdHh0LnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpO1xyXG5cdFx0XHR0eHQgPSB0eHQucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIik7XHJcblx0XHRcdHR4dCA9IHR4dC5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR4dCA9IFwiPG5vIHRleHQ+XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHR5cGVTdHJpbmcgPSBTdHJpbmcodGhpcy5fdHlwZSk7XHJcblx0XHRpZiAocmVjb2duaXplcikge1xyXG5cdFx0XHR0eXBlU3RyaW5nID0gcmVjb2duaXplci52b2NhYnVsYXJ5LmdldERpc3BsYXlOYW1lKHRoaXMuX3R5cGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBcIltAXCIgKyB0aGlzLnRva2VuSW5kZXggKyBcIixcIiArIHRoaXMuc3RhcnQgKyBcIjpcIiArIHRoaXMuc3RvcCArIFwiPSdcIiArIHR4dCArIFwiJyw8XCIgKyB0eXBlU3RyaW5nICsgXCI+XCIgKyBjaGFubmVsU3RyICsgXCIsXCIgKyB0aGlzLl9saW5lICsgXCI6XCIgKyB0aGlzLmNoYXJQb3NpdGlvbkluTGluZSArIFwiXVwiO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTAuMzAxMDExMi0wNzowMFxyXG5cclxuaW1wb3J0IHsgQ2hhclN0cmVhbSB9IGZyb20gXCIuL0NoYXJTdHJlYW1cIjtcclxuaW1wb3J0IHsgQ29tbW9uVG9rZW4gfSBmcm9tIFwiLi9Db21tb25Ub2tlblwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFRva2VuRmFjdG9yeSB9IGZyb20gXCIuL1Rva2VuRmFjdG9yeVwiO1xyXG5pbXBvcnQgeyBUb2tlblNvdXJjZSB9IGZyb20gXCIuL1Rva2VuU291cmNlXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBUb2tlbkZhY3Rvcnl9IGNyZWF0ZXNcclxuICoge0BsaW5rIENvbW1vblRva2VufSBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbW1vblRva2VuRmFjdG9yeSBpbXBsZW1lbnRzIFRva2VuRmFjdG9yeSB7XHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIge0BsaW5rIENvbW1vblRva2VuI3NldFRleHR9IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXJcclxuXHQgKiBjb25zdHJ1Y3RpbmcgdG9rZW5zIHRvIGV4cGxpY2l0bHkgc2V0IHRoZSB0ZXh0LiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXNcclxuXHQgKiB3aGVyZSB0aGUgaW5wdXQgc3RyZWFtIG1pZ2h0IG5vdCBiZSBhYmxlIHRvIHByb3ZpZGUgYXJiaXRyYXJ5IHN1YnN0cmluZ3NcclxuXHQgKiBvZiB0ZXh0IGZyb20gdGhlIGlucHV0IGFmdGVyIHRoZSBsZXhlciBjcmVhdGVzIGEgdG9rZW4gKGUuZy4gdGhlXHJcblx0ICogaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENoYXJTdHJlYW0jZ2V0VGV4dH0gaW5cclxuXHQgKiB7QGxpbmsgVW5idWZmZXJlZENoYXJTdHJlYW19XHJcblx0ICoge0BsaW5rIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9ufSkuIEV4cGxpY2l0bHkgc2V0dGluZyB0aGUgdG9rZW4gdGV4dFxyXG5cdCAqIGFsbG93cyB7QGxpbmsgVG9rZW4jZ2V0VGV4dH0gdG8gYmUgY2FsbGVkIGF0IGFueSB0aW1lIHJlZ2FyZGxlc3Mgb2YgdGhlXHJcblx0ICogaW5wdXQgc3RyZWFtIGltcGxlbWVudGF0aW9uLlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYCB0byBhdm9pZCB0aGUgcGVyZm9ybWFuY2UgYW5kIG1lbW9yeVxyXG5cdCAqIG92ZXJoZWFkIG9mIGNvcHlpbmcgdGV4dCBmb3IgZXZlcnkgdG9rZW4gdW5sZXNzIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBjb3B5VGV4dDogYm9vbGVhbjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBDb21tb25Ub2tlbkZhY3Rvcnl9IHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZSBmb3JcclxuXHQgKiB7QGxpbmsgI2NvcHlUZXh0fS5cclxuXHQgKlxyXG5cdCAqIFdoZW4gYGNvcHlUZXh0YCBpcyBgZmFsc2VgLCB0aGUge0BsaW5rICNERUZBVUxUfSBpbnN0YW5jZVxyXG5cdCAqIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgY29uc3RydWN0aW5nIGEgbmV3IGluc3RhbmNlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGNvcHlUZXh0IFRoZSB2YWx1ZSBmb3Ige0BsaW5rICNjb3B5VGV4dH0uXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoY29weVRleHQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG5cdFx0dGhpcy5jb3B5VGV4dCA9IGNvcHlUZXh0O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGNyZWF0ZShcclxuXHRcdHNvdXJjZTogeyBzb3VyY2U/OiBUb2tlblNvdXJjZSwgc3RyZWFtPzogQ2hhclN0cmVhbSB9LFxyXG5cdFx0dHlwZTogbnVtYmVyLFxyXG5cdFx0dGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkLFxyXG5cdFx0Y2hhbm5lbDogbnVtYmVyLFxyXG5cdFx0c3RhcnQ6IG51bWJlcixcclxuXHRcdHN0b3A6IG51bWJlcixcclxuXHRcdGxpbmU6IG51bWJlcixcclxuXHRcdGNoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyKTogQ29tbW9uVG9rZW4ge1xyXG5cclxuXHRcdGxldCB0OiBDb21tb25Ub2tlbiA9IG5ldyBDb21tb25Ub2tlbih0eXBlLCB0ZXh0LCBzb3VyY2UsIGNoYW5uZWwsIHN0YXJ0LCBzdG9wKTtcclxuXHRcdHQubGluZSA9IGxpbmU7XHJcblx0XHR0LmNoYXJQb3NpdGlvbkluTGluZSA9IGNoYXJQb3NpdGlvbkluTGluZTtcclxuXHRcdGlmICh0ZXh0ID09IG51bGwgJiYgdGhpcy5jb3B5VGV4dCAmJiBzb3VyY2Uuc3RyZWFtICE9IG51bGwpIHtcclxuXHRcdFx0dC50ZXh0ID0gc291cmNlLnN0cmVhbS5nZXRUZXh0KEludGVydmFsLm9mKHN0YXJ0LCBzdG9wKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgY3JlYXRlU2ltcGxlKHR5cGU6IG51bWJlciwgdGV4dDogc3RyaW5nKTogQ29tbW9uVG9rZW4ge1xyXG5cdFx0cmV0dXJuIG5ldyBDb21tb25Ub2tlbih0eXBlLCB0ZXh0KTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgQ29tbW9uVG9rZW5GYWN0b3J5IHtcclxuXHQvKipcclxuXHQgKiBUaGUgZGVmYXVsdCB7QGxpbmsgQ29tbW9uVG9rZW5GYWN0b3J5fSBpbnN0YW5jZS5cclxuXHQgKlxyXG5cdCAqIFRoaXMgdG9rZW4gZmFjdG9yeSBkb2VzIG5vdCBleHBsaWNpdGx5IGNvcHkgdG9rZW4gdGV4dCB3aGVuIGNvbnN0cnVjdGluZ1xyXG5cdCAqIHRva2Vucy5cclxuXHQgKi9cclxuXHRleHBvcnQgY29uc3QgREVGQVVMVDogVG9rZW5GYWN0b3J5ID0gbmV3IENvbW1vblRva2VuRmFjdG9yeSgpO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0MC42NjQ3MTAxLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBJbnRlZ2VyTGlzdCB9IGZyb20gXCIuL0ludGVnZXJMaXN0XCI7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEludGVnZXJTdGFjayBleHRlbmRzIEludGVnZXJMaXN0IHtcclxuXHJcblx0Y29uc3RydWN0b3IoYXJnPzogbnVtYmVyIHwgSW50ZWdlclN0YWNrKSB7XHJcblx0XHRzdXBlcihhcmcpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHB1c2godmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5hZGQodmFsdWUpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHBvcCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlQXQodGhpcy5zaXplIC0gMSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcGVlaygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0KHRoaXMuc2l6ZSAtIDEpO1xyXG5cdH1cclxuXHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM4LjExNzIwNzYtMDc6MDBcclxuXHJcbmltcG9ydCB7IExleGVyQWN0aW9uRXhlY3V0b3IgfSBmcm9tIFwiLi4vYXRuL0xleGVyQWN0aW9uRXhlY3V0b3JcIjtcclxuXHJcbi8qKlxyXG4gKiBTdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgYSB7QGxpbmsgREZBU3RhdGV9IHdoaWNoIGlzIGFuIGFjY2VwdCBzdGF0ZSB1bmRlclxyXG4gKiBzb21lIGNvbmRpdGlvbi4gQ2VydGFpbiBzZXR0aW5ncywgc3VjaCBhc1xyXG4gKiB7QGxpbmsgUGFyc2VyQVROU2ltdWxhdG9yI2dldFByZWRpY3Rpb25Nb2RlKCl9LCBtYXkgYmUgdXNlZCBpbiBhZGRpdGlvbiB0b1xyXG4gKiB0aGlzIGluZm9ybWF0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIHBhcnRpY3VsYXIgc3RhdGUgaXMgYW4gYWNjZXB0XHJcbiAqIHN0YXRlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWNjZXB0U3RhdGVJbmZvIHtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9wcmVkaWN0aW9uOiBudW1iZXI7XHJcblx0cHJpdmF0ZSByZWFkb25seSBfbGV4ZXJBY3Rpb25FeGVjdXRvcj86IExleGVyQWN0aW9uRXhlY3V0b3I7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHByZWRpY3Rpb246IG51bWJlcik7XHJcblx0Y29uc3RydWN0b3IocHJlZGljdGlvbjogbnVtYmVyLCBsZXhlckFjdGlvbkV4ZWN1dG9yOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHwgdW5kZWZpbmVkKTtcclxuXHRjb25zdHJ1Y3RvcihwcmVkaWN0aW9uOiBudW1iZXIsIGxleGVyQWN0aW9uRXhlY3V0b3I/OiBMZXhlckFjdGlvbkV4ZWN1dG9yKSB7XHJcblx0XHR0aGlzLl9wcmVkaWN0aW9uID0gcHJlZGljdGlvbjtcclxuXHRcdHRoaXMuX2xleGVyQWN0aW9uRXhlY3V0b3IgPSBsZXhlckFjdGlvbkV4ZWN1dG9yO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgcHJlZGljdGlvbiBtYWRlIGJ5IHRoaXMgYWNjZXB0IHN0YXRlLiBOb3RlIHRoYXQgdGhpcyB2YWx1ZVxyXG5cdCAqIGFzc3VtZXMgdGhlIHByZWRpY2F0ZXMsIGlmIGFueSwgaW4gdGhlIHtAbGluayBERkFTdGF0ZX0gZXZhbHVhdGUgdG9cclxuXHQgKiBgdHJ1ZWAuIElmIHByZWRpY2F0ZSBldmFsdWF0aW9uIGlzIGVuYWJsZWQsIHRoZSBmaW5hbCBwcmVkaWN0aW9uIG9mXHJcblx0ICogdGhlIGFjY2VwdCBzdGF0ZSB3aWxsIGJlIGRldGVybWluZWQgYnkgdGhlIHJlc3VsdCBvZiBwcmVkaWNhdGVcclxuXHQgKiBldmFsdWF0aW9uLlxyXG5cdCAqL1xyXG5cdGdldCBwcmVkaWN0aW9uKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcHJlZGljdGlvbjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yfSB3aGljaCBjYW4gYmUgdXNlZCB0byBleGVjdXRlIGFjdGlvbnNcclxuXHQgKiBhbmQvb3IgY29tbWFuZHMgYWZ0ZXIgdGhlIGxleGVyIG1hdGNoZXMgYSB0b2tlbi5cclxuXHQgKi9cclxuXHRnZXQgbGV4ZXJBY3Rpb25FeGVjdXRvcigpOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLl9sZXhlckFjdGlvbkV4ZWN1dG9yO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG5pbXBvcnQgeyBBcnJheTJESGFzaFNldCB9IGZyb20gXCIuL0FycmF5MkRIYXNoU2V0XCI7XHJcbmltcG9ydCB7IERlZmF1bHRFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi9EZWZhdWx0RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IEVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuL0VxdWFsaXR5Q29tcGFyYXRvclwiO1xyXG5pbXBvcnQgeyBFcXVhdGFibGUsIEphdmFDb2xsZWN0aW9uLCBKYXZhTWFwLCBKYXZhU2V0IH0gZnJvbSBcIi4vU3R1YnNcIjtcclxuXHJcbi8vIFNpbmNlIGBBcnJheTJESGFzaE1hcGAgaXMgaW1wbGVtZW50ZWQgb24gdG9wIG9mIGBBcnJheTJESGFzaFNldGAsIHdlIGRlZmluZWQgYSBidWNrZXQgdHlwZSB3aGljaCBjYW4gc3RvcmUgYVxyXG4vLyBrZXktdmFsdWUgcGFpci4gVGhlIHZhbHVlIGlzIG9wdGlvbmFsIHNpbmNlIGxvb2tpbmcgdXAgdmFsdWVzIGluIHRoZSBtYXAgYnkgYSBrZXkgb25seSBuZWVkcyB0byBpbmNsdWRlIHRoZSBrZXkuXHJcbmludGVyZmFjZSBCdWNrZXQ8SywgVj4geyBrZXk6IEs7IHZhbHVlPzogVjsgfVxyXG5cclxuY2xhc3MgTWFwS2V5RXF1YWxpdHlDb21wYXJhdG9yPEssIFY+IGltcGxlbWVudHMgRXF1YWxpdHlDb21wYXJhdG9yPEJ1Y2tldDxLLCBWPj4ge1xyXG5cdHByaXZhdGUgcmVhZG9ubHkga2V5Q29tcGFyYXRvcjogRXF1YWxpdHlDb21wYXJhdG9yPEs+O1xyXG5cclxuXHRjb25zdHJ1Y3RvcihrZXlDb21wYXJhdG9yOiBFcXVhbGl0eUNvbXBhcmF0b3I8Sz4pIHtcclxuXHRcdHRoaXMua2V5Q29tcGFyYXRvciA9IGtleUNvbXBhcmF0b3I7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaGFzaENvZGUob2JqOiBCdWNrZXQ8SywgVj4pOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMua2V5Q29tcGFyYXRvci5oYXNoQ29kZShvYmoua2V5KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBlcXVhbHMoYTogQnVja2V0PEssIFY+LCBiOiBCdWNrZXQ8SywgVj4pOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmtleUNvbXBhcmF0b3IuZXF1YWxzKGEua2V5LCBiLmtleSk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQXJyYXkyREhhc2hNYXA8SywgVj4gaW1wbGVtZW50cyBKYXZhTWFwPEssIFY+IHtcclxuXHRwcml2YXRlIGJhY2tpbmdTdG9yZTogQXJyYXkyREhhc2hTZXQ8QnVja2V0PEssIFY+PjtcclxuXHJcblx0Y29uc3RydWN0b3Ioa2V5Q29tcGFyZXI6IEVxdWFsaXR5Q29tcGFyYXRvcjxLPik7XHJcblx0Y29uc3RydWN0b3IobWFwOiBBcnJheTJESGFzaE1hcDxLLCBWPik7XHJcblx0Y29uc3RydWN0b3Ioa2V5Q29tcGFyZXI6IEVxdWFsaXR5Q29tcGFyYXRvcjxLPiB8IEFycmF5MkRIYXNoTWFwPEssIFY+KSB7XHJcblx0XHRpZiAoa2V5Q29tcGFyZXIgaW5zdGFuY2VvZiBBcnJheTJESGFzaE1hcCkge1xyXG5cdFx0XHR0aGlzLmJhY2tpbmdTdG9yZSA9IG5ldyBBcnJheTJESGFzaFNldDxCdWNrZXQ8SywgVj4+KGtleUNvbXBhcmVyLmJhY2tpbmdTdG9yZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmJhY2tpbmdTdG9yZSA9IG5ldyBBcnJheTJESGFzaFNldDxCdWNrZXQ8SywgVj4+KG5ldyBNYXBLZXlFcXVhbGl0eUNvbXBhcmF0b3I8SywgVj4oa2V5Q29tcGFyZXIpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcclxuXHRcdHRoaXMuYmFja2luZ1N0b3JlLmNsZWFyKCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY29udGFpbnNLZXkoa2V5OiBLKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUuY29udGFpbnMoeyBrZXkgfSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0KGtleTogSyk6IFYgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IGJ1Y2tldCA9IHRoaXMuYmFja2luZ1N0b3JlLmdldCh7IGtleSB9KTtcclxuXHRcdGlmICghYnVja2V0KSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJ1Y2tldC52YWx1ZTtcclxuXHR9XHJcblxyXG5cdGdldCBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuYmFja2luZ1N0b3JlLmlzRW1wdHk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcHV0KGtleTogSywgdmFsdWU6IFYpOiBWIHwgdW5kZWZpbmVkIHtcclxuXHRcdGxldCBlbGVtZW50ID0gdGhpcy5iYWNraW5nU3RvcmUuZ2V0KHsga2V5LCB2YWx1ZSB9KTtcclxuXHRcdGxldCByZXN1bHQ6IFYgfCB1bmRlZmluZWQ7XHJcblx0XHRpZiAoIWVsZW1lbnQpIHtcclxuXHRcdFx0dGhpcy5iYWNraW5nU3RvcmUuYWRkKHsga2V5LCB2YWx1ZSB9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlc3VsdCA9IGVsZW1lbnQudmFsdWU7XHJcblx0XHRcdGVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIHB1dElmQWJzZW50KGtleTogSywgdmFsdWU6IFYpOiBWIHwgdW5kZWZpbmVkIHtcclxuXHRcdGxldCBlbGVtZW50ID0gdGhpcy5iYWNraW5nU3RvcmUuZ2V0KHsga2V5LCB2YWx1ZSB9KTtcclxuXHRcdGxldCByZXN1bHQ6IFYgfCB1bmRlZmluZWQ7XHJcblx0XHRpZiAoIWVsZW1lbnQpIHtcclxuXHRcdFx0dGhpcy5iYWNraW5nU3RvcmUuYWRkKHsga2V5LCB2YWx1ZSB9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlc3VsdCA9IGVsZW1lbnQudmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdGdldCBzaXplKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUuc2l6ZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuYmFja2luZ1N0b3JlLmhhc2hDb2RlKCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZXF1YWxzKG86IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKCEobyBpbnN0YW5jZW9mIEFycmF5MkRIYXNoTWFwKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYmFja2luZ1N0b3JlLmVxdWFscyhvLmJhY2tpbmdTdG9yZSk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOC40MzgxMTAzLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGVjaXNpb25TdGF0ZSBleHRlbmRzIEFUTlN0YXRlIHtcclxuXHRwdWJsaWMgZGVjaXNpb246IG51bWJlciA9IC0xO1xyXG5cdHB1YmxpYyBub25HcmVlZHk6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwdWJsaWMgc2xsOiBib29sZWFuID0gZmFsc2U7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM1LjYzOTA2MTQtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFycmF5MkRIYXNoTWFwIH0gZnJvbSBcIi4uL21pc2MvQXJyYXkyREhhc2hNYXBcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBKYXZhTWFwIH0gZnJvbSBcIi4uL21pc2MvU3R1YnNcIjtcclxuaW1wb3J0IHsgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IFByZWRpY3Rpb25Db250ZXh0IH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRcIjtcclxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcclxuXHJcbi8qKiBVc2VkIHRvIGNhY2hlIHtAbGluayBQcmVkaWN0aW9uQ29udGV4dH0gb2JqZWN0cy4gSXRzIHVzZWQgZm9yIHRoZSBzaGFyZWRcclxuICogIGNvbnRleHQgY2FzaCBhc3NvY2lhdGVkIHdpdGggY29udGV4dHMgaW4gREZBIHN0YXRlcy4gVGhpcyBjYWNoZVxyXG4gKiAgY2FuIGJlIHVzZWQgZm9yIGJvdGggbGV4ZXJzIGFuZCBwYXJzZXJzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUHJlZGljdGlvbkNvbnRleHRDYWNoZSB7XHJcblx0cHVibGljIHN0YXRpYyBVTkNBQ0hFRDogUHJlZGljdGlvbkNvbnRleHRDYWNoZSA9IG5ldyBQcmVkaWN0aW9uQ29udGV4dENhY2hlKGZhbHNlKTtcclxuXHJcblx0cHJpdmF0ZSBjb250ZXh0czogSmF2YU1hcDxQcmVkaWN0aW9uQ29udGV4dCwgUHJlZGljdGlvbkNvbnRleHQ+ID1cclxuXHRcdG5ldyBBcnJheTJESGFzaE1hcDxQcmVkaWN0aW9uQ29udGV4dCwgUHJlZGljdGlvbkNvbnRleHQ+KE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSk7XHJcblx0cHJpdmF0ZSBjaGlsZENvbnRleHRzOiBKYXZhTWFwPFByZWRpY3Rpb25Db250ZXh0Q2FjaGUuUHJlZGljdGlvbkNvbnRleHRBbmRJbnQsIFByZWRpY3Rpb25Db250ZXh0PiA9XHJcblx0XHRuZXcgQXJyYXkyREhhc2hNYXA8UHJlZGljdGlvbkNvbnRleHRDYWNoZS5QcmVkaWN0aW9uQ29udGV4dEFuZEludCwgUHJlZGljdGlvbkNvbnRleHQ+KE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSk7XHJcblx0cHJpdmF0ZSBqb2luQ29udGV4dHM6IEphdmFNYXA8UHJlZGljdGlvbkNvbnRleHRDYWNoZS5JZGVudGl0eUNvbW11dGF0aXZlUHJlZGljdGlvbkNvbnRleHRPcGVyYW5kcywgUHJlZGljdGlvbkNvbnRleHQ+ID1cclxuXHRcdG5ldyBBcnJheTJESGFzaE1hcDxQcmVkaWN0aW9uQ29udGV4dENhY2hlLklkZW50aXR5Q29tbXV0YXRpdmVQcmVkaWN0aW9uQ29udGV4dE9wZXJhbmRzLCBQcmVkaWN0aW9uQ29udGV4dD4oT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcclxuXHJcblx0cHJpdmF0ZSBlbmFibGVDYWNoZTogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IoZW5hYmxlQ2FjaGU6IGJvb2xlYW4gPSB0cnVlKSB7XHJcblx0XHR0aGlzLmVuYWJsZUNhY2hlID0gZW5hYmxlQ2FjaGU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0QXNDYWNoZWQoY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRpZiAoIXRoaXMuZW5hYmxlQ2FjaGUpIHtcclxuXHRcdFx0cmV0dXJuIGNvbnRleHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJlc3VsdCA9IHRoaXMuY29udGV4dHMuZ2V0KGNvbnRleHQpO1xyXG5cdFx0aWYgKCFyZXN1bHQpIHtcclxuXHRcdFx0cmVzdWx0ID0gY29udGV4dDtcclxuXHRcdFx0dGhpcy5jb250ZXh0cy5wdXQoY29udGV4dCwgY29udGV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRDaGlsZChjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCwgaW52b2tpbmdTdGF0ZTogbnVtYmVyKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0aWYgKCF0aGlzLmVuYWJsZUNhY2hlKSB7XHJcblx0XHRcdHJldHVybiBjb250ZXh0LmdldENoaWxkKGludm9raW5nU3RhdGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBvcGVyYW5kczogUHJlZGljdGlvbkNvbnRleHRDYWNoZS5QcmVkaWN0aW9uQ29udGV4dEFuZEludCA9IG5ldyBQcmVkaWN0aW9uQ29udGV4dENhY2hlLlByZWRpY3Rpb25Db250ZXh0QW5kSW50KGNvbnRleHQsIGludm9raW5nU3RhdGUpO1xyXG5cdFx0bGV0IHJlc3VsdCA9IHRoaXMuY2hpbGRDb250ZXh0cy5nZXQob3BlcmFuZHMpO1xyXG5cdFx0aWYgKCFyZXN1bHQpIHtcclxuXHRcdFx0cmVzdWx0ID0gY29udGV4dC5nZXRDaGlsZChpbnZva2luZ1N0YXRlKTtcclxuXHRcdFx0cmVzdWx0ID0gdGhpcy5nZXRBc0NhY2hlZChyZXN1bHQpO1xyXG5cdFx0XHR0aGlzLmNoaWxkQ29udGV4dHMucHV0KG9wZXJhbmRzLCByZXN1bHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgam9pbih4OiBQcmVkaWN0aW9uQ29udGV4dCwgeTogUHJlZGljdGlvbkNvbnRleHQpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRpZiAoIXRoaXMuZW5hYmxlQ2FjaGUpIHtcclxuXHRcdFx0cmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LmpvaW4oeCwgeSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG9wZXJhbmRzOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlLklkZW50aXR5Q29tbXV0YXRpdmVQcmVkaWN0aW9uQ29udGV4dE9wZXJhbmRzID0gbmV3IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUuSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHMoeCwgeSk7XHJcblx0XHRsZXQgcmVzdWx0ID0gdGhpcy5qb2luQ29udGV4dHMuZ2V0KG9wZXJhbmRzKTtcclxuXHRcdGlmIChyZXN1bHQpIHtcclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXN1bHQgPSBQcmVkaWN0aW9uQ29udGV4dC5qb2luKHgsIHksIHRoaXMpO1xyXG5cdFx0cmVzdWx0ID0gdGhpcy5nZXRBc0NhY2hlZChyZXN1bHQpO1xyXG5cdFx0dGhpcy5qb2luQ29udGV4dHMucHV0KG9wZXJhbmRzLCByZXN1bHQpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgUHJlZGljdGlvbkNvbnRleHRDYWNoZSB7XHJcblx0ZXhwb3J0IGNsYXNzIFByZWRpY3Rpb25Db250ZXh0QW5kSW50IHtcclxuXHRcdHByaXZhdGUgb2JqOiBQcmVkaWN0aW9uQ29udGV4dDtcclxuXHRcdHByaXZhdGUgdmFsdWU6IG51bWJlcjtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcihvYmo6IFByZWRpY3Rpb25Db250ZXh0LCB2YWx1ZTogbnVtYmVyKSB7XHJcblx0XHRcdHRoaXMub2JqID0gb2JqO1xyXG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbiB7XHJcblx0XHRcdGlmICghKG9iaiBpbnN0YW5jZW9mIFByZWRpY3Rpb25Db250ZXh0QW5kSW50KSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fSBlbHNlIGlmIChvYmogPT09IHRoaXMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IG90aGVyOiBQcmVkaWN0aW9uQ29udGV4dEFuZEludCA9IG9iajtcclxuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWUgPT09IG90aGVyLnZhbHVlXHJcblx0XHRcdFx0JiYgKHRoaXMub2JqID09PSBvdGhlci5vYmogfHwgKHRoaXMub2JqICE9IG51bGwgJiYgdGhpcy5vYmouZXF1YWxzKG90aGVyLm9iaikpKTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0XHRsZXQgaGFzaENvZGU6IG51bWJlciA9IDU7XHJcblx0XHRcdGhhc2hDb2RlID0gNyAqIGhhc2hDb2RlICsgKHRoaXMub2JqICE9IG51bGwgPyB0aGlzLm9iai5oYXNoQ29kZSgpIDogMCk7XHJcblx0XHRcdGhhc2hDb2RlID0gNyAqIGhhc2hDb2RlICsgdGhpcy52YWx1ZTtcclxuXHRcdFx0cmV0dXJuIGhhc2hDb2RlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZXhwb3J0IGNsYXNzIElkZW50aXR5Q29tbXV0YXRpdmVQcmVkaWN0aW9uQ29udGV4dE9wZXJhbmRzIHtcclxuXHRcdHByaXZhdGUgX3g6IFByZWRpY3Rpb25Db250ZXh0O1xyXG5cdFx0cHJpdmF0ZSBfeTogUHJlZGljdGlvbkNvbnRleHQ7XHJcblxyXG5cdFx0Y29uc3RydWN0b3IoeDogUHJlZGljdGlvbkNvbnRleHQsIHk6IFByZWRpY3Rpb25Db250ZXh0KSB7XHJcblx0XHRcdGFzc2VydCh4ICE9IG51bGwpO1xyXG5cdFx0XHRhc3NlcnQoeSAhPSBudWxsKTtcclxuXHRcdFx0dGhpcy5feCA9IHg7XHJcblx0XHRcdHRoaXMuX3kgPSB5O1xyXG5cdFx0fVxyXG5cclxuXHRcdGdldCB4KCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX3g7XHJcblx0XHR9XHJcblxyXG5cdFx0Z2V0IHkoKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5feTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBlcXVhbHMobzogYW55KTogYm9vbGVhbiB7XHJcblx0XHRcdGlmICghKG8gaW5zdGFuY2VvZiBJZGVudGl0eUNvbW11dGF0aXZlUHJlZGljdGlvbkNvbnRleHRPcGVyYW5kcykpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcyA9PT0gbykge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgb3RoZXI6IElkZW50aXR5Q29tbXV0YXRpdmVQcmVkaWN0aW9uQ29udGV4dE9wZXJhbmRzID0gbztcclxuXHRcdFx0cmV0dXJuICh0aGlzLl94ID09PSBvdGhlci5feCAmJiB0aGlzLl95ID09PSBvdGhlci5feSkgfHwgKHRoaXMuX3ggPT09IG90aGVyLl95ICYmIHRoaXMuX3kgPT09IG90aGVyLl94KTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5feC5oYXNoQ29kZSgpIF4gdGhpcy5feS5oYXNoQ29kZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzUuMzgxMjYzNi0wNzowMFxyXG5cclxuXHJcbmltcG9ydCB7IEFycmF5MkRIYXNoTWFwIH0gZnJvbSBcIi4uL21pc2MvQXJyYXkyREhhc2hNYXBcIjtcclxuaW1wb3J0IHsgQXJyYXkyREhhc2hTZXQgfSBmcm9tIFwiLi4vbWlzYy9BcnJheTJESGFzaFNldFwiO1xyXG5pbXBvcnQgeyBBcnJheXMgfSBmcm9tIFwiLi4vbWlzYy9BcnJheXNcIjtcclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vQVROXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgRXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvRXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgRXF1YXRhYmxlLCBKYXZhU2V0IH0gZnJvbSBcIi4uL21pc2MvU3R1YnNcIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbkNvbnRleHRDYWNoZSB9IGZyb20gXCIuL1ByZWRpY3Rpb25Db250ZXh0Q2FjaGVcIjtcclxuaW1wb3J0IHsgUmVjb2duaXplciB9IGZyb20gXCIuLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFJ1bGVDb250ZXh0IH0gZnJvbSBcIi4uL1J1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IFJ1bGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vUnVsZVRyYW5zaXRpb25cIjtcclxuXHJcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XHJcblxyXG5jb25zdCBJTklUSUFMX0hBU0g6IG51bWJlciA9IDE7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUHJlZGljdGlvbkNvbnRleHQgaW1wbGVtZW50cyBFcXVhdGFibGUge1xyXG5cdC8qKlxyXG5cdCAqIFN0b3JlcyB0aGUgY29tcHV0ZWQgaGFzaCBjb2RlIG9mIHRoaXMge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0fS4gVGhlIGhhc2hcclxuXHQgKiBjb2RlIGlzIGNvbXB1dGVkIGluIHBhcnRzIHRvIG1hdGNoIHRoZSBmb2xsb3dpbmcgcmVmZXJlbmNlIGFsZ29yaXRobS5cclxuXHQgKlxyXG5cdCAqIGBgYFxyXG5cdCAqIHByaXZhdGUgaW50IHJlZmVyZW5jZUhhc2hDb2RlKCkge1xyXG5cdCAqICAgaW50IGhhc2ggPSB7QGxpbmsgTXVybXVySGFzaCNpbml0aWFsaXplIE11cm11ckhhc2guaW5pdGlhbGl6ZX0oe0BsaW5rICNJTklUSUFMX0hBU0h9KTtcclxuXHQgKlxyXG5cdCAqICAgZm9yIChpbnQgaSA9IDA7IGkgJmx0OyB0aGlzLnNpemU7IGkrKykge1xyXG5cdCAqICAgICBoYXNoID0ge0BsaW5rIE11cm11ckhhc2gjdXBkYXRlIE11cm11ckhhc2gudXBkYXRlfShoYXNoLCB7QGxpbmsgI2dldFBhcmVudCBnZXRQYXJlbnR9KGkpKTtcclxuXHQgKiAgIH1cclxuXHQgKlxyXG5cdCAqICAgZm9yIChpbnQgaSA9IDA7IGkgJmx0OyB0aGlzLnNpemU7IGkrKykge1xyXG5cdCAqICAgICBoYXNoID0ge0BsaW5rIE11cm11ckhhc2gjdXBkYXRlIE11cm11ckhhc2gudXBkYXRlfShoYXNoLCB7QGxpbmsgI2dldFJldHVyblN0YXRlIGdldFJldHVyblN0YXRlfShpKSk7XHJcblx0ICogICB9XHJcblx0ICpcclxuXHQgKiAgIGhhc2ggPSB7QGxpbmsgTXVybXVySGFzaCNmaW5pc2ggTXVybXVySGFzaC5maW5pc2h9KGhhc2gsIDIgKiB0aGlzLnNpemUpO1xyXG5cdCAqICAgcmV0dXJuIGhhc2g7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqL1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgY2FjaGVkSGFzaENvZGU6IG51bWJlcjtcclxuXHJcblx0Y29uc3RydWN0b3IoY2FjaGVkSGFzaENvZGU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5jYWNoZWRIYXNoQ29kZSA9IGNhY2hlZEhhc2hDb2RlO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHN0YXRpYyBjYWxjdWxhdGVFbXB0eUhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKElOSVRJQUxfSEFTSCk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC5maW5pc2goaGFzaCwgMCk7XHJcblx0XHRyZXR1cm4gaGFzaDtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBzdGF0aWMgY2FsY3VsYXRlU2luZ2xlSGFzaENvZGUocGFyZW50OiBQcmVkaWN0aW9uQ29udGV4dCwgcmV0dXJuU3RhdGU6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKElOSVRJQUxfSEFTSCk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgcGFyZW50KTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCByZXR1cm5TdGF0ZSk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC5maW5pc2goaGFzaCwgMik7XHJcblx0XHRyZXR1cm4gaGFzaDtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBzdGF0aWMgY2FsY3VsYXRlSGFzaENvZGUocGFyZW50czogUHJlZGljdGlvbkNvbnRleHRbXSwgcmV0dXJuU3RhdGVzOiBudW1iZXJbXSk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKElOSVRJQUxfSEFTSCk7XHJcblxyXG5cdFx0Zm9yIChsZXQgcGFyZW50IG9mIHBhcmVudHMpIHtcclxuXHRcdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHBhcmVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgcmV0dXJuU3RhdGUgb2YgcmV0dXJuU3RhdGVzKSB7XHJcblx0XHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCByZXR1cm5TdGF0ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aGFzaCA9IE11cm11ckhhc2guZmluaXNoKGhhc2gsIDIgKiBwYXJlbnRzLmxlbmd0aCk7XHJcblx0XHRyZXR1cm4gaGFzaDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBzaXplOiBudW1iZXI7XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCBnZXRSZXR1cm5TdGF0ZShpbmRleDogbnVtYmVyKTogbnVtYmVyO1xyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgZmluZFJldHVyblN0YXRlKHJldHVyblN0YXRlOiBudW1iZXIpOiBudW1iZXI7XHJcblxyXG5cdC8vIEBOb3ROdWxsXHJcblx0cHVibGljIGFic3RyYWN0IGdldFBhcmVudChpbmRleDogbnVtYmVyKTogUHJlZGljdGlvbkNvbnRleHQ7XHJcblxyXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBhZGRFbXB0eUNvbnRleHQoKTogUHJlZGljdGlvbkNvbnRleHQ7XHJcblxyXG5cdHByb3RlY3RlZCBhYnN0cmFjdCByZW1vdmVFbXB0eUNvbnRleHQoKTogUHJlZGljdGlvbkNvbnRleHQ7XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZnJvbVJ1bGVDb250ZXh0KGF0bjogQVROLCBvdXRlckNvbnRleHQ6IFJ1bGVDb250ZXh0LCBmdWxsQ29udGV4dDogYm9vbGVhbiA9IHRydWUpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRpZiAob3V0ZXJDb250ZXh0LmlzRW1wdHkpIHtcclxuXHRcdFx0cmV0dXJuIGZ1bGxDb250ZXh0ID8gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTCA6IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBwYXJlbnQ6IFByZWRpY3Rpb25Db250ZXh0O1xyXG5cdFx0aWYgKG91dGVyQ29udGV4dC5fcGFyZW50KSB7XHJcblx0XHRcdHBhcmVudCA9IFByZWRpY3Rpb25Db250ZXh0LmZyb21SdWxlQ29udGV4dChhdG4sIG91dGVyQ29udGV4dC5fcGFyZW50LCBmdWxsQ29udGV4dCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwYXJlbnQgPSBmdWxsQ29udGV4dCA/IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTEwgOiBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9MT0NBTDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgc3RhdGU6IEFUTlN0YXRlID0gYXRuLnN0YXRlc1tvdXRlckNvbnRleHQuaW52b2tpbmdTdGF0ZV07XHJcblx0XHRsZXQgdHJhbnNpdGlvbjogUnVsZVRyYW5zaXRpb24gPSBzdGF0ZS50cmFuc2l0aW9uKDApIGFzIFJ1bGVUcmFuc2l0aW9uO1xyXG5cdFx0cmV0dXJuIHBhcmVudC5nZXRDaGlsZCh0cmFuc2l0aW9uLmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGFkZEVtcHR5Q29udGV4dChjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdHJldHVybiBjb250ZXh0LmFkZEVtcHR5Q29udGV4dCgpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVtb3ZlRW1wdHlDb250ZXh0KGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0KTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0cmV0dXJuIGNvbnRleHQucmVtb3ZlRW1wdHlDb250ZXh0KCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc3RhdGljIGpvaW4oQE5vdE51bGwgY29udGV4dDA6IFByZWRpY3Rpb25Db250ZXh0LCBATm90TnVsbCBjb250ZXh0MTogUHJlZGljdGlvbkNvbnRleHQsIEBOb3ROdWxsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSA9IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUuVU5DQUNIRUQpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRpZiAoY29udGV4dDAgPT09IGNvbnRleHQxKSB7XHJcblx0XHRcdHJldHVybiBjb250ZXh0MDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dDAuaXNFbXB0eSkge1xyXG5cdFx0XHRyZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKGNvbnRleHQwKSA/IGNvbnRleHQwIDogUHJlZGljdGlvbkNvbnRleHQuYWRkRW1wdHlDb250ZXh0KGNvbnRleHQxKTtcclxuXHRcdH0gZWxzZSBpZiAoY29udGV4dDEuaXNFbXB0eSkge1xyXG5cdFx0XHRyZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKGNvbnRleHQxKSA/IGNvbnRleHQxIDogUHJlZGljdGlvbkNvbnRleHQuYWRkRW1wdHlDb250ZXh0KGNvbnRleHQwKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgY29udGV4dDBzaXplOiBudW1iZXIgPSBjb250ZXh0MC5zaXplO1xyXG5cdFx0bGV0IGNvbnRleHQxc2l6ZTogbnVtYmVyID0gY29udGV4dDEuc2l6ZTtcclxuXHRcdGlmIChjb250ZXh0MHNpemUgPT09IDEgJiYgY29udGV4dDFzaXplID09PSAxICYmIGNvbnRleHQwLmdldFJldHVyblN0YXRlKDApID09PSBjb250ZXh0MS5nZXRSZXR1cm5TdGF0ZSgwKSkge1xyXG5cdFx0XHRsZXQgbWVyZ2VkOiBQcmVkaWN0aW9uQ29udGV4dCA9IGNvbnRleHRDYWNoZS5qb2luKGNvbnRleHQwLmdldFBhcmVudCgwKSwgY29udGV4dDEuZ2V0UGFyZW50KDApKTtcclxuXHRcdFx0aWYgKG1lcmdlZCA9PT0gY29udGV4dDAuZ2V0UGFyZW50KDApKSB7XHJcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQwO1xyXG5cdFx0XHR9IGVsc2UgaWYgKG1lcmdlZCA9PT0gY29udGV4dDEuZ2V0UGFyZW50KDApKSB7XHJcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQxO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBtZXJnZWQuZ2V0Q2hpbGQoY29udGV4dDAuZ2V0UmV0dXJuU3RhdGUoMCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGNvdW50OiBudW1iZXIgPSAwO1xyXG5cdFx0bGV0IHBhcmVudHNMaXN0OiBQcmVkaWN0aW9uQ29udGV4dFtdID0gbmV3IEFycmF5PFByZWRpY3Rpb25Db250ZXh0Pihjb250ZXh0MHNpemUgKyBjb250ZXh0MXNpemUpO1xyXG5cdFx0bGV0IHJldHVyblN0YXRlc0xpc3Q6IG51bWJlcltdID0gbmV3IEFycmF5PG51bWJlcj4ocGFyZW50c0xpc3QubGVuZ3RoKTtcclxuXHRcdGxldCBsZWZ0SW5kZXg6IG51bWJlciA9IDA7XHJcblx0XHRsZXQgcmlnaHRJbmRleDogbnVtYmVyID0gMDtcclxuXHRcdGxldCBjYW5SZXR1cm5MZWZ0OiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdGxldCBjYW5SZXR1cm5SaWdodDogYm9vbGVhbiA9IHRydWU7XHJcblx0XHR3aGlsZSAobGVmdEluZGV4IDwgY29udGV4dDBzaXplICYmIHJpZ2h0SW5kZXggPCBjb250ZXh0MXNpemUpIHtcclxuXHRcdFx0aWYgKGNvbnRleHQwLmdldFJldHVyblN0YXRlKGxlZnRJbmRleCkgPT09IGNvbnRleHQxLmdldFJldHVyblN0YXRlKHJpZ2h0SW5kZXgpKSB7XHJcblx0XHRcdFx0cGFyZW50c0xpc3RbY291bnRdID0gY29udGV4dENhY2hlLmpvaW4oY29udGV4dDAuZ2V0UGFyZW50KGxlZnRJbmRleCksIGNvbnRleHQxLmdldFBhcmVudChyaWdodEluZGV4KSk7XHJcblx0XHRcdFx0cmV0dXJuU3RhdGVzTGlzdFtjb3VudF0gPSBjb250ZXh0MC5nZXRSZXR1cm5TdGF0ZShsZWZ0SW5kZXgpO1xyXG5cdFx0XHRcdGNhblJldHVybkxlZnQgPSBjYW5SZXR1cm5MZWZ0ICYmIHBhcmVudHNMaXN0W2NvdW50XSA9PT0gY29udGV4dDAuZ2V0UGFyZW50KGxlZnRJbmRleCk7XHJcblx0XHRcdFx0Y2FuUmV0dXJuUmlnaHQgPSBjYW5SZXR1cm5SaWdodCAmJiBwYXJlbnRzTGlzdFtjb3VudF0gPT09IGNvbnRleHQxLmdldFBhcmVudChyaWdodEluZGV4KTtcclxuXHRcdFx0XHRsZWZ0SW5kZXgrKztcclxuXHRcdFx0XHRyaWdodEluZGV4Kys7XHJcblx0XHRcdH0gZWxzZSBpZiAoY29udGV4dDAuZ2V0UmV0dXJuU3RhdGUobGVmdEluZGV4KSA8IGNvbnRleHQxLmdldFJldHVyblN0YXRlKHJpZ2h0SW5kZXgpKSB7XHJcblx0XHRcdFx0cGFyZW50c0xpc3RbY291bnRdID0gY29udGV4dDAuZ2V0UGFyZW50KGxlZnRJbmRleCk7XHJcblx0XHRcdFx0cmV0dXJuU3RhdGVzTGlzdFtjb3VudF0gPSBjb250ZXh0MC5nZXRSZXR1cm5TdGF0ZShsZWZ0SW5kZXgpO1xyXG5cdFx0XHRcdGNhblJldHVyblJpZ2h0ID0gZmFsc2U7XHJcblx0XHRcdFx0bGVmdEluZGV4Kys7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0YXNzZXJ0KGNvbnRleHQxLmdldFJldHVyblN0YXRlKHJpZ2h0SW5kZXgpIDwgY29udGV4dDAuZ2V0UmV0dXJuU3RhdGUobGVmdEluZGV4KSk7XHJcblx0XHRcdFx0cGFyZW50c0xpc3RbY291bnRdID0gY29udGV4dDEuZ2V0UGFyZW50KHJpZ2h0SW5kZXgpO1xyXG5cdFx0XHRcdHJldHVyblN0YXRlc0xpc3RbY291bnRdID0gY29udGV4dDEuZ2V0UmV0dXJuU3RhdGUocmlnaHRJbmRleCk7XHJcblx0XHRcdFx0Y2FuUmV0dXJuTGVmdCA9IGZhbHNlO1xyXG5cdFx0XHRcdHJpZ2h0SW5kZXgrKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y291bnQrKztcclxuXHRcdH1cclxuXHJcblx0XHR3aGlsZSAobGVmdEluZGV4IDwgY29udGV4dDBzaXplKSB7XHJcblx0XHRcdHBhcmVudHNMaXN0W2NvdW50XSA9IGNvbnRleHQwLmdldFBhcmVudChsZWZ0SW5kZXgpO1xyXG5cdFx0XHRyZXR1cm5TdGF0ZXNMaXN0W2NvdW50XSA9IGNvbnRleHQwLmdldFJldHVyblN0YXRlKGxlZnRJbmRleCk7XHJcblx0XHRcdGxlZnRJbmRleCsrO1xyXG5cdFx0XHRjYW5SZXR1cm5SaWdodCA9IGZhbHNlO1xyXG5cdFx0XHRjb3VudCsrO1xyXG5cdFx0fVxyXG5cclxuXHRcdHdoaWxlIChyaWdodEluZGV4IDwgY29udGV4dDFzaXplKSB7XHJcblx0XHRcdHBhcmVudHNMaXN0W2NvdW50XSA9IGNvbnRleHQxLmdldFBhcmVudChyaWdodEluZGV4KTtcclxuXHRcdFx0cmV0dXJuU3RhdGVzTGlzdFtjb3VudF0gPSBjb250ZXh0MS5nZXRSZXR1cm5TdGF0ZShyaWdodEluZGV4KTtcclxuXHRcdFx0cmlnaHRJbmRleCsrO1xyXG5cdFx0XHRjYW5SZXR1cm5MZWZ0ID0gZmFsc2U7XHJcblx0XHRcdGNvdW50Kys7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNhblJldHVybkxlZnQpIHtcclxuXHRcdFx0cmV0dXJuIGNvbnRleHQwO1xyXG5cdFx0fSBlbHNlIGlmIChjYW5SZXR1cm5SaWdodCkge1xyXG5cdFx0XHRyZXR1cm4gY29udGV4dDE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvdW50IDwgcGFyZW50c0xpc3QubGVuZ3RoKSB7XHJcblx0XHRcdHBhcmVudHNMaXN0ID0gcGFyZW50c0xpc3Quc2xpY2UoMCwgY291bnQpO1xyXG5cdFx0XHRyZXR1cm5TdGF0ZXNMaXN0ID0gcmV0dXJuU3RhdGVzTGlzdC5zbGljZSgwLCBjb3VudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHBhcmVudHNMaXN0Lmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHQvLyBpZiBvbmUgb2YgdGhlbSB3YXMgRU1QVFlfTE9DQUwsIGl0IHdvdWxkIGJlIGVtcHR5IGFuZCBoYW5kbGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1ldGhvZFxyXG5cdFx0XHRyZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTDtcclxuXHRcdH0gZWxzZSBpZiAocGFyZW50c0xpc3QubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdHJldHVybiBuZXcgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQocGFyZW50c0xpc3RbMF0sIHJldHVyblN0YXRlc0xpc3RbMF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KHBhcmVudHNMaXN0LCByZXR1cm5TdGF0ZXNMaXN0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgaXNFbXB0eUxvY2FsKGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0KTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gY29udGV4dCA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfTE9DQUw7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc3RhdGljIGdldENhY2hlZENvbnRleHQoXHJcblx0XHRATm90TnVsbCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCxcclxuXHRcdEBOb3ROdWxsIGNvbnRleHRDYWNoZTogQXJyYXkyREhhc2hNYXA8UHJlZGljdGlvbkNvbnRleHQsIFByZWRpY3Rpb25Db250ZXh0PixcclxuXHRcdEBOb3ROdWxsIHZpc2l0ZWQ6IFByZWRpY3Rpb25Db250ZXh0LklkZW50aXR5SGFzaE1hcCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdGlmIChjb250ZXh0LmlzRW1wdHkpIHtcclxuXHRcdFx0cmV0dXJuIGNvbnRleHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGV4aXN0aW5nID0gdmlzaXRlZC5nZXQoY29udGV4dCk7XHJcblx0XHRpZiAoZXhpc3RpbmcpIHtcclxuXHRcdFx0cmV0dXJuIGV4aXN0aW5nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGV4aXN0aW5nID0gY29udGV4dENhY2hlLmdldChjb250ZXh0KTtcclxuXHRcdGlmIChleGlzdGluZykge1xyXG5cdFx0XHR2aXNpdGVkLnB1dChjb250ZXh0LCBleGlzdGluZyk7XHJcblx0XHRcdHJldHVybiBleGlzdGluZztcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgY2hhbmdlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdFx0bGV0IHBhcmVudHM6IFByZWRpY3Rpb25Db250ZXh0W10gPSBuZXcgQXJyYXk8UHJlZGljdGlvbkNvbnRleHQ+KGNvbnRleHQuc2l6ZSk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IHBhcmVudDogUHJlZGljdGlvbkNvbnRleHQgPSBQcmVkaWN0aW9uQ29udGV4dC5nZXRDYWNoZWRDb250ZXh0KGNvbnRleHQuZ2V0UGFyZW50KGkpLCBjb250ZXh0Q2FjaGUsIHZpc2l0ZWQpO1xyXG5cdFx0XHRpZiAoY2hhbmdlZCB8fCBwYXJlbnQgIT09IGNvbnRleHQuZ2V0UGFyZW50KGkpKSB7XHJcblx0XHRcdFx0aWYgKCFjaGFuZ2VkKSB7XHJcblx0XHRcdFx0XHRwYXJlbnRzID0gbmV3IEFycmF5PFByZWRpY3Rpb25Db250ZXh0Pihjb250ZXh0LnNpemUpO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBjb250ZXh0LnNpemU7IGorKykge1xyXG5cdFx0XHRcdFx0XHRwYXJlbnRzW2pdID0gY29udGV4dC5nZXRQYXJlbnQoaik7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwYXJlbnRzW2ldID0gcGFyZW50O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFjaGFuZ2VkKSB7XHJcblx0XHRcdGV4aXN0aW5nID0gY29udGV4dENhY2hlLnB1dElmQWJzZW50KGNvbnRleHQsIGNvbnRleHQpO1xyXG5cdFx0XHR2aXNpdGVkLnB1dChjb250ZXh0LCBleGlzdGluZyAhPSBudWxsID8gZXhpc3RpbmcgOiBjb250ZXh0KTtcclxuXHRcdFx0cmV0dXJuIGNvbnRleHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gV2Uga25vdyBwYXJlbnRzLmxlbmd0aD4wIGJlY2F1c2UgY29udGV4dC5pc0VtcHR5IGlzIGNoZWNrZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbWV0aG9kLlxyXG5cdFx0bGV0IHVwZGF0ZWQ6IFByZWRpY3Rpb25Db250ZXh0O1xyXG5cdFx0aWYgKHBhcmVudHMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdHVwZGF0ZWQgPSBuZXcgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQocGFyZW50c1swXSwgY29udGV4dC5nZXRSZXR1cm5TdGF0ZSgwKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgcmV0dXJuU3RhdGVzOiBudW1iZXJbXSA9IG5ldyBBcnJheTxudW1iZXI+KGNvbnRleHQuc2l6ZSk7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29udGV4dC5zaXplOyBpKyspIHtcclxuXHRcdFx0XHRyZXR1cm5TdGF0ZXNbaV0gPSBjb250ZXh0LmdldFJldHVyblN0YXRlKGkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1cGRhdGVkID0gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQocGFyZW50cywgcmV0dXJuU3RhdGVzLCBjb250ZXh0Lmhhc2hDb2RlKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGV4aXN0aW5nID0gY29udGV4dENhY2hlLnB1dElmQWJzZW50KHVwZGF0ZWQsIHVwZGF0ZWQpO1xyXG5cdFx0dmlzaXRlZC5wdXQodXBkYXRlZCwgZXhpc3RpbmcgfHwgdXBkYXRlZCk7XHJcblx0XHR2aXNpdGVkLnB1dChjb250ZXh0LCBleGlzdGluZyB8fCB1cGRhdGVkKTtcclxuXHJcblx0XHRyZXR1cm4gdXBkYXRlZDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhcHBlbmRTaW5nbGVDb250ZXh0KHJldHVybkNvbnRleHQ6IG51bWJlciwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kQ29udGV4dChQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMLmdldENoaWxkKHJldHVybkNvbnRleHQpLCBjb250ZXh0Q2FjaGUpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFic3RyYWN0IGFwcGVuZENvbnRleHQoc3VmZml4OiBQcmVkaWN0aW9uQ29udGV4dCwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogUHJlZGljdGlvbkNvbnRleHQ7XHJcblxyXG5cdHB1YmxpYyBnZXRDaGlsZChyZXR1cm5TdGF0ZTogbnVtYmVyKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0cmV0dXJuIG5ldyBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCh0aGlzLCByZXR1cm5TdGF0ZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgaXNFbXB0eTogYm9vbGVhbjtcclxuXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGhhc0VtcHR5OiBib29sZWFuO1xyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmNhY2hlZEhhc2hDb2RlO1xyXG5cdH1cclxuXHJcblx0Ly8gQE92ZXJyaWRlXHJcblx0cHVibGljIGFic3RyYWN0IGVxdWFscyhvOiBhbnkpOiBib29sZWFuO1xyXG5cclxuXHRwdWJsaWMgdG9TdHJpbmdzKHJlY29nbml6ZXI6IFJlY29nbml6ZXI8YW55LCBhbnk+IHwgdW5kZWZpbmVkLCBjdXJyZW50U3RhdGU6IG51bWJlciwgc3RvcDogUHJlZGljdGlvbkNvbnRleHQgPSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMKTogc3RyaW5nW10ge1xyXG5cdFx0bGV0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcclxuXHJcblx0XHRvdXRlcjpcclxuXHRcdGZvciAobGV0IHBlcm0gPSAwOyA7IHBlcm0rKykge1xyXG5cdFx0XHRsZXQgb2Zmc2V0OiBudW1iZXIgPSAwO1xyXG5cdFx0XHRsZXQgbGFzdDogYm9vbGVhbiA9IHRydWU7XHJcblx0XHRcdGxldCBwOiBQcmVkaWN0aW9uQ29udGV4dCA9IHRoaXM7XHJcblx0XHRcdGxldCBzdGF0ZU51bWJlcjogbnVtYmVyID0gY3VycmVudFN0YXRlO1xyXG5cdFx0XHRsZXQgbG9jYWxCdWZmZXI6IHN0cmluZyA9IFwiXCI7XHJcblx0XHRcdGxvY2FsQnVmZmVyICs9IFwiW1wiO1xyXG5cdFx0XHR3aGlsZSAoIXAuaXNFbXB0eSAmJiBwICE9PSBzdG9wKSB7XHJcblx0XHRcdFx0bGV0IGluZGV4OiBudW1iZXIgPSAwO1xyXG5cdFx0XHRcdGlmIChwLnNpemUgPiAwKSB7XHJcblx0XHRcdFx0XHRsZXQgYml0czogbnVtYmVyID0gMTtcclxuXHRcdFx0XHRcdHdoaWxlICgoKDEgPDwgYml0cykgPj4+IDApIDwgcC5zaXplKSB7XHJcblx0XHRcdFx0XHRcdGJpdHMrKztcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsZXQgbWFzazogbnVtYmVyID0gKCgxIDw8IGJpdHMpID4+PiAwKSAtIDE7XHJcblx0XHRcdFx0XHRpbmRleCA9IChwZXJtID4+IG9mZnNldCkgJiBtYXNrO1xyXG5cdFx0XHRcdFx0bGFzdCA9IGxhc3QgJiYgaW5kZXggPj0gcC5zaXplIC0gMTtcclxuXHRcdFx0XHRcdGlmIChpbmRleCA+PSBwLnNpemUpIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWUgb3V0ZXI7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ICs9IGJpdHM7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAocmVjb2duaXplcikge1xyXG5cdFx0XHRcdFx0aWYgKGxvY2FsQnVmZmVyLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0Ly8gZmlyc3QgY2hhciBpcyAnWycsIGlmIG1vcmUgdGhhbiB0aGF0IHRoaXMgaXNuJ3QgdGhlIGZpcnN0IHJ1bGVcclxuXHRcdFx0XHRcdFx0bG9jYWxCdWZmZXIgKz0gXCIgXCI7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0IGF0bjogQVROID0gcmVjb2duaXplci5hdG47XHJcblx0XHRcdFx0XHRsZXQgczogQVROU3RhdGUgPSBhdG4uc3RhdGVzW3N0YXRlTnVtYmVyXTtcclxuXHRcdFx0XHRcdGxldCBydWxlTmFtZTogc3RyaW5nID0gcmVjb2duaXplci5ydWxlTmFtZXNbcy5ydWxlSW5kZXhdO1xyXG5cdFx0XHRcdFx0bG9jYWxCdWZmZXIgKz0gcnVsZU5hbWU7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChwLmdldFJldHVyblN0YXRlKGluZGV4KSAhPT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVkpIHtcclxuXHRcdFx0XHRcdGlmICghcC5pc0VtcHR5KSB7XHJcblx0XHRcdFx0XHRcdGlmIChsb2NhbEJ1ZmZlci5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gZmlyc3QgY2hhciBpcyAnWycsIGlmIG1vcmUgdGhhbiB0aGF0IHRoaXMgaXNuJ3QgdGhlIGZpcnN0IHJ1bGVcclxuXHRcdFx0XHRcdFx0XHRsb2NhbEJ1ZmZlciArPSBcIiBcIjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0bG9jYWxCdWZmZXIgKz0gcC5nZXRSZXR1cm5TdGF0ZShpbmRleCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGF0ZU51bWJlciA9IHAuZ2V0UmV0dXJuU3RhdGUoaW5kZXgpO1xyXG5cdFx0XHRcdHAgPSBwLmdldFBhcmVudChpbmRleCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxvY2FsQnVmZmVyICs9IFwiXVwiO1xyXG5cdFx0XHRyZXN1bHQucHVzaChsb2NhbEJ1ZmZlcik7XHJcblxyXG5cdFx0XHRpZiAobGFzdCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcbn1cclxuXHJcbmNsYXNzIEVtcHR5UHJlZGljdGlvbkNvbnRleHQgZXh0ZW5kcyBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0cHJpdmF0ZSBmdWxsQ29udGV4dDogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IoZnVsbENvbnRleHQ6IGJvb2xlYW4pIHtcclxuXHRcdHN1cGVyKFByZWRpY3Rpb25Db250ZXh0LmNhbGN1bGF0ZUVtcHR5SGFzaENvZGUoKSk7XHJcblx0XHR0aGlzLmZ1bGxDb250ZXh0ID0gZnVsbENvbnRleHQ7XHJcblx0fVxyXG5cclxuXHRnZXQgaXNGdWxsQ29udGV4dCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmZ1bGxDb250ZXh0O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIGFkZEVtcHR5Q29udGV4dCgpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCByZW1vdmVFbXB0eUNvbnRleHQoKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgZW1wdHkgY29udGV4dCBmcm9tIGl0c2VsZi5cIik7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0UGFyZW50KGluZGV4OiBudW1iZXIpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGdldFJldHVyblN0YXRlKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBmaW5kUmV0dXJuU3RhdGUocmV0dXJuU3RhdGU6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgYXBwZW5kU2luZ2xlQ29udGV4dChyZXR1cm5Db250ZXh0OiBudW1iZXIsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdHJldHVybiBjb250ZXh0Q2FjaGUuZ2V0Q2hpbGQodGhpcywgcmV0dXJuQ29udGV4dCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgYXBwZW5kQ29udGV4dChzdWZmaXg6IFByZWRpY3Rpb25Db250ZXh0LCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gc3VmZml4O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBoYXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzID09PSBvO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5ncyhyZWNvZ25pemVyOiBhbnksIGN1cnJlbnRTdGF0ZTogbnVtYmVyLCBzdG9wPzogUHJlZGljdGlvbkNvbnRleHQpOiBzdHJpbmdbXSB7XHJcblx0XHRyZXR1cm4gW1wiW11cIl07XHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgQXJyYXlQcmVkaWN0aW9uQ29udGV4dCBleHRlbmRzIFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBwYXJlbnRzOiBQcmVkaWN0aW9uQ29udGV4dFtdO1xyXG5cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyByZXR1cm5TdGF0ZXM6IG51bWJlcltdO1xyXG5cclxuXHRjb25zdHJ1Y3RvciggQE5vdE51bGwgcGFyZW50czogUHJlZGljdGlvbkNvbnRleHRbXSwgcmV0dXJuU3RhdGVzOiBudW1iZXJbXSwgaGFzaENvZGU/OiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKGhhc2hDb2RlIHx8IFByZWRpY3Rpb25Db250ZXh0LmNhbGN1bGF0ZUhhc2hDb2RlKHBhcmVudHMsIHJldHVyblN0YXRlcykpO1xyXG5cdFx0YXNzZXJ0KHBhcmVudHMubGVuZ3RoID09PSByZXR1cm5TdGF0ZXMubGVuZ3RoKTtcclxuXHRcdGFzc2VydChyZXR1cm5TdGF0ZXMubGVuZ3RoID4gMSB8fCByZXR1cm5TdGF0ZXNbMF0gIT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZLCBcIlNob3VsZCBiZSB1c2luZyBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSBpbnN0ZWFkLlwiKTtcclxuXHJcblx0XHR0aGlzLnBhcmVudHMgPSBwYXJlbnRzO1xyXG5cdFx0dGhpcy5yZXR1cm5TdGF0ZXMgPSByZXR1cm5TdGF0ZXM7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0UGFyZW50KGluZGV4OiBudW1iZXIpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRzW2luZGV4XTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXRSZXR1cm5TdGF0ZShpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLnJldHVyblN0YXRlc1tpbmRleF07XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZmluZFJldHVyblN0YXRlKHJldHVyblN0YXRlOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIEFycmF5cy5iaW5hcnlTZWFyY2godGhpcy5yZXR1cm5TdGF0ZXMsIHJldHVyblN0YXRlKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzaXplKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZXMubGVuZ3RoO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaGFzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZXNbdGhpcy5yZXR1cm5TdGF0ZXMubGVuZ3RoIC0gMV0gPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIGFkZEVtcHR5Q29udGV4dCgpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRpZiAodGhpcy5oYXNFbXB0eSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcGFyZW50czI6IFByZWRpY3Rpb25Db250ZXh0W10gPSB0aGlzLnBhcmVudHMuc2xpY2UoMCk7XHJcblx0XHRsZXQgcmV0dXJuU3RhdGVzMjogbnVtYmVyW10gPSB0aGlzLnJldHVyblN0YXRlcy5zbGljZSgwKTtcclxuXHRcdHBhcmVudHMyLnB1c2goUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTCk7XHJcblx0XHRyZXR1cm5TdGF0ZXMyLnB1c2goUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVkpO1xyXG5cdFx0cmV0dXJuIG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KHBhcmVudHMyLCByZXR1cm5TdGF0ZXMyKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCByZW1vdmVFbXB0eUNvbnRleHQoKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0VtcHR5KSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLnJldHVyblN0YXRlcy5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCh0aGlzLnBhcmVudHNbMF0sIHRoaXMucmV0dXJuU3RhdGVzWzBdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBwYXJlbnRzMjogUHJlZGljdGlvbkNvbnRleHRbXSA9IHRoaXMucGFyZW50cy5zbGljZSgwLCB0aGlzLnBhcmVudHMubGVuZ3RoIC0gMSk7XHJcblx0XHRcdGxldCByZXR1cm5TdGF0ZXMyOiBudW1iZXJbXSA9IHRoaXMucmV0dXJuU3RhdGVzLnNsaWNlKDAsIHRoaXMucmV0dXJuU3RhdGVzLmxlbmd0aCAtIDEpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQocGFyZW50czIsIHJldHVyblN0YXRlczIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGFwcGVuZENvbnRleHQoc3VmZml4OiBQcmVkaWN0aW9uQ29udGV4dCwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0cmV0dXJuIEFycmF5UHJlZGljdGlvbkNvbnRleHQuYXBwZW5kQ29udGV4dEltcGwodGhpcywgc3VmZml4LCBuZXcgUHJlZGljdGlvbkNvbnRleHQuSWRlbnRpdHlIYXNoTWFwKCkpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgYXBwZW5kQ29udGV4dEltcGwoY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQsIHN1ZmZpeDogUHJlZGljdGlvbkNvbnRleHQsIHZpc2l0ZWQ6IFByZWRpY3Rpb25Db250ZXh0LklkZW50aXR5SGFzaE1hcCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdGlmIChzdWZmaXguaXNFbXB0eSkge1xyXG5cdFx0XHRpZiAoUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKHN1ZmZpeCkpIHtcclxuXHRcdFx0XHRpZiAoY29udGV4dC5oYXNFbXB0eSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwid2hhdCB0byBkbyBoZXJlP1wiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNvbnRleHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN1ZmZpeC5zaXplICE9PSAxKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkFwcGVuZGluZyBhIHRyZWUgc3VmZml4IGlzIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVzdWx0ID0gdmlzaXRlZC5nZXQoY29udGV4dCk7XHJcblx0XHRpZiAoIXJlc3VsdCkge1xyXG5cdFx0XHRpZiAoY29udGV4dC5pc0VtcHR5KSB7XHJcblx0XHRcdFx0cmVzdWx0ID0gc3VmZml4O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBwYXJlbnRDb3VudDogbnVtYmVyID0gY29udGV4dC5zaXplO1xyXG5cdFx0XHRcdGlmIChjb250ZXh0Lmhhc0VtcHR5KSB7XHJcblx0XHRcdFx0XHRwYXJlbnRDb3VudC0tO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IHVwZGF0ZWRQYXJlbnRzOiBQcmVkaWN0aW9uQ29udGV4dFtdID0gbmV3IEFycmF5PFByZWRpY3Rpb25Db250ZXh0PihwYXJlbnRDb3VudCk7XHJcblx0XHRcdFx0bGV0IHVwZGF0ZWRSZXR1cm5TdGF0ZXM6IG51bWJlcltdID0gbmV3IEFycmF5PG51bWJlcj4ocGFyZW50Q291bnQpO1xyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50Q291bnQ7IGkrKykge1xyXG5cdFx0XHRcdFx0dXBkYXRlZFJldHVyblN0YXRlc1tpXSA9IGNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudENvdW50OyBpKyspIHtcclxuXHRcdFx0XHRcdHVwZGF0ZWRQYXJlbnRzW2ldID0gQXJyYXlQcmVkaWN0aW9uQ29udGV4dC5hcHBlbmRDb250ZXh0SW1wbChjb250ZXh0LmdldFBhcmVudChpKSwgc3VmZml4LCB2aXNpdGVkKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICh1cGRhdGVkUGFyZW50cy5sZW5ndGggPT09IDEpIHtcclxuXHRcdFx0XHRcdHJlc3VsdCA9IG5ldyBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCh1cGRhdGVkUGFyZW50c1swXSwgdXBkYXRlZFJldHVyblN0YXRlc1swXSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGFzc2VydCh1cGRhdGVkUGFyZW50cy5sZW5ndGggPiAxKTtcclxuXHRcdFx0XHRcdHJlc3VsdCA9IG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KHVwZGF0ZWRQYXJlbnRzLCB1cGRhdGVkUmV0dXJuU3RhdGVzKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjb250ZXh0Lmhhc0VtcHR5KSB7XHJcblx0XHRcdFx0XHRyZXN1bHQgPSBQcmVkaWN0aW9uQ29udGV4dC5qb2luKHJlc3VsdCwgc3VmZml4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZpc2l0ZWQucHV0KGNvbnRleHQsIHJlc3VsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMobzogYW55KTogYm9vbGVhbiB7XHJcblx0XHRpZiAodGhpcyA9PT0gbykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAoIShvIGluc3RhbmNlb2YgQXJyYXlQcmVkaWN0aW9uQ29udGV4dCkpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmhhc2hDb2RlKCkgIT09IG8uaGFzaENvZGUoKSkge1xyXG5cdFx0XHQvLyBjYW4ndCBiZSBzYW1lIGlmIGhhc2ggaXMgZGlmZmVyZW50XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgb3RoZXI6IEFycmF5UHJlZGljdGlvbkNvbnRleHQgPSBvO1xyXG5cdFx0cmV0dXJuIHRoaXMuZXF1YWxzSW1wbChvdGhlciwgbmV3IEFycmF5MkRIYXNoU2V0PFByZWRpY3Rpb25Db250ZXh0Q2FjaGUuSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHM+KCkpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBlcXVhbHNJbXBsKG90aGVyOiBBcnJheVByZWRpY3Rpb25Db250ZXh0LCB2aXNpdGVkOiBKYXZhU2V0PFByZWRpY3Rpb25Db250ZXh0Q2FjaGUuSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHM+KTogYm9vbGVhbiB7XHJcblx0XHRsZXQgc2VsZldvcmtMaXN0OiBQcmVkaWN0aW9uQ29udGV4dFtdID0gW107XHJcblx0XHRsZXQgb3RoZXJXb3JrTGlzdDogUHJlZGljdGlvbkNvbnRleHRbXSA9IFtdO1xyXG5cdFx0c2VsZldvcmtMaXN0LnB1c2godGhpcyk7XHJcblx0XHRvdGhlcldvcmtMaXN0LnB1c2gob3RoZXIpO1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0bGV0IGN1cnJlbnRTZWxmID0gc2VsZldvcmtMaXN0LnBvcCgpO1xyXG5cdFx0XHRsZXQgY3VycmVudE90aGVyID0gb3RoZXJXb3JrTGlzdC5wb3AoKTtcclxuXHRcdFx0aWYgKCFjdXJyZW50U2VsZiB8fCAhY3VycmVudE90aGVyKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBvcGVyYW5kczogUHJlZGljdGlvbkNvbnRleHRDYWNoZS5JZGVudGl0eUNvbW11dGF0aXZlUHJlZGljdGlvbkNvbnRleHRPcGVyYW5kcyA9IG5ldyBQcmVkaWN0aW9uQ29udGV4dENhY2hlLklkZW50aXR5Q29tbXV0YXRpdmVQcmVkaWN0aW9uQ29udGV4dE9wZXJhbmRzKGN1cnJlbnRTZWxmLCBjdXJyZW50T3RoZXIpO1xyXG5cdFx0XHRpZiAoIXZpc2l0ZWQuYWRkKG9wZXJhbmRzKSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgc2VsZlNpemU6IG51bWJlciA9IG9wZXJhbmRzLnguc2l6ZTtcclxuXHRcdFx0aWYgKHNlbGZTaXplID09PSAwKSB7XHJcblx0XHRcdFx0aWYgKCFvcGVyYW5kcy54LmVxdWFscyhvcGVyYW5kcy55KSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBvdGhlclNpemU6IG51bWJlciA9IG9wZXJhbmRzLnkuc2l6ZTtcclxuXHRcdFx0aWYgKHNlbGZTaXplICE9PSBvdGhlclNpemUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZlNpemU7IGkrKykge1xyXG5cdFx0XHRcdGlmIChvcGVyYW5kcy54LmdldFJldHVyblN0YXRlKGkpICE9PSBvcGVyYW5kcy55LmdldFJldHVyblN0YXRlKGkpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgc2VsZlBhcmVudDogUHJlZGljdGlvbkNvbnRleHQgPSBvcGVyYW5kcy54LmdldFBhcmVudChpKTtcclxuXHRcdFx0XHRsZXQgb3RoZXJQYXJlbnQ6IFByZWRpY3Rpb25Db250ZXh0ID0gb3BlcmFuZHMueS5nZXRQYXJlbnQoaSk7XHJcblx0XHRcdFx0aWYgKHNlbGZQYXJlbnQuaGFzaENvZGUoKSAhPT0gb3RoZXJQYXJlbnQuaGFzaENvZGUoKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHNlbGZQYXJlbnQgIT09IG90aGVyUGFyZW50KSB7XHJcblx0XHRcdFx0XHRzZWxmV29ya0xpc3QucHVzaChzZWxmUGFyZW50KTtcclxuXHRcdFx0XHRcdG90aGVyV29ya0xpc3QucHVzaChvdGhlclBhcmVudCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQgZXh0ZW5kcyBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHBhcmVudDogUHJlZGljdGlvbkNvbnRleHQ7XHJcblx0cHVibGljIHJldHVyblN0YXRlOiBudW1iZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHBhcmVudDogUHJlZGljdGlvbkNvbnRleHQsIHJldHVyblN0YXRlOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKFByZWRpY3Rpb25Db250ZXh0LmNhbGN1bGF0ZVNpbmdsZUhhc2hDb2RlKHBhcmVudCwgcmV0dXJuU3RhdGUpKTtcclxuXHRcdC8vIGFzc2VydChyZXR1cm5TdGF0ZSAhPSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSAmJiByZXR1cm5TdGF0ZSAhPSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9MT0NBTF9TVEFURV9LRVkpO1xyXG5cdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblx0XHR0aGlzLnJldHVyblN0YXRlID0gcmV0dXJuU3RhdGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0UGFyZW50KGluZGV4OiBudW1iZXIpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHQvLyBhc3NlcnQoaW5kZXggPT0gMCk7XHJcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0UmV0dXJuU3RhdGUoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHQvLyBhc3NlcnQoaW5kZXggPT0gMCk7XHJcblx0XHRyZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBmaW5kUmV0dXJuU3RhdGUocmV0dXJuU3RhdGU6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZSA9PT0gcmV0dXJuU3RhdGUgPyAwIDogLTE7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIDE7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBoYXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBhcHBlbmRDb250ZXh0KHN1ZmZpeDogUHJlZGljdGlvbkNvbnRleHQsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdHJldHVybiBjb250ZXh0Q2FjaGUuZ2V0Q2hpbGQodGhpcy5wYXJlbnQuYXBwZW5kQ29udGV4dChzdWZmaXgsIGNvbnRleHRDYWNoZSksIHRoaXMucmV0dXJuU3RhdGUpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIGFkZEVtcHR5Q29udGV4dCgpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRsZXQgcGFyZW50czogUHJlZGljdGlvbkNvbnRleHRbXSA9IFt0aGlzLnBhcmVudCwgUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF07XHJcblx0XHRsZXQgcmV0dXJuU3RhdGVzOiBudW1iZXJbXSA9IFt0aGlzLnJldHVyblN0YXRlLCBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWV07XHJcblx0XHRyZXR1cm4gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQocGFyZW50cywgcmV0dXJuU3RhdGVzKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCByZW1vdmVFbXB0eUNvbnRleHQoKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG86IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG8gPT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKCEobyBpbnN0YW5jZW9mIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0KSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG90aGVyOiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCA9IG87XHJcblx0XHRpZiAodGhpcy5oYXNoQ29kZSgpICE9PSBvdGhlci5oYXNoQ29kZSgpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZSA9PT0gb3RoZXIucmV0dXJuU3RhdGVcclxuXHRcdFx0JiYgdGhpcy5wYXJlbnQuZXF1YWxzKG90aGVyLnBhcmVudCk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRleHBvcnQgY29uc3QgRU1QVFlfTE9DQUw6IFByZWRpY3Rpb25Db250ZXh0ID0gbmV3IEVtcHR5UHJlZGljdGlvbkNvbnRleHQoZmFsc2UpO1xyXG5cdGV4cG9ydCBjb25zdCBFTVBUWV9GVUxMOiBQcmVkaWN0aW9uQ29udGV4dCA9IG5ldyBFbXB0eVByZWRpY3Rpb25Db250ZXh0KHRydWUpO1xyXG5cdGV4cG9ydCBjb25zdCBFTVBUWV9MT0NBTF9TVEFURV9LRVk6IG51bWJlciA9IC0oKDEgPDwgMzEpID4+PiAwKTtcclxuXHRleHBvcnQgY29uc3QgRU1QVFlfRlVMTF9TVEFURV9LRVk6IG51bWJlciA9ICgoMSA8PCAzMSkgPj4+IDApIC0gMTtcclxuXHJcblx0ZXhwb3J0IGNsYXNzIElkZW50aXR5SGFzaE1hcCBleHRlbmRzIEFycmF5MkRIYXNoTWFwPFByZWRpY3Rpb25Db250ZXh0LCBQcmVkaWN0aW9uQ29udGV4dD4ge1xyXG5cdFx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRcdHN1cGVyKElkZW50aXR5RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGV4cG9ydCBjbGFzcyBJZGVudGl0eUVxdWFsaXR5Q29tcGFyYXRvciBpbXBsZW1lbnRzIEVxdWFsaXR5Q29tcGFyYXRvcjxQcmVkaWN0aW9uQ29udGV4dD4ge1xyXG5cdFx0cHVibGljIHN0YXRpYyByZWFkb25seSBJTlNUQU5DRTogSWRlbnRpdHlFcXVhbGl0eUNvbXBhcmF0b3IgPSBuZXcgSWRlbnRpdHlFcXVhbGl0eUNvbXBhcmF0b3IoKTtcclxuXHJcblx0XHRwcml2YXRlIElkZW50aXR5RXF1YWxpdHlDb21wYXJhdG9yKCkge1xyXG5cdFx0XHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgaGFzaENvZGUob2JqOiBQcmVkaWN0aW9uQ29udGV4dCk6IG51bWJlciB7XHJcblx0XHRcdHJldHVybiBvYmouaGFzaENvZGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBlcXVhbHMoYTogUHJlZGljdGlvbkNvbnRleHQsIGI6IFByZWRpY3Rpb25Db250ZXh0KTogYm9vbGVhbiB7XHJcblx0XHRcdHJldHVybiBhID09PSBiO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjUuMjc5NjY5Mi0wNzowMFxyXG5cclxuaW1wb3J0IHsgQXJyYXkyREhhc2hNYXAgfSBmcm9tIFwiLi4vbWlzYy9BcnJheTJESGFzaE1hcFwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IERlY2lzaW9uU3RhdGUgfSBmcm9tIFwiLi9EZWNpc2lvblN0YXRlXCI7XHJcbmltcG9ydCB7IEVxdWF0YWJsZSB9IGZyb20gXCIuLi9taXNjL1N0dWJzXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uRXhlY3V0b3IgfSBmcm9tIFwiLi9MZXhlckFjdGlvbkV4ZWN1dG9yXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IFByZWRpY3Rpb25Db250ZXh0IH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRcIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbkNvbnRleHRDYWNoZSB9IGZyb20gXCIuL1ByZWRpY3Rpb25Db250ZXh0Q2FjaGVcIjtcclxuaW1wb3J0IHsgUmVjb2duaXplciB9IGZyb20gXCIuLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFNlbWFudGljQ29udGV4dCB9IGZyb20gXCIuL1NlbWFudGljQ29udGV4dFwiO1xyXG5cclxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZpZWxkIHN0b3JlcyB0aGUgYml0IG1hc2sgZm9yIGltcGxlbWVudGluZyB0aGVcclxuICoge0BsaW5rICNpc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkfSBwcm9wZXJ0eSBhcyBhIGJpdCB3aXRoaW4gdGhlXHJcbiAqIGV4aXN0aW5nIHtAbGluayAjYWx0QW5kT3V0ZXJDb250ZXh0RGVwdGh9IGZpZWxkLlxyXG4gKi9cclxuY29uc3QgU1VQUFJFU1NfUFJFQ0VERU5DRV9GSUxURVI6IG51bWJlciA9IDB4ODAwMDAwMDA7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGxvY2F0aW9uIHdpdGggY29udGV4dCBpbiBhbiBBVE4uIFRoZSBsb2NhdGlvbiBpcyBpZGVudGlmaWVkIGJ5IHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxyXG4gKlxyXG4gKiAqIFRoZSBjdXJyZW50IEFUTiBzdGF0ZVxyXG4gKiAqIFRoZSBwcmVkaWN0ZWQgYWx0ZXJuYXRpdmVcclxuICogKiBUaGUgc2VtYW50aWMgY29udGV4dCB3aGljaCBtdXN0IGJlIHRydWUgZm9yIHRoaXMgY29uZmlndXJhdGlvbiB0byBiZSBlbmFibGVkXHJcbiAqICogVGhlIHN5bnRhY3RpYyBjb250ZXh0LCB3aGljaCBpcyByZXByZXNlbnRlZCBhcyBhIGdyYXBoLXN0cnVjdHVyZWQgc3RhY2sgd2hvc2UgcGF0aChzKSBsZWFkIHRvIHRoZSByb290IG9mIHRoZSBydWxlXHJcbiAqICAgaW52b2NhdGlvbnMgbGVhZGluZyB0byB0aGlzIHN0YXRlXHJcbiAqXHJcbiAqIEluIGFkZGl0aW9uIHRvIHRoZXNlIHZhbHVlcywgYEFUTkNvbmZpZ2Agc3RvcmVzIHNldmVyYWwgcHJvcGVydGllcyBhYm91dCBwYXRocyB0YWtlbiB0byBnZXQgdG8gdGhlIGxvY2F0aW9uIHdoaWNoXHJcbiAqIHdlcmUgYWRkZWQgb3ZlciB0aW1lIHRvIGhlbHAgd2l0aCBwZXJmb3JtYW5jZSwgY29ycmVjdG5lc3MsIGFuZC9vciBkZWJ1Z2dpbmcuXHJcbiAqXHJcbiAqICogYHJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0YDo6IFVzZWQgdG8gZW5zdXJlIHNlbWFudGljIHByZWRpY2F0ZXMgYXJlIG5vdCBldmFsdWF0ZWQgaW4gdGhlIHdyb25nIGNvbnRleHQuXHJcbiAqICogYGhhc1Bhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbmA6IFVzZWQgZm9yIGVuYWJsaW5nIGZpcnN0LW1hdGNoLXdpbnMgaW5zdGVhZCBvZiBsb25nZXN0LW1hdGNoLXdpbnMgYWZ0ZXJcclxuICogICBjcm9zc2luZyBhIG5vbi1ncmVlZHkgZGVjaXNpb24uXHJcbiAqICogYGxleGVyQWN0aW9uRXhlY3V0b3JgOiBVc2VkIGZvciB0cmFja2luZyB0aGUgbGV4ZXIgYWN0aW9uKHMpIHRvIGV4ZWN1dGUgc2hvdWxkIHRoaXMgaW5zdGFuY2UgYmUgc2VsZWN0ZWQgZHVyaW5nXHJcbiAqICAgbGV4aW5nLlxyXG4gKiAqIGBpc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkYDogQSBzdGF0ZSB2YXJpYWJsZSBmb3Igb25lIG9mIHRoZSBkeW5hbWljIGRpc2FtYmlndWF0aW9uIHN0cmF0ZWdpZXMgZW1wbG95ZWQgYnlcclxuICogICBgUGFyc2VyQVROU2ltdWxhdG9yLmFwcGx5UHJlY2VkZW5jZUZpbHRlcmAuXHJcbiAqXHJcbiAqIER1ZSB0byB0aGUgdXNlIG9mIGEgZ3JhcGgtc3RydWN0dXJlZCBzdGFjaywgYSBzaW5nbGUgYEFUTkNvbmZpZ2AgaXMgY2FwYWJsZSBvZiByZXByZXNlbnRpbmcgbWFueSBpbmRpdmlkdWFsIEFUTlxyXG4gKiBjb25maWd1cmF0aW9ucyB3aGljaCByZWFjaGVkIHRoZSBzYW1lIGxvY2F0aW9uIGluIGFuIEFUTiBieSBmb2xsb3dpbmcgZGlmZmVyZW50IHBhdGhzLlxyXG4gKlxyXG4gKiBQRVJGOiBUbyBjb25zZXJ2ZSBtZW1vcnksIGBBVE5Db25maWdgIGlzIHNwbGl0IGludG8gc2V2ZXJhbCBkaWZmZXJlbnQgY29uY3JldGUgdHlwZXMuIGBBVE5Db25maWdgIGl0c2VsZiBzdG9yZXMgdGhlXHJcbiAqIG1pbmltdW0gYW1vdW50IG9mIGluZm9ybWF0aW9uIHR5cGljYWxseSB1c2VkIHRvIGRlZmluZSBhbiBgQVROQ29uZmlnYCBpbnN0YW5jZS4gVmFyaW91cyBkZXJpdmVkIHR5cGVzIHByb3ZpZGVcclxuICogYWRkaXRpb25hbCBzdG9yYWdlIHNwYWNlIGZvciBjYXNlcyB3aGVyZSBhIG5vbi1kZWZhdWx0IHZhbHVlIGlzIHVzZWQgZm9yIHNvbWUgb2YgdGhlIG9iamVjdCBwcm9wZXJ0aWVzLiBUaGVcclxuICogYEFUTkNvbmZpZy5jcmVhdGVgIGFuZCBgQVROQ29uZmlnLnRyYW5zZm9ybWAgbWV0aG9kcyBhdXRvbWF0aWNhbGx5IHNlbGVjdCB0aGUgc21hbGxlc3QgY29uY3JldGUgdHlwZSBjYXBhYmxlIG9mXHJcbiAqIHJlcHJlc2VudGluZyB0aGUgdW5pcXVlIGluZm9ybWF0aW9uIGZvciBhbnkgZ2l2ZW4gYEFUTkNvbmZpZ2AuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQVROQ29uZmlnIGltcGxlbWVudHMgRXF1YXRhYmxlIHtcclxuXHQvKiogVGhlIEFUTiBzdGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25maWd1cmF0aW9uICovXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIF9zdGF0ZTogQVROU3RhdGU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgYSBiaXQtZmllbGQgY3VycmVudGx5IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXMuXHJcblx0ICpcclxuXHQgKiAqIDB4MDBGRkZGRkY6IEFsdGVybmF0aXZlXHJcblx0ICogKiAweDdGMDAwMDAwOiBPdXRlciBjb250ZXh0IGRlcHRoXHJcblx0ICogKiAweDgwMDAwMDAwOiBTdXBwcmVzcyBwcmVjZWRlbmNlIGZpbHRlclxyXG5cdCAqL1xyXG5cdHByaXZhdGUgYWx0QW5kT3V0ZXJDb250ZXh0RGVwdGg6IG51bWJlcjtcclxuXHJcblx0LyoqIFRoZSBzdGFjayBvZiBpbnZva2luZyBzdGF0ZXMgbGVhZGluZyB0byB0aGUgcnVsZS9zdGF0ZXMgYXNzb2NpYXRlZFxyXG5cdCAqICB3aXRoIHRoaXMgY29uZmlnLiAgV2UgdHJhY2sgb25seSB0aG9zZSBjb250ZXh0cyBwdXNoZWQgZHVyaW5nXHJcblx0ICogIGV4ZWN1dGlvbiBvZiB0aGUgQVROIHNpbXVsYXRvci5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgX2NvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0O1xyXG5cclxuXHRjb25zdHJ1Y3RvcigvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCBhbHQ6IG51bWJlciwgLypATm90TnVsbCovIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0KTtcclxuXHRjb25zdHJ1Y3RvcigvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCAvKkBOb3ROdWxsKi8gYzogQVROQ29uZmlnLCAvKkBOb3ROdWxsKi8gY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCBzdGF0ZTogQVROU3RhdGUsIGFsdE9yQ29uZmlnOiBudW1iZXIgfCBBVE5Db25maWcsIEBOb3ROdWxsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0KSB7XHJcblx0XHRpZiAodHlwZW9mIGFsdE9yQ29uZmlnID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdGFzc2VydCgoYWx0T3JDb25maWcgJiAweEZGRkZGRikgPT09IGFsdE9yQ29uZmlnKTtcclxuXHRcdFx0dGhpcy5fc3RhdGUgPSBzdGF0ZTtcclxuXHRcdFx0dGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCA9IGFsdE9yQ29uZmlnO1xyXG5cdFx0XHR0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX3N0YXRlID0gc3RhdGU7XHJcblx0XHRcdHRoaXMuYWx0QW5kT3V0ZXJDb250ZXh0RGVwdGggPSBhbHRPckNvbmZpZy5hbHRBbmRPdXRlckNvbnRleHREZXB0aDtcclxuXHRcdFx0dGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc3RhdGljIGNyZWF0ZSgvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCBhbHQ6IG51bWJlciwgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpOiBBVE5Db25maWc7XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgY3JlYXRlKC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIGFsdDogbnVtYmVyLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCwgLypATm90TnVsbCovIHNlbWFudGljQ29udGV4dDogU2VtYW50aWNDb250ZXh0KTogQVROQ29uZmlnO1xyXG5cclxuXHRwdWJsaWMgc3RhdGljIGNyZWF0ZSgvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCBhbHQ6IG51bWJlciwgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQsIC8qQCovIHNlbWFudGljQ29udGV4dDogU2VtYW50aWNDb250ZXh0LCBsZXhlckFjdGlvbkV4ZWN1dG9yOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHwgdW5kZWZpbmVkKTogQVROQ29uZmlnO1xyXG5cclxuXHRwdWJsaWMgc3RhdGljIGNyZWF0ZShATm90TnVsbCBzdGF0ZTogQVROU3RhdGUsIGFsdDogbnVtYmVyLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCwgQE5vdE51bGwgc2VtYW50aWNDb250ZXh0OiBTZW1hbnRpY0NvbnRleHQgPSBTZW1hbnRpY0NvbnRleHQuTk9ORSwgbGV4ZXJBY3Rpb25FeGVjdXRvcj86IExleGVyQWN0aW9uRXhlY3V0b3IpOiBBVE5Db25maWcge1xyXG5cdFx0aWYgKHNlbWFudGljQ29udGV4dCAhPT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcclxuXHRcdFx0aWYgKGxleGVyQWN0aW9uRXhlY3V0b3IgIT0gbnVsbCkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgQWN0aW9uU2VtYW50aWNDb250ZXh0QVROQ29uZmlnKGxleGVyQWN0aW9uRXhlY3V0b3IsIHNlbWFudGljQ29udGV4dCwgc3RhdGUsIGFsdCwgY29udGV4dCwgZmFsc2UpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgU2VtYW50aWNDb250ZXh0QVROQ29uZmlnKHNlbWFudGljQ29udGV4dCwgc3RhdGUsIGFsdCwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGxleGVyQWN0aW9uRXhlY3V0b3IgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEFjdGlvbkFUTkNvbmZpZyhsZXhlckFjdGlvbkV4ZWN1dG9yLCBzdGF0ZSwgYWx0LCBjb250ZXh0LCBmYWxzZSk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBBVE5Db25maWcoc3RhdGUsIGFsdCwgY29udGV4dCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogR2V0cyB0aGUgQVROIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbmZpZ3VyYXRpb24gKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBzdGF0ZSgpOiBBVE5TdGF0ZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RhdGU7XHJcblx0fVxyXG5cclxuXHQvKiogV2hhdCBhbHQgKG9yIGxleGVyIHJ1bGUpIGlzIHByZWRpY3RlZCBieSB0aGlzIGNvbmZpZ3VyYXRpb24gKi9cclxuXHRnZXQgYWx0KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCAmIDB4MDBGRkZGRkY7XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdGdldCBjb250ZXh0KCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0O1xyXG5cdH1cclxuXHJcblx0c2V0IGNvbnRleHQoQE5vdE51bGwgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpIHtcclxuXHRcdHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG5cdH1cclxuXHJcblx0Z2V0IHJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMub3V0ZXJDb250ZXh0RGVwdGggIT09IDA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBXZSBjYW5ub3QgZXhlY3V0ZSBwcmVkaWNhdGVzIGRlcGVuZGVudCB1cG9uIGxvY2FsIGNvbnRleHQgdW5sZXNzXHJcblx0ICogd2Uga25vdyBmb3Igc3VyZSB3ZSBhcmUgaW4gdGhlIGNvcnJlY3QgY29udGV4dC4gQmVjYXVzZSB0aGVyZSBpc1xyXG5cdCAqIG5vIHdheSB0byBkbyB0aGlzIGVmZmljaWVudGx5LCB3ZSBzaW1wbHkgY2Fubm90IGV2YWx1YXRlXHJcblx0ICogZGVwZW5kZW50IHByZWRpY2F0ZXMgdW5sZXNzIHdlIGFyZSBpbiB0aGUgcnVsZSB0aGF0IGluaXRpYWxseVxyXG5cdCAqIGludm9rZXMgdGhlIEFUTiBzaW11bGF0b3IuXHJcblx0ICpcclxuXHQgKiBjbG9zdXJlKCkgdHJhY2tzIHRoZSBkZXB0aCBvZiBob3cgZmFyIHdlIGRpcCBpbnRvIHRoZSBvdXRlciBjb250ZXh0OlxyXG5cdCAqIGRlcHRoICZndDsgMC4gIE5vdGUgdGhhdCBpdCBtYXkgbm90IGJlIHRvdGFsbHkgYWNjdXJhdGUgZGVwdGggc2luY2UgSVxyXG5cdCAqIGRvbid0IGV2ZXIgZGVjcmVtZW50LiBUT0RPOiBtYWtlIGl0IGEgYm9vbGVhbiB0aGVuXHJcblx0ICovXHJcblx0Z2V0IG91dGVyQ29udGV4dERlcHRoKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gKHRoaXMuYWx0QW5kT3V0ZXJDb250ZXh0RGVwdGggPj4+IDI0KSAmIDB4N0Y7XHJcblx0fVxyXG5cclxuXHRzZXQgb3V0ZXJDb250ZXh0RGVwdGgob3V0ZXJDb250ZXh0RGVwdGg6IG51bWJlcikge1xyXG5cdFx0YXNzZXJ0KG91dGVyQ29udGV4dERlcHRoID49IDApO1xyXG5cdFx0Ly8gc2F0dXJhdGUgYXQgMHg3RiAtIGV2ZXJ5dGhpbmcgYnV0IHplcm8vcG9zaXRpdmUgaXMgb25seSB1c2VkIGZvciBkZWJ1ZyBpbmZvcm1hdGlvbiBhbnl3YXlcclxuXHRcdG91dGVyQ29udGV4dERlcHRoID0gTWF0aC5taW4ob3V0ZXJDb250ZXh0RGVwdGgsIDB4N0YpO1xyXG5cdFx0dGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCA9ICgob3V0ZXJDb250ZXh0RGVwdGggPDwgMjQpIHwgKHRoaXMuYWx0QW5kT3V0ZXJDb250ZXh0RGVwdGggJiB+MHg3RjAwMDAwMCkgPj4+IDApO1xyXG5cdH1cclxuXHJcblx0Z2V0IGxleGVyQWN0aW9uRXhlY3V0b3IoKTogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRnZXQgc2VtYW50aWNDb250ZXh0KCk6IFNlbWFudGljQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gU2VtYW50aWNDb250ZXh0Lk5PTkU7XHJcblx0fVxyXG5cclxuXHRnZXQgaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGNsb25lKCk6IEFUTkNvbmZpZyB7XHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0odGhpcy5zdGF0ZSwgZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRyYW5zZm9ybSgvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCBjaGVja05vbkdyZWVkeTogYm9vbGVhbik6IEFUTkNvbmZpZztcclxuXHRwdWJsaWMgdHJhbnNmb3JtKC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIGNoZWNrTm9uR3JlZWR5OiBib29sZWFuLCAvKkBOb3ROdWxsKi8gc2VtYW50aWNDb250ZXh0OiBTZW1hbnRpY0NvbnRleHQpOiBBVE5Db25maWc7XHJcblx0cHVibGljIHRyYW5zZm9ybSgvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCBjaGVja05vbkdyZWVkeTogYm9vbGVhbiwgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpOiBBVE5Db25maWc7XHJcblx0cHVibGljIHRyYW5zZm9ybSgvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCBjaGVja05vbkdyZWVkeTogYm9vbGVhbiwgbGV4ZXJBY3Rpb25FeGVjdXRvcjogTGV4ZXJBY3Rpb25FeGVjdXRvcik6IEFUTkNvbmZpZztcclxuXHRwdWJsaWMgdHJhbnNmb3JtKC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIGNoZWNrTm9uR3JlZWR5OiBib29sZWFuLCBhcmcyPzogU2VtYW50aWNDb250ZXh0IHwgUHJlZGljdGlvbkNvbnRleHQgfCBMZXhlckFjdGlvbkV4ZWN1dG9yKTogQVROQ29uZmlnIHtcclxuXHRcdGlmIChhcmcyID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtSW1wbChzdGF0ZSwgdGhpcy5fY29udGV4dCwgdGhpcy5zZW1hbnRpY0NvbnRleHQsIGNoZWNrTm9uR3JlZWR5LCB0aGlzLmxleGVyQWN0aW9uRXhlY3V0b3IpO1xyXG5cdFx0fSBlbHNlIGlmIChhcmcyIGluc3RhbmNlb2YgUHJlZGljdGlvbkNvbnRleHQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtSW1wbChzdGF0ZSwgYXJnMiwgdGhpcy5zZW1hbnRpY0NvbnRleHQsIGNoZWNrTm9uR3JlZWR5LCB0aGlzLmxleGVyQWN0aW9uRXhlY3V0b3IpO1xyXG5cdFx0fSBlbHNlIGlmIChhcmcyIGluc3RhbmNlb2YgU2VtYW50aWNDb250ZXh0KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybUltcGwoc3RhdGUsIHRoaXMuX2NvbnRleHQsIGFyZzIsIGNoZWNrTm9uR3JlZWR5LCB0aGlzLmxleGVyQWN0aW9uRXhlY3V0b3IpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtSW1wbChzdGF0ZSwgdGhpcy5fY29udGV4dCwgdGhpcy5zZW1hbnRpY0NvbnRleHQsIGNoZWNrTm9uR3JlZWR5LCBhcmcyKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgdHJhbnNmb3JtSW1wbChATm90TnVsbCBzdGF0ZTogQVROU3RhdGUsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LCBATm90TnVsbCBzZW1hbnRpY0NvbnRleHQ6IFNlbWFudGljQ29udGV4dCwgY2hlY2tOb25HcmVlZHk6IGJvb2xlYW4sIGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQpOiBBVE5Db25maWcge1xyXG5cdFx0bGV0IHBhc3NlZFRocm91Z2hOb25HcmVlZHk6IGJvb2xlYW4gPSBjaGVja05vbkdyZWVkeSAmJiBBVE5Db25maWcuY2hlY2tOb25HcmVlZHlEZWNpc2lvbih0aGlzLCBzdGF0ZSk7XHJcblx0XHRpZiAoc2VtYW50aWNDb250ZXh0ICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xyXG5cdFx0XHRpZiAobGV4ZXJBY3Rpb25FeGVjdXRvciAhPSBudWxsIHx8IHBhc3NlZFRocm91Z2hOb25HcmVlZHkpIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IEFjdGlvblNlbWFudGljQ29udGV4dEFUTkNvbmZpZyhsZXhlckFjdGlvbkV4ZWN1dG9yLCBzZW1hbnRpY0NvbnRleHQsIHN0YXRlLCB0aGlzLCBjb250ZXh0LCBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFNlbWFudGljQ29udGV4dEFUTkNvbmZpZyhzZW1hbnRpY0NvbnRleHQsIHN0YXRlLCB0aGlzLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAobGV4ZXJBY3Rpb25FeGVjdXRvciAhPSBudWxsIHx8IHBhc3NlZFRocm91Z2hOb25HcmVlZHkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBBY3Rpb25BVE5Db25maWcobGV4ZXJBY3Rpb25FeGVjdXRvciwgc3RhdGUsIHRoaXMsIGNvbnRleHQsIHBhc3NlZFRocm91Z2hOb25HcmVlZHkpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHJldHVybiBuZXcgQVROQ29uZmlnKHN0YXRlLCB0aGlzLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGNoZWNrTm9uR3JlZWR5RGVjaXNpb24oc291cmNlOiBBVE5Db25maWcsIHRhcmdldDogQVROU3RhdGUpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBzb3VyY2UuaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uXHJcblx0XHRcdHx8IHRhcmdldCBpbnN0YW5jZW9mIERlY2lzaW9uU3RhdGUgJiYgdGFyZ2V0Lm5vbkdyZWVkeTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhcHBlbmRDb250ZXh0KGNvbnRleHQ6IG51bWJlciwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogQVROQ29uZmlnO1xyXG5cdHB1YmxpYyBhcHBlbmRDb250ZXh0KGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBBVE5Db25maWc7XHJcblx0cHVibGljIGFwcGVuZENvbnRleHQoY29udGV4dDogbnVtYmVyIHwgUHJlZGljdGlvbkNvbnRleHQsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IEFUTkNvbmZpZyB7XHJcblx0XHRpZiAodHlwZW9mIGNvbnRleHQgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0bGV0IGFwcGVuZGVkQ29udGV4dDogUHJlZGljdGlvbkNvbnRleHQgPSB0aGlzLmNvbnRleHQuYXBwZW5kU2luZ2xlQ29udGV4dChjb250ZXh0LCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRsZXQgcmVzdWx0OiBBVE5Db25maWcgPSB0aGlzLnRyYW5zZm9ybSh0aGlzLnN0YXRlLCBmYWxzZSwgYXBwZW5kZWRDb250ZXh0KTtcclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBhcHBlbmRlZENvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0ID0gdGhpcy5jb250ZXh0LmFwcGVuZENvbnRleHQoY29udGV4dCwgY29udGV4dENhY2hlKTtcclxuXHRcdFx0bGV0IHJlc3VsdDogQVROQ29uZmlnID0gdGhpcy50cmFuc2Zvcm0odGhpcy5zdGF0ZSwgZmFsc2UsIGFwcGVuZGVkQ29udGV4dCk7XHJcblx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoaXMgYEFUTkNvbmZpZ2AgZnVsbHkgY29udGFpbnMgYW5vdGhlciBgQVROQ29uZmlnYC5cclxuXHQgKlxyXG5cdCAqIEFuIEFUTiBjb25maWd1cmF0aW9uIHJlcHJlc2VudHMgYSBwb3NpdGlvbiAoaW5jbHVkaW5nIGNvbnRleHQpIGluIGFuIEFUTiBkdXJpbmcgcGFyc2luZy4gU2luY2UgYEFUTkNvbmZpZ2Agc3RvcmVzXHJcblx0ICogdGhlIGNvbnRleHQgYXMgYSBncmFwaCwgYSBzaW5nbGUgYEFUTkNvbmZpZ2AgaW5zdGFuY2UgaXMgY2FwYWJsZSBvZiByZXByZXNlbnRpbmcgbWFueSBBVE4gY29uZmlndXJhdGlvbnMgd2hpY2hcclxuXHQgKiBhcmUgYWxsIGluIHRoZSBzYW1lIFwibG9jYXRpb25cIiBidXQgaGF2ZSBkaWZmZXJlbnQgY29udGV4dHMuIFRoZXNlIGBBVE5Db25maWdgIGluc3RhbmNlcyBhcmUgYWdhaW4gbWVyZ2VkIHdoZW5cclxuXHQgKiB0aGV5IGFyZSBhZGRlZCB0byBhbiBgQVROQ29uZmlnU2V0YC4gVGhpcyBtZXRob2Qgc3VwcG9ydHMgYEFUTkNvbmZpZ1NldC5jb250YWluc2AgYnkgZXZhbHVhdGluZyB3aGV0aGVyIGFcclxuXHQgKiBwYXJ0aWN1bGFyIGBBVE5Db25maWdgIGNvbnRhaW5zIGFsbCBvZiB0aGUgQVROIGNvbmZpZ3VyYXRpb25zIHJlcHJlc2VudGVkIGJ5IGFub3RoZXIgYEFUTkNvbmZpZ2AuXHJcblx0ICpcclxuXHQgKiBBbiBgQVROQ29uZmlnYCBfYV8gY29udGFpbnMgYW5vdGhlciBgQVROQ29uZmlnYCBfYl8gaWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG5cdCAqXHJcblx0ICogKiBUaGUgY29uZmlndXJhdGlvbnMgYXJlIGluIHRoZSBzYW1lIHN0YXRlIChgc3RhdGVgKVxyXG5cdCAqICogVGhlIGNvbmZpZ3VyYXRpb25zIHByZWRpY3QgdGhlIHNhbWUgYWx0ZXJuYXRpdmUgKGBhbHRgKVxyXG5cdCAqICogVGhlIHNlbWFudGljIGNvbnRleHQgb2YgX2FfIGltcGxpZXMgdGhlIHNlbWFudGljIGNvbnRleHQgb2YgX2JfICh0aGlzIG1ldGhvZCBwZXJmb3JtcyBhIHdlYWtlciBlcXVhbGl0eSBjaGVjaylcclxuXHQgKiAqIEpvaW5pbmcgdGhlIHByZWRpY3Rpb24gY29udGV4dHMgb2YgX2FfIGFuZCBfYl8gcmVzdWx0cyBpbiB0aGUgcHJlZGljdGlvbiBjb250ZXh0IG9mIF9hX1xyXG5cdCAqXHJcblx0ICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyBhIGNvbnNlcnZhdGl2ZSBhcHByb3hpbWF0aW9uIG9mIGNvbnRhaW5tZW50LiBBcyBhIHJlc3VsdCwgd2hlbiB0aGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYFxyXG5cdCAqIGl0IGlzIGtub3duIHRoYXQgcGFyc2luZyBmcm9tIGBzdWJjb25maWdgIGNhbiBvbmx5IHJlY29nbml6ZSBhIHN1YnNldCBvZiB0aGUgaW5wdXRzIHdoaWNoIGNhbiBiZSByZWNvZ25pemVkXHJcblx0ICogc3RhcnRpbmcgYXQgdGhlIGN1cnJlbnQgYEFUTkNvbmZpZ2AuIEhvd2V2ZXIsIGR1ZSB0byB0aGUgaW1wcmVjaXNlIGV2YWx1YXRpb24gb2YgaW1wbGljYXRpb24gZm9yIHRoZSBzZW1hbnRpY1xyXG5cdCAqIGNvbnRleHRzLCBubyBhc3N1bXB0aW9ucyBjYW4gYmUgbWFkZSBhYm91dCB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlIGNvbmZpZ3VyYXRpb25zIHdoZW4gdGhpcyBtZXRob2QgcmV0dXJuc1xyXG5cdCAqIGBmYWxzZWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gc3ViY29uZmlnIFRoZSBzdWIgY29uZmlndXJhdGlvbi5cclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBjb25maWd1cmF0aW9uIGNvbnRhaW5zIGBzdWJjb25maWdgOyBvdGhlcndpc2UsIGBmYWxzZWAuXHJcblx0ICovXHJcblx0cHVibGljIGNvbnRhaW5zKHN1YmNvbmZpZzogQVROQ29uZmlnKTogYm9vbGVhbiB7XHJcblx0XHRpZiAodGhpcy5zdGF0ZS5zdGF0ZU51bWJlciAhPT0gc3ViY29uZmlnLnN0YXRlLnN0YXRlTnVtYmVyXHJcblx0XHRcdHx8IHRoaXMuYWx0ICE9PSBzdWJjb25maWcuYWx0XHJcblx0XHRcdHx8ICF0aGlzLnNlbWFudGljQ29udGV4dC5lcXVhbHMoc3ViY29uZmlnLnNlbWFudGljQ29udGV4dCkpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBsZWZ0V29ya0xpc3Q6IFByZWRpY3Rpb25Db250ZXh0W10gPSBbXTtcclxuXHRcdGxldCByaWdodFdvcmtMaXN0OiBQcmVkaWN0aW9uQ29udGV4dFtdID0gW107XHJcblx0XHRsZWZ0V29ya0xpc3QucHVzaCh0aGlzLmNvbnRleHQpO1xyXG5cdFx0cmlnaHRXb3JrTGlzdC5wdXNoKHN1YmNvbmZpZy5jb250ZXh0KTtcclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGxldCBsZWZ0ID0gbGVmdFdvcmtMaXN0LnBvcCgpO1xyXG5cdFx0XHRsZXQgcmlnaHQgPSByaWdodFdvcmtMaXN0LnBvcCgpO1xyXG5cdFx0XHRpZiAoIWxlZnQgfHwgIXJpZ2h0KSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChsZWZ0ID09PSByaWdodCkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAobGVmdC5zaXplIDwgcmlnaHQuc2l6ZSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHJpZ2h0LmlzRW1wdHkpIHtcclxuXHRcdFx0XHRyZXR1cm4gbGVmdC5oYXNFbXB0eTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJpZ2h0LnNpemU7IGkrKykge1xyXG5cdFx0XHRcdFx0bGV0IGluZGV4OiBudW1iZXIgPSBsZWZ0LmZpbmRSZXR1cm5TdGF0ZShyaWdodC5nZXRSZXR1cm5TdGF0ZShpKSk7XHJcblx0XHRcdFx0XHRpZiAoaW5kZXggPCAwKSB7XHJcblx0XHRcdFx0XHRcdC8vIGFzc3VtZXMgaW52b2tpbmdTdGF0ZXMgaGFzIG5vIGR1cGxpY2F0ZSBlbnRyaWVzXHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsZWZ0V29ya0xpc3QucHVzaChsZWZ0LmdldFBhcmVudChpbmRleCkpO1xyXG5cdFx0XHRcdFx0cmlnaHRXb3JrTGlzdC5wdXNoKHJpZ2h0LmdldFBhcmVudChpKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Z2V0IGlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gKHRoaXMuYWx0QW5kT3V0ZXJDb250ZXh0RGVwdGggJiBTVVBQUkVTU19QUkVDRURFTkNFX0ZJTFRFUikgIT09IDA7XHJcblx0fVxyXG5cclxuXHRzZXQgaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCh2YWx1ZTogYm9vbGVhbikge1xyXG5cdFx0aWYgKHZhbHVlKSB7XHJcblx0XHRcdHRoaXMuYWx0QW5kT3V0ZXJDb250ZXh0RGVwdGggfD0gU1VQUFJFU1NfUFJFQ0VERU5DRV9GSUxURVI7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCAmPSB+U1VQUFJFU1NfUFJFQ0VERU5DRV9GSUxURVI7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogQW4gQVROIGNvbmZpZ3VyYXRpb24gaXMgZXF1YWwgdG8gYW5vdGhlciBpZiBib3RoIGhhdmVcclxuXHQgKiAgdGhlIHNhbWUgc3RhdGUsIHRoZXkgcHJlZGljdCB0aGUgc2FtZSBhbHRlcm5hdGl2ZSwgYW5kXHJcblx0ICogIHN5bnRhY3RpYy9zZW1hbnRpYyBjb250ZXh0cyBhcmUgdGhlIHNhbWUuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzID09PSBvKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIGlmICghKG8gaW5zdGFuY2VvZiBBVE5Db25maWcpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5zdGF0ZU51bWJlciA9PT0gby5zdGF0ZS5zdGF0ZU51bWJlclxyXG5cdFx0XHQmJiB0aGlzLmFsdCA9PT0gby5hbHRcclxuXHRcdFx0JiYgdGhpcy5yZWFjaGVzSW50b091dGVyQ29udGV4dCA9PT0gby5yZWFjaGVzSW50b091dGVyQ29udGV4dFxyXG5cdFx0XHQmJiB0aGlzLmNvbnRleHQuZXF1YWxzKG8uY29udGV4dClcclxuXHRcdFx0JiYgdGhpcy5zZW1hbnRpY0NvbnRleHQuZXF1YWxzKG8uc2VtYW50aWNDb250ZXh0KVxyXG5cdFx0XHQmJiB0aGlzLmlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPT09IG8uaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZFxyXG5cdFx0XHQmJiB0aGlzLmhhc1Bhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbiA9PT0gby5oYXNQYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb25cclxuXHRcdFx0JiYgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFLmVxdWFscyh0aGlzLmxleGVyQWN0aW9uRXhlY3V0b3IsIG8ubGV4ZXJBY3Rpb25FeGVjdXRvcik7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoQ29kZTogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKDcpO1xyXG5cdFx0aGFzaENvZGUgPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5zdGF0ZS5zdGF0ZU51bWJlcik7XHJcblx0XHRoYXNoQ29kZSA9IE11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCB0aGlzLmFsdCk7XHJcblx0XHRoYXNoQ29kZSA9IE11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCB0aGlzLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0ID8gMSA6IDApO1xyXG5cdFx0aGFzaENvZGUgPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5jb250ZXh0KTtcclxuXHRcdGhhc2hDb2RlID0gTXVybXVySGFzaC51cGRhdGUoaGFzaENvZGUsIHRoaXMuc2VtYW50aWNDb250ZXh0KTtcclxuXHRcdGhhc2hDb2RlID0gTXVybXVySGFzaC51cGRhdGUoaGFzaENvZGUsIHRoaXMuaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uID8gMSA6IDApO1xyXG5cdFx0aGFzaENvZGUgPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5sZXhlckFjdGlvbkV4ZWN1dG9yKTtcclxuXHRcdGhhc2hDb2RlID0gTXVybXVySGFzaC5maW5pc2goaGFzaENvZGUsIDcpO1xyXG5cdFx0cmV0dXJuIGhhc2hDb2RlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBgQVROQ29uZmlnYCBpbiBHcmFwaHZpeiBmb3JtYXQuIFRoZSBncmFwaCBjYW4gYmUgc3RvcmVkIHRvIGFcclxuXHQgKiAqKi5kb3QqKiBmaWxlIGFuZCB0aGVuIHJlbmRlcmVkIHRvIGFuIGltYWdlIHVzaW5nIEdyYXBodml6LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgQSBHcmFwaHZpeiBncmFwaCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgYEFUTkNvbmZpZ2AuXHJcblx0ICpcclxuXHQgKiBAc2VlIGh0dHA6Ly93d3cuZ3JhcGh2aXoub3JnL1xyXG5cdCAqL1xyXG5cdHB1YmxpYyB0b0RvdFN0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0bGV0IGJ1aWxkZXIgPSBcIlwiO1xyXG5cdFx0YnVpbGRlciArPSAoXCJkaWdyYXBoIEcge1xcblwiKTtcclxuXHRcdGJ1aWxkZXIgKz0gKFwicmFua2Rpcj1MUjtcXG5cIik7XHJcblxyXG5cdFx0bGV0IHZpc2l0ZWQgPSBuZXcgQXJyYXkyREhhc2hNYXA8UHJlZGljdGlvbkNvbnRleHQsIG51bWJlcj4oUHJlZGljdGlvbkNvbnRleHQuSWRlbnRpdHlFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xyXG5cdFx0bGV0IHdvcmtMaXN0OiBQcmVkaWN0aW9uQ29udGV4dFtdID0gW107XHJcblx0XHRmdW5jdGlvbiBnZXRPckFkZENvbnRleHQoY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpOiBudW1iZXIge1xyXG5cdFx0XHRsZXQgbmV3TnVtYmVyID0gdmlzaXRlZC5zaXplO1xyXG5cdFx0XHRsZXQgcmVzdWx0ID0gdmlzaXRlZC5wdXRJZkFic2VudChjb250ZXh0LCBuZXdOdW1iZXIpO1xyXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwpIHtcclxuXHRcdFx0XHQvLyBBbHJlYWR5IHNhdyB0aGlzIGNvbnRleHRcclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR3b3JrTGlzdC5wdXNoKGNvbnRleHQpO1xyXG5cdFx0XHRyZXR1cm4gbmV3TnVtYmVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHdvcmtMaXN0LnB1c2godGhpcy5jb250ZXh0KTtcclxuXHRcdHZpc2l0ZWQucHV0KHRoaXMuY29udGV4dCwgMCk7XHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRsZXQgY3VycmVudCA9IHdvcmtMaXN0LnBvcCgpO1xyXG5cdFx0XHRpZiAoIWN1cnJlbnQpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50LnNpemU7IGkrKykge1xyXG5cdFx0XHRcdGJ1aWxkZXIgKz0gKFwiICBzXCIpICsgKGdldE9yQWRkQ29udGV4dChjdXJyZW50KSk7XHJcblx0XHRcdFx0YnVpbGRlciArPSAoXCItPlwiKTtcclxuXHRcdFx0XHRidWlsZGVyICs9IChcInNcIikgKyAoZ2V0T3JBZGRDb250ZXh0KGN1cnJlbnQuZ2V0UGFyZW50KGkpKSk7XHJcblx0XHRcdFx0YnVpbGRlciArPSAoXCJbbGFiZWw9XFxcIlwiKSArIChjdXJyZW50LmdldFJldHVyblN0YXRlKGkpKSArIChcIlxcXCJdO1xcblwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGJ1aWxkZXIgKz0gKFwifVxcblwiKTtcclxuXHRcdHJldHVybiBidWlsZGVyLnRvU3RyaW5nKCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nO1xyXG5cdHB1YmxpYyB0b1N0cmluZyhyZWNvZzogUmVjb2duaXplcjxhbnksIGFueT4gfCB1bmRlZmluZWQsIHNob3dBbHQ6IGJvb2xlYW4pOiBzdHJpbmc7XHJcblx0cHVibGljIHRvU3RyaW5nKHJlY29nOiBSZWNvZ25pemVyPGFueSwgYW55PiB8IHVuZGVmaW5lZCwgc2hvd0FsdDogYm9vbGVhbiwgc2hvd0NvbnRleHQ6IGJvb2xlYW4pOiBzdHJpbmc7XHJcblx0cHVibGljIHRvU3RyaW5nKHJlY29nPzogUmVjb2duaXplcjxhbnksIGFueT4sIHNob3dBbHQ/OiBib29sZWFuLCBzaG93Q29udGV4dD86IGJvb2xlYW4pOiBzdHJpbmcge1xyXG5cdFx0Ly8gTXVzdCBjaGVjayBzaG93Q29udGV4dCBiZWZvcmUgc2hvd0FsdCB0byBwcmVzZXJ2ZSBvcmlnaW5hbCBvdmVybG9hZCBiZWhhdmlvclxyXG5cdFx0aWYgKHNob3dDb250ZXh0ID09IG51bGwpIHtcclxuXHRcdFx0c2hvd0NvbnRleHQgPSBzaG93QWx0ICE9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNob3dBbHQgPT0gbnVsbCkge1xyXG5cdFx0XHRzaG93QWx0ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYnVmID0gXCJcIjtcclxuXHRcdC8vIGlmICh0aGlzLnN0YXRlLnJ1bGVJbmRleCA+PSAwKSB7XHJcblx0XHQvLyBcdGlmIChyZWNvZyAhPSBudWxsKSB7XHJcblx0XHQvLyBcdFx0YnVmICs9IChyZWNvZy5ydWxlTmFtZXNbdGhpcy5zdGF0ZS5ydWxlSW5kZXhdICsgXCI6XCIpO1xyXG5cdFx0Ly8gXHR9IGVsc2Uge1xyXG5cdFx0Ly8gXHRcdGJ1ZiArPSAodGhpcy5zdGF0ZS5ydWxlSW5kZXggKyBcIjpcIik7XHJcblx0XHQvLyBcdH1cclxuXHRcdC8vIH1cclxuXHRcdGxldCBjb250ZXh0czogc3RyaW5nW107XHJcblx0XHRpZiAoc2hvd0NvbnRleHQpIHtcclxuXHRcdFx0Y29udGV4dHMgPSB0aGlzLmNvbnRleHQudG9TdHJpbmdzKHJlY29nLCB0aGlzLnN0YXRlLnN0YXRlTnVtYmVyKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRjb250ZXh0cyA9IFtcIj9cIl07XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGZpcnN0OiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdGZvciAobGV0IGNvbnRleHREZXNjIG9mIGNvbnRleHRzKSB7XHJcblx0XHRcdGlmIChmaXJzdCkge1xyXG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0YnVmICs9IChcIiwgXCIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRidWYgKz0gKFwiKFwiKTtcclxuXHRcdFx0YnVmICs9ICh0aGlzLnN0YXRlKTtcclxuXHRcdFx0aWYgKHNob3dBbHQpIHtcclxuXHRcdFx0XHRidWYgKz0gKFwiLFwiKTtcclxuXHRcdFx0XHRidWYgKz0gKHRoaXMuYWx0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5jb250ZXh0KSB7XHJcblx0XHRcdFx0YnVmICs9IChcIixcIik7XHJcblx0XHRcdFx0YnVmICs9IChjb250ZXh0RGVzYyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuc2VtYW50aWNDb250ZXh0ICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xyXG5cdFx0XHRcdGJ1ZiArPSAoXCIsXCIpO1xyXG5cdFx0XHRcdGJ1ZiArPSAodGhpcy5zZW1hbnRpY0NvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0KSB7XHJcblx0XHRcdFx0YnVmICs9IChcIix1cD1cIikgKyAodGhpcy5vdXRlckNvbnRleHREZXB0aCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnVmICs9IChcIilcIik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYnVmLnRvU3RyaW5nKCk7XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyB3YXMgZGVyaXZlZCBmcm9tIGBBVE5Db25maWdgIHB1cmVseSBhcyBhIG1lbW9yeSBvcHRpbWl6YXRpb24uIEl0IGFsbG93cyBmb3IgdGhlIGNyZWF0aW9uIG9mIGFuIGBBVE5Db25maWdgXHJcbiAqIHdpdGggYSBub24tZGVmYXVsdCBzZW1hbnRpYyBjb250ZXh0LlxyXG4gKlxyXG4gKiBTZWUgdGhlIGBBVE5Db25maWdgIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgY29uc2VydmluZyBtZW1vcnkgdGhyb3VnaCB0aGUgdXNlIG9mIHNldmVyYWwgY29uY3JldGVcclxuICogdHlwZXMuXHJcbiAqL1xyXG5jbGFzcyBTZW1hbnRpY0NvbnRleHRBVE5Db25maWcgZXh0ZW5kcyBBVE5Db25maWcge1xyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSBfc2VtYW50aWNDb250ZXh0OiBTZW1hbnRpY0NvbnRleHQ7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHNlbWFudGljQ29udGV4dDogU2VtYW50aWNDb250ZXh0LCAvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCBhbHQ6IG51bWJlciwgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpO1xyXG5cdGNvbnN0cnVjdG9yKHNlbWFudGljQ29udGV4dDogU2VtYW50aWNDb250ZXh0LCAvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCAvKkBOb3ROdWxsKi8gYzogQVROQ29uZmlnLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCk7XHJcblx0Y29uc3RydWN0b3Ioc2VtYW50aWNDb250ZXh0OiBTZW1hbnRpY0NvbnRleHQsIEBOb3ROdWxsIHN0YXRlOiBBVE5TdGF0ZSwgQE5vdE51bGwgYWx0T3JDb25maWc6IG51bWJlciB8IEFUTkNvbmZpZywgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpIHtcclxuXHRcdGlmICh0eXBlb2YgYWx0T3JDb25maWcgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0c3VwZXIoc3RhdGUsIGFsdE9yQ29uZmlnLCBjb250ZXh0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN1cGVyKHN0YXRlLCBhbHRPckNvbmZpZywgY29udGV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VtYW50aWNDb250ZXh0ID0gc2VtYW50aWNDb250ZXh0O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNlbWFudGljQ29udGV4dCgpOiBTZW1hbnRpY0NvbnRleHQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NlbWFudGljQ29udGV4dDtcclxuXHR9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyB3YXMgZGVyaXZlZCBmcm9tIGBBVE5Db25maWdgIHB1cmVseSBhcyBhIG1lbW9yeSBvcHRpbWl6YXRpb24uIEl0IGFsbG93cyBmb3IgdGhlIGNyZWF0aW9uIG9mIGFuIGBBVE5Db25maWdgXHJcbiAqIHdpdGggYSBsZXhlciBhY3Rpb24uXHJcbiAqXHJcbiAqIFNlZSB0aGUgYEFUTkNvbmZpZ2AgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjb25zZXJ2aW5nIG1lbW9yeSB0aHJvdWdoIHRoZSB1c2Ugb2Ygc2V2ZXJhbCBjb25jcmV0ZVxyXG4gKiB0eXBlcy5cclxuICovXHJcbmNsYXNzIEFjdGlvbkFUTkNvbmZpZyBleHRlbmRzIEFUTkNvbmZpZyB7XHJcblx0cHJpdmF0ZSBfbGV4ZXJBY3Rpb25FeGVjdXRvcj86IExleGVyQWN0aW9uRXhlY3V0b3I7XHJcblx0cHJpdmF0ZSBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb246IGJvb2xlYW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQsIC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIGFsdDogbnVtYmVyLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCwgcGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uOiBib29sZWFuKTtcclxuXHRjb25zdHJ1Y3RvcihsZXhlckFjdGlvbkV4ZWN1dG9yOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHwgdW5kZWZpbmVkLCAvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCAvKkBOb3ROdWxsKi8gYzogQVROQ29uZmlnLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCwgcGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uOiBib29sZWFuKTtcclxuXHRjb25zdHJ1Y3RvcihsZXhlckFjdGlvbkV4ZWN1dG9yOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHwgdW5kZWZpbmVkLCBATm90TnVsbCBzdGF0ZTogQVROU3RhdGUsIEBOb3ROdWxsIGFsdE9yQ29uZmlnOiBudW1iZXIgfCBBVE5Db25maWcsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LCBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb246IGJvb2xlYW4pIHtcclxuXHRcdGlmICh0eXBlb2YgYWx0T3JDb25maWcgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0c3VwZXIoc3RhdGUsIGFsdE9yQ29uZmlnLCBjb250ZXh0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN1cGVyKHN0YXRlLCBhbHRPckNvbmZpZywgY29udGV4dCk7XHJcblx0XHRcdGlmIChhbHRPckNvbmZpZy5zZW1hbnRpY0NvbnRleHQgIT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xleGVyQWN0aW9uRXhlY3V0b3IgPSBsZXhlckFjdGlvbkV4ZWN1dG9yO1xyXG5cdFx0dGhpcy5wYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24gPSBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb247XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgbGV4ZXJBY3Rpb25FeGVjdXRvcigpOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLl9sZXhlckFjdGlvbkV4ZWN1dG9yO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGhhc1Bhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbigpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbjtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHdhcyBkZXJpdmVkIGZyb20gYFNlbWFudGljQ29udGV4dEFUTkNvbmZpZ2AgcHVyZWx5IGFzIGEgbWVtb3J5IG9wdGltaXphdGlvbi4gSXQgYWxsb3dzIGZvciB0aGUgY3JlYXRpb24gb2ZcclxuICogYW4gYEFUTkNvbmZpZ2Agd2l0aCBib3RoIGEgbGV4ZXIgYWN0aW9uIGFuZCBhIG5vbi1kZWZhdWx0IHNlbWFudGljIGNvbnRleHQuXHJcbiAqXHJcbiAqIFNlZSB0aGUgYEFUTkNvbmZpZ2AgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjb25zZXJ2aW5nIG1lbW9yeSB0aHJvdWdoIHRoZSB1c2Ugb2Ygc2V2ZXJhbCBjb25jcmV0ZVxyXG4gKiB0eXBlcy5cclxuICovXHJcbmNsYXNzIEFjdGlvblNlbWFudGljQ29udGV4dEFUTkNvbmZpZyBleHRlbmRzIFNlbWFudGljQ29udGV4dEFUTkNvbmZpZyB7XHJcblx0cHJpdmF0ZSBfbGV4ZXJBY3Rpb25FeGVjdXRvcj86IExleGVyQWN0aW9uRXhlY3V0b3I7XHJcblx0cHJpdmF0ZSBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb246IGJvb2xlYW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQsIC8qQE5vdE51bGwqLyBzZW1hbnRpY0NvbnRleHQ6IFNlbWFudGljQ29udGV4dCwgLypATm90TnVsbCovIHN0YXRlOiBBVE5TdGF0ZSwgYWx0OiBudW1iZXIsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LCBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb246IGJvb2xlYW4pO1xyXG5cdGNvbnN0cnVjdG9yKGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQsIC8qQE5vdE51bGwqLyBzZW1hbnRpY0NvbnRleHQ6IFNlbWFudGljQ29udGV4dCwgLypATm90TnVsbCovIHN0YXRlOiBBVE5TdGF0ZSwgLypATm90TnVsbCovIGM6IEFUTkNvbmZpZywgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQsIHBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbjogYm9vbGVhbik7XHJcblx0Y29uc3RydWN0b3IobGV4ZXJBY3Rpb25FeGVjdXRvcjogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCwgQE5vdE51bGwgc2VtYW50aWNDb250ZXh0OiBTZW1hbnRpY0NvbnRleHQsIEBOb3ROdWxsIHN0YXRlOiBBVE5TdGF0ZSwgYWx0T3JDb25maWc6IG51bWJlciB8IEFUTkNvbmZpZywgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQsIHBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbjogYm9vbGVhbikge1xyXG5cdFx0aWYgKHR5cGVvZiBhbHRPckNvbmZpZyA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRzdXBlcihzZW1hbnRpY0NvbnRleHQsIHN0YXRlLCBhbHRPckNvbmZpZywgY29udGV4dCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdXBlcihzZW1hbnRpY0NvbnRleHQsIHN0YXRlLCBhbHRPckNvbmZpZywgY29udGV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGV4ZXJBY3Rpb25FeGVjdXRvciA9IGxleGVyQWN0aW9uRXhlY3V0b3I7XHJcblx0XHR0aGlzLnBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbiA9IHBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBsZXhlckFjdGlvbkV4ZWN1dG9yKCk6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xleGVyQWN0aW9uRXhlY3V0b3I7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCJ1dGlsXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi9NdXJtdXJIYXNoXCI7XHJcblxyXG4vKipcclxuICogUHJpdmF0ZSBlbXB0eSBhcnJheSB1c2VkIHRvIGNvbnN0cnVjdCBlbXB0eSBCaXRTZXRzXHJcbiAqL1xyXG5jb25zdCBFTVBUWV9EQVRBOiBVaW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSgwKTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB3b3JkIGluZGV4IG9mIHRoZSBgVUludDE2YCBlbGVtZW50IGluIGBCaXRTZXQuZGF0YWAgY29udGFpbmluZyB0aGUgYml0IHdpdGggdGhlIHNwZWNpZmllZCBpbmRleC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEluZGV4KGJpdE51bWJlcjogbnVtYmVyKSB7XHJcblx0cmV0dXJuIGJpdE51bWJlciA+Pj4gNDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSB3b3JkIGluZGV4IGludG8gdGhlIGJpdCBpbmRleCBvZiB0aGUgTFNCIG9mIHRoYXQgd29yZFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHVuSW5kZXgobjogbnVtYmVyKSB7XHJcblx0cmV0dXJuIG4gKiAxNjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCdzIHRoZSBiaXQgbnVtYmVyIG9mIHRoZSBsZWFzdCBzaWduZmljYW50IGJpdCBzZXQgTFNCIHdoaWNoIGlzIHNldCBpbiBhIHdvcmQgbm9uLXplcm8gd29yZDtcclxuICogQml0IG51bWJlcnMgcnVuIGZyb20gTFNCIHRvIE1TQiBzdGFydGluZyB3aXRoIDAuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kTFNCU2V0KHdvcmQ6IG51bWJlcikge1xyXG5cdGxldCBiaXQgPSAxO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG5cdFx0aWYgKCh3b3JkICYgYml0KSAhPT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gaTtcclxuXHRcdH1cclxuXHRcdGJpdCA9IChiaXQgPDwgMSkgPj4+IDA7XHJcblx0fVxyXG5cdHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gc3BlY2lmaWVkIGJpdCBmb3VuZFwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmluZE1TQlNldCh3b3JkOiBudW1iZXIpIHtcclxuXHRsZXQgYml0ID0gKDEgPDwgMTUpID4+PiAwO1xyXG5cdGZvciAobGV0IGkgPSAxNTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdGlmICgod29yZCAmIGJpdCkgIT09IDApIHtcclxuXHRcdFx0cmV0dXJuIGk7XHJcblx0XHR9XHJcblx0XHRiaXQgPSBiaXQgPj4+IDE7XHJcblx0fVxyXG5cdHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gc3BlY2lmaWVkIGJpdCBmb3VuZFwiKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgYSAxNi1iaXQgbWFzayB3aXRoIGJpdCBudW1iZXJzIGZyb21CaXQgdG8gdG9CaXQgKGluY2x1c2l2ZSkgc2V0LlxyXG4gKiBCaXQgbnVtYmVycyBydW4gZnJvbSBMU0IgdG8gTVNCIHN0YXJ0aW5nIHdpdGggMC5cclxuICovXHJcbmZ1bmN0aW9uIGJpdHNGb3IoZnJvbUJpdDogbnVtYmVyLCB0b0JpdDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRmcm9tQml0ICY9IDB4RjtcclxuXHR0b0JpdCAmPSAweEY7XHJcblx0aWYgKGZyb21CaXQgPT09IHRvQml0KSB7XHJcblx0XHRyZXR1cm4gKDEgPDwgZnJvbUJpdCkgPj4+IDA7XHJcblx0fVxyXG5cdHJldHVybiAoKDB4RkZGRiA+Pj4gKDE1IC0gdG9CaXQpKSBeICgweEZGRkYgPj4+ICgxNiAtIGZyb21CaXQpKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGxvb2t1cCB0YWJsZSBmb3IgbnVtYmVyIG9mIHNldCBiaXRzIGluIGEgMTYtYml0IGludGVnZXIuICAgVGhpcyBpcyB1c2VkIHRvIHF1aWNrbHkgY291bnQgdGhlIGNhcmRpbmFsaXR5IChudW1iZXIgb2YgdW5pcXVlIGVsZW1lbnRzKSBvZiBhIEJpdFNldC5cclxuICovXHJcbmNvbnN0IFBPUF9DTlQ6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg2NTUzNik7XHJcbmZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG5cdGNvbnN0IHN0cmlkZSA9ICgxIDw8IGkpID4+PiAwO1xyXG5cdGxldCBpbmRleCA9IDA7XHJcblx0d2hpbGUgKGluZGV4IDwgUE9QX0NOVC5sZW5ndGgpIHtcclxuXHRcdC8vIHNraXAgdGhlIG51bWJlcnMgd2hlcmUgdGhlIGJpdCBpc24ndCBzZXRcclxuXHRcdGluZGV4ICs9IHN0cmlkZTtcclxuXHJcblx0XHQvLyBpbmNyZW1lbnQgdGhlIG9uZXMgd2hlcmUgdGhlIGJpdCBpcyBzZXRcclxuXHRcdGZvciAobGV0IGogPSAwOyBqIDwgc3RyaWRlOyBqKyspIHtcclxuXHRcdFx0UE9QX0NOVFtpbmRleF0rKztcclxuXHRcdFx0aW5kZXgrKztcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBCaXRTZXQgaW1wbGVtZW50cyBJdGVyYWJsZTxudW1iZXI+e1xyXG5cdHByaXZhdGUgZGF0YTogVWludDE2QXJyYXk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgYml0IHNldC4gQWxsIGJpdHMgYXJlIGluaXRpYWxseSBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBiaXQgc2V0IHdob3NlIGluaXRpYWwgc2l6ZSBpcyBsYXJnZSBlbm91Z2ggdG8gZXhwbGljaXRseSByZXByZXNlbnQgYml0cyB3aXRoIGluZGljZXMgaW4gdGhlIHJhbmdlIGAwYFxyXG5cdCAqIHRocm91Z2ggYG5iaXRzLTFgLiBBbGwgYml0cyBhcmUgaW5pdGlhbGx5IGBmYWxzZWAuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IobmJpdHM6IG51bWJlcik7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBiaXQgc2V0IGZyb20gYSBpdGVyYWJsZSBsaXN0IG9mIG51bWJlcnMgKGluY2x1ZGluZyBhbm90aGVyIEJpdFNldCk7XHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IobnVtYmVyczogSXRlcmFibGU8bnVtYmVyPik7XHJcblxyXG5cdC8qXHJcblx0KiogY29uc3RydWN0b3IgaW1wbGVtZW50YXRpb25cclxuXHQqL1xyXG5cdGNvbnN0cnVjdG9yKGFyZz86IG51bWJlciB8IEl0ZXJhYmxlPG51bWJlcj4pIHtcclxuXHRcdGlmICghYXJnKSB7XHJcblx0XHRcdC8vIGNvdmVyaW5nIHRoZSBjYXNlIG9mIHVuc3BlY2lmaWVkIGFuZCBuYml0cz09PTBcclxuXHRcdFx0dGhpcy5kYXRhID0gRU1QVFlfREFUQTtcclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRpZiAoYXJnIDwgMCkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwibmJpdHMgY2Fubm90IGJlIG5lZ2F0aXZlXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZGF0YSA9IG5ldyBVaW50MTZBcnJheShnZXRJbmRleChhcmcgLSAxKSArIDEpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoYXJnIGluc3RhbmNlb2YgQml0U2V0KSB7XHJcblx0XHRcdFx0dGhpcy5kYXRhID0gYXJnLmRhdGEuc2xpY2UoMCk7IC8vIENsb25lIHRoZSBkYXRhXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IG1heCA9IC0xO1xyXG5cdFx0XHRcdGZvciAobGV0IHYgb2YgYXJnKSB7XHJcblx0XHRcdFx0XHRpZiAobWF4IDwgdikge1xyXG5cdFx0XHRcdFx0XHRtYXggPSB2O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmRhdGEgPSBuZXcgVWludDE2QXJyYXkoZ2V0SW5kZXgobWF4IC0gMSkgKyAxKTtcclxuXHRcdFx0XHRmb3IgKGxldCB2IG9mIGFyZykge1xyXG5cdFx0XHRcdFx0dGhpcy5zZXQodik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBQZXJmb3JtcyBhIGxvZ2ljYWwgKipBTkQqKiBvZiB0aGlzIHRhcmdldCBiaXQgc2V0IHdpdGggdGhlIGFyZ3VtZW50IGJpdCBzZXQuIFRoaXMgYml0IHNldCBpcyBtb2RpZmllZCBzbyB0aGF0XHJcblx0ICogZWFjaCBiaXQgaW4gaXQgaGFzIHRoZSB2YWx1ZSBgdHJ1ZWAgaWYgYW5kIG9ubHkgaWYgaXQgYm90aCBpbml0aWFsbHkgaGFkIHRoZSB2YWx1ZSBgdHJ1ZWAgYW5kIHRoZSBjb3JyZXNwb25kaW5nXHJcblx0ICogYml0IGluIHRoZSBiaXQgc2V0IGFyZ3VtZW50IGFsc28gaGFkIHRoZSB2YWx1ZSBgdHJ1ZWAuXHJcblx0ICovXHJcblx0cHVibGljIGFuZChzZXQ6IEJpdFNldCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdGNvbnN0IG90aGVyID0gc2V0LmRhdGE7XHJcblx0XHRjb25zdCB3b3JkcyA9IE1hdGgubWluKGRhdGEubGVuZ3RoLCBvdGhlci5sZW5ndGgpO1xyXG5cclxuXHRcdGxldCBsYXN0V29yZCA9IC0xO1x0Ly8gS2VlcCB0cmFjayBvZiBpbmRleCBvZiBsYXN0IG5vbi16ZXJvIHdvcmRcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzOyBpKyspIHtcclxuXHRcdFx0bGV0IHZhbHVlID0gZGF0YVtpXSAmPSBvdGhlcltpXTtcclxuXHRcdFx0aWYgKHZhbHVlICE9PSAwKSB7XHJcblx0XHRcdFx0bGFzdFdvcmQgPSBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhc3RXb3JkID09PSAtMSkge1xyXG5cdFx0XHR0aGlzLmRhdGEgPSBFTVBUWV9EQVRBO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXN0V29yZCA8IGRhdGEubGVuZ3RoIC0gMSkge1xyXG5cdFx0XHR0aGlzLmRhdGEgPSBkYXRhLnNsaWNlKDAsIGxhc3RXb3JkICsgMSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDbGVhcnMgYWxsIG9mIHRoZSBiaXRzIGluIHRoaXMgYEJpdFNldGAgd2hvc2UgY29ycmVzcG9uZGluZyBiaXQgaXMgc2V0IGluIHRoZSBzcGVjaWZpZWQgYEJpdFNldGAuXHJcblx0ICovXHJcblx0cHVibGljIGFuZE5vdChzZXQ6IEJpdFNldCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdGNvbnN0IG90aGVyID0gc2V0LmRhdGE7XHJcblx0XHRjb25zdCB3b3JkcyA9IE1hdGgubWluKGRhdGEubGVuZ3RoLCBvdGhlci5sZW5ndGgpO1xyXG5cclxuXHRcdGxldCBsYXN0V29yZCA9IC0xO1x0Ly8gS2VlcCB0cmFjayBvZiBpbmRleCBvZiBsYXN0IG5vbi16ZXJvIHdvcmRcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzOyBpKyspIHtcclxuXHRcdFx0bGV0IHZhbHVlID0gZGF0YVtpXSAmPSAob3RoZXJbaV0gXiAweEZGRkYpO1xyXG5cdFx0XHRpZiAodmFsdWUgIT09IDApIHtcclxuXHRcdFx0XHRsYXN0V29yZCA9IGk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGFzdFdvcmQgPT09IC0xKSB7XHJcblx0XHRcdHRoaXMuZGF0YSA9IEVNUFRZX0RBVEE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhc3RXb3JkIDwgZGF0YS5sZW5ndGggLSAxKSB7XHJcblx0XHRcdHRoaXMuZGF0YSA9IGRhdGEuc2xpY2UoMCwgbGFzdFdvcmQgKyAxKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYml0cyBzZXQgdG8gYHRydWVgIGluIHRoaXMgYEJpdFNldGAuXHJcblx0ICovXHJcblx0cHVibGljIGNhcmRpbmFsaXR5KCk6IG51bWJlciB7XHJcblx0XHRpZiAodGhpcy5pc0VtcHR5KSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG5cdFx0bGV0IHJlc3VsdCA9IDA7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG5cdFx0XHRyZXN1bHQgKz0gUE9QX0NOVFtkYXRhW2ldXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyBhbGwgb2YgdGhlIGJpdHMgaW4gdGhpcyBgQml0U2V0YCB0byBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBiaXQgc3BlY2lmaWVkIGJ5IHRoZSBpbmRleCB0byBgZmFsc2VgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGJpdEluZGV4IHRoZSBpbmRleCBvZiB0aGUgYml0IHRvIGJlIGNsZWFyZWRcclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiB0aGUgc3BlY2lmaWVkIGluZGV4IGlzIG5lZ2F0aXZlXHJcblx0ICovXHJcblx0cHVibGljIGNsZWFyKGJpdEluZGV4OiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCBgZnJvbUluZGV4YCAoaW5jbHVzaXZlKSB0byB0aGUgc3BlY2lmaWVkIGB0b0luZGV4YCAoZXhjbHVzaXZlKSB0byBgZmFsc2VgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGZyb21JbmRleCBpbmRleCBvZiB0aGUgZmlyc3QgYml0IHRvIGJlIGNsZWFyZWRcclxuXHQgKiBAcGFyYW0gdG9JbmRleCBpbmRleCBhZnRlciB0aGUgbGFzdCBiaXQgdG8gYmUgY2xlYXJlZFxyXG5cdCAqXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBvciBgdG9JbmRleGAgaXMgbmVnYXRpdmUsIG9yIGBmcm9tSW5kZXhgIGlzIGxhcmdlciB0aGFuIGB0b0luZGV4YFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjbGVhcihmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyKTogdm9pZDtcclxuXHRwdWJsaWMgY2xlYXIoZnJvbUluZGV4PzogbnVtYmVyLCB0b0luZGV4PzogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAoZnJvbUluZGV4ID09IG51bGwpIHtcclxuXHRcdFx0dGhpcy5kYXRhLmZpbGwoMCk7XHJcblx0XHR9IGVsc2UgaWYgKHRvSW5kZXggPT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLnNldChmcm9tSW5kZXgsIGZhbHNlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuc2V0KGZyb21JbmRleCwgdG9JbmRleCwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgYml0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggdG8gdGhlIGNvbXBsZW1lbnQgb2YgaXRzIGN1cnJlbnQgdmFsdWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gYml0SW5kZXggdGhlIGluZGV4IG9mIHRoZSBiaXQgdG8gZmxpcFxyXG5cdCAqXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgbmVnYXRpdmVcclxuXHQgKi9cclxuXHRwdWJsaWMgZmxpcChiaXRJbmRleDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyBlYWNoIGJpdCBmcm9tIHRoZSBzcGVjaWZpZWQgYGZyb21JbmRleGAgKGluY2x1c2l2ZSkgdG8gdGhlIHNwZWNpZmllZCBgdG9JbmRleGAgKGV4Y2x1c2l2ZSkgdG8gdGhlIGNvbXBsZW1lbnRcclxuXHQgKiBvZiBpdHMgY3VycmVudCB2YWx1ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBmcm9tSW5kZXggaW5kZXggb2YgdGhlIGZpcnN0IGJpdCB0byBmbGlwXHJcblx0ICogQHBhcmFtIHRvSW5kZXggaW5kZXggYWZ0ZXIgdGhlIGxhc3QgYml0IHRvIGZsaXBcclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgb3IgYHRvSW5kZXhgIGlzIG5lZ2F0aXZlLCBvciBgZnJvbUluZGV4YCBpcyBsYXJnZXIgdGhhbiBgdG9JbmRleGBcclxuXHQgKi9cclxuXHRwdWJsaWMgZmxpcChmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyKTogdm9pZDtcclxuXHRwdWJsaWMgZmxpcChmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleD86IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKHRvSW5kZXggPT0gbnVsbCkge1xyXG5cdFx0XHR0b0luZGV4ID0gZnJvbUluZGV4O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGZyb21JbmRleCA8IDAgfHwgdG9JbmRleCA8IGZyb21JbmRleCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB3b3JkID0gZ2V0SW5kZXgoZnJvbUluZGV4KTtcclxuXHRcdGNvbnN0IGxhc3RXb3JkID0gZ2V0SW5kZXgodG9JbmRleCk7XHJcblxyXG5cdFx0aWYgKHdvcmQgPT09IGxhc3RXb3JkKSB7XHJcblx0XHRcdHRoaXMuZGF0YVt3b3JkXSBePSBiaXRzRm9yKGZyb21JbmRleCwgdG9JbmRleCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmRhdGFbd29yZCsrXSBePSBiaXRzRm9yKGZyb21JbmRleCwgMTUpO1xyXG5cdFx0XHR3aGlsZSAod29yZCA8IGxhc3RXb3JkKSB7XHJcblx0XHRcdFx0dGhpcy5kYXRhW3dvcmQrK10gXj0gMHhGRkZGO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZGF0YVt3b3JkKytdIF49IGJpdHNGb3IoMCwgdG9JbmRleCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYml0IHdpdGggdGhlIHNwZWNpZmllZCBpbmRleC4gVGhlIHZhbHVlIGlzIGB0cnVlYCBpZiB0aGUgYml0IHdpdGggdGhlIGluZGV4IGBiaXRJbmRleGBcclxuXHQgKiBpcyBjdXJyZW50bHkgc2V0IGluIHRoaXMgYEJpdFNldGA7IG90aGVyd2lzZSwgdGhlIHJlc3VsdCBpcyBgZmFsc2VgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGJpdEluZGV4IHRoZSBiaXQgaW5kZXhcclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiB0aGUgc3BlY2lmaWVkIGluZGV4IGlzIG5lZ2F0aXZlXHJcblx0ICovXHJcblx0cHVibGljIGdldChiaXRJbmRleDogbnVtYmVyKTogYm9vbGVhbjtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIG5ldyBgQml0U2V0YCBjb21wb3NlZCBvZiBiaXRzIGZyb20gdGhpcyBgQml0U2V0YCBmcm9tIGBmcm9tSW5kZXhgIChpbmNsdXNpdmUpIHRvIGB0b0luZGV4YCAoZXhjbHVzaXZlKS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBmcm9tSW5kZXggaW5kZXggb2YgdGhlIGZpcnN0IGJpdCB0byBpbmNsdWRlXHJcblx0ICogQHBhcmFtIHRvSW5kZXggaW5kZXggYWZ0ZXIgdGhlIGxhc3QgYml0IHRvIGluY2x1ZGVcclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgb3IgYHRvSW5kZXhgIGlzIG5lZ2F0aXZlLCBvciBgZnJvbUluZGV4YCBpcyBsYXJnZXIgdGhhbiBgdG9JbmRleGBcclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0KGZyb21JbmRleDogbnVtYmVyLCB0b0luZGV4OiBudW1iZXIpOiBCaXRTZXQ7XHJcblx0cHVibGljIGdldChmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleD86IG51bWJlcik6IGJvb2xlYW4gfCBCaXRTZXQge1xyXG5cdFx0aWYgKHRvSW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gISEodGhpcy5kYXRhW2dldEluZGV4KGZyb21JbmRleCldICYgYml0c0Zvcihmcm9tSW5kZXgsIGZyb21JbmRleCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gcmV0dXJuIGEgQml0U2V0XHJcblx0XHRcdGxldCByZXN1bHQgPSBuZXcgQml0U2V0KHRvSW5kZXggKyAxKTtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IGZyb21JbmRleDsgaSA8PSB0b0luZGV4OyBpKyspIHtcclxuXHRcdFx0XHRyZXN1bHQuc2V0KGksIHRoaXMuZ2V0KGkpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYEJpdFNldGAgaGFzIGFueSBiaXRzIHNldCB0byBgdHJ1ZWAgdGhhdCBhcmUgYWxzbyBzZXQgdG8gYHRydWVgIGluIHRoaXMgYEJpdFNldGAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gc2V0IGBCaXRTZXRgIHRvIGludGVyc2VjdCB3aXRoXHJcblx0ICovXHJcblx0cHVibGljIGludGVyc2VjdHMoc2V0OiBCaXRTZXQpOiBib29sZWFuIHtcclxuXHRcdGxldCBzbWFsbGVyTGVuZ3RoID0gTWF0aC5taW4odGhpcy5sZW5ndGgoKSwgc2V0Lmxlbmd0aCgpKTtcclxuXHRcdGlmIChzbWFsbGVyTGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYm91bmQgPSBnZXRJbmRleChzbWFsbGVyTGVuZ3RoIC0gMSk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSBib3VuZDsgaSsrKSB7XHJcblx0XHRcdGlmICgodGhpcy5kYXRhW2ldICYgc2V0LmRhdGFbaV0pICE9PSAwKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgQml0U2V0YCBjb250YWlucyBubyBiaXRzIHRoYXQgYXJlIHNldCB0byBgdHJ1ZWAuXHJcblx0ICovXHJcblx0Z2V0IGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGgoKSA9PT0gMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIFwibG9naWNhbCBzaXplXCIgb2YgdGhpcyBgQml0U2V0YDogdGhlIGluZGV4IG9mIHRoZSBoaWdoZXN0IHNldCBiaXQgaW4gdGhlIGBCaXRTZXRgIHBsdXMgb25lLiBSZXR1cm5zXHJcblx0ICogemVybyBpZiB0aGUgYEJpdFNldGAgY29udGFpbnMgbm8gc2V0IGJpdHMuXHJcblx0ICovXHJcblx0cHVibGljIGxlbmd0aCgpOiBudW1iZXIge1xyXG5cdFx0aWYgKCF0aGlzLmRhdGEubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMucHJldmlvdXNTZXRCaXQodW5JbmRleCh0aGlzLmRhdGEubGVuZ3RoKSAtIDEpICsgMTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBiaXQgdGhhdCBpcyBzZXQgdG8gYGZhbHNlYCB0aGF0IG9jY3VycyBvbiBvciBhZnRlciB0aGUgc3BlY2lmaWVkIHN0YXJ0aW5nIGluZGV4LFxyXG5cdCAqIElmIG5vIHN1Y2ggYml0IGV4aXN0cyB0aGVuIGAtMWAgaXMgcmV0dXJuZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gZnJvbUluZGV4IHRoZSBpbmRleCB0byBzdGFydCBjaGVja2luZyBmcm9tIChpbmNsdXNpdmUpXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgdGhlIHNwZWNpZmllZCBpbmRleCBpcyBuZWdhdGl2ZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBuZXh0Q2xlYXJCaXQoZnJvbUluZGV4OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0aWYgKGZyb21JbmRleCA8IDApIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJmcm9tSW5kZXggY2Fubm90IGJlIG5lZ2F0aXZlXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuXHRcdGxldCB3b3JkID0gZ2V0SW5kZXgoZnJvbUluZGV4KTtcclxuXHRcdGlmICh3b3JkID4gbGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgaWdub3JlID0gMHhGRkZGIF4gYml0c0Zvcihmcm9tSW5kZXgsIDE1KTtcclxuXHJcblx0XHRpZiAoKGRhdGFbd29yZF0gfCBpZ25vcmUpID09PSAweEZGRkYpIHtcclxuXHRcdFx0d29yZCsrO1xyXG5cdFx0XHRpZ25vcmUgPSAwO1xyXG5cdFx0XHRmb3IgKDsgd29yZCA8IGxlbmd0aDsgd29yZCsrKSB7XHJcblx0XHRcdFx0aWYgKGRhdGFbd29yZF0gIT09IDB4RkZGRikge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh3b3JkID09PSBsZW5ndGgpIHtcclxuXHRcdFx0XHQvLyBIaXQgdGhlIGVuZFxyXG5cdFx0XHRcdHJldHVybiAtMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHVuSW5kZXgod29yZCkgKyBmaW5kTFNCU2V0KChkYXRhW3dvcmRdIHwgaWdub3JlKSBeIDB4RkZGRik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgYml0IHRoYXQgaXMgc2V0IHRvIGB0cnVlYCB0aGF0IG9jY3VycyBvbiBvciBhZnRlciB0aGUgc3BlY2lmaWVkIHN0YXJ0aW5nIGluZGV4LlxyXG5cdCAqIElmIG5vIHN1Y2ggYml0IGV4aXN0cyB0aGVuIGAtMWAgaXMgcmV0dXJuZWQuXHJcblx0ICpcclxuXHQgKiBUbyBpdGVyYXRlIG92ZXIgdGhlIGB0cnVlYCBiaXRzIGluIGEgYEJpdFNldGAsIHVzZSB0aGUgZm9sbG93aW5nIGxvb3A6XHJcblx0ICpcclxuXHQgKiBgYGBcclxuXHQgKiBmb3IgKGxldCBpID0gYnMubmV4dFNldEJpdCgwKTsgaSA+PSAwOyBpID0gYnMubmV4dFNldEJpdChpICsgMSkpIHtcclxuXHQgKiAgIC8vIG9wZXJhdGUgb24gaW5kZXggaSBoZXJlXHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGZyb21JbmRleCB0aGUgaW5kZXggdG8gc3RhcnQgY2hlY2tpbmcgZnJvbSAoaW5jbHVzaXZlKVxyXG5cdCAqXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgbmVnYXRpdmVcclxuXHQgKi9cclxuXHRwdWJsaWMgbmV4dFNldEJpdChmcm9tSW5kZXg6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRpZiAoZnJvbUluZGV4IDwgMCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImZyb21JbmRleCBjYW5ub3QgYmUgbmVnYXRpdmVcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG5cdFx0bGV0IHdvcmQgPSBnZXRJbmRleChmcm9tSW5kZXgpO1xyXG5cdFx0aWYgKHdvcmQgPiBsZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cdFx0bGV0IG1hc2sgPSBiaXRzRm9yKGZyb21JbmRleCwgMTUpO1xyXG5cclxuXHRcdGlmICgoZGF0YVt3b3JkXSAmIG1hc2spID09PSAwKSB7XHJcblx0XHRcdHdvcmQrKztcclxuXHRcdFx0bWFzayA9IDB4RkZGRjtcclxuXHRcdFx0Zm9yICg7IHdvcmQgPCBsZW5ndGg7IHdvcmQrKykge1xyXG5cdFx0XHRcdGlmIChkYXRhW3dvcmRdICE9PSAwKSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHdvcmQgPj0gbGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdW5JbmRleCh3b3JkKSArIGZpbmRMU0JTZXQoZGF0YVt3b3JkXSAmIG1hc2spO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUGVyZm9ybXMgYSBsb2dpY2FsICoqT1IqKiBvZiB0aGlzIGJpdCBzZXQgd2l0aCB0aGUgYml0IHNldCBhcmd1bWVudC4gVGhpcyBiaXQgc2V0IGlzIG1vZGlmaWVkIHNvIHRoYXQgYSBiaXQgaW4gaXRcclxuXHQgKiBoYXMgdGhlIHZhbHVlIGB0cnVlYCBpZiBhbmQgb25seSBpZiBpdCBlaXRoZXIgYWxyZWFkeSBoYWQgdGhlIHZhbHVlIGB0cnVlYCBvciB0aGUgY29ycmVzcG9uZGluZyBiaXQgaW4gdGhlIGJpdFxyXG5cdCAqIHNldCBhcmd1bWVudCBoYXMgdGhlIHZhbHVlIGB0cnVlYC5cclxuXHQgKi9cclxuXHRwdWJsaWMgb3Ioc2V0OiBCaXRTZXQpOiB2b2lkIHtcclxuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRjb25zdCBvdGhlciA9IHNldC5kYXRhO1xyXG5cdFx0Y29uc3QgbWluV29yZHMgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCwgb3RoZXIubGVuZ3RoKTtcclxuXHRcdGNvbnN0IHdvcmRzID0gTWF0aC5tYXgoZGF0YS5sZW5ndGgsIG90aGVyLmxlbmd0aCk7XHJcblx0XHRjb25zdCBkZXN0ID0gZGF0YS5sZW5ndGggPT09IHdvcmRzID8gZGF0YSA6IG5ldyBVaW50MTZBcnJheSh3b3Jkcyk7XHJcblxyXG5cdFx0bGV0IGxhc3RXb3JkID0gLTE7XHJcblxyXG5cdFx0Ly8gT3IgdGhvc2Ugd29yZHMgYm90aCBzZXRzIGhhdmUgaW4gY29tbW9uXHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtaW5Xb3JkczsgaSsrKSB7XHJcblx0XHRcdGxldCB2YWx1ZSA9IGRlc3RbaV0gPSBkYXRhW2ldIHwgb3RoZXJbaV07XHJcblx0XHRcdGlmICh2YWx1ZSAhPT0gMCkge1xyXG5cdFx0XHRcdGxhc3RXb3JkID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENvcHkgd29yZHMgZnJvbSBsYXJnZXIgc2V0IChpZiB0aGVyZSBpcyBvbmUpXHJcblxyXG5cdFx0Y29uc3QgbG9uZ2VyID0gZGF0YS5sZW5ndGggPiBvdGhlci5sZW5ndGggPyBkYXRhIDogb3RoZXI7XHJcblx0XHRmb3IgKGxldCBpID0gbWluV29yZHM7IGkgPCB3b3JkczsgaSsrKSB7XHJcblx0XHRcdGxldCB2YWx1ZSA9IGRlc3RbaV0gPSBsb25nZXJbaV07XHJcblx0XHRcdGlmICh2YWx1ZSAhPT0gMCkge1xyXG5cdFx0XHRcdGxhc3RXb3JkID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXN0V29yZCA9PT0gLTEpIHtcclxuXHRcdFx0dGhpcy5kYXRhID0gRU1QVFlfREFUQTtcclxuXHRcdH0gZWxzZSBpZiAoZGVzdC5sZW5ndGggPT09IGxhc3RXb3JkICsgMSkge1xyXG5cdFx0XHR0aGlzLmRhdGEgPSBkZXN0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5kYXRhID0gZGVzdC5zbGljZSgwLCBsYXN0V29yZCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbmVhcmVzdCBiaXQgdGhhdCBpcyBzZXQgdG8gYGZhbHNlYCB0aGF0IG9jY3VycyBvbiBvciBiZWZvcmUgdGhlIHNwZWNpZmllZCBzdGFydGluZ1xyXG5cdCAqIGluZGV4LiBJZiBubyBzdWNoIGJpdCBleGlzdHMsIG9yIGlmIGAtMWAgaXMgZ2l2ZW4gYXMgdGhlIHN0YXJ0aW5nIGluZGV4LCB0aGVuIGAtMWAgaXMgcmV0dXJuZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gZnJvbUluZGV4IHRoZSBpbmRleCB0byBzdGFydCBjaGVja2luZyBmcm9tIChpbmNsdXNpdmUpXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgdGhlIHNwZWNpZmllZCBpbmRleCBpcyBsZXNzIHRoYW4gYC0xYFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBwcmV2aW91c0NsZWFyQml0KGZyb21JbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGlmIChmcm9tSW5kZXggPCAwKSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiZnJvbUluZGV4IGNhbm5vdCBiZSBuZWdhdGl2ZVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0Y29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcblx0XHRsZXQgd29yZCA9IGdldEluZGV4KGZyb21JbmRleCk7XHJcblx0XHRpZiAod29yZCA+PSBsZW5ndGgpIHtcclxuXHRcdFx0d29yZCA9IGxlbmd0aCAtIDE7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGlnbm9yZSA9IDB4RkZGRiBeIGJpdHNGb3IoMCwgZnJvbUluZGV4KTtcclxuXHJcblx0XHRpZiAoKGRhdGFbd29yZF0gfCBpZ25vcmUpID09PSAweEZGRkYpIHtcclxuXHRcdFx0aWdub3JlID0gMDtcclxuXHRcdFx0d29yZC0tO1xyXG5cdFx0XHRmb3IgKDsgd29yZCA+PSAwOyB3b3JkLS0pIHtcclxuXHRcdFx0XHRpZiAoZGF0YVt3b3JkXSAhPT0gMHhGRkZGKSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHdvcmQgPCAwKSB7XHJcblx0XHRcdFx0Ly8gSGl0IHRoZSBlbmRcclxuXHRcdFx0XHRyZXR1cm4gLTE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB1bkluZGV4KHdvcmQpICsgZmluZE1TQlNldCgoZGF0YVt3b3JkXSB8IGlnbm9yZSkgXiAweEZGRkYpO1xyXG5cdH1cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBuZWFyZXN0IGJpdCB0aGF0IGlzIHNldCB0byBgdHJ1ZWAgdGhhdCBvY2N1cnMgb24gb3IgYmVmb3JlIHRoZSBzcGVjaWZpZWQgc3RhcnRpbmcgaW5kZXguXHJcblx0ICogSWYgbm8gc3VjaCBiaXQgZXhpc3RzLCBvciBpZiBgLTFgIGlzIGdpdmVuIGFzIHRoZSBzdGFydGluZyBpbmRleCwgdGhlbiBgLTFgIGlzIHJldHVybmVkLlxyXG5cdCAqXHJcblx0ICogVG8gaXRlcmF0ZSBvdmVyIHRoZSBgdHJ1ZWAgYml0cyBpbiBhIGBCaXRTZXRgLCB1c2UgdGhlIGZvbGxvd2luZyBsb29wOlxyXG5cdCAqXHJcblx0ICogYGBgXHJcblx0ICogZm9yIChsZXQgaSA9IGJzLmxlbmd0aCgpOyAoaSA9IGJzLnByZXZpb3VzU2V0Qml0KGktMSkpID49IDA7ICkge1xyXG5cdCAqICAgLy8gb3BlcmF0ZSBvbiBpbmRleCBpIGhlcmVcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gZnJvbUluZGV4IHRoZSBpbmRleCB0byBzdGFydCBjaGVja2luZyBmcm9tIChpbmNsdXNpdmUpXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgdGhlIHNwZWNpZmllZCBpbmRleCBpcyBsZXNzIHRoYW4gYC0xYFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBwcmV2aW91c1NldEJpdChmcm9tSW5kZXg6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRpZiAoZnJvbUluZGV4IDwgMCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImZyb21JbmRleCBjYW5ub3QgYmUgbmVnYXRpdmVcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG5cdFx0bGV0IHdvcmQgPSBnZXRJbmRleChmcm9tSW5kZXgpO1xyXG5cdFx0aWYgKHdvcmQgPj0gbGVuZ3RoKSB7XHJcblx0XHRcdHdvcmQgPSBsZW5ndGggLSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBtYXNrID0gYml0c0ZvcigwLCBmcm9tSW5kZXgpO1xyXG5cclxuXHRcdGlmICgoZGF0YVt3b3JkXSAmIG1hc2spID09PSAwKSB7XHJcblx0XHRcdHdvcmQtLTtcclxuXHRcdFx0bWFzayA9IDB4RkZGRjtcclxuXHRcdFx0Zm9yICg7IHdvcmQgPj0gMDsgd29yZC0tKSB7XHJcblx0XHRcdFx0aWYgKGRhdGFbd29yZF0gIT09IDApIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAod29yZCA8IDApIHtcclxuXHRcdFx0XHRyZXR1cm4gLTE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB1bkluZGV4KHdvcmQpICsgZmluZE1TQlNldChkYXRhW3dvcmRdICYgbWFzayk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBiaXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCB0byBgdHJ1ZWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gYml0SW5kZXggYSBiaXQgaW5kZXhcclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiB0aGUgc3BlY2lmaWVkIGluZGV4IGlzIG5lZ2F0aXZlXHJcblx0ICovXHJcblx0cHVibGljIHNldChiaXRJbmRleDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgYml0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBiaXRJbmRleCBhIGJpdCBpbmRleFxyXG5cdCAqIEBwYXJhbSB2YWx1ZSBhIGJvb2xlYW4gdmFsdWUgdG8gc2V0XHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgdGhlIHNwZWNpZmllZCBpbmRleCBpcyBuZWdhdGl2ZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzZXQoYml0SW5kZXg6IG51bWJlciwgdmFsdWU6IGJvb2xlYW4pOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCBgZnJvbUluZGV4YCAoaW5jbHVzaXZlKSB0byB0aGUgc3BlY2lmaWVkIGB0b0luZGV4YCAoZXhjbHVzaXZlKSB0byBgdHJ1ZWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gZnJvbUluZGV4IGluZGV4IG9mIHRoZSBmaXJzdCBiaXQgdG8gYmUgc2V0XHJcblx0ICogQHBhcmFtIHRvSW5kZXggaW5kZXggYWZ0ZXIgdGhlIGxhc3QgYml0IHRvIGJlIHNldFxyXG5cdCAqXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBvciBgdG9JbmRleGAgaXMgbmVnYXRpdmUsIG9yIGBmcm9tSW5kZXhgIGlzIGxhcmdlciB0aGFuIGB0b0luZGV4YFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzZXQoZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg6IG51bWJlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIGBmcm9tSW5kZXhgIChpbmNsdXNpdmUpIHRvIHRoZSBzcGVjaWZpZWQgYHRvSW5kZXhgIChleGNsdXNpdmUpIHRvIHRoZSBzcGVjaWZpZWRcclxuXHQgKiB2YWx1ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBmcm9tSW5kZXggaW5kZXggb2YgdGhlIGZpcnN0IGJpdCB0byBiZSBzZXRcclxuXHQgKiBAcGFyYW0gdG9JbmRleCBpbmRleCBhZnRlciB0aGUgbGFzdCBiaXQgdG8gYmUgc2V0XHJcblx0ICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIHNldCB0aGUgc2VsZWN0ZWQgYml0cyB0b1xyXG5cdCAqXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBvciBgdG9JbmRleGAgaXMgbmVnYXRpdmUsIG9yIGBmcm9tSW5kZXhgIGlzIGxhcmdlciB0aGFuIGB0b0luZGV4YFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzZXQoZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg6IG51bWJlciwgdmFsdWU6IGJvb2xlYW4pOiB2b2lkO1xyXG5cdHB1YmxpYyBzZXQoZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg/OiBib29sZWFuIHwgbnVtYmVyLCB2YWx1ZT86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGlmICh0b0luZGV4ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dG9JbmRleCA9IGZyb21JbmRleDtcclxuXHRcdFx0dmFsdWUgPSB0cnVlO1xyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdG9JbmRleCA9PT0gXCJib29sZWFuXCIpIHtcclxuXHRcdFx0dmFsdWUgPSB0b0luZGV4O1xyXG5cdFx0XHR0b0luZGV4ID0gZnJvbUluZGV4O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHZhbHVlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZnJvbUluZGV4IDwgMCB8fCBmcm9tSW5kZXggPiB0b0luZGV4KSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHdvcmQgPSBnZXRJbmRleChmcm9tSW5kZXgpO1xyXG5cdFx0bGV0IGxhc3RXb3JkID0gZ2V0SW5kZXgodG9JbmRleCk7XHJcblxyXG5cdFx0aWYgKHZhbHVlICYmIGxhc3RXb3JkID49IHRoaXMuZGF0YS5sZW5ndGgpIHtcclxuXHRcdFx0Ly8gR3JvdyBhcnJheSBcImp1c3QgZW5vdWdoXCIgZm9yIGJpdHMgd2UgbmVlZCB0byBzZXRcclxuXHRcdFx0bGV0IHRlbXAgPSBuZXcgVWludDE2QXJyYXkobGFzdFdvcmQgKyAxKTtcclxuXHRcdFx0dGhpcy5kYXRhLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4gdGVtcFtpbmRleF0gPSB2YWx1ZSk7XHJcblx0XHRcdHRoaXMuZGF0YSA9IHRlbXA7XHJcblx0XHR9IGVsc2UgaWYgKCF2YWx1ZSkge1xyXG5cdFx0XHQvLyBCdXQgdGhlcmUgaXMgbm8gbmVlZCB0byBncm93IGFycmF5IHRvIGNsZWFyIGJpdHMuXHJcblx0XHRcdGlmICh3b3JkID49IHRoaXMuZGF0YS5sZW5ndGgpIHtcclxuXHRcdFx0XHQvLyBFYXJseSBleGl0XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChsYXN0V29yZCA+PSB0aGlzLmRhdGEubGVuZ3RoKSB7XHJcblx0XHRcdFx0Ly8gQWRqdXN0IHdvcmsgdG8gZml0IGFycmF5XHJcblx0XHRcdFx0bGFzdFdvcmQgPSB0aGlzLmRhdGEubGVuZ3RoIC0gMTtcclxuXHRcdFx0XHR0b0luZGV4ID0gdGhpcy5kYXRhLmxlbmd0aCAqIDE2IC0gMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3b3JkID09PSBsYXN0V29yZCkge1xyXG5cdFx0XHR0aGlzLl9zZXRCaXRzKHdvcmQsIHZhbHVlLCBiaXRzRm9yKGZyb21JbmRleCwgdG9JbmRleCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fc2V0Qml0cyh3b3JkKyssIHZhbHVlLCBiaXRzRm9yKGZyb21JbmRleCwgMTUpKTtcclxuXHRcdFx0d2hpbGUgKHdvcmQgPCBsYXN0V29yZCkge1xyXG5cdFx0XHRcdHRoaXMuZGF0YVt3b3JkKytdID0gdmFsdWUgPyAweEZGRkYgOiAwO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3NldEJpdHMod29yZCwgdmFsdWUsIGJpdHNGb3IoMCwgdG9JbmRleCkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBfc2V0Qml0cyh3b3JkOiBudW1iZXIsIHZhbHVlOiBib29sZWFuLCBtYXNrOiBudW1iZXIpIHtcclxuXHRcdGlmICh2YWx1ZSkge1xyXG5cdFx0XHR0aGlzLmRhdGFbd29yZF0gfD0gbWFzaztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuZGF0YVt3b3JkXSAmPSAweEZGRkYgXiBtYXNrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJpdHMgb2Ygc3BhY2UgYWN0dWFsbHkgaW4gdXNlIGJ5IHRoaXMgYEJpdFNldGAgdG8gcmVwcmVzZW50IGJpdCB2YWx1ZXMuIFRoZSBtYXhpbXVtIGVsZW1lbnRcclxuXHQgKiBpbiB0aGUgc2V0IGlzIHRoZSBzaXplIC0gMXN0IGVsZW1lbnQuXHJcblx0ICovXHJcblx0Z2V0IHNpemUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmRhdGEuYnl0ZUxlbmd0aCAqIDg7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbmV3IGJ5dGUgYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGJpdHMgaW4gdGhpcyBiaXQgc2V0LlxyXG5cdCAqXHJcblx0ICogTW9yZSBwcmVjaXNlbHksIGlmXHJcblx0ICogYGxldCBieXRlcyA9IHMudG9CeXRlQXJyYXkoKTtgXHJcblx0ICogdGhlbiBgYnl0ZXMubGVuZ3RoID09PSAocy5sZW5ndGgoKSs3KS84YCBhbmQgYHMuZ2V0KG4pID09PSAoKGJ5dGVzW24vOF0gJiAoMTw8KG4lOCkpKSAhPSAwKWAgZm9yIGFsbFxyXG5cdCAqIGBuIDwgOCAqIGJ5dGVzLmxlbmd0aGAuXHJcblx0ICovXHJcblx0Ly8gdG9CeXRlQXJyYXkoKTogSW50OEFycmF5IHtcclxuXHQvLyBcdHRocm93IG5ldyBFcnJvcihcIk5PVCBJTVBMRU1FTlRFRFwiKTtcclxuXHQvLyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBuZXcgaW50ZWdlciBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgYml0cyBpbiB0aGlzIGJpdCBzZXQuXHJcblx0ICpcclxuXHQgKiBNb3JlIHByZWNpc2VseSwgaWZcclxuXHQgKiBgbGV0IGludGVnZXJzID0gcy50b0ludGVnZXJBcnJheSgpO2BcclxuXHQgKiB0aGVuIGBpbnRlZ2Vycy5sZW5ndGggPT09IChzLmxlbmd0aCgpKzMxKS8zMmAgYW5kIGBzLmdldChuKSA9PT0gKChpbnRlZ2Vyc1tuLzMyXSAmICgxPDwobiUzMikpKSAhPSAwKWAgZm9yIGFsbFxyXG5cdCAqIGBuIDwgMzIgKiBpbnRlZ2Vycy5sZW5ndGhgLlxyXG5cdCAqL1xyXG5cdC8vIHRvSW50ZWdlckFycmF5KCk6IEludDMyQXJyYXkge1xyXG5cdC8vIFx0dGhyb3cgbmV3IEVycm9yKFwiTk9UIElNUExFTUVOVEVEXCIpO1xyXG5cdC8vIH1cclxuXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gTXVybXVySGFzaC5oYXNoQ29kZSh0aGlzLmRhdGEsIDIyKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXBhcmVzIHRoaXMgb2JqZWN0IGFnYWluc3QgdGhlIHNwZWNpZmllZCBvYmplY3QuIFRoZSByZXN1bHQgaXMgYHRydWVgIGlmIGFuZCBvbmx5IGlmIHRoZSBhcmd1bWVudCBpcyBub3RcclxuXHQgKiBgdW5kZWZpbmVkYCBhbmQgaXMgYSBgQml0c2V0YCBvYmplY3QgdGhhdCBoYXMgZXhhY3RseSB0aGUgc2FtZSBzZXQgb2YgYml0cyBzZXQgdG8gYHRydWVgIGFzIHRoaXMgYml0IHNldC4gVGhhdFxyXG5cdCAqIGlzLCBmb3IgZXZlcnkgbm9ubmVnYXRpdmUgaW5kZXggYGtgLFxyXG5cdCAqXHJcblx0ICogYGBgXHJcblx0ICogKChCaXRTZXQpb2JqKS5nZXQoaykgPT0gdGhpcy5nZXQoaylcclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIG11c3QgYmUgdHJ1ZS4gVGhlIGN1cnJlbnQgc2l6ZXMgb2YgdGhlIHR3byBiaXQgc2V0cyBhcmUgbm90IGNvbXBhcmVkLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChvYmogPT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgQml0U2V0KSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbGVuID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRpZiAobGVuICE9PSBvYmoubGVuZ3RoKCkpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsZW4gPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGJvdW5kID0gZ2V0SW5kZXgobGVuIC0gMSk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSBib3VuZDsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLmRhdGFbaV0gIT09IG9iai5kYXRhW2ldKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYml0IHNldC4gRm9yIGV2ZXJ5IGluZGV4IGZvciB3aGljaCB0aGlzIGBCaXRTZXRgIGNvbnRhaW5zIGEgYml0IGluIHRoZVxyXG5cdCAqIHNldCBzdGF0ZSwgdGhlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhhdCBpbmRleCBpcyBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0LiBTdWNoIGluZGljZXMgYXJlIGxpc3RlZCBpbiBvcmRlclxyXG5cdCAqIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QsIHNlcGFyYXRlZCBieSBcIiwgXCIgKGEgY29tbWEgYW5kIGEgc3BhY2UpIGFuZCBzdXJyb3VuZGVkIGJ5IGJyYWNlcywgcmVzdWx0aW5nIGluIHRoZSB1c3VhbFxyXG5cdCAqIG1hdGhlbWF0aWNhbCBub3RhdGlvbiBmb3IgYSBzZXQgb2YgaW50ZWdlcnMuXHJcblx0ICpcclxuXHQgKiBFeGFtcGxlOlxyXG5cdCAqXHJcblx0ICogICAgIEJpdFNldCBkclBlcHBlciA9IG5ldyBCaXRTZXQoKTtcclxuXHQgKlxyXG5cdCAqIE5vdyBgZHJQZXBwZXIudG9TdHJpbmcoKWAgcmV0dXJucyBgXCJ7fVwiYC5cclxuXHQgKlxyXG5cdCAqICAgICBkclBlcHBlci5zZXQoMik7XHJcblx0ICpcclxuXHQgKiBOb3cgYGRyUGVwcGVyLnRvU3RyaW5nKClgIHJldHVybnMgYFwiezJ9XCJgLlxyXG5cdCAqXHJcblx0ICogICAgIGRyUGVwcGVyLnNldCg0KTtcclxuXHQgKiAgICAgZHJQZXBwZXIuc2V0KDEwKTtcclxuXHQgKlxyXG5cdCAqIE5vdyBgZHJQZXBwZXIudG9TdHJpbmcoKWAgcmV0dXJucyBgXCJ7MiwgNCwgMTB9XCJgLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0bGV0IHJlc3VsdCA9IFwie1wiO1xyXG5cclxuXHRcdGxldCBmaXJzdCA9IHRydWU7XHJcblx0XHRmb3IgKGxldCBpID0gdGhpcy5uZXh0U2V0Qml0KDApOyBpID49IDA7IGkgPSB0aGlzLm5leHRTZXRCaXQoaSArIDEpKSB7XHJcblx0XHRcdGlmIChmaXJzdCkge1xyXG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0ICs9IFwiLCBcIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmVzdWx0ICs9IGk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmVzdWx0ICs9IFwifVwiO1xyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdC8vIHN0YXRpYyB2YWx1ZU9mKGJ5dGVzOiBJbnQ4QXJyYXkpOiBCaXRTZXQ7XHJcblx0Ly8gc3RhdGljIHZhbHVlT2YoYnVmZmVyOiBBcnJheUJ1ZmZlcik6IEJpdFNldDtcclxuXHQvLyBzdGF0aWMgdmFsdWVPZihpbnRlZ2VyczogSW50MzJBcnJheSk6IEJpdFNldDtcclxuXHQvLyBzdGF0aWMgdmFsdWVPZihkYXRhOiBJbnQ4QXJyYXkgfCBJbnQzMkFycmF5IHwgQXJyYXlCdWZmZXIpOiBCaXRTZXQge1xyXG5cdC8vIFx0dGhyb3cgbmV3IEVycm9yKFwiTk9UIElNUExFTUVOVEVEXCIpO1xyXG5cdC8vIH1cclxuXHJcblx0LyoqXHJcblx0ICogUGVyZm9ybXMgYSBsb2dpY2FsICoqWE9SKiogb2YgdGhpcyBiaXQgc2V0IHdpdGggdGhlIGJpdCBzZXQgYXJndW1lbnQuIFRoaXMgYml0IHNldCBpcyBtb2RpZmllZCBzbyB0aGF0IGEgYml0IGluXHJcblx0ICogaXQgaGFzIHRoZSB2YWx1ZSBgdHJ1ZWAgaWYgYW5kIG9ubHkgaWYgb25lIG9mIHRoZSBmb2xsb3dpbmcgc3RhdGVtZW50cyBob2xkczpcclxuXHQgKlxyXG5cdCAqICogVGhlIGJpdCBpbml0aWFsbHkgaGFzIHRoZSB2YWx1ZSBgdHJ1ZWAsIGFuZCB0aGUgY29ycmVzcG9uZGluZyBiaXQgaW4gdGhlIGFyZ3VtZW50IGhhcyB0aGUgdmFsdWUgYGZhbHNlYC5cclxuXHQgKiAqIFRoZSBiaXQgaW5pdGlhbGx5IGhhcyB0aGUgdmFsdWUgYGZhbHNlYCwgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGJpdCBpbiB0aGUgYXJndW1lbnQgaGFzIHRoZSB2YWx1ZSBgdHJ1ZWAuXHJcblx0ICovXHJcblx0cHVibGljIHhvcihzZXQ6IEJpdFNldCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdGNvbnN0IG90aGVyID0gc2V0LmRhdGE7XHJcblx0XHRjb25zdCBtaW5Xb3JkcyA9IE1hdGgubWluKGRhdGEubGVuZ3RoLCBvdGhlci5sZW5ndGgpO1xyXG5cdFx0Y29uc3Qgd29yZHMgPSBNYXRoLm1heChkYXRhLmxlbmd0aCwgb3RoZXIubGVuZ3RoKTtcclxuXHRcdGNvbnN0IGRlc3QgPSBkYXRhLmxlbmd0aCA9PT0gd29yZHMgPyBkYXRhIDogbmV3IFVpbnQxNkFycmF5KHdvcmRzKTtcclxuXHJcblx0XHRsZXQgbGFzdFdvcmQgPSAtMTtcclxuXHJcblx0XHQvLyBYb3IgdGhvc2Ugd29yZHMgYm90aCBzZXRzIGhhdmUgaW4gY29tbW9uXHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtaW5Xb3JkczsgaSsrKSB7XHJcblx0XHRcdGxldCB2YWx1ZSA9IGRlc3RbaV0gPSBkYXRhW2ldIF4gb3RoZXJbaV07XHJcblx0XHRcdGlmICh2YWx1ZSAhPT0gMCkge1xyXG5cdFx0XHRcdGxhc3RXb3JkID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENvcHkgd29yZHMgZnJvbSBsYXJnZXIgc2V0IChpZiB0aGVyZSBpcyBvbmUpXHJcblxyXG5cdFx0Y29uc3QgbG9uZ2VyID0gZGF0YS5sZW5ndGggPiBvdGhlci5sZW5ndGggPyBkYXRhIDogb3RoZXI7XHJcblx0XHRmb3IgKGxldCBpID0gbWluV29yZHM7IGkgPCB3b3JkczsgaSsrKSB7XHJcblx0XHRcdGxldCB2YWx1ZSA9IGRlc3RbaV0gPSBsb25nZXJbaV07XHJcblx0XHRcdGlmICh2YWx1ZSAhPT0gMCkge1xyXG5cdFx0XHRcdGxhc3RXb3JkID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXN0V29yZCA9PT0gLTEpIHtcclxuXHRcdFx0dGhpcy5kYXRhID0gRU1QVFlfREFUQTtcclxuXHRcdH0gZWxzZSBpZiAoZGVzdC5sZW5ndGggPT09IGxhc3RXb3JkICsgMSkge1xyXG5cdFx0XHR0aGlzLmRhdGEgPSBkZXN0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5kYXRhID0gZGVzdC5zbGljZSgwLCBsYXN0V29yZCArIDEpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGNsb25lKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBCaXRTZXQodGhpcyk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgW1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmFibGVJdGVyYXRvcjxudW1iZXI+IHtcclxuXHRcdHJldHVybiBuZXcgQml0U2V0SXRlcmF0b3IodGhpcy5kYXRhKTtcclxuXHR9XHJcblxyXG5cdC8vIE92ZXJyaWRlcyBmb3JtYXR0aW5nIGZvciBub2RlanMgYXNzZXJ0IGV0Yy5cclxuXHRwdWJsaWMgWyh1dGlsLmluc3BlY3QgYXMgYW55KS5jdXN0b21dKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCJCaXRTZXQgXCIgKyB0aGlzLnRvU3RyaW5nKCk7XHJcblx0fVxyXG59XHJcblxyXG5jbGFzcyBCaXRTZXRJdGVyYXRvciBpbXBsZW1lbnRzIEl0ZXJhYmxlSXRlcmF0b3I8bnVtYmVyPntcclxuXHRwcml2YXRlIGluZGV4ID0gMDtcclxuXHRwcml2YXRlIG1hc2sgPSAweEZGRkY7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0YTogVWludDE2QXJyYXkpIHsgfVxyXG5cclxuXHRwdWJsaWMgbmV4dCgpIHtcclxuXHRcdHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy5kYXRhLmxlbmd0aCkge1xyXG5cdFx0XHRjb25zdCBiaXRzID0gdGhpcy5kYXRhW3RoaXMuaW5kZXhdICYgdGhpcy5tYXNrO1xyXG5cdFx0XHRpZiAoYml0cyAhPT0gMCkge1xyXG5cdFx0XHRcdGNvbnN0IGJpdE51bWJlciA9IHVuSW5kZXgodGhpcy5pbmRleCkgKyBmaW5kTFNCU2V0KGJpdHMpO1xyXG5cdFx0XHRcdHRoaXMubWFzayA9IGJpdHNGb3IoYml0TnVtYmVyICsgMSwgMTUpO1xyXG5cdFx0XHRcdHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogYml0TnVtYmVyIH07XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5pbmRleCsrO1xyXG5cdFx0XHR0aGlzLm1hc2sgPSAweEZGRkY7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogLTEgfTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYWJsZUl0ZXJhdG9yPG51bWJlcj4geyByZXR1cm4gdGhpczsgfVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyNS41NDg4MDEzLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBcnJheTJESGFzaE1hcCB9IGZyb20gXCIuLi9taXNjL0FycmF5MkRIYXNoTWFwXCI7XHJcbmltcG9ydCB7IEFycmF5MkRIYXNoU2V0IH0gZnJvbSBcIi4uL21pc2MvQXJyYXkyREhhc2hTZXRcIjtcclxuaW1wb3J0IHsgQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi4vbWlzYy9BcnJheUVxdWFsaXR5Q29tcGFyYXRvclwiO1xyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9BVE5cIjtcclxuaW1wb3J0IHsgQVROQ29uZmlnIH0gZnJvbSBcIi4vQVROQ29uZmlnXCI7XHJcbmltcG9ydCB7IEFUTlNpbXVsYXRvciB9IGZyb20gXCIuL0FUTlNpbXVsYXRvclwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEJpdFNldCB9IGZyb20gXCIuLi9taXNjL0JpdFNldFwiO1xyXG5pbXBvcnQgeyBDb25mbGljdEluZm8gfSBmcm9tIFwiLi9Db25mbGljdEluZm9cIjtcclxuaW1wb3J0IHsgRXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvRXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IEphdmFTZXQgfSBmcm9tIFwiLi4vbWlzYy9TdHVic1wiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuLi9taXNjL09iamVjdEVxdWFsaXR5Q29tcGFyYXRvclwiO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uQ29udGV4dCB9IGZyb20gXCIuL1ByZWRpY3Rpb25Db250ZXh0XCI7XHJcbmltcG9ydCB7IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUgfSBmcm9tIFwiLi9QcmVkaWN0aW9uQ29udGV4dENhY2hlXCI7XHJcbmltcG9ydCB7IFNlbWFudGljQ29udGV4dCB9IGZyb20gXCIuL1NlbWFudGljQ29udGV4dFwiO1xyXG5cclxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4uL21pc2MvVXRpbHNcIjtcclxuXHJcbmludGVyZmFjZSBLZXlUeXBlIHsgc3RhdGU6IG51bWJlcjsgYWx0OiBudW1iZXI7IH1cclxuXHJcbmNsYXNzIEtleVR5cGVFcXVhbGl0eUNvbXBhcmVyIGltcGxlbWVudHMgRXF1YWxpdHlDb21wYXJhdG9yPEtleVR5cGU+IHtcclxuXHRwdWJsaWMgaGFzaENvZGUoa2V5OiBLZXlUeXBlKSB7XHJcblx0XHRyZXR1cm4ga2V5LnN0YXRlIF4ga2V5LmFsdDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBlcXVhbHMoYTogS2V5VHlwZSwgYjogS2V5VHlwZSkge1xyXG5cdFx0cmV0dXJuIGEuc3RhdGUgPT09IGIuc3RhdGUgJiYgYS5hbHQgPT09IGIuYWx0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBJTlNUQU5DRSA9IG5ldyBLZXlUeXBlRXF1YWxpdHlDb21wYXJlcigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBOZXdLZXllZENvbmZpZ01hcChtYXA/OiBBcnJheTJESGFzaE1hcDxLZXlUeXBlLCBBVE5Db25maWc+KSB7XHJcblx0aWYgKG1hcCkge1xyXG5cdFx0cmV0dXJuIG5ldyBBcnJheTJESGFzaE1hcDxLZXlUeXBlLCBBVE5Db25maWc+KG1hcCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBuZXcgQXJyYXkyREhhc2hNYXA8S2V5VHlwZSwgQVROQ29uZmlnPihLZXlUeXBlRXF1YWxpdHlDb21wYXJlci5JTlNUQU5DRSk7XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHNldCBvZiBBVE4gY29uZmlndXJhdGlvbnMgKHNlZSBgQVROQ29uZmlnYCkuIEFzIGNvbmZpZ3VyYXRpb25zIGFyZSBhZGRlZCB0byB0aGUgc2V0LCB0aGV5IGFyZSBtZXJnZWRcclxuICogd2l0aCBvdGhlciBgQVROQ29uZmlnYCBpbnN0YW5jZXMgYWxyZWFkeSBpbiB0aGUgc2V0IHdoZW4gcG9zc2libGUgdXNpbmcgdGhlIGdyYXBoLXN0cnVjdHVyZWQgc3RhY2suXHJcbiAqXHJcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgY29tcGxldGUgc2V0IG9mIHBvc2l0aW9ucyAod2l0aCBjb250ZXh0KSBpbiBhbiBBVE4gd2hpY2ggd291bGQgYmUgYXNzb2NpYXRlZFxyXG4gKiB3aXRoIGEgc2luZ2xlIERGQSBzdGF0ZS4gSXRzIGludGVybmFsIHJlcHJlc2VudGF0aW9uIGlzIG1vcmUgY29tcGxleCB0aGFuIHRyYWRpdGlvbmFsIHN0YXRlIHVzZWQgZm9yIE5GQSB0byBERkFcclxuICogY29udmVyc2lvbiBkdWUgdG8gcGVyZm9ybWFuY2UgcmVxdWlyZW1lbnRzIChib3RoIGltcHJvdmluZyBzcGVlZCBhbmQgcmVkdWNpbmcgbWVtb3J5IG92ZXJoZWFkKSBhcyB3ZWxsIGFzIHN1cHBvcnRpbmdcclxuICogZmVhdHVyZXMgc3VjaCBhcyBzZW1hbnRpYyBwcmVkaWNhdGVzIGFuZCBub24tZ3JlZWR5IG9wZXJhdG9ycyBpbiBhIGZvcm0gdG8gc3VwcG9ydCBBTlRMUidzIHByZWRpY3Rpb24gYWxnb3JpdGhtLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQVROQ29uZmlnU2V0IGltcGxlbWVudHMgSmF2YVNldDxBVE5Db25maWc+IHtcclxuXHQvKipcclxuXHQgKiBUaGlzIG1hcHMgKHN0YXRlLCBhbHQpIC0+IG1lcmdlZCB7QGxpbmsgQVROQ29uZmlnfS4gVGhlIGtleSBkb2VzIG5vdCBhY2NvdW50IGZvclxyXG5cdCAqIHRoZSB7QGxpbmsgQVROQ29uZmlnI2dldFNlbWFudGljQ29udGV4dH0gb2YgdGhlIHZhbHVlLCB3aGljaCBpcyBvbmx5IGEgcHJvYmxlbSBpZiBhIHNpbmdsZVxyXG5cdCAqIGBBVE5Db25maWdTZXRgIGNvbnRhaW5zIHR3byBjb25maWdzIHdpdGggdGhlIHNhbWUgc3RhdGUgYW5kIGFsdGVybmF0aXZlXHJcblx0ICogYnV0IGRpZmZlcmVudCBzZW1hbnRpYyBjb250ZXh0cy4gV2hlbiB0aGlzIGNhc2UgYXJpc2VzLCB0aGUgZmlyc3QgY29uZmlnXHJcblx0ICogYWRkZWQgdG8gdGhpcyBtYXAgc3RheXMsIGFuZCB0aGUgcmVtYWluaW5nIGNvbmZpZ3MgYXJlIHBsYWNlZCBpbiB7QGxpbmsgI3VubWVyZ2VkfS5cclxuXHQgKlxyXG5cdCAqIFRoaXMgbWFwIGlzIG9ubHkgdXNlZCBmb3Igb3B0aW1pemluZyB0aGUgcHJvY2VzcyBvZiBhZGRpbmcgY29uZmlncyB0byB0aGUgc2V0LFxyXG5cdCAqIGFuZCBpcyBgdW5kZWZpbmVkYCBmb3IgcmVhZC1vbmx5IHNldHMgc3RvcmVkIGluIHRoZSBERkEuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBtZXJnZWRDb25maWdzPzogQXJyYXkyREhhc2hNYXA8S2V5VHlwZSwgQVROQ29uZmlnPjtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyBhbiBcIm92ZXJmbG93XCIgbGlzdCBob2xkaW5nIGNvbmZpZ3Mgd2hpY2ggY2Fubm90IGJlIG1lcmdlZCB3aXRoIG9uZVxyXG5cdCAqIG9mIHRoZSBjb25maWdzIGluIHtAbGluayAjbWVyZ2VkQ29uZmlnc30gYnV0IGhhdmUgYSBjb2xsaWRpbmcga2V5LiBUaGlzXHJcblx0ICogb2NjdXJzIHdoZW4gdHdvIGNvbmZpZ3MgaW4gdGhlIHNldCBoYXZlIHRoZSBzYW1lIHN0YXRlIGFuZCBhbHRlcm5hdGl2ZSBidXRcclxuXHQgKiBkaWZmZXJlbnQgc2VtYW50aWMgY29udGV4dHMuXHJcblx0ICpcclxuXHQgKiBUaGlzIGxpc3QgaXMgb25seSB1c2VkIGZvciBvcHRpbWl6aW5nIHRoZSBwcm9jZXNzIG9mIGFkZGluZyBjb25maWdzIHRvIHRoZSBzZXQsXHJcblx0ICogYW5kIGlzIGB1bmRlZmluZWRgIGZvciByZWFkLW9ubHkgc2V0cyBzdG9yZWQgaW4gdGhlIERGQS5cclxuXHQgKi9cclxuXHRwcml2YXRlIHVubWVyZ2VkPzogQVROQ29uZmlnW107XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBjb25maWdzIGluIHRoaXMgc2V0LlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgY29uZmlnczogQVROQ29uZmlnW107XHJcblxyXG5cdHByaXZhdGUgX3VuaXF1ZUFsdDogbnVtYmVyID0gMDtcclxuXHRwcml2YXRlIF9jb25mbGljdEluZm8/OiBDb25mbGljdEluZm87XHJcblx0Ly8gVXNlZCBpbiBwYXJzZXIgYW5kIGxleGVyLiBJbiBsZXhlciwgaXQgaW5kaWNhdGVzIHdlIGhpdCBhIHByZWRcclxuXHQvLyB3aGlsZSBjb21wdXRpbmcgYSBjbG9zdXJlIG9wZXJhdGlvbi4gIERvbid0IG1ha2UgYSBERkEgc3RhdGUgZnJvbSB0aGlzLlxyXG5cdHByaXZhdGUgX2hhc1NlbWFudGljQ29udGV4dDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHByaXZhdGUgX2RpcHNJbnRvT3V0ZXJDb250ZXh0OiBib29sZWFuID0gZmFsc2U7XHJcblx0LyoqXHJcblx0ICogV2hlbiBgdHJ1ZWAsIHRoaXMgY29uZmlnIHNldCByZXByZXNlbnRzIGNvbmZpZ3VyYXRpb25zIHdoZXJlIHRoZSBlbnRpcmVcclxuXHQgKiBvdXRlciBjb250ZXh0IGhhcyBiZWVuIGNvbnN1bWVkIGJ5IHRoZSBBVE4gaW50ZXJwcmV0ZXIuIFRoaXMgcHJldmVudHMgdGhlXHJcblx0ICoge0BsaW5rIFBhcnNlckFUTlNpbXVsYXRvciNjbG9zdXJlfSBmcm9tIHB1cnN1aW5nIHRoZSBnbG9iYWwgRk9MTE9XIHdoZW4gYVxyXG5cdCAqIHJ1bGUgc3RvcCBzdGF0ZSBpcyByZWFjaGVkIHdpdGggYW4gZW1wdHkgcHJlZGljdGlvbiBjb250ZXh0LlxyXG5cdCAqXHJcblx0ICogTm90ZTogYG91dGVybW9zdENvbmZpZ1NldGAgYW5kIHtAbGluayAjZGlwc0ludG9PdXRlckNvbnRleHR9IHNob3VsZCBuZXZlclxyXG5cdCAqIGJlIHRydWUgYXQgdGhlIHNhbWUgdGltZS5cclxuXHQgKi9cclxuXHRwcml2YXRlIG91dGVybW9zdENvbmZpZ1NldDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHRwcml2YXRlIGNhY2hlZEhhc2hDb2RlOiBudW1iZXIgPSAtMTtcclxuXHJcblx0Y29uc3RydWN0b3IoKTtcclxuXHRjb25zdHJ1Y3RvcihzZXQ6IEFUTkNvbmZpZ1NldCwgcmVhZG9ubHk6IGJvb2xlYW4pO1xyXG5cdGNvbnN0cnVjdG9yKHNldD86IEFUTkNvbmZpZ1NldCwgcmVhZG9ubHk/OiBib29sZWFuKSB7XHJcblx0XHRpZiAoIXNldCkge1xyXG5cdFx0XHR0aGlzLm1lcmdlZENvbmZpZ3MgPSBOZXdLZXllZENvbmZpZ01hcCgpO1xyXG5cdFx0XHR0aGlzLnVubWVyZ2VkID0gW107XHJcblx0XHRcdHRoaXMuY29uZmlncyA9IFtdO1xyXG5cclxuXHRcdFx0dGhpcy5fdW5pcXVlQWx0ID0gQVROLklOVkFMSURfQUxUX05VTUJFUjtcclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAocmVhZG9ubHkpIHtcclxuXHRcdFx0XHR0aGlzLm1lcmdlZENvbmZpZ3MgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0dGhpcy51bm1lcmdlZCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0fSBlbHNlIGlmICghc2V0LmlzUmVhZE9ubHkpIHtcclxuXHRcdFx0XHR0aGlzLm1lcmdlZENvbmZpZ3MgPSBOZXdLZXllZENvbmZpZ01hcChzZXQubWVyZ2VkQ29uZmlncyk7XHJcblx0XHRcdFx0dGhpcy51bm1lcmdlZCA9IChzZXQudW5tZXJnZWQgYXMgQVROQ29uZmlnW10pLnNsaWNlKDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMubWVyZ2VkQ29uZmlncyA9IE5ld0tleWVkQ29uZmlnTWFwKCk7XHJcblx0XHRcdFx0dGhpcy51bm1lcmdlZCA9IFtdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmNvbmZpZ3MgPSBzZXQuY29uZmlncy5zbGljZSgwKTtcclxuXHJcblx0XHRcdHRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0ID0gc2V0Ll9kaXBzSW50b091dGVyQ29udGV4dDtcclxuXHRcdFx0dGhpcy5faGFzU2VtYW50aWNDb250ZXh0ID0gc2V0Ll9oYXNTZW1hbnRpY0NvbnRleHQ7XHJcblx0XHRcdHRoaXMub3V0ZXJtb3N0Q29uZmlnU2V0ID0gc2V0Lm91dGVybW9zdENvbmZpZ1NldDtcclxuXHJcblx0XHRcdGlmIChyZWFkb25seSB8fCAhc2V0LmlzUmVhZE9ubHkpIHtcclxuXHRcdFx0XHR0aGlzLl91bmlxdWVBbHQgPSBzZXQuX3VuaXF1ZUFsdDtcclxuXHRcdFx0XHR0aGlzLl9jb25mbGljdEluZm8gPSBzZXQuX2NvbmZsaWN0SW5mbztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaWYgKCFyZWFkb25seSAmJiBzZXQuaXNSZWFkT25seSkgLT4gYWRkQWxsIGlzIGNhbGxlZCBmcm9tIGNsb25lKClcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgc2V0IG9mIGFsbCBhbHRlcm5hdGl2ZXMgcmVwcmVzZW50ZWQgYnkgY29uZmlndXJhdGlvbnMgaW4gdGhpc1xyXG5cdCAqIHNldC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRSZXByZXNlbnRlZEFsdGVybmF0aXZlcygpOiBCaXRTZXQge1xyXG5cdFx0aWYgKHRoaXMuX2NvbmZsaWN0SW5mbyAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jb25mbGljdEluZm8uY29uZmxpY3RlZEFsdHMuY2xvbmUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYWx0czogQml0U2V0ID0gbmV3IEJpdFNldCgpO1xyXG5cdFx0Zm9yIChsZXQgY29uZmlnIG9mIHRoaXMpIHtcclxuXHRcdFx0YWx0cy5zZXQoY29uZmlnLmFsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFsdHM7XHJcblx0fVxyXG5cclxuXHRnZXQgaXNSZWFkT25seSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLm1lcmdlZENvbmZpZ3MgPT0gbnVsbDtcclxuXHR9XHJcblxyXG5cdGdldCBpc091dGVybW9zdENvbmZpZ1NldCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLm91dGVybW9zdENvbmZpZ1NldDtcclxuXHR9XHJcblxyXG5cdHNldCBpc091dGVybW9zdENvbmZpZ1NldChvdXRlcm1vc3RDb25maWdTZXQ6IGJvb2xlYW4pIHtcclxuXHRcdGlmICh0aGlzLm91dGVybW9zdENvbmZpZ1NldCAmJiAhb3V0ZXJtb3N0Q29uZmlnU2V0KSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIklsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRhc3NlcnQoIW91dGVybW9zdENvbmZpZ1NldCB8fCAhdGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQpO1xyXG5cdFx0dGhpcy5vdXRlcm1vc3RDb25maWdTZXQgPSBvdXRlcm1vc3RDb25maWdTZXQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0U3RhdGVzKCk6IEFycmF5MkRIYXNoU2V0PEFUTlN0YXRlPiB7XHJcblx0XHRsZXQgc3RhdGVzID0gbmV3IEFycmF5MkRIYXNoU2V0PEFUTlN0YXRlPihPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xyXG5cdFx0Zm9yIChsZXQgYyBvZiB0aGlzLmNvbmZpZ3MpIHtcclxuXHRcdFx0c3RhdGVzLmFkZChjLnN0YXRlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3RhdGVzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIG9wdGltaXplQ29uZmlncyhpbnRlcnByZXRlcjogQVROU2ltdWxhdG9yKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5jb25maWdzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgY29uZmlnIG9mIHRoaXMuY29uZmlncykge1xyXG5cdFx0XHRjb25maWcuY29udGV4dCA9IGludGVycHJldGVyLmF0bi5nZXRDYWNoZWRDb250ZXh0KGNvbmZpZy5jb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBjbG9uZShyZWFkb25seTogYm9vbGVhbik6IEFUTkNvbmZpZ1NldCB7XHJcblx0XHRsZXQgY29weTogQVROQ29uZmlnU2V0ID0gbmV3IEFUTkNvbmZpZ1NldCh0aGlzLCByZWFkb25seSk7XHJcblx0XHRpZiAoIXJlYWRvbmx5ICYmIHRoaXMuaXNSZWFkT25seSkge1xyXG5cdFx0XHRjb3B5LmFkZEFsbCh0aGlzLmNvbmZpZ3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb3B5O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNpemUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZ3MubGVuZ3RoO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWdzLmxlbmd0aCA9PT0gMDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjb250YWlucyhvOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmICghKG8gaW5zdGFuY2VvZiBBVE5Db25maWcpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5tZXJnZWRDb25maWdzICYmIHRoaXMudW5tZXJnZWQpIHtcclxuXHRcdFx0bGV0IGNvbmZpZzogQVROQ29uZmlnID0gbztcclxuXHRcdFx0bGV0IGNvbmZpZ0tleSA9IHRoaXMuZ2V0S2V5KGNvbmZpZyk7XHJcblx0XHRcdGxldCBtZXJnZWRDb25maWcgPSB0aGlzLm1lcmdlZENvbmZpZ3MuZ2V0KGNvbmZpZ0tleSk7XHJcblx0XHRcdGlmIChtZXJnZWRDb25maWcgIT0gbnVsbCAmJiB0aGlzLmNhbk1lcmdlKGNvbmZpZywgY29uZmlnS2V5LCBtZXJnZWRDb25maWcpKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1lcmdlZENvbmZpZy5jb250YWlucyhjb25maWcpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKGxldCBjIG9mIHRoaXMudW5tZXJnZWQpIHtcclxuXHRcdFx0XHRpZiAoYy5jb250YWlucyhvKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRmb3IgKGxldCBjIG9mIHRoaXMuY29uZmlncykge1xyXG5cdFx0XHRcdGlmIChjLmNvbnRhaW5zKG8pKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgKltTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8QVROQ29uZmlnPiB7XHJcblx0XHR5aWVsZCogdGhpcy5jb25maWdzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvQXJyYXkoKTogQVROQ29uZmlnW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlncztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhZGQoZTogQVROQ29uZmlnKTogYm9vbGVhbjtcclxuXHRwdWJsaWMgYWRkKGU6IEFUTkNvbmZpZywgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlIHwgdW5kZWZpbmVkKTogYm9vbGVhbjtcclxuXHRwdWJsaWMgYWRkKGU6IEFUTkNvbmZpZywgY29udGV4dENhY2hlPzogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IGJvb2xlYW4ge1xyXG5cdFx0dGhpcy5lbnN1cmVXcml0YWJsZSgpO1xyXG5cdFx0aWYgKCF0aGlzLm1lcmdlZENvbmZpZ3MgfHwgIXRoaXMudW5tZXJnZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ292ZXJlZCBieSBlbnN1cmVXcml0YWJsZSBidXQgZHVwbGljYXRlZCBoZXJlIGZvciBzdHJpY3QgbnVsbCBjaGVjayBsaW1pdGF0aW9uXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGFzc2VydCghdGhpcy5vdXRlcm1vc3RDb25maWdTZXQgfHwgIWUucmVhY2hlc0ludG9PdXRlckNvbnRleHQpO1xyXG5cclxuXHRcdGlmIChjb250ZXh0Q2FjaGUgPT0gbnVsbCkge1xyXG5cdFx0XHRjb250ZXh0Q2FjaGUgPSBQcmVkaWN0aW9uQ29udGV4dENhY2hlLlVOQ0FDSEVEO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBhZGRLZXk6IGJvb2xlYW47XHJcblx0XHRsZXQga2V5ID0gdGhpcy5nZXRLZXkoZSk7XHJcblx0XHRsZXQgbWVyZ2VkQ29uZmlnID0gdGhpcy5tZXJnZWRDb25maWdzLmdldChrZXkpO1xyXG5cdFx0YWRkS2V5ID0gKG1lcmdlZENvbmZpZyA9PSBudWxsKTtcclxuXHRcdGlmIChtZXJnZWRDb25maWcgIT0gbnVsbCAmJiB0aGlzLmNhbk1lcmdlKGUsIGtleSwgbWVyZ2VkQ29uZmlnKSkge1xyXG5cdFx0XHRtZXJnZWRDb25maWcub3V0ZXJDb250ZXh0RGVwdGggPSBNYXRoLm1heChtZXJnZWRDb25maWcub3V0ZXJDb250ZXh0RGVwdGgsIGUub3V0ZXJDb250ZXh0RGVwdGgpO1xyXG5cdFx0XHRpZiAoZS5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkKSB7XHJcblx0XHRcdFx0bWVyZ2VkQ29uZmlnLmlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgam9pbmVkOiBQcmVkaWN0aW9uQ29udGV4dCA9IFByZWRpY3Rpb25Db250ZXh0LmpvaW4obWVyZ2VkQ29uZmlnLmNvbnRleHQsIGUuY29udGV4dCwgY29udGV4dENhY2hlKTtcclxuXHRcdFx0dGhpcy51cGRhdGVQcm9wZXJ0aWVzRm9yTWVyZ2VkQ29uZmlnKGUpO1xyXG5cdFx0XHRpZiAobWVyZ2VkQ29uZmlnLmNvbnRleHQgPT09IGpvaW5lZCkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bWVyZ2VkQ29uZmlnLmNvbnRleHQgPSBqb2luZWQ7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy51bm1lcmdlZC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgdW5tZXJnZWRDb25maWc6IEFUTkNvbmZpZyA9IHRoaXMudW5tZXJnZWRbaV07XHJcblx0XHRcdGlmICh0aGlzLmNhbk1lcmdlKGUsIGtleSwgdW5tZXJnZWRDb25maWcpKSB7XHJcblx0XHRcdFx0dW5tZXJnZWRDb25maWcub3V0ZXJDb250ZXh0RGVwdGggPSBNYXRoLm1heCh1bm1lcmdlZENvbmZpZy5vdXRlckNvbnRleHREZXB0aCwgZS5vdXRlckNvbnRleHREZXB0aCk7XHJcblx0XHRcdFx0aWYgKGUuaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCkge1xyXG5cdFx0XHRcdFx0dW5tZXJnZWRDb25maWcuaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgam9pbmVkOiBQcmVkaWN0aW9uQ29udGV4dCA9IFByZWRpY3Rpb25Db250ZXh0LmpvaW4odW5tZXJnZWRDb25maWcuY29udGV4dCwgZS5jb250ZXh0LCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdHRoaXMudXBkYXRlUHJvcGVydGllc0Zvck1lcmdlZENvbmZpZyhlKTtcclxuXHRcdFx0XHRpZiAodW5tZXJnZWRDb25maWcuY29udGV4dCA9PT0gam9pbmVkKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR1bm1lcmdlZENvbmZpZy5jb250ZXh0ID0gam9pbmVkO1xyXG5cclxuXHRcdFx0XHRpZiAoYWRkS2V5KSB7XHJcblx0XHRcdFx0XHR0aGlzLm1lcmdlZENvbmZpZ3MucHV0KGtleSwgdW5tZXJnZWRDb25maWcpO1xyXG5cdFx0XHRcdFx0dGhpcy51bm1lcmdlZC5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29uZmlncy5wdXNoKGUpO1xyXG5cdFx0aWYgKGFkZEtleSkge1xyXG5cdFx0XHR0aGlzLm1lcmdlZENvbmZpZ3MucHV0KGtleSwgZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnVubWVyZ2VkLnB1c2goZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy51cGRhdGVQcm9wZXJ0aWVzRm9yQWRkZWRDb25maWcoZSk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgdXBkYXRlUHJvcGVydGllc0Zvck1lcmdlZENvbmZpZyhjb25maWc6IEFUTkNvbmZpZyk6IHZvaWQge1xyXG5cdFx0Ly8gbWVyZ2VkIGNvbmZpZ3MgY2FuJ3QgY2hhbmdlIHRoZSBhbHQgb3Igc2VtYW50aWMgY29udGV4dFxyXG5cdFx0dGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQgPSB0aGlzLl9kaXBzSW50b091dGVyQ29udGV4dCB8fCBjb25maWcucmVhY2hlc0ludG9PdXRlckNvbnRleHQ7XHJcblx0XHRhc3NlcnQoIXRoaXMub3V0ZXJtb3N0Q29uZmlnU2V0IHx8ICF0aGlzLl9kaXBzSW50b091dGVyQ29udGV4dCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHVwZGF0ZVByb3BlcnRpZXNGb3JBZGRlZENvbmZpZyhjb25maWc6IEFUTkNvbmZpZyk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuY29uZmlncy5sZW5ndGggPT09IDEpIHtcclxuXHRcdFx0dGhpcy5fdW5pcXVlQWx0ID0gY29uZmlnLmFsdDtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5fdW5pcXVlQWx0ICE9PSBjb25maWcuYWx0KSB7XHJcblx0XHRcdHRoaXMuX3VuaXF1ZUFsdCA9IEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFzU2VtYW50aWNDb250ZXh0ID0gdGhpcy5faGFzU2VtYW50aWNDb250ZXh0IHx8ICFTZW1hbnRpY0NvbnRleHQuTk9ORS5lcXVhbHMoY29uZmlnLnNlbWFudGljQ29udGV4dCk7XHJcblx0XHR0aGlzLl9kaXBzSW50b091dGVyQ29udGV4dCA9IHRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0IHx8IGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dDtcclxuXHRcdGFzc2VydCghdGhpcy5vdXRlcm1vc3RDb25maWdTZXQgfHwgIXRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0KTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBjYW5NZXJnZShsZWZ0OiBBVE5Db25maWcsIGxlZnRLZXk6IHsgc3RhdGU6IG51bWJlciwgYWx0OiBudW1iZXIgfSwgcmlnaHQ6IEFUTkNvbmZpZyk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKGxlZnQuc3RhdGUuc3RhdGVOdW1iZXIgIT09IHJpZ2h0LnN0YXRlLnN0YXRlTnVtYmVyKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGVmdEtleS5hbHQgIT09IHJpZ2h0LmFsdCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxlZnQuc2VtYW50aWNDb250ZXh0LmVxdWFscyhyaWdodC5zZW1hbnRpY0NvbnRleHQpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldEtleShlOiBBVE5Db25maWcpOiB7IHN0YXRlOiBudW1iZXIsIGFsdDogbnVtYmVyIH0ge1xyXG5cdFx0cmV0dXJuIHsgc3RhdGU6IGUuc3RhdGUuc3RhdGVOdW1iZXIsIGFsdDogZS5hbHQgfTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjb250YWluc0FsbChjOiBJdGVyYWJsZTxhbnk+KTogYm9vbGVhbiB7XHJcblx0XHRmb3IgKGxldCBvIG9mIGMpIHtcclxuXHRcdFx0aWYgKCEobyBpbnN0YW5jZW9mIEFUTkNvbmZpZykpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghdGhpcy5jb250YWlucyhvKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFkZEFsbChjOiBJdGVyYWJsZTxBVE5Db25maWc+KTogYm9vbGVhbjtcclxuXHRwdWJsaWMgYWRkQWxsKGM6IEl0ZXJhYmxlPEFUTkNvbmZpZz4sIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IGJvb2xlYW47XHJcblx0cHVibGljIGFkZEFsbChjOiBJdGVyYWJsZTxBVE5Db25maWc+LCBjb250ZXh0Q2FjaGU/OiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogYm9vbGVhbiB7XHJcblx0XHR0aGlzLmVuc3VyZVdyaXRhYmxlKCk7XHJcblxyXG5cdFx0bGV0IGNoYW5nZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdGZvciAobGV0IGdyb3VwIG9mIGMpIHtcclxuXHRcdFx0aWYgKHRoaXMuYWRkKGdyb3VwLCBjb250ZXh0Q2FjaGUpKSB7XHJcblx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2hhbmdlZDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcclxuXHRcdHRoaXMuZW5zdXJlV3JpdGFibGUoKTtcclxuXHRcdGlmICghdGhpcy5tZXJnZWRDb25maWdzIHx8ICF0aGlzLnVubWVyZ2VkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNvdmVyZWQgYnkgZW5zdXJlV3JpdGFibGUgYnV0IGR1cGxpY2F0ZWQgaGVyZSBmb3Igc3RyaWN0IG51bGwgY2hlY2sgbGltaXRhdGlvblwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm1lcmdlZENvbmZpZ3MuY2xlYXIoKTtcclxuXHRcdHRoaXMudW5tZXJnZWQubGVuZ3RoID0gMDtcclxuXHRcdHRoaXMuY29uZmlncy5sZW5ndGggPSAwO1xyXG5cclxuXHRcdHRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0ID0gZmFsc2U7XHJcblx0XHR0aGlzLl9oYXNTZW1hbnRpY0NvbnRleHQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3VuaXF1ZUFsdCA9IEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XHJcblx0XHR0aGlzLl9jb25mbGljdEluZm8gPSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbiB7XHJcblx0XHRpZiAodGhpcyA9PT0gb2JqKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghKG9iaiBpbnN0YW5jZW9mIEFUTkNvbmZpZ1NldCkpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm91dGVybW9zdENvbmZpZ1NldCA9PT0gb2JqLm91dGVybW9zdENvbmZpZ1NldFxyXG5cdFx0XHQmJiBVdGlscy5lcXVhbHModGhpcy5fY29uZmxpY3RJbmZvLCBvYmouX2NvbmZsaWN0SW5mbylcclxuXHRcdFx0JiYgQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuZXF1YWxzKHRoaXMuY29uZmlncywgb2JqLmNvbmZpZ3MpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRpZiAodGhpcy5pc1JlYWRPbmx5ICYmIHRoaXMuY2FjaGVkSGFzaENvZGUgIT09IC0xKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNhY2hlZEhhc2hDb2RlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBoYXNoQ29kZTogbnVtYmVyID0gMTtcclxuXHRcdGhhc2hDb2RlID0gNSAqIGhhc2hDb2RlIF4gKHRoaXMub3V0ZXJtb3N0Q29uZmlnU2V0ID8gMSA6IDApO1xyXG5cdFx0aGFzaENvZGUgPSA1ICogaGFzaENvZGUgXiBBcnJheUVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRS5oYXNoQ29kZSh0aGlzLmNvbmZpZ3MpO1xyXG5cclxuXHRcdGlmICh0aGlzLmlzUmVhZE9ubHkpIHtcclxuXHRcdFx0dGhpcy5jYWNoZWRIYXNoQ29kZSA9IGhhc2hDb2RlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBoYXNoQ29kZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmc7XHJcblx0cHVibGljIHRvU3RyaW5nKHNob3dDb250ZXh0OiBib29sZWFuKTogc3RyaW5nO1xyXG5cdHB1YmxpYyB0b1N0cmluZyhzaG93Q29udGV4dD86IGJvb2xlYW4pOiBzdHJpbmcge1xyXG5cdFx0aWYgKHNob3dDb250ZXh0ID09IG51bGwpIHtcclxuXHRcdFx0c2hvd0NvbnRleHQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYnVmID0gXCJcIjtcclxuXHRcdGxldCBzb3J0ZWRDb25maWdzID0gdGhpcy5jb25maWdzLnNsaWNlKDApO1xyXG5cdFx0c29ydGVkQ29uZmlncy5zb3J0KChvMSwgbzIpID0+IHtcclxuXHRcdFx0aWYgKG8xLmFsdCAhPT0gbzIuYWx0KSB7XHJcblx0XHRcdFx0cmV0dXJuIG8xLmFsdCAtIG8yLmFsdDtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChvMS5zdGF0ZS5zdGF0ZU51bWJlciAhPT0gbzIuc3RhdGUuc3RhdGVOdW1iZXIpIHtcclxuXHRcdFx0XHRyZXR1cm4gbzEuc3RhdGUuc3RhdGVOdW1iZXIgLSBvMi5zdGF0ZS5zdGF0ZU51bWJlcjtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gbzEuc2VtYW50aWNDb250ZXh0LnRvU3RyaW5nKCkubG9jYWxlQ29tcGFyZShvMi5zZW1hbnRpY0NvbnRleHQudG9TdHJpbmcoKSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGJ1ZiArPSAoXCJbXCIpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRDb25maWdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChpID4gMCkge1xyXG5cdFx0XHRcdGJ1ZiArPSAoXCIsIFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRidWYgKz0gKHNvcnRlZENvbmZpZ3NbaV0udG9TdHJpbmcodW5kZWZpbmVkLCB0cnVlLCBzaG93Q29udGV4dCkpO1xyXG5cdFx0fVxyXG5cdFx0YnVmICs9IChcIl1cIik7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2hhc1NlbWFudGljQ29udGV4dCkge1xyXG5cdFx0XHRidWYgKz0gKFwiLGhhc1NlbWFudGljQ29udGV4dD1cIikgKyAodGhpcy5faGFzU2VtYW50aWNDb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl91bmlxdWVBbHQgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuXHRcdFx0YnVmICs9IChcIix1bmlxdWVBbHQ9XCIpICsgKHRoaXMuX3VuaXF1ZUFsdCk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fY29uZmxpY3RJbmZvICE9IG51bGwpIHtcclxuXHRcdFx0YnVmICs9IChcIixjb25mbGljdGluZ0FsdHM9XCIpICsgKHRoaXMuX2NvbmZsaWN0SW5mby5jb25mbGljdGVkQWx0cyk7XHJcblx0XHRcdGlmICghdGhpcy5fY29uZmxpY3RJbmZvLmlzRXhhY3QpIHtcclxuXHRcdFx0XHRidWYgKz0gKFwiKlwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0KSB7XHJcblx0XHRcdGJ1ZiArPSAoXCIsZGlwc0ludG9PdXRlckNvbnRleHRcIik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYnVmLnRvU3RyaW5nKCk7XHJcblx0fVxyXG5cclxuXHRnZXQgdW5pcXVlQWx0KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdW5pcXVlQWx0O1xyXG5cdH1cclxuXHJcblx0Z2V0IGhhc1NlbWFudGljQ29udGV4dCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLl9oYXNTZW1hbnRpY0NvbnRleHQ7XHJcblx0fVxyXG5cclxuXHRzZXQgaGFzU2VtYW50aWNDb250ZXh0KHZhbHVlOiBib29sZWFuKSB7XHJcblx0XHR0aGlzLmVuc3VyZVdyaXRhYmxlKCk7XHJcblx0XHR0aGlzLl9oYXNTZW1hbnRpY0NvbnRleHQgPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdGdldCBjb25mbGljdEluZm8oKTogQ29uZmxpY3RJbmZvIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb25mbGljdEluZm87XHJcblx0fVxyXG5cclxuXHRzZXQgY29uZmxpY3RJbmZvKGNvbmZsaWN0SW5mbzogQ29uZmxpY3RJbmZvIHwgdW5kZWZpbmVkKSB7XHJcblx0XHR0aGlzLmVuc3VyZVdyaXRhYmxlKCk7XHJcblx0XHR0aGlzLl9jb25mbGljdEluZm8gPSBjb25mbGljdEluZm87XHJcblx0fVxyXG5cclxuXHRnZXQgY29uZmxpY3RpbmdBbHRzKCk6IEJpdFNldCB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAodGhpcy5fY29uZmxpY3RJbmZvID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29uZmxpY3RJbmZvLmNvbmZsaWN0ZWRBbHRzO1xyXG5cdH1cclxuXHJcblx0Z2V0IGlzRXhhY3RDb25mbGljdCgpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLl9jb25mbGljdEluZm8gPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbmZsaWN0SW5mby5pc0V4YWN0O1xyXG5cdH1cclxuXHJcblx0Z2V0IGRpcHNJbnRvT3V0ZXJDb250ZXh0KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldChpbmRleDogbnVtYmVyKTogQVROQ29uZmlnIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZ3NbaW5kZXhdO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGVuc3VyZVdyaXRhYmxlKCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuaXNSZWFkT25seSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEFUTkNvbmZpZ1NldCBpcyByZWFkIG9ubHkuXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzguNzc3MTA1Ni0wNzowMFxyXG5cclxuaW1wb3J0IHsgQWNjZXB0U3RhdGVJbmZvIH0gZnJvbSBcIi4vQWNjZXB0U3RhdGVJbmZvXCI7XHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuLi9hdG4vQVROXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuLi9hdG4vQVROQ29uZmlnU2V0XCI7XHJcbmltcG9ydCB7IEJpdFNldCB9IGZyb20gXCIuLi9taXNjL0JpdFNldFwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvbkV4ZWN1dG9yIH0gZnJvbSBcIi4uL2F0bi9MZXhlckFjdGlvbkV4ZWN1dG9yXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbkNvbnRleHQgfSBmcm9tIFwiLi4vYXRuL1ByZWRpY3Rpb25Db250ZXh0XCI7XHJcbmltcG9ydCB7IFNlbWFudGljQ29udGV4dCB9IGZyb20gXCIuLi9hdG4vU2VtYW50aWNDb250ZXh0XCI7XHJcblxyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5cclxuLyoqIEEgREZBIHN0YXRlIHJlcHJlc2VudHMgYSBzZXQgb2YgcG9zc2libGUgQVROIGNvbmZpZ3VyYXRpb25zLlxyXG4gKiAgQXMgQWhvLCBTZXRoaSwgVWxsbWFuIHAuIDExNyBzYXlzIFwiVGhlIERGQSB1c2VzIGl0cyBzdGF0ZVxyXG4gKiAgdG8ga2VlcCB0cmFjayBvZiBhbGwgcG9zc2libGUgc3RhdGVzIHRoZSBBVE4gY2FuIGJlIGluIGFmdGVyXHJcbiAqICByZWFkaW5nIGVhY2ggaW5wdXQgc3ltYm9sLiAgVGhhdCBpcyB0byBzYXksIGFmdGVyIHJlYWRpbmdcclxuICogIGlucHV0IGExYTIuLmFuLCB0aGUgREZBIGlzIGluIGEgc3RhdGUgdGhhdCByZXByZXNlbnRzIHRoZVxyXG4gKiAgc3Vic2V0IFQgb2YgdGhlIHN0YXRlcyBvZiB0aGUgQVROIHRoYXQgYXJlIHJlYWNoYWJsZSBmcm9tIHRoZVxyXG4gKiAgQVROJ3Mgc3RhcnQgc3RhdGUgYWxvbmcgc29tZSBwYXRoIGxhYmVsZWQgYTFhMi4uYW4uXCJcclxuICogIEluIGNvbnZlbnRpb25hbCBORkEmcmFycjtERkEgY29udmVyc2lvbiwgdGhlcmVmb3JlLCB0aGUgc3Vic2V0IFRcclxuICogIHdvdWxkIGJlIGEgYml0c2V0IHJlcHJlc2VudGluZyB0aGUgc2V0IG9mIHN0YXRlcyB0aGVcclxuICogIEFUTiBjb3VsZCBiZSBpbi4gIFdlIG5lZWQgdG8gdHJhY2sgdGhlIGFsdCBwcmVkaWN0ZWQgYnkgZWFjaFxyXG4gKiAgc3RhdGUgYXMgd2VsbCwgaG93ZXZlci4gIE1vcmUgaW1wb3J0YW50bHksIHdlIG5lZWQgdG8gbWFpbnRhaW5cclxuICogIGEgc3RhY2sgb2Ygc3RhdGVzLCB0cmFja2luZyB0aGUgY2xvc3VyZSBvcGVyYXRpb25zIGFzIHRoZXlcclxuICogIGp1bXAgZnJvbSBydWxlIHRvIHJ1bGUsIGVtdWxhdGluZyBydWxlIGludm9jYXRpb25zIChtZXRob2QgY2FsbHMpLlxyXG4gKiAgSSBoYXZlIHRvIGFkZCBhIHN0YWNrIHRvIHNpbXVsYXRlIHRoZSBwcm9wZXIgbG9va2FoZWFkIHNlcXVlbmNlcyBmb3JcclxuICogIHRoZSB1bmRlcmx5aW5nIExMIGdyYW1tYXIgZnJvbSB3aGljaCB0aGUgQVROIHdhcyBkZXJpdmVkLlxyXG4gKlxyXG4gKiAgSSB1c2UgYSBzZXQgb2YgQVROQ29uZmlnIG9iamVjdHMgbm90IHNpbXBsZSBzdGF0ZXMuICBBbiBBVE5Db25maWdcclxuICogIGlzIGJvdGggYSBzdGF0ZSAoYWxhIG5vcm1hbCBjb252ZXJzaW9uKSBhbmQgYSBSdWxlQ29udGV4dCBkZXNjcmliaW5nXHJcbiAqICB0aGUgY2hhaW4gb2YgcnVsZXMgKGlmIGFueSkgZm9sbG93ZWQgdG8gYXJyaXZlIGF0IHRoYXQgc3RhdGUuXHJcbiAqXHJcbiAqICBBIERGQSBzdGF0ZSBtYXkgaGF2ZSBtdWx0aXBsZSByZWZlcmVuY2VzIHRvIGEgcGFydGljdWxhciBzdGF0ZSxcclxuICogIGJ1dCB3aXRoIGRpZmZlcmVudCBBVE4gY29udGV4dHMgKHdpdGggc2FtZSBvciBkaWZmZXJlbnQgYWx0cylcclxuICogIG1lYW5pbmcgdGhhdCBzdGF0ZSB3YXMgcmVhY2hlZCB2aWEgYSBkaWZmZXJlbnQgc2V0IG9mIHJ1bGUgaW52b2NhdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgREZBU3RhdGUge1xyXG5cdHB1YmxpYyBzdGF0ZU51bWJlcjogbnVtYmVyID0gLTE7XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldDtcclxuXHJcblx0LyoqIGBlZGdlcy5nZXQoc3ltYm9sKWAgcG9pbnRzIHRvIHRhcmdldCBvZiBzeW1ib2wuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIHJlYWRvbmx5IGVkZ2VzOiBNYXA8bnVtYmVyLCBERkFTdGF0ZT47XHJcblxyXG5cdHByaXZhdGUgX2FjY2VwdFN0YXRlSW5mbzogQWNjZXB0U3RhdGVJbmZvIHwgdW5kZWZpbmVkO1xyXG5cclxuXHQvKiogVGhlc2Uga2V5cyBmb3IgdGhlc2UgZWRnZXMgYXJlIHRoZSB0b3AgbGV2ZWwgZWxlbWVudCBvZiB0aGUgZ2xvYmFsIGNvbnRleHQuICovXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIHJlYWRvbmx5IGNvbnRleHRFZGdlczogTWFwPG51bWJlciwgREZBU3RhdGU+O1xyXG5cclxuXHQvKiogU3ltYm9scyBpbiB0aGlzIHNldCByZXF1aXJlIGEgZ2xvYmFsIGNvbnRleHQgdHJhbnNpdGlvbiBiZWZvcmUgbWF0Y2hpbmcgYW4gaW5wdXQgc3ltYm9sLiAqL1xyXG5cdHByaXZhdGUgY29udGV4dFN5bWJvbHM6IEJpdFNldCB8IHVuZGVmaW5lZDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBsaXN0IGlzIGNvbXB1dGVkIGJ5IHtAbGluayBQYXJzZXJBVE5TaW11bGF0b3IjcHJlZGljYXRlREZBU3RhdGV9LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBwcmVkaWNhdGVzOiBERkFTdGF0ZS5QcmVkUHJlZGljdGlvbltdIHwgdW5kZWZpbmVkO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGBERkFTdGF0ZWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gY29uZmlncyBUaGUgc2V0IG9mIEFUTiBjb25maWd1cmF0aW9ucyBkZWZpbmluZyB0aGlzIHN0YXRlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCkge1xyXG5cdFx0dGhpcy5jb25maWdzID0gY29uZmlncztcclxuXHRcdHRoaXMuZWRnZXMgPSBuZXcgTWFwPG51bWJlciwgREZBU3RhdGU+KCk7XHJcblx0XHR0aGlzLmNvbnRleHRFZGdlcyA9IG5ldyBNYXA8bnVtYmVyLCBERkFTdGF0ZT4oKTtcclxuXHR9XHJcblxyXG5cdGdldCBpc0NvbnRleHRTZW5zaXRpdmUoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gISF0aGlzLmNvbnRleHRTeW1ib2xzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGlzQ29udGV4dFN5bWJvbChzeW1ib2w6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKCF0aGlzLmlzQ29udGV4dFNlbnNpdGl2ZSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFN5bWJvbHMhLmdldChzeW1ib2wpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldENvbnRleHRTeW1ib2woc3ltYm9sOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGFzc2VydCh0aGlzLmlzQ29udGV4dFNlbnNpdGl2ZSk7XHJcblx0XHR0aGlzLmNvbnRleHRTeW1ib2xzIS5zZXQoc3ltYm9sKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXRDb250ZXh0U2Vuc2l0aXZlKGF0bjogQVROKTogdm9pZCB7XHJcblx0XHRhc3NlcnQoIXRoaXMuY29uZmlncy5pc091dGVybW9zdENvbmZpZ1NldCk7XHJcblx0XHRpZiAodGhpcy5pc0NvbnRleHRTZW5zaXRpdmUpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5jb250ZXh0U3ltYm9scykge1xyXG5cdFx0XHR0aGlzLmNvbnRleHRTeW1ib2xzID0gbmV3IEJpdFNldCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0IGFjY2VwdFN0YXRlSW5mbygpOiBBY2NlcHRTdGF0ZUluZm8gfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2FjY2VwdFN0YXRlSW5mbztcclxuXHR9XHJcblxyXG5cdHNldCBhY2NlcHRTdGF0ZUluZm8oYWNjZXB0U3RhdGVJbmZvOiBBY2NlcHRTdGF0ZUluZm8gfCB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuX2FjY2VwdFN0YXRlSW5mbyA9IGFjY2VwdFN0YXRlSW5mbztcclxuXHR9XHJcblxyXG5cdGdldCBpc0FjY2VwdFN0YXRlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5fYWNjZXB0U3RhdGVJbmZvO1xyXG5cdH1cclxuXHJcblx0Z2V0IHByZWRpY3Rpb24oKTogbnVtYmVyIHtcclxuXHRcdGlmICghdGhpcy5fYWNjZXB0U3RhdGVJbmZvKSB7XHJcblx0XHRcdHJldHVybiBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9hY2NlcHRTdGF0ZUluZm8ucHJlZGljdGlvbjtcclxuXHR9XHJcblxyXG5cdGdldCBsZXhlckFjdGlvbkV4ZWN1dG9yKCk6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKCF0aGlzLl9hY2NlcHRTdGF0ZUluZm8pIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fYWNjZXB0U3RhdGVJbmZvLmxleGVyQWN0aW9uRXhlY3V0b3I7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0VGFyZ2V0KHN5bWJvbDogbnVtYmVyKTogREZBU3RhdGUgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWRnZXMuZ2V0KHN5bWJvbCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0VGFyZ2V0KHN5bWJvbDogbnVtYmVyLCB0YXJnZXQ6IERGQVN0YXRlKTogdm9pZCB7XHJcblx0XHR0aGlzLmVkZ2VzLnNldChzeW1ib2wsIHRhcmdldCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0RWRnZU1hcCgpOiBNYXA8bnVtYmVyLCBERkFTdGF0ZT4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWRnZXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0Q29udGV4dFRhcmdldChpbnZva2luZ1N0YXRlOiBudW1iZXIpOiBERkFTdGF0ZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAoaW52b2tpbmdTdGF0ZSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVkpIHtcclxuXHRcdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvbnRleHRFZGdlcy5nZXQoaW52b2tpbmdTdGF0ZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0Q29udGV4dFRhcmdldChpbnZva2luZ1N0YXRlOiBudW1iZXIsIHRhcmdldDogREZBU3RhdGUpOiB2b2lkIHtcclxuXHRcdGlmICghdGhpcy5pc0NvbnRleHRTZW5zaXRpdmUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0YXRlIGlzIG5vdCBjb250ZXh0IHNlbnNpdGl2ZS5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGludm9raW5nU3RhdGUgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XHJcblx0XHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNvbnRleHRFZGdlcy5zZXQoaW52b2tpbmdTdGF0ZSwgdGFyZ2V0KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRDb250ZXh0RWRnZU1hcCgpOiBNYXA8bnVtYmVyLCBERkFTdGF0ZT4ge1xyXG5cdFx0bGV0IG1hcCA9IG5ldyBNYXA8bnVtYmVyLCBERkFTdGF0ZT4odGhpcy5jb250ZXh0RWRnZXMpO1xyXG5cdFx0bGV0IGV4aXN0aW5nID0gbWFwLmdldCgtMSk7XHJcblx0XHRpZiAoZXhpc3RpbmcgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZiAobWFwLnNpemUgPT09IDEpIHtcclxuXHRcdFx0XHRsZXQgcmVzdWx0ID0gbmV3IE1hcDxudW1iZXIsIERGQVN0YXRlPigpO1xyXG5cdFx0XHRcdHJlc3VsdC5zZXQoUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVksIGV4aXN0aW5nKTtcclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdG1hcC5kZWxldGUoLTEpO1xyXG5cdFx0XHRcdG1hcC5zZXQoUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVksIGV4aXN0aW5nKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXA7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoNyk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5jb25maWdzLmhhc2hDb2RlKCkpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2guZmluaXNoKGhhc2gsIDEpO1xyXG5cdFx0cmV0dXJuIGhhc2g7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUd28ge0BsaW5rIERGQVN0YXRlfSBpbnN0YW5jZXMgYXJlIGVxdWFsIGlmIHRoZWlyIEFUTiBjb25maWd1cmF0aW9uIHNldHNcclxuXHQgKiBhcmUgdGhlIHNhbWUuIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2VlIGlmIGEgc3RhdGUgYWxyZWFkeSBleGlzdHMuXHJcblx0ICpcclxuXHQgKiBCZWNhdXNlIHRoZSBudW1iZXIgb2YgYWx0ZXJuYXRpdmVzIGFuZCBudW1iZXIgb2YgQVROIGNvbmZpZ3VyYXRpb25zIGFyZVxyXG5cdCAqIGZpbml0ZSwgdGhlcmUgaXMgYSBmaW5pdGUgbnVtYmVyIG9mIERGQSBzdGF0ZXMgdGhhdCBjYW4gYmUgcHJvY2Vzc2VkLlxyXG5cdCAqIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHNob3cgdGhhdCB0aGUgYWxnb3JpdGhtIHRlcm1pbmF0ZXMuXHJcblx0ICpcclxuXHQgKiBDYW5ub3QgdGVzdCB0aGUgREZBIHN0YXRlIG51bWJlcnMgaGVyZSBiZWNhdXNlIGluXHJcblx0ICoge0BsaW5rIFBhcnNlckFUTlNpbXVsYXRvciNhZGRERkFTdGF0ZX0gd2UgbmVlZCB0byBrbm93IGlmIGFueSBvdGhlciBzdGF0ZVxyXG5cdCAqIGV4aXN0cyB0aGF0IGhhcyB0aGlzIGV4YWN0IHNldCBvZiBBVE4gY29uZmlndXJhdGlvbnMuIFRoZVxyXG5cdCAqIHtAbGluayAjc3RhdGVOdW1iZXJ9IGlzIGlycmVsZXZhbnQuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdC8vIGNvbXBhcmUgc2V0IG9mIEFUTiBjb25maWd1cmF0aW9ucyBpbiB0aGlzIHNldCB3aXRoIG90aGVyXHJcblx0XHRpZiAodGhpcyA9PT0gbykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIShvIGluc3RhbmNlb2YgREZBU3RhdGUpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgb3RoZXI6IERGQVN0YXRlID0gbztcclxuXHRcdGxldCBzYW1lU2V0OiBib29sZWFuID0gdGhpcy5jb25maWdzLmVxdWFscyhvdGhlci5jb25maWdzKTtcclxuLy9cdFx0U3lzdGVtLm91dC5wcmludGxuKFwiREZBU3RhdGUuZXF1YWxzOiBcIitjb25maWdzKyhzYW1lU2V0P1wiPT1cIjpcIiE9XCIpK290aGVyLmNvbmZpZ3MpO1xyXG5cdFx0cmV0dXJuIHNhbWVTZXQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGxldCBidWYgPSBcIlwiO1xyXG5cdFx0YnVmICs9ICh0aGlzLnN0YXRlTnVtYmVyKSArIChcIjpcIikgKyAodGhpcy5jb25maWdzKTtcclxuXHRcdGlmICh0aGlzLmlzQWNjZXB0U3RhdGUpIHtcclxuXHRcdFx0YnVmICs9IChcIj0+XCIpO1xyXG5cdFx0XHRpZiAodGhpcy5wcmVkaWNhdGVzKSB7XHJcblx0XHRcdFx0YnVmICs9IHRoaXMucHJlZGljYXRlcztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRidWYgKz0gKHRoaXMucHJlZGljdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBidWYudG9TdHJpbmcoKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgREZBU3RhdGUge1xyXG5cdC8qKiBNYXAgYSBwcmVkaWNhdGUgdG8gYSBwcmVkaWN0ZWQgYWx0ZXJuYXRpdmUuICovXHJcblx0ZXhwb3J0IGNsYXNzIFByZWRQcmVkaWN0aW9uIHtcclxuXHRcdEBOb3ROdWxsXHJcblx0XHRwdWJsaWMgcHJlZDogU2VtYW50aWNDb250ZXh0OyAgLy8gbmV2ZXIgbnVsbDsgYXQgbGVhc3QgU2VtYW50aWNDb250ZXh0Lk5PTkVcclxuXHRcdHB1YmxpYyBhbHQ6IG51bWJlcjtcclxuXHRcdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHByZWQ6IFNlbWFudGljQ29udGV4dCwgYWx0OiBudW1iZXIpIHtcclxuXHRcdFx0dGhpcy5hbHQgPSBhbHQ7XHJcblx0XHRcdHRoaXMucHJlZCA9IHByZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdFx0cmV0dXJuIFwiKFwiICsgdGhpcy5wcmVkICsgXCIsIFwiICsgdGhpcy5hbHQgKyBcIilcIjtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI3LjMxODQzMTEtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5Db25maWdTZXQgfSBmcm9tIFwiLi9BVE5Db25maWdTZXRcIjtcclxuaW1wb3J0IHsgREZBU3RhdGUgfSBmcm9tIFwiLi4vZGZhL0RGQVN0YXRlXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uQ29udGV4dCB9IGZyb20gXCIuL1ByZWRpY3Rpb25Db250ZXh0XCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQVROU2ltdWxhdG9yIHtcclxuXHQvKiogTXVzdCBkaXN0aW5ndWlzaCBiZXR3ZWVuIG1pc3NpbmcgZWRnZSBhbmQgZWRnZSB3ZSBrbm93IGxlYWRzIG5vd2hlcmUgKi9cclxuXHRwcml2YXRlIHN0YXRpYyBfRVJST1I6IERGQVN0YXRlO1xyXG5cdEBOb3ROdWxsXHJcblx0c3RhdGljIGdldCBFUlJPUigpOiBERkFTdGF0ZSB7XHJcblx0XHRpZiAoIUFUTlNpbXVsYXRvci5fRVJST1IpIHtcclxuXHRcdFx0QVROU2ltdWxhdG9yLl9FUlJPUiA9IG5ldyBERkFTdGF0ZShuZXcgQVROQ29uZmlnU2V0KCkpO1xyXG5cdFx0XHRBVE5TaW11bGF0b3IuX0VSUk9SLnN0YXRlTnVtYmVyID0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEFUTlNpbXVsYXRvci5fRVJST1I7XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBhdG46IEFUTjtcclxuXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgYXRuOiBBVE4pIHtcclxuXHRcdHRoaXMuYXRuID0gYXRuO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFic3RyYWN0IHJlc2V0KCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsZWFyIHRoZSBERkEgY2FjaGUgdXNlZCBieSB0aGUgY3VycmVudCBpbnN0YW5jZS4gU2luY2UgdGhlIERGQSBjYWNoZSBtYXlcclxuXHQgKiBiZSBzaGFyZWQgYnkgbXVsdGlwbGUgQVROIHNpbXVsYXRvcnMsIHRoaXMgbWV0aG9kIG1heSBhZmZlY3QgdGhlXHJcblx0ICogcGVyZm9ybWFuY2UgKGJ1dCBub3QgYWNjdXJhY3kpIG9mIG90aGVyIHBhcnNlcnMgd2hpY2ggYXJlIGJlaW5nIHVzZWRcclxuXHQgKiBjb25jdXJyZW50bHkuXHJcblx0ICpcclxuXHQgKiBAIGlmIHRoZSBjdXJyZW50IGluc3RhbmNlIGRvZXMgbm90XHJcblx0ICogc3VwcG9ydCBjbGVhcmluZyB0aGUgREZBLlxyXG5cdCAqXHJcblx0ICogQHNpbmNlIDQuM1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBjbGVhckRGQSgpOiB2b2lkIHtcclxuXHRcdHRoaXMuYXRuLmNsZWFyREZBKCk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIEFUTlNpbXVsYXRvciB7XHJcblx0Y29uc3QgUlVMRV9WQVJJQU5UX0RFTElNSVRFUjogc3RyaW5nID0gXCIkXCI7XHJcblx0Y29uc3QgUlVMRV9MRl9WQVJJQU5UX01BUktFUjogc3RyaW5nID0gXCIkbGYkXCI7XHJcblx0Y29uc3QgUlVMRV9OT0xGX1ZBUklBTlRfTUFSS0VSOiBzdHJpbmcgPSBcIiRub2xmJFwiO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1MC41NDc5NjAyLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBTlRMUkVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi9BTlRMUkVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4vUmVjb2duaXplclwiO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb25zb2xlRXJyb3JMaXN0ZW5lciBpbXBsZW1lbnRzIEFOVExSRXJyb3JMaXN0ZW5lcjxhbnk+IHtcclxuXHQvKipcclxuXHQgKiBQcm92aWRlcyBhIGRlZmF1bHQgaW5zdGFuY2Ugb2Yge0BsaW5rIENvbnNvbGVFcnJvckxpc3RlbmVyfS5cclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IElOU1RBTkNFOiBDb25zb2xlRXJyb3JMaXN0ZW5lciA9IG5ldyBDb25zb2xlRXJyb3JMaXN0ZW5lcigpO1xyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGltcGxlbWVudGF0aW9uIHByaW50cyBtZXNzYWdlcyB0byB7QGxpbmsgU3lzdGVtI2Vycn0gY29udGFpbmluZyB0aGVcclxuXHQgKiB2YWx1ZXMgb2YgYGxpbmVgLCBgY2hhclBvc2l0aW9uSW5MaW5lYCwgYW5kIGBtc2dgIHVzaW5nXHJcblx0ICogdGhlIGZvbGxvd2luZyBmb3JtYXQuXHJcblx0ICpcclxuXHQgKiA8cHJlPlxyXG5cdCAqIGxpbmUgKmxpbmUqOipjaGFyUG9zaXRpb25JbkxpbmUqICptc2cqXHJcblx0ICogPC9wcmU+XHJcblx0ICovXHJcblx0cHVibGljIHN5bnRheEVycm9yPFQ+KFxyXG5cdFx0cmVjb2duaXplcjogUmVjb2duaXplcjxULCBhbnk+LFxyXG5cdFx0b2ZmZW5kaW5nU3ltYm9sOiBULFxyXG5cdFx0bGluZTogbnVtYmVyLFxyXG5cdFx0Y2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXIsXHJcblx0XHRtc2c6IHN0cmluZyxcclxuXHRcdGU6IFJlY29nbml0aW9uRXhjZXB0aW9uIHwgdW5kZWZpbmVkKTogdm9pZCB7XHJcblx0XHRjb25zb2xlLmVycm9yKGBsaW5lICR7bGluZX06JHtjaGFyUG9zaXRpb25JbkxpbmV9ICR7bXNnfWApO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTYuODEyNjY5MC0wNzowMFxyXG5pbXBvcnQgeyBBTlRMUkVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi9BTlRMUkVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4vUmVjb2duaXplclwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSwgTm90TnVsbCB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBBTlRMUkVycm9yTGlzdGVuZXJ9IGRpc3BhdGNoZXMgYWxsIGNhbGxzIHRvIGFcclxuICogY29sbGVjdGlvbiBvZiBkZWxlZ2F0ZSBsaXN0ZW5lcnMuIFRoaXMgcmVkdWNlcyB0aGUgZWZmb3J0IHJlcXVpcmVkIHRvIHN1cHBvcnQgbXVsdGlwbGVcclxuICogbGlzdGVuZXJzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUHJveHlFcnJvckxpc3RlbmVyPFRTeW1ib2wsIFRMaXN0ZW5lciBleHRlbmRzIEFOVExSRXJyb3JMaXN0ZW5lcjxUU3ltYm9sPj4gaW1wbGVtZW50cyBBTlRMUkVycm9yTGlzdGVuZXI8VFN5bWJvbD4ge1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwcml2YXRlIGRlbGVnYXRlczogVExpc3RlbmVyW10pIHtcclxuXHRcdGlmICghZGVsZWdhdGVzKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGVsZWdhdGVzXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldERlbGVnYXRlcygpOiBSZWFkb25seUFycmF5PFRMaXN0ZW5lcj4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuZGVsZWdhdGVzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHN5bnRheEVycm9yPFQgZXh0ZW5kcyBUU3ltYm9sPihcclxuXHRcdEBOb3ROdWxsIHJlY29nbml6ZXI6IFJlY29nbml6ZXI8VCwgYW55PixcclxuXHRcdG9mZmVuZGluZ1N5bWJvbDogVCB8IHVuZGVmaW5lZCxcclxuXHRcdGxpbmU6IG51bWJlcixcclxuXHRcdGNoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyLFxyXG5cdFx0QE5vdE51bGwgbXNnOiBzdHJpbmcsXHJcblx0XHRlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB8IHVuZGVmaW5lZCk6IHZvaWQge1xyXG5cdFx0dGhpcy5kZWxlZ2F0ZXMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcclxuXHRcdFx0aWYgKGxpc3RlbmVyLnN5bnRheEVycm9yKSB7XHJcblx0XHRcdFx0bGlzdGVuZXIuc3ludGF4RXJyb3IocmVjb2duaXplciwgb2ZmZW5kaW5nU3ltYm9sLCBsaW5lLCBjaGFyUG9zaXRpb25JbkxpbmUsIG1zZywgZSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTcuMTk1NDQ0MS0wNzowMFxyXG5pbXBvcnQgeyBBTlRMUkVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi9BTlRMUkVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vYXRuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5TaW11bGF0b3IgfSBmcm9tIFwiLi9hdG4vQVROU2ltdWxhdG9yXCI7XHJcbmltcG9ydCB7IENvbnNvbGVFcnJvckxpc3RlbmVyIH0gZnJvbSBcIi4vQ29uc29sZUVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgSW50U3RyZWFtIH0gZnJvbSBcIi4vSW50U3RyZWFtXCI7XHJcbmltcG9ydCB7IFBhcnNlSW5mbyB9IGZyb20gXCIuL2F0bi9QYXJzZUluZm9cIjtcclxuaW1wb3J0IHsgUHJveHlFcnJvckxpc3RlbmVyIH0gZnJvbSBcIi4vUHJveHlFcnJvckxpc3RlbmVyXCI7XHJcbmltcG9ydCB7IFJlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4vUmVjb2duaXRpb25FeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9SdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBTdXBwcmVzc1dhcm5pbmdzLCBOb3ROdWxsIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnkgfSBmcm9tIFwiLi9Wb2NhYnVsYXJ5XCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnlJbXBsIH0gZnJvbSBcIi4vVm9jYWJ1bGFyeUltcGxcIjtcclxuXHJcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gXCIuL21pc2MvVXRpbHNcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWNvZ25pemVyPFRTeW1ib2wsIEFUTkludGVycHJldGVyIGV4dGVuZHMgQVROU2ltdWxhdG9yPiB7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBFT0Y6IG51bWJlciA9IC0xO1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyB0b2tlblR5cGVNYXBDYWNoZSA9XHJcblx0XHRuZXcgV2Vha01hcDxWb2NhYnVsYXJ5LCBSZWFkb25seU1hcDxzdHJpbmcsIG51bWJlcj4+KCk7XHJcblx0cHJpdmF0ZSBzdGF0aWMgcnVsZUluZGV4TWFwQ2FjaGUgPVxyXG5cdFx0bmV3IFdlYWtNYXA8c3RyaW5nW10sIFJlYWRvbmx5TWFwPHN0cmluZywgbnVtYmVyPj4oKTtcclxuXHJcblx0QFN1cHByZXNzV2FybmluZ3MoXCJzZXJpYWxcIilcclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgcmVhZG9ubHkgX2xpc3RlbmVyczogQXJyYXk8QU5UTFJFcnJvckxpc3RlbmVyPFRTeW1ib2w+PiA9IFtDb25zb2xlRXJyb3JMaXN0ZW5lci5JTlNUQU5DRV07XHJcblxyXG5cdHByb3RlY3RlZCBfaW50ZXJwITogQVROSW50ZXJwcmV0ZXI7XHJcblxyXG5cdHByaXZhdGUgX3N0YXRlTnVtYmVyID0gLTE7XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBydWxlTmFtZXM6IHN0cmluZ1tdO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHZvY2FidWxhcnkgdXNlZCBieSB0aGUgcmVjb2duaXplci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIEEge0BsaW5rIFZvY2FidWxhcnl9IGluc3RhbmNlIHByb3ZpZGluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGVcclxuXHQgKiB2b2NhYnVsYXJ5IHVzZWQgYnkgdGhlIGdyYW1tYXIuXHJcblx0ICovXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHZvY2FidWxhcnk6IFZvY2FidWxhcnk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhIG1hcCBmcm9tIHRva2VuIG5hbWVzIHRvIHRva2VuIHR5cGVzLlxyXG5cdCAqXHJcblx0ICogVXNlZCBmb3IgWFBhdGggYW5kIHRyZWUgcGF0dGVybiBjb21waWxhdGlvbi5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRUb2tlblR5cGVNYXAoKTogUmVhZG9ubHlNYXA8c3RyaW5nLCBudW1iZXI+IHtcclxuXHRcdGxldCB2b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5ID0gdGhpcy52b2NhYnVsYXJ5O1xyXG5cdFx0bGV0IHJlc3VsdCA9IFJlY29nbml6ZXIudG9rZW5UeXBlTWFwQ2FjaGUuZ2V0KHZvY2FidWxhcnkpO1xyXG5cdFx0aWYgKHJlc3VsdCA9PSBudWxsKSB7XHJcblx0XHRcdGxldCBpbnRlcm1lZGlhdGVSZXN1bHQgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSB0aGlzLmF0bi5tYXhUb2tlblR5cGU7IGkrKykge1xyXG5cdFx0XHRcdGxldCBsaXRlcmFsTmFtZSA9IHZvY2FidWxhcnkuZ2V0TGl0ZXJhbE5hbWUoaSk7XHJcblx0XHRcdFx0aWYgKGxpdGVyYWxOYW1lICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGludGVybWVkaWF0ZVJlc3VsdC5zZXQobGl0ZXJhbE5hbWUsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IHN5bWJvbGljTmFtZSA9IHZvY2FidWxhcnkuZ2V0U3ltYm9saWNOYW1lKGkpO1xyXG5cdFx0XHRcdGlmIChzeW1ib2xpY05hbWUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0aW50ZXJtZWRpYXRlUmVzdWx0LnNldChzeW1ib2xpY05hbWUsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aW50ZXJtZWRpYXRlUmVzdWx0LnNldChcIkVPRlwiLCBUb2tlbi5FT0YpO1xyXG5cdFx0XHRyZXN1bHQgPSBpbnRlcm1lZGlhdGVSZXN1bHQ7XHJcblx0XHRcdFJlY29nbml6ZXIudG9rZW5UeXBlTWFwQ2FjaGUuc2V0KHZvY2FidWxhcnksIHJlc3VsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhIG1hcCBmcm9tIHJ1bGUgbmFtZXMgdG8gcnVsZSBpbmRleGVzLlxyXG5cdCAqXHJcblx0ICogVXNlZCBmb3IgWFBhdGggYW5kIHRyZWUgcGF0dGVybiBjb21waWxhdGlvbi5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRSdWxlSW5kZXhNYXAoKTogUmVhZG9ubHlNYXA8c3RyaW5nLCBudW1iZXI+IHtcclxuXHRcdGxldCBydWxlTmFtZXM6IHN0cmluZ1tdID0gdGhpcy5ydWxlTmFtZXM7XHJcblx0XHRpZiAocnVsZU5hbWVzID09IG51bGwpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgcmVjb2duaXplciBkb2VzIG5vdCBwcm92aWRlIGEgbGlzdCBvZiBydWxlIG5hbWVzLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVzdWx0OiBSZWFkb25seU1hcDxzdHJpbmcsIG51bWJlcj4gfCB1bmRlZmluZWQgPSBSZWNvZ25pemVyLnJ1bGVJbmRleE1hcENhY2hlLmdldChydWxlTmFtZXMpO1xyXG5cdFx0aWYgKHJlc3VsdCA9PSBudWxsKSB7XHJcblx0XHRcdHJlc3VsdCA9IFV0aWxzLnRvTWFwKHJ1bGVOYW1lcyk7XHJcblx0XHRcdFJlY29nbml6ZXIucnVsZUluZGV4TWFwQ2FjaGUuc2V0KHJ1bGVOYW1lcywgcmVzdWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldFRva2VuVHlwZSh0b2tlbk5hbWU6IHN0cmluZyk6IG51bWJlciB7XHJcblx0XHRsZXQgdHR5cGUgPSB0aGlzLmdldFRva2VuVHlwZU1hcCgpLmdldCh0b2tlbk5hbWUpO1xyXG5cdFx0aWYgKHR0eXBlICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHR0eXBlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIFRva2VuLklOVkFMSURfVFlQRTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIElmIHRoaXMgcmVjb2duaXplciB3YXMgZ2VuZXJhdGVkLCBpdCB3aWxsIGhhdmUgYSBzZXJpYWxpemVkIEFUTlxyXG5cdCAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncmFtbWFyLlxyXG5cdCAqXHJcblx0ICogRm9yIGludGVycHJldGVycywgd2UgZG9uJ3Qga25vdyB0aGVpciBzZXJpYWxpemVkIEFUTiBkZXNwaXRlIGhhdmluZ1xyXG5cdCAqIGNyZWF0ZWQgdGhlIGludGVycHJldGVyIGZyb20gaXQuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRnZXQgc2VyaWFsaXplZEFUTigpOiBzdHJpbmcge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwidGhlcmUgaXMgbm8gc2VyaWFsaXplZCBBVE5cIik7XHJcblx0fVxyXG5cclxuXHQvKiogRm9yIGRlYnVnZ2luZyBhbmQgb3RoZXIgcHVycG9zZXMsIG1pZ2h0IHdhbnQgdGhlIGdyYW1tYXIgbmFtZS5cclxuXHQgKiAgSGF2ZSBBTlRMUiBnZW5lcmF0ZSBhbiBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBtZXRob2QuXHJcblx0ICovXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGdyYW1tYXJGaWxlTmFtZTogc3RyaW5nO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHtAbGluayBBVE59IHVzZWQgYnkgdGhlIHJlY29nbml6ZXIgZm9yIHByZWRpY3Rpb24uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUge0BsaW5rIEFUTn0gdXNlZCBieSB0aGUgcmVjb2duaXplciBmb3IgcHJlZGljdGlvbi5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBhdG4oKTogQVROIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbnRlcnAuYXRuO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBBVE4gaW50ZXJwcmV0ZXIgdXNlZCBieSB0aGUgcmVjb2duaXplciBmb3IgcHJlZGljdGlvbi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBBVE4gaW50ZXJwcmV0ZXIgdXNlZCBieSB0aGUgcmVjb2duaXplciBmb3IgcHJlZGljdGlvbi5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBpbnRlcnByZXRlcigpOiBBVE5JbnRlcnByZXRlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW50ZXJwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSBBVE4gaW50ZXJwcmV0ZXIgdXNlZCBieSB0aGUgcmVjb2duaXplciBmb3IgcHJlZGljdGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBpbnRlcnByZXRlciBUaGUgQVROIGludGVycHJldGVyIHVzZWQgYnkgdGhlIHJlY29nbml6ZXIgZm9yXHJcblx0ICogcHJlZGljdGlvbi5cclxuXHQgKi9cclxuXHRzZXQgaW50ZXJwcmV0ZXIoQE5vdE51bGwgaW50ZXJwcmV0ZXI6IEFUTkludGVycHJldGVyKSB7XHJcblx0XHR0aGlzLl9pbnRlcnAgPSBpbnRlcnByZXRlcjtcclxuXHR9XHJcblxyXG5cdC8qKiBJZiBwcm9maWxpbmcgZHVyaW5nIHRoZSBwYXJzZS9sZXgsIHRoaXMgd2lsbCByZXR1cm4gRGVjaXNpb25JbmZvIHJlY29yZHNcclxuXHQgKiAgZm9yIGVhY2ggZGVjaXNpb24gaW4gcmVjb2duaXplciBpbiBhIFBhcnNlSW5mbyBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAc2luY2UgNC4zXHJcblx0ICovXHJcblx0Z2V0IHBhcnNlSW5mbygpOiBQcm9taXNlPFBhcnNlSW5mbyB8IHVuZGVmaW5lZD4ge1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xyXG5cdH1cclxuXHJcblx0LyoqIFdoYXQgaXMgdGhlIGVycm9yIGhlYWRlciwgbm9ybWFsbHkgbGluZS9jaGFyYWN0ZXIgcG9zaXRpb24gaW5mb3JtYXRpb24/ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0RXJyb3JIZWFkZXIoQE5vdE51bGwgZTogUmVjb2duaXRpb25FeGNlcHRpb24pOiBzdHJpbmcge1xyXG5cdFx0bGV0IHRva2VuID0gZS5nZXRPZmZlbmRpbmdUb2tlbigpO1xyXG5cdFx0aWYgKCF0b2tlbikge1xyXG5cdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdH1cclxuXHRcdGxldCBsaW5lID0gdG9rZW4ubGluZTtcclxuXHRcdGxldCBjaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlciA9IHRva2VuLmNoYXJQb3NpdGlvbkluTGluZTtcclxuXHRcdHJldHVybiBcImxpbmUgXCIgKyBsaW5lICsgXCI6XCIgKyBjaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAZXhjZXB0aW9uIE51bGxQb2ludGVyRXhjZXB0aW9uIGlmIGBsaXN0ZW5lcmAgaXMgYHVuZGVmaW5lZGAuXHJcblx0ICovXHJcblx0cHVibGljIGFkZEVycm9yTGlzdGVuZXIoQE5vdE51bGwgbGlzdGVuZXI6IEFOVExSRXJyb3JMaXN0ZW5lcjxUU3ltYm9sPik6IHZvaWQge1xyXG5cdFx0aWYgKCFsaXN0ZW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwibGlzdGVuZXIgbXVzdCBub3QgYmUgbnVsbFwiKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyByZW1vdmVFcnJvckxpc3RlbmVyKEBOb3ROdWxsIGxpc3RlbmVyOiBBTlRMUkVycm9yTGlzdGVuZXI8VFN5bWJvbD4pOiB2b2lkIHtcclxuXHRcdGxldCBwb3NpdGlvbiA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuXHRcdGlmIChwb3NpdGlvbiAhPT0gLTEpIHtcclxuXHRcdFx0dGhpcy5fbGlzdGVuZXJzLnNwbGljZShwb3NpdGlvbiwgMSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVtb3ZlRXJyb3JMaXN0ZW5lcnMoKTogdm9pZCB7XHJcblx0XHR0aGlzLl9saXN0ZW5lcnMubGVuZ3RoID0gMDtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGdldEVycm9yTGlzdGVuZXJzKCk6IEFycmF5PEFOVExSRXJyb3JMaXN0ZW5lcjxUU3ltYm9sPj4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xpc3RlbmVycy5zbGljZSgwKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKTogQU5UTFJFcnJvckxpc3RlbmVyPFRTeW1ib2w+IHtcclxuXHRcdHJldHVybiBuZXcgUHJveHlFcnJvckxpc3RlbmVyPFRTeW1ib2wsIEFOVExSRXJyb3JMaXN0ZW5lcjxUU3ltYm9sPj4odGhpcy5nZXRFcnJvckxpc3RlbmVycygpKTtcclxuXHR9XHJcblxyXG5cdC8vIHN1YmNsYXNzIG5lZWRzIHRvIG92ZXJyaWRlIHRoZXNlIGlmIHRoZXJlIGFyZSBzZW1wcmVkcyBvciBhY3Rpb25zXHJcblx0Ly8gdGhhdCB0aGUgQVROIGludGVycCBuZWVkcyB0byBleGVjdXRlXHJcblx0cHVibGljIHNlbXByZWQoXHJcblx0XHRfbG9jYWxjdHg6IFJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLFxyXG5cdFx0cnVsZUluZGV4OiBudW1iZXIsXHJcblx0XHRhY3Rpb25JbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBwcmVjcHJlZChcclxuXHRcdGxvY2FsY3R4OiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCxcclxuXHRcdHByZWNlZGVuY2U6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWN0aW9uKFxyXG5cdFx0X2xvY2FsY3R4OiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCxcclxuXHRcdHJ1bGVJbmRleDogbnVtYmVyLFxyXG5cdFx0YWN0aW9uSW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH1cclxuXHJcblx0Z2V0IHN0YXRlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RhdGVOdW1iZXI7XHJcblx0fVxyXG5cclxuXHQvKiogSW5kaWNhdGUgdGhhdCB0aGUgcmVjb2duaXplciBoYXMgY2hhbmdlZCBpbnRlcm5hbCBzdGF0ZSB0aGF0IGlzXHJcblx0ICogIGNvbnNpc3RlbnQgd2l0aCB0aGUgQVROIHN0YXRlIHBhc3NlZCBpbi4gIFRoaXMgd2F5IHdlIGFsd2F5cyBrbm93XHJcblx0ICogIHdoZXJlIHdlIGFyZSBpbiB0aGUgQVROIGFzIHRoZSBwYXJzZXIgZ29lcyBhbG9uZy4gVGhlIHJ1bGVcclxuXHQgKiAgY29udGV4dCBvYmplY3RzIGZvcm0gYSBzdGFjayB0aGF0IGxldHMgdXMgc2VlIHRoZSBzdGFjayBvZlxyXG5cdCAqICBpbnZva2luZyBydWxlcy4gQ29tYmluZSB0aGlzIGFuZCB3ZSBoYXZlIGNvbXBsZXRlIEFUTlxyXG5cdCAqICBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uLlxyXG5cdCAqL1xyXG5cdHNldCBzdGF0ZShhdG5TdGF0ZTogbnVtYmVyKSB7XHJcbi8vXHRcdFN5c3RlbS5lcnIucHJpbnRsbihcInNldFN0YXRlIFwiK2F0blN0YXRlKTtcclxuXHRcdHRoaXMuX3N0YXRlTnVtYmVyID0gYXRuU3RhdGU7XHJcbi8vXHRcdGlmICggdHJhY2VBVE5TdGF0ZXMgKSBfY3R4LnRyYWNlKGF0blN0YXRlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBpbnB1dFN0cmVhbTogSW50U3RyZWFtIHwgdW5kZWZpbmVkO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1OS41ODI5NjU0LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBWb2NhYnVsYXJ5IH0gZnJvbSBcIi4vVm9jYWJ1bGFyeVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSB7QGxpbmsgVm9jYWJ1bGFyeX1cclxuICogaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVm9jYWJ1bGFyeUltcGwgaW1wbGVtZW50cyBWb2NhYnVsYXJ5IHtcclxuXHQvKipcclxuXHQgKiBHZXRzIGFuIGVtcHR5IHtAbGluayBWb2NhYnVsYXJ5fSBpbnN0YW5jZS5cclxuXHQgKlxyXG5cdCAqIE5vIGxpdGVyYWwgb3Igc3ltYm9sIG5hbWVzIGFyZSBhc3NpZ25lZCB0byB0b2tlbiB0eXBlcywgc29cclxuXHQgKiB7QGxpbmsgI2dldERpc3BsYXlOYW1lKGludCl9IHJldHVybnMgdGhlIG51bWVyaWMgdmFsdWUgZm9yIGFsbCB0b2tlbnNcclxuXHQgKiBleGNlcHQge0BsaW5rIFRva2VuI0VPRn0uXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEVNUFRZX1ZPQ0FCVUxBUlk6IFZvY2FidWxhcnlJbXBsID0gbmV3IFZvY2FidWxhcnlJbXBsKFtdLCBbXSwgW10pO1xyXG5cclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgcmVhZG9ubHkgbGl0ZXJhbE5hbWVzOiBBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSByZWFkb25seSBzeW1ib2xpY05hbWVzOiBBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSByZWFkb25seSBkaXNwbGF5TmFtZXM6IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZD47XHJcblxyXG5cdHByaXZhdGUgX21heFRva2VuVHlwZTogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBWb2NhYnVsYXJ5SW1wbH0gZnJvbSB0aGUgc3BlY2lmaWVkXHJcblx0ICogbGl0ZXJhbCwgc3ltYm9saWMsIGFuZCBkaXNwbGF5IHRva2VuIG5hbWVzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGxpdGVyYWxOYW1lcyBUaGUgbGl0ZXJhbCBuYW1lcyBhc3NpZ25lZCB0byB0b2tlbnMsIG9yIGFuIGVtcHR5IGFycmF5XHJcblx0ICogaWYgbm8gbGl0ZXJhbCBuYW1lcyBhcmUgYXNzaWduZWQuXHJcblx0ICogQHBhcmFtIHN5bWJvbGljTmFtZXMgVGhlIHN5bWJvbGljIG5hbWVzIGFzc2lnbmVkIHRvIHRva2Vucywgb3JcclxuXHQgKiBhbiBlbXB0eSBhcnJheSBpZiBubyBzeW1ib2xpYyBuYW1lcyBhcmUgYXNzaWduZWQuXHJcblx0ICogQHBhcmFtIGRpc3BsYXlOYW1lcyBUaGUgZGlzcGxheSBuYW1lcyBhc3NpZ25lZCB0byB0b2tlbnMsIG9yIGFuIGVtcHR5IGFycmF5XHJcblx0ICogdG8gdXNlIHRoZSB2YWx1ZXMgaW4gYGxpdGVyYWxOYW1lc2AgYW5kIGBzeW1ib2xpY05hbWVzYCBhc1xyXG5cdCAqIHRoZSBzb3VyY2Ugb2YgZGlzcGxheSBuYW1lcywgYXMgZGVzY3JpYmVkIGluXHJcblx0ICoge0BsaW5rICNnZXREaXNwbGF5TmFtZShpbnQpfS5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI2dldExpdGVyYWxOYW1lKGludClcclxuXHQgKiBAc2VlICNnZXRTeW1ib2xpY05hbWUoaW50KVxyXG5cdCAqIEBzZWUgI2dldERpc3BsYXlOYW1lKGludClcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihsaXRlcmFsTmFtZXM6IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZD4sIHN5bWJvbGljTmFtZXM6IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZD4sIGRpc3BsYXlOYW1lczogQXJyYXk8c3RyaW5nIHwgdW5kZWZpbmVkPikge1xyXG5cdFx0dGhpcy5saXRlcmFsTmFtZXMgPSBsaXRlcmFsTmFtZXM7XHJcblx0XHR0aGlzLnN5bWJvbGljTmFtZXMgPSBzeW1ib2xpY05hbWVzO1xyXG5cdFx0dGhpcy5kaXNwbGF5TmFtZXMgPSBkaXNwbGF5TmFtZXM7XHJcblx0XHQvLyBTZWUgbm90ZSBoZXJlIG9uIC0xIHBhcnQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRsci9hbnRscjQvcHVsbC8xMTQ2XHJcblx0XHR0aGlzLl9tYXhUb2tlblR5cGUgPVxyXG5cdFx0XHRNYXRoLm1heCh0aGlzLmRpc3BsYXlOYW1lcy5sZW5ndGgsXHJcblx0XHRcdFx0TWF0aC5tYXgodGhpcy5saXRlcmFsTmFtZXMubGVuZ3RoLCB0aGlzLnN5bWJvbGljTmFtZXMubGVuZ3RoKSkgLSAxO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IG1heFRva2VuVHlwZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX21heFRva2VuVHlwZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXRMaXRlcmFsTmFtZSh0b2tlblR5cGU6IG51bWJlcik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAodG9rZW5UeXBlID49IDAgJiYgdG9rZW5UeXBlIDwgdGhpcy5saXRlcmFsTmFtZXMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmxpdGVyYWxOYW1lc1t0b2tlblR5cGVdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0U3ltYm9saWNOYW1lKHRva2VuVHlwZTogbnVtYmVyKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICh0b2tlblR5cGUgPj0gMCAmJiB0b2tlblR5cGUgPCB0aGlzLnN5bWJvbGljTmFtZXMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnN5bWJvbGljTmFtZXNbdG9rZW5UeXBlXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodG9rZW5UeXBlID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0cmV0dXJuIFwiRU9GXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGdldERpc3BsYXlOYW1lKHRva2VuVHlwZTogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdGlmICh0b2tlblR5cGUgPj0gMCAmJiB0b2tlblR5cGUgPCB0aGlzLmRpc3BsYXlOYW1lcy5sZW5ndGgpIHtcclxuXHRcdFx0bGV0IGRpc3BsYXlOYW1lID0gdGhpcy5kaXNwbGF5TmFtZXNbdG9rZW5UeXBlXTtcclxuXHRcdFx0aWYgKGRpc3BsYXlOYW1lKSB7XHJcblx0XHRcdFx0cmV0dXJuIGRpc3BsYXlOYW1lO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGxpdGVyYWxOYW1lID0gdGhpcy5nZXRMaXRlcmFsTmFtZSh0b2tlblR5cGUpO1xyXG5cdFx0aWYgKGxpdGVyYWxOYW1lKSB7XHJcblx0XHRcdHJldHVybiBsaXRlcmFsTmFtZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgc3ltYm9saWNOYW1lID0gdGhpcy5nZXRTeW1ib2xpY05hbWUodG9rZW5UeXBlKTtcclxuXHRcdGlmIChzeW1ib2xpY05hbWUpIHtcclxuXHRcdFx0cmV0dXJuIHN5bWJvbGljTmFtZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gU3RyaW5nKHRva2VuVHlwZSk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozOC41MDk3OTI1LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi4vYXRuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5TaW11bGF0b3IgfSBmcm9tIFwiLi4vYXRuL0FUTlNpbXVsYXRvclwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuLi9hdG4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgREZBIH0gZnJvbSBcIi4vREZBXCI7XHJcbmltcG9ydCB7IERGQVN0YXRlIH0gZnJvbSBcIi4vREZBU3RhdGVcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uQ29udGV4dCB9IGZyb20gXCIuLi9hdG4vUHJlZGljdGlvbkNvbnRleHRcIjtcclxuaW1wb3J0IHsgUmVjb2duaXplciB9IGZyb20gXCIuLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnkgfSBmcm9tIFwiLi4vVm9jYWJ1bGFyeVwiO1xyXG5pbXBvcnQgeyBWb2NhYnVsYXJ5SW1wbCB9IGZyb20gXCIuLi9Wb2NhYnVsYXJ5SW1wbFwiO1xyXG5cclxuLyoqIEEgREZBIHdhbGtlciB0aGF0IGtub3dzIGhvdyB0byBkdW1wIHRoZW0gdG8gc2VyaWFsaXplZCBzdHJpbmdzLiAqL1xyXG5leHBvcnQgY2xhc3MgREZBU2VyaWFsaXplciB7XHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIGRmYTogREZBO1xyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSB2b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5O1xyXG5cclxuXHRwdWJsaWMgcnVsZU5hbWVzPzogc3RyaW5nW107XHJcblxyXG5cdHB1YmxpYyBhdG4/OiBBVE47XHJcblxyXG5cdGNvbnN0cnVjdG9yKC8qQE5vdE51bGwqLyBkZmE6IERGQSwgLypATm90TnVsbCovIHZvY2FidWxhcnk6IFZvY2FidWxhcnkpO1xyXG5cdGNvbnN0cnVjdG9yKC8qQE5vdE51bGwqLyBkZmE6IERGQSwgLypATnVsbGFibGUqLyBwYXJzZXI6IFJlY29nbml6ZXI8YW55LCBhbnk+IHwgdW5kZWZpbmVkKTtcclxuXHRjb25zdHJ1Y3RvcigvKkBOb3ROdWxsKi8gZGZhOiBERkEsIC8qQE5vdE51bGwqLyB2b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5LCAvKkBOdWxsYWJsZSovIHJ1bGVOYW1lczogc3RyaW5nW10gfCB1bmRlZmluZWQsIC8qQE51bGxhYmxlKi8gYXRuOiBBVE4gfCB1bmRlZmluZWQpO1xyXG5cdGNvbnN0cnVjdG9yKGRmYTogREZBLCB2b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5IHwgUmVjb2duaXplcjxhbnksIGFueT4gfCB1bmRlZmluZWQsIHJ1bGVOYW1lcz86IHN0cmluZ1tdLCBhdG4/OiBBVE4pIHtcclxuXHRcdGlmICh2b2NhYnVsYXJ5IGluc3RhbmNlb2YgUmVjb2duaXplcikge1xyXG5cdFx0XHRydWxlTmFtZXMgPSB2b2NhYnVsYXJ5LnJ1bGVOYW1lcztcclxuXHRcdFx0YXRuID0gdm9jYWJ1bGFyeS5hdG47XHJcblx0XHRcdHZvY2FidWxhcnkgPSB2b2NhYnVsYXJ5LnZvY2FidWxhcnk7XHJcblx0XHR9IGVsc2UgaWYgKCF2b2NhYnVsYXJ5KSB7XHJcblx0XHRcdHZvY2FidWxhcnkgPSBWb2NhYnVsYXJ5SW1wbC5FTVBUWV9WT0NBQlVMQVJZO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGZhID0gZGZhO1xyXG5cdFx0dGhpcy52b2NhYnVsYXJ5ID0gdm9jYWJ1bGFyeTtcclxuXHRcdHRoaXMucnVsZU5hbWVzID0gcnVsZU5hbWVzO1xyXG5cdFx0dGhpcy5hdG4gPSBhdG47XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGlmICghdGhpcy5kZmEuczApIHtcclxuXHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGJ1ZiA9IFwiXCI7XHJcblxyXG5cdFx0aWYgKHRoaXMuZGZhLnN0YXRlcykge1xyXG5cdFx0XHRsZXQgc3RhdGVzOiBERkFTdGF0ZVtdID0gbmV3IEFycmF5PERGQVN0YXRlPiguLi50aGlzLmRmYS5zdGF0ZXMudG9BcnJheSgpKTtcclxuXHRcdFx0c3RhdGVzLnNvcnQoKG8xLCBvMikgPT4gbzEuc3RhdGVOdW1iZXIgLSBvMi5zdGF0ZU51bWJlcik7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBzIG9mIHN0YXRlcykge1xyXG5cdFx0XHRcdGxldCBlZGdlczogTWFwPG51bWJlciwgREZBU3RhdGU+ID0gcy5nZXRFZGdlTWFwKCk7XHJcblx0XHRcdFx0bGV0IGVkZ2VLZXlzID0gWy4uLmVkZ2VzLmtleXMoKV0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG5cdFx0XHRcdGxldCBjb250ZXh0RWRnZXM6IE1hcDxudW1iZXIsIERGQVN0YXRlPiA9IHMuZ2V0Q29udGV4dEVkZ2VNYXAoKTtcclxuXHRcdFx0XHRsZXQgY29udGV4dEVkZ2VLZXlzID0gWy4uLmNvbnRleHRFZGdlcy5rZXlzKCldLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuXHRcdFx0XHRmb3IgKGxldCBlbnRyeSBvZiBlZGdlS2V5cykge1xyXG5cdFx0XHRcdFx0bGV0IHZhbHVlID0gZWRnZXMuZ2V0KGVudHJ5KTtcclxuXHRcdFx0XHRcdGlmICgodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gQVROU2ltdWxhdG9yLkVSUk9SKSAmJiAhcy5pc0NvbnRleHRTeW1ib2woZW50cnkpKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCBjb250ZXh0U3ltYm9sOiBib29sZWFuID0gZmFsc2U7XHJcblx0XHRcdFx0XHRidWYgKz0gKHRoaXMuZ2V0U3RhdGVTdHJpbmcocykpICsgKFwiLVwiKSArICh0aGlzLmdldEVkZ2VMYWJlbChlbnRyeSkpICsgKFwiLT5cIik7XHJcblx0XHRcdFx0XHRpZiAocy5pc0NvbnRleHRTeW1ib2woZW50cnkpKSB7XHJcblx0XHRcdFx0XHRcdGJ1ZiArPSAoXCIhXCIpO1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0U3ltYm9sID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsZXQgdDogREZBU3RhdGUgfCB1bmRlZmluZWQgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdGlmICh0ICYmIHQuc3RhdGVOdW1iZXIgIT09IEFUTlNpbXVsYXRvci5FUlJPUi5zdGF0ZU51bWJlcikge1xyXG5cdFx0XHRcdFx0XHRidWYgKz0gKHRoaXMuZ2V0U3RhdGVTdHJpbmcodCkpICsgKFwiXFxuXCIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoY29udGV4dFN5bWJvbCkge1xyXG5cdFx0XHRcdFx0XHRidWYgKz0gKFwiY3R4XFxuXCIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHMuaXNDb250ZXh0U2Vuc2l0aXZlKSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBlbnRyeSBvZiBjb250ZXh0RWRnZUtleXMpIHtcclxuXHRcdFx0XHRcdFx0YnVmICs9ICh0aGlzLmdldFN0YXRlU3RyaW5nKHMpKVxyXG5cdFx0XHRcdFx0XHRcdCsgKFwiLVwiKVxyXG5cdFx0XHRcdFx0XHRcdCsgKHRoaXMuZ2V0Q29udGV4dExhYmVsKGVudHJ5KSlcclxuXHRcdFx0XHRcdFx0XHQrIChcIi0+XCIpXHJcblx0XHRcdFx0XHRcdFx0KyAodGhpcy5nZXRTdGF0ZVN0cmluZyhjb250ZXh0RWRnZXMuZ2V0KGVudHJ5KSEpKVxyXG5cdFx0XHRcdFx0XHRcdCsgKFwiXFxuXCIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0bGV0IG91dHB1dDogc3RyaW5nID0gYnVmO1xyXG5cdFx0aWYgKG91dHB1dC5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHR9XHJcblx0XHQvL3JldHVybiBVdGlscy5zb3J0TGluZXNJblN0cmluZyhvdXRwdXQpO1xyXG5cdFx0cmV0dXJuIG91dHB1dDtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRDb250ZXh0TGFiZWwoaTogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdGlmIChpID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSkge1xyXG5cdFx0XHRyZXR1cm4gXCJjdHg6RU1QVFlfRlVMTFwiO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoaSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfTE9DQUxfU1RBVEVfS0VZKSB7XHJcblx0XHRcdHJldHVybiBcImN0eDpFTVBUWV9MT0NBTFwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmF0biAmJiBpID4gMCAmJiBpIDw9IHRoaXMuYXRuLnN0YXRlcy5sZW5ndGgpIHtcclxuXHRcdFx0bGV0IHN0YXRlOiBBVE5TdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tpXTtcclxuXHRcdFx0bGV0IHJ1bGVJbmRleDogbnVtYmVyID0gc3RhdGUucnVsZUluZGV4O1xyXG5cdFx0XHRpZiAodGhpcy5ydWxlTmFtZXMgJiYgcnVsZUluZGV4ID49IDAgJiYgcnVsZUluZGV4IDwgdGhpcy5ydWxlTmFtZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0dXJuIFwiY3R4OlwiICsgU3RyaW5nKGkpICsgXCIoXCIgKyB0aGlzLnJ1bGVOYW1lc1tydWxlSW5kZXhdICsgXCIpXCI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gXCJjdHg6XCIgKyBTdHJpbmcoaSk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0RWRnZUxhYmVsKGk6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy52b2NhYnVsYXJ5LmdldERpc3BsYXlOYW1lKGkpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldFN0YXRlU3RyaW5nKHM6IERGQVN0YXRlKTogc3RyaW5nIHtcclxuXHRcdGlmIChzID09PSBBVE5TaW11bGF0b3IuRVJST1IpIHtcclxuXHRcdFx0cmV0dXJuIFwiRVJST1JcIjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbjogbnVtYmVyID0gcy5zdGF0ZU51bWJlcjtcclxuXHRcdGxldCBzdGF0ZVN0cjogc3RyaW5nID0gXCJzXCIgKyBuO1xyXG5cdFx0aWYgKHMuaXNBY2NlcHRTdGF0ZSkge1xyXG5cdFx0XHRpZiAocy5wcmVkaWNhdGVzKSB7XHJcblx0XHRcdFx0c3RhdGVTdHIgPSBcIjpzXCIgKyBuICsgXCI9PlwiICsgcy5wcmVkaWNhdGVzO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHN0YXRlU3RyID0gXCI6c1wiICsgbiArIFwiPT5cIiArIHMucHJlZGljdGlvbjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzLmlzQ29udGV4dFNlbnNpdGl2ZSkge1xyXG5cdFx0XHRzdGF0ZVN0ciArPSBcIipcIjtcclxuXHRcdFx0Zm9yIChsZXQgY29uZmlnIG9mIHMuY29uZmlncykge1xyXG5cdFx0XHRcdGlmIChjb25maWcucmVhY2hlc0ludG9PdXRlckNvbnRleHQpIHtcclxuXHRcdFx0XHRcdHN0YXRlU3RyICs9IFwiKlwiO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RhdGVTdHI7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozOS4yMTY3MjM4LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBERkEgfSBmcm9tIFwiLi9ERkFcIjtcclxuaW1wb3J0IHsgREZBU2VyaWFsaXplciB9IGZyb20gXCIuL0RGQVNlcmlhbGl6ZXJcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBWb2NhYnVsYXJ5SW1wbCB9IGZyb20gXCIuLi9Wb2NhYnVsYXJ5SW1wbFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIExleGVyREZBU2VyaWFsaXplciBleHRlbmRzIERGQVNlcmlhbGl6ZXIge1xyXG5cdGNvbnN0cnVjdG9yKCBATm90TnVsbCBkZmE6IERGQSkge1xyXG5cdFx0c3VwZXIoZGZhLCBWb2NhYnVsYXJ5SW1wbC5FTVBUWV9WT0NBQlVMQVJZKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGdldEVkZ2VMYWJlbChpOiBudW1iZXIpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiJ1wiICsgU3RyaW5nLmZyb21Db2RlUG9pbnQoaSkgKyBcIidcIjtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM3LjcwOTkyMDEtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlVHlwZSB9IGZyb20gXCIuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBCaXRTZXQgfSBmcm9tIFwiLi4vbWlzYy9CaXRTZXRcIjtcclxuaW1wb3J0IHsgRGVjaXNpb25TdGF0ZSB9IGZyb20gXCIuL0RlY2lzaW9uU3RhdGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBTdGFyTG9vcGJhY2tTdGF0ZSB9IGZyb20gXCIuL1N0YXJMb29wYmFja1N0YXRlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU3Rhckxvb3BFbnRyeVN0YXRlIGV4dGVuZHMgRGVjaXNpb25TdGF0ZSB7XHJcblx0Ly8gVGhpcyBpcyBhbHdheXMgc2V0IGR1cmluZyBBVE4gZGVzZXJpYWxpemF0aW9uXHJcblx0cHVibGljIGxvb3BCYWNrU3RhdGUhOiBTdGFyTG9vcGJhY2tTdGF0ZTtcclxuXHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBzdGF0ZSBjYW4gYmVuZWZpdCBmcm9tIGEgcHJlY2VkZW5jZSBERkEgZHVyaW5nIFNMTFxyXG5cdCAqIGRlY2lzaW9uIG1ha2luZy5cclxuXHQgKlxyXG5cdCAqIFRoaXMgaXMgYSBjb21wdXRlZCBwcm9wZXJ0eSB0aGF0IGlzIGNhbGN1bGF0ZWQgZHVyaW5nIEFUTiBkZXNlcmlhbGl6YXRpb25cclxuXHQgKiBhbmQgc3RvcmVkIGZvciB1c2UgaW4ge0BsaW5rIFBhcnNlckFUTlNpbXVsYXRvcn0gYW5kXHJcblx0ICoge0BsaW5rIFBhcnNlckludGVycHJldGVyfS5cclxuXHQgKlxyXG5cdCAqIEBzZWUgYERGQS5pc1ByZWNlZGVuY2VEZmFgXHJcblx0ICovXHJcblx0cHVibGljIHByZWNlZGVuY2VSdWxlRGVjaXNpb246IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0LyoqXHJcblx0ICogRm9yIHByZWNlZGVuY2UgZGVjaXNpb25zLCB0aGlzIHNldCBtYXJrcyBzdGF0ZXMgKlMqIHdoaWNoIGhhdmUgYWxsXHJcblx0ICogb2YgdGhlIGZvbGxvd2luZyBjaGFyYWN0ZXJpc3RpY3M6XHJcblx0ICpcclxuXHQgKiAqIE9uZSBvciBtb3JlIGludm9jYXRpb24gc2l0ZXMgb2YgdGhlIGN1cnJlbnQgcnVsZSByZXR1cm5zIHRvXHJcblx0ICogICAqUyouXHJcblx0ICogKiBUaGUgY2xvc3VyZSBmcm9tICpTKiBpbmNsdWRlcyB0aGUgY3VycmVudCBkZWNpc2lvbiB3aXRob3V0XHJcblx0ICogICBwYXNzaW5nIHRocm91Z2ggYW55IHJ1bGUgaW52b2NhdGlvbnMgb3Igc3RlcHBpbmcgb3V0IG9mIHRoZSBjdXJyZW50XHJcblx0ICogICBydWxlLlxyXG5cdCAqXHJcblx0ICogVGhpcyBmaWVsZCBpcyBub3QgdXNlZCB3aGVuIHtAbGluayAjcHJlY2VkZW5jZVJ1bGVEZWNpc2lvbn0gaXNcclxuXHQgKiBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBwcmVjZWRlbmNlTG9vcGJhY2tTdGF0ZXM6IEJpdFNldCA9IG5ldyBCaXRTZXQoKTtcclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHN0YXRlVHlwZSgpOiBBVE5TdGF0ZVR5cGUge1xyXG5cdFx0cmV0dXJuIEFUTlN0YXRlVHlwZS5TVEFSX0xPT1BfRU5UUlk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozOC4zNTY3MDk0LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBcnJheTJESGFzaFNldCB9IGZyb20gXCIuLi9taXNjL0FycmF5MkRIYXNoU2V0XCI7XHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuLi9hdG4vQVROXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuLi9hdG4vQVROQ29uZmlnU2V0XCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4uL2F0bi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBBVE5UeXBlIH0gZnJvbSBcIi4uL2F0bi9BVE5UeXBlXCI7XHJcbmltcG9ydCB7IERlY2lzaW9uU3RhdGUgfSBmcm9tIFwiLi4vYXRuL0RlY2lzaW9uU3RhdGVcIjtcclxuaW1wb3J0IHsgREZBU2VyaWFsaXplciB9IGZyb20gXCIuL0RGQVNlcmlhbGl6ZXJcIjtcclxuaW1wb3J0IHsgREZBU3RhdGUgfSBmcm9tIFwiLi9ERkFTdGF0ZVwiO1xyXG5pbXBvcnQgeyBMZXhlckFUTlNpbXVsYXRvciB9IGZyb20gXCIuLi9hdG4vTGV4ZXJBVE5TaW11bGF0b3JcIjtcclxuaW1wb3J0IHsgTGV4ZXJERkFTZXJpYWxpemVyIH0gZnJvbSBcIi4vTGV4ZXJERkFTZXJpYWxpemVyXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi4vbWlzYy9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgU3Rhckxvb3BFbnRyeVN0YXRlIH0gZnJvbSBcIi4uL2F0bi9TdGFyTG9vcEVudHJ5U3RhdGVcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5zU3RhcnRTdGF0ZSB9IGZyb20gXCIuLi9hdG4vVG9rZW5zU3RhcnRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBWb2NhYnVsYXJ5IH0gZnJvbSBcIi4uL1ZvY2FidWxhcnlcIjtcclxuaW1wb3J0IHsgVm9jYWJ1bGFyeUltcGwgfSBmcm9tIFwiLi4vVm9jYWJ1bGFyeUltcGxcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBERkEge1xyXG5cdC8qKlxyXG5cdCAqIEEgc2V0IG9mIGFsbCBzdGF0ZXMgaW4gdGhlIGBERkFgLlxyXG5cdCAqXHJcblx0ICogTm90ZSB0aGF0IHRoaXMgY29sbGVjdGlvbiBvZiBzdGF0ZXMgaG9sZHMgdGhlIERGQSBzdGF0ZXMgZm9yIGJvdGggU0xMIGFuZCBMTCBwcmVkaWN0aW9uLiBPbmx5IHRoZSBzdGFydCBzdGF0ZVxyXG5cdCAqIG5lZWRzIHRvIGJlIGRpZmZlcmVudGlhdGVkIGZvciB0aGVzZSBjYXNlcywgd2hpY2ggaXMgdHJhY2tlZCBieSB0aGUgYHMwYCBhbmQgYHMwZnVsbGAgZmllbGRzLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHJlYWRvbmx5IHN0YXRlczogQXJyYXkyREhhc2hTZXQ8REZBU3RhdGU+ID0gbmV3IEFycmF5MkRIYXNoU2V0PERGQVN0YXRlPihPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xyXG5cclxuXHRwdWJsaWMgczA6IERGQVN0YXRlIHwgdW5kZWZpbmVkO1xyXG5cclxuXHRwdWJsaWMgczBmdWxsOiBERkFTdGF0ZSB8IHVuZGVmaW5lZDtcclxuXHJcblx0cHVibGljIHJlYWRvbmx5IGRlY2lzaW9uOiBudW1iZXI7XHJcblxyXG5cdC8qKiBGcm9tIHdoaWNoIEFUTiBzdGF0ZSBkaWQgd2UgY3JlYXRlIHRoaXMgREZBPyAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGF0blN0YXJ0U3RhdGU6IEFUTlN0YXRlO1xyXG5cdC8qKlxyXG5cdCAqIE5vdGU6IHRoaXMgZmllbGQgaXMgYWNjZXNzZWQgYXMgYGF0blN0YXJ0U3RhdGUuYXRuYCBpbiBvdGhlciB0YXJnZXRzLiBUaGUgVHlwZVNjcmlwdCB0YXJnZXQga2VlcHMgYSBzZXBhcmF0ZSBjb3B5XHJcblx0ICogdG8gYXZvaWQgYSBudW1iZXIgb2YgYWRkaXRpb25hbCBudWxsL3VuZGVmaW5lZCBjaGVja3MgZWFjaCB0aW1lIHRoZSBBVE4gaXMgYWNjZXNzZWQuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgYXRuOiBBVE47XHJcblxyXG5cdHByaXZhdGUgbmV4dFN0YXRlTnVtYmVyOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBgdHJ1ZWAgaWYgdGhpcyBERkEgaXMgZm9yIGEgcHJlY2VkZW5jZSBkZWNpc2lvbjsgb3RoZXJ3aXNlLFxyXG5cdCAqIGBmYWxzZWAuIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIHtAbGluayAjaXNQcmVjZWRlbmNlRGZhfS5cclxuXHQgKi9cclxuXHRwcml2YXRlIHByZWNlZGVuY2VEZmE6IGJvb2xlYW47XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBgREZBYCBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggYSBsZXhlciBtb2RlLlxyXG5cdCAqXHJcblx0ICogVGhlIHN0YXJ0IHN0YXRlIGZvciBhIGBERkFgIGNvbnN0cnVjdGVkIHdpdGggdGhpcyBjb25zdHJ1Y3RvciBzaG91bGQgYmUgYSBgVG9rZW5zU3RhcnRTdGF0ZWAsIHdoaWNoIGlzIHRoZSBzdGFydFxyXG5cdCAqIHN0YXRlIGZvciBhIGxleGVyIG1vZGUuIFRoZSBwcmVkaWN0aW9uIG1hZGUgYnkgdGhpcyBERkEgZGV0ZXJtaW5lcyB0aGUgbGV4ZXIgcnVsZSB3aGljaCBtYXRjaGVzIHRoZSBjdXJyZW50XHJcblx0ICogaW5wdXQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gYXRuU3RhcnRTdGF0ZSBUaGUgc3RhcnQgc3RhdGUgZm9yIHRoZSBtb2RlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGF0blN0YXJ0U3RhdGU6IFRva2Vuc1N0YXJ0U3RhdGUpO1xyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBgREZBYCBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggYSBkZWNpc2lvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBhdG5TdGFydFN0YXRlIFRoZSBkZWNpc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBERkEuXHJcblx0ICogQHBhcmFtIGRlY2lzaW9uIFRoZSBkZWNpc2lvbiBudW1iZXIuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoYXRuU3RhcnRTdGF0ZTogRGVjaXNpb25TdGF0ZSwgZGVjaXNpb246IG51bWJlcik7XHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgYXRuU3RhcnRTdGF0ZTogQVROU3RhdGUsIGRlY2lzaW9uOiBudW1iZXIgPSAwKSB7XHJcblx0XHRpZiAoIWF0blN0YXJ0U3RhdGUuYXRuKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSBBVE5TdGF0ZSBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBhbiBBVE5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hdG5TdGFydFN0YXRlID0gYXRuU3RhcnRTdGF0ZTtcclxuXHRcdHRoaXMuYXRuID0gYXRuU3RhcnRTdGF0ZS5hdG47XHJcblx0XHR0aGlzLmRlY2lzaW9uID0gZGVjaXNpb247XHJcblxyXG5cdFx0Ly8gUHJlY2VkZW5jZSBERkFzIGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpYWwgcHJlY2VkZW5jZSBkZWNpc2lvbiBjcmVhdGVkIGZvciBsZWZ0LXJlY3Vyc2l2ZSBydWxlcyB3aGljaFxyXG5cdFx0Ly8gZXZhbHVhdGUgdGhlaXIgYWx0ZXJuYXRpdmVzIHVzaW5nIGEgcHJlY2VkZW5jZSBoaWVyYXJjaHkuIFdoZW4gc3VjaCBhIGRlY2lzaW9uIGlzIGVuY291bnRlcmVkLCB3ZSBtYXJrIHRoaXNcclxuXHRcdC8vIERGQSBpbnN0YW5jZSBhcyBhIHByZWNlZGVuY2UgREZBIGFuZCBpbml0aWFsaXplIHRoZSBpbml0aWFsIHN0YXRlcyBzMCBhbmQgczBmdWxsIHRvIHNwZWNpYWwgREZBU3RhdGVcclxuXHRcdC8vIGluc3RhbmNlcyB3aGljaCB1c2Ugb3V0Z29pbmcgZWRnZXMgdG8gbGluayB0byB0aGUgYWN0dWFsIHN0YXJ0IHN0YXRlIHVzZWQgZm9yIGVhY2ggcHJlY2VkZW5jZSBsZXZlbC5cclxuXHRcdGxldCBpc1ByZWNlZGVuY2VEZmE6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdGlmIChhdG5TdGFydFN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKSB7XHJcblx0XHRcdGlmIChhdG5TdGFydFN0YXRlLnByZWNlZGVuY2VSdWxlRGVjaXNpb24pIHtcclxuXHRcdFx0XHRpc1ByZWNlZGVuY2VEZmEgPSB0cnVlO1xyXG5cdFx0XHRcdHRoaXMuczAgPSBuZXcgREZBU3RhdGUobmV3IEFUTkNvbmZpZ1NldCgpKTtcclxuXHRcdFx0XHR0aGlzLnMwZnVsbCA9IG5ldyBERkFTdGF0ZShuZXcgQVROQ29uZmlnU2V0KCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5wcmVjZWRlbmNlRGZhID0gaXNQcmVjZWRlbmNlRGZhO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB3aGV0aGVyIHRoaXMgREZBIGlzIGEgcHJlY2VkZW5jZSBERkEuIFByZWNlZGVuY2UgREZBcyB1c2UgYSBzcGVjaWFsXHJcblx0ICogc3RhcnQgc3RhdGUge0BsaW5rICNzMH0gd2hpY2ggaXMgbm90IHN0b3JlZCBpbiB7QGxpbmsgI3N0YXRlc30uIFRoZVxyXG5cdCAqIHtAbGluayBERkFTdGF0ZSNlZGdlc30gYXJyYXkgZm9yIHRoaXMgc3RhcnQgc3RhdGUgY29udGFpbnMgb3V0Z29pbmcgZWRnZXNcclxuXHQgKiBzdXBwbHlpbmcgaW5kaXZpZHVhbCBzdGFydCBzdGF0ZXMgY29ycmVzcG9uZGluZyB0byBzcGVjaWZpYyBwcmVjZWRlbmNlXHJcblx0ICogdmFsdWVzLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIHRoaXMgaXMgYSBwcmVjZWRlbmNlIERGQTsgb3RoZXJ3aXNlLFxyXG5cdCAqIGBmYWxzZWAuXHJcblx0ICogQHNlZSBQYXJzZXIucHJlY2VkZW5jZVxyXG5cdCAqL1xyXG5cdGdldCBpc1ByZWNlZGVuY2VEZmEoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcmVjZWRlbmNlRGZhO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBzdGFydCBzdGF0ZSBmb3IgYSBzcGVjaWZpYyBwcmVjZWRlbmNlIHZhbHVlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHByZWNlZGVuY2UgVGhlIGN1cnJlbnQgcHJlY2VkZW5jZS5cclxuXHQgKiBAcmV0dXJucyBUaGUgc3RhcnQgc3RhdGUgY29ycmVzcG9uZGluZyB0byB0aGUgc3BlY2lmaWVkIHByZWNlZGVuY2UsIG9yXHJcblx0ICogYHVuZGVmaW5lZGAgaWYgbm8gc3RhcnQgc3RhdGUgZXhpc3RzIGZvciB0aGUgc3BlY2lmaWVkIHByZWNlZGVuY2UuXHJcblx0ICpcclxuXHQgKiBAIGlmIHRoaXMgaXMgbm90IGEgcHJlY2VkZW5jZSBERkEuXHJcblx0ICogQHNlZSBgaXNQcmVjZWRlbmNlRGZhYFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRQcmVjZWRlbmNlU3RhcnRTdGF0ZShwcmVjZWRlbmNlOiBudW1iZXIsIGZ1bGxDb250ZXh0OiBib29sZWFuKTogREZBU3RhdGUgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKCF0aGlzLmlzUHJlY2VkZW5jZURmYSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHByZWNlZGVuY2UgREZBcyBtYXkgY29udGFpbiBhIHByZWNlZGVuY2Ugc3RhcnQgc3RhdGUuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHMwIGFuZCBzMGZ1bGwgYXJlIG5ldmVyIG51bGwgZm9yIGEgcHJlY2VkZW5jZSBERkFcclxuXHRcdGlmIChmdWxsQ29udGV4dCkge1xyXG5cdFx0XHRyZXR1cm4gKHRoaXMuczBmdWxsIGFzIERGQVN0YXRlKS5nZXRUYXJnZXQocHJlY2VkZW5jZSk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0cmV0dXJuICh0aGlzLnMwIGFzIERGQVN0YXRlKS5nZXRUYXJnZXQocHJlY2VkZW5jZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIHN0YXJ0IHN0YXRlIGZvciBhIHNwZWNpZmljIHByZWNlZGVuY2UgdmFsdWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcHJlY2VkZW5jZSBUaGUgY3VycmVudCBwcmVjZWRlbmNlLlxyXG5cdCAqIEBwYXJhbSBzdGFydFN0YXRlIFRoZSBzdGFydCBzdGF0ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzcGVjaWZpZWRcclxuXHQgKiBwcmVjZWRlbmNlLlxyXG5cdCAqXHJcblx0ICogQCBpZiB0aGlzIGlzIG5vdCBhIHByZWNlZGVuY2UgREZBLlxyXG5cdCAqIEBzZWUgYGlzUHJlY2VkZW5jZURmYWBcclxuXHQgKi9cclxuXHRwdWJsaWMgc2V0UHJlY2VkZW5jZVN0YXJ0U3RhdGUocHJlY2VkZW5jZTogbnVtYmVyLCBmdWxsQ29udGV4dDogYm9vbGVhbiwgc3RhcnRTdGF0ZTogREZBU3RhdGUpOiB2b2lkIHtcclxuXHRcdGlmICghdGhpcy5pc1ByZWNlZGVuY2VEZmEpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiT25seSBwcmVjZWRlbmNlIERGQXMgbWF5IGNvbnRhaW4gYSBwcmVjZWRlbmNlIHN0YXJ0IHN0YXRlLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJlY2VkZW5jZSA8IDApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChmdWxsQ29udGV4dCkge1xyXG5cdFx0XHQvLyBzMGZ1bGwgaXMgbmV2ZXIgbnVsbCBmb3IgYSBwcmVjZWRlbmNlIERGQVxyXG5cdFx0XHQodGhpcy5zMGZ1bGwgYXMgREZBU3RhdGUpLnNldFRhcmdldChwcmVjZWRlbmNlLCBzdGFydFN0YXRlKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHQvLyBzMCBpcyBuZXZlciBudWxsIGZvciBhIHByZWNlZGVuY2UgREZBXHJcblx0XHRcdCh0aGlzLnMwIGFzIERGQVN0YXRlKS5zZXRUYXJnZXQocHJlY2VkZW5jZSwgc3RhcnRTdGF0ZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLmlzUHJlY2VkZW5jZURmYSkge1xyXG5cdFx0XHQvLyBzMCBhbmQgczBmdWxsIGFyZSBuZXZlciBudWxsIGZvciBhIHByZWNlZGVuY2UgREZBXHJcblx0XHRcdHJldHVybiB0aGlzLnMwIS5nZXRFZGdlTWFwKCkuc2l6ZSA9PT0gMCAmJiB0aGlzLnMwZnVsbCEuZ2V0RWRnZU1hcCgpLnNpemUgPT09IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuczAgPT0gbnVsbCAmJiB0aGlzLnMwZnVsbCA9PSBudWxsO1xyXG5cdH1cclxuXHJcblx0Z2V0IGlzQ29udGV4dFNlbnNpdGl2ZSgpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLmlzUHJlY2VkZW5jZURmYSkge1xyXG5cdFx0XHQvLyBzMGZ1bGwgaXMgbmV2ZXIgbnVsbCBmb3IgYSBwcmVjZWRlbmNlIERGQVxyXG5cdFx0XHRyZXR1cm4gKHRoaXMuczBmdWxsIGFzIERGQVN0YXRlKS5nZXRFZGdlTWFwKCkuc2l6ZSA+IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuczBmdWxsICE9IG51bGw7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWRkU3RhdGUoc3RhdGU6IERGQVN0YXRlKTogREZBU3RhdGUge1xyXG5cdFx0c3RhdGUuc3RhdGVOdW1iZXIgPSB0aGlzLm5leHRTdGF0ZU51bWJlcisrO1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhdGVzLmdldE9yQWRkKHN0YXRlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmc7XHJcblx0cHVibGljIHRvU3RyaW5nKC8qQE5vdE51bGwqLyB2b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5KTogc3RyaW5nO1xyXG5cdHB1YmxpYyB0b1N0cmluZygvKkBOb3ROdWxsKi8gdm9jYWJ1bGFyeTogVm9jYWJ1bGFyeSwgcnVsZU5hbWVzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCk6IHN0cmluZztcclxuXHRwdWJsaWMgdG9TdHJpbmcodm9jYWJ1bGFyeT86IFZvY2FidWxhcnksIHJ1bGVOYW1lcz86IHN0cmluZ1tdKTogc3RyaW5nIHtcclxuXHRcdGlmICghdm9jYWJ1bGFyeSkge1xyXG5cdFx0XHR2b2NhYnVsYXJ5ID0gVm9jYWJ1bGFyeUltcGwuRU1QVFlfVk9DQUJVTEFSWTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuczApIHtcclxuXHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHNlcmlhbGl6ZXI6IERGQVNlcmlhbGl6ZXI7XHJcblx0XHRpZiAocnVsZU5hbWVzKSB7XHJcblx0XHRcdHNlcmlhbGl6ZXIgPSBuZXcgREZBU2VyaWFsaXplcih0aGlzLCB2b2NhYnVsYXJ5LCBydWxlTmFtZXMsIHRoaXMuYXRuU3RhcnRTdGF0ZS5hdG4pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c2VyaWFsaXplciA9IG5ldyBERkFTZXJpYWxpemVyKHRoaXMsIHZvY2FidWxhcnkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzZXJpYWxpemVyLnRvU3RyaW5nKCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdG9MZXhlclN0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0aWYgKCF0aGlzLnMwKSB7XHJcblx0XHRcdHJldHVybiBcIlwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBzZXJpYWxpemVyOiBERkFTZXJpYWxpemVyID0gbmV3IExleGVyREZBU2VyaWFsaXplcih0aGlzKTtcclxuXHRcdHJldHVybiBzZXJpYWxpemVyLnRvU3RyaW5nKCk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyNy44Mzg5OTMwLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlVHlwZSB9IGZyb20gXCIuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJhc2ljU3RhdGUgZXh0ZW5kcyBBVE5TdGF0ZSB7XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdGF0ZVR5cGUoKTogQVROU3RhdGVUeXBlIHtcclxuXHRcdHJldHVybiBBVE5TdGF0ZVR5cGUuQkFTSUM7XHJcblx0fVxyXG5cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlVHlwZSB9IGZyb20gXCIuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBCYXNpY1N0YXRlIH0gZnJvbSBcIi4vQmFzaWNTdGF0ZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEludmFsaWRTdGF0ZSBleHRlbmRzIEJhc2ljU3RhdGUge1xyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhdGVUeXBlKCk6IEFUTlN0YXRlVHlwZSB7XHJcblx0XHRyZXR1cm4gQVROU3RhdGVUeXBlLklOVkFMSURfVFlQRTtcclxuXHR9XHJcblxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNy4zMDYwMTM1LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEludGVydmFsU2V0IH0gZnJvbSBcIi4uL21pc2MvSW50ZXJ2YWxTZXRcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUsIE5vdE51bGwsIE51bGxhYmxlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCIuL1RyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvblR5cGUgfSBmcm9tIFwiLi9UcmFuc2l0aW9uVHlwZVwiO1xyXG5cclxuLyoqIEEgdHJhbnNpdGlvbiBjb250YWluaW5nIGEgc2V0IG9mIHZhbHVlcy4gKi9cclxuZXhwb3J0IGNsYXNzIFNldFRyYW5zaXRpb24gZXh0ZW5kcyBUcmFuc2l0aW9uIHtcclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBzZXQ6IEludGVydmFsU2V0O1xyXG5cclxuXHQvLyBUT0RPIChzYW0pOiBzaG91bGQgd2UgcmVhbGx5IGFsbG93IHVuZGVmaW5lZCBoZXJlP1xyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHRhcmdldDogQVROU3RhdGUsIEBOdWxsYWJsZSBzZXQ6IEludGVydmFsU2V0KSB7XHJcblx0XHRzdXBlcih0YXJnZXQpO1xyXG5cdFx0aWYgKHNldCA9PSBudWxsKSB7XHJcblx0XHRcdHNldCA9IEludGVydmFsU2V0Lm9mKFRva2VuLklOVkFMSURfVFlQRSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXQgPSBzZXQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2VyaWFsaXphdGlvblR5cGUoKTogVHJhbnNpdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIFRyYW5zaXRpb25UeXBlLlNFVDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGxhYmVsKCk6IEludGVydmFsU2V0IHtcclxuXHRcdHJldHVybiB0aGlzLnNldDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBtYXRjaGVzKHN5bWJvbDogbnVtYmVyLCBtaW5Wb2NhYlN5bWJvbDogbnVtYmVyLCBtYXhWb2NhYlN5bWJvbDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXQuY29udGFpbnMoc3ltYm9sKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXQudG9TdHJpbmcoKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjMwLjg0ODM2MTctMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWxTZXQgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFNldFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSwgTm90TnVsbCwgTnVsbGFibGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBTZXRUcmFuc2l0aW9uIH0gZnJvbSBcIi4vU2V0VHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgTm90U2V0VHJhbnNpdGlvbiBleHRlbmRzIFNldFRyYW5zaXRpb24ge1xyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHRhcmdldDogQVROU3RhdGUsIEBOdWxsYWJsZSBzZXQ6IEludGVydmFsU2V0KSB7XHJcblx0XHRzdXBlcih0YXJnZXQsIHNldCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2VyaWFsaXphdGlvblR5cGUoKTogVHJhbnNpdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIFRyYW5zaXRpb25UeXBlLk5PVF9TRVQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgbWF0Y2hlcyhzeW1ib2w6IG51bWJlciwgbWluVm9jYWJTeW1ib2w6IG51bWJlciwgbWF4Vm9jYWJTeW1ib2w6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHN5bWJvbCA+PSBtaW5Wb2NhYlN5bWJvbFxyXG5cdFx0XHQmJiBzeW1ib2wgPD0gbWF4Vm9jYWJTeW1ib2xcclxuXHRcdFx0JiYgIXN1cGVyLm1hdGNoZXMoc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgbWF4Vm9jYWJTeW1ib2wpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCJ+XCIgKyBzdXBlci50b1N0cmluZygpO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzYuNzUxMzg1Ni0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZVR5cGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVR5cGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqIFRoZSBsYXN0IG5vZGUgaW4gdGhlIEFUTiBmb3IgYSBydWxlLCB1bmxlc3MgdGhhdCBydWxlIGlzIHRoZSBzdGFydCBzeW1ib2wuXHJcbiAqICBJbiB0aGF0IGNhc2UsIHRoZXJlIGlzIG9uZSB0cmFuc2l0aW9uIHRvIEVPRi4gTGF0ZXIsIHdlIG1pZ2h0IGVuY29kZVxyXG4gKiAgcmVmZXJlbmNlcyB0byBhbGwgY2FsbHMgdG8gdGhpcyBydWxlIHRvIGNvbXB1dGUgRk9MTE9XIHNldHMgZm9yXHJcbiAqICBlcnJvciBoYW5kbGluZy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlU3RvcFN0YXRlIGV4dGVuZHMgQVROU3RhdGUge1xyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgbm9uU3RvcFN0YXRlTnVtYmVyKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhdGVUeXBlKCk6IEFUTlN0YXRlVHlwZSB7XHJcblx0XHRyZXR1cm4gQVROU3RhdGVUeXBlLlJVTEVfU1RPUDtcclxuXHR9XHJcblxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNi44Mjk0NDUzLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlLCBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUnVsZVN0YXJ0U3RhdGUgfSBmcm9tIFwiLi9SdWxlU3RhcnRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcblxyXG4vKiogKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVUcmFuc2l0aW9uIGV4dGVuZHMgVHJhbnNpdGlvbiB7XHJcblx0LyoqIFB0ciB0byB0aGUgcnVsZSBkZWZpbml0aW9uIG9iamVjdCBmb3IgdGhpcyBydWxlIHJlZiAqL1xyXG5cdHB1YmxpYyBydWxlSW5kZXg6IG51bWJlcjsgICAgICAvLyBubyBSdWxlIG9iamVjdCBhdCBydW50aW1lXHJcblxyXG5cdHB1YmxpYyBwcmVjZWRlbmNlOiBudW1iZXI7XHJcblxyXG5cdC8qKiBXaGF0IG5vZGUgdG8gYmVnaW4gY29tcHV0YXRpb25zIGZvbGxvd2luZyByZWYgdG8gcnVsZSAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGZvbGxvd1N0YXRlOiBBVE5TdGF0ZTtcclxuXHJcblx0cHVibGljIHRhaWxDYWxsOiBib29sZWFuID0gZmFsc2U7XHJcblx0cHVibGljIG9wdGltaXplZFRhaWxDYWxsOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHJ1bGVTdGFydDogUnVsZVN0YXJ0U3RhdGUsIHJ1bGVJbmRleDogbnVtYmVyLCBwcmVjZWRlbmNlOiBudW1iZXIsIEBOb3ROdWxsIGZvbGxvd1N0YXRlOiBBVE5TdGF0ZSkge1xyXG5cdFx0c3VwZXIocnVsZVN0YXJ0KTtcclxuXHRcdHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4O1xyXG5cdFx0dGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcclxuXHRcdHRoaXMuZm9sbG93U3RhdGUgPSBmb2xsb3dTdGF0ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzZXJpYWxpemF0aW9uVHlwZSgpOiBUcmFuc2l0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gVHJhbnNpdGlvblR5cGUuUlVMRTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc0Vwc2lsb24oKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBtYXRjaGVzKHN5bWJvbDogbnVtYmVyLCBtaW5Wb2NhYlN5bWJvbDogbnVtYmVyLCBtYXhWb2NhYlN5bWJvbDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNy45NDU2ODM5LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlLCBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCIuL1RyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvblR5cGUgfSBmcm9tIFwiLi9UcmFuc2l0aW9uVHlwZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFdpbGRjYXJkVHJhbnNpdGlvbiBleHRlbmRzIFRyYW5zaXRpb24ge1xyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHRhcmdldDogQVROU3RhdGUpIHtcclxuXHRcdHN1cGVyKHRhcmdldCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2VyaWFsaXphdGlvblR5cGUoKTogVHJhbnNpdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIFRyYW5zaXRpb25UeXBlLldJTERDQVJEO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG1hdGNoZXMoc3ltYm9sOiBudW1iZXIsIG1pblZvY2FiU3ltYm9sOiBudW1iZXIsIG1heFZvY2FiU3ltYm9sOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBzeW1ib2wgPj0gbWluVm9jYWJTeW1ib2wgJiYgc3ltYm9sIDw9IG1heFZvY2FiU3ltYm9sO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIi5cIjtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjMwLjQ0NDUzNjAtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbiB9IGZyb20gXCIuL0Fic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBBcnJheTJESGFzaFNldCB9IGZyb20gXCIuLi9taXNjL0FycmF5MkRIYXNoU2V0XCI7XHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5Db25maWcgfSBmcm9tIFwiLi9BVE5Db25maWdcIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBCaXRTZXQgfSBmcm9tIFwiLi4vbWlzYy9CaXRTZXRcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWxTZXQgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFNldFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgTm90U2V0VHJhbnNpdGlvbiB9IGZyb20gXCIuL05vdFNldFRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IFByZWRpY3Rpb25Db250ZXh0IH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRcIjtcclxuaW1wb3J0IHsgUnVsZVN0b3BTdGF0ZSB9IGZyb20gXCIuL1J1bGVTdG9wU3RhdGVcIjtcclxuaW1wb3J0IHsgUnVsZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9SdWxlVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBTZXRUcmFuc2l0aW9uIH0gZnJvbSBcIi4vU2V0VHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBXaWxkY2FyZFRyYW5zaXRpb24gfSBmcm9tIFwiLi9XaWxkY2FyZFRyYW5zaXRpb25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBMTDFBbmFseXplciB7XHJcblx0LyoqIFNwZWNpYWwgdmFsdWUgYWRkZWQgdG8gdGhlIGxvb2thaGVhZCBzZXRzIHRvIGluZGljYXRlIHRoYXQgd2UgaGl0XHJcblx0ICogIGEgcHJlZGljYXRlIGR1cmluZyBhbmFseXNpcyBpZiBgc2VlVGhydVByZWRzPT1mYWxzZWAuXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBISVRfUFJFRDogbnVtYmVyID0gVG9rZW4uSU5WQUxJRF9UWVBFO1xyXG5cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBhdG46IEFUTjtcclxuXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgYXRuOiBBVE4pIHsgdGhpcy5hdG4gPSBhdG47IH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2FsY3VsYXRlcyB0aGUgU0xMKDEpIGV4cGVjdGVkIGxvb2thaGVhZCBzZXQgZm9yIGVhY2ggb3V0Z29pbmcgdHJhbnNpdGlvblxyXG5cdCAqIG9mIGFuIHtAbGluayBBVE5TdGF0ZX0uIFRoZSByZXR1cm5lZCBhcnJheSBoYXMgb25lIGVsZW1lbnQgZm9yIGVhY2hcclxuXHQgKiBvdXRnb2luZyB0cmFuc2l0aW9uIGluIGBzYC4gSWYgdGhlIGNsb3N1cmUgZnJvbSB0cmFuc2l0aW9uXHJcblx0ICogKmkqIGxlYWRzIHRvIGEgc2VtYW50aWMgcHJlZGljYXRlIGJlZm9yZSBtYXRjaGluZyBhIHN5bWJvbCwgdGhlXHJcblx0ICogZWxlbWVudCBhdCBpbmRleCAqaSogb2YgdGhlIHJlc3VsdCB3aWxsIGJlIGB1bmRlZmluZWRgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHMgdGhlIEFUTiBzdGF0ZVxyXG5cdCAqIEByZXR1cm5zIHRoZSBleHBlY3RlZCBzeW1ib2xzIGZvciBlYWNoIG91dGdvaW5nIHRyYW5zaXRpb24gb2YgYHNgLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXREZWNpc2lvbkxvb2thaGVhZChzOiBBVE5TdGF0ZSB8IHVuZGVmaW5lZCk6IEFycmF5PEludGVydmFsU2V0IHwgdW5kZWZpbmVkPiB8IHVuZGVmaW5lZCB7XHJcbi8vXHRcdFN5c3RlbS5vdXQucHJpbnRsbihcIkxPT0soXCIrcy5zdGF0ZU51bWJlcitcIilcIik7XHJcblx0XHRpZiAocyA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGxvb2s6IEFycmF5PEludGVydmFsU2V0IHwgdW5kZWZpbmVkPiA9IG5ldyBBcnJheTxJbnRlcnZhbFNldD4ocy5udW1iZXJPZlRyYW5zaXRpb25zKTtcclxuXHRcdGZvciAobGV0IGFsdCA9IDA7IGFsdCA8IHMubnVtYmVyT2ZUcmFuc2l0aW9uczsgYWx0KyspIHtcclxuXHRcdFx0bGV0IGN1cnJlbnQ6IEludGVydmFsU2V0IHwgdW5kZWZpbmVkID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHRcdGxvb2tbYWx0XSA9IGN1cnJlbnQ7XHJcblx0XHRcdGxldCBsb29rQnVzeTogQXJyYXkyREhhc2hTZXQ8QVROQ29uZmlnPiA9IG5ldyBBcnJheTJESGFzaFNldDxBVE5Db25maWc+KE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSk7XHJcblx0XHRcdGxldCBzZWVUaHJ1UHJlZHM6IGJvb2xlYW4gPSBmYWxzZTsgLy8gZmFpbCB0byBnZXQgbG9va2FoZWFkIHVwb24gcHJlZFxyXG5cdFx0XHR0aGlzLl9MT09LKHMudHJhbnNpdGlvbihhbHQpLnRhcmdldCwgdW5kZWZpbmVkLCBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9MT0NBTCxcclxuXHRcdFx0XHRjdXJyZW50LCBsb29rQnVzeSwgbmV3IEJpdFNldCgpLCBzZWVUaHJ1UHJlZHMsIGZhbHNlKTtcclxuXHRcdFx0Ly8gV2lwZSBvdXQgbG9va2FoZWFkIGZvciB0aGlzIGFsdGVybmF0aXZlIGlmIHdlIGZvdW5kIG5vdGhpbmdcclxuXHRcdFx0Ly8gb3Igd2UgaGFkIGEgcHJlZGljYXRlIHdoZW4gd2UgIXNlZVRocnVQcmVkc1xyXG5cdFx0XHRpZiAoY3VycmVudC5zaXplID09PSAwIHx8IGN1cnJlbnQuY29udGFpbnMoTEwxQW5hbHl6ZXIuSElUX1BSRUQpKSB7XHJcblx0XHRcdFx0Y3VycmVudCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRsb29rW2FsdF0gPSBjdXJyZW50O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbG9vaztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGUgc2V0IG9mIHRva2VucyB0aGF0IGNhbiBmb2xsb3cgYHNgIGluIHRoZSBBVE4gaW4gdGhlXHJcblx0ICogc3BlY2lmaWVkIGBjdHhgLlxyXG5cdCAqXHJcblx0ICogSWYgYGN0eGAgaXMgYHVuZGVmaW5lZGAgYW5kIHRoZSBlbmQgb2YgdGhlIHJ1bGUgY29udGFpbmluZ1xyXG5cdCAqIGBzYCBpcyByZWFjaGVkLCB7QGxpbmsgVG9rZW4jRVBTSUxPTn0gaXMgYWRkZWQgdG8gdGhlIHJlc3VsdCBzZXQuXHJcblx0ICogSWYgYGN0eGAgaXMgbm90IGB1bmRlZmluZWRgIGFuZCB0aGUgZW5kIG9mIHRoZSBvdXRlcm1vc3QgcnVsZSBpc1xyXG5cdCAqIHJlYWNoZWQsIHtAbGluayBUb2tlbiNFT0Z9IGlzIGFkZGVkIHRvIHRoZSByZXN1bHQgc2V0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHMgdGhlIEFUTiBzdGF0ZVxyXG5cdCAqIEBwYXJhbSBjdHggdGhlIGNvbXBsZXRlIHBhcnNlciBjb250ZXh0LCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgY29udGV4dFxyXG5cdCAqIHNob3VsZCBiZSBpZ25vcmVkXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgc2V0IG9mIHRva2VucyB0aGF0IGNhbiBmb2xsb3cgYHNgIGluIHRoZSBBVE4gaW4gdGhlXHJcblx0ICogc3BlY2lmaWVkIGBjdHhgLlxyXG5cdCAqL1xyXG5cdC8vIEBOb3ROdWxsXHJcblx0cHVibGljIExPT0soLypATm90TnVsbCovIHM6IEFUTlN0YXRlLCAvKkBOb3ROdWxsKi8gY3R4OiBQcmVkaWN0aW9uQ29udGV4dCk6IEludGVydmFsU2V0O1xyXG5cclxuXHQvKipcclxuXHQgKiBDb21wdXRlIHNldCBvZiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IGBzYCBpbiB0aGUgQVROIGluIHRoZVxyXG5cdCAqIHNwZWNpZmllZCBgY3R4YC5cclxuXHQgKlxyXG5cdCAqIElmIGBjdHhgIGlzIGB1bmRlZmluZWRgIGFuZCB0aGUgZW5kIG9mIHRoZSBydWxlIGNvbnRhaW5pbmdcclxuXHQgKiBgc2AgaXMgcmVhY2hlZCwge0BsaW5rIFRva2VuI0VQU0lMT059IGlzIGFkZGVkIHRvIHRoZSByZXN1bHQgc2V0LlxyXG5cdCAqIElmIGBjdHhgIGlzIG5vdCBgUHJlZGljdGlvbkNvbnRleHQjRU1QVFlfTE9DQUxgIGFuZCB0aGUgZW5kIG9mIHRoZSBvdXRlcm1vc3QgcnVsZSBpc1xyXG5cdCAqIHJlYWNoZWQsIHtAbGluayBUb2tlbiNFT0Z9IGlzIGFkZGVkIHRvIHRoZSByZXN1bHQgc2V0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHMgdGhlIEFUTiBzdGF0ZVxyXG5cdCAqIEBwYXJhbSBzdG9wU3RhdGUgdGhlIEFUTiBzdGF0ZSB0byBzdG9wIGF0LiBUaGlzIGNhbiBiZSBhXHJcblx0ICoge0BsaW5rIEJsb2NrRW5kU3RhdGV9IHRvIGRldGVjdCBlcHNpbG9uIHBhdGhzIHRocm91Z2ggYSBjbG9zdXJlLlxyXG5cdCAqIEBwYXJhbSBjdHggdGhlIGNvbXBsZXRlIHBhcnNlciBjb250ZXh0LCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgY29udGV4dFxyXG5cdCAqIHNob3VsZCBiZSBpZ25vcmVkXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgc2V0IG9mIHRva2VucyB0aGF0IGNhbiBmb2xsb3cgYHNgIGluIHRoZSBBVE4gaW4gdGhlXHJcblx0ICogc3BlY2lmaWVkIGBjdHhgLlxyXG5cdCAqL1xyXG5cdC8vIEBOb3ROdWxsXHJcblx0cHVibGljIExPT0soLypATm90TnVsbCovIHM6IEFUTlN0YXRlLCAvKkBOb3ROdWxsKi8gY3R4OiBQcmVkaWN0aW9uQ29udGV4dCwgc3RvcFN0YXRlOiBBVE5TdGF0ZSB8IG51bGwpOiBJbnRlcnZhbFNldDtcclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgTE9PSyhATm90TnVsbCBzOiBBVE5TdGF0ZSwgQE5vdE51bGwgY3R4OiBQcmVkaWN0aW9uQ29udGV4dCwgc3RvcFN0YXRlPzogQVROU3RhdGUgfCBudWxsKTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0aWYgKHN0b3BTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGlmIChzLmF0biA9PSBudWxsKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZVwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3RvcFN0YXRlID0gcy5hdG4ucnVsZVRvU3RvcFN0YXRlW3MucnVsZUluZGV4XTtcclxuXHRcdH0gZWxzZSBpZiAoc3RvcFN0YXRlID09PSBudWxsKSB7XHJcblx0XHRcdC8vIFRoaXMgaXMgYW4gZXhwbGljaXQgcmVxdWVzdCB0byBwYXNzIHVuZGVmaW5lZCBhcyB0aGUgc3RvcFN0YXRlIHRvIF9MT09LLiBVc2VkIHRvIGRpc3Rpbmd1aXNoIGFuIG92ZXJsb2FkXHJcblx0XHRcdC8vIGZyb20gdGhlIG1ldGhvZCB3aGljaCBzaW1wbHkgb21pdHMgdGhlIHN0b3BTdGF0ZSBwYXJhbWV0ZXIuXHJcblx0XHRcdHN0b3BTdGF0ZSA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcjogSW50ZXJ2YWxTZXQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdGxldCBzZWVUaHJ1UHJlZHM6IGJvb2xlYW4gPSB0cnVlOyAvLyBpZ25vcmUgcHJlZHM7IGdldCBhbGwgbG9va2FoZWFkXHJcblx0XHRsZXQgYWRkRU9GOiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdHRoaXMuX0xPT0socywgc3RvcFN0YXRlLCBjdHgsIHIsIG5ldyBBcnJheTJESGFzaFNldDxBVE5Db25maWc+KCksIG5ldyBCaXRTZXQoKSwgc2VlVGhydVByZWRzLCBhZGRFT0YpO1xyXG5cdFx0cmV0dXJuIHI7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wdXRlIHNldCBvZiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IGBzYCBpbiB0aGUgQVROIGluIHRoZVxyXG5cdCAqIHNwZWNpZmllZCBgY3R4YC5cclxuXHQgKiA8cC8+XHJcblx0ICogSWYgYGN0eGAgaXMge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0I0VNUFRZX0xPQ0FMfSBhbmRcclxuXHQgKiBgc3RvcFN0YXRlYCBvciB0aGUgZW5kIG9mIHRoZSBydWxlIGNvbnRhaW5pbmcgYHNgIGlzIHJlYWNoZWQsXHJcblx0ICoge0BsaW5rIFRva2VuI0VQU0lMT059IGlzIGFkZGVkIHRvIHRoZSByZXN1bHQgc2V0LiBJZiBgY3R4YCBpcyBub3RcclxuXHQgKiB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHQjRU1QVFlfTE9DQUx9IGFuZCBgYWRkRU9GYCBpcyBgdHJ1ZWBcclxuXHQgKiBhbmQgYHN0b3BTdGF0ZWAgb3IgdGhlIGVuZCBvZiB0aGUgb3V0ZXJtb3N0IHJ1bGUgaXMgcmVhY2hlZCxcclxuXHQgKiB7QGxpbmsgVG9rZW4jRU9GfSBpcyBhZGRlZCB0byB0aGUgcmVzdWx0IHNldC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBzIHRoZSBBVE4gc3RhdGUuXHJcblx0ICogQHBhcmFtIHN0b3BTdGF0ZSB0aGUgQVROIHN0YXRlIHRvIHN0b3AgYXQuIFRoaXMgY2FuIGJlIGFcclxuXHQgKiB7QGxpbmsgQmxvY2tFbmRTdGF0ZX0gdG8gZGV0ZWN0IGVwc2lsb24gcGF0aHMgdGhyb3VnaCBhIGNsb3N1cmUuXHJcblx0ICogQHBhcmFtIGN0eCBUaGUgb3V0ZXIgY29udGV4dCwgb3Ige0BsaW5rIFByZWRpY3Rpb25Db250ZXh0I0VNUFRZX0xPQ0FMfSBpZlxyXG5cdCAqIHRoZSBvdXRlciBjb250ZXh0IHNob3VsZCBub3QgYmUgdXNlZC5cclxuXHQgKiBAcGFyYW0gbG9vayBUaGUgcmVzdWx0IGxvb2thaGVhZCBzZXQuXHJcblx0ICogQHBhcmFtIGxvb2tCdXN5IEEgc2V0IHVzZWQgZm9yIHByZXZlbnRpbmcgZXBzaWxvbiBjbG9zdXJlcyBpbiB0aGUgQVROXHJcblx0ICogZnJvbSBjYXVzaW5nIGEgc3RhY2sgb3ZlcmZsb3cuIE91dHNpZGUgY29kZSBzaG91bGQgcGFzc1xyXG5cdCAqIGBuZXcgSGFzaFNldDxBVE5Db25maWc+YCBmb3IgdGhpcyBhcmd1bWVudC5cclxuXHQgKiBAcGFyYW0gY2FsbGVkUnVsZVN0YWNrIEEgc2V0IHVzZWQgZm9yIHByZXZlbnRpbmcgbGVmdCByZWN1cnNpb24gaW4gdGhlXHJcblx0ICogQVROIGZyb20gY2F1c2luZyBhIHN0YWNrIG92ZXJmbG93LiBPdXRzaWRlIGNvZGUgc2hvdWxkIHBhc3NcclxuXHQgKiBgbmV3IEJpdFNldCgpYCBmb3IgdGhpcyBhcmd1bWVudC5cclxuXHQgKiBAcGFyYW0gc2VlVGhydVByZWRzIGB0cnVlYCB0byB0cnVlIHNlbWFudGljIHByZWRpY2F0ZXMgYXNcclxuXHQgKiBpbXBsaWNpdGx5IGB0cnVlYCBhbmQgXCJzZWUgdGhyb3VnaCB0aGVtXCIsIG90aGVyd2lzZSBgZmFsc2VgXHJcblx0ICogdG8gdHJlYXQgc2VtYW50aWMgcHJlZGljYXRlcyBhcyBvcGFxdWUgYW5kIGFkZCB7QGxpbmsgI0hJVF9QUkVEfSB0byB0aGVcclxuXHQgKiByZXN1bHQgaWYgb25lIGlzIGVuY291bnRlcmVkLlxyXG5cdCAqIEBwYXJhbSBhZGRFT0YgQWRkIHtAbGluayBUb2tlbiNFT0Z9IHRvIHRoZSByZXN1bHQgaWYgdGhlIGVuZCBvZiB0aGVcclxuXHQgKiBvdXRlcm1vc3QgY29udGV4dCBpcyByZWFjaGVkLiBUaGlzIHBhcmFtZXRlciBoYXMgbm8gZWZmZWN0IGlmIGBjdHhgXHJcblx0ICogaXMge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0I0VNUFRZX0xPQ0FMfS5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgX0xPT0soXHJcblx0XHRATm90TnVsbCBzOiBBVE5TdGF0ZSxcclxuXHRcdHN0b3BTdGF0ZTogQVROU3RhdGUgfCB1bmRlZmluZWQsXHJcblx0XHRATm90TnVsbCBjdHg6IFByZWRpY3Rpb25Db250ZXh0LFxyXG5cdFx0QE5vdE51bGwgbG9vazogSW50ZXJ2YWxTZXQsXHJcblx0XHRATm90TnVsbCBsb29rQnVzeTogQXJyYXkyREhhc2hTZXQ8QVROQ29uZmlnPixcclxuXHRcdEBOb3ROdWxsIGNhbGxlZFJ1bGVTdGFjazogQml0U2V0LFxyXG5cdFx0c2VlVGhydVByZWRzOiBib29sZWFuLFxyXG5cdFx0YWRkRU9GOiBib29sZWFuKTogdm9pZCB7XHJcbi8vXHRcdFN5c3RlbS5vdXQucHJpbnRsbihcIl9MT09LKFwiK3Muc3RhdGVOdW1iZXIrXCIsIGN0eD1cIitjdHgpO1xyXG5cdFx0bGV0IGM6IEFUTkNvbmZpZyA9IEFUTkNvbmZpZy5jcmVhdGUocywgMCwgY3R4KTtcclxuXHRcdGlmICghbG9va0J1c3kuYWRkKGMpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAocyA9PT0gc3RvcFN0YXRlKSB7XHJcblx0XHRcdGlmIChQcmVkaWN0aW9uQ29udGV4dC5pc0VtcHR5TG9jYWwoY3R4KSkge1xyXG5cdFx0XHRcdGxvb2suYWRkKFRva2VuLkVQU0lMT04pO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fSBlbHNlIGlmIChjdHguaXNFbXB0eSkge1xyXG5cdFx0XHRcdGlmIChhZGRFT0YpIHtcclxuXHRcdFx0XHRcdGxvb2suYWRkKFRva2VuLkVPRik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocyBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcclxuXHRcdFx0aWYgKGN0eC5pc0VtcHR5ICYmICFQcmVkaWN0aW9uQ29udGV4dC5pc0VtcHR5TG9jYWwoY3R4KSkge1xyXG5cdFx0XHRcdGlmIChhZGRFT0YpIHtcclxuXHRcdFx0XHRcdGxvb2suYWRkKFRva2VuLkVPRik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCByZW1vdmVkOiBib29sZWFuID0gY2FsbGVkUnVsZVN0YWNrLmdldChzLnJ1bGVJbmRleCk7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Y2FsbGVkUnVsZVN0YWNrLmNsZWFyKHMucnVsZUluZGV4KTtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGN0eC5zaXplOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChjdHguZ2V0UmV0dXJuU3RhdGUoaSkgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCByZXR1cm5TdGF0ZTogQVROU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbY3R4LmdldFJldHVyblN0YXRlKGkpXTtcclxuLy9cdFx0XHRcdFx0U3lzdGVtLm91dC5wcmludGxuKFwicG9wcGluZyBiYWNrIHRvIFwiK3JldFN0YXRlKTtcclxuXHRcdFx0XHRcdHRoaXMuX0xPT0socmV0dXJuU3RhdGUsIHN0b3BTdGF0ZSwgY3R4LmdldFBhcmVudChpKSwgbG9vaywgbG9va0J1c3ksIGNhbGxlZFJ1bGVTdGFjaywgc2VlVGhydVByZWRzLCBhZGRFT0YpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRmaW5hbGx5IHtcclxuXHRcdFx0XHRpZiAocmVtb3ZlZCkge1xyXG5cdFx0XHRcdFx0Y2FsbGVkUnVsZVN0YWNrLnNldChzLnJ1bGVJbmRleCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG46IG51bWJlciA9IHMubnVtYmVyT2ZUcmFuc2l0aW9ucztcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdGxldCB0OiBUcmFuc2l0aW9uID0gcy50cmFuc2l0aW9uKGkpO1xyXG5cdFx0XHRpZiAodCBpbnN0YW5jZW9mIFJ1bGVUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0aWYgKGNhbGxlZFJ1bGVTdGFjay5nZXQodC5ydWxlSW5kZXgpKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBuZXdDb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCA9IGN0eC5nZXRDaGlsZCh0LmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyKTtcclxuXHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGNhbGxlZFJ1bGVTdGFjay5zZXQodC5ydWxlSW5kZXgpO1xyXG5cdFx0XHRcdFx0dGhpcy5fTE9PSyh0LnRhcmdldCwgc3RvcFN0YXRlLCBuZXdDb250ZXh0LCBsb29rLCBsb29rQnVzeSwgY2FsbGVkUnVsZVN0YWNrLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZpbmFsbHkge1xyXG5cdFx0XHRcdFx0Y2FsbGVkUnVsZVN0YWNrLmNsZWFyKHQucnVsZUluZGV4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAodCBpbnN0YW5jZW9mIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdGlmIChzZWVUaHJ1UHJlZHMpIHtcclxuXHRcdFx0XHRcdHRoaXMuX0xPT0sodC50YXJnZXQsIHN0b3BTdGF0ZSwgY3R4LCBsb29rLCBsb29rQnVzeSwgY2FsbGVkUnVsZVN0YWNrLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0bG9vay5hZGQoTEwxQW5hbHl6ZXIuSElUX1BSRUQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh0LmlzRXBzaWxvbikge1xyXG5cdFx0XHRcdHRoaXMuX0xPT0sodC50YXJnZXQsIHN0b3BTdGF0ZSwgY3R4LCBsb29rLCBsb29rQnVzeSwgY2FsbGVkUnVsZVN0YWNrLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAodCBpbnN0YW5jZW9mIFdpbGRjYXJkVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdGxvb2suYWRkQWxsKEludGVydmFsU2V0Lm9mKFRva2VuLk1JTl9VU0VSX1RPS0VOX1RZUEUsIHRoaXMuYXRuLm1heFRva2VuVHlwZSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG4vL1x0XHRcdFx0U3lzdGVtLm91dC5wcmludGxuKFwiYWRkaW5nIFwiKyB0KTtcclxuXHRcdFx0XHRsZXQgc2V0OiBJbnRlcnZhbFNldCB8IHVuZGVmaW5lZCA9IHQubGFiZWw7XHJcblx0XHRcdFx0aWYgKHNldCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRpZiAodCBpbnN0YW5jZW9mIE5vdFNldFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRcdFx0c2V0ID0gc2V0LmNvbXBsZW1lbnQoSW50ZXJ2YWxTZXQub2YoVG9rZW4uTUlOX1VTRVJfVE9LRU5fVFlQRSwgdGhpcy5hdG4ubWF4VG9rZW5UeXBlKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsb29rLmFkZEFsbChzZXQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjUuMTA2MzUxMC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQXJyYXkyREhhc2hNYXAgfSBmcm9tIFwiLi4vbWlzYy9BcnJheTJESGFzaE1hcFwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEFUTlR5cGUgfSBmcm9tIFwiLi9BVE5UeXBlXCI7XHJcbmltcG9ydCB7IERlY2lzaW9uU3RhdGUgfSBmcm9tIFwiLi9EZWNpc2lvblN0YXRlXCI7XHJcbmltcG9ydCB7IERGQSB9IGZyb20gXCIuLi9kZmEvREZBXCI7XHJcbmltcG9ydCB7IEludGVydmFsU2V0IH0gZnJvbSBcIi4uL21pc2MvSW50ZXJ2YWxTZXRcIjtcclxuaW1wb3J0IHsgSW52YWxpZFN0YXRlIH0gZnJvbSBcIi4vSW52YWxpZFN0YXRlXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25cIjtcclxuaW1wb3J0IHsgTEwxQW5hbHl6ZXIgfSBmcm9tIFwiLi9MTDFBbmFseXplclwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IFByZWRpY3Rpb25Db250ZXh0IH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRcIjtcclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUnVsZVN0YXJ0U3RhdGUgfSBmcm9tIFwiLi9SdWxlU3RhcnRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBSdWxlU3RvcFN0YXRlIH0gZnJvbSBcIi4vUnVsZVN0b3BTdGF0ZVwiO1xyXG5pbXBvcnQgeyBSdWxlVHJhbnNpdGlvbiB9IGZyb20gXCIuL1J1bGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4uL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2Vuc1N0YXJ0U3RhdGUgfSBmcm9tIFwiLi9Ub2tlbnNTdGFydFN0YXRlXCI7XHJcblxyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5cclxuLyoqICovXHJcbmV4cG9ydCBjbGFzcyBBVE4ge1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHJlYWRvbmx5IHN0YXRlczogQVROU3RhdGVbXSA9IFtdO1xyXG5cclxuXHQvKiogRWFjaCBzdWJydWxlL3J1bGUgaXMgYSBkZWNpc2lvbiBwb2ludCBhbmQgd2UgbXVzdCB0cmFjayB0aGVtIHNvIHdlXHJcblx0ICogIGNhbiBnbyBiYWNrIGxhdGVyIGFuZCBidWlsZCBERkEgcHJlZGljdG9ycyBmb3IgdGhlbS4gIFRoaXMgaW5jbHVkZXNcclxuXHQgKiAgYWxsIHRoZSBydWxlcywgc3VicnVsZXMsIG9wdGlvbmFsIGJsb2NrcywgKCkrLCAoKSogZXRjLi4uXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZGVjaXNpb25Ub1N0YXRlOiBEZWNpc2lvblN0YXRlW10gPSBbXTtcclxuXHJcblx0LyoqXHJcblx0ICogTWFwcyBmcm9tIHJ1bGUgaW5kZXggdG8gc3RhcnRpbmcgc3RhdGUgbnVtYmVyLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBydWxlVG9TdGFydFN0YXRlITogUnVsZVN0YXJ0U3RhdGVbXTtcclxuXHJcblx0LyoqXHJcblx0ICogTWFwcyBmcm9tIHJ1bGUgaW5kZXggdG8gc3RvcCBzdGF0ZSBudW1iZXIuXHJcblx0ICovXHJcblx0cHVibGljIHJ1bGVUb1N0b3BTdGF0ZSE6IFJ1bGVTdG9wU3RhdGVbXTtcclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgbW9kZU5hbWVUb1N0YXJ0U3RhdGU6IE1hcDxzdHJpbmcsIFRva2Vuc1N0YXJ0U3RhdGU+ID1cclxuXHRcdG5ldyBNYXA8c3RyaW5nLCBUb2tlbnNTdGFydFN0YXRlPigpO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgdHlwZSBvZiB0aGUgQVROLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBncmFtbWFyVHlwZTogQVROVHlwZTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG1heGltdW0gdmFsdWUgZm9yIGFueSBzeW1ib2wgcmVjb2duaXplZCBieSBhIHRyYW5zaXRpb24gaW4gdGhlIEFUTi5cclxuXHQgKi9cclxuXHRwdWJsaWMgbWF4VG9rZW5UeXBlOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEZvciBsZXhlciBBVE5zLCB0aGlzIG1hcHMgdGhlIHJ1bGUgaW5kZXggdG8gdGhlIHJlc3VsdGluZyB0b2tlbiB0eXBlLlxyXG5cdCAqIEZvciBwYXJzZXIgQVROcywgdGhpcyBtYXBzIHRoZSBydWxlIGluZGV4IHRvIHRoZSBnZW5lcmF0ZWQgYnlwYXNzIHRva2VuXHJcblx0ICogdHlwZSBpZiB0aGVcclxuXHQgKiB7QGxpbmsgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyNpc0dlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zfVxyXG5cdCAqIGRlc2VyaWFsaXphdGlvbiBvcHRpb24gd2FzIHNwZWNpZmllZDsgb3RoZXJ3aXNlLCB0aGlzIGlzIGB1bmRlZmluZWRgLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBydWxlVG9Ub2tlblR5cGUhOiBJbnQzMkFycmF5O1xyXG5cclxuXHQvKipcclxuXHQgKiBGb3IgbGV4ZXIgQVROcywgdGhpcyBpcyBhbiBhcnJheSBvZiB7QGxpbmsgTGV4ZXJBY3Rpb259IG9iamVjdHMgd2hpY2ggbWF5XHJcblx0ICogYmUgcmVmZXJlbmNlZCBieSBhY3Rpb24gdHJhbnNpdGlvbnMgaW4gdGhlIEFUTi5cclxuXHQgKi9cclxuXHRwdWJsaWMgbGV4ZXJBY3Rpb25zITogTGV4ZXJBY3Rpb25bXTtcclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgbW9kZVRvU3RhcnRTdGF0ZTogVG9rZW5zU3RhcnRTdGF0ZVtdID0gW107XHJcblxyXG5cdHByaXZhdGUgY29udGV4dENhY2hlOiBBcnJheTJESGFzaE1hcDxQcmVkaWN0aW9uQ29udGV4dCwgUHJlZGljdGlvbkNvbnRleHQ+ID1cclxuXHRcdG5ldyBBcnJheTJESGFzaE1hcDxQcmVkaWN0aW9uQ29udGV4dCwgUHJlZGljdGlvbkNvbnRleHQ+KE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSk7XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGRlY2lzaW9uVG9ERkE6IERGQVtdID0gW107XHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgbW9kZVRvREZBOiBERkFbXSA9IFtdO1xyXG5cclxuXHRwdWJsaWMgTEwxVGFibGU6IE1hcDxudW1iZXIsIG51bWJlcj4gPSBuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpO1xyXG5cclxuXHQvKiogVXNlZCBmb3IgcnVudGltZSBkZXNlcmlhbGl6YXRpb24gb2YgQVROcyBmcm9tIHN0cmluZ3MgKi9cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCBncmFtbWFyVHlwZTogQVROVHlwZSwgbWF4VG9rZW5UeXBlOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuZ3JhbW1hclR5cGUgPSBncmFtbWFyVHlwZTtcclxuXHRcdHRoaXMubWF4VG9rZW5UeXBlID0gbWF4VG9rZW5UeXBlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGNsZWFyREZBKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5kZWNpc2lvblRvREZBID0gbmV3IEFycmF5PERGQT4odGhpcy5kZWNpc2lvblRvU3RhdGUubGVuZ3RoKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZWNpc2lvblRvREZBLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZGVjaXNpb25Ub0RGQVtpXSA9IG5ldyBERkEodGhpcy5kZWNpc2lvblRvU3RhdGVbaV0sIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubW9kZVRvREZBID0gbmV3IEFycmF5PERGQT4odGhpcy5tb2RlVG9TdGFydFN0YXRlLmxlbmd0aCk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubW9kZVRvREZBLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMubW9kZVRvREZBW2ldID0gbmV3IERGQSh0aGlzLm1vZGVUb1N0YXJ0U3RhdGVbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29udGV4dENhY2hlLmNsZWFyKCk7XHJcblx0XHR0aGlzLkxMMVRhYmxlLmNsZWFyKCk7XHJcblx0fVxyXG5cclxuXHRnZXQgY29udGV4dENhY2hlU2l6ZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dENhY2hlLnNpemU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0Q2FjaGVkQ29udGV4dChjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdHJldHVybiBQcmVkaWN0aW9uQ29udGV4dC5nZXRDYWNoZWRDb250ZXh0KGNvbnRleHQsIHRoaXMuY29udGV4dENhY2hlLCBuZXcgUHJlZGljdGlvbkNvbnRleHQuSWRlbnRpdHlIYXNoTWFwKCkpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldERlY2lzaW9uVG9ERkEoKTogREZBW10ge1xyXG5cdFx0YXNzZXJ0KHRoaXMuZGVjaXNpb25Ub0RGQSAhPSBudWxsICYmIHRoaXMuZGVjaXNpb25Ub0RGQS5sZW5ndGggPT09IHRoaXMuZGVjaXNpb25Ub1N0YXRlLmxlbmd0aCk7XHJcblx0XHRyZXR1cm4gdGhpcy5kZWNpc2lvblRvREZBO1xyXG5cdH1cclxuXHJcblx0LyoqIENvbXB1dGUgdGhlIHNldCBvZiB2YWxpZCB0b2tlbnMgdGhhdCBjYW4gb2NjdXIgc3RhcnRpbmcgaW4gc3RhdGUgYHNgLlxyXG5cdCAqICBJZiBgY3R4YCBpcyB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHQjRU1QVFlfTE9DQUx9LCB0aGUgc2V0IG9mIHRva2VucyB3aWxsIG5vdCBpbmNsdWRlIHdoYXQgY2FuIGZvbGxvd1xyXG5cdCAqICB0aGUgcnVsZSBzdXJyb3VuZGluZyBgc2AuIEluIG90aGVyIHdvcmRzLCB0aGUgc2V0IHdpbGwgYmVcclxuXHQgKiAgcmVzdHJpY3RlZCB0byB0b2tlbnMgcmVhY2hhYmxlIHN0YXlpbmcgd2l0aGluIGBzYCdzIHJ1bGUuXHJcblx0ICovXHJcblx0Ly8gQE5vdE51bGxcclxuXHRwdWJsaWMgbmV4dFRva2VucyhzOiBBVE5TdGF0ZSwgLypATm90TnVsbCovIGN0eDogUHJlZGljdGlvbkNvbnRleHQpOiBJbnRlcnZhbFNldDtcclxuXHJcblx0LyoqXHJcblx0ICogQ29tcHV0ZSB0aGUgc2V0IG9mIHZhbGlkIHRva2VucyB0aGF0IGNhbiBvY2N1ciBzdGFydGluZyBpbiBgc2AgYW5kXHJcblx0ICogc3RheWluZyBpbiBzYW1lIHJ1bGUuIHtAbGluayBUb2tlbiNFUFNJTE9OfSBpcyBpbiBzZXQgaWYgd2UgcmVhY2ggZW5kIG9mXHJcblx0ICogcnVsZS5cclxuXHQgKi9cclxuXHQvLyBATm90TnVsbFxyXG5cdHB1YmxpYyBuZXh0VG9rZW5zKC8qQE5vdE51bGwqLyBzOiBBVE5TdGF0ZSk6IEludGVydmFsU2V0O1xyXG5cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBuZXh0VG9rZW5zKHM6IEFUTlN0YXRlLCBjdHg/OiBQcmVkaWN0aW9uQ29udGV4dCk6IEludGVydmFsU2V0IHtcclxuXHRcdGlmIChjdHgpIHtcclxuXHRcdFx0bGV0IGFuYWw6IExMMUFuYWx5emVyID0gbmV3IExMMUFuYWx5emVyKHRoaXMpO1xyXG5cdFx0XHRsZXQgbmV4dDogSW50ZXJ2YWxTZXQgPSBhbmFsLkxPT0socywgY3R4KTtcclxuXHRcdFx0cmV0dXJuIG5leHQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAocy5uZXh0VG9rZW5XaXRoaW5SdWxlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHMubmV4dFRva2VuV2l0aGluUnVsZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cy5uZXh0VG9rZW5XaXRoaW5SdWxlID0gdGhpcy5uZXh0VG9rZW5zKHMsIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMKTtcclxuXHRcdFx0cy5uZXh0VG9rZW5XaXRoaW5SdWxlLnNldFJlYWRvbmx5KHRydWUpO1xyXG5cdFx0XHRyZXR1cm4gcy5uZXh0VG9rZW5XaXRoaW5SdWxlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGFkZFN0YXRlKHN0YXRlOiBBVE5TdGF0ZSk6IHZvaWQge1xyXG5cdFx0c3RhdGUuYXRuID0gdGhpcztcclxuXHRcdHN0YXRlLnN0YXRlTnVtYmVyID0gdGhpcy5zdGF0ZXMubGVuZ3RoO1xyXG5cdFx0dGhpcy5zdGF0ZXMucHVzaChzdGF0ZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVtb3ZlU3RhdGUoQE5vdE51bGwgc3RhdGU6IEFUTlN0YXRlKTogdm9pZCB7XHJcblx0XHQvLyBqdXN0IHJlcGxhY2UgdGhlIHN0YXRlLCBkb24ndCBzaGlmdCBzdGF0ZXMgaW4gbGlzdFxyXG5cdFx0bGV0IGludmFsaWRTdGF0ZSA9IG5ldyBJbnZhbGlkU3RhdGUoKTtcclxuXHRcdGludmFsaWRTdGF0ZS5hdG4gPSB0aGlzO1xyXG5cdFx0aW52YWxpZFN0YXRlLnN0YXRlTnVtYmVyID0gc3RhdGUuc3RhdGVOdW1iZXI7XHJcblx0XHR0aGlzLnN0YXRlc1tzdGF0ZS5zdGF0ZU51bWJlcl0gPSBpbnZhbGlkU3RhdGU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZGVmaW5lTW9kZShATm90TnVsbCBuYW1lOiBzdHJpbmcsIEBOb3ROdWxsIHM6IFRva2Vuc1N0YXJ0U3RhdGUpOiB2b2lkIHtcclxuXHRcdHRoaXMubW9kZU5hbWVUb1N0YXJ0U3RhdGUuc2V0KG5hbWUsIHMpO1xyXG5cdFx0dGhpcy5tb2RlVG9TdGFydFN0YXRlLnB1c2gocyk7XHJcblx0XHR0aGlzLm1vZGVUb0RGQS5wdXNoKG5ldyBERkEocykpO1xyXG5cdFx0dGhpcy5kZWZpbmVEZWNpc2lvblN0YXRlKHMpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGRlZmluZURlY2lzaW9uU3RhdGUoQE5vdE51bGwgczogRGVjaXNpb25TdGF0ZSk6IG51bWJlciB7XHJcblx0XHR0aGlzLmRlY2lzaW9uVG9TdGF0ZS5wdXNoKHMpO1xyXG5cdFx0cy5kZWNpc2lvbiA9IHRoaXMuZGVjaXNpb25Ub1N0YXRlLmxlbmd0aCAtIDE7XHJcblx0XHR0aGlzLmRlY2lzaW9uVG9ERkEucHVzaChuZXcgREZBKHMsIHMuZGVjaXNpb24pKTtcclxuXHRcdHJldHVybiBzLmRlY2lzaW9uO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldERlY2lzaW9uU3RhdGUoZGVjaXNpb246IG51bWJlcik6IERlY2lzaW9uU3RhdGUgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKHRoaXMuZGVjaXNpb25Ub1N0YXRlLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZGVjaXNpb25Ub1N0YXRlW2RlY2lzaW9uXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRnZXQgbnVtYmVyT2ZEZWNpc2lvbnMoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmRlY2lzaW9uVG9TdGF0ZS5sZW5ndGg7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wdXRlcyB0aGUgc2V0IG9mIGlucHV0IHN5bWJvbHMgd2hpY2ggY291bGQgZm9sbG93IEFUTiBzdGF0ZSBudW1iZXJcclxuXHQgKiBgc3RhdGVOdW1iZXJgIGluIHRoZSBzcGVjaWZpZWQgZnVsbCBgY29udGV4dGAuIFRoaXMgbWV0aG9kXHJcblx0ICogY29uc2lkZXJzIHRoZSBjb21wbGV0ZSBwYXJzZXIgY29udGV4dCwgYnV0IGRvZXMgbm90IGV2YWx1YXRlIHNlbWFudGljXHJcblx0ICogcHJlZGljYXRlcyAoaS5lLiBhbGwgcHJlZGljYXRlcyBlbmNvdW50ZXJlZCBkdXJpbmcgdGhlIGNhbGN1bGF0aW9uIGFyZVxyXG5cdCAqIGFzc3VtZWQgdHJ1ZSkuIElmIGEgcGF0aCBpbiB0aGUgQVROIGV4aXN0cyBmcm9tIHRoZSBzdGFydGluZyBzdGF0ZSB0byB0aGVcclxuXHQgKiB7QGxpbmsgUnVsZVN0b3BTdGF0ZX0gb2YgdGhlIG91dGVybW9zdCBjb250ZXh0IHdpdGhvdXQgbWF0Y2hpbmcgYW55XHJcblx0ICogc3ltYm9scywge0BsaW5rIFRva2VuI0VPRn0gaXMgYWRkZWQgdG8gdGhlIHJldHVybmVkIHNldC5cclxuXHQgKlxyXG5cdCAqIElmIGBjb250ZXh0YCBpcyBgdW5kZWZpbmVkYCwgaXQgaXMgdHJlYXRlZCBhc1xyXG5cdCAqIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dCNFTVBUWX0uXHJcblx0ICpcclxuXHQgKiBOb3RlIHRoYXQgdGhpcyBkb2VzIE5PVCBnaXZlIHlvdSB0aGUgc2V0IG9mIGFsbCB0b2tlbnMgdGhhdCBjb3VsZFxyXG5cdCAqIGFwcGVhciBhdCBhIGdpdmVuIHRva2VuIHBvc2l0aW9uIGluIHRoZSBpbnB1dCBwaHJhc2UuICBJbiBvdGhlciB3b3JkcywgaXRcclxuXHQgKiBkb2VzIG5vdCBhbnN3ZXI6XHJcblx0ICpcclxuXHQgKiA+IEdpdmVuIGEgc3BlY2lmaWMgcGFydGlhbCBpbnB1dCBwaHJhc2UsIHJldHVybiB0aGUgc2V0IG9mIGFsbFxyXG5cdCAqID4gdG9rZW5zIHRoYXQgY2FuIGZvbGxvdyB0aGUgbGFzdCB0b2tlbiBpbiB0aGUgaW5wdXQgcGhyYXNlLlxyXG5cdCAqXHJcblx0ICogVGhlIGJpZyBkaWZmZXJlbmNlIGlzIHRoYXQgd2l0aCBqdXN0IHRoZSBpbnB1dCwgdGhlIHBhcnNlciBjb3VsZCBsYW5kXHJcblx0ICogcmlnaHQgaW4gdGhlIG1pZGRsZSBvZiBhIGxvb2thaGVhZCBkZWNpc2lvbi4gR2V0dGluZyBhbGxcclxuXHQgKiAqcG9zc2libGUqIHRva2VucyBnaXZlbiBhIHBhcnRpYWwgaW5wdXQgc3RyZWFtIGlzIGEgc2VwYXJhdGVcclxuXHQgKiBjb21wdXRhdGlvbi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRsci9hbnRscjQvaXNzdWVzLzE0MjhcclxuXHQgKlxyXG5cdCAqIEZvciB0aGlzIGZ1bmN0aW9uLCB3ZSBhcmUgc3BlY2lmeWluZyBhbiBBVE4gc3RhdGUgYW5kIGNhbGwgc3RhY2sgdG9cclxuXHQgKiBjb21wdXRlIHdoYXQgdG9rZW4ocykgY2FuIGNvbWUgbmV4dCBhbmQgc3BlY2lmaWNhbGx5OiBvdXRzaWRlIG9mIGFcclxuXHQgKiBsb29rYWhlYWQgZGVjaXNpb24uIFRoYXQgaXMgd2hhdCB5b3Ugd2FudCBmb3IgZXJyb3IgcmVwb3J0aW5nIGFuZFxyXG5cdCAqIHJlY292ZXJ5IHVwb24gcGFyc2UgZXJyb3IuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gc3RhdGVOdW1iZXIgdGhlIEFUTiBzdGF0ZSBudW1iZXJcclxuXHQgKiBAcGFyYW0gY29udGV4dCB0aGUgZnVsbCBwYXJzZSBjb250ZXh0XHJcblx0ICogQHJldHVybnMgVGhlIHNldCBvZiBwb3RlbnRpYWxseSB2YWxpZCBpbnB1dCBzeW1ib2xzIHdoaWNoIGNvdWxkIGZvbGxvdyB0aGVcclxuXHQgKiBzcGVjaWZpZWQgc3RhdGUgaW4gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxyXG5cdCAqIEAgaWYgdGhlIEFUTiBkb2VzIG5vdCBjb250YWluIGEgc3RhdGUgd2l0aFxyXG5cdCAqIG51bWJlciBgc3RhdGVOdW1iZXJgXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0RXhwZWN0ZWRUb2tlbnMoc3RhdGVOdW1iZXI6IG51bWJlciwgY29udGV4dDogUnVsZUNvbnRleHQgfCB1bmRlZmluZWQpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRpZiAoc3RhdGVOdW1iZXIgPCAwIHx8IHN0YXRlTnVtYmVyID49IHRoaXMuc3RhdGVzLmxlbmd0aCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgc3RhdGUgbnVtYmVyLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgY3R4OiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCA9IGNvbnRleHQ7XHJcblx0XHRsZXQgczogQVROU3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZU51bWJlcl07XHJcblx0XHRsZXQgZm9sbG93aW5nOiBJbnRlcnZhbFNldCA9IHRoaXMubmV4dFRva2VucyhzKTtcclxuXHRcdGlmICghZm9sbG93aW5nLmNvbnRhaW5zKFRva2VuLkVQU0lMT04pKSB7XHJcblx0XHRcdHJldHVybiBmb2xsb3dpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGV4cGVjdGVkOiBJbnRlcnZhbFNldCA9IG5ldyBJbnRlcnZhbFNldCgpO1xyXG5cdFx0ZXhwZWN0ZWQuYWRkQWxsKGZvbGxvd2luZyk7XHJcblx0XHRleHBlY3RlZC5yZW1vdmUoVG9rZW4uRVBTSUxPTik7XHJcblx0XHR3aGlsZSAoY3R4ICE9IG51bGwgJiYgY3R4Lmludm9raW5nU3RhdGUgPj0gMCAmJiBmb2xsb3dpbmcuY29udGFpbnMoVG9rZW4uRVBTSUxPTikpIHtcclxuXHRcdFx0bGV0IGludm9raW5nU3RhdGU6IEFUTlN0YXRlID0gdGhpcy5zdGF0ZXNbY3R4Lmludm9raW5nU3RhdGVdO1xyXG5cdFx0XHRsZXQgcnQ6IFJ1bGVUcmFuc2l0aW9uID0gaW52b2tpbmdTdGF0ZS50cmFuc2l0aW9uKDApIGFzIFJ1bGVUcmFuc2l0aW9uO1xyXG5cdFx0XHRmb2xsb3dpbmcgPSB0aGlzLm5leHRUb2tlbnMocnQuZm9sbG93U3RhdGUpO1xyXG5cdFx0XHRleHBlY3RlZC5hZGRBbGwoZm9sbG93aW5nKTtcclxuXHRcdFx0ZXhwZWN0ZWQucmVtb3ZlKFRva2VuLkVQU0lMT04pO1xyXG5cdFx0XHRjdHggPSBjdHguX3BhcmVudDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZm9sbG93aW5nLmNvbnRhaW5zKFRva2VuLkVQU0lMT04pKSB7XHJcblx0XHRcdGV4cGVjdGVkLmFkZChUb2tlbi5FT0YpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBleHBlY3RlZDtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgQVROIHtcclxuXHRleHBvcnQgY29uc3QgSU5WQUxJRF9BTFRfTlVNQkVSOiBudW1iZXIgPSAwO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOS43NjEzMDM4LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvbiB9IGZyb20gXCIuL0xleGVyQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uVHlwZSB9IGZyb20gXCIuL0xleGVyQWN0aW9uVHlwZVwiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4uL21pc2MvTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgTGV4ZXJBY3Rpb259IGlzIHVzZWQgZm9yIHRyYWNraW5nIGlucHV0IG9mZnNldHNcclxuICogZm9yIHBvc2l0aW9uLWRlcGVuZGVudCBhY3Rpb25zIHdpdGhpbiBhIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yfS5cclxuICpcclxuICogVGhpcyBhY3Rpb24gaXMgbm90IHNlcmlhbGl6ZWQgYXMgcGFydCBvZiB0aGUgQVROLCBhbmQgaXMgb25seSByZXF1aXJlZCBmb3JcclxuICogcG9zaXRpb24tZGVwZW5kZW50IGxleGVyIGFjdGlvbnMgd2hpY2ggYXBwZWFyIGF0IGEgbG9jYXRpb24gb3RoZXIgdGhhbiB0aGVcclxuICogZW5kIG9mIGEgcnVsZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgREZBIG9wdGltaXphdGlvbnMgZW1wbG95ZWQgZm9yXHJcbiAqIGxleGVyIGFjdGlvbnMsIHNlZSB7QGxpbmsgTGV4ZXJBY3Rpb25FeGVjdXRvciNhcHBlbmR9IGFuZFxyXG4gKiB7QGxpbmsgTGV4ZXJBY3Rpb25FeGVjdXRvciNmaXhPZmZzZXRCZWZvcmVNYXRjaH0uXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICogQHNpbmNlIDQuMlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbiBpbXBsZW1lbnRzIExleGVyQWN0aW9uIHtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9vZmZzZXQ6IG51bWJlcjtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9hY3Rpb246IExleGVyQWN0aW9uO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluZGV4ZWQgY3VzdG9tIGFjdGlvbiBieSBhc3NvY2lhdGluZyBhIGNoYXJhY3RlciBvZmZzZXRcclxuXHQgKiB3aXRoIGEge0BsaW5rIExleGVyQWN0aW9ufS5cclxuXHQgKlxyXG5cdCAqIE5vdGU6IFRoaXMgY2xhc3MgaXMgb25seSByZXF1aXJlZCBmb3IgbGV4ZXIgYWN0aW9ucyBmb3Igd2hpY2hcclxuXHQgKiB7QGxpbmsgTGV4ZXJBY3Rpb24jaXNQb3NpdGlvbkRlcGVuZGVudH0gcmV0dXJucyBgdHJ1ZWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgaW50byB0aGUgaW5wdXQge0BsaW5rIENoYXJTdHJlYW19LCByZWxhdGl2ZSB0b1xyXG5cdCAqIHRoZSB0b2tlbiBzdGFydCBpbmRleCwgYXQgd2hpY2ggdGhlIHNwZWNpZmllZCBsZXhlciBhY3Rpb24gc2hvdWxkIGJlXHJcblx0ICogZXhlY3V0ZWQuXHJcblx0ICogQHBhcmFtIGFjdGlvbiBUaGUgbGV4ZXIgYWN0aW9uIHRvIGV4ZWN1dGUgYXQgYSBwYXJ0aWN1bGFyIG9mZnNldCBpbiB0aGVcclxuXHQgKiBpbnB1dCB7QGxpbmsgQ2hhclN0cmVhbX0uXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Iob2Zmc2V0OiBudW1iZXIsIEBOb3ROdWxsIGFjdGlvbjogTGV4ZXJBY3Rpb24pIHtcclxuXHRcdHRoaXMuX29mZnNldCA9IG9mZnNldDtcclxuXHRcdHRoaXMuX2FjdGlvbiA9IGFjdGlvbjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGxvY2F0aW9uIGluIHRoZSBpbnB1dCB7QGxpbmsgQ2hhclN0cmVhbX0gYXQgd2hpY2ggdGhlIGxleGVyXHJcblx0ICogYWN0aW9uIHNob3VsZCBiZSBleGVjdXRlZC4gVGhlIHZhbHVlIGlzIGludGVycHJldGVkIGFzIGFuIG9mZnNldCByZWxhdGl2ZVxyXG5cdCAqIHRvIHRoZSB0b2tlbiBzdGFydCBpbmRleC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBsb2NhdGlvbiBpbiB0aGUgaW5wdXQge0BsaW5rIENoYXJTdHJlYW19IGF0IHdoaWNoIHRoZSBsZXhlclxyXG5cdCAqIGFjdGlvbiBzaG91bGQgYmUgZXhlY3V0ZWQuXHJcblx0ICovXHJcblx0Z2V0IG9mZnNldCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX29mZnNldDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGxleGVyIGFjdGlvbiB0byBleGVjdXRlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgQSB7QGxpbmsgTGV4ZXJBY3Rpb259IG9iamVjdCB3aGljaCBleGVjdXRlcyB0aGUgbGV4ZXIgYWN0aW9uLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGFjdGlvbigpOiBMZXhlckFjdGlvbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYWN0aW9uO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcge0BsaW5rICNnZXRBY3Rpb25UeXBlfVxyXG5cdCAqIG9uIHRoZSB7QGxpbmsgTGV4ZXJBY3Rpb259IHJldHVybmVkIGJ5IHtAbGluayAjZ2V0QWN0aW9ufS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgYWN0aW9uVHlwZSgpOiBMZXhlckFjdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2FjdGlvbi5hY3Rpb25UeXBlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc1Bvc2l0aW9uRGVwZW5kZW50KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCBjYWxscyB7QGxpbmsgI2V4ZWN1dGV9IG9uIHRoZSByZXN1bHQgb2Yge0BsaW5rICNnZXRBY3Rpb259XHJcblx0ICogdXNpbmcgdGhlIHByb3ZpZGVkIGBsZXhlcmAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGV4ZWN1dGUobGV4ZXI6IExleGVyKTogdm9pZCB7XHJcblx0XHQvLyBhc3N1bWUgdGhlIGlucHV0IHN0cmVhbSBwb3NpdGlvbiB3YXMgcHJvcGVybHkgc2V0IGJ5IHRoZSBjYWxsaW5nIGNvZGVcclxuXHRcdHRoaXMuX2FjdGlvbi5leGVjdXRlKGxleGVyKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IGhhc2g6IG51bWJlciA9IE11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuX29mZnNldCk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5fYWN0aW9uKTtcclxuXHRcdHJldHVybiBNdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAyKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChvYmogPT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX29mZnNldCA9PT0gb2JqLl9vZmZzZXRcclxuXHRcdFx0JiYgdGhpcy5fYWN0aW9uLmVxdWFscyhvYmouX2FjdGlvbik7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOC44ODEwNDUzLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBcnJheUVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuLi9taXNjL0FycmF5RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiLi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvbiB9IGZyb20gXCIuL0xleGVyQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVySW5kZXhlZEN1c3RvbUFjdGlvbiB9IGZyb20gXCIuL0xleGVySW5kZXhlZEN1c3RvbUFjdGlvblwiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4uL21pc2MvTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBleGVjdXRvciBmb3IgYSBzZXF1ZW5jZSBvZiBsZXhlciBhY3Rpb25zIHdoaWNoIHRyYXZlcnNlZCBkdXJpbmdcclxuICogdGhlIG1hdGNoaW5nIG9wZXJhdGlvbiBvZiBhIGxleGVyIHJ1bGUgKHRva2VuKS5cclxuICpcclxuICogVGhlIGV4ZWN1dG9yIHRyYWNrcyBwb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgcG9zaXRpb24tZGVwZW5kZW50IGxleGVyIGFjdGlvbnNcclxuICogZWZmaWNpZW50bHksIGVuc3VyaW5nIHRoYXQgYWN0aW9ucyBhcHBlYXJpbmcgb25seSBhdCB0aGUgZW5kIG9mIHRoZSBydWxlIGRvXHJcbiAqIG5vdCBjYXVzZSBibG9hdGluZyBvZiB0aGUge0BsaW5rIERGQX0gY3JlYXRlZCBmb3IgdGhlIGxleGVyLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqIEBzaW5jZSA0LjJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMZXhlckFjdGlvbkV4ZWN1dG9yIHtcclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgX2xleGVyQWN0aW9uczogTGV4ZXJBY3Rpb25bXTtcclxuXHJcblx0LyoqXHJcblx0ICogQ2FjaGVzIHRoZSByZXN1bHQgb2Yge0BsaW5rICNoYXNoQ29kZX0gc2luY2UgdGhlIGhhc2ggY29kZSBpcyBhbiBlbGVtZW50XHJcblx0ICogb2YgdGhlIHBlcmZvcm1hbmNlLWNyaXRpY2FsIHtAbGluayBMZXhlckFUTkNvbmZpZyNoYXNoQ29kZX0gb3BlcmF0aW9uLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgY2FjaGVkSGFzaENvZGU6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhbiBleGVjdXRvciBmb3IgYSBzZXF1ZW5jZSBvZiB7QGxpbmsgTGV4ZXJBY3Rpb259IGFjdGlvbnMuXHJcblx0ICogQHBhcmFtIGxleGVyQWN0aW9ucyBUaGUgbGV4ZXIgYWN0aW9ucyB0byBleGVjdXRlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIGxleGVyQWN0aW9uczogTGV4ZXJBY3Rpb25bXSkge1xyXG5cdFx0dGhpcy5fbGV4ZXJBY3Rpb25zID0gbGV4ZXJBY3Rpb25zO1xyXG5cclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoKTtcclxuXHRcdGZvciAobGV0IGxleGVyQWN0aW9uIG9mIGxleGVyQWN0aW9ucykge1xyXG5cdFx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgbGV4ZXJBY3Rpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2FjaGVkSGFzaENvZGUgPSBNdXJtdXJIYXNoLmZpbmlzaChoYXNoLCBsZXhlckFjdGlvbnMubGVuZ3RoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSB7QGxpbmsgTGV4ZXJBY3Rpb25FeGVjdXRvcn0gd2hpY2ggZXhlY3V0ZXMgdGhlIGFjdGlvbnMgZm9yXHJcblx0ICogdGhlIGlucHV0IGBsZXhlckFjdGlvbkV4ZWN1dG9yYCBmb2xsb3dlZCBieSBhIHNwZWNpZmllZFxyXG5cdCAqIGBsZXhlckFjdGlvbmAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gbGV4ZXJBY3Rpb25FeGVjdXRvciBUaGUgZXhlY3V0b3IgZm9yIGFjdGlvbnMgYWxyZWFkeSB0cmF2ZXJzZWQgYnlcclxuXHQgKiB0aGUgbGV4ZXIgd2hpbGUgbWF0Y2hpbmcgYSB0b2tlbiB3aXRoaW4gYSBwYXJ0aWN1bGFyXHJcblx0ICoge0BsaW5rIEFUTkNvbmZpZ30uIElmIHRoaXMgaXMgYHVuZGVmaW5lZGAsIHRoZSBtZXRob2QgYmVoYXZlcyBhcyB0aG91Z2hcclxuXHQgKiBpdCB3ZXJlIGFuIGVtcHR5IGV4ZWN1dG9yLlxyXG5cdCAqIEBwYXJhbSBsZXhlckFjdGlvbiBUaGUgbGV4ZXIgYWN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGFjdGlvbnNcclxuXHQgKiBzcGVjaWZpZWQgaW4gYGxleGVyQWN0aW9uRXhlY3V0b3JgLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgQSB7QGxpbmsgTGV4ZXJBY3Rpb25FeGVjdXRvcn0gZm9yIGV4ZWN1dGluZyB0aGUgY29tYmluZSBhY3Rpb25zXHJcblx0ICogb2YgYGxleGVyQWN0aW9uRXhlY3V0b3JgIGFuZCBgbGV4ZXJBY3Rpb25gLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHN0YXRpYyBhcHBlbmQobGV4ZXJBY3Rpb25FeGVjdXRvcjogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCwgQE5vdE51bGwgbGV4ZXJBY3Rpb246IExleGVyQWN0aW9uKTogTGV4ZXJBY3Rpb25FeGVjdXRvciB7XHJcblx0XHRpZiAoIWxleGVyQWN0aW9uRXhlY3V0b3IpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMZXhlckFjdGlvbkV4ZWN1dG9yKFtsZXhlckFjdGlvbl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBsZXhlckFjdGlvbnMgPSBsZXhlckFjdGlvbkV4ZWN1dG9yLl9sZXhlckFjdGlvbnMuc2xpY2UoMCk7XHJcblx0XHRsZXhlckFjdGlvbnMucHVzaChsZXhlckFjdGlvbik7XHJcblx0XHRyZXR1cm4gbmV3IExleGVyQWN0aW9uRXhlY3V0b3IobGV4ZXJBY3Rpb25zKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSB7QGxpbmsgTGV4ZXJBY3Rpb25FeGVjdXRvcn0gd2hpY2ggZW5jb2RlcyB0aGUgY3VycmVudCBvZmZzZXRcclxuXHQgKiBmb3IgcG9zaXRpb24tZGVwZW5kZW50IGxleGVyIGFjdGlvbnMuXHJcblx0ICpcclxuXHQgKiBOb3JtYWxseSwgd2hlbiB0aGUgZXhlY3V0b3IgZW5jb3VudGVycyBsZXhlciBhY3Rpb25zIHdoZXJlXHJcblx0ICoge0BsaW5rIExleGVyQWN0aW9uI2lzUG9zaXRpb25EZXBlbmRlbnR9IHJldHVybnMgYHRydWVgLCBpdCBjYWxsc1xyXG5cdCAqIHtAbGluayBJbnRTdHJlYW0jc2Vla30gb24gdGhlIGlucHV0IHtAbGluayBDaGFyU3RyZWFtfSB0byBzZXQgdGhlIGlucHV0XHJcblx0ICogcG9zaXRpb24gdG8gdGhlICplbmQqIG9mIHRoZSBjdXJyZW50IHRva2VuLiBUaGlzIGJlaGF2aW9yIHByb3ZpZGVzXHJcblx0ICogZm9yIGVmZmljaWVudCBERkEgcmVwcmVzZW50YXRpb24gb2YgbGV4ZXIgYWN0aW9ucyB3aGljaCBhcHBlYXIgYXQgdGhlIGVuZFxyXG5cdCAqIG9mIGEgbGV4ZXIgcnVsZSwgZXZlbiB3aGVuIHRoZSBsZXhlciBydWxlIG1hdGNoZXMgYSB2YXJpYWJsZSBudW1iZXIgb2ZcclxuXHQgKiBjaGFyYWN0ZXJzLlxyXG5cdCAqXHJcblx0ICogUHJpb3IgdG8gdHJhdmVyc2luZyBhIG1hdGNoIHRyYW5zaXRpb24gaW4gdGhlIEFUTiwgdGhlIGN1cnJlbnQgb2Zmc2V0XHJcblx0ICogZnJvbSB0aGUgdG9rZW4gc3RhcnQgaW5kZXggaXMgYXNzaWduZWQgdG8gYWxsIHBvc2l0aW9uLWRlcGVuZGVudCBsZXhlclxyXG5cdCAqIGFjdGlvbnMgd2hpY2ggaGF2ZSBub3QgYWxyZWFkeSBiZWVuIGFzc2lnbmVkIGEgZml4ZWQgb2Zmc2V0LiBCeSBzdG9yaW5nXHJcblx0ICogdGhlIG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHRva2VuIHN0YXJ0IGluZGV4LCB0aGUgREZBIHJlcHJlc2VudGF0aW9uIG9mXHJcblx0ICogbGV4ZXIgYWN0aW9ucyB3aGljaCBhcHBlYXIgaW4gdGhlIG1pZGRsZSBvZiB0b2tlbnMgcmVtYWlucyBlZmZpY2llbnQgZHVlXHJcblx0ICogdG8gc2hhcmluZyBhbW9uZyB0b2tlbnMgb2YgdGhlIHNhbWUgbGVuZ3RoLCByZWdhcmRsZXNzIG9mIHRoZWlyIGFic29sdXRlXHJcblx0ICogcG9zaXRpb24gaW4gdGhlIGlucHV0IHN0cmVhbS5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSBjdXJyZW50IGV4ZWN1dG9yIGFscmVhZHkgaGFzIG9mZnNldHMgYXNzaWduZWQgdG8gYWxsXHJcblx0ICogcG9zaXRpb24tZGVwZW5kZW50IGxleGVyIGFjdGlvbnMsIHRoZSBtZXRob2QgcmV0dXJucyBgdGhpc2AuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gb2Zmc2V0IFRoZSBjdXJyZW50IG9mZnNldCB0byBhc3NpZ24gdG8gYWxsIHBvc2l0aW9uLWRlcGVuZGVudFxyXG5cdCAqIGxleGVyIGFjdGlvbnMgd2hpY2ggZG8gbm90IGFscmVhZHkgaGF2ZSBvZmZzZXRzIGFzc2lnbmVkLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgQSB7QGxpbmsgTGV4ZXJBY3Rpb25FeGVjdXRvcn0gd2hpY2ggc3RvcmVzIGlucHV0IHN0cmVhbSBvZmZzZXRzXHJcblx0ICogZm9yIGFsbCBwb3NpdGlvbi1kZXBlbmRlbnQgbGV4ZXIgYWN0aW9ucy5cclxuXHQgKi9cclxuXHRwdWJsaWMgZml4T2Zmc2V0QmVmb3JlTWF0Y2gob2Zmc2V0OiBudW1iZXIpOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHtcclxuXHRcdGxldCB1cGRhdGVkTGV4ZXJBY3Rpb25zOiBMZXhlckFjdGlvbltdIHwgdW5kZWZpbmVkO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9sZXhlckFjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX2xleGVyQWN0aW9uc1tpXS5pc1Bvc2l0aW9uRGVwZW5kZW50ICYmICEodGhpcy5fbGV4ZXJBY3Rpb25zW2ldIGluc3RhbmNlb2YgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uKSkge1xyXG5cdFx0XHRcdGlmICghdXBkYXRlZExleGVyQWN0aW9ucykge1xyXG5cdFx0XHRcdFx0dXBkYXRlZExleGVyQWN0aW9ucyA9IHRoaXMuX2xleGVyQWN0aW9ucy5zbGljZSgwKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHVwZGF0ZWRMZXhlckFjdGlvbnNbaV0gPSBuZXcgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uKG9mZnNldCwgdGhpcy5fbGV4ZXJBY3Rpb25zW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdXBkYXRlZExleGVyQWN0aW9ucykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IExleGVyQWN0aW9uRXhlY3V0b3IodXBkYXRlZExleGVyQWN0aW9ucyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBsZXhlciBhY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIGJ5IHRoaXMgZXhlY3V0b3IuXHJcblx0ICogQHJldHVybnMgVGhlIGxleGVyIGFjdGlvbnMgdG8gYmUgZXhlY3V0ZWQgYnkgdGhpcyBleGVjdXRvci5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBsZXhlckFjdGlvbnMoKTogTGV4ZXJBY3Rpb25bXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGV4ZXJBY3Rpb25zO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZSB0aGUgYWN0aW9ucyBlbmNhcHN1bGF0ZWQgYnkgdGhpcyBleGVjdXRvciB3aXRoaW4gdGhlIGNvbnRleHQgb2YgYVxyXG5cdCAqIHBhcnRpY3VsYXIge0BsaW5rIExleGVyfS5cclxuXHQgKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGNhbGxzIHtAbGluayBJbnRTdHJlYW0jc2Vla30gdG8gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGVcclxuXHQgKiBgaW5wdXRgIHtAbGluayBDaGFyU3RyZWFtfSBwcmlvciB0byBjYWxsaW5nXHJcblx0ICoge0BsaW5rIExleGVyQWN0aW9uI2V4ZWN1dGV9IG9uIGEgcG9zaXRpb24tZGVwZW5kZW50IGFjdGlvbi4gQmVmb3JlIHRoZVxyXG5cdCAqIG1ldGhvZCByZXR1cm5zLCB0aGUgaW5wdXQgcG9zaXRpb24gd2lsbCBiZSByZXN0b3JlZCB0byB0aGUgc2FtZSBwb3NpdGlvblxyXG5cdCAqIGl0IHdhcyBpbiB3aGVuIHRoZSBtZXRob2Qgd2FzIGludm9rZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gbGV4ZXIgVGhlIGxleGVyIGluc3RhbmNlLlxyXG5cdCAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgc3RyZWFtIHdoaWNoIGlzIHRoZSBzb3VyY2UgZm9yIHRoZSBjdXJyZW50IHRva2VuLlxyXG5cdCAqIFdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGUgY3VycmVudCB7QGxpbmsgSW50U3RyZWFtI2luZGV4fSBmb3JcclxuXHQgKiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgc3RhcnQgb2YgdGhlIGZvbGxvd2luZyB0b2tlbiwgaS5lLiAxXHJcblx0ICogY2hhcmFjdGVyIHBhc3QgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0b2tlbi5cclxuXHQgKiBAcGFyYW0gc3RhcnRJbmRleCBUaGUgdG9rZW4gc3RhcnQgaW5kZXguIFRoaXMgdmFsdWUgbWF5IGJlIHBhc3NlZCB0b1xyXG5cdCAqIHtAbGluayBJbnRTdHJlYW0jc2Vla30gdG8gc2V0IHRoZSBgaW5wdXRgIHBvc2l0aW9uIHRvIHRoZSBiZWdpbm5pbmdcclxuXHQgKiBvZiB0aGUgdG9rZW4uXHJcblx0ICovXHJcblx0cHVibGljIGV4ZWN1dGUoQE5vdE51bGwgbGV4ZXI6IExleGVyLCBpbnB1dDogQ2hhclN0cmVhbSwgc3RhcnRJbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRsZXQgcmVxdWlyZXNTZWVrOiBib29sZWFuID0gZmFsc2U7XHJcblx0XHRsZXQgc3RvcEluZGV4OiBudW1iZXIgPSBpbnB1dC5pbmRleDtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGZvciAobGV0IGxleGVyQWN0aW9uIG9mIHRoaXMuX2xleGVyQWN0aW9ucykge1xyXG5cdFx0XHRcdGlmIChsZXhlckFjdGlvbiBpbnN0YW5jZW9mIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbikge1xyXG5cdFx0XHRcdFx0bGV0IG9mZnNldDogbnVtYmVyID0gbGV4ZXJBY3Rpb24ub2Zmc2V0O1xyXG5cdFx0XHRcdFx0aW5wdXQuc2VlayhzdGFydEluZGV4ICsgb2Zmc2V0KTtcclxuXHRcdFx0XHRcdGxleGVyQWN0aW9uID0gbGV4ZXJBY3Rpb24uYWN0aW9uO1xyXG5cdFx0XHRcdFx0cmVxdWlyZXNTZWVrID0gKHN0YXJ0SW5kZXggKyBvZmZzZXQpICE9PSBzdG9wSW5kZXg7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChsZXhlckFjdGlvbi5pc1Bvc2l0aW9uRGVwZW5kZW50KSB7XHJcblx0XHRcdFx0XHRpbnB1dC5zZWVrKHN0b3BJbmRleCk7XHJcblx0XHRcdFx0XHRyZXF1aXJlc1NlZWsgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxleGVyQWN0aW9uLmV4ZWN1dGUobGV4ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGZpbmFsbHkge1xyXG5cdFx0XHRpZiAocmVxdWlyZXNTZWVrKSB7XHJcblx0XHRcdFx0aW5wdXQuc2VlayhzdG9wSW5kZXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmNhY2hlZEhhc2hDb2RlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG9iaiA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAoIShvYmogaW5zdGFuY2VvZiBMZXhlckFjdGlvbkV4ZWN1dG9yKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVkSGFzaENvZGUgPT09IG9iai5jYWNoZWRIYXNoQ29kZVxyXG5cdFx0XHQmJiBBcnJheUVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRS5lcXVhbHModGhpcy5fbGV4ZXJBY3Rpb25zLCBvYmouX2xleGVyQWN0aW9ucyk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Mi4wOTYxMTM2LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5Db25maWdTZXQgfSBmcm9tIFwiLi9hdG4vQVROQ29uZmlnU2V0XCI7XHJcbmltcG9ydCB7IFJlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4vUmVjb2duaXRpb25FeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4vTGV4ZXJcIjtcclxuaW1wb3J0IHsgQ2hhclN0cmVhbSB9IGZyb20gXCIuL0NoYXJTdHJlYW1cIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gXCIuL21pc2MvVXRpbHNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uIGV4dGVuZHMgUmVjb2duaXRpb25FeGNlcHRpb24ge1xyXG5cdC8vcHJpdmF0ZSBzdGF0aWMgc2VyaWFsVmVyc2lvblVJRDogbnVtYmVyID0gIC03MzA5OTkyMDM5MTMwMDE3MjZMO1xyXG5cclxuXHQvKiogTWF0Y2hpbmcgYXR0ZW1wdGVkIGF0IHdoYXQgaW5wdXQgaW5kZXg/ICovXHJcblx0cHJpdmF0ZSBfc3RhcnRJbmRleDogbnVtYmVyO1xyXG5cclxuXHQvKiogV2hpY2ggY29uZmlndXJhdGlvbnMgZGlkIHdlIHRyeSBhdCBpbnB1dC5pbmRleCB0aGF0IGNvdWxkbid0IG1hdGNoIGlucHV0LkxBKDEpPyAqL1xyXG5cdHByaXZhdGUgX2RlYWRFbmRDb25maWdzPzogQVROQ29uZmlnU2V0O1xyXG5cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdGxleGVyOiBMZXhlciB8IHVuZGVmaW5lZCxcclxuXHRcdEBOb3ROdWxsIGlucHV0OiBDaGFyU3RyZWFtLFxyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyLFxyXG5cdFx0ZGVhZEVuZENvbmZpZ3M6IEFUTkNvbmZpZ1NldCB8IHVuZGVmaW5lZCkge1xyXG5cdFx0c3VwZXIobGV4ZXIsIGlucHV0KTtcclxuXHRcdHRoaXMuX3N0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xyXG5cdFx0dGhpcy5fZGVhZEVuZENvbmZpZ3MgPSBkZWFkRW5kQ29uZmlncztcclxuXHR9XHJcblxyXG5cdGdldCBzdGFydEluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RhcnRJbmRleDtcclxuXHR9XHJcblxyXG5cdGdldCBkZWFkRW5kQ29uZmlncygpOiBBVE5Db25maWdTZXQgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2RlYWRFbmRDb25maWdzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlucHV0U3RyZWFtKCk6IENoYXJTdHJlYW0ge1xyXG5cdFx0cmV0dXJuIHN1cGVyLmlucHV0U3RyZWFtIGFzIENoYXJTdHJlYW07XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGxldCBzeW1ib2wgPSBcIlwiO1xyXG5cdFx0aWYgKHRoaXMuX3N0YXJ0SW5kZXggPj0gMCAmJiB0aGlzLl9zdGFydEluZGV4IDwgdGhpcy5pbnB1dFN0cmVhbS5zaXplKSB7XHJcblx0XHRcdHN5bWJvbCA9IHRoaXMuaW5wdXRTdHJlYW0uZ2V0VGV4dChJbnRlcnZhbC5vZih0aGlzLl9zdGFydEluZGV4LCB0aGlzLl9zdGFydEluZGV4KSk7XHJcblx0XHRcdHN5bWJvbCA9IFV0aWxzLmVzY2FwZVdoaXRlc3BhY2Uoc3ltYm9sLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmV0dXJuIFN0cmluZy5mb3JtYXQoTG9jYWxlLmdldERlZmF1bHQoKSwgXCIlcygnJXMnKVwiLCBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uLmNsYXNzLmdldFNpbXBsZU5hbWUoKSwgc3ltYm9sKTtcclxuXHRcdHJldHVybiBgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbignJHtzeW1ib2x9JylgO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzAuOTQ0NDU1Ni0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROQ29uZmlnIH0gZnJvbSBcIi4vQVROQ29uZmlnXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuL0FUTkNvbmZpZ1NldFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE9yZGVyZWRBVE5Db25maWdTZXQgZXh0ZW5kcyBBVE5Db25maWdTZXQge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpO1xyXG5cdGNvbnN0cnVjdG9yKHNldDogQVROQ29uZmlnU2V0LCByZWFkb25seTogYm9vbGVhbik7XHJcblx0Y29uc3RydWN0b3Ioc2V0PzogQVROQ29uZmlnU2V0LCByZWFkb25seT86IGJvb2xlYW4pIHtcclxuXHRcdGlmIChzZXQgIT0gbnVsbCAmJiByZWFkb25seSAhPSBudWxsKSB7XHJcblx0XHRcdHN1cGVyKHNldCwgcmVhZG9ubHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3VwZXIoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjbG9uZShyZWFkb25seTogYm9vbGVhbik6IEFUTkNvbmZpZ1NldCB7XHJcblx0XHRsZXQgY29weTogT3JkZXJlZEFUTkNvbmZpZ1NldCA9IG5ldyBPcmRlcmVkQVROQ29uZmlnU2V0KHRoaXMsIHJlYWRvbmx5KTtcclxuXHRcdGlmICghcmVhZG9ubHkgJiYgdGhpcy5pc1JlYWRPbmx5KSB7XHJcblx0XHRcdGNvcHkuYWRkQWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb3B5O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIGdldEtleShlOiBBVE5Db25maWcpOiB7IHN0YXRlOiBudW1iZXIsIGFsdDogbnVtYmVyIH0ge1xyXG5cdFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWxseSBjcmFmdGVkIGtleSB0byBlbnN1cmUgY29uZmlndXJhdGlvbnMgYXJlIG9ubHkgbWVyZ2VkIGlmIHRoZXkgYXJlIGVxdWFsXHJcblx0XHRyZXR1cm4geyBzdGF0ZTogMCwgYWx0OiBlLmhhc2hDb2RlKCkgfTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCBjYW5NZXJnZShsZWZ0OiBBVE5Db25maWcsIGxlZnRLZXk6IHsgc3RhdGU6IG51bWJlciwgYWx0OiBudW1iZXIgfSwgcmlnaHQ6IEFUTkNvbmZpZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGxlZnQuZXF1YWxzKHJpZ2h0KTtcclxuXHR9XHJcblxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOS4xMDgzMDY2LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBY2NlcHRTdGF0ZUluZm8gfSBmcm9tIFwiLi4vZGZhL0FjY2VwdFN0YXRlSW5mb1wiO1xyXG5pbXBvcnQgeyBBY3Rpb25UcmFuc2l0aW9uIH0gZnJvbSBcIi4vQWN0aW9uVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9BVE5cIjtcclxuaW1wb3J0IHsgQVROQ29uZmlnIH0gZnJvbSBcIi4vQVROQ29uZmlnXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuL0FUTkNvbmZpZ1NldFwiO1xyXG5pbXBvcnQgeyBBVE5TaW11bGF0b3IgfSBmcm9tIFwiLi9BVE5TaW11bGF0b3JcIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBDaGFyU3RyZWFtIH0gZnJvbSBcIi4uL0NoYXJTdHJlYW1cIjtcclxuaW1wb3J0IHsgREZBIH0gZnJvbSBcIi4uL2RmYS9ERkFcIjtcclxuaW1wb3J0IHsgREZBU3RhdGUgfSBmcm9tIFwiLi4vZGZhL0RGQVN0YXRlXCI7XHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4uL21pc2MvSW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgSW50U3RyZWFtIH0gZnJvbSBcIi4uL0ludFN0cmVhbVwiO1xyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvbkV4ZWN1dG9yIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25FeGVjdXRvclwiO1xyXG5pbXBvcnQgeyBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uIH0gZnJvbSBcIi4uL0xleGVyTm9WaWFibGVBbHRFeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBPcmRlcmVkQVROQ29uZmlnU2V0IH0gZnJvbSBcIi4vT3JkZXJlZEFUTkNvbmZpZ1NldFwiO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uQ29udGV4dCB9IGZyb20gXCIuL1ByZWRpY3Rpb25Db250ZXh0XCI7XHJcbmltcG9ydCB7IFByZWRpY2F0ZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9QcmVkaWNhdGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFJ1bGVTdG9wU3RhdGUgfSBmcm9tIFwiLi9SdWxlU3RvcFN0YXRlXCI7XHJcbmltcG9ydCB7IFJ1bGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vUnVsZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCIuL1RyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvblR5cGUgfSBmcm9tIFwiLi9UcmFuc2l0aW9uVHlwZVwiO1xyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5cclxuLyoqIFwiZHVwXCIgb2YgUGFyc2VySW50ZXJwcmV0ZXIgKi9cclxuZXhwb3J0IGNsYXNzIExleGVyQVROU2ltdWxhdG9yIGV4dGVuZHMgQVROU2ltdWxhdG9yIHtcclxuXHRwdWJsaWMgb3B0aW1pemVfdGFpbF9jYWxsczogYm9vbGVhbiA9IHRydWU7XHJcblxyXG5cdHByb3RlY3RlZCByZWNvZzogTGV4ZXIgfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKiBUaGUgY3VycmVudCB0b2tlbidzIHN0YXJ0aW5nIGluZGV4IGludG8gdGhlIGNoYXJhY3RlciBzdHJlYW0uXHJcblx0ICogIFNoYXJlZCBhY3Jvc3MgREZBIHRvIEFUTiBzaW11bGF0aW9uIGluIGNhc2UgdGhlIEFUTiBmYWlscyBhbmQgdGhlXHJcblx0ICogIERGQSBkaWQgbm90IGhhdmUgYSBwcmV2aW91cyBhY2NlcHQgc3RhdGUuIEluIHRoaXMgY2FzZSwgd2UgdXNlIHRoZVxyXG5cdCAqICBBVE4tZ2VuZXJhdGVkIGV4Y2VwdGlvbiBvYmplY3QuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHN0YXJ0SW5kZXg6IG51bWJlciA9IC0xO1xyXG5cclxuXHQvKiogbGluZSBudW1iZXIgMS4ubiB3aXRoaW4gdGhlIGlucHV0ICovXHJcblx0cHJpdmF0ZSBfbGluZTogbnVtYmVyID0gMTtcclxuXHJcblx0LyoqIFRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgMC4ubi0xICovXHJcblx0cHJpdmF0ZSBfY2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXIgPSAwO1xyXG5cclxuXHRwcm90ZWN0ZWQgbW9kZTogbnVtYmVyID0gTGV4ZXIuREVGQVVMVF9NT0RFO1xyXG5cclxuXHQvKiogVXNlZCBkdXJpbmcgREZBL0FUTiBleGVjIHRvIHJlY29yZCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0IGNvbmZpZ3VyYXRpb24gaW5mbyAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIHByZXZBY2NlcHQ6IExleGVyQVROU2ltdWxhdG9yLlNpbVN0YXRlID0gbmV3IExleGVyQVROU2ltdWxhdG9yLlNpbVN0YXRlKCk7XHJcblxyXG5cdGNvbnN0cnVjdG9yKC8qQE5vdE51bGwqLyBhdG46IEFUTik7XHJcblx0Y29uc3RydWN0b3IoLypATm90TnVsbCovIGF0bjogQVROLCByZWNvZzogTGV4ZXIgfCB1bmRlZmluZWQpO1xyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIGF0bjogQVROLCByZWNvZz86IExleGVyKSB7XHJcblx0XHRzdXBlcihhdG4pO1xyXG5cdFx0dGhpcy5yZWNvZyA9IHJlY29nO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGNvcHlTdGF0ZShATm90TnVsbCBzaW11bGF0b3I6IExleGVyQVROU2ltdWxhdG9yKTogdm9pZCB7XHJcblx0XHR0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmUgPSBzaW11bGF0b3IuY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdFx0dGhpcy5fbGluZSA9IHNpbXVsYXRvci5fbGluZTtcclxuXHRcdHRoaXMubW9kZSA9IHNpbXVsYXRvci5tb2RlO1xyXG5cdFx0dGhpcy5zdGFydEluZGV4ID0gc2ltdWxhdG9yLnN0YXJ0SW5kZXg7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgbWF0Y2goQE5vdE51bGwgaW5wdXQ6IENoYXJTdHJlYW0sIG1vZGU6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHR0aGlzLm1vZGUgPSBtb2RlO1xyXG5cdFx0bGV0IG1hcms6IG51bWJlciA9IGlucHV0Lm1hcmsoKTtcclxuXHRcdHRyeSB7XHJcblx0XHRcdHRoaXMuc3RhcnRJbmRleCA9IGlucHV0LmluZGV4O1xyXG5cdFx0XHR0aGlzLnByZXZBY2NlcHQucmVzZXQoKTtcclxuXHRcdFx0bGV0IHMwOiBERkFTdGF0ZSB8IHVuZGVmaW5lZCA9IHRoaXMuYXRuLm1vZGVUb0RGQVttb2RlXS5zMDtcclxuXHRcdFx0aWYgKHMwID09IG51bGwpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXRjaEFUTihpbnB1dCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXhlY0FUTihpbnB1dCwgczApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmaW5hbGx5IHtcclxuXHRcdFx0aW5wdXQucmVsZWFzZShtYXJrKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuXHRcdHRoaXMucHJldkFjY2VwdC5yZXNldCgpO1xyXG5cdFx0dGhpcy5zdGFydEluZGV4ID0gLTE7XHJcblx0XHR0aGlzLl9saW5lID0gMTtcclxuXHRcdHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSA9IDA7XHJcblx0XHR0aGlzLm1vZGUgPSBMZXhlci5ERUZBVUxUX01PREU7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgbWF0Y2hBVE4oQE5vdE51bGwgaW5wdXQ6IENoYXJTdHJlYW0pOiBudW1iZXIge1xyXG5cdFx0bGV0IHN0YXJ0U3RhdGU6IEFUTlN0YXRlID0gdGhpcy5hdG4ubW9kZVRvU3RhcnRTdGF0ZVt0aGlzLm1vZGVdO1xyXG5cclxuXHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhgbWF0Y2hBVE4gbW9kZSAke3RoaXMubW9kZX0gc3RhcnQ6ICR7c3RhcnRTdGF0ZX1gKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgb2xkX21vZGU6IG51bWJlciA9IHRoaXMubW9kZTtcclxuXHJcblx0XHRsZXQgczBfY2xvc3VyZTogQVROQ29uZmlnU2V0ID0gdGhpcy5jb21wdXRlU3RhcnRTdGF0ZShpbnB1dCwgc3RhcnRTdGF0ZSk7XHJcblx0XHRsZXQgc3VwcHJlc3NFZGdlOiBib29sZWFuID0gczBfY2xvc3VyZS5oYXNTZW1hbnRpY0NvbnRleHQ7XHJcblx0XHRpZiAoc3VwcHJlc3NFZGdlKSB7XHJcblx0XHRcdHMwX2Nsb3N1cmUuaGFzU2VtYW50aWNDb250ZXh0ID0gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG5leHQ6IERGQVN0YXRlID0gdGhpcy5hZGRERkFTdGF0ZShzMF9jbG9zdXJlKTtcclxuXHRcdGlmICghc3VwcHJlc3NFZGdlKSB7XHJcblx0XHRcdGxldCBkZmEgPSB0aGlzLmF0bi5tb2RlVG9ERkFbdGhpcy5tb2RlXTtcclxuXHRcdFx0aWYgKCFkZmEuczApIHtcclxuXHRcdFx0XHRkZmEuczAgPSBuZXh0O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG5leHQgPSBkZmEuczA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcHJlZGljdDogbnVtYmVyID0gdGhpcy5leGVjQVROKGlucHV0LCBuZXh0KTtcclxuXHJcblx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coYERGQSBhZnRlciBtYXRjaEFUTjogJHt0aGlzLmF0bi5tb2RlVG9ERkFbb2xkX21vZGVdLnRvTGV4ZXJTdHJpbmcoKX1gKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcHJlZGljdDtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBleGVjQVROKEBOb3ROdWxsIGlucHV0OiBDaGFyU3RyZWFtLCBATm90TnVsbCBkczA6IERGQVN0YXRlKTogbnVtYmVyIHtcclxuXHRcdC8vIGNvbnNvbGUubG9nKFwiZW50ZXIgZXhlYyBpbmRleCBcIitpbnB1dC5pbmRleCtcIiBmcm9tIFwiK2RzMC5jb25maWdzKTtcclxuXHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhgc3RhcnQgc3RhdGUgY2xvc3VyZT0ke2RzMC5jb25maWdzfWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChkczAuaXNBY2NlcHRTdGF0ZSkge1xyXG5cdFx0XHQvLyBhbGxvdyB6ZXJvLWxlbmd0aCB0b2tlbnNcclxuXHRcdFx0dGhpcy5jYXB0dXJlU2ltU3RhdGUodGhpcy5wcmV2QWNjZXB0LCBpbnB1dCwgZHMwKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdDogbnVtYmVyID0gaW5wdXQuTEEoMSk7XHJcblx0XHQvLyBATm90TnVsbFxyXG5cdFx0bGV0IHM6IERGQVN0YXRlID0gZHMwOyAvLyBzIGlzIGN1cnJlbnQvZnJvbSBERkEgc3RhdGVcclxuXHJcblx0XHR3aGlsZSAodHJ1ZSkgeyAvLyB3aGlsZSBtb3JlIHdvcmtcclxuXHRcdFx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coYGV4ZWNBVE4gbG9vcCBzdGFydGluZyBjbG9zdXJlOiAke3MuY29uZmlnc31gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQXMgd2UgbW92ZSBzcmMtPnRyZywgc3JjLT50cmcsIHdlIGtlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIHRyZyB0b1xyXG5cdFx0XHQvLyBhdm9pZCBsb29raW5nIHVwIHRoZSBERkEgc3RhdGUgYWdhaW4sIHdoaWNoIGlzIGV4cGVuc2l2ZS5cclxuXHRcdFx0Ly8gSWYgdGhlIHByZXZpb3VzIHRhcmdldCB3YXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBERkEsIHdlIG1pZ2h0XHJcblx0XHRcdC8vIGJlIGFibGUgdG8gYXZvaWQgZG9pbmcgYSByZWFjaCBvcGVyYXRpb24gdXBvbiB0LiBJZiBzIT1udWxsLFxyXG5cdFx0XHQvLyBpdCBtZWFucyB0aGF0IHNlbWFudGljIHByZWRpY2F0ZXMgZGlkbid0IHByZXZlbnQgdXMgZnJvbVxyXG5cdFx0XHQvLyBjcmVhdGluZyBhIERGQSBzdGF0ZS4gT25jZSB3ZSBrbm93IHMhPW51bGwsIHdlIGNoZWNrIHRvIHNlZSBpZlxyXG5cdFx0XHQvLyB0aGUgREZBIHN0YXRlIGhhcyBhbiBlZGdlIGFscmVhZHkgZm9yIHQuIElmIHNvLCB3ZSBjYW4ganVzdCByZXVzZVxyXG5cdFx0XHQvLyBpdCdzIGNvbmZpZ3VyYXRpb24gc2V0OyB0aGVyZSdzIG5vIHBvaW50IGluIHJlLWNvbXB1dGluZyBpdC5cclxuXHRcdFx0Ly8gVGhpcyBpcyBraW5kIG9mIGxpa2UgZG9pbmcgREZBIHNpbXVsYXRpb24gd2l0aGluIHRoZSBBVE5cclxuXHRcdFx0Ly8gc2ltdWxhdGlvbiBiZWNhdXNlIERGQSBzaW11bGF0aW9uIGlzIHJlYWxseSBqdXN0IGEgd2F5IHRvIGF2b2lkXHJcblx0XHRcdC8vIGNvbXB1dGluZyByZWFjaC9jbG9zdXJlIHNldHMuIFRlY2huaWNhbGx5LCBvbmNlIHdlIGtub3cgdGhhdFxyXG5cdFx0XHQvLyB3ZSBoYXZlIGEgcHJldmlvdXNseSBhZGRlZCBERkEgc3RhdGUsIHdlIGNvdWxkIGp1bXAgb3ZlciB0b1xyXG5cdFx0XHQvLyB0aGUgREZBIHNpbXVsYXRvci4gQnV0LCB0aGF0IHdvdWxkIG1lYW4gcG9wcGluZyBiYWNrIGFuZCBmb3J0aFxyXG5cdFx0XHQvLyBhIGxvdCBhbmQgbWFraW5nIHRoaW5ncyBtb3JlIGNvbXBsaWNhdGVkIGFsZ29yaXRobWljYWxseS5cclxuXHRcdFx0Ly8gVGhpcyBvcHRpbWl6YXRpb24gbWFrZXMgYSBsb3Qgb2Ygc2Vuc2UgZm9yIGxvb3BzIHdpdGhpbiBERkEuXHJcblx0XHRcdC8vIEEgY2hhcmFjdGVyIHdpbGwgdGFrZSB1cyBiYWNrIHRvIGFuIGV4aXN0aW5nIERGQSBzdGF0ZVxyXG5cdFx0XHQvLyB0aGF0IGFscmVhZHkgaGFzIGxvdHMgb2YgZWRnZXMgb3V0IG9mIGl0LiBlLmcuLCAuKiBpbiBjb21tZW50cy5cclxuXHRcdFx0bGV0IHRhcmdldDogREZBU3RhdGUgfCB1bmRlZmluZWQgPSB0aGlzLmdldEV4aXN0aW5nVGFyZ2V0U3RhdGUocywgdCk7XHJcblx0XHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMuY29tcHV0ZVRhcmdldFN0YXRlKGlucHV0LCBzLCB0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRhcmdldCA9PT0gQVROU2ltdWxhdG9yLkVSUk9SKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElmIHRoaXMgaXMgYSBjb25zdW1hYmxlIGlucHV0IGVsZW1lbnQsIG1ha2Ugc3VyZSB0byBjb25zdW1lIGJlZm9yZVxyXG5cdFx0XHQvLyBjYXB0dXJpbmcgdGhlIGFjY2VwdCBzdGF0ZSBzbyB0aGUgaW5wdXQgaW5kZXgsIGxpbmUsIGFuZCBjaGFyXHJcblx0XHRcdC8vIHBvc2l0aW9uIGFjY3VyYXRlbHkgcmVmbGVjdCB0aGUgc3RhdGUgb2YgdGhlIGludGVycHJldGVyIGF0IHRoZVxyXG5cdFx0XHQvLyBlbmQgb2YgdGhlIHRva2VuLlxyXG5cdFx0XHRpZiAodCAhPT0gSW50U3RyZWFtLkVPRikge1xyXG5cdFx0XHRcdHRoaXMuY29uc3VtZShpbnB1dCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0YXJnZXQuaXNBY2NlcHRTdGF0ZSkge1xyXG5cdFx0XHRcdHRoaXMuY2FwdHVyZVNpbVN0YXRlKHRoaXMucHJldkFjY2VwdCwgaW5wdXQsIHRhcmdldCk7XHJcblx0XHRcdFx0aWYgKHQgPT09IEludFN0cmVhbS5FT0YpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dCA9IGlucHV0LkxBKDEpO1xyXG5cdFx0XHRzID0gdGFyZ2V0OyAvLyBmbGlwOyBjdXJyZW50IERGQSB0YXJnZXQgYmVjb21lcyBuZXcgc3JjL2Zyb20gc3RhdGVcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5mYWlsT3JBY2NlcHQodGhpcy5wcmV2QWNjZXB0LCBpbnB1dCwgcy5jb25maWdzLCB0KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbiBleGlzdGluZyB0YXJnZXQgc3RhdGUgZm9yIGFuIGVkZ2UgaW4gdGhlIERGQS4gSWYgdGhlIHRhcmdldCBzdGF0ZVxyXG5cdCAqIGZvciB0aGUgZWRnZSBoYXMgbm90IHlldCBiZWVuIGNvbXB1dGVkIG9yIGlzIG90aGVyd2lzZSBub3QgYXZhaWxhYmxlLFxyXG5cdCAqIHRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcyBUaGUgY3VycmVudCBERkEgc3RhdGVcclxuXHQgKiBAcGFyYW0gdCBUaGUgbmV4dCBpbnB1dCBzeW1ib2xcclxuXHQgKiBAcmV0dXJucyBUaGUgZXhpc3RpbmcgdGFyZ2V0IERGQSBzdGF0ZSBmb3IgdGhlIGdpdmVuIGlucHV0IHN5bWJvbFxyXG5cdCAqIGB0YCwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHRhcmdldCBzdGF0ZSBmb3IgdGhpcyBlZGdlIGlzIG5vdFxyXG5cdCAqIGFscmVhZHkgY2FjaGVkXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGdldEV4aXN0aW5nVGFyZ2V0U3RhdGUoQE5vdE51bGwgczogREZBU3RhdGUsIHQ6IG51bWJlcik6IERGQVN0YXRlIHwgdW5kZWZpbmVkIHtcclxuXHRcdGxldCB0YXJnZXQ6IERGQVN0YXRlIHwgdW5kZWZpbmVkID0gcy5nZXRUYXJnZXQodCk7XHJcblx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcgJiYgdGFyZ2V0ICE9IG51bGwpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJyZXVzZSBzdGF0ZSBcIiArIHMuc3RhdGVOdW1iZXIgK1xyXG5cdFx0XHRcdFwiIGVkZ2UgdG8gXCIgKyB0YXJnZXQuc3RhdGVOdW1iZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wdXRlIGEgdGFyZ2V0IHN0YXRlIGZvciBhbiBlZGdlIGluIHRoZSBERkEsIGFuZCBhdHRlbXB0IHRvIGFkZCB0aGVcclxuXHQgKiBjb21wdXRlZCBzdGF0ZSBhbmQgY29ycmVzcG9uZGluZyBlZGdlIHRvIHRoZSBERkEuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHN0cmVhbVxyXG5cdCAqIEBwYXJhbSBzIFRoZSBjdXJyZW50IERGQSBzdGF0ZVxyXG5cdCAqIEBwYXJhbSB0IFRoZSBuZXh0IGlucHV0IHN5bWJvbFxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIGNvbXB1dGVkIHRhcmdldCBERkEgc3RhdGUgZm9yIHRoZSBnaXZlbiBpbnB1dCBzeW1ib2xcclxuXHQgKiBgdGAuIElmIGB0YCBkb2VzIG5vdCBsZWFkIHRvIGEgdmFsaWQgREZBIHN0YXRlLCB0aGlzIG1ldGhvZFxyXG5cdCAqIHJldHVybnMge0BsaW5rICNFUlJPUn0uXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgY29tcHV0ZVRhcmdldFN0YXRlKEBOb3ROdWxsIGlucHV0OiBDaGFyU3RyZWFtLCBATm90TnVsbCBzOiBERkFTdGF0ZSwgdDogbnVtYmVyKTogREZBU3RhdGUge1xyXG5cdFx0bGV0IHJlYWNoOiBBVE5Db25maWdTZXQgPSBuZXcgT3JkZXJlZEFUTkNvbmZpZ1NldCgpO1xyXG5cclxuXHRcdC8vIGlmIHdlIGRvbid0IGZpbmQgYW4gZXhpc3RpbmcgREZBIHN0YXRlXHJcblx0XHQvLyBGaWxsIHJlYWNoIHN0YXJ0aW5nIGZyb20gY2xvc3VyZSwgZm9sbG93aW5nIHQgdHJhbnNpdGlvbnNcclxuXHRcdHRoaXMuZ2V0UmVhY2hhYmxlQ29uZmlnU2V0KGlucHV0LCBzLmNvbmZpZ3MsIHJlYWNoLCB0KTtcclxuXHJcblx0XHRpZiAocmVhY2guaXNFbXB0eSkgeyAvLyB3ZSBnb3Qgbm93aGVyZSBvbiB0IGZyb20gc1xyXG5cdFx0XHRpZiAoIXJlYWNoLmhhc1NlbWFudGljQ29udGV4dCkge1xyXG5cdFx0XHRcdC8vIHdlIGdvdCBub3doZXJlIG9uIHQsIGRvbid0IHRocm93IG91dCB0aGlzIGtub3dsZWRnZTsgaXQnZFxyXG5cdFx0XHRcdC8vIGNhdXNlIGEgZmFpbG92ZXIgZnJvbSBERkEgbGF0ZXIuXHJcblx0XHRcdFx0dGhpcy5hZGRERkFFZGdlKHMsIHQsIEFUTlNpbXVsYXRvci5FUlJPUik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHN0b3Agd2hlbiB3ZSBjYW4ndCBtYXRjaCBhbnkgbW9yZSBjaGFyXHJcblx0XHRcdHJldHVybiBBVE5TaW11bGF0b3IuRVJST1I7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWRkIGFuIGVkZ2UgZnJvbSBzIHRvIHRhcmdldCBERkEgZm91bmQvY3JlYXRlZCBmb3IgcmVhY2hcclxuXHRcdHJldHVybiB0aGlzLmFkZERGQUVkZ2UocywgdCwgcmVhY2gpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGZhaWxPckFjY2VwdChcclxuXHRcdHByZXZBY2NlcHQ6IExleGVyQVROU2ltdWxhdG9yLlNpbVN0YXRlLCBpbnB1dDogQ2hhclN0cmVhbSxcclxuXHRcdHJlYWNoOiBBVE5Db25maWdTZXQsIHQ6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRpZiAocHJldkFjY2VwdC5kZmFTdGF0ZSAhPSBudWxsKSB7XHJcblx0XHRcdGxldCBsZXhlckFjdGlvbkV4ZWN1dG9yOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHwgdW5kZWZpbmVkID0gcHJldkFjY2VwdC5kZmFTdGF0ZS5sZXhlckFjdGlvbkV4ZWN1dG9yO1xyXG5cdFx0XHR0aGlzLmFjY2VwdChpbnB1dCwgbGV4ZXJBY3Rpb25FeGVjdXRvciwgdGhpcy5zdGFydEluZGV4LFxyXG5cdFx0XHRcdHByZXZBY2NlcHQuaW5kZXgsIHByZXZBY2NlcHQubGluZSwgcHJldkFjY2VwdC5jaGFyUG9zKTtcclxuXHRcdFx0cmV0dXJuIHByZXZBY2NlcHQuZGZhU3RhdGUucHJlZGljdGlvbjtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHQvLyBpZiBubyBhY2NlcHQgYW5kIEVPRiBpcyBmaXJzdCBjaGFyLCByZXR1cm4gRU9GXHJcblx0XHRcdGlmICh0ID09PSBJbnRTdHJlYW0uRU9GICYmIGlucHV0LmluZGV4ID09PSB0aGlzLnN0YXJ0SW5kZXgpIHtcclxuXHRcdFx0XHRyZXR1cm4gVG9rZW4uRU9GO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzLnJlY29nLCBpbnB1dCwgdGhpcy5zdGFydEluZGV4LCByZWFjaCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogR2l2ZW4gYSBzdGFydGluZyBjb25maWd1cmF0aW9uIHNldCwgZmlndXJlIG91dCBhbGwgQVROIGNvbmZpZ3VyYXRpb25zXHJcblx0ICogIHdlIGNhbiByZWFjaCB1cG9uIGlucHV0IGB0YC4gUGFyYW1ldGVyIGByZWFjaGAgaXMgYSByZXR1cm5cclxuXHQgKiAgcGFyYW1ldGVyLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBnZXRSZWFjaGFibGVDb25maWdTZXQoQE5vdE51bGwgaW5wdXQ6IENoYXJTdHJlYW0sIEBOb3ROdWxsIGNsb3N1cmU6IEFUTkNvbmZpZ1NldCwgQE5vdE51bGwgcmVhY2g6IEFUTkNvbmZpZ1NldCwgdDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHQvLyB0aGlzIGlzIHVzZWQgdG8gc2tpcCBwcm9jZXNzaW5nIGZvciBjb25maWdzIHdoaWNoIGhhdmUgYSBsb3dlciBwcmlvcml0eVxyXG5cdFx0Ly8gdGhhbiBhIGNvbmZpZyB0aGF0IGFscmVhZHkgcmVhY2hlZCBhbiBhY2NlcHQgc3RhdGUgZm9yIHRoZSBzYW1lIHJ1bGVcclxuXHRcdGxldCBza2lwQWx0OiBudW1iZXIgPSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xyXG5cdFx0Zm9yIChsZXQgYyBvZiBjbG9zdXJlKSB7XHJcblx0XHRcdGxldCBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlOiBib29sZWFuID0gYy5hbHQgPT09IHNraXBBbHQ7XHJcblx0XHRcdGlmIChjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlICYmIGMuaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKGB0ZXN0aW5nICR7dGhpcy5nZXRUb2tlbk5hbWUodCl9IGF0ICR7Yy50b1N0cmluZyh0aGlzLnJlY29nLCB0cnVlKX1gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IG46IG51bWJlciA9IGMuc3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucztcclxuXHRcdFx0Zm9yIChsZXQgdGkgPSAwOyB0aSA8IG47IHRpKyspIHsgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBvcHRpbWl6ZWQgdHJhbnNpdGlvblxyXG5cdFx0XHRcdGxldCB0cmFuczogVHJhbnNpdGlvbiA9IGMuc3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbih0aSk7XHJcblx0XHRcdFx0bGV0IHRhcmdldDogQVROU3RhdGUgfCB1bmRlZmluZWQgPSB0aGlzLmdldFJlYWNoYWJsZVRhcmdldCh0cmFucywgdCk7XHJcblx0XHRcdFx0aWYgKHRhcmdldCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRsZXQgbGV4ZXJBY3Rpb25FeGVjdXRvcjogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCA9IGMubGV4ZXJBY3Rpb25FeGVjdXRvcjtcclxuXHRcdFx0XHRcdGxldCBjb25maWc6IEFUTkNvbmZpZztcclxuXHRcdFx0XHRcdGlmIChsZXhlckFjdGlvbkV4ZWN1dG9yICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0bGV4ZXJBY3Rpb25FeGVjdXRvciA9IGxleGVyQWN0aW9uRXhlY3V0b3IuZml4T2Zmc2V0QmVmb3JlTWF0Y2goaW5wdXQuaW5kZXggLSB0aGlzLnN0YXJ0SW5kZXgpO1xyXG5cdFx0XHRcdFx0XHRjb25maWcgPSBjLnRyYW5zZm9ybSh0YXJnZXQsIHRydWUsIGxleGVyQWN0aW9uRXhlY3V0b3IpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0YXNzZXJ0KGMubGV4ZXJBY3Rpb25FeGVjdXRvciA9PSBudWxsKTtcclxuXHRcdFx0XHRcdFx0Y29uZmlnID0gYy50cmFuc2Zvcm0odGFyZ2V0LCB0cnVlKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsZXQgdHJlYXRFb2ZBc0Vwc2lsb246IGJvb2xlYW4gPSB0ID09PSBJbnRTdHJlYW0uRU9GO1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuY2xvc3VyZShpbnB1dCwgY29uZmlnLCByZWFjaCwgY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSwgdHJ1ZSwgdHJlYXRFb2ZBc0Vwc2lsb24pKSB7XHJcblx0XHRcdFx0XHRcdC8vIGFueSByZW1haW5pbmcgY29uZmlncyBmb3IgdGhpcyBhbHQgaGF2ZSBhIGxvd2VyIHByaW9yaXR5IHRoYW5cclxuXHRcdFx0XHRcdFx0Ly8gdGhlIG9uZSB0aGF0IGp1c3QgcmVhY2hlZCBhbiBhY2NlcHQgc3RhdGUuXHJcblx0XHRcdFx0XHRcdHNraXBBbHQgPSBjLmFsdDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgYWNjZXB0KFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IENoYXJTdHJlYW0sIGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQsXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGxpbmU6IG51bWJlciwgY2hhclBvczogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coYEFDVElPTiAke2xleGVyQWN0aW9uRXhlY3V0b3J9YCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2VlayB0byBhZnRlciBsYXN0IGNoYXIgaW4gdG9rZW5cclxuXHRcdGlucHV0LnNlZWsoaW5kZXgpO1xyXG5cdFx0dGhpcy5fbGluZSA9IGxpbmU7XHJcblx0XHR0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmUgPSBjaGFyUG9zO1xyXG5cclxuXHRcdGlmIChsZXhlckFjdGlvbkV4ZWN1dG9yICE9IG51bGwgJiYgdGhpcy5yZWNvZyAhPSBudWxsKSB7XHJcblx0XHRcdGxleGVyQWN0aW9uRXhlY3V0b3IuZXhlY3V0ZSh0aGlzLnJlY29nLCBpbnB1dCwgc3RhcnRJbmRleCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0UmVhY2hhYmxlVGFyZ2V0KHRyYW5zOiBUcmFuc2l0aW9uLCB0OiBudW1iZXIpOiBBVE5TdGF0ZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAodHJhbnMubWF0Y2hlcyh0LCBMZXhlci5NSU5fQ0hBUl9WQUxVRSwgTGV4ZXIuTUFYX0NIQVJfVkFMVUUpKSB7XHJcblx0XHRcdHJldHVybiB0cmFucy50YXJnZXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGNvbXB1dGVTdGFydFN0YXRlKFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IENoYXJTdHJlYW0sXHJcblx0XHRATm90TnVsbCBwOiBBVE5TdGF0ZSk6IEFUTkNvbmZpZ1NldCB7XHJcblx0XHRsZXQgaW5pdGlhbENvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0ID0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTDtcclxuXHRcdGxldCBjb25maWdzOiBBVE5Db25maWdTZXQgPSBuZXcgT3JkZXJlZEFUTkNvbmZpZ1NldCgpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwLm51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xyXG5cdFx0XHRsZXQgdGFyZ2V0OiBBVE5TdGF0ZSA9IHAudHJhbnNpdGlvbihpKS50YXJnZXQ7XHJcblx0XHRcdGxldCBjOiBBVE5Db25maWcgPSBBVE5Db25maWcuY3JlYXRlKHRhcmdldCwgaSArIDEsIGluaXRpYWxDb250ZXh0KTtcclxuXHRcdFx0dGhpcy5jbG9zdXJlKGlucHV0LCBjLCBjb25maWdzLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjb25maWdzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2luY2UgdGhlIGFsdGVybmF0aXZlcyB3aXRoaW4gYW55IGxleGVyIGRlY2lzaW9uIGFyZSBvcmRlcmVkIGJ5XHJcblx0ICogcHJlZmVyZW5jZSwgdGhpcyBtZXRob2Qgc3RvcHMgcHVyc3VpbmcgdGhlIGNsb3N1cmUgYXMgc29vbiBhcyBhbiBhY2NlcHRcclxuXHQgKiBzdGF0ZSBpcyByZWFjaGVkLiBBZnRlciB0aGUgZmlyc3QgYWNjZXB0IHN0YXRlIGlzIHJlYWNoZWQgYnkgZGVwdGgtZmlyc3RcclxuXHQgKiBzZWFyY2ggZnJvbSBgY29uZmlnYCwgYWxsIG90aGVyIChwb3RlbnRpYWxseSByZWFjaGFibGUpIHN0YXRlcyBmb3JcclxuXHQgKiB0aGlzIHJ1bGUgd291bGQgaGF2ZSBhIGxvd2VyIHByaW9yaXR5LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIGFuIGFjY2VwdCBzdGF0ZSBpcyByZWFjaGVkLCBvdGhlcndpc2VcclxuXHQgKiBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBjbG9zdXJlKEBOb3ROdWxsIGlucHV0OiBDaGFyU3RyZWFtLCBATm90TnVsbCBjb25maWc6IEFUTkNvbmZpZywgQE5vdE51bGwgY29uZmlnczogQVROQ29uZmlnU2V0LCBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlOiBib29sZWFuLCBzcGVjdWxhdGl2ZTogYm9vbGVhbiwgdHJlYXRFb2ZBc0Vwc2lsb246IGJvb2xlYW4pOiBib29sZWFuIHtcclxuXHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcImNsb3N1cmUoXCIgKyBjb25maWcudG9TdHJpbmcodGhpcy5yZWNvZywgdHJ1ZSkgKyBcIilcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcclxuXHRcdFx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMucmVjb2cgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYGNsb3N1cmUgYXQgJHt0aGlzLnJlY29nLnJ1bGVOYW1lc1tjb25maWcuc3RhdGUucnVsZUluZGV4XX0gcnVsZSBzdG9wICR7Y29uZmlnfWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBjbG9zdXJlIGF0IHJ1bGUgc3RvcCAke2NvbmZpZ31gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCA9IGNvbmZpZy5jb250ZXh0O1xyXG5cdFx0XHRpZiAoY29udGV4dC5pc0VtcHR5KSB7XHJcblx0XHRcdFx0Y29uZmlncy5hZGQoY29uZmlnKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChjb250ZXh0Lmhhc0VtcHR5KSB7XHJcblx0XHRcdFx0Y29uZmlncy5hZGQoY29uZmlnLnRyYW5zZm9ybShjb25maWcuc3RhdGUsIHRydWUsIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTEwpKTtcclxuXHRcdFx0XHRjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZXh0LnNpemU7IGkrKykge1xyXG5cdFx0XHRcdGxldCByZXR1cm5TdGF0ZU51bWJlcjogbnVtYmVyID0gY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKTtcclxuXHRcdFx0XHRpZiAocmV0dXJuU3RhdGVOdW1iZXIgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBuZXdDb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCA9IGNvbnRleHQuZ2V0UGFyZW50KGkpOyAvLyBcInBvcFwiIHJldHVybiBzdGF0ZVxyXG5cdFx0XHRcdGxldCByZXR1cm5TdGF0ZTogQVROU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbcmV0dXJuU3RhdGVOdW1iZXJdO1xyXG5cdFx0XHRcdGxldCBjOiBBVE5Db25maWcgPSBjb25maWcudHJhbnNmb3JtKHJldHVyblN0YXRlLCBmYWxzZSwgbmV3Q29udGV4dCk7XHJcblx0XHRcdFx0Y3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSA9IHRoaXMuY2xvc3VyZShpbnB1dCwgYywgY29uZmlncywgY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSwgc3BlY3VsYXRpdmUsIHRyZWF0RW9mQXNFcHNpbG9uKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3B0aW1pemF0aW9uXHJcblx0XHRpZiAoIWNvbmZpZy5zdGF0ZS5vbmx5SGFzRXBzaWxvblRyYW5zaXRpb25zKSB7XHJcblx0XHRcdGlmICghY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSB8fCAhY29uZmlnLmhhc1Bhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbikge1xyXG5cdFx0XHRcdGNvbmZpZ3MuYWRkKGNvbmZpZyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcDogQVROU3RhdGUgPSBjb25maWcuc3RhdGU7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHAubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9uczsgaSsrKSB7XHJcblx0XHRcdGxldCB0OiBUcmFuc2l0aW9uID0gcC5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKGkpO1xyXG5cdFx0XHRsZXQgYzogQVROQ29uZmlnIHwgdW5kZWZpbmVkID0gdGhpcy5nZXRFcHNpbG9uVGFyZ2V0KGlucHV0LCBjb25maWcsIHQsIGNvbmZpZ3MsIHNwZWN1bGF0aXZlLCB0cmVhdEVvZkFzRXBzaWxvbik7XHJcblx0XHRcdGlmIChjICE9IG51bGwpIHtcclxuXHRcdFx0XHRjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlID0gdGhpcy5jbG9zdXJlKGlucHV0LCBjLCBjb25maWdzLCBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlLCBzcGVjdWxhdGl2ZSwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGU7XHJcblx0fVxyXG5cclxuXHQvLyBzaWRlLWVmZmVjdDogY2FuIGFsdGVyIGNvbmZpZ3MuaGFzU2VtYW50aWNDb250ZXh0XHJcblx0cHJvdGVjdGVkIGdldEVwc2lsb25UYXJnZXQoXHJcblx0XHRATm90TnVsbCBpbnB1dDogQ2hhclN0cmVhbSxcclxuXHRcdEBOb3ROdWxsIGNvbmZpZzogQVROQ29uZmlnLFxyXG5cdFx0QE5vdE51bGwgdDogVHJhbnNpdGlvbixcclxuXHRcdEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCxcclxuXHRcdHNwZWN1bGF0aXZlOiBib29sZWFuLFxyXG5cdFx0dHJlYXRFb2ZBc0Vwc2lsb246IGJvb2xlYW4pOiBBVE5Db25maWcgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IGM6IEFUTkNvbmZpZyB8IHVuZGVmaW5lZDtcclxuXHJcblx0XHRzd2l0Y2ggKHQuc2VyaWFsaXphdGlvblR5cGUpIHtcclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUlVMRTpcclxuXHRcdFx0bGV0IHJ1bGVUcmFuc2l0aW9uOiBSdWxlVHJhbnNpdGlvbiA9IHQgYXMgUnVsZVRyYW5zaXRpb247XHJcblx0XHRcdGlmICh0aGlzLm9wdGltaXplX3RhaWxfY2FsbHMgJiYgcnVsZVRyYW5zaXRpb24ub3B0aW1pemVkVGFpbENhbGwgJiYgIWNvbmZpZy5jb250ZXh0Lmhhc0VtcHR5KSB7XHJcblx0XHRcdFx0YyA9IGNvbmZpZy50cmFuc2Zvcm0odC50YXJnZXQsIHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGxldCBuZXdDb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCA9IGNvbmZpZy5jb250ZXh0LmdldENoaWxkKHJ1bGVUcmFuc2l0aW9uLmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyKTtcclxuXHRcdFx0XHRjID0gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgdHJ1ZSwgbmV3Q29udGV4dCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUFJFQ0VERU5DRTpcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUHJlY2VkZW5jZSBwcmVkaWNhdGVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGxleGVycy5cIik7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5QUkVESUNBVEU6XHJcblx0XHRcdC8qICBUcmFjayB0cmF2ZXJzaW5nIHNlbWFudGljIHByZWRpY2F0ZXMuIElmIHdlIHRyYXZlcnNlLFxyXG5cdFx0XHRcdHdlIGNhbm5vdCBhZGQgYSBERkEgc3RhdGUgZm9yIHRoaXMgXCJyZWFjaFwiIGNvbXB1dGF0aW9uXHJcblx0XHRcdFx0YmVjYXVzZSB0aGUgREZBIHdvdWxkIG5vdCB0ZXN0IHRoZSBwcmVkaWNhdGUgYWdhaW4gaW4gdGhlXHJcblx0XHRcdFx0ZnV0dXJlLiBSYXRoZXIgdGhhbiBjcmVhdGluZyBjb2xsZWN0aW9ucyBvZiBzZW1hbnRpYyBwcmVkaWNhdGVzXHJcblx0XHRcdFx0bGlrZSB2MyBhbmQgdGVzdGluZyB0aGVtIG9uIHByZWRpY3Rpb24sIHY0IHdpbGwgdGVzdCB0aGVtIG9uIHRoZVxyXG5cdFx0XHRcdGZseSBhbGwgdGhlIHRpbWUgdXNpbmcgdGhlIEFUTiBub3QgdGhlIERGQS4gVGhpcyBpcyBzbG93ZXIgYnV0XHJcblx0XHRcdFx0c2VtYW50aWNhbGx5IGl0J3Mgbm90IHVzZWQgdGhhdCBvZnRlbi4gT25lIG9mIHRoZSBrZXkgZWxlbWVudHMgdG9cclxuXHRcdFx0XHR0aGlzIHByZWRpY2F0ZSBtZWNoYW5pc20gaXMgbm90IGFkZGluZyBERkEgc3RhdGVzIHRoYXQgc2VlXHJcblx0XHRcdFx0cHJlZGljYXRlcyBpbW1lZGlhdGVseSBhZnRlcndhcmRzIGluIHRoZSBBVE4uIEZvciBleGFtcGxlLFxyXG5cclxuXHRcdFx0XHRhIDogSUQge3AxfT8gfCBJRCB7cDJ9PyA7XHJcblxyXG5cdFx0XHRcdHNob3VsZCBjcmVhdGUgdGhlIHN0YXJ0IHN0YXRlIGZvciBydWxlICdhJyAodG8gc2F2ZSBzdGFydCBzdGF0ZVxyXG5cdFx0XHRcdGNvbXBldGl0aW9uKSwgYnV0IHNob3VsZCBub3QgY3JlYXRlIHRhcmdldCBvZiBJRCBzdGF0ZS4gVGhlXHJcblx0XHRcdFx0Y29sbGVjdGlvbiBvZiBBVE4gc3RhdGVzIHRoZSBmb2xsb3dpbmcgSUQgcmVmZXJlbmNlcyBpbmNsdWRlc1xyXG5cdFx0XHRcdHN0YXRlcyByZWFjaGVkIGJ5IHRyYXZlcnNpbmcgcHJlZGljYXRlcy4gU2luY2UgdGhpcyBpcyB3aGVuIHdlXHJcblx0XHRcdFx0dGVzdCB0aGVtLCB3ZSBjYW5ub3QgY2FzaCB0aGUgREZBIHN0YXRlIHRhcmdldCBvZiBJRC5cclxuXHRcdFx0Ki9cclxuXHRcdFx0bGV0IHB0OiBQcmVkaWNhdGVUcmFuc2l0aW9uID0gdCBhcyBQcmVkaWNhdGVUcmFuc2l0aW9uO1xyXG5cdFx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkVWQUwgcnVsZSBcIiArIHB0LnJ1bGVJbmRleCArIFwiOlwiICsgcHQucHJlZEluZGV4KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb25maWdzLmhhc1NlbWFudGljQ29udGV4dCA9IHRydWU7XHJcblx0XHRcdGlmICh0aGlzLmV2YWx1YXRlUHJlZGljYXRlKGlucHV0LCBwdC5ydWxlSW5kZXgsIHB0LnByZWRJbmRleCwgc3BlY3VsYXRpdmUpKSB7XHJcblx0XHRcdFx0YyA9IGNvbmZpZy50cmFuc2Zvcm0odC50YXJnZXQsIHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGMgPSB1bmRlZmluZWQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuQUNUSU9OOlxyXG5cdFx0XHRpZiAoY29uZmlnLmNvbnRleHQuaGFzRW1wdHkpIHtcclxuXHRcdFx0XHQvLyBleGVjdXRlIGFjdGlvbnMgYW55d2hlcmUgaW4gdGhlIHN0YXJ0IHJ1bGUgZm9yIGEgdG9rZW4uXHJcblx0XHRcdFx0Ly9cclxuXHRcdFx0XHQvLyBUT0RPOiBpZiB0aGUgZW50cnkgcnVsZSBpcyBpbnZva2VkIHJlY3Vyc2l2ZWx5LCBzb21lXHJcblx0XHRcdFx0Ly8gYWN0aW9ucyBtYXkgYmUgZXhlY3V0ZWQgZHVyaW5nIHRoZSByZWN1cnNpdmUgY2FsbC4gVGhlXHJcblx0XHRcdFx0Ly8gcHJvYmxlbSBjYW4gYXBwZWFyIHdoZW4gaGFzRW1wdHkgaXMgdHJ1ZSBidXRcclxuXHRcdFx0XHQvLyBpc0VtcHR5IGlzIGZhbHNlLiBJbiB0aGlzIGNhc2UsIHRoZSBjb25maWcgbmVlZHMgdG8gYmVcclxuXHRcdFx0XHQvLyBzcGxpdCBpbnRvIHR3byBjb250ZXh0cyAtIG9uZSB3aXRoIGp1c3QgdGhlIGVtcHR5IHBhdGhcclxuXHRcdFx0XHQvLyBhbmQgYW5vdGhlciB3aXRoIGV2ZXJ5dGhpbmcgYnV0IHRoZSBlbXB0eSBwYXRoLlxyXG5cdFx0XHRcdC8vIFVuZm9ydHVuYXRlbHksIHRoZSBjdXJyZW50IGFsZ29yaXRobSBkb2VzIG5vdCBhbGxvd1xyXG5cdFx0XHRcdC8vIGdldEVwc2lsb25UYXJnZXQgdG8gcmV0dXJuIHR3byBjb25maWd1cmF0aW9ucywgc29cclxuXHRcdFx0XHQvLyBhZGRpdGlvbmFsIG1vZGlmaWNhdGlvbnMgYXJlIG5lZWRlZCBiZWZvcmUgd2UgY2FuIHN1cHBvcnRcclxuXHRcdFx0XHQvLyB0aGUgc3BsaXQgb3BlcmF0aW9uLlxyXG5cdFx0XHRcdGxldCBsZXhlckFjdGlvbkV4ZWN1dG9yOiBMZXhlckFjdGlvbkV4ZWN1dG9yID0gTGV4ZXJBY3Rpb25FeGVjdXRvci5hcHBlbmQoY29uZmlnLmxleGVyQWN0aW9uRXhlY3V0b3IsIHRoaXMuYXRuLmxleGVyQWN0aW9uc1sodCBhcyBBY3Rpb25UcmFuc2l0aW9uKS5hY3Rpb25JbmRleF0pO1xyXG5cdFx0XHRcdGMgPSBjb25maWcudHJhbnNmb3JtKHQudGFyZ2V0LCB0cnVlLCBsZXhlckFjdGlvbkV4ZWN1dG9yKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHQvLyBpZ25vcmUgYWN0aW9ucyBpbiByZWZlcmVuY2VkIHJ1bGVzXHJcblx0XHRcdFx0YyA9IGNvbmZpZy50cmFuc2Zvcm0odC50YXJnZXQsIHRydWUpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5FUFNJTE9OOlxyXG5cdFx0XHRjID0gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgdHJ1ZSk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuQVRPTTpcclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUkFOR0U6XHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlNFVDpcclxuXHRcdFx0aWYgKHRyZWF0RW9mQXNFcHNpbG9uKSB7XHJcblx0XHRcdFx0aWYgKHQubWF0Y2hlcyhJbnRTdHJlYW0uRU9GLCBMZXhlci5NSU5fQ0hBUl9WQUxVRSwgTGV4ZXIuTUFYX0NIQVJfVkFMVUUpKSB7XHJcblx0XHRcdFx0XHRjID0gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHRjID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV2YWx1YXRlIGEgcHJlZGljYXRlIHNwZWNpZmllZCBpbiB0aGUgbGV4ZXIuXHJcblx0ICpcclxuXHQgKiBJZiBgc3BlY3VsYXRpdmVgIGlzIGB0cnVlYCwgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCBiZWZvcmVcclxuXHQgKiB7QGxpbmsgI2NvbnN1bWV9IGZvciB0aGUgbWF0Y2hlZCBjaGFyYWN0ZXIuIFRoaXMgbWV0aG9kIHNob3VsZCBjYWxsXHJcblx0ICoge0BsaW5rICNjb25zdW1lfSBiZWZvcmUgZXZhbHVhdGluZyB0aGUgcHJlZGljYXRlIHRvIGVuc3VyZSBwb3NpdGlvblxyXG5cdCAqIHNlbnNpdGl2ZSB2YWx1ZXMsIGluY2x1ZGluZyB7QGxpbmsgTGV4ZXIjZ2V0VGV4dH0sIHtAbGluayBMZXhlciNnZXRMaW5lfSxcclxuXHQgKiBhbmQge0BsaW5rIExleGVyI2dldENoYXJQb3NpdGlvbkluTGluZX0sIHByb3Blcmx5IHJlZmxlY3QgdGhlIGN1cnJlbnRcclxuXHQgKiBsZXhlciBzdGF0ZS4gVGhpcyBtZXRob2Qgc2hvdWxkIHJlc3RvcmUgYGlucHV0YCBhbmQgdGhlIHNpbXVsYXRvclxyXG5cdCAqIHRvIHRoZSBvcmlnaW5hbCBzdGF0ZSBiZWZvcmUgcmV0dXJuaW5nIChpLmUuIHVuZG8gdGhlIGFjdGlvbnMgbWFkZSBieSB0aGVcclxuXHQgKiBjYWxsIHRvIHtAbGluayAjY29uc3VtZX0uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHN0cmVhbS5cclxuXHQgKiBAcGFyYW0gcnVsZUluZGV4IFRoZSBydWxlIGNvbnRhaW5pbmcgdGhlIHByZWRpY2F0ZS5cclxuXHQgKiBAcGFyYW0gcHJlZEluZGV4IFRoZSBpbmRleCBvZiB0aGUgcHJlZGljYXRlIHdpdGhpbiB0aGUgcnVsZS5cclxuXHQgKiBAcGFyYW0gc3BlY3VsYXRpdmUgYHRydWVgIGlmIHRoZSBjdXJyZW50IGluZGV4IGluIGBpbnB1dGAgaXNcclxuXHQgKiBvbmUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgcHJlZGljYXRlJ3MgbG9jYXRpb24uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUgZXZhbHVhdGVzIHRvXHJcblx0ICogYHRydWVgLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBldmFsdWF0ZVByZWRpY2F0ZShATm90TnVsbCBpbnB1dDogQ2hhclN0cmVhbSwgcnVsZUluZGV4OiBudW1iZXIsIHByZWRJbmRleDogbnVtYmVyLCBzcGVjdWxhdGl2ZTogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG5cdFx0Ly8gYXNzdW1lIHRydWUgaWYgbm8gcmVjb2duaXplciB3YXMgcHJvdmlkZWRcclxuXHRcdGlmICh0aGlzLnJlY29nID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFzcGVjdWxhdGl2ZSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5yZWNvZy5zZW1wcmVkKHVuZGVmaW5lZCwgcnVsZUluZGV4LCBwcmVkSW5kZXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBzYXZlZENoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyID0gdGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdFx0bGV0IHNhdmVkTGluZTogbnVtYmVyID0gdGhpcy5fbGluZTtcclxuXHRcdGxldCBpbmRleDogbnVtYmVyID0gaW5wdXQuaW5kZXg7XHJcblx0XHRsZXQgbWFya2VyOiBudW1iZXIgPSBpbnB1dC5tYXJrKCk7XHJcblx0XHR0cnkge1xyXG5cdFx0XHR0aGlzLmNvbnN1bWUoaW5wdXQpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5yZWNvZy5zZW1wcmVkKHVuZGVmaW5lZCwgcnVsZUluZGV4LCBwcmVkSW5kZXgpO1xyXG5cdFx0fVxyXG5cdFx0ZmluYWxseSB7XHJcblx0XHRcdHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSA9IHNhdmVkQ2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdFx0XHR0aGlzLl9saW5lID0gc2F2ZWRMaW5lO1xyXG5cdFx0XHRpbnB1dC5zZWVrKGluZGV4KTtcclxuXHRcdFx0aW5wdXQucmVsZWFzZShtYXJrZXIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGNhcHR1cmVTaW1TdGF0ZShcclxuXHRcdEBOb3ROdWxsIHNldHRpbmdzOiBMZXhlckFUTlNpbXVsYXRvci5TaW1TdGF0ZSxcclxuXHRcdEBOb3ROdWxsIGlucHV0OiBDaGFyU3RyZWFtLFxyXG5cdFx0QE5vdE51bGwgZGZhU3RhdGU6IERGQVN0YXRlKTogdm9pZCB7XHJcblx0XHRzZXR0aW5ncy5pbmRleCA9IGlucHV0LmluZGV4O1xyXG5cdFx0c2V0dGluZ3MubGluZSA9IHRoaXMuX2xpbmU7XHJcblx0XHRzZXR0aW5ncy5jaGFyUG9zID0gdGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdFx0c2V0dGluZ3MuZGZhU3RhdGUgPSBkZmFTdGF0ZTtcclxuXHR9XHJcblxyXG5cdC8vIEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGFkZERGQUVkZ2UoLypATm90TnVsbCovIHA6IERGQVN0YXRlLCB0OiBudW1iZXIsIC8qQE5vdE51bGwqLyBxOiBBVE5Db25maWdTZXQpOiBERkFTdGF0ZTtcclxuXHRwcm90ZWN0ZWQgYWRkREZBRWRnZSgvKkBOb3ROdWxsKi8gcDogREZBU3RhdGUsIHQ6IG51bWJlciwgLypATm90TnVsbCovIHE6IERGQVN0YXRlKTogdm9pZDtcclxuXHRwcm90ZWN0ZWQgYWRkREZBRWRnZShwOiBERkFTdGF0ZSwgdDogbnVtYmVyLCBxOiBBVE5Db25maWdTZXQgfCBERkFTdGF0ZSk6IERGQVN0YXRlIHwgdm9pZCB7XHJcblx0XHRpZiAocSBpbnN0YW5jZW9mIEFUTkNvbmZpZ1NldCkge1xyXG5cdFx0XHQvKiBsZWFkaW5nIHRvIHRoaXMgY2FsbCwgQVROQ29uZmlnU2V0Lmhhc1NlbWFudGljQ29udGV4dCBpcyB1c2VkIGFzIGFcclxuXHRcdFx0KiBtYXJrZXIgaW5kaWNhdGluZyBkeW5hbWljIHByZWRpY2F0ZSBldmFsdWF0aW9uIG1ha2VzIHRoaXMgZWRnZVxyXG5cdFx0XHQqIGRlcGVuZGVudCBvbiB0aGUgc3BlY2lmaWMgaW5wdXQgc2VxdWVuY2UsIHNvIHRoZSBzdGF0aWMgZWRnZSBpbiB0aGVcclxuXHRcdFx0KiBERkEgc2hvdWxkIGJlIG9taXR0ZWQuIFRoZSB0YXJnZXQgREZBU3RhdGUgaXMgc3RpbGwgY3JlYXRlZCBzaW5jZVxyXG5cdFx0XHQqIGV4ZWNBVE4gaGFzIHRoZSBhYmlsaXR5IHRvIHJlc3luY2hyb25pemUgd2l0aCB0aGUgREZBIHN0YXRlIGNhY2hlXHJcblx0XHRcdCogZm9sbG93aW5nIHRoZSBwcmVkaWNhdGUgZXZhbHVhdGlvbiBzdGVwLlxyXG5cdFx0XHQqXHJcblx0XHRcdCogVEpQIG5vdGVzOiBuZXh0IHRpbWUgdGhyb3VnaCB0aGUgREZBLCB3ZSBzZWUgYSBwcmVkIGFnYWluIGFuZCBldmFsLlxyXG5cdFx0XHQqIElmIHRoYXQgZ2V0cyB1cyB0byBhIHByZXZpb3VzbHkgY3JlYXRlZCAoYnV0IGRhbmdsaW5nKSBERkFcclxuXHRcdFx0KiBzdGF0ZSwgd2UgY2FuIGNvbnRpbnVlIGluIHB1cmUgREZBIG1vZGUgZnJvbSB0aGVyZS5cclxuXHRcdFx0Ki9cclxuXHRcdFx0bGV0IHN1cHByZXNzRWRnZTogYm9vbGVhbiA9IHEuaGFzU2VtYW50aWNDb250ZXh0O1xyXG5cdFx0XHRpZiAoc3VwcHJlc3NFZGdlKSB7XHJcblx0XHRcdFx0cS5oYXNTZW1hbnRpY0NvbnRleHQgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQE5vdE51bGxcclxuXHRcdFx0bGV0IHRvOiBERkFTdGF0ZSA9IHRoaXMuYWRkREZBU3RhdGUocSk7XHJcblxyXG5cdFx0XHRpZiAoc3VwcHJlc3NFZGdlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRvO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmFkZERGQUVkZ2UocCwgdCwgdG8pO1xyXG5cdFx0XHRyZXR1cm4gdG87XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkVER0UgXCIgKyBwICsgXCIgLT4gXCIgKyBxICsgXCIgdXBvbiBcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAocCAhPSBudWxsKSB7XHJcblx0XHRcdFx0cC5zZXRUYXJnZXQodCwgcSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBBZGQgYSBuZXcgREZBIHN0YXRlIGlmIHRoZXJlIGlzbid0IG9uZSB3aXRoIHRoaXMgc2V0IG9mXHJcblx0ICogXHRjb25maWd1cmF0aW9ucyBhbHJlYWR5LiBUaGlzIG1ldGhvZCBhbHNvIGRldGVjdHMgdGhlIGZpcnN0XHJcblx0ICogXHRjb25maWd1cmF0aW9uIGNvbnRhaW5pbmcgYW4gQVROIHJ1bGUgc3RvcCBzdGF0ZS4gTGF0ZXIsIHdoZW5cclxuXHQgKiBcdHRyYXZlcnNpbmcgdGhlIERGQSwgd2Ugd2lsbCBrbm93IHdoaWNoIHJ1bGUgdG8gYWNjZXB0LlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGFkZERGQVN0YXRlKEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCk6IERGQVN0YXRlIHtcclxuXHRcdC8qIHRoZSBsZXhlciBldmFsdWF0ZXMgcHJlZGljYXRlcyBvbi10aGUtZmx5OyBieSB0aGlzIHBvaW50IGNvbmZpZ3NcclxuXHRcdCAqIHNob3VsZCBub3QgY29udGFpbiBhbnkgY29uZmlndXJhdGlvbnMgd2l0aCB1bmV2YWx1YXRlZCBwcmVkaWNhdGVzLlxyXG5cdFx0ICovXHJcblx0XHRhc3NlcnQoIWNvbmZpZ3MuaGFzU2VtYW50aWNDb250ZXh0KTtcclxuXHJcblx0XHRsZXQgcHJvcG9zZWQ6IERGQVN0YXRlID0gbmV3IERGQVN0YXRlKGNvbmZpZ3MpO1xyXG5cdFx0bGV0IGV4aXN0aW5nOiBERkFTdGF0ZSB8IHVuZGVmaW5lZCA9IHRoaXMuYXRuLm1vZGVUb0RGQVt0aGlzLm1vZGVdLnN0YXRlcy5nZXQocHJvcG9zZWQpO1xyXG5cdFx0aWYgKGV4aXN0aW5nICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIGV4aXN0aW5nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZ3Mub3B0aW1pemVDb25maWdzKHRoaXMpO1xyXG5cdFx0bGV0IG5ld1N0YXRlOiBERkFTdGF0ZSA9IG5ldyBERkFTdGF0ZShjb25maWdzLmNsb25lKHRydWUpKTtcclxuXHJcblx0XHRsZXQgZmlyc3RDb25maWdXaXRoUnVsZVN0b3BTdGF0ZTogQVROQ29uZmlnIHwgdW5kZWZpbmVkO1xyXG5cdFx0Zm9yIChsZXQgYyBvZiBjb25maWdzKSB7XHJcblx0XHRcdGlmIChjLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xyXG5cdFx0XHRcdGZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGUgPSBjO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRsZXQgcHJlZGljdGlvbjogbnVtYmVyID0gdGhpcy5hdG4ucnVsZVRvVG9rZW5UeXBlW2ZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGUuc3RhdGUucnVsZUluZGV4XTtcclxuXHRcdFx0bGV0IGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQgPSBmaXJzdENvbmZpZ1dpdGhSdWxlU3RvcFN0YXRlLmxleGVyQWN0aW9uRXhlY3V0b3I7XHJcblx0XHRcdG5ld1N0YXRlLmFjY2VwdFN0YXRlSW5mbyA9IG5ldyBBY2NlcHRTdGF0ZUluZm8ocHJlZGljdGlvbiwgbGV4ZXJBY3Rpb25FeGVjdXRvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXRuLm1vZGVUb0RGQVt0aGlzLm1vZGVdLmFkZFN0YXRlKG5ld1N0YXRlKTtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGdldERGQShtb2RlOiBudW1iZXIpOiBERkEge1xyXG5cdFx0cmV0dXJuIHRoaXMuYXRuLm1vZGVUb0RGQVttb2RlXTtcclxuXHR9XHJcblxyXG5cdC8qKiBHZXQgdGhlIHRleHQgbWF0Y2hlZCBzbyBmYXIgZm9yIHRoZSBjdXJyZW50IHRva2VuLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGdldFRleHQoQE5vdE51bGwgaW5wdXQ6IENoYXJTdHJlYW0pOiBzdHJpbmcge1xyXG5cdFx0Ly8gaW5kZXggaXMgZmlyc3QgbG9va2FoZWFkIGNoYXIsIGRvbid0IGluY2x1ZGUuXHJcblx0XHRyZXR1cm4gaW5wdXQuZ2V0VGV4dChJbnRlcnZhbC5vZih0aGlzLnN0YXJ0SW5kZXgsIGlucHV0LmluZGV4IC0gMSkpO1xyXG5cdH1cclxuXHJcblx0Z2V0IGxpbmUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9saW5lO1xyXG5cdH1cclxuXHJcblx0c2V0IGxpbmUobGluZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLl9saW5lID0gbGluZTtcclxuXHR9XHJcblxyXG5cdGdldCBjaGFyUG9zaXRpb25JbkxpbmUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0fVxyXG5cclxuXHRzZXQgY2hhclBvc2l0aW9uSW5MaW5lKGNoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmUgPSBjaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY29uc3VtZShATm90TnVsbCBpbnB1dDogQ2hhclN0cmVhbSk6IHZvaWQge1xyXG5cdFx0bGV0IGN1ckNoYXI6IG51bWJlciA9IGlucHV0LkxBKDEpO1xyXG5cdFx0aWYgKGN1ckNoYXIgPT09IFwiXFxuXCIuY2hhckNvZGVBdCgwKSkge1xyXG5cdFx0XHR0aGlzLl9saW5lKys7XHJcblx0XHRcdHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSA9IDA7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmUrKztcclxuXHRcdH1cclxuXHRcdGlucHV0LmNvbnN1bWUoKTtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGdldFRva2VuTmFtZSh0OiBudW1iZXIpOiBzdHJpbmcge1xyXG5cdFx0aWYgKHQgPT09IC0xKSB7XHJcblx0XHRcdHJldHVybiBcIkVPRlwiO1xyXG5cdFx0fVxyXG5cdFx0Ly9pZiAoIGF0bi5nIT1udWxsICkgcmV0dXJuIGF0bi5nLmdldFRva2VuRGlzcGxheU5hbWUodCk7XHJcblx0XHRyZXR1cm4gXCInXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHQpICsgXCInXCI7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIExleGVyQVROU2ltdWxhdG9yIHtcclxuXHRleHBvcnQgY29uc3QgZGVidWc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRleHBvcnQgY29uc3QgZGZhX2RlYnVnOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdC8qKiBXaGVuIHdlIGhpdCBhbiBhY2NlcHQgc3RhdGUgaW4gZWl0aGVyIHRoZSBERkEgb3IgdGhlIEFUTiwgd2VcclxuXHQgKiAgaGF2ZSB0byBub3RpZnkgdGhlIGNoYXJhY3RlciBzdHJlYW0gdG8gc3RhcnQgYnVmZmVyaW5nIGNoYXJhY3RlcnNcclxuXHQgKiAgdmlhIHtAbGluayBJbnRTdHJlYW0jbWFya30gYW5kIHJlY29yZCB0aGUgY3VycmVudCBzdGF0ZS4gVGhlIGN1cnJlbnQgc2ltIHN0YXRlXHJcblx0ICogIGluY2x1ZGVzIHRoZSBjdXJyZW50IGluZGV4IGludG8gdGhlIGlucHV0LCB0aGUgY3VycmVudCBsaW5lLFxyXG5cdCAqICBhbmQgY3VycmVudCBjaGFyYWN0ZXIgcG9zaXRpb24gaW4gdGhhdCBsaW5lLiBOb3RlIHRoYXQgdGhlIExleGVyIGlzXHJcblx0ICogIHRyYWNraW5nIHRoZSBzdGFydGluZyBsaW5lIGFuZCBjaGFyYWN0ZXJpemF0aW9uIG9mIHRoZSB0b2tlbi4gVGhlc2VcclxuXHQgKiAgdmFyaWFibGVzIHRyYWNrIHRoZSBcInN0YXRlXCIgb2YgdGhlIHNpbXVsYXRvciB3aGVuIGl0IGhpdHMgYW4gYWNjZXB0IHN0YXRlLlxyXG5cdCAqXHJcblx0ICogIFdlIHRyYWNrIHRoZXNlIHZhcmlhYmxlcyBzZXBhcmF0ZWx5IGZvciB0aGUgREZBIGFuZCBBVE4gc2ltdWxhdGlvblxyXG5cdCAqICBiZWNhdXNlIHRoZSBERkEgc2ltdWxhdGlvbiBvZnRlbiBoYXMgdG8gZmFpbCBvdmVyIHRvIHRoZSBBVE5cclxuXHQgKiAgc2ltdWxhdGlvbi4gSWYgdGhlIEFUTiBzaW11bGF0aW9uIGZhaWxzLCB3ZSBuZWVkIHRoZSBERkEgdG8gZmFsbFxyXG5cdCAqICBiYWNrIHRvIGl0cyBwcmV2aW91c2x5IGFjY2VwdGVkIHN0YXRlLCBpZiBhbnkuIElmIHRoZSBBVE4gc3VjY2VlZHMsXHJcblx0ICogIHRoZW4gdGhlIEFUTiBkb2VzIHRoZSBhY2NlcHQgYW5kIHRoZSBERkEgc2ltdWxhdG9yIHRoYXQgaW52b2tlZCBpdFxyXG5cdCAqICBjYW4gc2ltcGx5IHJldHVybiB0aGUgcHJlZGljdGVkIHRva2VuIHR5cGUuXHJcblx0ICovXHJcblx0ZXhwb3J0IGNsYXNzIFNpbVN0YXRlIHtcclxuXHRcdHB1YmxpYyBpbmRleDogbnVtYmVyID0gLTE7XHJcblx0XHRwdWJsaWMgbGluZTogbnVtYmVyID0gMDtcclxuXHRcdHB1YmxpYyBjaGFyUG9zOiBudW1iZXIgPSAtMTtcclxuXHRcdHB1YmxpYyBkZmFTdGF0ZT86IERGQVN0YXRlO1xyXG5cclxuXHRcdHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuXHRcdFx0dGhpcy5pbmRleCA9IC0xO1xyXG5cdFx0XHR0aGlzLmxpbmUgPSAwO1xyXG5cdFx0XHR0aGlzLmNoYXJQb3MgPSAtMTtcclxuXHRcdFx0dGhpcy5kZmFTdGF0ZSA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUxLjc5MTMzMTgtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFOVExSRXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL0FOVExSRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBDaGFyU3RyZWFtIH0gZnJvbSBcIi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBDb21tb25Ub2tlbkZhY3RvcnkgfSBmcm9tIFwiLi9Db21tb25Ub2tlbkZhY3RvcnlcIjtcclxuaW1wb3J0IHsgSW50ZWdlclN0YWNrIH0gZnJvbSBcIi4vbWlzYy9JbnRlZ2VyU3RhY2tcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IEludFN0cmVhbSB9IGZyb20gXCIuL0ludFN0cmVhbVwiO1xyXG5pbXBvcnQgeyBMZXhlckFUTlNpbXVsYXRvciB9IGZyb20gXCIuL2F0bi9MZXhlckFUTlNpbXVsYXRvclwiO1xyXG5pbXBvcnQgeyBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uIH0gZnJvbSBcIi4vTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4vUmVjb2duaXplclwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuRmFjdG9yeSB9IGZyb20gXCIuL1Rva2VuRmFjdG9yeVwiO1xyXG5pbXBvcnQgeyBUb2tlblNvdXJjZSB9IGZyb20gXCIuL1Rva2VuU291cmNlXCI7XHJcblxyXG4vKiogQSBsZXhlciBpcyByZWNvZ25pemVyIHRoYXQgZHJhd3MgaW5wdXQgc3ltYm9scyBmcm9tIGEgY2hhcmFjdGVyIHN0cmVhbS5cclxuICogIGxleGVyIGdyYW1tYXJzIHJlc3VsdCBpbiBhIHN1YmNsYXNzIG9mIHRoaXMgb2JqZWN0LiBBIExleGVyIG9iamVjdFxyXG4gKiAgdXNlcyBzaW1wbGlmaWVkIG1hdGNoKCkgYW5kIGVycm9yIHJlY292ZXJ5IG1lY2hhbmlzbXMgaW4gdGhlIGludGVyZXN0XHJcbiAqICBvZiBzcGVlZC5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMZXhlciBleHRlbmRzIFJlY29nbml6ZXI8bnVtYmVyLCBMZXhlckFUTlNpbXVsYXRvcj5cclxuXHRpbXBsZW1lbnRzIFRva2VuU291cmNlIHtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfTU9ERTogbnVtYmVyID0gMDtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE1PUkU6IG51bWJlciA9IC0yO1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU0tJUDogbnVtYmVyID0gLTM7XHJcblxyXG5cdHN0YXRpYyBnZXQgREVGQVVMVF9UT0tFTl9DSEFOTkVMKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gVG9rZW4uREVGQVVMVF9DSEFOTkVMO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldCBISURERU4oKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBUb2tlbi5ISURERU5fQ0hBTk5FTDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTUlOX0NIQVJfVkFMVUU6IG51bWJlciA9IDB4MDAwMDtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE1BWF9DSEFSX1ZBTFVFOiBudW1iZXIgPSAweDEwRkZGRjtcclxuXHJcblx0cHVibGljIF9pbnB1dDogQ2hhclN0cmVhbTtcclxuXHJcblx0cHJvdGVjdGVkIF90b2tlbkZhY3RvcnlTb3VyY2VQYWlyOiB7IHNvdXJjZTogVG9rZW5Tb3VyY2UsIHN0cmVhbTogQ2hhclN0cmVhbSB9O1xyXG5cclxuXHQvKiogSG93IHRvIGNyZWF0ZSB0b2tlbiBvYmplY3RzICovXHJcblx0cHJvdGVjdGVkIF9mYWN0b3J5OiBUb2tlbkZhY3RvcnkgPSBDb21tb25Ub2tlbkZhY3RvcnkuREVGQVVMVDtcclxuXHJcblx0LyoqIFRoZSBnb2FsIG9mIGFsbCBsZXhlciBydWxlcy9tZXRob2RzIGlzIHRvIGNyZWF0ZSBhIHRva2VuIG9iamVjdC5cclxuXHQgKiAgVGhpcyBpcyBhbiBpbnN0YW5jZSB2YXJpYWJsZSBhcyBtdWx0aXBsZSBydWxlcyBtYXkgY29sbGFib3JhdGUgdG9cclxuXHQgKiAgY3JlYXRlIGEgc2luZ2xlIHRva2VuLiAgbmV4dFRva2VuIHdpbGwgcmV0dXJuIHRoaXMgb2JqZWN0IGFmdGVyXHJcblx0ICogIG1hdGNoaW5nIGxleGVyIHJ1bGUocykuICBJZiB5b3Ugc3ViY2xhc3MgdG8gYWxsb3cgbXVsdGlwbGUgdG9rZW5cclxuXHQgKiAgZW1pc3Npb25zLCB0aGVuIHNldCB0aGlzIHRvIHRoZSBsYXN0IHRva2VuIHRvIGJlIG1hdGNoZWQgb3JcclxuXHQgKiAgc29tZXRoaW5nIG5vbi11bmRlZmluZWQgc28gdGhhdCB0aGUgYXV0byB0b2tlbiBlbWl0IG1lY2hhbmlzbSB3aWxsIG5vdFxyXG5cdCAqICBlbWl0IGFub3RoZXIgdG9rZW4uXHJcblx0ICovXHJcblx0cHVibGljIF90b2tlbjogVG9rZW4gfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKiBXaGF0IGNoYXJhY3RlciBpbmRleCBpbiB0aGUgc3RyZWFtIGRpZCB0aGUgY3VycmVudCB0b2tlbiBzdGFydCBhdD9cclxuXHQgKiAgTmVlZGVkLCBmb3IgZXhhbXBsZSwgdG8gZ2V0IHRoZSB0ZXh0IGZvciBjdXJyZW50IHRva2VuLiAgU2V0IGF0XHJcblx0ICogIHRoZSBzdGFydCBvZiBuZXh0VG9rZW4uXHJcblx0ICovXHJcblx0cHVibGljIF90b2tlblN0YXJ0Q2hhckluZGV4OiBudW1iZXIgPSAtMTtcclxuXHJcblx0LyoqIFRoZSBsaW5lIG9uIHdoaWNoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHRva2VuIHJlc2lkZXMgKi9cclxuXHRwdWJsaWMgX3Rva2VuU3RhcnRMaW5lOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKiogVGhlIGNoYXJhY3RlciBwb3NpdGlvbiBvZiBmaXJzdCBjaGFyYWN0ZXIgd2l0aGluIHRoZSBsaW5lICovXHJcblx0cHVibGljIF90b2tlblN0YXJ0Q2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKiogT25jZSB3ZSBzZWUgRU9GIG9uIGNoYXIgc3RyZWFtLCBuZXh0IHRva2VuIHdpbGwgYmUgRU9GLlxyXG5cdCAqICBJZiB5b3UgaGF2ZSBET05FIDogRU9GIDsgdGhlbiB5b3Ugc2VlIERPTkUgRU9GLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBfaGl0RU9GOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdC8qKiBUaGUgY2hhbm5lbCBudW1iZXIgZm9yIHRoZSBjdXJyZW50IHRva2VuICovXHJcblx0cHVibGljIF9jaGFubmVsOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKiogVGhlIHRva2VuIHR5cGUgZm9yIHRoZSBjdXJyZW50IHRva2VuICovXHJcblx0cHVibGljIF90eXBlOiBudW1iZXIgPSAwO1xyXG5cclxuXHRwdWJsaWMgcmVhZG9ubHkgX21vZGVTdGFjazogSW50ZWdlclN0YWNrID0gbmV3IEludGVnZXJTdGFjaygpO1xyXG5cdHB1YmxpYyBfbW9kZTogbnVtYmVyID0gTGV4ZXIuREVGQVVMVF9NT0RFO1xyXG5cclxuXHQvKiogWW91IGNhbiBzZXQgdGhlIHRleHQgZm9yIHRoZSBjdXJyZW50IHRva2VuIHRvIG92ZXJyaWRlIHdoYXQgaXMgaW5cclxuXHQgKiAgdGhlIGlucHV0IGNoYXIgYnVmZmVyLiAgU2V0IGB0ZXh0YCBvciBjYW4gc2V0IHRoaXMgaW5zdGFuY2UgdmFyLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBfdGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihpbnB1dDogQ2hhclN0cmVhbSkge1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMuX2lucHV0ID0gaW5wdXQ7XHJcblx0XHR0aGlzLl90b2tlbkZhY3RvcnlTb3VyY2VQYWlyID0geyBzb3VyY2U6IHRoaXMsIHN0cmVhbTogaW5wdXQgfTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyByZXNldCgpOiB2b2lkO1xyXG5cdHB1YmxpYyByZXNldChyZXNldElucHV0OiBib29sZWFuKTogdm9pZDtcclxuXHRwdWJsaWMgcmVzZXQocmVzZXRJbnB1dD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdC8vIHdhY2sgTGV4ZXIgc3RhdGUgdmFyaWFibGVzXHJcblx0XHRpZiAocmVzZXRJbnB1dCA9PT0gdW5kZWZpbmVkIHx8IHJlc2V0SW5wdXQpIHtcclxuXHRcdFx0dGhpcy5faW5wdXQuc2VlaygwKTsgLy8gcmV3aW5kIHRoZSBpbnB1dFxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3Rva2VuID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5fdHlwZSA9IFRva2VuLklOVkFMSURfVFlQRTtcclxuXHRcdHRoaXMuX2NoYW5uZWwgPSBUb2tlbi5ERUZBVUxUX0NIQU5ORUw7XHJcblx0XHR0aGlzLl90b2tlblN0YXJ0Q2hhckluZGV4ID0gLTE7XHJcblx0XHR0aGlzLl90b2tlblN0YXJ0Q2hhclBvc2l0aW9uSW5MaW5lID0gLTE7XHJcblx0XHR0aGlzLl90b2tlblN0YXJ0TGluZSA9IC0xO1xyXG5cdFx0dGhpcy5fdGV4dCA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHR0aGlzLl9oaXRFT0YgPSBmYWxzZTtcclxuXHRcdHRoaXMuX21vZGUgPSBMZXhlci5ERUZBVUxUX01PREU7XHJcblx0XHR0aGlzLl9tb2RlU3RhY2suY2xlYXIoKTtcclxuXHJcblx0XHR0aGlzLmludGVycHJldGVyLnJlc2V0KCk7XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIGEgdG9rZW4gZnJvbSB0aGlzIHNvdXJjZTsgaS5lLiwgbWF0Y2ggYSB0b2tlbiBvbiB0aGUgY2hhclxyXG5cdCAqICBzdHJlYW0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG5leHRUb2tlbigpOiBUb2tlbiB7XHJcblx0XHRpZiAodGhpcy5faW5wdXQgPT0gbnVsbCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJuZXh0VG9rZW4gcmVxdWlyZXMgYSBub24tbnVsbCBpbnB1dCBzdHJlYW0uXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1hcmsgc3RhcnQgbG9jYXRpb24gaW4gY2hhciBzdHJlYW0gc28gdW5idWZmZXJlZCBzdHJlYW1zIGFyZVxyXG5cdFx0Ly8gZ3VhcmFudGVlZCBhdCBsZWFzdCBoYXZlIHRleHQgb2YgY3VycmVudCB0b2tlblxyXG5cdFx0bGV0IHRva2VuU3RhcnRNYXJrZXI6IG51bWJlciA9IHRoaXMuX2lucHV0Lm1hcmsoKTtcclxuXHRcdHRyeSB7XHJcblx0XHRcdG91dGVyOlxyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9oaXRFT0YpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmVtaXRFT0YoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX3Rva2VuID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdHRoaXMuX2NoYW5uZWwgPSBUb2tlbi5ERUZBVUxUX0NIQU5ORUw7XHJcblx0XHRcdFx0dGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCA9IHRoaXMuX2lucHV0LmluZGV4O1xyXG5cdFx0XHRcdHRoaXMuX3Rva2VuU3RhcnRDaGFyUG9zaXRpb25JbkxpbmUgPSB0aGlzLmludGVycHJldGVyLmNoYXJQb3NpdGlvbkluTGluZTtcclxuXHRcdFx0XHR0aGlzLl90b2tlblN0YXJ0TGluZSA9IHRoaXMuaW50ZXJwcmV0ZXIubGluZTtcclxuXHRcdFx0XHR0aGlzLl90ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdGRvIHtcclxuXHRcdFx0XHRcdHRoaXMuX3R5cGUgPSBUb2tlbi5JTlZBTElEX1RZUEU7XHJcbi8vXHRcdFx0XHRTeXN0ZW0ub3V0LnByaW50bG4oXCJuZXh0VG9rZW4gbGluZSBcIit0b2tlblN0YXJ0TGluZStcIiBhdCBcIisoKGNoYXIpaW5wdXQuTEEoMSkpK1xyXG4vL1x0XHRcdFx0XHRcdFx0XHQgICBcIiBpbiBtb2RlIFwiK21vZGUrXHJcbi8vXHRcdFx0XHRcdFx0XHRcdCAgIFwiIGF0IGluZGV4IFwiK2lucHV0LmluZGV4KTtcclxuXHRcdFx0XHRcdGxldCB0dHlwZTogbnVtYmVyO1xyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0dHR5cGUgPSB0aGlzLmludGVycHJldGVyLm1hdGNoKHRoaXMuX2lucHV0LCB0aGlzLl9tb2RlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRcdGlmIChlIGluc3RhbmNlb2YgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbikge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMubm90aWZ5TGlzdGVuZXJzKGUpO1x0XHQvLyByZXBvcnQgZXJyb3JcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnJlY292ZXIoZSk7XHJcblx0XHRcdFx0XHRcdFx0dHR5cGUgPSBMZXhlci5TS0lQO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93IGU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICh0aGlzLl9pbnB1dC5MQSgxKSA9PT0gSW50U3RyZWFtLkVPRikge1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9oaXRFT0YgPSB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3R5cGUgPT09IFRva2VuLklOVkFMSURfVFlQRSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLl90eXBlID0gdHR5cGU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gTGV4ZXIuU0tJUCkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZSBvdXRlcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IHdoaWxlICh0aGlzLl90eXBlID09PSBMZXhlci5NT1JFKTtcclxuXHRcdFx0XHRpZiAodGhpcy5fdG9rZW4gPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZW1pdCgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG9rZW47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZpbmFsbHkge1xyXG5cdFx0XHQvLyBtYWtlIHN1cmUgd2UgcmVsZWFzZSBtYXJrZXIgYWZ0ZXIgbWF0Y2ggb3JcclxuXHRcdFx0Ly8gdW5idWZmZXJlZCBjaGFyIHN0cmVhbSB3aWxsIGtlZXAgYnVmZmVyaW5nXHJcblx0XHRcdHRoaXMuX2lucHV0LnJlbGVhc2UodG9rZW5TdGFydE1hcmtlcik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogSW5zdHJ1Y3QgdGhlIGxleGVyIHRvIHNraXAgY3JlYXRpbmcgYSB0b2tlbiBmb3IgY3VycmVudCBsZXhlciBydWxlXHJcblx0ICogIGFuZCBsb29rIGZvciBhbm90aGVyIHRva2VuLiAgbmV4dFRva2VuKCkga25vd3MgdG8ga2VlcCBsb29raW5nIHdoZW5cclxuXHQgKiAgYSBsZXhlciBydWxlIGZpbmlzaGVzIHdpdGggdG9rZW4gc2V0IHRvIFNLSVBfVE9LRU4uICBSZWNhbGwgdGhhdFxyXG5cdCAqICBpZiB0b2tlbj09dW5kZWZpbmVkIGF0IGVuZCBvZiBhbnkgdG9rZW4gcnVsZSwgaXQgY3JlYXRlcyBvbmUgZm9yIHlvdVxyXG5cdCAqICBhbmQgZW1pdHMgaXQuXHJcblx0ICovXHJcblx0cHVibGljIHNraXAoKTogdm9pZCB7XHJcblx0XHR0aGlzLl90eXBlID0gTGV4ZXIuU0tJUDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBtb3JlKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5fdHlwZSA9IExleGVyLk1PUkU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgbW9kZShtOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMuX21vZGUgPSBtO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHB1c2hNb2RlKG06IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwicHVzaE1vZGUgXCIgKyBtKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX21vZGVTdGFjay5wdXNoKHRoaXMuX21vZGUpO1xyXG5cdFx0dGhpcy5tb2RlKG0pO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHBvcE1vZGUoKTogbnVtYmVyIHtcclxuXHRcdGlmICh0aGlzLl9tb2RlU3RhY2suaXNFbXB0eSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eVN0YWNrRXhjZXB0aW9uXCIpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwicG9wTW9kZSBiYWNrIHRvIFwiICsgdGhpcy5fbW9kZVN0YWNrLnBlZWsoKSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLm1vZGUodGhpcy5fbW9kZVN0YWNrLnBvcCgpKTtcclxuXHRcdHJldHVybiB0aGlzLl9tb2RlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHRva2VuRmFjdG9yeSgpOiBUb2tlbkZhY3Rvcnkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ZhY3Rvcnk7XHJcblx0fVxyXG5cclxuXHQvLyBAT3ZlcnJpZGVcclxuXHRzZXQgdG9rZW5GYWN0b3J5KGZhY3Rvcnk6IFRva2VuRmFjdG9yeSkge1xyXG5cdFx0dGhpcy5fZmFjdG9yeSA9IGZhY3Rvcnk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaW5wdXRTdHJlYW0oKTogQ2hhclN0cmVhbSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW5wdXQ7XHJcblx0fVxyXG5cclxuXHQvKiogU2V0IHRoZSBjaGFyIHN0cmVhbSBhbmQgcmVzZXQgdGhlIGxleGVyICovXHJcblx0c2V0IGlucHV0U3RyZWFtKGlucHV0OiBDaGFyU3RyZWFtKSB7XHJcblx0XHR0aGlzLnJlc2V0KGZhbHNlKTtcclxuXHRcdHRoaXMuX2lucHV0ID0gaW5wdXQ7XHJcblx0XHR0aGlzLl90b2tlbkZhY3RvcnlTb3VyY2VQYWlyID0geyBzb3VyY2U6IHRoaXMsIHN0cmVhbTogdGhpcy5faW5wdXQgfTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzb3VyY2VOYW1lKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW5wdXQuc291cmNlTmFtZTtcclxuXHR9XHJcblxyXG5cclxuXHQvKiogVGhlIHN0YW5kYXJkIG1ldGhvZCBjYWxsZWQgdG8gYXV0b21hdGljYWxseSBlbWl0IGEgdG9rZW4gYXQgdGhlXHJcblx0ICogIG91dGVybW9zdCBsZXhpY2FsIHJ1bGUuICBUaGUgdG9rZW4gb2JqZWN0IHNob3VsZCBwb2ludCBpbnRvIHRoZVxyXG5cdCAqICBjaGFyIGJ1ZmZlciBzdGFydC4uc3RvcC4gIElmIHRoZXJlIGlzIGEgdGV4dCBvdmVycmlkZSBpbiAndGV4dCcsXHJcblx0ICogIHVzZSB0aGF0IHRvIHNldCB0aGUgdG9rZW4ncyB0ZXh0LiAgT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZW1pdFxyXG5cdCAqICBjdXN0b20gVG9rZW4gb2JqZWN0cyBvciBwcm92aWRlIGEgbmV3IGZhY3RvcnkuXHJcblx0ICovXHJcblx0cHVibGljIGVtaXQodG9rZW46IFRva2VuKTogVG9rZW47XHJcblxyXG5cdC8qKiBCeSBkZWZhdWx0IGRvZXMgbm90IHN1cHBvcnQgbXVsdGlwbGUgZW1pdHMgcGVyIG5leHRUb2tlbiBpbnZvY2F0aW9uXHJcblx0ICogIGZvciBlZmZpY2llbmN5IHJlYXNvbnMuICBTdWJjbGFzcyBhbmQgb3ZlcnJpZGUgdGhpcyBtZXRob2QsIG5leHRUb2tlbixcclxuXHQgKiAgYW5kIGdldFRva2VuICh0byBwdXNoIHRva2VucyBpbnRvIGEgbGlzdCBhbmQgcHVsbCBmcm9tIHRoYXQgbGlzdFxyXG5cdCAqICByYXRoZXIgdGhhbiBhIHNpbmdsZSB2YXJpYWJsZSBhcyB0aGlzIGltcGxlbWVudGF0aW9uIGRvZXMpLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBlbWl0KCk6IFRva2VuO1xyXG5cclxuXHRwdWJsaWMgZW1pdCh0b2tlbj86IFRva2VuKTogVG9rZW4ge1xyXG5cdFx0aWYgKCF0b2tlbikge1xyXG5cdFx0XHR0b2tlbiA9IHRoaXMuX2ZhY3RvcnkuY3JlYXRlKFxyXG5cdFx0XHRcdHRoaXMuX3Rva2VuRmFjdG9yeVNvdXJjZVBhaXIsIHRoaXMuX3R5cGUsIHRoaXMuX3RleHQsIHRoaXMuX2NoYW5uZWwsXHJcblx0XHRcdFx0dGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCwgdGhpcy5jaGFySW5kZXggLSAxLCB0aGlzLl90b2tlblN0YXJ0TGluZSxcclxuXHRcdFx0XHR0aGlzLl90b2tlblN0YXJ0Q2hhclBvc2l0aW9uSW5MaW5lKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3Rva2VuID0gdG9rZW47XHJcblx0XHRyZXR1cm4gdG9rZW47XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZW1pdEVPRigpOiBUb2tlbiB7XHJcblx0XHRsZXQgY3BvczogbnVtYmVyID0gdGhpcy5jaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0XHRsZXQgbGluZTogbnVtYmVyID0gdGhpcy5saW5lO1xyXG5cdFx0bGV0IGVvZjogVG9rZW4gPSB0aGlzLl9mYWN0b3J5LmNyZWF0ZShcclxuXHRcdFx0dGhpcy5fdG9rZW5GYWN0b3J5U291cmNlUGFpciwgVG9rZW4uRU9GLCB1bmRlZmluZWQsXHJcblx0XHRcdFRva2VuLkRFRkFVTFRfQ0hBTk5FTCwgdGhpcy5faW5wdXQuaW5kZXgsIHRoaXMuX2lucHV0LmluZGV4IC0gMSxcclxuXHRcdFx0bGluZSwgY3Bvcyk7XHJcblx0XHR0aGlzLmVtaXQoZW9mKTtcclxuXHRcdHJldHVybiBlb2Y7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgbGluZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJwcmV0ZXIubGluZTtcclxuXHR9XHJcblxyXG5cdHNldCBsaW5lKGxpbmU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5pbnRlcnByZXRlci5saW5lID0gbGluZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBjaGFyUG9zaXRpb25JbkxpbmUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmludGVycHJldGVyLmNoYXJQb3NpdGlvbkluTGluZTtcclxuXHR9XHJcblxyXG5cdHNldCBjaGFyUG9zaXRpb25JbkxpbmUoY2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuaW50ZXJwcmV0ZXIuY2hhclBvc2l0aW9uSW5MaW5lID0gY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdH1cclxuXHJcblx0LyoqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlciBvZiBsb29rYWhlYWQ/ICovXHJcblx0Z2V0IGNoYXJJbmRleCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2lucHV0LmluZGV4O1xyXG5cdH1cclxuXHJcblx0LyoqIFJldHVybiB0aGUgdGV4dCBtYXRjaGVkIHNvIGZhciBmb3IgdGhlIGN1cnJlbnQgdG9rZW4gb3IgYW55XHJcblx0ICogIHRleHQgb3ZlcnJpZGUuXHJcblx0ICovXHJcblx0Z2V0IHRleHQoKTogc3RyaW5nIHtcclxuXHRcdGlmICh0aGlzLl90ZXh0ICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX3RleHQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnByZXRlci5nZXRUZXh0KHRoaXMuX2lucHV0KTtcclxuXHR9XHJcblxyXG5cdC8qKiBTZXQgdGhlIGNvbXBsZXRlIHRleHQgb2YgdGhpcyB0b2tlbjsgaXQgd2lwZXMgYW55IHByZXZpb3VzXHJcblx0ICogIGNoYW5nZXMgdG8gdGhlIHRleHQuXHJcblx0ICovXHJcblx0c2V0IHRleHQodGV4dDogc3RyaW5nKSB7XHJcblx0XHR0aGlzLl90ZXh0ID0gdGV4dDtcclxuXHR9XHJcblxyXG5cdC8qKiBPdmVycmlkZSBpZiBlbWl0dGluZyBtdWx0aXBsZSB0b2tlbnMuICovXHJcblx0Z2V0IHRva2VuKCk6IFRva2VuIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMuX3Rva2VuOyB9XHJcblxyXG5cdHNldCB0b2tlbihfdG9rZW46IFRva2VuIHwgdW5kZWZpbmVkKSB7XHJcblx0XHR0aGlzLl90b2tlbiA9IF90b2tlbjtcclxuXHR9XHJcblxyXG5cdHNldCB0eXBlKHR0eXBlOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuX3R5cGUgPSB0dHlwZTtcclxuXHR9XHJcblxyXG5cdGdldCB0eXBlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcclxuXHR9XHJcblxyXG5cdHNldCBjaGFubmVsKGNoYW5uZWw6IG51bWJlcikge1xyXG5cdFx0dGhpcy5fY2hhbm5lbCA9IGNoYW5uZWw7XHJcblx0fVxyXG5cclxuXHRnZXQgY2hhbm5lbCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NoYW5uZWw7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgY2hhbm5lbE5hbWVzOiBzdHJpbmdbXTtcclxuXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IG1vZGVOYW1lczogc3RyaW5nW107XHJcblxyXG5cdC8qKiBSZXR1cm4gYSBsaXN0IG9mIGFsbCBUb2tlbiBvYmplY3RzIGluIGlucHV0IGNoYXIgc3RyZWFtLlxyXG5cdCAqICBGb3JjZXMgbG9hZCBvZiBhbGwgdG9rZW5zLiBEb2VzIG5vdCBpbmNsdWRlIEVPRiB0b2tlbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0QWxsVG9rZW5zKCk6IFRva2VuW10ge1xyXG5cdFx0bGV0IHRva2VuczogVG9rZW5bXSA9IFtdO1xyXG5cdFx0bGV0IHQ6IFRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHRcdHdoaWxlICh0LnR5cGUgIT09IFRva2VuLkVPRikge1xyXG5cdFx0XHR0b2tlbnMucHVzaCh0KTtcclxuXHRcdFx0dCA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdG9rZW5zO1xyXG5cdH1cclxuXHJcblx0cHVibGljIG5vdGlmeUxpc3RlbmVycyhlOiBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKTogdm9pZCB7XHJcblx0XHRsZXQgdGV4dDogc3RyaW5nID0gdGhpcy5faW5wdXQuZ2V0VGV4dChcclxuXHRcdFx0SW50ZXJ2YWwub2YodGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCwgdGhpcy5faW5wdXQuaW5kZXgpKTtcclxuXHRcdGxldCBtc2c6IHN0cmluZyA9IFwidG9rZW4gcmVjb2duaXRpb24gZXJyb3IgYXQ6ICdcIiArXHJcblx0XHRcdHRoaXMuZ2V0RXJyb3JEaXNwbGF5KHRleHQpICsgXCInXCI7XHJcblxyXG5cdFx0bGV0IGxpc3RlbmVyOiBBTlRMUkVycm9yTGlzdGVuZXI8bnVtYmVyPiA9IHRoaXMuZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCk7XHJcblx0XHRpZiAobGlzdGVuZXIuc3ludGF4RXJyb3IpIHtcclxuXHRcdFx0bGlzdGVuZXIuc3ludGF4RXJyb3IodGhpcywgdW5kZWZpbmVkLCB0aGlzLl90b2tlblN0YXJ0TGluZSwgdGhpcy5fdG9rZW5TdGFydENoYXJQb3NpdGlvbkluTGluZSwgbXNnLCBlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRFcnJvckRpc3BsYXkoczogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdGlmICh0eXBlb2YgcyA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRzd2l0Y2ggKHMpIHtcclxuXHRcdFx0Y2FzZSBUb2tlbi5FT0Y6XHJcblx0XHRcdFx0cmV0dXJuIFwiPEVPRj5cIjtcclxuXHRcdFx0Y2FzZSAweDBhOlxyXG5cdFx0XHRcdHJldHVybiBcIlxcXFxuXCI7XHJcblx0XHRcdGNhc2UgMHgwOTpcclxuXHRcdFx0XHRyZXR1cm4gXCJcXFxcdFwiO1xyXG5cdFx0XHRjYXNlIDB4MGQ6XHJcblx0XHRcdFx0cmV0dXJuIFwiXFxcXHJcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXHJcblx0XHRcdC5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKVxyXG5cdFx0XHQucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIik7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0Q2hhckVycm9yRGlzcGxheShjOiBudW1iZXIpOiBzdHJpbmcge1xyXG5cdFx0bGV0IHM6IHN0cmluZyA9IHRoaXMuZ2V0RXJyb3JEaXNwbGF5KGMpO1xyXG5cdFx0cmV0dXJuIFwiJ1wiICsgcyArIFwiJ1wiO1xyXG5cdH1cclxuXHJcblx0LyoqIExleGVycyBjYW4gbm9ybWFsbHkgbWF0Y2ggYW55IGNoYXIgaW4gaXQncyB2b2NhYnVsYXJ5IGFmdGVyIG1hdGNoaW5nXHJcblx0ICogIGEgdG9rZW4sIHNvIGRvIHRoZSBlYXN5IHRoaW5nIGFuZCBqdXN0IGtpbGwgYSBjaGFyYWN0ZXIgYW5kIGhvcGVcclxuXHQgKiAgaXQgYWxsIHdvcmtzIG91dC4gIFlvdSBjYW4gaW5zdGVhZCB1c2UgdGhlIHJ1bGUgaW52b2NhdGlvbiBzdGFja1xyXG5cdCAqICB0byBkbyBzb3BoaXN0aWNhdGVkIGVycm9yIHJlY292ZXJ5IGlmIHlvdSBhcmUgaW4gYSBmcmFnbWVudCBydWxlLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyByZWNvdmVyKHJlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbik6IHZvaWQ7XHJcblx0cHVibGljIHJlY292ZXIocmU6IExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24pOiB2b2lkO1xyXG5cdHB1YmxpYyByZWNvdmVyKHJlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbik6IHZvaWQge1xyXG5cdFx0aWYgKHJlIGluc3RhbmNlb2YgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbikge1xyXG5cdFx0XHRpZiAodGhpcy5faW5wdXQuTEEoMSkgIT09IEludFN0cmVhbS5FT0YpIHtcclxuXHRcdFx0XHQvLyBza2lwIGEgY2hhciBhbmQgdHJ5IGFnYWluXHJcblx0XHRcdFx0dGhpcy5pbnRlcnByZXRlci5jb25zdW1lKHRoaXMuX2lucHV0KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly9TeXN0ZW0ub3V0LnByaW50bG4oXCJjb25zdW1pbmcgY2hhciBcIisoY2hhcilpbnB1dC5MQSgxKStcIiBkdXJpbmcgcmVjb3ZlcnlcIik7XHJcblx0XHRcdC8vcmUucHJpbnRTdGFja1RyYWNlKCk7XHJcblx0XHRcdC8vIFRPRE86IERvIHdlIGxvc2UgY2hhcmFjdGVyIG9yIGxpbmUgcG9zaXRpb24gaW5mb3JtYXRpb24/XHJcblx0XHRcdHRoaXMuX2lucHV0LmNvbnN1bWUoKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQwLjg2ODM0ODAtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFycmF5RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4vQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgSW50ZWdlckxpc3QgfSBmcm9tIFwiLi9JbnRlZ2VyTGlzdFwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IEludFNldCB9IGZyb20gXCIuL0ludFNldFwiO1xyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4vTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSwgTm90TnVsbCB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4uL1Rva2VuXCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnkgfSBmcm9tIFwiLi4vVm9jYWJ1bGFyeVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB0aGUge0BsaW5rIEludFNldH0gYmFja2VkIGJ5IGEgc29ydGVkIGFycmF5IG9mXHJcbiAqIG5vbi1vdmVybGFwcGluZyBpbnRlcnZhbHMuIEl0IGlzIHBhcnRpY3VsYXJseSBlZmZpY2llbnQgZm9yIHJlcHJlc2VudGluZ1xyXG4gKiBsYXJnZSBjb2xsZWN0aW9ucyBvZiBudW1iZXJzLCB3aGVyZSB0aGUgbWFqb3JpdHkgb2YgZWxlbWVudHMgYXBwZWFyIGFzIHBhcnRcclxuICogb2YgYSBzZXF1ZW50aWFsIHJhbmdlIG9mIG51bWJlcnMgdGhhdCBhcmUgYWxsIHBhcnQgb2YgdGhlIHNldC4gRm9yIGV4YW1wbGUsXHJcbiAqIHRoZSBzZXQgeyAxLCAyLCAzLCA0LCA3LCA4IH0gbWF5IGJlIHJlcHJlc2VudGVkIGFzIHsgWzEsIDRdLCBbNywgOF0gfS5cclxuICpcclxuICogVGhpcyBjbGFzcyBpcyBhYmxlIHRvIHJlcHJlc2VudCBzZXRzIGNvbnRhaW5pbmcgYW55IGNvbWJpbmF0aW9uIG9mIHZhbHVlcyBpblxyXG4gKiB0aGUgcmFuZ2Uge0BsaW5rIEludGVnZXIjTUlOX1ZBTFVFfSB0byB7QGxpbmsgSW50ZWdlciNNQVhfVkFMVUV9XHJcbiAqIChpbmNsdXNpdmUpLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEludGVydmFsU2V0IGltcGxlbWVudHMgSW50U2V0IHtcclxuXHRwcml2YXRlIHN0YXRpYyBfQ09NUExFVEVfQ0hBUl9TRVQ6IEludGVydmFsU2V0O1xyXG5cdHN0YXRpYyBnZXQgQ09NUExFVEVfQ0hBUl9TRVQoKTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0aWYgKEludGVydmFsU2V0Ll9DT01QTEVURV9DSEFSX1NFVCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdEludGVydmFsU2V0Ll9DT01QTEVURV9DSEFSX1NFVCA9IEludGVydmFsU2V0Lm9mKExleGVyLk1JTl9DSEFSX1ZBTFVFLCBMZXhlci5NQVhfQ0hBUl9WQUxVRSk7XHJcblx0XHRcdEludGVydmFsU2V0Ll9DT01QTEVURV9DSEFSX1NFVC5zZXRSZWFkb25seSh0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gSW50ZXJ2YWxTZXQuX0NPTVBMRVRFX0NIQVJfU0VUO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgX0VNUFRZX1NFVDogSW50ZXJ2YWxTZXQ7XHJcblx0c3RhdGljIGdldCBFTVBUWV9TRVQoKTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0aWYgKEludGVydmFsU2V0Ll9FTVBUWV9TRVQgPT0gbnVsbCkge1xyXG5cdFx0XHRJbnRlcnZhbFNldC5fRU1QVFlfU0VUID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHRcdEludGVydmFsU2V0Ll9FTVBUWV9TRVQuc2V0UmVhZG9ubHkodHJ1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEludGVydmFsU2V0Ll9FTVBUWV9TRVQ7XHJcblx0fVxyXG5cclxuXHQvKiogVGhlIGxpc3Qgb2Ygc29ydGVkLCBkaXNqb2ludCBpbnRlcnZhbHMuICovXHJcblx0cHJpdmF0ZSBfaW50ZXJ2YWxzOiBJbnRlcnZhbFtdO1xyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5OiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGludGVydmFscz86IEludGVydmFsW10pIHtcclxuXHRcdGlmIChpbnRlcnZhbHMgIT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLl9pbnRlcnZhbHMgPSBpbnRlcnZhbHMuc2xpY2UoMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9pbnRlcnZhbHMgPSBbXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZSBhIHNldCB3aXRoIGFsbCBpbnRzIHdpdGhpbiByYW5nZSBbYS4uYl0gKGluY2x1c2l2ZSkuIElmIGIgaXMgb21pdHRlZCwgdGhlIHNldCBjb250YWlucyB0aGUgc2luZ2xlIGVsZW1lbnRcclxuXHQgKiBhLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHN0YXRpYyBvZihhOiBudW1iZXIsIGI6IG51bWJlciA9IGEpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRsZXQgczogSW50ZXJ2YWxTZXQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdHMuYWRkKGEsIGIpO1xyXG5cdFx0cmV0dXJuIHM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY2xlYXIoKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5yZWFkb25seSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBhbHRlciByZWFkb25seSBJbnRlcnZhbFNldFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbnRlcnZhbHMubGVuZ3RoID0gMDtcclxuXHR9XHJcblxyXG5cdC8qKiBBZGQgaW50ZXJ2YWw7IGkuZS4sIGFkZCBhbGwgaW50ZWdlcnMgZnJvbSBhIHRvIGIgdG8gc2V0LlxyXG5cdCAqICBJZiBiJmx0O2EsIGRvIG5vdGhpbmcuXHJcblx0ICogIEtlZXAgbGlzdCBpbiBzb3J0ZWQgb3JkZXIgKGJ5IGxlZnQgcmFuZ2UgdmFsdWUpLlxyXG5cdCAqICBJZiBvdmVybGFwLCBjb21iaW5lIHJhbmdlcy4gIEZvciBleGFtcGxlLFxyXG5cdCAqICBJZiB0aGlzIGlzIHsxLi41LCAxMC4uMjB9LCBhZGRpbmcgNi4uNyB5aWVsZHNcclxuXHQgKiAgezEuLjUsIDYuLjcsIDEwLi4yMH0uICBBZGRpbmcgNC4uOCB5aWVsZHMgezEuLjgsIDEwLi4yMH0uXHJcblx0ICovXHJcblx0cHVibGljIGFkZChhOiBudW1iZXIsIGI6IG51bWJlciA9IGEpOiB2b2lkIHtcclxuXHRcdHRoaXMuYWRkUmFuZ2UoSW50ZXJ2YWwub2YoYSwgYikpO1xyXG5cdH1cclxuXHJcblx0Ly8gY29weSBvbiB3cml0ZSBzbyB3ZSBjYW4gY2FjaGUgYS4uYSBpbnRlcnZhbHMgYW5kIHNldHMgb2YgdGhhdFxyXG5cdHByb3RlY3RlZCBhZGRSYW5nZShhZGRpdGlvbjogSW50ZXJ2YWwpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLnJlYWRvbmx5KSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImNhbid0IGFsdGVyIHJlYWRvbmx5IEludGVydmFsU2V0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vU3lzdGVtLm91dC5wcmludGxuKFwiYWRkIFwiK2FkZGl0aW9uK1wiIHRvIFwiK2ludGVydmFscy50b1N0cmluZygpKTtcclxuXHRcdGlmIChhZGRpdGlvbi5iIDwgYWRkaXRpb24uYSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmluZCBwb3NpdGlvbiBpbiBsaXN0XHJcblx0XHQvLyBVc2UgaXRlcmF0b3JzIGFzIHdlIG1vZGlmeSBsaXN0IGluIHBsYWNlXHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5faW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCByOiBJbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsc1tpXTtcclxuXHRcdFx0aWYgKGFkZGl0aW9uLmVxdWFscyhyKSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGFkZGl0aW9uLmFkamFjZW50KHIpIHx8ICFhZGRpdGlvbi5kaXNqb2ludChyKSkge1xyXG5cdFx0XHRcdC8vIG5leHQgdG8gZWFjaCBvdGhlciwgbWFrZSBhIHNpbmdsZSBsYXJnZXIgaW50ZXJ2YWxcclxuXHRcdFx0XHRsZXQgYmlnZ2VyOiBJbnRlcnZhbCA9IGFkZGl0aW9uLnVuaW9uKHIpO1xyXG5cdFx0XHRcdHRoaXMuX2ludGVydmFsc1tpXSA9IGJpZ2dlcjtcclxuXHRcdFx0XHQvLyBtYWtlIHN1cmUgd2UgZGlkbid0IGp1c3QgY3JlYXRlIGFuIGludGVydmFsIHRoYXRcclxuXHRcdFx0XHQvLyBzaG91bGQgYmUgbWVyZ2VkIHdpdGggbmV4dCBpbnRlcnZhbCBpbiBsaXN0XHJcblx0XHRcdFx0d2hpbGUgKGkgPCB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoIC0gMSkge1xyXG5cdFx0XHRcdFx0aSsrO1xyXG5cdFx0XHRcdFx0bGV0IG5leHQ6IEludGVydmFsID0gdGhpcy5faW50ZXJ2YWxzW2ldO1xyXG5cdFx0XHRcdFx0aWYgKCFiaWdnZXIuYWRqYWNlbnQobmV4dCkgJiYgYmlnZ2VyLmRpc2pvaW50KG5leHQpKSB7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIGlmIHdlIGJ1bXAgdXAgYWdhaW5zdCBvciBvdmVybGFwIG5leHQsIG1lcmdlXHJcblx0XHRcdFx0XHQvLyByZW1vdmUgdGhpcyBvbmVcclxuXHRcdFx0XHRcdHRoaXMuX2ludGVydmFscy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0XHRpLS07XHJcblx0XHRcdFx0XHQvLyBtb3ZlIGJhY2t3YXJkcyB0byB3aGF0IHdlIGp1c3Qgc2V0XHJcblx0XHRcdFx0XHR0aGlzLl9pbnRlcnZhbHNbaV0gPSBiaWdnZXIudW5pb24obmV4dCk7XHJcblx0XHRcdFx0XHQvLyBzZXQgdG8gMyBtZXJnZWQgb25lc1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZmlyc3QgY2FsbCB0byBuZXh0IGFmdGVyIHByZXZpb3VzIGR1cGxpY2F0ZXMgdGhlIHJlc3VsdFxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGFkZGl0aW9uLnN0YXJ0c0JlZm9yZURpc2pvaW50KHIpKSB7XHJcblx0XHRcdFx0Ly8gaW5zZXJ0IGJlZm9yZSByXHJcblx0XHRcdFx0dGhpcy5faW50ZXJ2YWxzLnNwbGljZShpLCAwLCBhZGRpdGlvbik7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpZiBkaXNqb2ludCBhbmQgYWZ0ZXIgciwgYSBmdXR1cmUgaXRlcmF0aW9uIHdpbGwgaGFuZGxlIGl0XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb2ssIG11c3QgYmUgYWZ0ZXIgbGFzdCBpbnRlcnZhbCAoYW5kIGRpc2pvaW50IGZyb20gbGFzdCBpbnRlcnZhbClcclxuXHRcdC8vIGp1c3QgYWRkIGl0XHJcblx0XHR0aGlzLl9pbnRlcnZhbHMucHVzaChhZGRpdGlvbik7XHJcblx0fVxyXG5cclxuXHQvKiogY29tYmluZSBhbGwgc2V0cyBpbiB0aGUgYXJyYXkgcmV0dXJuZWQgdGhlIG9yJ2QgdmFsdWUgKi9cclxuXHRwdWJsaWMgc3RhdGljIG9yKHNldHM6IEludGVydmFsU2V0W10pOiBJbnRlcnZhbFNldCB7XHJcblx0XHRsZXQgcjogSW50ZXJ2YWxTZXQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdGZvciAobGV0IHMgb2Ygc2V0cykge1xyXG5cdFx0XHRyLmFkZEFsbChzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBhZGRBbGwoc2V0OiBJbnRTZXQpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRpZiAoc2V0ID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNldCBpbnN0YW5jZW9mIEludGVydmFsU2V0KSB7XHJcblx0XHRcdGxldCBvdGhlcjogSW50ZXJ2YWxTZXQgPSBzZXQ7XHJcblx0XHRcdC8vIHdhbGsgc2V0IGFuZCBhZGQgZWFjaCBpbnRlcnZhbFxyXG5cdFx0XHRsZXQgbjogbnVtYmVyID0gb3RoZXIuX2ludGVydmFscy5sZW5ndGg7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IEk6IEludGVydmFsID0gb3RoZXIuX2ludGVydmFsc1tpXTtcclxuXHRcdFx0XHR0aGlzLmFkZChJLmEsIEkuYik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRmb3IgKGxldCB2YWx1ZSBvZiBzZXQudG9BcnJheSgpKSB7XHJcblx0XHRcdFx0dGhpcy5hZGQodmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY29tcGxlbWVudFJhbmdlKG1pbkVsZW1lbnQ6IG51bWJlciwgbWF4RWxlbWVudDogbnVtYmVyKTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGxlbWVudChJbnRlcnZhbFNldC5vZihtaW5FbGVtZW50LCBtYXhFbGVtZW50KSk7XHJcblx0fVxyXG5cclxuXHQvKioge0Bpbmhlcml0RG9jfSAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjb21wbGVtZW50KHZvY2FidWxhcnk6IEludFNldCk6IEludGVydmFsU2V0IHtcclxuXHRcdGlmICh2b2NhYnVsYXJ5LmlzTmlsKSB7XHJcblx0XHRcdC8vIG5vdGhpbmcgaW4gY29tbW9uIHdpdGggbnVsbCBzZXRcclxuXHRcdFx0cmV0dXJuIEludGVydmFsU2V0LkVNUFRZX1NFVDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdm9jYWJ1bGFyeUlTOiBJbnRlcnZhbFNldDtcclxuXHRcdGlmICh2b2NhYnVsYXJ5IGluc3RhbmNlb2YgSW50ZXJ2YWxTZXQpIHtcclxuXHRcdFx0dm9jYWJ1bGFyeUlTID0gdm9jYWJ1bGFyeTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZvY2FidWxhcnlJUyA9IG5ldyBJbnRlcnZhbFNldCgpO1xyXG5cdFx0XHR2b2NhYnVsYXJ5SVMuYWRkQWxsKHZvY2FidWxhcnkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2b2NhYnVsYXJ5SVMuc3VidHJhY3QodGhpcyk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgc3VidHJhY3QoYTogSW50U2V0KTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0aWYgKGEgPT0gbnVsbCB8fCBhLmlzTmlsKSB7XHJcblx0XHRcdHJldHVybiBuZXcgSW50ZXJ2YWxTZXQodGhpcy5faW50ZXJ2YWxzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYSBpbnN0YW5jZW9mIEludGVydmFsU2V0KSB7XHJcblx0XHRcdHJldHVybiBJbnRlcnZhbFNldC5zdWJ0cmFjdCh0aGlzLCBhKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgb3RoZXI6IEludGVydmFsU2V0ID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHRvdGhlci5hZGRBbGwoYSk7XHJcblx0XHRyZXR1cm4gSW50ZXJ2YWxTZXQuc3VidHJhY3QodGhpcywgb3RoZXIpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29tcHV0ZSB0aGUgc2V0IGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gaW50ZXJ2YWwgc2V0cy4gVGhlIHNwZWNpZmljXHJcblx0ICogb3BlcmF0aW9uIGlzIGBsZWZ0IC0gcmlnaHRgLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHN0YXRpYyBzdWJ0cmFjdChsZWZ0OiBJbnRlcnZhbFNldCwgcmlnaHQ6IEludGVydmFsU2V0KTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0aWYgKGxlZnQuaXNOaWwpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBJbnRlcnZhbFNldCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZXN1bHQ6IEludGVydmFsU2V0ID0gbmV3IEludGVydmFsU2V0KGxlZnQuX2ludGVydmFscyk7XHJcblx0XHRpZiAocmlnaHQuaXNOaWwpIHtcclxuXHRcdFx0Ly8gcmlnaHQgc2V0IGhhcyBubyBlbGVtZW50czsganVzdCByZXR1cm4gdGhlIGNvcHkgb2YgdGhlIGN1cnJlbnQgc2V0XHJcblx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJlc3VsdEk6IG51bWJlciA9IDA7XHJcblx0XHRsZXQgcmlnaHRJOiBudW1iZXIgPSAwO1xyXG5cdFx0d2hpbGUgKHJlc3VsdEkgPCByZXN1bHQuX2ludGVydmFscy5sZW5ndGggJiYgcmlnaHRJIDwgcmlnaHQuX2ludGVydmFscy5sZW5ndGgpIHtcclxuXHRcdFx0bGV0IHJlc3VsdEludGVydmFsOiBJbnRlcnZhbCA9IHJlc3VsdC5faW50ZXJ2YWxzW3Jlc3VsdEldO1xyXG5cdFx0XHRsZXQgcmlnaHRJbnRlcnZhbDogSW50ZXJ2YWwgPSByaWdodC5faW50ZXJ2YWxzW3JpZ2h0SV07XHJcblxyXG5cdFx0XHQvLyBvcGVyYXRpb246IChyZXN1bHRJbnRlcnZhbCAtIHJpZ2h0SW50ZXJ2YWwpIGFuZCB1cGRhdGUgaW5kZXhlc1xyXG5cclxuXHRcdFx0aWYgKHJpZ2h0SW50ZXJ2YWwuYiA8IHJlc3VsdEludGVydmFsLmEpIHtcclxuXHRcdFx0XHRyaWdodEkrKztcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHJpZ2h0SW50ZXJ2YWwuYSA+IHJlc3VsdEludGVydmFsLmIpIHtcclxuXHRcdFx0XHRyZXN1bHRJKys7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBiZWZvcmVDdXJyZW50OiBJbnRlcnZhbCB8IHVuZGVmaW5lZDtcclxuXHRcdFx0bGV0IGFmdGVyQ3VycmVudDogSW50ZXJ2YWwgfCB1bmRlZmluZWQ7XHJcblx0XHRcdGlmIChyaWdodEludGVydmFsLmEgPiByZXN1bHRJbnRlcnZhbC5hKSB7XHJcblx0XHRcdFx0YmVmb3JlQ3VycmVudCA9IG5ldyBJbnRlcnZhbChyZXN1bHRJbnRlcnZhbC5hLCByaWdodEludGVydmFsLmEgLSAxKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHJpZ2h0SW50ZXJ2YWwuYiA8IHJlc3VsdEludGVydmFsLmIpIHtcclxuXHRcdFx0XHRhZnRlckN1cnJlbnQgPSBuZXcgSW50ZXJ2YWwocmlnaHRJbnRlcnZhbC5iICsgMSwgcmVzdWx0SW50ZXJ2YWwuYik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChiZWZvcmVDdXJyZW50KSB7XHJcblx0XHRcdFx0aWYgKGFmdGVyQ3VycmVudCkge1xyXG5cdFx0XHRcdFx0Ly8gc3BsaXQgdGhlIGN1cnJlbnQgaW50ZXJ2YWwgaW50byB0d29cclxuXHRcdFx0XHRcdHJlc3VsdC5faW50ZXJ2YWxzW3Jlc3VsdEldID0gYmVmb3JlQ3VycmVudDtcclxuXHRcdFx0XHRcdHJlc3VsdC5faW50ZXJ2YWxzLnNwbGljZShyZXN1bHRJICsgMSwgMCwgYWZ0ZXJDdXJyZW50KTtcclxuXHRcdFx0XHRcdHJlc3VsdEkrKztcclxuXHRcdFx0XHRcdHJpZ2h0SSsrO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gcmVwbGFjZSB0aGUgY3VycmVudCBpbnRlcnZhbFxyXG5cdFx0XHRcdFx0cmVzdWx0Ll9pbnRlcnZhbHNbcmVzdWx0SV0gPSBiZWZvcmVDdXJyZW50O1xyXG5cdFx0XHRcdFx0cmVzdWx0SSsrO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGlmIChhZnRlckN1cnJlbnQpIHtcclxuXHRcdFx0XHRcdC8vIHJlcGxhY2UgdGhlIGN1cnJlbnQgaW50ZXJ2YWxcclxuXHRcdFx0XHRcdHJlc3VsdC5faW50ZXJ2YWxzW3Jlc3VsdEldID0gYWZ0ZXJDdXJyZW50O1xyXG5cdFx0XHRcdFx0cmlnaHRJKys7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHQvLyByZW1vdmUgdGhlIGN1cnJlbnQgaW50ZXJ2YWwgKHRodXMgbm8gbmVlZCB0byBpbmNyZW1lbnQgcmVzdWx0SSlcclxuXHRcdFx0XHRcdHJlc3VsdC5faW50ZXJ2YWxzLnNwbGljZShyZXN1bHRJLCAxKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIHJpZ2h0SSByZWFjaGVkIHJpZ2h0LmludGVydmFscy5zaXplLCBubyBtb3JlIGludGVydmFscyB0byBzdWJ0cmFjdCBmcm9tIHJlc3VsdC5cclxuXHRcdC8vIElmIHJlc3VsdEkgcmVhY2hlZCByZXN1bHQuaW50ZXJ2YWxzLnNpemUsIHdlIHdvdWxkIGJlIHN1YnRyYWN0aW5nIGZyb20gYW4gZW1wdHkgc2V0LlxyXG5cdFx0Ly8gRWl0aGVyIHdheSwgd2UgYXJlIGRvbmUuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG9yKGE6IEludFNldCk6IEludGVydmFsU2V0IHtcclxuXHRcdGxldCBvOiBJbnRlcnZhbFNldCA9IG5ldyBJbnRlcnZhbFNldCgpO1xyXG5cdFx0by5hZGRBbGwodGhpcyk7XHJcblx0XHRvLmFkZEFsbChhKTtcclxuXHRcdHJldHVybiBvO1xyXG5cdH1cclxuXHJcblx0LyoqIHtAaW5oZXJpdERvY30gKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgYW5kKG90aGVyOiBJbnRTZXQpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRpZiAob3RoZXIuaXNOaWwpIHsgLy98fCAhKG90aGVyIGluc3RhbmNlb2YgSW50ZXJ2YWxTZXQpICkge1xyXG5cdFx0XHQvLyBub3RoaW5nIGluIGNvbW1vbiB3aXRoIG51bGwgc2V0XHJcblx0XHRcdHJldHVybiBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbXlJbnRlcnZhbHM6IEludGVydmFsW10gPSB0aGlzLl9pbnRlcnZhbHM7XHJcblx0XHRsZXQgdGhlaXJJbnRlcnZhbHM6IEludGVydmFsW10gPSAob3RoZXIgYXMgSW50ZXJ2YWxTZXQpLl9pbnRlcnZhbHM7XHJcblx0XHRsZXQgaW50ZXJzZWN0aW9uOiBJbnRlcnZhbFNldCB8IHVuZGVmaW5lZDtcclxuXHRcdGxldCBteVNpemU6IG51bWJlciA9IG15SW50ZXJ2YWxzLmxlbmd0aDtcclxuXHRcdGxldCB0aGVpclNpemU6IG51bWJlciA9IHRoZWlySW50ZXJ2YWxzLmxlbmd0aDtcclxuXHRcdGxldCBpOiBudW1iZXIgPSAwO1xyXG5cdFx0bGV0IGo6IG51bWJlciA9IDA7XHJcblx0XHQvLyBpdGVyYXRlIGRvd24gYm90aCBpbnRlcnZhbCBsaXN0cyBsb29raW5nIGZvciBub25kaXNqb2ludCBpbnRlcnZhbHNcclxuXHRcdHdoaWxlIChpIDwgbXlTaXplICYmIGogPCB0aGVpclNpemUpIHtcclxuXHRcdFx0bGV0IG1pbmU6IEludGVydmFsID0gbXlJbnRlcnZhbHNbaV07XHJcblx0XHRcdGxldCB0aGVpcnM6IEludGVydmFsID0gdGhlaXJJbnRlcnZhbHNbal07XHJcblx0XHRcdC8vU3lzdGVtLm91dC5wcmludGxuKFwibWluZT1cIittaW5lK1wiIGFuZCB0aGVpcnM9XCIrdGhlaXJzKTtcclxuXHRcdFx0aWYgKG1pbmUuc3RhcnRzQmVmb3JlRGlzam9pbnQodGhlaXJzKSkge1xyXG5cdFx0XHRcdC8vIG1vdmUgdGhpcyBpdGVyYXRvciBsb29raW5nIGZvciBpbnRlcnZhbCB0aGF0IG1pZ2h0IG92ZXJsYXBcclxuXHRcdFx0XHRpKys7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAodGhlaXJzLnN0YXJ0c0JlZm9yZURpc2pvaW50KG1pbmUpKSB7XHJcblx0XHRcdFx0Ly8gbW92ZSBvdGhlciBpdGVyYXRvciBsb29raW5nIGZvciBpbnRlcnZhbCB0aGF0IG1pZ2h0IG92ZXJsYXBcclxuXHRcdFx0XHRqKys7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAobWluZS5wcm9wZXJseUNvbnRhaW5zKHRoZWlycykpIHtcclxuXHRcdFx0XHQvLyBvdmVybGFwLCBhZGQgaW50ZXJzZWN0aW9uLCBnZXQgbmV4dCB0aGVpcnNcclxuXHRcdFx0XHRpZiAoIWludGVyc2VjdGlvbikge1xyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3Rpb24uYWRkUmFuZ2UobWluZS5pbnRlcnNlY3Rpb24odGhlaXJzKSk7XHJcblx0XHRcdFx0aisrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHRoZWlycy5wcm9wZXJseUNvbnRhaW5zKG1pbmUpKSB7XHJcblx0XHRcdFx0Ly8gb3ZlcmxhcCwgYWRkIGludGVyc2VjdGlvbiwgZ2V0IG5leHQgbWluZVxyXG5cdFx0XHRcdGlmICghaW50ZXJzZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdGlvbi5hZGRSYW5nZShtaW5lLmludGVyc2VjdGlvbih0aGVpcnMpKTtcclxuXHRcdFx0XHRpKys7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoIW1pbmUuZGlzam9pbnQodGhlaXJzKSkge1xyXG5cdFx0XHRcdC8vIG92ZXJsYXAsIGFkZCBpbnRlcnNlY3Rpb25cclxuXHRcdFx0XHRpZiAoIWludGVyc2VjdGlvbikge1xyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3Rpb24uYWRkUmFuZ2UobWluZS5pbnRlcnNlY3Rpb24odGhlaXJzKSk7XHJcblx0XHRcdFx0Ly8gTW92ZSB0aGUgaXRlcmF0b3Igb2YgbG93ZXIgcmFuZ2UgW2EuLmJdLCBidXQgbm90XHJcblx0XHRcdFx0Ly8gdGhlIHVwcGVyIHJhbmdlIGFzIGl0IG1heSBjb250YWluIGVsZW1lbnRzIHRoYXQgd2lsbCBjb2xsaWRlXHJcblx0XHRcdFx0Ly8gd2l0aCB0aGUgbmV4dCBpdGVyYXRvci4gU28sIGlmIG1pbmU9WzAuLjExNV0gYW5kXHJcblx0XHRcdFx0Ly8gdGhlaXJzPVsxMTUuLjIwMF0sIHRoZW4gaW50ZXJzZWN0aW9uIGlzIDExNSBhbmQgbW92ZSBtaW5lXHJcblx0XHRcdFx0Ly8gYnV0IG5vdCB0aGVpcnMgYXMgdGhlaXJzIG1heSBjb2xsaWRlIHdpdGggdGhlIG5leHQgcmFuZ2VcclxuXHRcdFx0XHQvLyBpbiB0aGlzSXRlci5cclxuXHRcdFx0XHQvLyBtb3ZlIGJvdGggaXRlcmF0b3JzIHRvIG5leHQgcmFuZ2VzXHJcblx0XHRcdFx0aWYgKG1pbmUuc3RhcnRzQWZ0ZXJOb25EaXNqb2ludCh0aGVpcnMpKSB7XHJcblx0XHRcdFx0XHRqKys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHRoZWlycy5zdGFydHNBZnRlck5vbkRpc2pvaW50KG1pbmUpKSB7XHJcblx0XHRcdFx0XHRpKys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFpbnRlcnNlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBJbnRlcnZhbFNldCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb247XHJcblx0fVxyXG5cclxuXHQvKioge0Bpbmhlcml0RG9jfSAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjb250YWlucyhlbDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRsZXQgbjogbnVtYmVyID0gdGhpcy5faW50ZXJ2YWxzLmxlbmd0aDtcclxuXHRcdGxldCBsOiBudW1iZXIgPSAwO1xyXG5cdFx0bGV0IHI6IG51bWJlciA9IG4gLSAxO1xyXG5cdFx0Ly8gQmluYXJ5IHNlYXJjaCBmb3IgdGhlIGVsZW1lbnQgaW4gdGhlIChzb3J0ZWQsIGRpc2pvaW50KSBhcnJheSBvZiBpbnRlcnZhbHMuXHJcblx0XHR3aGlsZSAobCA8PSByKSB7XHJcblx0XHRcdGxldCBtOiBudW1iZXIgPSAobCArIHIpID4+IDE7XHJcblx0XHRcdGxldCBJOiBJbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsc1ttXTtcclxuXHRcdFx0bGV0IGE6IG51bWJlciA9IEkuYTtcclxuXHRcdFx0bGV0IGI6IG51bWJlciA9IEkuYjtcclxuXHRcdFx0aWYgKGIgPCBlbCkge1xyXG5cdFx0XHRcdGwgPSBtICsgMTtcclxuXHRcdFx0fSBlbHNlIGlmIChhID4gZWwpIHtcclxuXHRcdFx0XHRyID0gbSAtIDE7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gZWwgPj0gYSAmJiBlbCA8PSBiXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKioge0Bpbmhlcml0RG9jfSAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc05pbCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbnRlcnZhbHMgPT0gbnVsbCB8fCB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoID09PSAwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIHNldCBpZiBub3QgaXNOaWwuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHRoZSBtYXhpbXVtIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgc2V0LlxyXG5cdCAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiBzZXQgaXMgZW1wdHlcclxuXHQgKi9cclxuXHRnZXQgbWF4RWxlbWVudCgpOiBudW1iZXIge1xyXG5cdFx0aWYgKHRoaXMuaXNOaWwpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzZXQgaXMgZW1wdHlcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGxhc3Q6IEludGVydmFsID0gdGhpcy5faW50ZXJ2YWxzW3RoaXMuX2ludGVydmFscy5sZW5ndGggLSAxXTtcclxuXHRcdHJldHVybiBsYXN0LmI7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IGlmIG5vdCBpc05pbC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4gdGhlIG1pbmltdW0gdmFsdWUgY29udGFpbmVkIGluIHRoZSBzZXQuXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIHNldCBpcyBlbXB0eVxyXG5cdCAqL1xyXG5cdGdldCBtaW5FbGVtZW50KCk6IG51bWJlciB7XHJcblx0XHRpZiAodGhpcy5pc05pbCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNldCBpcyBlbXB0eVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5faW50ZXJ2YWxzWzBdLmE7XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIGEgbGlzdCBvZiBJbnRlcnZhbCBvYmplY3RzLiAqL1xyXG5cdGdldCBpbnRlcnZhbHMoKTogSW50ZXJ2YWxbXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW50ZXJ2YWxzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKCk7XHJcblx0XHRmb3IgKGxldCBJIG9mIHRoaXMuX2ludGVydmFscykge1xyXG5cdFx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgSS5hKTtcclxuXHRcdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIEkuYik7XHJcblx0XHR9XHJcblxyXG5cdFx0aGFzaCA9IE11cm11ckhhc2guZmluaXNoKGhhc2gsIHRoaXMuX2ludGVydmFscy5sZW5ndGggKiAyKTtcclxuXHRcdHJldHVybiBoYXNoO1xyXG5cdH1cclxuXHJcblx0LyoqIEFyZSB0d28gSW50ZXJ2YWxTZXRzIGVxdWFsPyAgQmVjYXVzZSBhbGwgaW50ZXJ2YWxzIGFyZSBzb3J0ZWRcclxuXHQgKiAgYW5kIGRpc2pvaW50LCBlcXVhbHMgaXMgYSBzaW1wbGUgbGluZWFyIHdhbGsgb3ZlciBib3RoIGxpc3RzXHJcblx0ICogIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSB0aGUgc2FtZS4gIEludGVydmFsLmVxdWFscygpIGlzIHVzZWRcclxuXHQgKiAgYnkgdGhlIExpc3QuZXF1YWxzKCkgbWV0aG9kIHRvIGNoZWNrIHRoZSByYW5nZXMuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChvID09IG51bGwgfHwgIShvIGluc3RhbmNlb2YgSW50ZXJ2YWxTZXQpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuZXF1YWxzKHRoaXMuX2ludGVydmFscywgby5faW50ZXJ2YWxzKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b1N0cmluZyhlbGVtQXJlQ2hhcjogYm9vbGVhbiA9IGZhbHNlKTogc3RyaW5nIHtcclxuXHRcdGxldCBidWY6IHN0cmluZyA9IFwiXCI7XHJcblx0XHRpZiAodGhpcy5faW50ZXJ2YWxzID09IG51bGwgfHwgdGhpcy5faW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gXCJ7fVwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLnNpemUgPiAxKSB7XHJcblx0XHRcdGJ1ZiArPSBcIntcIjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZmlyc3Q6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdFx0Zm9yIChsZXQgSSBvZiB0aGlzLl9pbnRlcnZhbHMpIHtcclxuXHRcdFx0aWYgKGZpcnN0KSB7XHJcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRidWYgKz0gXCIsIFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgYTogbnVtYmVyID0gSS5hO1xyXG5cdFx0XHRsZXQgYjogbnVtYmVyID0gSS5iO1xyXG5cdFx0XHRpZiAoYSA9PT0gYikge1xyXG5cdFx0XHRcdGlmIChhID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0XHRcdGJ1ZiArPSBcIjxFT0Y+XCI7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChlbGVtQXJlQ2hhcikge1xyXG5cdFx0XHRcdFx0YnVmICs9IFwiJ1wiICsgU3RyaW5nLmZyb21Db2RlUG9pbnQoYSkgKyBcIidcIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YnVmICs9IGE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmIChlbGVtQXJlQ2hhcikge1xyXG5cdFx0XHRcdFx0YnVmICs9IFwiJ1wiICsgU3RyaW5nLmZyb21Db2RlUG9pbnQoYSkgKyBcIicuLidcIiArIFN0cmluZy5mcm9tQ29kZVBvaW50KGIpICsgXCInXCI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGJ1ZiArPSBhICsgXCIuLlwiICsgYjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5zaXplID4gMSkge1xyXG5cdFx0XHRidWYgKz0gXCJ9XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJ1ZjtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b1N0cmluZ1ZvY2FidWxhcnkoIEBOb3ROdWxsIHZvY2FidWxhcnk6IFZvY2FidWxhcnkpOiBzdHJpbmcge1xyXG5cdFx0aWYgKHRoaXMuX2ludGVydmFscyA9PSBudWxsIHx8IHRoaXMuX2ludGVydmFscy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIFwie31cIjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYnVmOiBzdHJpbmcgPSBcIlwiO1xyXG5cdFx0aWYgKHRoaXMuc2l6ZSA+IDEpIHtcclxuXHRcdFx0YnVmICs9IFwie1wiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBmaXJzdDogYm9vbGVhbiA9IHRydWU7XHJcblx0XHRmb3IgKGxldCBJIG9mIHRoaXMuX2ludGVydmFscykge1xyXG5cdFx0XHRpZiAoZmlyc3QpIHtcclxuXHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGJ1ZiArPSBcIiwgXCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBhOiBudW1iZXIgPSBJLmE7XHJcblx0XHRcdGxldCBiOiBudW1iZXIgPSBJLmI7XHJcblx0XHRcdGlmIChhID09PSBiKSB7XHJcblx0XHRcdFx0YnVmICs9IHRoaXMuZWxlbWVudE5hbWUodm9jYWJ1bGFyeSwgYSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IGE7IGkgPD0gYjsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAoaSA+IGEpIHtcclxuXHRcdFx0XHRcdFx0YnVmICs9IFwiLCBcIjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRidWYgKz0gdGhpcy5lbGVtZW50TmFtZSh2b2NhYnVsYXJ5LCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5zaXplID4gMSkge1xyXG5cdFx0XHRidWYgKz0gXCJ9XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJ1ZjtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGVsZW1lbnROYW1lKCBATm90TnVsbCB2b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5LCBhOiBudW1iZXIpOiBzdHJpbmcge1xyXG5cdFx0aWYgKGEgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHRyZXR1cm4gXCI8RU9GPlwiO1xyXG5cdFx0fSBlbHNlIGlmIChhID09PSBUb2tlbi5FUFNJTE9OKSB7XHJcblx0XHRcdHJldHVybiBcIjxFUFNJTE9OPlwiO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHZvY2FidWxhcnkuZ2V0RGlzcGxheU5hbWUoYSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IG46IG51bWJlciA9IDA7XHJcblx0XHRsZXQgbnVtSW50ZXJ2YWxzOiBudW1iZXIgPSB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoO1xyXG5cdFx0aWYgKG51bUludGVydmFscyA9PT0gMSkge1xyXG5cdFx0XHRsZXQgZmlyc3RJbnRlcnZhbDogSW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbHNbMF07XHJcblx0XHRcdHJldHVybiBmaXJzdEludGVydmFsLmIgLSBmaXJzdEludGVydmFsLmEgKyAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW50ZXJ2YWxzOyBpKyspIHtcclxuXHRcdFx0bGV0IEk6IEludGVydmFsID0gdGhpcy5faW50ZXJ2YWxzW2ldO1xyXG5cdFx0XHRuICs9IChJLmIgLSBJLmEgKyAxKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbjtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b0ludGVnZXJMaXN0KCk6IEludGVnZXJMaXN0IHtcclxuXHRcdGxldCB2YWx1ZXM6IEludGVnZXJMaXN0ID0gbmV3IEludGVnZXJMaXN0KHRoaXMuc2l6ZSk7XHJcblx0XHRsZXQgbjogbnVtYmVyID0gdGhpcy5faW50ZXJ2YWxzLmxlbmd0aDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdGxldCBJOiBJbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsc1tpXTtcclxuXHRcdFx0bGV0IGE6IG51bWJlciA9IEkuYTtcclxuXHRcdFx0bGV0IGI6IG51bWJlciA9IEkuYjtcclxuXHRcdFx0Zm9yIChsZXQgdiA9IGE7IHYgPD0gYjsgdisrKSB7XHJcblx0XHRcdFx0dmFsdWVzLmFkZCh2KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdG9TZXQoKTogU2V0PG51bWJlcj4ge1xyXG5cdFx0bGV0IHM6IFNldDxudW1iZXI+ID0gbmV3IFNldDxudW1iZXI+KCk7XHJcblx0XHRmb3IgKGxldCBJIG9mIHRoaXMuX2ludGVydmFscykge1xyXG5cdFx0XHRsZXQgYTogbnVtYmVyID0gSS5hO1xyXG5cdFx0XHRsZXQgYjogbnVtYmVyID0gSS5iO1xyXG5cdFx0XHRmb3IgKGxldCB2ID0gYTsgdiA8PSBiOyB2KyspIHtcclxuXHRcdFx0XHRzLmFkZCh2KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvQXJyYXkoKTogbnVtYmVyW10ge1xyXG5cdFx0bGV0IHZhbHVlczogbnVtYmVyW10gPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xyXG5cdFx0bGV0IG46IG51bWJlciA9IHRoaXMuX2ludGVydmFscy5sZW5ndGg7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRsZXQgSTogSW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbHNbaV07XHJcblx0XHRcdGxldCBhOiBudW1iZXIgPSBJLmE7XHJcblx0XHRcdGxldCBiOiBudW1iZXIgPSBJLmI7XHJcblx0XHRcdGZvciAobGV0IHYgPSBhOyB2IDw9IGI7IHYrKykge1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKHYpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZW1vdmUoZWw6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMucmVhZG9ubHkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgYWx0ZXIgcmVhZG9ubHkgSW50ZXJ2YWxTZXRcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG46IG51bWJlciA9IHRoaXMuX2ludGVydmFscy5sZW5ndGg7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRsZXQgSTogSW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbHNbaV07XHJcblx0XHRcdGxldCBhOiBudW1iZXIgPSBJLmE7XHJcblx0XHRcdGxldCBiOiBudW1iZXIgPSBJLmI7XHJcblx0XHRcdGlmIChlbCA8IGEpIHtcclxuXHRcdFx0XHRicmVhazsgLy8gbGlzdCBpcyBzb3J0ZWQgYW5kIGVsIGlzIGJlZm9yZSB0aGlzIGludGVydmFsOyBub3QgaGVyZVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGlmIHdob2xlIGludGVydmFsIHguLngsIHJtXHJcblx0XHRcdGlmIChlbCA9PT0gYSAmJiBlbCA9PT0gYikge1xyXG5cdFx0XHRcdHRoaXMuX2ludGVydmFscy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gaWYgb24gbGVmdCBlZGdlIHguLmIsIGFkanVzdCBsZWZ0XHJcblx0XHRcdGlmIChlbCA9PT0gYSkge1xyXG5cdFx0XHRcdHRoaXMuX2ludGVydmFsc1tpXSA9IEludGVydmFsLm9mKEkuYSArIDEsIEkuYik7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gaWYgb24gcmlnaHQgZWRnZSBhLi54LCBhZGp1c3QgcmlnaHRcclxuXHRcdFx0aWYgKGVsID09PSBiKSB7XHJcblx0XHRcdFx0dGhpcy5faW50ZXJ2YWxzW2ldID0gSW50ZXJ2YWwub2YoSS5hLCBJLmIgLSAxKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBpZiBpbiBtaWRkbGUgYS4ueC4uYiwgc3BsaXQgaW50ZXJ2YWxcclxuXHRcdFx0aWYgKGVsID4gYSAmJiBlbCA8IGIpIHsgLy8gZm91bmQgaW4gdGhpcyBpbnRlcnZhbFxyXG5cdFx0XHRcdGxldCBvbGRiOiBudW1iZXIgPSBJLmI7XHJcblx0XHRcdFx0dGhpcy5faW50ZXJ2YWxzW2ldID0gSW50ZXJ2YWwub2YoSS5hLCBlbCAtIDEpOyAvLyBbYS4ueC0xXVxyXG5cdFx0XHRcdHRoaXMuYWRkKGVsICsgMSwgb2xkYik7IC8vIGFkZCBbeCsxLi5iXVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXQgaXNSZWFkb25seSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnJlYWRvbmx5O1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldFJlYWRvbmx5KHJlYWRvbmx5OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5yZWFkb25seSAmJiAhcmVhZG9ubHkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgYWx0ZXIgcmVhZG9ubHkgSW50ZXJ2YWxTZXRcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5yZWFkb25seSA9IHJlYWRvbmx5O1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjUuODE4NzkxMi0wNzowMFxyXG5cclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMge1xyXG5cdHByaXZhdGUgc3RhdGljIF9kZWZhdWx0T3B0aW9ucz86IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnM7XHJcblxyXG5cdHByaXZhdGUgcmVhZE9ubHk6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwcml2YXRlIHZlcmlmeUFUTjogYm9vbGVhbjtcclxuXHRwcml2YXRlIGdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zOiBib29sZWFuO1xyXG5cdHByaXZhdGUgb3B0aW1pemU6IGJvb2xlYW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zKSB7XHJcblx0XHRpZiAob3B0aW9ucykge1xyXG5cdFx0XHR0aGlzLnZlcmlmeUFUTiA9IG9wdGlvbnMudmVyaWZ5QVROO1xyXG5cdFx0XHR0aGlzLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zID0gb3B0aW9ucy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucztcclxuXHRcdFx0dGhpcy5vcHRpbWl6ZSA9IG9wdGlvbnMub3B0aW1pemU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnZlcmlmeUFUTiA9IHRydWU7XHJcblx0XHRcdHRoaXMuZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5vcHRpbWl6ZSA9IHRydWU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdHN0YXRpYyBnZXQgZGVmYXVsdE9wdGlvbnMoKTogQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyB7XHJcblx0XHRpZiAoQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5fZGVmYXVsdE9wdGlvbnMgPT0gbnVsbCkge1xyXG5cdFx0XHRBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zLl9kZWZhdWx0T3B0aW9ucyA9IG5ldyBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zKCk7XHJcblx0XHRcdEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMuX2RlZmF1bHRPcHRpb25zLm1ha2VSZWFkT25seSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zLl9kZWZhdWx0T3B0aW9ucztcclxuXHR9XHJcblxyXG5cdGdldCBpc1JlYWRPbmx5KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMucmVhZE9ubHk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgbWFrZVJlYWRPbmx5KCk6IHZvaWQge1xyXG5cdFx0dGhpcy5yZWFkT25seSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRnZXQgaXNWZXJpZnlBVE4oKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy52ZXJpZnlBVE47XHJcblx0fVxyXG5cclxuXHRzZXQgaXNWZXJpZnlBVE4odmVyaWZ5QVROOiBib29sZWFuKSB7XHJcblx0XHR0aGlzLnRocm93SWZSZWFkT25seSgpO1xyXG5cdFx0dGhpcy52ZXJpZnlBVE4gPSB2ZXJpZnlBVE47XHJcblx0fVxyXG5cclxuXHRnZXQgaXNHZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zO1xyXG5cdH1cclxuXHJcblx0c2V0IGlzR2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMoZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnM6IGJvb2xlYW4pIHtcclxuXHRcdHRoaXMudGhyb3dJZlJlYWRPbmx5KCk7XHJcblx0XHR0aGlzLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zID0gZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnM7XHJcblx0fVxyXG5cclxuXHRnZXQgaXNPcHRpbWl6ZSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGltaXplO1xyXG5cdH1cclxuXHJcblx0c2V0IGlzT3B0aW1pemUob3B0aW1pemU6IGJvb2xlYW4pIHtcclxuXHRcdHRoaXMudGhyb3dJZlJlYWRPbmx5KCk7XHJcblx0XHR0aGlzLm9wdGltaXplID0gb3B0aW1pemU7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgdGhyb3dJZlJlYWRPbmx5KCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuaXNSZWFkT25seSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgb2JqZWN0IGlzIHJlYWQgb25seS5cIik7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyNC43MzYzNDQ4LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlLCBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCIuL1RyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvblR5cGUgfSBmcm9tIFwiLi9UcmFuc2l0aW9uVHlwZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFjdGlvblRyYW5zaXRpb24gZXh0ZW5kcyBUcmFuc2l0aW9uIHtcclxuXHRwdWJsaWMgcnVsZUluZGV4OiBudW1iZXI7XHJcblx0cHVibGljIGFjdGlvbkluZGV4OiBudW1iZXI7XHJcblx0cHVibGljIGlzQ3R4RGVwZW5kZW50OiBib29sZWFuOyAgLy8gZS5nLiwgJGkgcmVmIGluIGFjdGlvblxyXG5cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCB0YXJnZXQ6IEFUTlN0YXRlLCBydWxlSW5kZXg6IG51bWJlciwgYWN0aW9uSW5kZXg6IG51bWJlciA9IC0xLCBpc0N0eERlcGVuZGVudDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcblx0XHRzdXBlcih0YXJnZXQpO1xyXG5cdFx0dGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XHJcblx0XHR0aGlzLmFjdGlvbkluZGV4ID0gYWN0aW9uSW5kZXg7XHJcblx0XHR0aGlzLmlzQ3R4RGVwZW5kZW50ID0gaXNDdHhEZXBlbmRlbnQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2VyaWFsaXphdGlvblR5cGUoKTogVHJhbnNpdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIFRyYW5zaXRpb25UeXBlLkFDVElPTjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc0Vwc2lsb24oKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdHJ1ZTsgLy8gd2UgYXJlIHRvIGJlIGlnbm9yZWQgYnkgYW5hbHlzaXMgJ2NlcHQgZm9yIHByZWRpY2F0ZXNcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBtYXRjaGVzKHN5bWJvbDogbnVtYmVyLCBtaW5Wb2NhYlN5bWJvbDogbnVtYmVyLCBtYXhWb2NhYlN5bWJvbDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcImFjdGlvbl9cIiArIHRoaXMucnVsZUluZGV4ICsgXCI6XCIgKyB0aGlzLmFjdGlvbkluZGV4O1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjcuNjc2OTEyMi0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbFNldCB9IGZyb20gXCIuLi9taXNjL0ludGVydmFsU2V0XCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlLCBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCIuL1RyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvblR5cGUgfSBmcm9tIFwiLi9UcmFuc2l0aW9uVHlwZVwiO1xyXG5cclxuLyoqIFRPRE86IG1ha2UgYWxsIHRyYW5zaXRpb25zIHNldHM/IG5vLCBzaG91bGQgcmVtb3ZlIHNldCBlZGdlcyAqL1xyXG5leHBvcnQgY2xhc3MgQXRvbVRyYW5zaXRpb24gZXh0ZW5kcyBUcmFuc2l0aW9uIHtcclxuXHQvKiogVGhlIHRva2VuIHR5cGUgb3IgY2hhcmFjdGVyIHZhbHVlOyBvciwgc2lnbmlmaWVzIHNwZWNpYWwgbGFiZWwuICovXHJcblx0cHVibGljIF9sYWJlbDogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCB0YXJnZXQ6IEFUTlN0YXRlLCBsYWJlbDogbnVtYmVyKSB7XHJcblx0XHRzdXBlcih0YXJnZXQpO1xyXG5cdFx0dGhpcy5fbGFiZWwgPSBsYWJlbDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzZXJpYWxpemF0aW9uVHlwZSgpOiBUcmFuc2l0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gVHJhbnNpdGlvblR5cGUuQVRPTTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGxhYmVsKCk6IEludGVydmFsU2V0IHtcclxuXHRcdHJldHVybiBJbnRlcnZhbFNldC5vZih0aGlzLl9sYWJlbCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgbWF0Y2hlcyhzeW1ib2w6IG51bWJlciwgbWluVm9jYWJTeW1ib2w6IG51bWJlciwgbWF4Vm9jYWJTeW1ib2w6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhYmVsID09PSBzeW1ib2w7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFN0cmluZyh0aGlzLmxhYmVsKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI3Ljk5MzAzOTQtMDc6MDBcclxuXHJcbmltcG9ydCB7IEJsb2NrRW5kU3RhdGUgfSBmcm9tIFwiLi9CbG9ja0VuZFN0YXRlXCI7XHJcbmltcG9ydCB7IERlY2lzaW9uU3RhdGUgfSBmcm9tIFwiLi9EZWNpc2lvblN0YXRlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKiAgVGhlIHN0YXJ0IG9mIGEgcmVndWxhciBgKC4uLilgIGJsb2NrLiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmxvY2tTdGFydFN0YXRlIGV4dGVuZHMgRGVjaXNpb25TdGF0ZSB7XHJcblx0Ly8gVGhpcyBpcyBhbHdheXMgc2V0IGR1cmluZyBBVE4gZGVzZXJpYWxpemF0aW9uXHJcblx0cHVibGljIGVuZFN0YXRlITogQmxvY2tFbmRTdGF0ZTtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjcuNzY2OTgwMS0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IEJsb2NrU3RhcnRTdGF0ZSB9IGZyb20gXCIuL0Jsb2NrU3RhcnRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJhc2ljQmxvY2tTdGFydFN0YXRlIGV4dGVuZHMgQmxvY2tTdGFydFN0YXRlIHtcclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHN0YXRlVHlwZSgpOiBBVE5TdGF0ZVR5cGUge1xyXG5cdFx0cmV0dXJuIEFUTlN0YXRlVHlwZS5CTE9DS19TVEFSVDtcclxuXHR9XHJcblxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyNy45MTI1MzA0LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlVHlwZSB9IGZyb20gXCIuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBCbG9ja1N0YXJ0U3RhdGUgfSBmcm9tIFwiLi9CbG9ja1N0YXJ0U3RhdGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqIFRlcm1pbmFsIG5vZGUgb2YgYSBzaW1wbGUgYChhfGJ8YylgIGJsb2NrLiAqL1xyXG5leHBvcnQgY2xhc3MgQmxvY2tFbmRTdGF0ZSBleHRlbmRzIEFUTlN0YXRlIHtcclxuXHQvLyBUaGlzIGlzIGFsd2F5cyBzZXQgZHVyaW5nIEFUTiBkZXNlcmlhbGl6YXRpb25cclxuXHRwdWJsaWMgc3RhcnRTdGF0ZSE6IEJsb2NrU3RhcnRTdGF0ZTtcclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHN0YXRlVHlwZSgpOiBBVE5TdGF0ZVR5cGUge1xyXG5cdFx0cmV0dXJuIEFUTlN0YXRlVHlwZS5CTE9DS19FTkQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOC42MjgzMjEzLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlLCBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCIuL1RyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvblR5cGUgfSBmcm9tIFwiLi9UcmFuc2l0aW9uVHlwZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEVwc2lsb25UcmFuc2l0aW9uIGV4dGVuZHMgVHJhbnNpdGlvbiB7XHJcblxyXG5cdHByaXZhdGUgX291dGVybW9zdFByZWNlZGVuY2VSZXR1cm46IG51bWJlcjtcclxuXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgdGFyZ2V0OiBBVE5TdGF0ZSwgb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybjogbnVtYmVyID0gLTEpIHtcclxuXHRcdHN1cGVyKHRhcmdldCk7XHJcblx0XHR0aGlzLl9vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuID0gb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEByZXR1cm5zIHRoZSBydWxlIGluZGV4IG9mIGEgcHJlY2VkZW5jZSBydWxlIGZvciB3aGljaCB0aGlzIHRyYW5zaXRpb24gaXNcclxuXHQgKiByZXR1cm5pbmcgZnJvbSwgd2hlcmUgdGhlIHByZWNlZGVuY2UgdmFsdWUgaXMgMDsgb3RoZXJ3aXNlLCAtMS5cclxuXHQgKlxyXG5cdCAqIEBzZWUgQVROQ29uZmlnLmlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWRcclxuXHQgKiBAc2VlIFBhcnNlckFUTlNpbXVsYXRvciNhcHBseVByZWNlZGVuY2VGaWx0ZXIoQVROQ29uZmlnU2V0LCBQYXJzZXJSdWxlQ29udGV4dCwgUHJlZGljdGlvbkNvbnRleHRDYWNoZSlcclxuXHQgKiBAc2luY2UgNC40LjFcclxuXHQgKi9cclxuXHRnZXQgb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybigpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX291dGVybW9zdFByZWNlZGVuY2VSZXR1cm47XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2VyaWFsaXphdGlvblR5cGUoKTogVHJhbnNpdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIFRyYW5zaXRpb25UeXBlLkVQU0lMT047XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaXNFcHNpbG9uKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgbWF0Y2hlcyhzeW1ib2w6IG51bWJlciwgbWluVm9jYWJTeW1ib2w6IG51bWJlciwgbWF4Vm9jYWJTeW1ib2w6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcImVwc2lsb25cIjtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI5LjU2MzQzODgtMDc6MDBcclxuXHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL0xleGVyXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb25UeXBlIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25UeXBlXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIHRoZSBgY2hhbm5lbGAgbGV4ZXIgYWN0aW9uIGJ5IGNhbGxpbmdcclxuICoge0BsaW5rIExleGVyI3NldENoYW5uZWx9IHdpdGggdGhlIGFzc2lnbmVkIGNoYW5uZWwuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICogQHNpbmNlIDQuMlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExleGVyQ2hhbm5lbEFjdGlvbiBpbXBsZW1lbnRzIExleGVyQWN0aW9uIHtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9jaGFubmVsOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYGNoYW5uZWxgIGFjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgY2hhbm5lbCB2YWx1ZS5cclxuXHQgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB2YWx1ZSB0byBwYXNzIHRvIHtAbGluayBMZXhlciNzZXRDaGFubmVsfS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihjaGFubmVsOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuX2NoYW5uZWwgPSBjaGFubmVsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgY2hhbm5lbCB0byB1c2UgZm9yIHRoZSB7QGxpbmsgVG9rZW59IGNyZWF0ZWQgYnkgdGhlIGxleGVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIGNoYW5uZWwgdG8gdXNlIGZvciB0aGUge0BsaW5rIFRva2VufSBjcmVhdGVkIGJ5IHRoZSBsZXhlci5cclxuXHQgKi9cclxuXHRnZXQgY2hhbm5lbCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NoYW5uZWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyB7QGxpbmsgTGV4ZXJBY3Rpb25UeXBlI0NIQU5ORUx9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBhY3Rpb25UeXBlKCk6IExleGVyQWN0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gTGV4ZXJBY3Rpb25UeXBlLkNIQU5ORUw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc1Bvc2l0aW9uRGVwZW5kZW50KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhpcyBhY3Rpb24gaXMgaW1wbGVtZW50ZWQgYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIjc2V0Q2hhbm5lbH0gd2l0aCB0aGVcclxuXHQgKiB2YWx1ZSBwcm92aWRlZCBieSB7QGxpbmsgI2dldENoYW5uZWx9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBleGVjdXRlKEBOb3ROdWxsIGxleGVyOiBMZXhlcik6IHZvaWQge1xyXG5cdFx0bGV4ZXIuY2hhbm5lbCA9IHRoaXMuX2NoYW5uZWw7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmFjdGlvblR5cGUpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuX2NoYW5uZWwpO1xyXG5cdFx0cmV0dXJuIE11cm11ckhhc2guZmluaXNoKGhhc2gsIDIpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG9iaiA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAoIShvYmogaW5zdGFuY2VvZiBMZXhlckNoYW5uZWxBY3Rpb24pKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY2hhbm5lbCA9PT0gb2JqLl9jaGFubmVsO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gYGNoYW5uZWwoJHt0aGlzLl9jaGFubmVsfSlgO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjkuNjU2Nzk5Mi0wNzowMFxyXG5cclxuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi4vTGV4ZXJcIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb24gfSBmcm9tIFwiLi9MZXhlckFjdGlvblwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvblR5cGUgfSBmcm9tIFwiLi9MZXhlckFjdGlvblR5cGVcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuLi9taXNjL011cm11ckhhc2hcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIEV4ZWN1dGVzIGEgY3VzdG9tIGxleGVyIGFjdGlvbiBieSBjYWxsaW5nIHtAbGluayBSZWNvZ25pemVyI2FjdGlvbn0gd2l0aCB0aGVcclxuICogcnVsZSBhbmQgYWN0aW9uIGluZGV4ZXMgYXNzaWduZWQgdG8gdGhlIGN1c3RvbSBhY3Rpb24uIFRoZSBpbXBsZW1lbnRhdGlvbiBvZlxyXG4gKiBhIGN1c3RvbSBhY3Rpb24gaXMgYWRkZWQgdG8gdGhlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgbGV4ZXIgaW4gYW4gb3ZlcnJpZGVcclxuICogb2Yge0BsaW5rIFJlY29nbml6ZXIjYWN0aW9ufSB3aGVuIHRoZSBncmFtbWFyIGlzIGNvbXBpbGVkLlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIG1heSByZXByZXNlbnQgZW1iZWRkZWQgYWN0aW9ucyBjcmVhdGVkIHdpdGggdGhlIGB7Li4ufWBcclxuICogc3ludGF4IGluIEFOVExSIDQsIGFzIHdlbGwgYXMgYWN0aW9ucyBjcmVhdGVkIGZvciBsZXhlciBjb21tYW5kcyB3aGVyZSB0aGVcclxuICogY29tbWFuZCBhcmd1bWVudCBjb3VsZCBub3QgYmUgZXZhbHVhdGVkIHdoZW4gdGhlIGdyYW1tYXIgd2FzIGNvbXBpbGVkLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqIEBzaW5jZSA0LjJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMZXhlckN1c3RvbUFjdGlvbiBpbXBsZW1lbnRzIExleGVyQWN0aW9uIHtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9ydWxlSW5kZXg6IG51bWJlcjtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9hY3Rpb25JbmRleDogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgY3VzdG9tIGxleGVyIGFjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgcnVsZSBhbmQgYWN0aW9uXHJcblx0ICogaW5kZXhlcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBydWxlSW5kZXggVGhlIHJ1bGUgaW5kZXggdG8gdXNlIGZvciBjYWxscyB0b1xyXG5cdCAqIHtAbGluayBSZWNvZ25pemVyI2FjdGlvbn0uXHJcblx0ICogQHBhcmFtIGFjdGlvbkluZGV4IFRoZSBhY3Rpb24gaW5kZXggdG8gdXNlIGZvciBjYWxscyB0b1xyXG5cdCAqIHtAbGluayBSZWNvZ25pemVyI2FjdGlvbn0uXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IocnVsZUluZGV4OiBudW1iZXIsIGFjdGlvbkluZGV4OiBudW1iZXIpIHtcclxuXHRcdHRoaXMuX3J1bGVJbmRleCA9IHJ1bGVJbmRleDtcclxuXHRcdHRoaXMuX2FjdGlvbkluZGV4ID0gYWN0aW9uSW5kZXg7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBydWxlIGluZGV4IHRvIHVzZSBmb3IgY2FsbHMgdG8ge0BsaW5rIFJlY29nbml6ZXIjYWN0aW9ufS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBydWxlIGluZGV4IGZvciB0aGUgY3VzdG9tIGFjdGlvbi5cclxuXHQgKi9cclxuXHRnZXQgcnVsZUluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcnVsZUluZGV4O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgYWN0aW9uIGluZGV4IHRvIHVzZSBmb3IgY2FsbHMgdG8ge0BsaW5rIFJlY29nbml6ZXIjYWN0aW9ufS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBhY3Rpb24gaW5kZXggZm9yIHRoZSBjdXN0b20gYWN0aW9uLlxyXG5cdCAqL1xyXG5cdGdldCBhY3Rpb25JbmRleCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2FjdGlvbkluZGV4O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyB7QGxpbmsgTGV4ZXJBY3Rpb25UeXBlI0NVU1RPTX0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGFjdGlvblR5cGUoKTogTGV4ZXJBY3Rpb25UeXBlIHtcclxuXHRcdHJldHVybiBMZXhlckFjdGlvblR5cGUuQ1VTVE9NO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB3aGV0aGVyIHRoZSBsZXhlciBhY3Rpb24gaXMgcG9zaXRpb24tZGVwZW5kZW50LiBQb3NpdGlvbi1kZXBlbmRlbnRcclxuXHQgKiBhY3Rpb25zIG1heSBoYXZlIGRpZmZlcmVudCBzZW1hbnRpY3MgZGVwZW5kaW5nIG9uIHRoZSB7QGxpbmsgQ2hhclN0cmVhbX1cclxuXHQgKiBpbmRleCBhdCB0aGUgdGltZSB0aGUgYWN0aW9uIGlzIGV4ZWN1dGVkLlxyXG5cdCAqXHJcblx0ICogQ3VzdG9tIGFjdGlvbnMgYXJlIHBvc2l0aW9uLWRlcGVuZGVudCBzaW5jZSB0aGV5IG1heSByZXByZXNlbnQgYVxyXG5cdCAqIHVzZXItZGVmaW5lZCBlbWJlZGRlZCBhY3Rpb24gd2hpY2ggbWFrZXMgY2FsbHMgdG8gbWV0aG9kcyBsaWtlXHJcblx0ICoge0BsaW5rIExleGVyI2dldFRleHR9LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIEN1c3RvbSBhY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBieSBjYWxsaW5nIHtAbGluayBMZXhlciNhY3Rpb259IHdpdGggdGhlXHJcblx0ICogYXBwcm9wcmlhdGUgcnVsZSBhbmQgYWN0aW9uIGluZGV4ZXMuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGV4ZWN1dGUoQE5vdE51bGwgbGV4ZXI6IExleGVyKTogdm9pZCB7XHJcblx0XHRsZXhlci5hY3Rpb24odW5kZWZpbmVkLCB0aGlzLl9ydWxlSW5kZXgsIHRoaXMuX2FjdGlvbkluZGV4KTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IGhhc2g6IG51bWJlciA9IE11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuYWN0aW9uVHlwZSk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5fcnVsZUluZGV4KTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLl9hY3Rpb25JbmRleCk7XHJcblx0XHRyZXR1cm4gTXVybXVySGFzaC5maW5pc2goaGFzaCwgMyk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbiB7XHJcblx0XHRpZiAob2JqID09PSB0aGlzKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIGlmICghKG9iaiBpbnN0YW5jZW9mIExleGVyQ3VzdG9tQWN0aW9uKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3J1bGVJbmRleCA9PT0gb2JqLl9ydWxlSW5kZXhcclxuXHRcdFx0JiYgdGhpcy5fYWN0aW9uSW5kZXggPT09IG9iai5fYWN0aW9uSW5kZXg7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOS44NjUzNDI3LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvbiB9IGZyb20gXCIuL0xleGVyQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uVHlwZSB9IGZyb20gXCIuL0xleGVyQWN0aW9uVHlwZVwiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4uL21pc2MvTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyB0aGUgYG1vZGVgIGxleGVyIGFjdGlvbiBieSBjYWxsaW5nIHtAbGluayBMZXhlciNtb2RlfSB3aXRoXHJcbiAqIHRoZSBhc3NpZ25lZCBtb2RlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqIEBzaW5jZSA0LjJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMZXhlck1vZGVBY3Rpb24gaW1wbGVtZW50cyBMZXhlckFjdGlvbiB7XHJcblx0cHJpdmF0ZSByZWFkb25seSBfbW9kZTogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGBtb2RlYCBhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIG1vZGUgdmFsdWUuXHJcblx0ICogQHBhcmFtIG1vZGUgVGhlIG1vZGUgdmFsdWUgdG8gcGFzcyB0byB7QGxpbmsgTGV4ZXIjbW9kZX0uXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IobW9kZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLl9tb2RlID0gbW9kZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbGV4ZXIgbW9kZSB0aGlzIGFjdGlvbiBzaG91bGQgdHJhbnNpdGlvbiB0aGUgbGV4ZXIgdG8uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgbGV4ZXIgbW9kZSBmb3IgdGhpcyBgbW9kZWAgY29tbWFuZC5cclxuXHQgKi9cclxuXHRnZXQgbW9kZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX21vZGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyB7QGxpbmsgTGV4ZXJBY3Rpb25UeXBlI01PREV9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBhY3Rpb25UeXBlKCk6IExleGVyQWN0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gTGV4ZXJBY3Rpb25UeXBlLk1PREU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc1Bvc2l0aW9uRGVwZW5kZW50KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhpcyBhY3Rpb24gaXMgaW1wbGVtZW50ZWQgYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIjbW9kZX0gd2l0aCB0aGVcclxuXHQgKiB2YWx1ZSBwcm92aWRlZCBieSB7QGxpbmsgI2dldE1vZGV9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBleGVjdXRlKEBOb3ROdWxsIGxleGVyOiBMZXhlcik6IHZvaWQge1xyXG5cdFx0bGV4ZXIubW9kZSh0aGlzLl9tb2RlKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IGhhc2g6IG51bWJlciA9IE11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuYWN0aW9uVHlwZSk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5fbW9kZSk7XHJcblx0XHRyZXR1cm4gTXVybXVySGFzaC5maW5pc2goaGFzaCwgMik7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbiB7XHJcblx0XHRpZiAob2JqID09PSB0aGlzKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIGlmICghKG9iaiBpbnN0YW5jZW9mIExleGVyTW9kZUFjdGlvbikpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9tb2RlID09PSBvYmouX21vZGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgbW9kZSgke3RoaXMuX21vZGV9KWA7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOS45NjEzMjIxLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvbiB9IGZyb20gXCIuL0xleGVyQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uVHlwZSB9IGZyb20gXCIuL0xleGVyQWN0aW9uVHlwZVwiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4uL21pc2MvTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyB0aGUgYG1vcmVgIGxleGVyIGFjdGlvbiBieSBjYWxsaW5nIHtAbGluayBMZXhlciNtb3JlfS5cclxuICpcclxuICogVGhlIGBtb3JlYCBjb21tYW5kIGRvZXMgbm90IGhhdmUgYW55IHBhcmFtZXRlcnMsIHNvIHRoaXMgYWN0aW9uIGlzXHJcbiAqIGltcGxlbWVudGVkIGFzIGEgc2luZ2xldG9uIGluc3RhbmNlIGV4cG9zZWQgYnkge0BsaW5rICNJTlNUQU5DRX0uXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICogQHNpbmNlIDQuMlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExleGVyTW9yZUFjdGlvbiBpbXBsZW1lbnRzIExleGVyQWN0aW9uIHtcclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGxleGVyIGBtb3JlYCBjb21tYW5kLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIHJldHVybnMge0BsaW5rIExleGVyQWN0aW9uVHlwZSNNT1JFfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgYWN0aW9uVHlwZSgpOiBMZXhlckFjdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIExleGVyQWN0aW9uVHlwZS5NT1JFO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaXNQb3NpdGlvbkRlcGVuZGVudCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoaXMgYWN0aW9uIGlzIGltcGxlbWVudGVkIGJ5IGNhbGxpbmcge0BsaW5rIExleGVyI21vcmV9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBleGVjdXRlKEBOb3ROdWxsIGxleGVyOiBMZXhlcik6IHZvaWQge1xyXG5cdFx0bGV4ZXIubW9yZSgpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKCk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5hY3Rpb25UeXBlKTtcclxuXHRcdHJldHVybiBNdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAxKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBvYmogPT09IHRoaXM7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIm1vcmVcIjtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgTGV4ZXJNb3JlQWN0aW9uIHtcclxuXHQvKipcclxuXHQgKiBQcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGlzIHBhcmFtZXRlcmxlc3MgbGV4ZXIgYWN0aW9uLlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBjb25zdCBJTlNUQU5DRTogTGV4ZXJNb3JlQWN0aW9uID0gbmV3IExleGVyTW9yZUFjdGlvbigpO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozMC4wNDQ5MjIwLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvbiB9IGZyb20gXCIuL0xleGVyQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uVHlwZSB9IGZyb20gXCIuL0xleGVyQWN0aW9uVHlwZVwiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4uL21pc2MvTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyB0aGUgYHBvcE1vZGVgIGxleGVyIGFjdGlvbiBieSBjYWxsaW5nIHtAbGluayBMZXhlciNwb3BNb2RlfS5cclxuICpcclxuICogVGhlIGBwb3BNb2RlYCBjb21tYW5kIGRvZXMgbm90IGhhdmUgYW55IHBhcmFtZXRlcnMsIHNvIHRoaXMgYWN0aW9uIGlzXHJcbiAqIGltcGxlbWVudGVkIGFzIGEgc2luZ2xldG9uIGluc3RhbmNlIGV4cG9zZWQgYnkge0BsaW5rICNJTlNUQU5DRX0uXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICogQHNpbmNlIDQuMlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExleGVyUG9wTW9kZUFjdGlvbiBpbXBsZW1lbnRzIExleGVyQWN0aW9uIHtcclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGxleGVyIGBwb3BNb2RlYCBjb21tYW5kLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIHJldHVybnMge0BsaW5rIExleGVyQWN0aW9uVHlwZSNQT1BfTU9ERX0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGFjdGlvblR5cGUoKTogTGV4ZXJBY3Rpb25UeXBlIHtcclxuXHRcdHJldHVybiBMZXhlckFjdGlvblR5cGUuUE9QX01PREU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc1Bvc2l0aW9uRGVwZW5kZW50KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhpcyBhY3Rpb24gaXMgaW1wbGVtZW50ZWQgYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIjcG9wTW9kZX0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGV4ZWN1dGUoQE5vdE51bGwgbGV4ZXI6IExleGVyKTogdm9pZCB7XHJcblx0XHRsZXhlci5wb3BNb2RlKCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmFjdGlvblR5cGUpO1xyXG5cdFx0cmV0dXJuIE11cm11ckhhc2guZmluaXNoKGhhc2gsIDEpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIG9iaiA9PT0gdGhpcztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwicG9wTW9kZVwiO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IG5hbWVzcGFjZSBMZXhlclBvcE1vZGVBY3Rpb24ge1xyXG5cdC8qKlxyXG5cdCAqIFByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoaXMgcGFyYW1ldGVybGVzcyBsZXhlciBhY3Rpb24uXHJcblx0ICovXHJcblx0ZXhwb3J0IGNvbnN0IElOU1RBTkNFOiBMZXhlclBvcE1vZGVBY3Rpb24gPSBuZXcgTGV4ZXJQb3BNb2RlQWN0aW9uKCk7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjMwLjEzNzg4MDEtMDc6MDBcclxuXHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL0xleGVyXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb25UeXBlIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25UeXBlXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIHRoZSBgcHVzaE1vZGVgIGxleGVyIGFjdGlvbiBieSBjYWxsaW5nXHJcbiAqIHtAbGluayBMZXhlciNwdXNoTW9kZX0gd2l0aCB0aGUgYXNzaWduZWQgbW9kZS5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKiBAc2luY2UgNC4yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGV4ZXJQdXNoTW9kZUFjdGlvbiBpbXBsZW1lbnRzIExleGVyQWN0aW9uIHtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9tb2RlOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYHB1c2hNb2RlYCBhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIG1vZGUgdmFsdWUuXHJcblx0ICogQHBhcmFtIG1vZGUgVGhlIG1vZGUgdmFsdWUgdG8gcGFzcyB0byB7QGxpbmsgTGV4ZXIjcHVzaE1vZGV9LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKG1vZGU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5fbW9kZSA9IG1vZGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGxleGVyIG1vZGUgdGhpcyBhY3Rpb24gc2hvdWxkIHRyYW5zaXRpb24gdGhlIGxleGVyIHRvLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIGxleGVyIG1vZGUgZm9yIHRoaXMgYHB1c2hNb2RlYCBjb21tYW5kLlxyXG5cdCAqL1xyXG5cdGdldCBtb2RlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbW9kZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIHtAbGluayBMZXhlckFjdGlvblR5cGUjUFVTSF9NT0RFfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgYWN0aW9uVHlwZSgpOiBMZXhlckFjdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIExleGVyQWN0aW9uVHlwZS5QVVNIX01PREU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc1Bvc2l0aW9uRGVwZW5kZW50KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhpcyBhY3Rpb24gaXMgaW1wbGVtZW50ZWQgYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIjcHVzaE1vZGV9IHdpdGggdGhlXHJcblx0ICogdmFsdWUgcHJvdmlkZWQgYnkge0BsaW5rICNnZXRNb2RlfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXhlY3V0ZShATm90TnVsbCBsZXhlcjogTGV4ZXIpOiB2b2lkIHtcclxuXHRcdGxleGVyLnB1c2hNb2RlKHRoaXMuX21vZGUpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKCk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5hY3Rpb25UeXBlKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLl9tb2RlKTtcclxuXHRcdHJldHVybiBNdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAyKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChvYmogPT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgTGV4ZXJQdXNoTW9kZUFjdGlvbikpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9tb2RlID09PSBvYmouX21vZGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgcHVzaE1vZGUoJHt0aGlzLl9tb2RlfSlgO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzAuMjMyNDQ2MC0wNzowMFxyXG5cclxuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi4vTGV4ZXJcIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb24gfSBmcm9tIFwiLi9MZXhlckFjdGlvblwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvblR5cGUgfSBmcm9tIFwiLi9MZXhlckFjdGlvblR5cGVcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuLi9taXNjL011cm11ckhhc2hcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIGBza2lwYCBsZXhlciBhY3Rpb24gYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIjc2tpcH0uXHJcbiAqXHJcbiAqIFRoZSBgc2tpcGAgY29tbWFuZCBkb2VzIG5vdCBoYXZlIGFueSBwYXJhbWV0ZXJzLCBzbyB0aGlzIGFjdGlvbiBpc1xyXG4gKiBpbXBsZW1lbnRlZCBhcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBleHBvc2VkIGJ5IHtAbGluayAjSU5TVEFOQ0V9LlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqIEBzaW5jZSA0LjJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMZXhlclNraXBBY3Rpb24gaW1wbGVtZW50cyBMZXhlckFjdGlvbiB7XHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyB0aGUgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBsZXhlciBgc2tpcGAgY29tbWFuZC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIHtAbGluayBMZXhlckFjdGlvblR5cGUjU0tJUH0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGFjdGlvblR5cGUoKTogTGV4ZXJBY3Rpb25UeXBlIHtcclxuXHRcdHJldHVybiBMZXhlckFjdGlvblR5cGUuU0tJUDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGFjdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBjYWxsaW5nIHtAbGluayBMZXhlciNza2lwfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXhlY3V0ZShATm90TnVsbCBsZXhlcjogTGV4ZXIpOiB2b2lkIHtcclxuXHRcdGxleGVyLnNraXAoKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IGhhc2g6IG51bWJlciA9IE11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuYWN0aW9uVHlwZSk7XHJcblx0XHRyZXR1cm4gTXVybXVySGFzaC5maW5pc2goaGFzaCwgMSk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gb2JqID09PSB0aGlzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCJza2lwXCI7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIExleGVyU2tpcEFjdGlvbiB7XHJcblx0LyoqXHJcblx0ICogUHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhpcyBwYXJhbWV0ZXJsZXNzIGxleGVyIGFjdGlvbi5cclxuXHQgKi9cclxuXHRleHBvcnQgY29uc3QgSU5TVEFOQ0U6IExleGVyU2tpcEFjdGlvbiA9IG5ldyBMZXhlclNraXBBY3Rpb24oKTtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzAuMzIwNDgzOS0wNzowMFxyXG5cclxuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi4vTGV4ZXJcIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb24gfSBmcm9tIFwiLi9MZXhlckFjdGlvblwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvblR5cGUgfSBmcm9tIFwiLi9MZXhlckFjdGlvblR5cGVcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuLi9taXNjL011cm11ckhhc2hcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIGB0eXBlYCBsZXhlciBhY3Rpb24gYnkgc2V0dGluZyBgTGV4ZXIudHlwZWBcclxuICogd2l0aCB0aGUgYXNzaWduZWQgdHlwZS5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKiBAc2luY2UgNC4yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGV4ZXJUeXBlQWN0aW9uIGltcGxlbWVudHMgTGV4ZXJBY3Rpb24ge1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgX3R5cGU6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBgdHlwZWAgYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCB0b2tlbiB0eXBlIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIHRvIGFzc2lnbiB0byB0aGUgdG9rZW4gdXNpbmcgYExleGVyLnR5cGVgLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHR5cGU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB0eXBlIHRvIGFzc2lnbiB0byBhIHRva2VuIGNyZWF0ZWQgYnkgdGhlIGxleGVyLlxyXG5cdCAqIEByZXR1cm5zIFRoZSB0eXBlIHRvIGFzc2lnbiB0byBhIHRva2VuIGNyZWF0ZWQgYnkgdGhlIGxleGVyLlxyXG5cdCAqL1xyXG5cdGdldCB0eXBlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIHtAbGluayBMZXhlckFjdGlvblR5cGUjVFlQRX0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGFjdGlvblR5cGUoKTogTGV4ZXJBY3Rpb25UeXBlIHtcclxuXHRcdHJldHVybiBMZXhlckFjdGlvblR5cGUuVFlQRTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGFjdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBzZXR0aW5nIGBMZXhlci50eXBlYCB3aXRoIHRoZVxyXG5cdCAqIHZhbHVlIHByb3ZpZGVkIGJ5IGB0eXBlYC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXhlY3V0ZShATm90TnVsbCBsZXhlcjogTGV4ZXIpOiB2b2lkIHtcclxuXHRcdGxleGVyLnR5cGUgPSB0aGlzLl90eXBlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKCk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5hY3Rpb25UeXBlKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLl90eXBlKTtcclxuXHRcdHJldHVybiBNdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAyKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChvYmogPT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgTGV4ZXJUeXBlQWN0aW9uKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IG9iai5fdHlwZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGB0eXBlKCR7dGhpcy5fdHlwZX0pYDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjMwLjc3Mzc5NzgtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKiBNYXJrIHRoZSBlbmQgb2YgYSAqIG9yICsgbG9vcC4gKi9cclxuZXhwb3J0IGNsYXNzIExvb3BFbmRTdGF0ZSBleHRlbmRzIEFUTlN0YXRlIHtcclxuXHQvLyBUaGlzIGlzIGFsd2F5cyBzZXQgZHVyaW5nIEFUTiBkZXNlcmlhbGl6YXRpb25cclxuXHRwdWJsaWMgbG9vcEJhY2tTdGF0ZSE6IEFUTlN0YXRlO1xyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhdGVUeXBlKCk6IEFUTlN0YXRlVHlwZSB7XHJcblx0XHRyZXR1cm4gQVROU3RhdGVUeXBlLkxPT1BfRU5EO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjguMDcxMDEzMS0wNzowMFxyXG5cclxuaW1wb3J0IHsgQml0U2V0IH0gZnJvbSBcIi4uL21pc2MvQml0U2V0XCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4uL21pc2MvVXRpbHNcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBhIGNvbmZpZ3VyYXRpb24gY29uZmxpY3QuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb25mbGljdEluZm8ge1xyXG5cdHByaXZhdGUgX2NvbmZsaWN0ZWRBbHRzOiBCaXRTZXQ7XHJcblxyXG5cdHByaXZhdGUgZXhhY3Q6IGJvb2xlYW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKGNvbmZsaWN0ZWRBbHRzOiBCaXRTZXQsIGV4YWN0OiBib29sZWFuKSB7XHJcblx0XHR0aGlzLl9jb25mbGljdGVkQWx0cyA9IGNvbmZsaWN0ZWRBbHRzO1xyXG5cdFx0dGhpcy5leGFjdCA9IGV4YWN0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgc2V0IG9mIGNvbmZsaWN0aW5nIGFsdGVybmF0aXZlcyBmb3IgdGhlIGNvbmZpZ3VyYXRpb24gc2V0LlxyXG5cdCAqL1xyXG5cdGdldCBjb25mbGljdGVkQWx0cygpOiBCaXRTZXQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbmZsaWN0ZWRBbHRzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgY29uZmlndXJhdGlvbiBjb25mbGljdCBpcyBhbiBleGFjdCBjb25mbGljdC5cclxuXHQgKiBBbiBleGFjdCBjb25mbGljdCBvY2N1cnMgd2hlbiB0aGUgcHJlZGljdGlvbiBhbGdvcml0aG0gZGV0ZXJtaW5lcyB0aGF0XHJcblx0ICogdGhlIHJlcHJlc2VudGVkIGFsdGVybmF0aXZlcyBmb3IgYSBwYXJ0aWN1bGFyIGNvbmZpZ3VyYXRpb24gc2V0IGNhbm5vdCBiZVxyXG5cdCAqIGZ1cnRoZXIgcmVkdWNlZCBieSBjb25zdW1pbmcgYWRkaXRpb25hbCBpbnB1dC4gQWZ0ZXIgcmVhY2hpbmcgYW4gZXhhY3RcclxuXHQgKiBjb25mbGljdCBkdXJpbmcgYW4gU0xMIHByZWRpY3Rpb24sIG9ubHkgc3dpdGNoIHRvIGZ1bGwtY29udGV4dCBwcmVkaWN0aW9uXHJcblx0ICogY291bGQgcmVkdWNlIHRoZSBzZXQgb2YgdmlhYmxlIGFsdGVybmF0aXZlcy4gSW4gTEwgcHJlZGljdGlvbiwgYW4gZXhhY3RcclxuXHQgKiBjb25mbGljdCBpbmRpY2F0ZXMgYSB0cnVlIGFtYmlndWl0eSBpbiB0aGUgaW5wdXQuXHJcblx0ICpcclxuXHQgKiBGb3IgdGhlIHtAbGluayBQcmVkaWN0aW9uTW9kZSNMTF9FWEFDVF9BTUJJR19ERVRFQ1RJT059IHByZWRpY3Rpb24gbW9kZSxcclxuXHQgKiBhY2NlcHQgc3RhdGVzIGFyZSBjb25mbGljdGluZyBidXQgbm90IGV4YWN0IGFyZSB0cmVhdGVkIGFzIG5vbi1hY2NlcHRcclxuXHQgKiBzdGF0ZXMuXHJcblx0ICovXHJcblx0Z2V0IGlzRXhhY3QoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5leGFjdDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChvYmogPT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgQ29uZmxpY3RJbmZvKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuaXNFeGFjdCA9PT0gb2JqLmlzRXhhY3RcclxuXHRcdFx0JiYgVXRpbHMuZXF1YWxzKHRoaXMuY29uZmxpY3RlZEFsdHMsIG9iai5jb25mbGljdGVkQWx0cyk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZsaWN0ZWRBbHRzLmhhc2hDb2RlKCk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0OC4xNDMzNjg2LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4uL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWUgfSBmcm9tIFwiLi9QYXJzZVRyZWVcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlVmlzaXRvciB9IGZyb20gXCIuL1BhcnNlVHJlZVZpc2l0b3JcIjtcclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUnVsZU5vZGUgfSBmcm9tIFwiLi9SdWxlTm9kZVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuLi9Ub2tlblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFRlcm1pbmFsTm9kZSBpbXBsZW1lbnRzIFBhcnNlVHJlZSB7XHJcblx0cHVibGljIF9zeW1ib2w6IFRva2VuO1xyXG5cdHB1YmxpYyBfcGFyZW50OiBSdWxlTm9kZSB8IHVuZGVmaW5lZDtcclxuXHJcblx0Y29uc3RydWN0b3Ioc3ltYm9sOiBUb2tlbikge1xyXG5cdFx0dGhpcy5fc3ltYm9sID0gc3ltYm9sO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGdldENoaWxkKGk6IG51bWJlcik6IG5ldmVyIHtcclxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGVybWluYWwgTm9kZSBoYXMgbm8gY2hpbGRyZW4uXCIpO1xyXG5cdH1cclxuXHJcblx0Z2V0IHN5bWJvbCgpOiBUb2tlbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc3ltYm9sO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHBhcmVudCgpOiBSdWxlTm9kZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHNldFBhcmVudChwYXJlbnQ6IFJ1bGVDb250ZXh0KTogdm9pZCB7XHJcblx0XHR0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgcGF5bG9hZCgpOiBUb2tlbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc3ltYm9sO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNvdXJjZUludGVydmFsKCk6IEludGVydmFsIHtcclxuXHRcdGxldCB0b2tlbkluZGV4OiBudW1iZXIgPSB0aGlzLl9zeW1ib2wudG9rZW5JbmRleDtcclxuXHRcdHJldHVybiBuZXcgSW50ZXJ2YWwodG9rZW5JbmRleCwgdG9rZW5JbmRleCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgY2hpbGRDb3VudCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgYWNjZXB0PFQ+KHZpc2l0b3I6IFBhcnNlVHJlZVZpc2l0b3I8VD4pOiBUIHtcclxuXHRcdHJldHVybiB2aXNpdG9yLnZpc2l0VGVybWluYWwodGhpcyk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgdGV4dCgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbC50ZXh0IHx8IFwiXCI7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmdUcmVlKHBhcnNlcj86IFBhcnNlcik6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRpZiAodGhpcy5fc3ltYm9sLnR5cGUgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHRyZXR1cm4gXCI8RU9GPlwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9zeW1ib2wudGV4dCB8fCBcIlwiO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDcuNDY0NjM1NS0wNzowMFxyXG5cclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWVWaXNpdG9yIH0gZnJvbSBcIi4vUGFyc2VUcmVlVmlzaXRvclwiO1xyXG5pbXBvcnQgeyBUZXJtaW5hbE5vZGUgfSBmcm9tIFwiLi9UZXJtaW5hbE5vZGVcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi4vVG9rZW5cIjtcclxuXHJcbi8qKiBSZXByZXNlbnRzIGEgdG9rZW4gdGhhdCB3YXMgY29uc3VtZWQgZHVyaW5nIHJlc3luY2hyb25pemF0aW9uXHJcbiAqICByYXRoZXIgdGhhbiBkdXJpbmcgYSB2YWxpZCBtYXRjaCBvcGVyYXRpb24uIEZvciBleGFtcGxlLFxyXG4gKiAgd2Ugd2lsbCBjcmVhdGUgdGhpcyBraW5kIG9mIGEgbm9kZSBkdXJpbmcgc2luZ2xlIHRva2VuIGluc2VydGlvblxyXG4gKiAgYW5kIGRlbGV0aW9uIGFzIHdlbGwgYXMgZHVyaW5nIFwiY29uc3VtZSB1bnRpbCBlcnJvciByZWNvdmVyeSBzZXRcIlxyXG4gKiAgdXBvbiBubyB2aWFibGUgYWx0ZXJuYXRpdmUgZXhjZXB0aW9ucy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBFcnJvck5vZGUgZXh0ZW5kcyBUZXJtaW5hbE5vZGUge1xyXG5cdGNvbnN0cnVjdG9yKHRva2VuOiBUb2tlbikge1xyXG5cdFx0c3VwZXIodG9rZW4pO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGFjY2VwdDxUPih2aXNpdG9yOiBQYXJzZVRyZWVWaXNpdG9yPFQ+KTogVCB7XHJcblx0XHRyZXR1cm4gdmlzaXRvci52aXNpdEVycm9yTm9kZSh0aGlzKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ3LjkyMzI3NTYtMDc6MDBcclxuXHJcbmltcG9ydCB7IFJ1bGVDb250ZXh0IH0gZnJvbSBcIi4uL1J1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWVWaXNpdG9yIH0gZnJvbSBcIi4vUGFyc2VUcmVlVmlzaXRvclwiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4uL21pc2MvSW50ZXJ2YWxcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSdWxlTm9kZSBpbXBsZW1lbnRzIFBhcnNlVHJlZSB7XHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHJ1bGVDb250ZXh0OiBSdWxlQ29udGV4dDtcclxuXHJcblx0Ly9AT3ZlcnJpZGVcclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgcGFyZW50OiBSdWxlTm9kZSB8IHVuZGVmaW5lZDtcclxuXHJcblx0cHVibGljIGFic3RyYWN0IHNldFBhcmVudChwYXJlbnQ6IFJ1bGVDb250ZXh0KTogdm9pZDtcclxuXHJcblx0cHVibGljIGFic3RyYWN0IGdldENoaWxkKGk6IG51bWJlcik6IFBhcnNlVHJlZTtcclxuXHJcblx0cHVibGljIGFic3RyYWN0IGFjY2VwdDxUPih2aXNpdG9yOiBQYXJzZVRyZWVWaXNpdG9yPFQ+KTogVDtcclxuXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHRleHQ6IHN0cmluZztcclxuXHJcblx0cHVibGljIGFic3RyYWN0IHRvU3RyaW5nVHJlZShwYXJzZXI/OiBQYXJzZXIgfCB1bmRlZmluZWQpOiBzdHJpbmc7XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBzb3VyY2VJbnRlcnZhbDogSW50ZXJ2YWw7XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBwYXlsb2FkOiBhbnk7XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBjaGlsZENvdW50OiBudW1iZXI7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ4LjMxODc4NjUtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFycmF5cyB9IGZyb20gXCIuLi9taXNjL0FycmF5c1wiO1xyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi4vYXRuL0FUTlwiO1xyXG5pbXBvcnQgeyBDb21tb25Ub2tlbiB9IGZyb20gXCIuLi9Db21tb25Ub2tlblwiO1xyXG5pbXBvcnQgeyBFcnJvck5vZGUgfSBmcm9tIFwiLi9FcnJvck5vZGVcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4uL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWUgfSBmcm9tIFwiLi9QYXJzZVRyZWVcIjtcclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUnVsZU5vZGUgfSBmcm9tIFwiLi9SdWxlTm9kZVwiO1xyXG5pbXBvcnQgeyBUZXJtaW5hbE5vZGUgfSBmcm9tIFwiLi9UZXJtaW5hbE5vZGVcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVHJlZSB9IGZyb20gXCIuL1RyZWVcIjtcclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4uL21pc2MvVXRpbHNcIjtcclxuXHJcbi8qKiBBIHNldCBvZiB1dGlsaXR5IHJvdXRpbmVzIHVzZWZ1bCBmb3IgYWxsIGtpbmRzIG9mIEFOVExSIHRyZWVzLiAqL1xyXG5leHBvcnQgY2xhc3MgVHJlZXMge1xyXG5cdC8qKiBQcmludCBvdXQgYSB3aG9sZSB0cmVlIGluIExJU1AgZm9ybS4ge0BsaW5rICNnZXROb2RlVGV4dH0gaXMgdXNlZCBvbiB0aGVcclxuXHQgKiAgbm9kZSBwYXlsb2FkcyB0byBnZXQgdGhlIHRleHQgZm9yIHRoZSBub2Rlcy4gIERldGVjdFxyXG5cdCAqICBwYXJzZSB0cmVlcyBhbmQgZXh0cmFjdCBkYXRhIGFwcHJvcHJpYXRlbHkuXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyB0b1N0cmluZ1RyZWUoLypATm90TnVsbCovIHQ6IFRyZWUpOiBzdHJpbmc7XHJcblxyXG5cdC8qKiBQcmludCBvdXQgYSB3aG9sZSB0cmVlIGluIExJU1AgZm9ybS4ge0BsaW5rICNnZXROb2RlVGV4dH0gaXMgdXNlZCBvbiB0aGVcclxuXHQgKiAgbm9kZSBwYXlsb2FkcyB0byBnZXQgdGhlIHRleHQgZm9yIHRoZSBub2Rlcy4gIERldGVjdFxyXG5cdCAqICBwYXJzZSB0cmVlcyBhbmQgZXh0cmFjdCBkYXRhIGFwcHJvcHJpYXRlbHkuXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyB0b1N0cmluZ1RyZWUoLypATm90TnVsbCovIHQ6IFRyZWUsIHJlY29nOiBQYXJzZXIgfCB1bmRlZmluZWQpOiBzdHJpbmc7XHJcblxyXG5cdC8qKiBQcmludCBvdXQgYSB3aG9sZSB0cmVlIGluIExJU1AgZm9ybS4ge0BsaW5rICNnZXROb2RlVGV4dH0gaXMgdXNlZCBvbiB0aGVcclxuXHQgKiAgbm9kZSBwYXlsb2FkcyB0byBnZXQgdGhlIHRleHQgZm9yIHRoZSBub2Rlcy5cclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIHRvU3RyaW5nVHJlZSgvKkBOb3ROdWxsKi8gdDogVHJlZSwgLypATnVsbGFibGUqLyBydWxlTmFtZXM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkKTogc3RyaW5nO1xyXG5cclxuXHRwdWJsaWMgc3RhdGljIHRvU3RyaW5nVHJlZSgvKkBOb3ROdWxsKi8gdDogVHJlZSwgYXJnMj86IFBhcnNlciB8IHN0cmluZ1tdKTogc3RyaW5nO1xyXG5cdHB1YmxpYyBzdGF0aWMgdG9TdHJpbmdUcmVlKEBOb3ROdWxsIHQ6IFRyZWUsIGFyZzI/OiBQYXJzZXIgfCBzdHJpbmdbXSk6IHN0cmluZyB7XHJcblx0XHRsZXQgcnVsZU5hbWVzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcclxuXHRcdGlmIChhcmcyIGluc3RhbmNlb2YgUGFyc2VyKSB7XHJcblx0XHRcdHJ1bGVOYW1lcyA9IGFyZzIucnVsZU5hbWVzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cnVsZU5hbWVzID0gYXJnMjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgczogc3RyaW5nID0gVXRpbHMuZXNjYXBlV2hpdGVzcGFjZSh0aGlzLmdldE5vZGVUZXh0KHQsIHJ1bGVOYW1lcyksIGZhbHNlKTtcclxuXHRcdGlmICh0LmNoaWxkQ291bnQgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIHM7XHJcblx0XHR9XHJcblx0XHRsZXQgYnVmID0gXCJcIjtcclxuXHRcdGJ1ZiArPSAoXCIoXCIpO1xyXG5cdFx0cyA9IFV0aWxzLmVzY2FwZVdoaXRlc3BhY2UodGhpcy5nZXROb2RlVGV4dCh0LCBydWxlTmFtZXMpLCBmYWxzZSk7XHJcblx0XHRidWYgKz0gKHMpO1xyXG5cdFx0YnVmICs9IChcIiBcIik7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHQuY2hpbGRDb3VudDsgaSsrKSB7XHJcblx0XHRcdGlmIChpID4gMCkge1xyXG5cdFx0XHRcdGJ1ZiArPSAoXCIgXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJ1ZiArPSAodGhpcy50b1N0cmluZ1RyZWUodC5nZXRDaGlsZChpKSwgcnVsZU5hbWVzKSk7XHJcblx0XHR9XHJcblx0XHRidWYgKz0gKFwiKVwiKTtcclxuXHRcdHJldHVybiBidWY7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc3RhdGljIGdldE5vZGVUZXh0KC8qQE5vdE51bGwqLyB0OiBUcmVlLCByZWNvZzogUGFyc2VyIHwgdW5kZWZpbmVkKTogc3RyaW5nO1xyXG5cdHB1YmxpYyBzdGF0aWMgZ2V0Tm9kZVRleHQoLypATm90TnVsbCovIHQ6IFRyZWUsIHJ1bGVOYW1lczogc3RyaW5nW10gfCB1bmRlZmluZWQpOiBzdHJpbmc7XHJcblx0cHVibGljIHN0YXRpYyBnZXROb2RlVGV4dCh0OiBUcmVlLCBhcmcyOiBQYXJzZXIgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XHJcblx0XHRsZXQgcnVsZU5hbWVzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcclxuXHRcdGlmIChhcmcyIGluc3RhbmNlb2YgUGFyc2VyKSB7XHJcblx0XHRcdHJ1bGVOYW1lcyA9IGFyZzIucnVsZU5hbWVzO1xyXG5cdFx0fSBlbHNlIGlmIChhcmcyKSB7XHJcblx0XHRcdHJ1bGVOYW1lcyA9IGFyZzI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBubyByZWNvZyBvciBydWxlIG5hbWVzXHJcblx0XHRcdGxldCBwYXlsb2FkID0gdC5wYXlsb2FkO1xyXG5cdFx0XHRpZiAodHlwZW9mIHBheWxvYWQudGV4dCA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRcdHJldHVybiBwYXlsb2FkLnRleHQ7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHQucGF5bG9hZC50b1N0cmluZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0IGluc3RhbmNlb2YgUnVsZU5vZGUpIHtcclxuXHRcdFx0bGV0IHJ1bGVDb250ZXh0OiBSdWxlQ29udGV4dCA9IHQucnVsZUNvbnRleHQ7XHJcblx0XHRcdGxldCBydWxlSW5kZXg6IG51bWJlciA9IHJ1bGVDb250ZXh0LnJ1bGVJbmRleDtcclxuXHRcdFx0bGV0IHJ1bGVOYW1lOiBzdHJpbmcgPSBydWxlTmFtZXNbcnVsZUluZGV4XTtcclxuXHRcdFx0bGV0IGFsdE51bWJlcjogbnVtYmVyID0gcnVsZUNvbnRleHQuYWx0TnVtYmVyO1xyXG5cdFx0XHRpZiAoYWx0TnVtYmVyICE9PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJ1bGVOYW1lICsgXCI6XCIgKyBhbHROdW1iZXI7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJ1bGVOYW1lO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAodCBpbnN0YW5jZW9mIEVycm9yTm9kZSkge1xyXG5cdFx0XHRyZXR1cm4gdC50b1N0cmluZygpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAodCBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZSkge1xyXG5cdFx0XHRsZXQgc3ltYm9sID0gdC5zeW1ib2w7XHJcblx0XHRcdHJldHVybiBzeW1ib2wudGV4dCB8fCBcIlwiO1xyXG5cdFx0fVxyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgbm9kZSB0eXBlXCIpO1xyXG5cdH1cclxuXHJcblx0LyoqIFJldHVybiBvcmRlcmVkIGxpc3Qgb2YgYWxsIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgZ2V0Q2hpbGRyZW4odDogUGFyc2VUcmVlKTogUGFyc2VUcmVlW107XHJcblx0cHVibGljIHN0YXRpYyBnZXRDaGlsZHJlbih0OiBUcmVlKTogVHJlZVtdO1xyXG5cdHB1YmxpYyBzdGF0aWMgZ2V0Q2hpbGRyZW4odDogVHJlZSk6IFRyZWVbXSB7XHJcblx0XHRsZXQga2lkczogVHJlZVtdID0gW107XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHQuY2hpbGRDb3VudDsgaSsrKSB7XHJcblx0XHRcdGtpZHMucHVzaCh0LmdldENoaWxkKGkpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBraWRzO1xyXG5cdH1cclxuXHJcblx0LyoqIFJldHVybiBhIGxpc3Qgb2YgYWxsIGFuY2VzdG9ycyBvZiB0aGlzIG5vZGUuICBUaGUgZmlyc3Qgbm9kZSBvZlxyXG5cdCAqICBsaXN0IGlzIHRoZSByb290IGFuZCB0aGUgbGFzdCBpcyB0aGUgcGFyZW50IG9mIHRoaXMgbm9kZS5cclxuXHQgKlxyXG5cdCAqICBAc2luY2UgNC41LjFcclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIGdldEFuY2VzdG9ycyh0OiBQYXJzZVRyZWUpOiBQYXJzZVRyZWVbXTtcclxuXHRwdWJsaWMgc3RhdGljIGdldEFuY2VzdG9ycyh0OiBUcmVlKTogVHJlZVtdO1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHN0YXRpYyBnZXRBbmNlc3RvcnMoQE5vdE51bGwgdDogVHJlZSk6IFRyZWVbXSB7XHJcblx0XHRsZXQgYW5jZXN0b3JzOiBUcmVlW10gPSBbXTtcclxuXHRcdGxldCBwID0gdC5wYXJlbnQ7XHJcblx0XHR3aGlsZSAocCkge1xyXG5cdFx0XHRhbmNlc3RvcnMudW5zaGlmdChwKTsgLy8gaW5zZXJ0IGF0IHN0YXJ0XHJcblx0XHRcdHAgPSBwLnBhcmVudDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhbmNlc3RvcnM7XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIHRydWUgaWYgdCBpcyB1J3MgcGFyZW50IG9yIGEgbm9kZSBvbiBwYXRoIHRvIHJvb3QgZnJvbSB1LlxyXG5cdCAqICBVc2UgPT09IG5vdCBlcXVhbHMoKS5cclxuXHQgKlxyXG5cdCAqICBAc2luY2UgNC41LjFcclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIGlzQW5jZXN0b3JPZih0OiBUcmVlLCB1OiBUcmVlKTogYm9vbGVhbiB7XHJcblx0XHRpZiAoIXQgfHwgIXUgfHwgIXQucGFyZW50KSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGxldCBwID0gdS5wYXJlbnQ7XHJcblx0XHR3aGlsZSAocCkge1xyXG5cdFx0XHRpZiAodCA9PT0gcCkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHAgPSBwLnBhcmVudDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZmluZEFsbFRva2VuTm9kZXModDogUGFyc2VUcmVlLCB0dHlwZTogbnVtYmVyKTogUGFyc2VUcmVlW10ge1xyXG5cdFx0cmV0dXJuIFRyZWVzLmZpbmRBbGxOb2Rlcyh0LCB0dHlwZSwgdHJ1ZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc3RhdGljIGZpbmRBbGxSdWxlTm9kZXModDogUGFyc2VUcmVlLCBydWxlSW5kZXg6IG51bWJlcik6IFBhcnNlVHJlZVtdIHtcclxuXHRcdHJldHVybiBUcmVlcy5maW5kQWxsTm9kZXModCwgcnVsZUluZGV4LCBmYWxzZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc3RhdGljIGZpbmRBbGxOb2Rlcyh0OiBQYXJzZVRyZWUsIGluZGV4OiBudW1iZXIsIGZpbmRUb2tlbnM6IGJvb2xlYW4pOiBQYXJzZVRyZWVbXSB7XHJcblx0XHRsZXQgbm9kZXM6IFBhcnNlVHJlZVtdID0gW107XHJcblx0XHRUcmVlcy5fZmluZEFsbE5vZGVzKHQsIGluZGV4LCBmaW5kVG9rZW5zLCBub2Rlcyk7XHJcblx0XHRyZXR1cm4gbm9kZXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc3RhdGljIF9maW5kQWxsTm9kZXModDogUGFyc2VUcmVlLCBpbmRleDogbnVtYmVyLCBmaW5kVG9rZW5zOiBib29sZWFuLCBub2RlczogUGFyc2VUcmVlW10pOiB2b2lkIHtcclxuXHRcdC8vIGNoZWNrIHRoaXMgbm9kZSAodGhlIHJvb3QpIGZpcnN0XHJcblx0XHRpZiAoZmluZFRva2VucyAmJiB0IGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XHJcblx0XHRcdGlmICh0LnN5bWJvbC50eXBlID09PSBpbmRleCkge1xyXG5cdFx0XHRcdG5vZGVzLnB1c2godCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKCFmaW5kVG9rZW5zICYmIHQgaW5zdGFuY2VvZiBQYXJzZXJSdWxlQ29udGV4dCkge1xyXG5cdFx0XHRpZiAodC5ydWxlSW5kZXggPT09IGluZGV4KSB7XHJcblx0XHRcdFx0bm9kZXMucHVzaCh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly8gY2hlY2sgY2hpbGRyZW5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdC5jaGlsZENvdW50OyBpKyspIHtcclxuXHRcdFx0VHJlZXMuX2ZpbmRBbGxOb2Rlcyh0LmdldENoaWxkKGkpLCBpbmRleCwgZmluZFRva2Vucywgbm9kZXMpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqIEdldCBhbGwgZGVzY2VuZGVudHM7IGluY2x1ZGVzIHQgaXRzZWxmLlxyXG5cdCAqXHJcblx0ICogQHNpbmNlIDQuNS4xXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyBnZXREZXNjZW5kYW50cyh0OiBQYXJzZVRyZWUpOiBQYXJzZVRyZWVbXSB7XHJcblx0XHRsZXQgbm9kZXM6IFBhcnNlVHJlZVtdID0gW107XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVjdXJzZShlOiBQYXJzZVRyZWUpOiB2b2lkIHtcclxuXHRcdFx0bm9kZXMucHVzaChlKTtcclxuXHRcdFx0Y29uc3QgbiA9IGUuY2hpbGRDb3VudDtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0XHRyZWN1cnNlKGUuZ2V0Q2hpbGQoaSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmVjdXJzZSh0KTtcclxuXHRcdHJldHVybiBub2RlcztcclxuXHR9XHJcblxyXG5cdC8qKiBGaW5kIHNtYWxsZXN0IHN1YnRyZWUgb2YgdCBlbmNsb3NpbmcgcmFuZ2Ugc3RhcnRUb2tlbkluZGV4Li5zdG9wVG9rZW5JbmRleFxyXG5cdCAqICBpbmNsdXNpdmVseSB1c2luZyBwb3N0b3JkZXIgdHJhdmVyc2FsLiAgUmVjdXJzaXZlIGRlcHRoLWZpcnN0LXNlYXJjaC5cclxuXHQgKlxyXG5cdCAqICBAc2luY2UgNC41XHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyBnZXRSb290T2ZTdWJ0cmVlRW5jbG9zaW5nUmVnaW9uKFxyXG5cdFx0QE5vdE51bGwgdDogUGFyc2VUcmVlLFxyXG5cdFx0c3RhcnRUb2tlbkluZGV4OiBudW1iZXIsIC8vIGluY2x1c2l2ZVxyXG5cdFx0c3RvcFRva2VuSW5kZXg6IG51bWJlciwgLy8gaW5jbHVzaXZlXHJcblx0KTogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IG46IG51bWJlciA9IHQuY2hpbGRDb3VudDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdGxldCBjaGlsZDogUGFyc2VUcmVlID0gdC5nZXRDaGlsZChpKTtcclxuXHRcdFx0bGV0IHIgPSBUcmVlcy5nZXRSb290T2ZTdWJ0cmVlRW5jbG9zaW5nUmVnaW9uKGNoaWxkLCBzdGFydFRva2VuSW5kZXgsIHN0b3BUb2tlbkluZGV4KTtcclxuXHRcdFx0aWYgKHIpIHtcclxuXHRcdFx0XHRyZXR1cm4gcjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHQgaW5zdGFuY2VvZiBQYXJzZXJSdWxlQ29udGV4dCkge1xyXG5cdFx0XHRsZXQgc3RvcFRva2VuID0gdC5zdG9wO1xyXG5cdFx0XHRpZiAoc3RhcnRUb2tlbkluZGV4ID49IHQuc3RhcnQudG9rZW5JbmRleCAmJiAvLyBpcyByYW5nZSBmdWxseSBjb250YWluZWQgaW4gdD9cclxuXHRcdFx0XHQoc3RvcFRva2VuID09IG51bGwgfHwgc3RvcFRva2VuSW5kZXggPD0gc3RvcFRva2VuLnRva2VuSW5kZXgpKSB7XHJcblx0XHRcdFx0Ly8gbm90ZTogci5zdG9wPT1udWxsIGxpa2VseSBpbXBsaWVzIHRoYXQgd2UgYmFpbGVkIG91dCBvZiBwYXJzZXIgYW5kIHRoZXJlJ3Mgbm90aGluZyB0byB0aGUgcmlnaHRcclxuXHRcdFx0XHRyZXR1cm4gdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdC8qKiBSZXBsYWNlIGFueSBzdWJ0cmVlIHNpYmxpbmdzIG9mIHJvb3QgdGhhdCBhcmUgY29tcGxldGVseSB0byBsZWZ0XHJcblx0ICogIG9yIHJpZ2h0IG9mIGxvb2thaGVhZCByYW5nZSB3aXRoIGEgQ29tbW9uVG9rZW4oVG9rZW4uSU5WQUxJRF9UWVBFLFwiLi4uXCIpXHJcblx0ICogIG5vZGUuIFRoZSBzb3VyY2UgaW50ZXJ2YWwgZm9yIHQgaXMgbm90IGFsdGVyZWQgdG8gc3VpdCBzbWFsbGVyIHJhbmdlIVxyXG5cdCAqXHJcblx0ICogIFdBUk5JTkc6IGRlc3RydWN0aXZlIHRvIHQuXHJcblx0ICpcclxuXHQgKiAgQHNpbmNlIDQuNS4xXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyBzdHJpcENoaWxkcmVuT3V0T2ZSYW5nZShcclxuXHRcdHQ6IFBhcnNlclJ1bGVDb250ZXh0LFxyXG5cdFx0cm9vdDogUGFyc2VyUnVsZUNvbnRleHQsXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKCF0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGxldCBjb3VudCA9IHQuY2hpbGRDb3VudDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG5cdFx0XHRsZXQgY2hpbGQgPSB0LmdldENoaWxkKGkpO1xyXG5cdFx0XHRsZXQgcmFuZ2U6IEludGVydmFsID0gY2hpbGQuc291cmNlSW50ZXJ2YWw7XHJcblx0XHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIFBhcnNlclJ1bGVDb250ZXh0ICYmIChyYW5nZS5iIDwgc3RhcnRJbmRleCB8fCByYW5nZS5hID4gc3RvcEluZGV4KSkge1xyXG5cdFx0XHRcdGlmIChUcmVlcy5pc0FuY2VzdG9yT2YoY2hpbGQsIHJvb3QpKSB7IC8vIHJlcGxhY2Ugb25seSBpZiBzdWJ0cmVlIGRvZXNuJ3QgaGF2ZSBkaXNwbGF5ZWQgcm9vdFxyXG5cdFx0XHRcdFx0bGV0IGFiYnJldjogQ29tbW9uVG9rZW4gPSBuZXcgQ29tbW9uVG9rZW4oVG9rZW4uSU5WQUxJRF9UWVBFLCBcIi4uLlwiKTtcclxuXHRcdFx0XHRcdHQuY2hpbGRyZW4hW2ldID0gbmV3IFRlcm1pbmFsTm9kZShhYmJyZXYpOyAvLyBIQUNLIGFjY2VzcyB0byBwcml2YXRlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIGZpcnN0IG5vZGUgc2F0aXNmeWluZyB0aGUgcHJlZFxyXG5cdCAqXHJcblx0ICogIEBzaW5jZSA0LjUuMVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgZmluZE5vZGVTdWNoVGhhdCh0OiBQYXJzZVRyZWUsIHByZWQ6ICh0cmVlOiBQYXJzZVRyZWUpID0+IGJvb2xlYW4pOiBQYXJzZVRyZWUgfCB1bmRlZmluZWQ7XHJcblx0cHVibGljIHN0YXRpYyBmaW5kTm9kZVN1Y2hUaGF0KHQ6IFRyZWUsIHByZWQ6ICh0cmVlOiBUcmVlKSA9PiBib29sZWFuKTogVHJlZSB8IHVuZGVmaW5lZDtcclxuXHRwdWJsaWMgc3RhdGljIGZpbmROb2RlU3VjaFRoYXQodDogVHJlZSwgcHJlZDogKHRyZWU6IFBhcnNlVHJlZSkgPT4gYm9vbGVhbik6IFRyZWUgfCB1bmRlZmluZWQge1xyXG5cdFx0Ly8gTm8gdHlwZSBjaGVjayBuZWVkZWQgYXMgbG9uZyBhcyB1c2VycyBvbmx5IHVzZSBvbmUgb2YgdGhlIGF2YWlsYWJsZSBvdmVybG9hZHNcclxuXHRcdGlmIChwcmVkKHQgYXMgUGFyc2VUcmVlKSkge1xyXG5cdFx0XHRyZXR1cm4gdDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbjogbnVtYmVyID0gIHQuY2hpbGRDb3VudDtcclxuXHRcdGZvciAobGV0IGkgPSAwIDsgaSA8IG4gOyBpKyspe1xyXG5cdFx0XHRsZXQgdSA9IFRyZWVzLmZpbmROb2RlU3VjaFRoYXQodC5nZXRDaGlsZChpKSwgcHJlZCBhcyAodHJlZTogVHJlZSkgPT4gYm9vbGVhbik7XHJcblx0XHRcdGlmICh1ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Ny4zNDkwODM3LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9hdG4vQVROXCI7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4vUmVjb2duaXplclwiO1xyXG5pbXBvcnQgeyBSdWxlTm9kZSB9IGZyb20gXCIuL3RyZWUvUnVsZU5vZGVcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlIH0gZnJvbSBcIi4vdHJlZS9QYXJzZVRyZWVcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUcmVlcyB9IGZyb20gXCIuL3RyZWUvVHJlZXNcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlVmlzaXRvciB9IGZyb20gXCIuL3RyZWUvUGFyc2VUcmVlVmlzaXRvclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuL1BhcnNlclJ1bGVDb250ZXh0XCI7XHJcblxyXG4vKiogQSBydWxlIGNvbnRleHQgaXMgYSByZWNvcmQgb2YgYSBzaW5nbGUgcnVsZSBpbnZvY2F0aW9uLlxyXG4gKlxyXG4gKiAgV2UgZm9ybSBhIHN0YWNrIG9mIHRoZXNlIGNvbnRleHQgb2JqZWN0cyB1c2luZyB0aGUgcGFyZW50XHJcbiAqICBwb2ludGVyLiBBIHBhcmVudCBwb2ludGVyIG9mIGB1bmRlZmluZWRgIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50XHJcbiAqICBjb250ZXh0IGlzIHRoZSBib3R0b20gb2YgdGhlIHN0YWNrLiBUaGUgUGFyc2VyUnVsZUNvbnRleHQgc3ViY2xhc3NcclxuICogIGFzIGEgY2hpbGRyZW4gbGlzdCBzbyB0aGF0IHdlIGNhbiB0dXJuIHRoaXMgZGF0YSBzdHJ1Y3R1cmUgaW50byBhXHJcbiAqICB0cmVlLlxyXG4gKlxyXG4gKiAgVGhlIHJvb3Qgbm9kZSBhbHdheXMgaGFzIGEgYHVuZGVmaW5lZGAgcG9pbnRlciBhbmQgaW52b2tpbmdTdGF0ZSBvZiAtMS5cclxuICpcclxuICogIFVwb24gZW50cnkgdG8gcGFyc2luZywgdGhlIGZpcnN0IGludm9rZWQgcnVsZSBmdW5jdGlvbiBjcmVhdGVzIGFcclxuICogIGNvbnRleHQgb2JqZWN0IChhIHN1YmNsYXNzIHNwZWNpYWxpemVkIGZvciB0aGF0IHJ1bGUgc3VjaCBhc1xyXG4gKiAgU0NvbnRleHQpIGFuZCBtYWtlcyBpdCB0aGUgcm9vdCBvZiBhIHBhcnNlIHRyZWUsIHJlY29yZGVkIGJ5IGZpZWxkXHJcbiAqICBQYXJzZXIuX2N0eC5cclxuICpcclxuICogIHB1YmxpYyBmaW5hbCBTQ29udGV4dCBzKCkgdGhyb3dzIFJlY29nbml0aW9uRXhjZXB0aW9uIHtcclxuICogICAgICBTQ29udGV4dCBfbG9jYWxjdHggPSBuZXcgU0NvbnRleHQoX2N0eCwgc3RhdGUpOyA8LS0gY3JlYXRlIG5ldyBub2RlXHJcbiAqICAgICAgZW50ZXJSdWxlKF9sb2NhbGN0eCwgMCwgUlVMRV9zKTsgICAgICAgICAgICAgICAgICAgICA8LS0gcHVzaCBpdFxyXG4gKiAgICAgIC4uLlxyXG4gKiAgICAgIGV4aXRSdWxlKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tIHBvcCBiYWNrIHRvIF9sb2NhbGN0eFxyXG4gKiAgICAgIHJldHVybiBfbG9jYWxjdHg7XHJcbiAqICB9XHJcbiAqXHJcbiAqICBBIHN1YnNlcXVlbnQgcnVsZSBpbnZvY2F0aW9uIG9mIHIgZnJvbSB0aGUgc3RhcnQgcnVsZSBzIHB1c2hlcyBhXHJcbiAqICBuZXcgY29udGV4dCBvYmplY3QgZm9yIHIgd2hvc2UgcGFyZW50IHBvaW50cyBhdCBzIGFuZCB1c2UgaW52b2tpbmdcclxuICogIHN0YXRlIGlzIHRoZSBzdGF0ZSB3aXRoIHIgZW1hbmF0aW5nIGFzIGVkZ2UgbGFiZWwuXHJcbiAqXHJcbiAqICBUaGUgaW52b2tpbmdTdGF0ZSBmaWVsZHMgZnJvbSBhIGNvbnRleHQgb2JqZWN0IHRvIHRoZSByb290XHJcbiAqICB0b2dldGhlciBmb3JtIGEgc3RhY2sgb2YgcnVsZSBpbmRpY2F0aW9uIHN0YXRlcyB3aGVyZSB0aGUgcm9vdFxyXG4gKiAgKGJvdHRvbSBvZiB0aGUgc3RhY2spIGhhcyBhIC0xIHNlbnRpbmVsIHZhbHVlLiBJZiB3ZSBpbnZva2Ugc3RhcnRcclxuICogIHN5bWJvbCBzIHRoZW4gY2FsbCByMSwgd2hpY2ggY2FsbHMgcjIsIHRoZSAgd291bGQgbG9vayBsaWtlXHJcbiAqICB0aGlzOlxyXG4gKlxyXG4gKiAgICAgU0NvbnRleHRbLTFdICAgPC0gcm9vdCBub2RlIChib3R0b20gb2YgdGhlIHN0YWNrKVxyXG4gKiAgICAgUjFDb250ZXh0W3BdICAgPC0gcCBpbiBydWxlIHMgY2FsbGVkIHIxXHJcbiAqICAgICBSMkNvbnRleHRbcV0gICA8LSBxIGluIHJ1bGUgcjEgY2FsbGVkIHIyXHJcbiAqXHJcbiAqICBTbyB0aGUgdG9wIG9mIHRoZSBzdGFjaywgX2N0eCwgcmVwcmVzZW50cyBhIGNhbGwgdG8gdGhlIGN1cnJlbnRcclxuICogIHJ1bGUgYW5kIGl0IGhvbGRzIHRoZSByZXR1cm4gYWRkcmVzcyBmcm9tIGFub3RoZXIgcnVsZSB0aGF0IGludm9rZVxyXG4gKiAgdG8gdGhpcyBydWxlLiBUbyBpbnZva2UgYSBydWxlLCB3ZSBtdXN0IGFsd2F5cyBoYXZlIGEgY3VycmVudCBjb250ZXh0LlxyXG4gKlxyXG4gKiAgVGhlIHBhcmVudCBjb250ZXh0cyBhcmUgdXNlZnVsIGZvciBjb21wdXRpbmcgbG9va2FoZWFkIHNldHMgYW5kXHJcbiAqICBnZXR0aW5nIGVycm9yIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiAgVGhlc2Ugb2JqZWN0cyBhcmUgdXNlZCBkdXJpbmcgcGFyc2luZyBhbmQgcHJlZGljdGlvbi5cclxuICogIEZvciB0aGUgc3BlY2lhbCBjYXNlIG9mIHBhcnNlcnMsIHdlIHVzZSB0aGUgc3ViY2xhc3NcclxuICogIFBhcnNlclJ1bGVDb250ZXh0LlxyXG4gKlxyXG4gKiAgQHNlZSBQYXJzZXJSdWxlQ29udGV4dFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVDb250ZXh0IGV4dGVuZHMgUnVsZU5vZGUge1xyXG5cdHB1YmxpYyBfcGFyZW50OiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZDtcclxuXHRwdWJsaWMgaW52b2tpbmdTdGF0ZTogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpO1xyXG5cdGNvbnN0cnVjdG9yKHBhcmVudDogUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsIGludm9raW5nU3RhdGU6IG51bWJlcik7XHJcblx0Y29uc3RydWN0b3IocGFyZW50PzogUnVsZUNvbnRleHQsIGludm9raW5nU3RhdGU/OiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKCk7XHJcblx0XHR0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XHJcblx0XHR0aGlzLmludm9raW5nU3RhdGUgPSBpbnZva2luZ1N0YXRlICE9IG51bGwgPyBpbnZva2luZ1N0YXRlIDogLTE7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc3RhdGljIGdldENoaWxkQ29udGV4dChwYXJlbnQ6IFJ1bGVDb250ZXh0LCBpbnZva2luZ1N0YXRlOiBudW1iZXIpOiBSdWxlQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gbmV3IFJ1bGVDb250ZXh0KHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZGVwdGgoKTogbnVtYmVyIHtcclxuXHRcdGxldCBuID0gMDtcclxuXHRcdGxldCBwOiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCA9IHRoaXM7XHJcblx0XHR3aGlsZSAocCkge1xyXG5cdFx0XHRwID0gcC5fcGFyZW50O1xyXG5cdFx0XHRuKys7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbjtcclxuXHR9XHJcblxyXG5cdC8qKiBBIGNvbnRleHQgaXMgZW1wdHkgaWYgdGhlcmUgaXMgbm8gaW52b2tpbmcgc3RhdGU7IG1lYW5pbmcgbm9ib2R5IGNhbGxlZFxyXG5cdCAqICBjdXJyZW50IGNvbnRleHQuXHJcblx0ICovXHJcblx0Z2V0IGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2luZ1N0YXRlID09PSAtMTtcclxuXHR9XHJcblxyXG5cdC8vIHNhdGlzZnkgdGhlIFBhcnNlVHJlZSAvIFN5bnRheFRyZWUgaW50ZXJmYWNlXHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzb3VyY2VJbnRlcnZhbCgpOiBJbnRlcnZhbCB7XHJcblx0XHRyZXR1cm4gSW50ZXJ2YWwuSU5WQUxJRDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBydWxlQ29udGV4dCgpOiBSdWxlQ29udGV4dCB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBwYXJlbnQoKTogUnVsZUNvbnRleHQgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy5fcGFyZW50OyB9XHJcblxyXG5cdC8qKiBAc2luY2UgNC43LiB7QHNlZSBQYXJzZVRyZWUjc2V0UGFyZW50fSBjb21tZW50ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHNldFBhcmVudChwYXJlbnQ6IFJ1bGVDb250ZXh0KTogdm9pZCB7XHJcblx0XHR0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgcGF5bG9hZCgpOiBSdWxlQ29udGV4dCB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdC8qKiBSZXR1cm4gdGhlIGNvbWJpbmVkIHRleHQgb2YgYWxsIGNoaWxkIG5vZGVzLiBUaGlzIG1ldGhvZCBvbmx5IGNvbnNpZGVyc1xyXG5cdCAqICB0b2tlbnMgd2hpY2ggaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBwYXJzZSB0cmVlLlxyXG5cdCAqXHJcblx0ICogIFNpbmNlIHRva2VucyBvbiBoaWRkZW4gY2hhbm5lbHMgKGUuZy4gd2hpdGVzcGFjZSBvciBjb21tZW50cykgYXJlIG5vdFxyXG5cdCAqICBhZGRlZCB0byB0aGUgcGFyc2UgdHJlZXMsIHRoZXkgd2lsbCBub3QgYXBwZWFyIGluIHRoZSBvdXRwdXQgb2YgdGhpc1xyXG5cdCAqICBtZXRob2QuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHRleHQoKTogc3RyaW5nIHtcclxuXHRcdGlmICh0aGlzLmNoaWxkQ291bnQgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGJ1aWxkZXIgPSBcIlwiO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkQ291bnQ7IGkrKykge1xyXG5cdFx0XHRidWlsZGVyICs9IHRoaXMuZ2V0Q2hpbGQoaSkudGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYnVpbGRlci50b1N0cmluZygpO1xyXG5cdH1cclxuXHJcblx0Z2V0IHJ1bGVJbmRleCgpOiBudW1iZXIgeyByZXR1cm4gLTE7IH1cclxuXHJcblx0LyoqIEZvciBydWxlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHBhcnNlIHRyZWUgaW50ZXJuYWwgbm9kZSwgcmV0dXJuXHJcblx0ICogIHRoZSBvdXRlciBhbHRlcm5hdGl2ZSBudW1iZXIgdXNlZCB0byBtYXRjaCB0aGUgaW5wdXQuIERlZmF1bHRcclxuXHQgKiAgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgY29tcHV0ZSBub3Igc3RvcmUgdGhpcyBhbHQgbnVtLiBDcmVhdGVcclxuXHQgKiAgYSBzdWJjbGFzcyBvZiBQYXJzZXJSdWxlQ29udGV4dCB3aXRoIGJhY2tpbmcgZmllbGQgYW5kIHNldFxyXG5cdCAqICBvcHRpb24gY29udGV4dFN1cGVyQ2xhc3MuXHJcblx0ICogIHRvIHNldCBpdC5cclxuXHQgKlxyXG5cdCAqICBAc2luY2UgNC41LjNcclxuXHQgKi9cclxuXHRnZXQgYWx0TnVtYmVyKCk6IG51bWJlciB7IHJldHVybiBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSOyB9XHJcblxyXG5cdC8qKiBTZXQgdGhlIG91dGVyIGFsdGVybmF0aXZlIG51bWJlciBmb3IgdGhpcyBjb250ZXh0IG5vZGUuIERlZmF1bHRcclxuXHQgKiAgaW1wbGVtZW50YXRpb24gZG9lcyBub3RoaW5nIHRvIGF2b2lkIGJhY2tpbmcgZmllbGQgb3ZlcmhlYWQgZm9yXHJcblx0ICogIHRyZWVzIHRoYXQgZG9uJ3QgbmVlZCBpdC4gIENyZWF0ZVxyXG5cdCAqICBhIHN1YmNsYXNzIG9mIFBhcnNlclJ1bGVDb250ZXh0IHdpdGggYmFja2luZyBmaWVsZCBhbmQgc2V0XHJcblx0ICogIG9wdGlvbiBjb250ZXh0U3VwZXJDbGFzcy5cclxuXHQgKlxyXG5cdCAqICBAc2luY2UgNC41LjNcclxuXHQgKi9cclxuXHRzZXQgYWx0TnVtYmVyKGFsdE51bWJlcjogbnVtYmVyKSB7XHJcblx0XHQvLyBpbnRlbnRpb25hbGx5IGlnbm9yZWQgYnkgdGhlIGJhc2UgaW1wbGVtZW50YXRpb25cclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXRDaGlsZChpOiBudW1iZXIpOiBQYXJzZVRyZWUge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgYW5kIGxlc3MgdGhhbiBjaGlsZENvdW50XCIpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGNoaWxkQ291bnQoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiAwO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGFjY2VwdDxUPih2aXNpdG9yOiBQYXJzZVRyZWVWaXNpdG9yPFQ+KTogVCB7XHJcblx0XHRyZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG5cdH1cclxuXHJcblx0LyoqIFByaW50IG91dCBhIHdob2xlIHRyZWUsIG5vdCBqdXN0IGEgbm9kZSwgaW4gTElTUCBmb3JtYXRcclxuXHQgKiAgKHJvb3QgY2hpbGQxIC4uIGNoaWxkTikuIFByaW50IGp1c3QgYSBub2RlIGlmIHRoaXMgaXMgYSBsZWFmLlxyXG5cdCAqICBXZSBoYXZlIHRvIGtub3cgdGhlIHJlY29nbml6ZXIgc28gd2UgY2FuIGdldCBydWxlIG5hbWVzLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyB0b1N0cmluZ1RyZWUocmVjb2c6IFBhcnNlcik6IHN0cmluZztcclxuXHJcblx0LyoqIFByaW50IG91dCBhIHdob2xlIHRyZWUsIG5vdCBqdXN0IGEgbm9kZSwgaW4gTElTUCBmb3JtYXRcclxuXHQgKiAgKHJvb3QgY2hpbGQxIC4uIGNoaWxkTikuIFByaW50IGp1c3QgYSBub2RlIGlmIHRoaXMgaXMgYSBsZWFmLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyB0b1N0cmluZ1RyZWUocnVsZU5hbWVzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCk6IHN0cmluZztcclxuXHJcblx0cHVibGljIHRvU3RyaW5nVHJlZSgpOiBzdHJpbmc7XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZ1RyZWUocmVjb2c/OiBQYXJzZXIgfCBzdHJpbmdbXSk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gVHJlZXMudG9TdHJpbmdUcmVlKHRoaXMsIHJlY29nKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmc7XHJcblx0cHVibGljIHRvU3RyaW5nKHJlY29nOiBSZWNvZ25pemVyPGFueSwgYW55PiB8IHVuZGVmaW5lZCk6IHN0cmluZztcclxuXHRwdWJsaWMgdG9TdHJpbmcocnVsZU5hbWVzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCk6IHN0cmluZztcclxuXHJcblx0Ly8gLy8gcmVjb2cgdW5kZWZpbmVkIHVubGVzcyBQYXJzZXJSdWxlQ29udGV4dCwgaW4gd2hpY2ggY2FzZSB3ZSB1c2Ugc3ViY2xhc3MgdG9TdHJpbmcoLi4uKVxyXG5cdHB1YmxpYyB0b1N0cmluZyhyZWNvZzogUmVjb2duaXplcjxhbnksIGFueT4gfCB1bmRlZmluZWQsIHN0b3A6IFJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkKTogc3RyaW5nO1xyXG5cclxuXHRwdWJsaWMgdG9TdHJpbmcocnVsZU5hbWVzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCwgc3RvcDogUnVsZUNvbnRleHQgfCB1bmRlZmluZWQpOiBzdHJpbmc7XHJcblxyXG5cdHB1YmxpYyB0b1N0cmluZyhcclxuXHRcdGFyZzE/OiBSZWNvZ25pemVyPGFueSwgYW55PiB8IHN0cmluZ1tdLFxyXG5cdFx0c3RvcD86IFJ1bGVDb250ZXh0KVxyXG5cdFx0OiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgcnVsZU5hbWVzID0gKGFyZzEgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSA/IGFyZzEucnVsZU5hbWVzIDogYXJnMTtcclxuXHRcdHN0b3AgPSBzdG9wIHx8IFBhcnNlclJ1bGVDb250ZXh0LmVtcHR5Q29udGV4dCgpO1xyXG5cclxuXHRcdGxldCBidWYgPSBcIlwiO1xyXG5cdFx0bGV0IHA6IFJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkID0gdGhpcztcclxuXHRcdGJ1ZiArPSAoXCJbXCIpO1xyXG5cdFx0d2hpbGUgKHAgJiYgcCAhPT0gc3RvcCkge1xyXG5cdFx0XHRpZiAoIXJ1bGVOYW1lcykge1xyXG5cdFx0XHRcdGlmICghcC5pc0VtcHR5KSB7XHJcblx0XHRcdFx0XHRidWYgKz0gKHAuaW52b2tpbmdTdGF0ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBydWxlSW5kZXg6IG51bWJlciA9IHAucnVsZUluZGV4O1xyXG5cdFx0XHRcdGxldCBydWxlTmFtZTogc3RyaW5nID0gKHJ1bGVJbmRleCA+PSAwICYmIHJ1bGVJbmRleCA8IHJ1bGVOYW1lcy5sZW5ndGgpXHJcblx0XHRcdFx0XHQ/IHJ1bGVOYW1lc1tydWxlSW5kZXhdIDogcnVsZUluZGV4LnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0YnVmICs9IChydWxlTmFtZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChwLl9wYXJlbnQgJiYgKHJ1bGVOYW1lcyB8fCAhcC5fcGFyZW50LmlzRW1wdHkpKSB7XHJcblx0XHRcdFx0YnVmICs9IChcIiBcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHAgPSBwLl9wYXJlbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0YnVmICs9IChcIl1cIik7XHJcblx0XHRyZXR1cm4gYnVmLnRvU3RyaW5nKCk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Ni42Mjg1NDk0LTA3OjAwXHJcbmltcG9ydCB7IEVycm9yTm9kZSB9IGZyb20gXCIuL3RyZWUvRXJyb3JOb2RlXCI7XHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuL3RyZWUvUGFyc2VUcmVlXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZUxpc3RlbmVyIH0gZnJvbSBcIi4vdHJlZS9QYXJzZVRyZWVMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgVGVybWluYWxOb2RlIH0gZnJvbSBcIi4vdHJlZS9UZXJtaW5hbE5vZGVcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblwiO1xyXG5cclxuLyoqIEEgcnVsZSBpbnZvY2F0aW9uIHJlY29yZCBmb3IgcGFyc2luZy5cclxuICpcclxuICogIENvbnRhaW5zIGFsbCBvZiB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgcnVsZSBub3Qgc3RvcmVkIGluIHRoZVxyXG4gKiAgUnVsZUNvbnRleHQuIEl0IGhhbmRsZXMgcGFyc2UgdHJlZSBjaGlsZHJlbiBsaXN0LCBBbnkgQVROIHN0YXRlXHJcbiAqICB0cmFjaW5nLCBhbmQgdGhlIGRlZmF1bHQgdmFsdWVzIGF2YWlsYWJsZSBmb3IgcnVsZSBpbnZvY2F0aW9uczpcclxuICogIHN0YXJ0LCBzdG9wLCBydWxlIGluZGV4LCBjdXJyZW50IGFsdCBudW1iZXIuXHJcbiAqXHJcbiAqICBTdWJjbGFzc2VzIG1hZGUgZm9yIGVhY2ggcnVsZSBhbmQgZ3JhbW1hciB0cmFjayB0aGUgcGFyYW1ldGVycyxcclxuICogIHJldHVybiB2YWx1ZXMsIGxvY2FscywgYW5kIGxhYmVscyBzcGVjaWZpYyB0byB0aGF0IHJ1bGUuIFRoZXNlXHJcbiAqICBhcmUgdGhlIG9iamVjdHMgdGhhdCBhcmUgcmV0dXJuZWQgZnJvbSBydWxlcy5cclxuICpcclxuICogIE5vdGUgdGV4dCBpcyBub3QgYW4gYWN0dWFsIGZpZWxkIG9mIGEgcnVsZSByZXR1cm4gdmFsdWU7IGl0IGlzIGNvbXB1dGVkXHJcbiAqICBmcm9tIHN0YXJ0IGFuZCBzdG9wIHVzaW5nIHRoZSBpbnB1dCBzdHJlYW0ncyB0b1N0cmluZygpIG1ldGhvZC4gIElcclxuICogIGNvdWxkIGFkZCBhIGN0b3IgdG8gdGhpcyBzbyB0aGF0IHdlIGNhbiBwYXNzIGluIGFuZCBzdG9yZSB0aGUgaW5wdXRcclxuICogIHN0cmVhbSwgYnV0IEknbSBub3Qgc3VyZSB3ZSB3YW50IHRvIGRvIHRoYXQuICBJdCB3b3VsZCBzZWVtIHRvIGJlIHVuZGVmaW5lZFxyXG4gKiAgdG8gZ2V0IHRoZSAudGV4dCBwcm9wZXJ0eSBhbnl3YXkgaWYgdGhlIHJ1bGUgbWF0Y2hlcyB0b2tlbnMgZnJvbSBtdWx0aXBsZVxyXG4gKiAgaW5wdXQgc3RyZWFtcy5cclxuICpcclxuICogIEkgZG8gbm90IHVzZSBnZXR0ZXJzIGZvciBmaWVsZHMgb2Ygb2JqZWN0cyB0aGF0IGFyZSB1c2VkIHNpbXBseSB0b1xyXG4gKiAgZ3JvdXAgdmFsdWVzIHN1Y2ggYXMgdGhpcyBhZ2dyZWdhdGUuICBUaGUgZ2V0dGVycy9zZXR0ZXJzIGFyZSB0aGVyZSB0b1xyXG4gKiAgc2F0aXNmeSB0aGUgc3VwZXJjbGFzcyBpbnRlcmZhY2UuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGFyc2VyUnVsZUNvbnRleHQgZXh0ZW5kcyBSdWxlQ29udGV4dCB7XHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRU1QVFk6IFBhcnNlclJ1bGVDb250ZXh0ID0gbmV3IFBhcnNlclJ1bGVDb250ZXh0KCk7XHJcblxyXG5cdC8qKiBJZiB3ZSBhcmUgZGVidWdnaW5nIG9yIGJ1aWxkaW5nIGEgcGFyc2UgdHJlZSBmb3IgYSB2aXNpdG9yLFxyXG5cdCAqICB3ZSBuZWVkIHRvIHRyYWNrIGFsbCBvZiB0aGUgdG9rZW5zIGFuZCBydWxlIGludm9jYXRpb25zIGFzc29jaWF0ZWRcclxuXHQgKiAgd2l0aCB0aGlzIHJ1bGUncyBjb250ZXh0LiBUaGlzIGlzIGVtcHR5IGZvciBwYXJzaW5nIHcvbyB0cmVlIGNvbnN0ci5cclxuXHQgKiAgb3BlcmF0aW9uIGJlY2F1c2Ugd2UgZG9uJ3QgdGhlIG5lZWQgdG8gdHJhY2sgdGhlIGRldGFpbHMgYWJvdXRcclxuXHQgKiAgaG93IHdlIHBhcnNlIHRoaXMgcnVsZS5cclxuXHQgKi9cclxuXHRwdWJsaWMgY2hpbGRyZW4/OiBQYXJzZVRyZWVbXTtcclxuXHJcblx0LyoqIEZvciBkZWJ1Z2dpbmcvdHJhY2luZyBwdXJwb3Nlcywgd2Ugd2FudCB0byB0cmFjayBhbGwgb2YgdGhlIG5vZGVzIGluXHJcblx0ICogIHRoZSBBVE4gdHJhdmVyc2VkIGJ5IHRoZSBwYXJzZXIgZm9yIGEgcGFydGljdWxhciBydWxlLlxyXG5cdCAqICBUaGlzIGxpc3QgaW5kaWNhdGVzIHRoZSBzZXF1ZW5jZSBvZiBBVE4gbm9kZXMgdXNlZCB0byBtYXRjaFxyXG5cdCAqICB0aGUgZWxlbWVudHMgb2YgdGhlIGNoaWxkcmVuIGxpc3QuIFRoaXMgbGlzdCBkb2VzIG5vdCBpbmNsdWRlXHJcblx0ICogIEFUTiBub2RlcyBhbmQgb3RoZXIgcnVsZXMgdXNlZCB0byBtYXRjaCBydWxlIGludm9jYXRpb25zLiBJdFxyXG5cdCAqICB0cmFjZXMgdGhlIHJ1bGUgaW52b2NhdGlvbiBub2RlIGl0c2VsZiBidXQgbm90aGluZyBpbnNpZGUgdGhhdFxyXG5cdCAqICBvdGhlciBydWxlJ3MgQVROIHN1Ym1hY2hpbmUuXHJcblx0ICpcclxuXHQgKiAgVGhlcmUgaXMgTk9UIGEgb25lLXRvLW9uZSBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIHRoZSBjaGlsZHJlbiBhbmRcclxuXHQgKiAgc3RhdGVzIGxpc3QuIFRoZXJlIGFyZSB0eXBpY2FsbHkgbWFueSBub2RlcyBpbiB0aGUgQVROIHRyYXZlcnNlZFxyXG5cdCAqICBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBjaGlsZHJlbiBsaXN0LiBGb3IgZXhhbXBsZSwgZm9yIGEgcnVsZVxyXG5cdCAqICBpbnZvY2F0aW9uIHRoZXJlIGlzIHRoZSBpbnZva2luZyBzdGF0ZSBhbmQgdGhlIGZvbGxvd2luZyBzdGF0ZS5cclxuXHQgKlxyXG5cdCAqICBUaGUgcGFyc2VyIHN0YXRlIHByb3BlcnR5IHVwZGF0ZXMgZmllbGQgcyBhbmQgYWRkcyBpdCB0byB0aGlzIGxpc3RcclxuXHQgKiAgaWYgd2UgYXJlIGRlYnVnZ2luZy90cmFjaW5nLlxyXG5cdCAqXHJcblx0ICogIFRoaXMgZG9lcyBub3QgdHJhY2Ugc3RhdGVzIHZpc2l0ZWQgZHVyaW5nIHByZWRpY3Rpb24uXHJcblx0ICovXHJcbi8vXHRwdWJsaWMgQXJyYXk8bnVtYmVyPiBzdGF0ZXM7XHJcblxyXG5cdHB1YmxpYyBfc3RhcnQhOiBUb2tlbjtcclxuXHRwdWJsaWMgX3N0b3A6IFRva2VuIHwgdW5kZWZpbmVkO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgZXhjZXB0aW9uIHRoYXQgZm9yY2VkIHRoaXMgcnVsZSB0byByZXR1cm4uIElmIHRoZSBydWxlIHN1Y2Nlc3NmdWxseVxyXG5cdCAqIGNvbXBsZXRlZCwgdGhpcyBpcyBgdW5kZWZpbmVkYC5cclxuXHQgKi9cclxuXHRwdWJsaWMgZXhjZXB0aW9uPzogUmVjb2duaXRpb25FeGNlcHRpb247XHJcblxyXG5cdGNvbnN0cnVjdG9yKCk7XHJcblx0Y29uc3RydWN0b3IocGFyZW50OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgaW52b2tpbmdTdGF0ZU51bWJlcjogbnVtYmVyKTtcclxuXHRjb25zdHJ1Y3RvcihwYXJlbnQ/OiBQYXJzZXJSdWxlQ29udGV4dCwgaW52b2tpbmdTdGF0ZU51bWJlcj86IG51bWJlcikge1xyXG5cdFx0aWYgKGludm9raW5nU3RhdGVOdW1iZXIgPT0gbnVsbCkge1xyXG5cdFx0XHRzdXBlcigpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlTnVtYmVyKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZW1wdHlDb250ZXh0KCk6IFBhcnNlclJ1bGVDb250ZXh0IHtcclxuXHRcdHJldHVybiBQYXJzZXJSdWxlQ29udGV4dC5FTVBUWTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENPUFkgYSBjdHggKEknbSBkZWxpYmVyYXRlbHkgbm90IHVzaW5nIGNvcHkgY29uc3RydWN0b3IpIHRvIGF2b2lkXHJcblx0ICogY29uZnVzaW9uIHdpdGggY3JlYXRpbmcgbm9kZSB3aXRoIHBhcmVudC4gRG9lcyBub3QgY29weSBjaGlsZHJlblxyXG5cdCAqIChleGNlcHQgZXJyb3IgbGVhdmVzKS5cclxuXHQgKlxyXG5cdCAqIFRoaXMgaXMgdXNlZCBpbiB0aGUgZ2VuZXJhdGVkIHBhcnNlciBjb2RlIHRvIGZsaXAgYSBnZW5lcmljIFhDb250ZXh0XHJcblx0ICogbm9kZSBmb3IgcnVsZSBYIHRvIGEgWUNvbnRleHQgZm9yIGFsdCBsYWJlbCBZLiBJbiB0aGF0IHNlbnNlLCBpdCBpcyBub3RcclxuXHQgKiByZWFsbHkgYSBnZW5lcmljIGNvcHkgZnVuY3Rpb24uXHJcblx0ICpcclxuXHQgKiBJZiB3ZSBkbyBhbiBlcnJvciBzeW5jKCkgYXQgc3RhcnQgb2YgYSBydWxlLCB3ZSBtaWdodCBhZGQgZXJyb3Igbm9kZXNcclxuXHQgKiB0byB0aGUgZ2VuZXJpYyBYQ29udGV4dCBzbyB0aGlzIGZ1bmN0aW9uIG11c3QgY29weSB0aG9zZSBub2RlcyB0byB0aGVcclxuXHQgKiBZQ29udGV4dCBhcyB3ZWxsIGVsc2UgdGhleSBhcmUgbG9zdCFcclxuXHQgKi9cclxuXHRwdWJsaWMgY29weUZyb20oY3R4OiBQYXJzZXJSdWxlQ29udGV4dCk6IHZvaWQge1xyXG5cdFx0dGhpcy5fcGFyZW50ID0gY3R4Ll9wYXJlbnQ7XHJcblx0XHR0aGlzLmludm9raW5nU3RhdGUgPSBjdHguaW52b2tpbmdTdGF0ZTtcclxuXHJcblx0XHR0aGlzLl9zdGFydCA9IGN0eC5fc3RhcnQ7XHJcblx0XHR0aGlzLl9zdG9wID0gY3R4Ll9zdG9wO1xyXG5cclxuXHRcdC8vIGNvcHkgYW55IGVycm9yIG5vZGVzIHRvIGFsdCBsYWJlbCBub2RlXHJcblx0XHRpZiAoY3R4LmNoaWxkcmVuKSB7XHJcblx0XHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHRcdFx0Ly8gcmVzZXQgcGFyZW50IHBvaW50ZXIgZm9yIGFueSBlcnJvciBub2Rlc1xyXG5cdFx0XHRmb3IgKGxldCBjaGlsZCBvZiBjdHguY2hpbGRyZW4pIHtcclxuXHRcdFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBFcnJvck5vZGUpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkQ2hpbGQoY2hpbGQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gRG91YmxlIGRpc3BhdGNoIG1ldGhvZHMgZm9yIGxpc3RlbmVyc1xyXG5cclxuXHRwdWJsaWMgZW50ZXJSdWxlKGxpc3RlbmVyOiBQYXJzZVRyZWVMaXN0ZW5lcik6IHZvaWQge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH1cclxuXHRwdWJsaWMgZXhpdFJ1bGUobGlzdGVuZXI6IFBhcnNlVHJlZUxpc3RlbmVyKTogdm9pZCB7XHJcblx0XHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcblx0fVxyXG5cclxuXHQvKiogQWRkIGEgcGFyc2UgdHJlZSBub2RlIHRvIHRoaXMgYXMgYSBjaGlsZC4gIFdvcmtzIGZvclxyXG5cdCAqICBpbnRlcm5hbCBhbmQgbGVhZiBub2Rlcy4gRG9lcyBub3Qgc2V0IHBhcmVudCBsaW5rO1xyXG5cdCAqICBvdGhlciBhZGQgbWV0aG9kcyBtdXN0IGRvIHRoYXQuIE90aGVyIGFkZENoaWxkIG1ldGhvZHNcclxuXHQgKiAgY2FsbCB0aGlzLlxyXG5cdCAqXHJcblx0ICogIFdlIGNhbm5vdCBzZXQgdGhlIHBhcmVudCBwb2ludGVyIG9mIHRoZSBpbmNvbWluZyBub2RlXHJcblx0ICogIGJlY2F1c2UgdGhlIGV4aXN0aW5nIGludGVyZmFjZXMgZG8gbm90IGhhdmUgYSBzZXRQYXJlbnQoKVxyXG5cdCAqICBtZXRob2QgYW5kIEkgZG9uJ3Qgd2FudCB0byBicmVhayBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciB0aGlzLlxyXG5cdCAqXHJcblx0ICogIEBzaW5jZSA0LjdcclxuXHQgKi9cclxuXHRwdWJsaWMgYWRkQW55Q2hpbGQ8VCBleHRlbmRzIFBhcnNlVHJlZT4odDogVCk6IFQge1xyXG5cdFx0aWYgKCF0aGlzLmNoaWxkcmVuKSB7XHJcblx0XHRcdHRoaXMuY2hpbGRyZW4gPSBbdF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2godCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHQ7XHJcblx0fVxyXG5cclxuXHQvKiogQWRkIGEgdG9rZW4gbGVhZiBub2RlIGNoaWxkIGFuZCBmb3JjZSBpdHMgcGFyZW50IHRvIGJlIHRoaXMgbm9kZS4gKi9cclxuXHRwdWJsaWMgYWRkQ2hpbGQodDogVGVybWluYWxOb2RlKTogdm9pZDtcclxuXHRwdWJsaWMgYWRkQ2hpbGQocnVsZUludm9jYXRpb246IFJ1bGVDb250ZXh0KTogdm9pZDtcclxuXHQvKipcclxuXHQgKiBBZGQgYSBjaGlsZCB0byB0aGlzIG5vZGUgYmFzZWQgdXBvbiBtYXRjaGVkVG9rZW4uIEl0XHJcblx0ICogY3JlYXRlcyBhIFRlcm1pbmFsTm9kZUltcGwgcmF0aGVyIHRoYW4gdXNpbmdcclxuXHQgKiB7QGxpbmsgUGFyc2VyI2NyZWF0ZVRlcm1pbmFsTm9kZShQYXJzZXJSdWxlQ29udGV4dCwgVG9rZW4pfS4gSSdtIGxlYXZpbmcgdGhpc1xyXG5cdCAqIGluIGZvciBjb21wYXRpYmlsaXR5IGJ1dCB0aGUgcGFyc2VyIGRvZXNuJ3QgdXNlIHRoaXMgYW55bW9yZS5cclxuXHQgKlxyXG5cdCAqIEBkZXByZWNhdGVkIFVzZSBhbm90aGVyIG92ZXJsb2FkIGluc3RlYWQuXHJcblx0ICovXHJcblx0cHVibGljIGFkZENoaWxkKG1hdGNoZWRUb2tlbjogVG9rZW4pOiBUZXJtaW5hbE5vZGU7XHJcblx0cHVibGljIGFkZENoaWxkKHQ6IFRlcm1pbmFsTm9kZSB8IFJ1bGVDb250ZXh0IHwgVG9rZW4pOiBUZXJtaW5hbE5vZGUgfCB2b2lkIHtcclxuXHRcdGxldCByZXN1bHQ6IFRlcm1pbmFsTm9kZSB8IHZvaWQ7XHJcblx0XHRpZiAodCBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZSkge1xyXG5cdFx0XHR0LnNldFBhcmVudCh0aGlzKTtcclxuXHRcdFx0dGhpcy5hZGRBbnlDaGlsZCh0KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fSBlbHNlIGlmICh0IGluc3RhbmNlb2YgUnVsZUNvbnRleHQpIHtcclxuXHRcdFx0Ly8gRG9lcyBub3Qgc2V0IHBhcmVudCBsaW5rXHJcblx0XHRcdHRoaXMuYWRkQW55Q2hpbGQodCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIERlcHJlY2F0ZWQgY29kZSBwYXRoXHJcblx0XHRcdHQgPSBuZXcgVGVybWluYWxOb2RlKHQpO1xyXG5cdFx0XHR0aGlzLmFkZEFueUNoaWxkKHQpO1xyXG5cdFx0XHR0LnNldFBhcmVudCh0aGlzKTtcclxuXHRcdFx0cmV0dXJuIHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogQWRkIGFuIGVycm9yIG5vZGUgY2hpbGQgYW5kIGZvcmNlIGl0cyBwYXJlbnQgdG8gYmUgdGhpcyBub2RlLlxyXG5cdCAqXHJcblx0ICogQHNpbmNlIDQuN1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBhZGRFcnJvck5vZGUoZXJyb3JOb2RlOiBFcnJvck5vZGUpOiBFcnJvck5vZGU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZCBhIGNoaWxkIHRvIHRoaXMgbm9kZSBiYXNlZCB1cG9uIGJhZFRva2VuLiBJdFxyXG5cdCAqIGNyZWF0ZXMgYSBFcnJvck5vZGUgcmF0aGVyIHRoYW4gdXNpbmdcclxuXHQgKiB7QGxpbmsgUGFyc2VyI2NyZWF0ZUVycm9yTm9kZShQYXJzZXJSdWxlQ29udGV4dCwgVG9rZW4pfS4gSSdtIGxlYXZpbmcgdGhpc1xyXG5cdCAqIGluIGZvciBjb21wYXRpYmlsaXR5IGJ1dCB0aGUgcGFyc2VyIGRvZXNuJ3QgdXNlIHRoaXMgYW55bW9yZS5cclxuXHQgKlxyXG5cdCAqIEBkZXByZWNhdGVkIFVzZSBhbm90aGVyIG92ZXJsb2FkIGluc3RlYWQuXHJcblx0ICovXHJcblx0cHVibGljIGFkZEVycm9yTm9kZShiYWRUb2tlbjogVG9rZW4pOiBFcnJvck5vZGU7XHJcblx0cHVibGljIGFkZEVycm9yTm9kZShub2RlOiBFcnJvck5vZGUgfCBUb2tlbik6IEVycm9yTm9kZSB7XHJcblx0XHRpZiAobm9kZSBpbnN0YW5jZW9mIEVycm9yTm9kZSkge1xyXG5cdFx0XHRjb25zdCBlcnJvck5vZGU6IEVycm9yTm9kZSA9IG5vZGU7XHJcblx0XHRcdGVycm9yTm9kZS5zZXRQYXJlbnQodGhpcyk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZEFueUNoaWxkKGVycm9yTm9kZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBkZXByZWNhdGVkIHBhdGhcclxuXHRcdFx0Y29uc3QgYmFkVG9rZW46IFRva2VuID0gbm9kZTtcclxuXHRcdFx0bGV0IHQgPSBuZXcgRXJyb3JOb2RlKGJhZFRva2VuKTtcclxuXHRcdFx0dGhpcy5hZGRBbnlDaGlsZCh0KTtcclxuXHRcdFx0dC5zZXRQYXJlbnQodGhpcyk7XHJcblx0XHRcdHJldHVybiB0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcbi8vXHRwdWJsaWMgdm9pZCB0cmFjZShpbnQgcykge1xyXG4vL1x0XHRpZiAoIHN0YXRlcz09bnVsbCApIHN0YXRlcyA9IG5ldyBBcnJheUxpc3Q8SW50ZWdlcj4oKTtcclxuLy9cdFx0c3RhdGVzLmFkZChzKTtcclxuLy9cdH1cclxuXHJcblx0LyoqIFVzZWQgYnkgZW50ZXJPdXRlckFsdCB0byB0b3NzIG91dCBhIFJ1bGVDb250ZXh0IHByZXZpb3VzbHkgYWRkZWQgYXNcclxuXHQgKiAgd2UgZW50ZXJlZCBhIHJ1bGUuIElmIHdlIGhhdmUgIyBsYWJlbCwgd2Ugd2lsbCBuZWVkIHRvIHJlbW92ZVxyXG5cdCAqICBnZW5lcmljIHJ1bGVDb250ZXh0IG9iamVjdC5cclxuXHQgKi9cclxuXHRwdWJsaWMgcmVtb3ZlTGFzdENoaWxkKCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuY2hpbGRyZW4pIHtcclxuXHRcdFx0dGhpcy5jaGlsZHJlbi5wb3AoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdC8qKiBPdmVycmlkZSB0byBtYWtlIHR5cGUgbW9yZSBzcGVjaWZpYyAqL1xyXG5cdGdldCBwYXJlbnQoKTogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IHBhcmVudCA9IHN1cGVyLnBhcmVudDtcclxuXHRcdGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCB8fCBwYXJlbnQgaW5zdGFuY2VvZiBQYXJzZXJSdWxlQ29udGV4dCkge1xyXG5cdFx0XHRyZXR1cm4gcGFyZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHBhcmVudCB0eXBlIGZvciBQYXJzZXJSdWxlQ29udGV4dFwiKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRDaGlsZChpOiBudW1iZXIpOiBQYXJzZVRyZWU7XHJcblx0cHVibGljIGdldENoaWxkPFQgZXh0ZW5kcyBQYXJzZVRyZWU+KGk6IG51bWJlciwgY3R4VHlwZTogeyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVDsgfSk6IFQ7XHJcblx0Ly8gTm90ZTogaW4gVHlwZVNjcmlwdCwgb3JkZXIgb3IgYXJndW1lbnRzIHJldmVyc2VkXHJcblx0cHVibGljIGdldENoaWxkPFQgZXh0ZW5kcyBQYXJzZVRyZWU+KGk6IG51bWJlciwgY3R4VHlwZT86IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQ7IH0pOiBQYXJzZVRyZWUge1xyXG5cdFx0aWYgKCF0aGlzLmNoaWxkcmVuIHx8IGkgPCAwIHx8IGkgPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbmRleCBwYXJhbWV0ZXIgbXVzdCBiZSBiZXR3ZWVuID49IDAgYW5kIDw9IG51bWJlciBvZiBjaGlsZHJlbi5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGN0eFR5cGUgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbltpXTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVzdWx0ID0gdGhpcy50cnlHZXRDaGlsZChpLCBjdHhUeXBlKTtcclxuXHRcdGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3BlY2lmaWVkIG5vZGUgZG9lcyBub3QgZXhpc3RcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0cnlHZXRDaGlsZDxUIGV4dGVuZHMgUGFyc2VUcmVlPihpOiBudW1iZXIsIGN0eFR5cGU6IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQ7IH0pOiBUIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICghdGhpcy5jaGlsZHJlbiB8fCBpIDwgMCB8fCBpID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGo6IG51bWJlciA9IC0xOyAvLyB3aGF0IG5vZGUgd2l0aCBjdHhUeXBlIGhhdmUgd2UgZm91bmQ/XHJcblx0XHRmb3IgKGxldCBvIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuXHRcdFx0aWYgKG8gaW5zdGFuY2VvZiBjdHhUeXBlKSB7XHJcblx0XHRcdFx0aisrO1xyXG5cdFx0XHRcdGlmIChqID09PSBpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldFRva2VuKHR0eXBlOiBudW1iZXIsIGk6IG51bWJlcik6IFRlcm1pbmFsTm9kZSB7XHJcblx0XHRsZXQgcmVzdWx0ID0gdGhpcy50cnlHZXRUb2tlbih0dHlwZSwgaSk7XHJcblx0XHRpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHNwZWNpZmllZCB0b2tlbiBkb2VzIG5vdCBleGlzdFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRyeUdldFRva2VuKHR0eXBlOiBudW1iZXIsIGk6IG51bWJlcik6IFRlcm1pbmFsTm9kZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAoIXRoaXMuY2hpbGRyZW4gfHwgaSA8IDAgfHwgaSA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBqOiBudW1iZXIgPSAtMTsgLy8gd2hhdCB0b2tlbiB3aXRoIHR0eXBlIGhhdmUgd2UgZm91bmQ/XHJcblx0XHRmb3IgKGxldCBvIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuXHRcdFx0aWYgKG8gaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcclxuXHRcdFx0XHRsZXQgc3ltYm9sOiBUb2tlbiA9IG8uc3ltYm9sO1xyXG5cdFx0XHRcdGlmIChzeW1ib2wudHlwZSA9PT0gdHR5cGUpIHtcclxuXHRcdFx0XHRcdGorKztcclxuXHRcdFx0XHRcdGlmIChqID09PSBpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBvO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0VG9rZW5zKHR0eXBlOiBudW1iZXIpOiBUZXJtaW5hbE5vZGVbXSB7XHJcblx0XHRsZXQgdG9rZW5zOiBUZXJtaW5hbE5vZGVbXSA9IFtdO1xyXG5cclxuXHRcdGlmICghdGhpcy5jaGlsZHJlbikge1xyXG5cdFx0XHRyZXR1cm4gdG9rZW5zO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IG8gb2YgdGhpcy5jaGlsZHJlbikge1xyXG5cdFx0XHRpZiAobyBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZSkge1xyXG5cdFx0XHRcdGxldCBzeW1ib2wgPSBvLnN5bWJvbDtcclxuXHRcdFx0XHRpZiAoc3ltYm9sLnR5cGUgPT09IHR0eXBlKSB7XHJcblx0XHRcdFx0XHR0b2tlbnMucHVzaChvKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdG9rZW5zO1xyXG5cdH1cclxuXHJcblx0Z2V0IHJ1bGVDb250ZXh0KCk6IHRoaXMge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvLyBOT1RFOiBhcmd1bWVudCBvcmRlciBjaGFuZ2UgZnJvbSBKYXZhIHZlcnNpb25cclxuXHRwdWJsaWMgZ2V0UnVsZUNvbnRleHQ8VCBleHRlbmRzIFBhcnNlclJ1bGVDb250ZXh0PihpOiBudW1iZXIsIGN0eFR5cGU6IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQ7IH0pOiBUIHtcclxuXHRcdHJldHVybiB0aGlzLmdldENoaWxkKGksIGN0eFR5cGUpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRyeUdldFJ1bGVDb250ZXh0PFQgZXh0ZW5kcyBQYXJzZXJSdWxlQ29udGV4dD4oaTogbnVtYmVyLCBjdHhUeXBlOiB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUOyB9KTogVCB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy50cnlHZXRDaGlsZChpLCBjdHhUeXBlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRSdWxlQ29udGV4dHM8VCBleHRlbmRzIFBhcnNlclJ1bGVDb250ZXh0PihjdHhUeXBlOiB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUOyB9KTogVFtdIHtcclxuXHRcdGxldCBjb250ZXh0czogVFtdID0gW107XHJcblx0XHRpZiAoIXRoaXMuY2hpbGRyZW4pIHtcclxuXHRcdFx0cmV0dXJuIGNvbnRleHRzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IG8gb2YgdGhpcy5jaGlsZHJlbikge1xyXG5cdFx0XHRpZiAobyBpbnN0YW5jZW9mIGN0eFR5cGUpIHtcclxuXHRcdFx0XHRjb250ZXh0cy5wdXNoKG8pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRleHRzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGNoaWxkQ291bnQoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbiA/IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDogMDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzb3VyY2VJbnRlcnZhbCgpOiBJbnRlcnZhbCB7XHJcblx0XHRpZiAoIXRoaXMuX3N0YXJ0KSB7XHJcblx0XHRcdHJldHVybiBJbnRlcnZhbC5JTlZBTElEO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0aGlzLl9zdG9wIHx8IHRoaXMuX3N0b3AudG9rZW5JbmRleCA8IHRoaXMuX3N0YXJ0LnRva2VuSW5kZXgpIHtcclxuXHRcdFx0cmV0dXJuIEludGVydmFsLm9mKHRoaXMuX3N0YXJ0LnRva2VuSW5kZXgsIHRoaXMuX3N0YXJ0LnRva2VuSW5kZXggLSAxKTsgLy8gZW1wdHlcclxuXHRcdH1cclxuXHRcdHJldHVybiBJbnRlcnZhbC5vZih0aGlzLl9zdGFydC50b2tlbkluZGV4LCB0aGlzLl9zdG9wLnRva2VuSW5kZXgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBpbml0aWFsIHRva2VuIGluIHRoaXMgY29udGV4dC5cclxuXHQgKiBOb3RlIHRoYXQgdGhlIHJhbmdlIGZyb20gc3RhcnQgdG8gc3RvcCBpcyBpbmNsdXNpdmUsIHNvIGZvciBydWxlcyB0aGF0IGRvIG5vdCBjb25zdW1lIGFueXRoaW5nXHJcblx0ICogKGZvciBleGFtcGxlLCB6ZXJvIGxlbmd0aCBvciBlcnJvciBwcm9kdWN0aW9ucykgdGhpcyB0b2tlbiBtYXkgZXhjZWVkIHN0b3AuXHJcblx0ICovXHJcblx0Z2V0IHN0YXJ0KCk6IFRva2VuIHsgcmV0dXJuIHRoaXMuX3N0YXJ0OyB9XHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBmaW5hbCB0b2tlbiBpbiB0aGlzIGNvbnRleHQuXHJcblx0ICogTm90ZSB0aGF0IHRoZSByYW5nZSBmcm9tIHN0YXJ0IHRvIHN0b3AgaXMgaW5jbHVzaXZlLCBzbyBmb3IgcnVsZXMgdGhhdCBkbyBub3QgY29uc3VtZSBhbnl0aGluZ1xyXG5cdCAqIChmb3IgZXhhbXBsZSwgemVybyBsZW5ndGggb3IgZXJyb3IgcHJvZHVjdGlvbnMpIHRoaXMgdG9rZW4gbWF5IHByZWNlZGUgc3RhcnQuXHJcblx0ICovXHJcblx0Z2V0IHN0b3AoKTogVG9rZW4gfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy5fc3RvcDsgfVxyXG5cclxuXHQvKiogVXNlZCBmb3IgcnVsZSBjb250ZXh0IGluZm8gZGVidWdnaW5nIGR1cmluZyBwYXJzZS10aW1lLCBub3Qgc28gbXVjaCBmb3IgQVROIGRlYnVnZ2luZyAqL1xyXG5cdHB1YmxpYyB0b0luZm9TdHJpbmcocmVjb2duaXplcjogUGFyc2VyKTogc3RyaW5nIHtcclxuXHRcdGxldCBydWxlczogc3RyaW5nW10gPVxyXG5cdFx0XHRyZWNvZ25pemVyLmdldFJ1bGVJbnZvY2F0aW9uU3RhY2sodGhpcykucmV2ZXJzZSgpO1xyXG5cdFx0cmV0dXJuIFwiUGFyc2VyUnVsZUNvbnRleHRcIiArIHJ1bGVzICsgXCJ7XCIgK1xyXG5cdFx0XHRcInN0YXJ0PVwiICsgdGhpcy5fc3RhcnQgK1xyXG5cdFx0XHRcIiwgc3RvcD1cIiArIHRoaXMuX3N0b3AgK1xyXG5cdFx0XHRcIn1cIjtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM2LjI2NzM4OTMtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFycmF5MkRIYXNoTWFwIH0gZnJvbSBcIi4uL21pc2MvQXJyYXkyREhhc2hNYXBcIjtcclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vQVROXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZyB9IGZyb20gXCIuL0FUTkNvbmZpZ1wiO1xyXG5pbXBvcnQgeyBBVE5Db25maWdTZXQgfSBmcm9tIFwiLi9BVE5Db25maWdTZXRcIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBCaXRTZXQgfSBmcm9tIFwiLi4vbWlzYy9CaXRTZXRcIjtcclxuaW1wb3J0IHsgRXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvRXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuLi9taXNjL09iamVjdEVxdWFsaXR5Q29tcGFyYXRvclwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFJ1bGVTdG9wU3RhdGUgfSBmcm9tIFwiLi9SdWxlU3RvcFN0YXRlXCI7XHJcbmltcG9ydCB7IFNlbWFudGljQ29udGV4dCB9IGZyb20gXCIuL1NlbWFudGljQ29udGV4dFwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZW51bWVyYXRpb24gZGVmaW5lcyB0aGUgcHJlZGljdGlvbiBtb2RlcyBhdmFpbGFibGUgaW4gQU5UTFIgNCBhbG9uZyB3aXRoXHJcbiAqIHV0aWxpdHkgbWV0aG9kcyBmb3IgYW5hbHl6aW5nIGNvbmZpZ3VyYXRpb24gc2V0cyBmb3IgY29uZmxpY3RzIGFuZC9vclxyXG4gKiBhbWJpZ3VpdGllcy5cclxuICovXHJcbmV4cG9ydCBlbnVtIFByZWRpY3Rpb25Nb2RlIHtcclxuXHQvKipcclxuXHQgKiBUaGUgU0xMKCopIHByZWRpY3Rpb24gbW9kZS4gVGhpcyBwcmVkaWN0aW9uIG1vZGUgaWdub3JlcyB0aGUgY3VycmVudFxyXG5cdCAqIHBhcnNlciBjb250ZXh0IHdoZW4gbWFraW5nIHByZWRpY3Rpb25zLiBUaGlzIGlzIHRoZSBmYXN0ZXN0IHByZWRpY3Rpb25cclxuXHQgKiBtb2RlLCBhbmQgcHJvdmlkZXMgY29ycmVjdCByZXN1bHRzIGZvciBtYW55IGdyYW1tYXJzLiBUaGlzIHByZWRpY3Rpb25cclxuXHQgKiBtb2RlIGlzIG1vcmUgcG93ZXJmdWwgdGhhbiB0aGUgcHJlZGljdGlvbiBtb2RlIHByb3ZpZGVkIGJ5IEFOVExSIDMsIGJ1dFxyXG5cdCAqIG1heSByZXN1bHQgaW4gc3ludGF4IGVycm9ycyBmb3IgZ3JhbW1hciBhbmQgaW5wdXQgY29tYmluYXRpb25zIHdoaWNoIGFyZVxyXG5cdCAqIG5vdCBTTEwuXHJcblx0ICpcclxuXHQgKiBXaGVuIHVzaW5nIHRoaXMgcHJlZGljdGlvbiBtb2RlLCB0aGUgcGFyc2VyIHdpbGwgZWl0aGVyIHJldHVybiBhIGNvcnJlY3RcclxuXHQgKiBwYXJzZSB0cmVlIChpLmUuIHRoZSBzYW1lIHBhcnNlIHRyZWUgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCB3aXRoIHRoZVxyXG5cdCAqIHtAbGluayAjTEx9IHByZWRpY3Rpb24gbW9kZSksIG9yIGl0IHdpbGwgcmVwb3J0IGEgc3ludGF4IGVycm9yLiBJZiBhXHJcblx0ICogc3ludGF4IGVycm9yIGlzIGVuY291bnRlcmVkIHdoZW4gdXNpbmcgdGhlIHtAbGluayAjU0xMfSBwcmVkaWN0aW9uIG1vZGUsXHJcblx0ICogaXQgbWF5IGJlIGR1ZSB0byBlaXRoZXIgYW4gYWN0dWFsIHN5bnRheCBlcnJvciBpbiB0aGUgaW5wdXQgb3IgaW5kaWNhdGVcclxuXHQgKiB0aGF0IHRoZSBwYXJ0aWN1bGFyIGNvbWJpbmF0aW9uIG9mIGdyYW1tYXIgYW5kIGlucHV0IHJlcXVpcmVzIHRoZSBtb3JlXHJcblx0ICogcG93ZXJmdWwge0BsaW5rICNMTH0gcHJlZGljdGlvbiBhYmlsaXRpZXMgdG8gY29tcGxldGUgc3VjY2Vzc2Z1bGx5LlxyXG5cdCAqXHJcblx0ICogVGhpcyBwcmVkaWN0aW9uIG1vZGUgZG9lcyBub3QgcHJvdmlkZSBhbnkgZ3VhcmFudGVlcyBmb3IgcHJlZGljdGlvblxyXG5cdCAqIGJlaGF2aW9yIGZvciBzeW50YWN0aWNhbGx5LWluY29ycmVjdCBpbnB1dHMuXHJcblx0ICovXHJcblx0U0xMLFxyXG5cdC8qKlxyXG5cdCAqIFRoZSBMTCgqKSBwcmVkaWN0aW9uIG1vZGUuIFRoaXMgcHJlZGljdGlvbiBtb2RlIGFsbG93cyB0aGUgY3VycmVudCBwYXJzZXJcclxuXHQgKiBjb250ZXh0IHRvIGJlIHVzZWQgZm9yIHJlc29sdmluZyBTTEwgY29uZmxpY3RzIHRoYXQgb2NjdXIgZHVyaW5nXHJcblx0ICogcHJlZGljdGlvbi4gVGhpcyBpcyB0aGUgZmFzdGVzdCBwcmVkaWN0aW9uIG1vZGUgdGhhdCBndWFyYW50ZWVzIGNvcnJlY3RcclxuXHQgKiBwYXJzZSByZXN1bHRzIGZvciBhbGwgY29tYmluYXRpb25zIG9mIGdyYW1tYXJzIHdpdGggc3ludGFjdGljYWxseSBjb3JyZWN0XHJcblx0ICogaW5wdXRzLlxyXG5cdCAqXHJcblx0ICogV2hlbiB1c2luZyB0aGlzIHByZWRpY3Rpb24gbW9kZSwgdGhlIHBhcnNlciB3aWxsIG1ha2UgY29ycmVjdCBkZWNpc2lvbnNcclxuXHQgKiBmb3IgYWxsIHN5bnRhY3RpY2FsbHktY29ycmVjdCBncmFtbWFyIGFuZCBpbnB1dCBjb21iaW5hdGlvbnMuIEhvd2V2ZXIsIGluXHJcblx0ICogY2FzZXMgd2hlcmUgdGhlIGdyYW1tYXIgaXMgdHJ1bHkgYW1iaWd1b3VzIHRoaXMgcHJlZGljdGlvbiBtb2RlIG1pZ2h0IG5vdFxyXG5cdCAqIHJlcG9ydCBhIHByZWNpc2UgYW5zd2VyIGZvciAqZXhhY3RseSB3aGljaCogYWx0ZXJuYXRpdmVzIGFyZVxyXG5cdCAqIGFtYmlndW91cy5cclxuXHQgKlxyXG5cdCAqIFRoaXMgcHJlZGljdGlvbiBtb2RlIGRvZXMgbm90IHByb3ZpZGUgYW55IGd1YXJhbnRlZXMgZm9yIHByZWRpY3Rpb25cclxuXHQgKiBiZWhhdmlvciBmb3Igc3ludGFjdGljYWxseS1pbmNvcnJlY3QgaW5wdXRzLlxyXG5cdCAqL1xyXG5cdExMLFxyXG5cdC8qKlxyXG5cdCAqIFRoZSBMTCgqKSBwcmVkaWN0aW9uIG1vZGUgd2l0aCBleGFjdCBhbWJpZ3VpdHkgZGV0ZWN0aW9uLiBJbiBhZGRpdGlvbiB0b1xyXG5cdCAqIHRoZSBjb3JyZWN0bmVzcyBndWFyYW50ZWVzIHByb3ZpZGVkIGJ5IHRoZSB7QGxpbmsgI0xMfSBwcmVkaWN0aW9uIG1vZGUsXHJcblx0ICogdGhpcyBwcmVkaWN0aW9uIG1vZGUgaW5zdHJ1Y3RzIHRoZSBwcmVkaWN0aW9uIGFsZ29yaXRobSB0byBkZXRlcm1pbmUgdGhlXHJcblx0ICogY29tcGxldGUgYW5kIGV4YWN0IHNldCBvZiBhbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzIGZvciBldmVyeSBhbWJpZ3VvdXNcclxuXHQgKiBkZWNpc2lvbiBlbmNvdW50ZXJlZCB3aGlsZSBwYXJzaW5nLlxyXG5cdCAqXHJcblx0ICogVGhpcyBwcmVkaWN0aW9uIG1vZGUgbWF5IGJlIHVzZWQgZm9yIGRpYWdub3NpbmcgYW1iaWd1aXRpZXMgZHVyaW5nXHJcblx0ICogZ3JhbW1hciBkZXZlbG9wbWVudC4gRHVlIHRvIHRoZSBwZXJmb3JtYW5jZSBvdmVyaGVhZCBvZiBjYWxjdWxhdGluZyBzZXRzXHJcblx0ICogb2YgYW1iaWd1b3VzIGFsdGVybmF0aXZlcywgdGhpcyBwcmVkaWN0aW9uIG1vZGUgc2hvdWxkIGJlIGF2b2lkZWQgd2hlblxyXG5cdCAqIHRoZSBleGFjdCByZXN1bHRzIGFyZSBub3QgbmVjZXNzYXJ5LlxyXG5cdCAqXHJcblx0ICogVGhpcyBwcmVkaWN0aW9uIG1vZGUgZG9lcyBub3QgcHJvdmlkZSBhbnkgZ3VhcmFudGVlcyBmb3IgcHJlZGljdGlvblxyXG5cdCAqIGJlaGF2aW9yIGZvciBzeW50YWN0aWNhbGx5LWluY29ycmVjdCBpbnB1dHMuXHJcblx0ICovXHJcblx0TExfRVhBQ1RfQU1CSUdfREVURUNUSU9OLFxyXG59XHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIFByZWRpY3Rpb25Nb2RlIHtcclxuXHQvKiogQSBNYXAgdGhhdCB1c2VzIGp1c3QgdGhlIHN0YXRlIGFuZCB0aGUgc3RhY2sgY29udGV4dCBhcyB0aGUga2V5LiAqL1xyXG5cdC8vIE5PVEU6IEJhc2UgdHlwZSB1c2VkIHRvIGJlIEZsZXhpYmxlSGFzaE1hcDxBVE5Db25maWcsIEJpdFNldD5cclxuXHRjbGFzcyBBbHRBbmRDb250ZXh0TWFwIGV4dGVuZHMgQXJyYXkyREhhc2hNYXA8QVROQ29uZmlnLCBCaXRTZXQ+IHtcclxuXHRcdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0XHRzdXBlcihBbHRBbmRDb250ZXh0Q29uZmlnRXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGNsYXNzIEFsdEFuZENvbnRleHRDb25maWdFcXVhbGl0eUNvbXBhcmF0b3IgaW1wbGVtZW50cyBFcXVhbGl0eUNvbXBhcmF0b3I8QVROQ29uZmlnPiB7XHJcblx0XHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IElOU1RBTkNFOiBBbHRBbmRDb250ZXh0Q29uZmlnRXF1YWxpdHlDb21wYXJhdG9yID0gbmV3IEFsdEFuZENvbnRleHRDb25maWdFcXVhbGl0eUNvbXBhcmF0b3IoKTtcclxuXHJcblx0XHRwcml2YXRlIEFsdEFuZENvbnRleHRDb25maWdFcXVhbGl0eUNvbXBhcmF0b3IoKSB7XHJcblx0XHRcdC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuXHRcdH1cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBoYXNoIGNvZGUgaXMgb25seSBhIGZ1bmN0aW9uIG9mIHRoZSB7QGxpbmsgQVROU3RhdGUjc3RhdGVOdW1iZXJ9XHJcblx0XHQgKiBhbmQge0BsaW5rIEFUTkNvbmZpZyNjb250ZXh0fS5cclxuXHRcdCAqL1xyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgaGFzaENvZGUobzogQVROQ29uZmlnKTogbnVtYmVyIHtcclxuXHRcdFx0bGV0IGhhc2hDb2RlOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoNyk7XHJcblx0XHRcdGhhc2hDb2RlID0gTXVybXVySGFzaC51cGRhdGUoaGFzaENvZGUsIG8uc3RhdGUuc3RhdGVOdW1iZXIpO1xyXG5cdFx0XHRoYXNoQ29kZSA9IE11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCBvLmNvbnRleHQpO1xyXG5cdFx0XHRoYXNoQ29kZSA9IE11cm11ckhhc2guZmluaXNoKGhhc2hDb2RlLCAyKTtcclxuXHRcdFx0cmV0dXJuIGhhc2hDb2RlO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGVxdWFscyhhOiBBVE5Db25maWcsIGI6IEFUTkNvbmZpZyk6IGJvb2xlYW4ge1xyXG5cdFx0XHRpZiAoYSA9PT0gYikge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBhLnN0YXRlLnN0YXRlTnVtYmVyID09PSBiLnN0YXRlLnN0YXRlTnVtYmVyXHJcblx0XHRcdFx0JiYgYS5jb250ZXh0LmVxdWFscyhiLmNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2tzIGlmIGFueSBjb25maWd1cmF0aW9uIGluIGBjb25maWdzYCBpcyBpbiBhXHJcblx0ICoge0BsaW5rIFJ1bGVTdG9wU3RhdGV9LiBDb25maWd1cmF0aW9ucyBtZWV0aW5nIHRoaXMgY29uZGl0aW9uIGhhdmUgcmVhY2hlZFxyXG5cdCAqIHRoZSBlbmQgb2YgdGhlIGRlY2lzaW9uIHJ1bGUgKGxvY2FsIGNvbnRleHQpIG9yIGVuZCBvZiBzdGFydCBydWxlIChmdWxsXHJcblx0ICogY29udGV4dCkuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gY29uZmlncyB0aGUgY29uZmlndXJhdGlvbiBzZXQgdG8gdGVzdFxyXG5cdCAqIEByZXR1cm5zIGB0cnVlYCBpZiBhbnkgY29uZmlndXJhdGlvbiBpbiBgY29uZmlnc2AgaXMgaW4gYVxyXG5cdCAqIHtAbGluayBSdWxlU3RvcFN0YXRlfSwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuXHQgKi9cclxuXHRleHBvcnQgZnVuY3Rpb24gaGFzQ29uZmlnSW5SdWxlU3RvcFN0YXRlKGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCk6IGJvb2xlYW4ge1xyXG5cdFx0Zm9yIChsZXQgYyBvZiBjb25maWdzKSB7XHJcblx0XHRcdGlmIChjLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2tzIGlmIGFsbCBjb25maWd1cmF0aW9ucyBpbiBgY29uZmlnc2AgYXJlIGluIGFcclxuXHQgKiB7QGxpbmsgUnVsZVN0b3BTdGF0ZX0uIENvbmZpZ3VyYXRpb25zIG1lZXRpbmcgdGhpcyBjb25kaXRpb24gaGF2ZSByZWFjaGVkXHJcblx0ICogdGhlIGVuZCBvZiB0aGUgZGVjaXNpb24gcnVsZSAobG9jYWwgY29udGV4dCkgb3IgZW5kIG9mIHN0YXJ0IHJ1bGUgKGZ1bGxcclxuXHQgKiBjb250ZXh0KS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBjb25maWdzIHRoZSBjb25maWd1cmF0aW9uIHNldCB0byB0ZXN0XHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIGFsbCBjb25maWd1cmF0aW9ucyBpbiBgY29uZmlnc2AgYXJlIGluIGFcclxuXHQgKiB7QGxpbmsgUnVsZVN0b3BTdGF0ZX0sIG90aGVyd2lzZSBgZmFsc2VgXHJcblx0ICovXHJcblx0ZXhwb3J0IGZ1bmN0aW9uIGFsbENvbmZpZ3NJblJ1bGVTdG9wU3RhdGVzKC8qQE5vdE51bGwqLyBjb25maWdzOiBBVE5Db25maWdTZXQpOiBib29sZWFuIHtcclxuXHRcdGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKSB7XHJcblx0XHRcdGlmICghKGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNy4zODcxOTg0LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBERkFTdGF0ZSB9IGZyb20gXCIuLi9kZmEvREZBU3RhdGVcIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4uL1BhcnNlclJ1bGVDb250ZXh0XCI7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNpbXVsYXRvclN0YXRlIHtcclxuXHRwdWJsaWMgb3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dDtcclxuXHJcblx0cHVibGljIHMwOiBERkFTdGF0ZTtcclxuXHJcblx0cHVibGljIHVzZUNvbnRleHQ6IGJvb2xlYW47XHJcblx0cHVibGljIHJlbWFpbmluZ091dGVyQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQ7XHJcblxyXG5cdGNvbnN0cnVjdG9yKG91dGVyQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQsIEBOb3ROdWxsIHMwOiBERkFTdGF0ZSwgdXNlQ29udGV4dDogYm9vbGVhbiwgcmVtYWluaW5nT3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5vdXRlckNvbnRleHQgPSBvdXRlckNvbnRleHQgIT0gbnVsbCA/IG91dGVyQ29udGV4dCA6IFBhcnNlclJ1bGVDb250ZXh0LmVtcHR5Q29udGV4dCgpO1xyXG5cdFx0dGhpcy5zMCA9IHMwO1xyXG5cdFx0dGhpcy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcclxuXHRcdHRoaXMucmVtYWluaW5nT3V0ZXJDb250ZXh0ID0gcmVtYWluaW5nT3V0ZXJDb250ZXh0O1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzEuMTk4OTgzNS0wNzowMFxyXG5cclxuaW1wb3J0IHsgQWNjZXB0U3RhdGVJbmZvIH0gZnJvbSBcIi4uL2RmYS9BY2NlcHRTdGF0ZUluZm9cIjtcclxuaW1wb3J0IHsgQWN0aW9uVHJhbnNpdGlvbiB9IGZyb20gXCIuL0FjdGlvblRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgQXJyYXkyREhhc2hTZXQgfSBmcm9tIFwiLi4vbWlzYy9BcnJheTJESGFzaFNldFwiO1xyXG5pbXBvcnQgeyBBcnJheXMgfSBmcm9tIFwiLi4vbWlzYy9BcnJheXNcIjtcclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vQVROXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZyB9IGZyb20gXCIuL0FUTkNvbmZpZ1wiO1xyXG5pbXBvcnQgeyBBVE5Db25maWdTZXQgfSBmcm9tIFwiLi9BVE5Db25maWdTZXRcIjtcclxuaW1wb3J0IHsgQVROU2ltdWxhdG9yIH0gZnJvbSBcIi4vQVROU2ltdWxhdG9yXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IEF0b21UcmFuc2l0aW9uIH0gZnJvbSBcIi4vQXRvbVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgQml0U2V0IH0gZnJvbSBcIi4uL21pc2MvQml0U2V0XCI7XHJcbmltcG9ydCB7IENvbmZsaWN0SW5mbyB9IGZyb20gXCIuL0NvbmZsaWN0SW5mb1wiO1xyXG5pbXBvcnQgeyBEZWNpc2lvblN0YXRlIH0gZnJvbSBcIi4vRGVjaXNpb25TdGF0ZVwiO1xyXG5pbXBvcnQgeyBERkEgfSBmcm9tIFwiLi4vZGZhL0RGQVwiO1xyXG5pbXBvcnQgeyBERkFTdGF0ZSB9IGZyb20gXCIuLi9kZmEvREZBU3RhdGVcIjtcclxuaW1wb3J0IHsgRXBzaWxvblRyYW5zaXRpb24gfSBmcm9tIFwiLi9FcHNpbG9uVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBJbnRlZ2VyTGlzdCB9IGZyb20gXCIuLi9taXNjL0ludGVnZXJMaXN0XCI7XHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4uL21pc2MvSW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgSW50U3RyZWFtIH0gZnJvbSBcIi4uL0ludFN0cmVhbVwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBOdWxsYWJsZSwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBOb3RTZXRUcmFuc2l0aW9uIH0gZnJvbSBcIi4vTm90U2V0VHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBOb1ZpYWJsZUFsdEV4Y2VwdGlvbiB9IGZyb20gXCIuLi9Ob1ZpYWJsZUFsdEV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi4vbWlzYy9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4uL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbiB9IGZyb20gXCIuL1ByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFByZWRpY2F0ZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9QcmVkaWNhdGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFByZWRpY3Rpb25Db250ZXh0IH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRcIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbkNvbnRleHRDYWNoZSB9IGZyb20gXCIuL1ByZWRpY3Rpb25Db250ZXh0Q2FjaGVcIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbk1vZGUgfSBmcm9tIFwiLi9QcmVkaWN0aW9uTW9kZVwiO1xyXG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCIuLi9SdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBSdWxlU3RvcFN0YXRlIH0gZnJvbSBcIi4vUnVsZVN0b3BTdGF0ZVwiO1xyXG5pbXBvcnQgeyBSdWxlVHJhbnNpdGlvbiB9IGZyb20gXCIuL1J1bGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFNlbWFudGljQ29udGV4dCB9IGZyb20gXCIuL1NlbWFudGljQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBTZXRUcmFuc2l0aW9uIH0gZnJvbSBcIi4vU2V0VHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBTaW11bGF0b3JTdGF0ZSB9IGZyb20gXCIuL1NpbXVsYXRvclN0YXRlXCI7XHJcbmltcG9ydCB7IFN0YXJMb29wRW50cnlTdGF0ZSB9IGZyb20gXCIuL1N0YXJMb29wRW50cnlTdGF0ZVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBUb2tlblN0cmVhbSB9IGZyb20gXCIuLi9Ub2tlblN0cmVhbVwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnkgfSBmcm9tIFwiLi4vVm9jYWJ1bGFyeVwiO1xyXG5pbXBvcnQgeyBWb2NhYnVsYXJ5SW1wbCB9IGZyb20gXCIuLi9Wb2NhYnVsYXJ5SW1wbFwiO1xyXG5cclxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcclxuXHJcbmNvbnN0IE1BWF9TSE9SVF9WQUxVRSA9IDB4RkZGRjtcclxuY29uc3QgTUlOX0lOVEVHRVJfVkFMVUUgPSAtKCgxIDw8IDMxKSA+Pj4gMCk7XHJcblxyXG4vKipcclxuICogVGhlIGVtYm9kaW1lbnQgb2YgdGhlIGFkYXB0aXZlIExMKCopLCBBTEwoKiksIHBhcnNpbmcgc3RyYXRlZ3kuXHJcbiAqXHJcbiAqIFRoZSBiYXNpYyBjb21wbGV4aXR5IG9mIHRoZSBhZGFwdGl2ZSBzdHJhdGVneSBtYWtlcyBpdCBoYXJkZXIgdG8gdW5kZXJzdGFuZC5cclxuICogV2UgYmVnaW4gd2l0aCBBVE4gc2ltdWxhdGlvbiB0byBidWlsZCBwYXRocyBpbiBhIERGQS4gU3Vic2VxdWVudCBwcmVkaWN0aW9uXHJcbiAqIHJlcXVlc3RzIGdvIHRocm91Z2ggdGhlIERGQSBmaXJzdC4gSWYgdGhleSByZWFjaCBhIHN0YXRlIHdpdGhvdXQgYW4gZWRnZSBmb3JcclxuICogdGhlIGN1cnJlbnQgc3ltYm9sLCB0aGUgYWxnb3JpdGhtIGZhaWxzIG92ZXIgdG8gdGhlIEFUTiBzaW11bGF0aW9uIHRvXHJcbiAqIGNvbXBsZXRlIHRoZSBERkEgcGF0aCBmb3IgdGhlIGN1cnJlbnQgaW5wdXQgKHVudGlsIGl0IGZpbmRzIGEgY29uZmxpY3Qgc3RhdGVcclxuICogb3IgdW5pcXVlbHkgcHJlZGljdGluZyBzdGF0ZSkuXHJcbiAqXHJcbiAqIEFsbCBvZiB0aGF0IGlzIGRvbmUgd2l0aG91dCB1c2luZyB0aGUgb3V0ZXIgY29udGV4dCBiZWNhdXNlIHdlIHdhbnQgdG8gY3JlYXRlXHJcbiAqIGEgREZBIHRoYXQgaXMgbm90IGRlcGVuZGVudCB1cG9uIHRoZSBydWxlIGludm9jYXRpb24gc3RhY2sgd2hlbiB3ZSBkbyBhXHJcbiAqIHByZWRpY3Rpb24uIE9uZSBERkEgd29ya3MgaW4gYWxsIGNvbnRleHRzLiBXZSBhdm9pZCB1c2luZyBjb250ZXh0IG5vdFxyXG4gKiBuZWNlc3NhcmlseSBiZWNhdXNlIGl0J3Mgc2xvd2VyLCBhbHRob3VnaCBpdCBjYW4gYmUsIGJ1dCBiZWNhdXNlIG9mIHRoZSBERkFcclxuICogY2FjaGluZyBwcm9ibGVtLiBUaGUgY2xvc3VyZSByb3V0aW5lIG9ubHkgY29uc2lkZXJzIHRoZSBydWxlIGludm9jYXRpb24gc3RhY2tcclxuICogY3JlYXRlZCBkdXJpbmcgcHJlZGljdGlvbiBiZWdpbm5pbmcgaW4gdGhlIGRlY2lzaW9uIHJ1bGUuIEZvciBleGFtcGxlLCBpZlxyXG4gKiBwcmVkaWN0aW9uIG9jY3VycyB3aXRob3V0IGludm9raW5nIGFub3RoZXIgcnVsZSdzIEFUTiwgdGhlcmUgYXJlIG5vIGNvbnRleHRcclxuICogc3RhY2tzIGluIHRoZSBjb25maWd1cmF0aW9ucy4gV2hlbiBsYWNrIG9mIGNvbnRleHQgbGVhZHMgdG8gYSBjb25mbGljdCwgd2VcclxuICogZG9uJ3Qga25vdyBpZiBpdCdzIGFuIGFtYmlndWl0eSBvciBhIHdlYWtuZXNzIGluIHRoZSBzdHJvbmcgTEwoKikgcGFyc2luZ1xyXG4gKiBzdHJhdGVneSAodmVyc3VzIGZ1bGwgTEwoKikpLlxyXG4gKlxyXG4gKiBXaGVuIFNMTCB5aWVsZHMgYSBjb25maWd1cmF0aW9uIHNldCB3aXRoIGNvbmZsaWN0LCB3ZSByZXdpbmQgdGhlIGlucHV0IGFuZFxyXG4gKiByZXRyeSB0aGUgQVROIHNpbXVsYXRpb24sIHRoaXMgdGltZSB1c2luZyBmdWxsIG91dGVyIGNvbnRleHQgd2l0aG91dCBhZGRpbmdcclxuICogdG8gdGhlIERGQS4gQ29uZmlndXJhdGlvbiBjb250ZXh0IHN0YWNrcyB3aWxsIGJlIHRoZSBmdWxsIGludm9jYXRpb24gc3RhY2tzXHJcbiAqIGZyb20gdGhlIHN0YXJ0IHJ1bGUuIElmIHdlIGdldCBhIGNvbmZsaWN0IHVzaW5nIGZ1bGwgY29udGV4dCwgdGhlbiB3ZSBjYW5cclxuICogZGVmaW5pdGl2ZWx5IHNheSB3ZSBoYXZlIGEgdHJ1ZSBhbWJpZ3VpdHkgZm9yIHRoYXQgaW5wdXQgc2VxdWVuY2UuIElmIHdlXHJcbiAqIGRvbid0IGdldCBhIGNvbmZsaWN0LCBpdCBpbXBsaWVzIHRoYXQgdGhlIGRlY2lzaW9uIGlzIHNlbnNpdGl2ZSB0byB0aGUgb3V0ZXJcclxuICogY29udGV4dC4gKEl0IGlzIG5vdCBjb250ZXh0LXNlbnNpdGl2ZSBpbiB0aGUgc2Vuc2Ugb2YgY29udGV4dC1zZW5zaXRpdmVcclxuICogZ3JhbW1hcnMuKVxyXG4gKlxyXG4gKiBUaGUgbmV4dCB0aW1lIHdlIHJlYWNoIHRoaXMgREZBIHN0YXRlIHdpdGggYW4gU0xMIGNvbmZsaWN0LCB0aHJvdWdoIERGQVxyXG4gKiBzaW11bGF0aW9uLCB3ZSB3aWxsIGFnYWluIHJldHJ5IHRoZSBBVE4gc2ltdWxhdGlvbiB1c2luZyBmdWxsIGNvbnRleHQgbW9kZS5cclxuICogVGhpcyBpcyBzbG93IGJlY2F1c2Ugd2UgY2FuJ3Qgc2F2ZSB0aGUgcmVzdWx0cyBhbmQgaGF2ZSB0byBcImludGVycHJldFwiIHRoZVxyXG4gKiBBVE4gZWFjaCB0aW1lIHdlIGdldCB0aGF0IGlucHV0LlxyXG4gKlxyXG4gKiAqKkNBQ0hJTkcgRlVMTCBDT05URVhUIFBSRURJQ1RJT05TKipcclxuICpcclxuICogV2UgY291bGQgY2FjaGUgcmVzdWx0cyBmcm9tIGZ1bGwgY29udGV4dCB0byBwcmVkaWN0ZWQgYWx0ZXJuYXRpdmUgZWFzaWx5IGFuZFxyXG4gKiB0aGF0IHNhdmVzIGEgbG90IG9mIHRpbWUgYnV0IGRvZXNuJ3Qgd29yayBpbiBwcmVzZW5jZSBvZiBwcmVkaWNhdGVzLiBUaGUgc2V0XHJcbiAqIG9mIHZpc2libGUgcHJlZGljYXRlcyBmcm9tIHRoZSBBVE4gc3RhcnQgc3RhdGUgY2hhbmdlcyBkZXBlbmRpbmcgb24gdGhlXHJcbiAqIGNvbnRleHQsIGJlY2F1c2UgY2xvc3VyZSBjYW4gZmFsbCBvZmYgdGhlIGVuZCBvZiBhIHJ1bGUuIEkgdHJpZWQgdG8gY2FjaGVcclxuICogdHVwbGVzIChzdGFjayBjb250ZXh0LCBzZW1hbnRpYyBjb250ZXh0LCBwcmVkaWN0ZWQgYWx0KSBidXQgaXQgd2FzIHNsb3dlclxyXG4gKiB0aGFuIGludGVycHJldGluZyBhbmQgbXVjaCBtb3JlIGNvbXBsaWNhdGVkLiBBbHNvIHJlcXVpcmVkIGEgaHVnZSBhbW91bnQgb2ZcclxuICogbWVtb3J5LiBUaGUgZ29hbCBpcyBub3QgdG8gY3JlYXRlIHRoZSB3b3JsZCdzIGZhc3Rlc3QgcGFyc2VyIGFueXdheS4gSSdkIGxpa2VcclxuICogdG8ga2VlcCB0aGlzIGFsZ29yaXRobSBzaW1wbGUuIEJ5IGxhdW5jaGluZyBtdWx0aXBsZSB0aHJlYWRzLCB3ZSBjYW4gaW1wcm92ZVxyXG4gKiB0aGUgc3BlZWQgb2YgcGFyc2luZyBhY3Jvc3MgYSBsYXJnZSBudW1iZXIgb2YgZmlsZXMuXHJcbiAqXHJcbiAqIFRoZXJlIGlzIG5vIHN0cmljdCBvcmRlcmluZyBiZXR3ZWVuIHRoZSBhbW91bnQgb2YgaW5wdXQgdXNlZCBieSBTTEwgdnMgTEwsXHJcbiAqIHdoaWNoIG1ha2VzIGl0IHJlYWxseSBoYXJkIHRvIGJ1aWxkIGEgY2FjaGUgZm9yIGZ1bGwgY29udGV4dC4gTGV0J3Mgc2F5IHRoYXRcclxuICogd2UgaGF2ZSBpbnB1dCBBIEIgQyB0aGF0IGxlYWRzIHRvIGFuIFNMTCBjb25mbGljdCB3aXRoIGZ1bGwgY29udGV4dCBYLiBUaGF0XHJcbiAqIGltcGxpZXMgdGhhdCB1c2luZyBYIHdlIG1pZ2h0IG9ubHkgdXNlIEEgQiBidXQgd2UgY291bGQgYWxzbyB1c2UgQSBCIEMgRCB0b1xyXG4gKiByZXNvbHZlIGNvbmZsaWN0LiBJbnB1dCBBIEIgQyBEIGNvdWxkIHByZWRpY3QgYWx0ZXJuYXRpdmUgMSBpbiBvbmUgcG9zaXRpb25cclxuICogaW4gdGhlIGlucHV0IGFuZCBBIEIgQyBFIGNvdWxkIHByZWRpY3QgYWx0ZXJuYXRpdmUgMiBpbiBhbm90aGVyIHBvc2l0aW9uIGluXHJcbiAqIGlucHV0LiBUaGUgY29uZmxpY3RpbmcgU0xMIGNvbmZpZ3VyYXRpb25zIGNvdWxkIHN0aWxsIGJlIG5vbi11bmlxdWUgaW4gdGhlXHJcbiAqIGZ1bGwgY29udGV4dCBwcmVkaWN0aW9uLCB3aGljaCB3b3VsZCBsZWFkIHVzIHRvIHJlcXVpcmluZyBtb3JlIGlucHV0IHRoYW4gdGhlXHJcbiAqIG9yaWdpbmFsIEEgQiBDLlx0VG8gbWFrZSBhXHRwcmVkaWN0aW9uIGNhY2hlIHdvcmssIHdlIGhhdmUgdG8gdHJhY2tcdHRoZSBleGFjdFxyXG4gKiBpbnB1dFx0dXNlZCBkdXJpbmcgdGhlIHByZXZpb3VzIHByZWRpY3Rpb24uIFRoYXQgYW1vdW50cyB0byBhIGNhY2hlIHRoYXQgbWFwc1xyXG4gKiBYIHRvIGEgc3BlY2lmaWMgREZBIGZvciB0aGF0IGNvbnRleHQuXHJcbiAqXHJcbiAqIFNvbWV0aGluZyBzaG91bGQgYmUgZG9uZSBmb3IgbGVmdC1yZWN1cnNpdmUgZXhwcmVzc2lvbiBwcmVkaWN0aW9ucy4gVGhleSBhcmVcclxuICogbGlrZWx5IExMKDEpICsgcHJlZCBldmFsLiBFYXNpZXIgdG8gZG8gdGhlIHdob2xlIFNMTCB1bmxlc3MgZXJyb3IgYW5kIHJldHJ5XHJcbiAqIHdpdGggZnVsbCBMTCB0aGluZyBTYW0gZG9lcy5cclxuICpcclxuICogKipBVk9JRElORyBGVUxMIENPTlRFWFQgUFJFRElDVElPTioqXHJcbiAqXHJcbiAqIFdlIGF2b2lkIGRvaW5nIGZ1bGwgY29udGV4dCByZXRyeSB3aGVuIHRoZSBvdXRlciBjb250ZXh0IGlzIGVtcHR5LCB3ZSBkaWQgbm90XHJcbiAqIGRpcCBpbnRvIHRoZSBvdXRlciBjb250ZXh0IGJ5IGZhbGxpbmcgb2ZmIHRoZSBlbmQgb2YgdGhlIGRlY2lzaW9uIHN0YXRlIHJ1bGUsXHJcbiAqIG9yIHdoZW4gd2UgZm9yY2UgU0xMIG1vZGUuXHJcbiAqXHJcbiAqIEFzIGFuIGV4YW1wbGUgb2YgdGhlIG5vdCBkaXAgaW50byBvdXRlciBjb250ZXh0IGNhc2UsIGNvbnNpZGVyIGFzIHN1cGVyXHJcbiAqIGNvbnN0cnVjdG9yIGNhbGxzIHZlcnN1cyBmdW5jdGlvbiBjYWxscy4gT25lIGdyYW1tYXIgbWlnaHQgbG9vayBsaWtlXHJcbiAqIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGFudGxyXHJcbiAqIGN0b3JCb2R5XHJcbiAqICAgOiAneycgc3VwZXJDYWxsPyBzdGF0KiAnfSdcclxuICogICA7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBPciwgeW91IG1pZ2h0IHNlZSBzb21ldGhpbmcgbGlrZVxyXG4gKlxyXG4gKiBgYGBhbnRsclxyXG4gKiBzdGF0XHJcbiAqICAgOiBzdXBlckNhbGwgJzsnXHJcbiAqICAgfCBleHByZXNzaW9uICc7J1xyXG4gKiAgIHwgLi4uXHJcbiAqICAgO1xyXG4gKiBgYGBcclxuICpcclxuICogSW4gYm90aCBjYXNlcyBJIGJlbGlldmUgdGhhdCBubyBjbG9zdXJlIG9wZXJhdGlvbnMgd2lsbCBkaXAgaW50byB0aGUgb3V0ZXJcclxuICogY29udGV4dC4gSW4gdGhlIGZpcnN0IGNhc2UgY3RvckJvZHkgaW4gdGhlIHdvcnN0IGNhc2Ugd2lsbCBzdG9wIGF0IHRoZSAnfScuXHJcbiAqIEluIHRoZSAybmQgY2FzZSBpdCBzaG91bGQgc3RvcCBhdCB0aGUgJzsnLiBCb3RoIGNhc2VzIHNob3VsZCBzdGF5IHdpdGhpbiB0aGVcclxuICogZW50cnkgcnVsZSBhbmQgbm90IGRpcCBpbnRvIHRoZSBvdXRlciBjb250ZXh0LlxyXG4gKlxyXG4gKiAqKlBSRURJQ0FURVMqKlxyXG4gKlxyXG4gKiBQcmVkaWNhdGVzIGFyZSBhbHdheXMgZXZhbHVhdGVkIGlmIHByZXNlbnQgaW4gZWl0aGVyIFNMTCBvciBMTCBib3RoLiBTTEwgYW5kXHJcbiAqIExMIHNpbXVsYXRpb24gZGVhbHMgd2l0aCBwcmVkaWNhdGVzIGRpZmZlcmVudGx5LiBTTEwgY29sbGVjdHMgcHJlZGljYXRlcyBhc1xyXG4gKiBpdCBwZXJmb3JtcyBjbG9zdXJlIG9wZXJhdGlvbnMgbGlrZSBBTlRMUiB2MyBkaWQuIEl0IGRlbGF5cyBwcmVkaWNhdGVcclxuICogZXZhbHVhdGlvbiB1bnRpbCBpdCByZWFjaGVzIGFuZCBhY2NlcHQgc3RhdGUuIFRoaXMgYWxsb3dzIHVzIHRvIGNhY2hlIHRoZSBTTExcclxuICogQVROIHNpbXVsYXRpb24gd2hlcmVhcywgaWYgd2UgaGFkIGV2YWx1YXRlZCBwcmVkaWNhdGVzIG9uLXRoZS1mbHkgZHVyaW5nXHJcbiAqIGNsb3N1cmUsIHRoZSBERkEgc3RhdGUgY29uZmlndXJhdGlvbiBzZXRzIHdvdWxkIGJlIGRpZmZlcmVudCBhbmQgd2UgY291bGRuJ3RcclxuICogYnVpbGQgdXAgYSBzdWl0YWJsZSBERkEuXHJcbiAqXHJcbiAqIFdoZW4gYnVpbGRpbmcgYSBERkEgYWNjZXB0IHN0YXRlIGR1cmluZyBBVE4gc2ltdWxhdGlvbiwgd2UgZXZhbHVhdGUgYW55XHJcbiAqIHByZWRpY2F0ZXMgYW5kIHJldHVybiB0aGUgc29sZSBzZW1hbnRpY2FsbHkgdmFsaWQgYWx0ZXJuYXRpdmUuIElmIHRoZXJlIGlzXHJcbiAqIG1vcmUgdGhhbiAxIGFsdGVybmF0aXZlLCB3ZSByZXBvcnQgYW4gYW1iaWd1aXR5LiBJZiB0aGVyZSBhcmUgMCBhbHRlcm5hdGl2ZXMsXHJcbiAqIHdlIHRocm93IGFuIGV4Y2VwdGlvbi4gQWx0ZXJuYXRpdmVzIHdpdGhvdXQgcHJlZGljYXRlcyBhY3QgbGlrZSB0aGV5IGhhdmVcclxuICogdHJ1ZSBwcmVkaWNhdGVzLiBUaGUgc2ltcGxlIHdheSB0byB0aGluayBhYm91dCBpdCBpcyB0byBzdHJpcCBhd2F5IGFsbFxyXG4gKiBhbHRlcm5hdGl2ZXMgd2l0aCBmYWxzZSBwcmVkaWNhdGVzIGFuZCBjaG9vc2UgdGhlIG1pbmltdW0gYWx0ZXJuYXRpdmUgdGhhdFxyXG4gKiByZW1haW5zLlxyXG4gKlxyXG4gKiBXaGVuIHdlIHN0YXJ0IGluIHRoZSBERkEgYW5kIHJlYWNoIGFuIGFjY2VwdCBzdGF0ZSB0aGF0J3MgcHJlZGljYXRlZCwgd2UgdGVzdFxyXG4gKiB0aG9zZSBhbmQgcmV0dXJuIHRoZSBtaW5pbXVtIHNlbWFudGljYWxseSB2aWFibGUgYWx0ZXJuYXRpdmUuIElmIG5vXHJcbiAqIGFsdGVybmF0aXZlcyBhcmUgdmlhYmxlLCB3ZSB0aHJvdyBhbiBleGNlcHRpb24uXHJcbiAqXHJcbiAqIER1cmluZyBmdWxsIExMIEFUTiBzaW11bGF0aW9uLCBjbG9zdXJlIGFsd2F5cyBldmFsdWF0ZXMgcHJlZGljYXRlcyBhbmRcclxuICogb24tdGhlLWZseS4gVGhpcyBpcyBjcnVjaWFsIHRvIHJlZHVjaW5nIHRoZSBjb25maWd1cmF0aW9uIHNldCBzaXplIGR1cmluZ1xyXG4gKiBjbG9zdXJlLiBJdCBoaXRzIGEgbGFuZG1pbmUgd2hlbiBwYXJzaW5nIHdpdGggdGhlIEphdmEgZ3JhbW1hciwgZm9yIGV4YW1wbGUsXHJcbiAqIHdpdGhvdXQgdGhpcyBvbi10aGUtZmx5IGV2YWx1YXRpb24uXHJcbiAqXHJcbiAqICoqU0hBUklORyBERkEqKlxyXG4gKlxyXG4gKiBBbGwgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIHBhcnNlciBzaGFyZSB0aGUgc2FtZSBkZWNpc2lvbiBERkFzIHRocm91Z2ggYVxyXG4gKiBzdGF0aWMgZmllbGQuIEVhY2ggaW5zdGFuY2UgZ2V0cyBpdHMgb3duIEFUTiBzaW11bGF0b3IgYnV0IHRoZXkgc2hhcmUgdGhlXHJcbiAqIHNhbWUge0BsaW5rIEFUTiNkZWNpc2lvblRvREZBfSBmaWVsZC4gVGhleSBhbHNvIHNoYXJlIGFcclxuICoge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0Q2FjaGV9IG9iamVjdCB0aGF0IG1ha2VzIHN1cmUgdGhhdCBhbGxcclxuICoge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0fSBvYmplY3RzIGFyZSBzaGFyZWQgYW1vbmcgdGhlIERGQSBzdGF0ZXMuIFRoaXMgbWFrZXNcclxuICogYSBiaWcgc2l6ZSBkaWZmZXJlbmNlLlxyXG4gKlxyXG4gKiAqKlRIUkVBRCBTQUZFVFkqKlxyXG4gKlxyXG4gKiBUaGUge0BsaW5rIFBhcnNlckFUTlNpbXVsYXRvcn0gbG9ja3Mgb24gdGhlIHtAbGluayBBVE4jZGVjaXNpb25Ub0RGQX0gZmllbGQgd2hlblxyXG4gKiBpdCBhZGRzIGEgbmV3IERGQSBvYmplY3QgdG8gdGhhdCBhcnJheS4ge0BsaW5rICNhZGRERkFFZGdlfVxyXG4gKiBsb2NrcyBvbiB0aGUgREZBIGZvciB0aGUgY3VycmVudCBkZWNpc2lvbiB3aGVuIHNldHRpbmcgdGhlXHJcbiAqIHtAbGluayBERkFTdGF0ZSNlZGdlc30gZmllbGQuIHtAbGluayAjYWRkREZBU3RhdGV9IGxvY2tzIG9uXHJcbiAqIHRoZSBERkEgZm9yIHRoZSBjdXJyZW50IGRlY2lzaW9uIHdoZW4gbG9va2luZyB1cCBhIERGQSBzdGF0ZSB0byBzZWUgaWYgaXRcclxuICogYWxyZWFkeSBleGlzdHMuIFdlIG11c3QgbWFrZSBzdXJlIHRoYXQgYWxsIHJlcXVlc3RzIHRvIGFkZCBERkEgc3RhdGVzIHRoYXRcclxuICogYXJlIGVxdWl2YWxlbnQgcmVzdWx0IGluIHRoZSBzYW1lIHNoYXJlZCBERkEgb2JqZWN0LiBUaGlzIGlzIGJlY2F1c2UgbG90cyBvZlxyXG4gKiB0aHJlYWRzIHdpbGwgYmUgdHJ5aW5nIHRvIHVwZGF0ZSB0aGUgREZBIGF0IG9uY2UuIFRoZVxyXG4gKiB7QGxpbmsgI2FkZERGQVN0YXRlfSBtZXRob2QgYWxzbyBsb2NrcyBpbnNpZGUgdGhlIERGQSBsb2NrXHJcbiAqIGJ1dCB0aGlzIHRpbWUgb24gdGhlIHNoYXJlZCBjb250ZXh0IGNhY2hlIHdoZW4gaXQgcmVidWlsZHMgdGhlXHJcbiAqIGNvbmZpZ3VyYXRpb25zJyB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHR9IG9iamVjdHMgdXNpbmcgY2FjaGVkXHJcbiAqIHN1YmdyYXBocy9ub2Rlcy4gTm8gb3RoZXIgbG9ja2luZyBvY2N1cnMsIGV2ZW4gZHVyaW5nIERGQSBzaW11bGF0aW9uLiBUaGlzIGlzXHJcbiAqIHNhZmUgYXMgbG9uZyBhcyB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgYWxsIHRocmVhZHMgcmVmZXJlbmNpbmdcclxuICogYHMuZWRnZVt0XWAgZ2V0IHRoZSBzYW1lIHBoeXNpY2FsIHRhcmdldCB7QGxpbmsgREZBU3RhdGV9LCBvclxyXG4gKiBgdW5kZWZpbmVkYC4gT25jZSBpbnRvIHRoZSBERkEsIHRoZSBERkEgc2ltdWxhdGlvbiBkb2VzIG5vdCByZWZlcmVuY2UgdGhlXHJcbiAqIHtAbGluayBERkEjc3RhdGVzfSBtYXAuIEl0IGZvbGxvd3MgdGhlIHtAbGluayBERkFTdGF0ZSNlZGdlc30gZmllbGQgdG8gbmV3XHJcbiAqIHRhcmdldHMuIFRoZSBERkEgc2ltdWxhdG9yIHdpbGwgZWl0aGVyIGZpbmQge0BsaW5rIERGQVN0YXRlI2VkZ2VzfSB0byBiZVxyXG4gKiBgdW5kZWZpbmVkYCwgdG8gYmUgbm9uLWB1bmRlZmluZWRgIGFuZCBgZGZhLmVkZ2VzW3RdYCB1bmRlZmluZWQsIG9yXHJcbiAqIGBkZmEuZWRnZXNbdF1gIHRvIGJlIG5vbi11bmRlZmluZWQuIFRoZVxyXG4gKiB7QGxpbmsgI2FkZERGQUVkZ2V9IG1ldGhvZCBjb3VsZCBiZSByYWNpbmcgdG8gc2V0IHRoZSBmaWVsZFxyXG4gKiBidXQgaW4gZWl0aGVyIGNhc2UgdGhlIERGQSBzaW11bGF0b3Igd29ya3M7IGlmIGB1bmRlZmluZWRgLCBhbmQgcmVxdWVzdHMgQVROXHJcbiAqIHNpbXVsYXRpb24uIEl0IGNvdWxkIGFsc28gcmFjZSB0cnlpbmcgdG8gZ2V0IGBkZmEuZWRnZXNbdF1gLCBidXQgZWl0aGVyXHJcbiAqIHdheSBpdCB3aWxsIHdvcmsgYmVjYXVzZSBpdCdzIG5vdCBkb2luZyBhIHRlc3QgYW5kIHNldCBvcGVyYXRpb24uXHJcbiAqXHJcbiAqICoqU3RhcnRpbmcgd2l0aCBTTEwgdGhlbiBmYWlsaW5nIHRvIGNvbWJpbmVkIFNMTC9MTCAoVHdvLVN0YWdlXHJcbiAqIFBhcnNpbmcpKipcclxuICpcclxuICogU2FtIHBvaW50ZWQgb3V0IHRoYXQgaWYgU0xMIGRvZXMgbm90IGdpdmUgYSBzeW50YXggZXJyb3IsIHRoZW4gdGhlcmUgaXMgbm9cclxuICogcG9pbnQgaW4gZG9pbmcgZnVsbCBMTCwgd2hpY2ggaXMgc2xvd2VyLiBXZSBvbmx5IGhhdmUgdG8gdHJ5IExMIGlmIHdlIGdldCBhXHJcbiAqIHN5bnRheCBlcnJvci4gRm9yIG1heGltdW0gc3BlZWQsIFNhbSBzdGFydHMgdGhlIHBhcnNlciBzZXQgdG8gcHVyZSBTTExcclxuICogbW9kZSB3aXRoIHRoZSB7QGxpbmsgQmFpbEVycm9yU3RyYXRlZ3l9OlxyXG4gKlxyXG4gKiBgYGBcclxuICogcGFyc2VyLmludGVycHJldGVyLntAbGluayAjc2V0UHJlZGljdGlvbk1vZGUgc2V0UHJlZGljdGlvbk1vZGV9YChge0BsaW5rIFByZWRpY3Rpb25Nb2RlI1NMTH1gKWA7XHJcbiAqIHBhcnNlci57QGxpbmsgUGFyc2VyI3NldEVycm9ySGFuZGxlciBzZXRFcnJvckhhbmRsZXJ9KG5ldyB7QGxpbmsgQmFpbEVycm9yU3RyYXRlZ3l9KCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogSWYgaXQgZG9lcyBub3QgZ2V0IGEgc3ludGF4IGVycm9yLCB0aGVuIHdlJ3JlIGRvbmUuIElmIGl0IGRvZXMgZ2V0IGEgc3ludGF4XHJcbiAqIGVycm9yLCB3ZSBuZWVkIHRvIHJldHJ5IHdpdGggdGhlIGNvbWJpbmVkIFNMTC9MTCBzdHJhdGVneS5cclxuICpcclxuICogVGhlIHJlYXNvbiB0aGlzIHdvcmtzIGlzIGFzIGZvbGxvd3MuIElmIHRoZXJlIGFyZSBubyBTTEwgY29uZmxpY3RzLCB0aGVuIHRoZVxyXG4gKiBncmFtbWFyIGlzIFNMTCAoYXQgbGVhc3QgZm9yIHRoYXQgaW5wdXQgc2V0KS4gSWYgdGhlcmUgaXMgYW4gU0xMIGNvbmZsaWN0LFxyXG4gKiB0aGUgZnVsbCBMTCBhbmFseXNpcyBtdXN0IHlpZWxkIGEgc2V0IG9mIHZpYWJsZSBhbHRlcm5hdGl2ZXMgd2hpY2ggaXMgYVxyXG4gKiBzdWJzZXQgb2YgdGhlIGFsdGVybmF0aXZlcyByZXBvcnRlZCBieSBTTEwuIElmIHRoZSBMTCBzZXQgaXMgYSBzaW5nbGV0b24sXHJcbiAqIHRoZW4gdGhlIGdyYW1tYXIgaXMgTEwgYnV0IG5vdCBTTEwuIElmIHRoZSBMTCBzZXQgaXMgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgU0xMXHJcbiAqIHNldCwgdGhlIGRlY2lzaW9uIGlzIFNMTC4gSWYgdGhlIExMIHNldCBoYXMgc2l6ZSAmZ3Q7IDEsIHRoZW4gdGhhdCBkZWNpc2lvblxyXG4gKiBpcyB0cnVseSBhbWJpZ3VvdXMgb24gdGhlIGN1cnJlbnQgaW5wdXQuIElmIHRoZSBMTCBzZXQgaXMgc21hbGxlciwgdGhlbiB0aGVcclxuICogU0xMIGNvbmZsaWN0IHJlc29sdXRpb24gbWlnaHQgY2hvb3NlIGFuIGFsdGVybmF0aXZlIHRoYXQgdGhlIGZ1bGwgTEwgd291bGRcclxuICogcnVsZSBvdXQgYXMgYSBwb3NzaWJpbGl0eSBiYXNlZCB1cG9uIGJldHRlciBjb250ZXh0IGluZm9ybWF0aW9uLiBJZiB0aGF0J3NcclxuICogdGhlIGNhc2UsIHRoZW4gdGhlIFNMTCBwYXJzZSB3aWxsIGRlZmluaXRlbHkgZ2V0IGFuIGVycm9yIGJlY2F1c2UgdGhlIGZ1bGwgTExcclxuICogYW5hbHlzaXMgc2F5cyBpdCdzIG5vdCB2aWFibGUuIElmIFNMTCBjb25mbGljdCByZXNvbHV0aW9uIGNob29zZXMgYW5cclxuICogYWx0ZXJuYXRpdmUgd2l0aGluIHRoZSBMTCBzZXQsIHRoZW0gYm90aCBTTEwgYW5kIExMIHdvdWxkIGNob29zZSB0aGUgc2FtZVxyXG4gKiBhbHRlcm5hdGl2ZSBiZWNhdXNlIHRoZXkgYm90aCBjaG9vc2UgdGhlIG1pbmltdW0gb2YgbXVsdGlwbGUgY29uZmxpY3RpbmdcclxuICogYWx0ZXJuYXRpdmVzLlxyXG4gKlxyXG4gKiBMZXQncyBzYXkgd2UgaGF2ZSBhIHNldCBvZiBTTEwgY29uZmxpY3RpbmcgYWx0ZXJuYXRpdmVzIGB7MSwgMiwgM31gIGFuZFxyXG4gKiBhIHNtYWxsZXIgTEwgc2V0IGNhbGxlZCAqcyouIElmICpzKiBpcyBgezIsIDN9YCwgdGhlbiBTTExcclxuICogcGFyc2luZyB3aWxsIGdldCBhbiBlcnJvciBiZWNhdXNlIFNMTCB3aWxsIHB1cnN1ZSBhbHRlcm5hdGl2ZSAxLiBJZlxyXG4gKiAqcyogaXMgYHsxLCAyfWAgb3IgYHsxLCAzfWAgdGhlbiBib3RoIFNMTCBhbmQgTEwgd2lsbFxyXG4gKiBjaG9vc2UgdGhlIHNhbWUgYWx0ZXJuYXRpdmUgYmVjYXVzZSBhbHRlcm5hdGl2ZSBvbmUgaXMgdGhlIG1pbmltdW0gb2YgZWl0aGVyXHJcbiAqIHNldC4gSWYgKnMqIGlzIGB7Mn1gIG9yIGB7M31gIHRoZW4gU0xMIHdpbGwgZ2V0IGEgc3ludGF4XHJcbiAqIGVycm9yLiBJZiAqcyogaXMgYHsxfWAgdGhlbiBTTEwgd2lsbCBzdWNjZWVkLlxyXG4gKlxyXG4gKiBPZiBjb3Vyc2UsIGlmIHRoZSBpbnB1dCBpcyBpbnZhbGlkLCB0aGVuIHdlIHdpbGwgZ2V0IGFuIGVycm9yIGZvciBzdXJlIGluXHJcbiAqIGJvdGggU0xMIGFuZCBMTCBwYXJzaW5nLiBFcnJvbmVvdXMgaW5wdXQgd2lsbCB0aGVyZWZvcmUgcmVxdWlyZSAyIHBhc3NlcyBvdmVyXHJcbiAqIHRoZSBpbnB1dC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQYXJzZXJBVE5TaW11bGF0b3IgZXh0ZW5kcyBBVE5TaW11bGF0b3Ige1xyXG5cdHB1YmxpYyBzdGF0aWMgZGVidWc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwdWJsaWMgc3RhdGljIGRmYV9kZWJ1ZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHB1YmxpYyBzdGF0aWMgcmV0cnlfZGVidWc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIHByZWRpY3Rpb25Nb2RlOiBQcmVkaWN0aW9uTW9kZSA9IFByZWRpY3Rpb25Nb2RlLkxMO1xyXG5cdHB1YmxpYyBmb3JjZV9nbG9iYWxfY29udGV4dDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHB1YmxpYyBhbHdheXNfdHJ5X2xvY2FsX2NvbnRleHQ6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIERGQSBpcyB1c2VkIGZvciBmdWxsLWNvbnRleHQgcHJlZGljdGlvbnMuIFdoZW5cclxuXHQgKiBgdHJ1ZWAsIHRoZSBERkEgc3RvcmVzIHRyYW5zaXRpb24gaW5mb3JtYXRpb24gZm9yIGJvdGggZnVsbC1jb250ZXh0XHJcblx0ICogYW5kIFNMTCBwYXJzaW5nOyBvdGhlcndpc2UsIHRoZSBERkEgb25seSBzdG9yZXMgU0xMIHRyYW5zaXRpb25cclxuXHQgKiBpbmZvcm1hdGlvbi5cclxuXHQgKlxyXG5cdCAqIEZvciBzb21lIGdyYW1tYXJzLCBlbmFibGluZyB0aGUgZnVsbC1jb250ZXh0IERGQSBjYW4gcmVzdWx0IGluIGFcclxuXHQgKiBzdWJzdGFudGlhbCBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC4gSG93ZXZlciwgdGhpcyBpbXByb3ZlbWVudCB0eXBpY2FsbHlcclxuXHQgKiBjb21lcyBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNlZCBmb3Igc3RvcmluZyB0aGUgY2FjaGVkIERGQSBzdGF0ZXMsXHJcblx0ICogY29uZmlndXJhdGlvbiBzZXRzLCBhbmQgcHJlZGljdGlvbiBjb250ZXh0cy5cclxuXHQgKlxyXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXHJcblx0ICovXHJcblx0cHVibGljIGVuYWJsZV9nbG9iYWxfY29udGV4dF9kZmE6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwdWJsaWMgb3B0aW1pemVfdW5pcXVlX2Nsb3N1cmU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdHB1YmxpYyBvcHRpbWl6ZV9sbDE6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdHB1YmxpYyBvcHRpbWl6ZV90YWlsX2NhbGxzOiBib29sZWFuID0gdHJ1ZTtcclxuXHRwdWJsaWMgdGFpbF9jYWxsX3ByZXNlcnZlc19zbGw6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdHB1YmxpYyB0cmVhdF9zbGxrMV9jb25mbGljdF9hc19hbWJpZ3VpdHk6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0cHJvdGVjdGVkIF9wYXJzZXI6IFBhcnNlcjtcclxuXHJcblx0LyoqXHJcblx0ICogV2hlbiBgdHJ1ZWAsIGFtYmlndW91cyBhbHRlcm5hdGl2ZXMgYXJlIHJlcG9ydGVkIHdoZW4gdGhleSBhcmVcclxuXHQgKiBlbmNvdW50ZXJlZCB3aXRoaW4ge0BsaW5rICNleGVjQVROfS4gV2hlbiBgZmFsc2VgLCB0aGVzZSBtZXNzYWdlc1xyXG5cdCAqIGFyZSBzdXBwcmVzc2VkLiBUaGUgZGVmYXVsdCBpcyBgZmFsc2VgLlxyXG5cdCAqXHJcblx0ICogV2hlbiBtZXNzYWdlcyBhYm91dCBhbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzIGFyZSBub3QgcmVxdWlyZWQsIHNldHRpbmcgdGhpc1xyXG5cdCAqIHRvIGBmYWxzZWAgZW5hYmxlcyBhZGRpdGlvbmFsIGludGVybmFsIG9wdGltaXphdGlvbnMgd2hpY2ggbWF5IGxvc2VcclxuXHQgKiB0aGlzIGluZm9ybWF0aW9uLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyByZXBvcnRBbWJpZ3VpdGllczogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHQvKiogQnkgZGVmYXVsdCB3ZSBkbyBmdWxsIGNvbnRleHQtc2Vuc2l0aXZlIExMKCopIHBhcnNpbmcgbm90XHJcblx0ICogIFN0cm9uZyBMTCgqKSBwYXJzaW5nLiBJZiB3ZSBmYWlsIHdpdGggU3Ryb25nIExMKCopIHdlXHJcblx0ICogIHRyeSBmdWxsIExMKCopLiBUaGF0IG1lYW5zIHdlIHJld2luZCBhbmQgdXNlIGNvbnRleHQgaW5mb3JtYXRpb25cclxuXHQgKiAgd2hlbiBjbG9zdXJlIG9wZXJhdGlvbnMgZmFsbCBvZmYgdGhlIGVuZCBvZiB0aGUgcnVsZSB0aGF0XHJcblx0ICogIGhvbGRzIHRoZSBkZWNpc2lvbiB3ZXJlIGV2YWx1YXRpbmcuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHVzZXJXYW50c0N0eFNlbnNpdGl2ZTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG5cdHByaXZhdGUgZGZhPzogREZBO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCBhdG46IEFUTiwgcGFyc2VyOiBQYXJzZXIpIHtcclxuXHRcdHN1cGVyKGF0bik7XHJcblx0XHR0aGlzLl9wYXJzZXIgPSBwYXJzZXI7XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRQcmVkaWN0aW9uTW9kZSgpOiBQcmVkaWN0aW9uTW9kZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcmVkaWN0aW9uTW9kZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXRQcmVkaWN0aW9uTW9kZShATm90TnVsbCBwcmVkaWN0aW9uTW9kZTogUHJlZGljdGlvbk1vZGUpOiB2b2lkIHtcclxuXHRcdHRoaXMucHJlZGljdGlvbk1vZGUgPSBwcmVkaWN0aW9uTW9kZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuXHRcdC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhZGFwdGl2ZVByZWRpY3QoLypATm90TnVsbCovIGlucHV0OiBUb2tlblN0cmVhbSwgZGVjaXNpb246IG51bWJlciwgb3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCk6IG51bWJlcjtcclxuXHRwdWJsaWMgYWRhcHRpdmVQcmVkaWN0KC8qQE5vdE51bGwqLyBpbnB1dDogVG9rZW5TdHJlYW0sIGRlY2lzaW9uOiBudW1iZXIsIG91dGVyQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsIHVzZUNvbnRleHQ6IGJvb2xlYW4pOiBudW1iZXI7XHJcblx0cHVibGljIGFkYXB0aXZlUHJlZGljdChcclxuXHRcdEBOb3ROdWxsIGlucHV0OiBUb2tlblN0cmVhbSxcclxuXHRcdGRlY2lzaW9uOiBudW1iZXIsXHJcblx0XHRvdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLFxyXG5cdFx0dXNlQ29udGV4dD86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cdFx0aWYgKHVzZUNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR1c2VDb250ZXh0ID0gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGRmYTogREZBID0gdGhpcy5hdG4uZGVjaXNpb25Ub0RGQVtkZWNpc2lvbl07XHJcblx0XHRhc3NlcnQoZGZhICE9IG51bGwpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW1pemVfbGwxICYmICFkZmEuaXNQcmVjZWRlbmNlRGZhICYmICFkZmEuaXNFbXB0eSkge1xyXG5cdFx0XHRsZXQgbGxfMTogbnVtYmVyID0gaW5wdXQuTEEoMSk7XHJcblx0XHRcdGlmIChsbF8xID49IDAgJiYgbGxfMSA8PSAweEZGRkYpIHtcclxuXHRcdFx0XHRsZXQga2V5OiBudW1iZXIgPSAoKGRlY2lzaW9uIDw8IDE2KSA+Pj4gMCkgKyBsbF8xO1xyXG5cdFx0XHRcdGxldCBhbHQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IHRoaXMuYXRuLkxMMVRhYmxlLmdldChrZXkpO1xyXG5cdFx0XHRcdGlmIChhbHQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGFsdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmRmYSA9IGRmYTtcclxuXHJcblx0XHRpZiAodGhpcy5mb3JjZV9nbG9iYWxfY29udGV4dCkge1xyXG5cdFx0XHR1c2VDb250ZXh0ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKCF0aGlzLmFsd2F5c190cnlfbG9jYWxfY29udGV4dCkge1xyXG5cdFx0XHR1c2VDb250ZXh0ID0gdXNlQ29udGV4dCB8fCBkZmEuaXNDb250ZXh0U2Vuc2l0aXZlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudXNlcldhbnRzQ3R4U2Vuc2l0aXZlID0gdXNlQ29udGV4dCB8fCAodGhpcy5wcmVkaWN0aW9uTW9kZSAhPT0gUHJlZGljdGlvbk1vZGUuU0xMICYmIG91dGVyQ29udGV4dCAhPSBudWxsICYmICF0aGlzLmF0bi5kZWNpc2lvblRvU3RhdGVbZGVjaXNpb25dLnNsbCk7XHJcblx0XHRpZiAob3V0ZXJDb250ZXh0ID09IG51bGwpIHtcclxuXHRcdFx0b3V0ZXJDb250ZXh0ID0gUGFyc2VyUnVsZUNvbnRleHQuZW1wdHlDb250ZXh0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHN0YXRlOiBTaW11bGF0b3JTdGF0ZSB8IHVuZGVmaW5lZDtcclxuXHRcdGlmICghZGZhLmlzRW1wdHkpIHtcclxuXHRcdFx0c3RhdGUgPSB0aGlzLmdldFN0YXJ0U3RhdGUoZGZhLCBpbnB1dCwgb3V0ZXJDb250ZXh0LCB1c2VDb250ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3RhdGUgPT0gbnVsbCkge1xyXG5cdFx0XHRpZiAob3V0ZXJDb250ZXh0ID09IG51bGwpIHtcclxuXHRcdFx0XHRvdXRlckNvbnRleHQgPSBQYXJzZXJSdWxlQ29udGV4dC5lbXB0eUNvbnRleHQoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJBVE4gZGVjaXNpb24gXCIgKyBkZmEuZGVjaXNpb24gK1xyXG5cdFx0XHRcdFx0XCIgZXhlYyBMQSgxKT09XCIgKyB0aGlzLmdldExvb2thaGVhZE5hbWUoaW5wdXQpICtcclxuXHRcdFx0XHRcdFwiLCBvdXRlckNvbnRleHQ9XCIgKyBvdXRlckNvbnRleHQudG9TdHJpbmcodGhpcy5fcGFyc2VyKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN0YXRlID0gdGhpcy5jb21wdXRlU3RhcnRTdGF0ZShkZmEsIG91dGVyQ29udGV4dCwgdXNlQ29udGV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG06IG51bWJlciA9IGlucHV0Lm1hcmsoKTtcclxuXHRcdGxldCBpbmRleDogbnVtYmVyID0gaW5wdXQuaW5kZXg7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRsZXQgYWx0OiBudW1iZXIgPSB0aGlzLmV4ZWNERkEoZGZhLCBpbnB1dCwgaW5kZXgsIHN0YXRlKTtcclxuXHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiREZBIGFmdGVyIHByZWRpY3RBVE46IFwiICsgZGZhLnRvU3RyaW5nKHRoaXMuX3BhcnNlci52b2NhYnVsYXJ5LCB0aGlzLl9wYXJzZXIucnVsZU5hbWVzKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGFsdDtcclxuXHRcdH1cclxuXHRcdGZpbmFsbHkge1xyXG5cdFx0XHR0aGlzLmRmYSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0aW5wdXQuc2VlayhpbmRleCk7XHJcblx0XHRcdGlucHV0LnJlbGVhc2UobSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0U3RhcnRTdGF0ZShcclxuXHRcdEBOb3ROdWxsIGRmYTogREZBLFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IFRva2VuU3RyZWFtLFxyXG5cdFx0QE5vdE51bGwgb3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCxcclxuXHRcdHVzZUNvbnRleHQ6IGJvb2xlYW4pOiBTaW11bGF0b3JTdGF0ZSB8IHVuZGVmaW5lZCB7XHJcblxyXG5cdFx0aWYgKCF1c2VDb250ZXh0KSB7XHJcblx0XHRcdGlmIChkZmEuaXNQcmVjZWRlbmNlRGZhKSB7XHJcblx0XHRcdFx0Ly8gdGhlIHN0YXJ0IHN0YXRlIGZvciBhIHByZWNlZGVuY2UgREZBIGRlcGVuZHMgb24gdGhlIGN1cnJlbnRcclxuXHRcdFx0XHQvLyBwYXJzZXIgcHJlY2VkZW5jZSwgYW5kIGlzIHByb3ZpZGVkIGJ5IGEgREZBIG1ldGhvZC5cclxuXHRcdFx0XHRsZXQgc3RhdGU6IERGQVN0YXRlIHwgdW5kZWZpbmVkID0gZGZhLmdldFByZWNlZGVuY2VTdGFydFN0YXRlKHRoaXMuX3BhcnNlci5wcmVjZWRlbmNlLCBmYWxzZSk7XHJcblx0XHRcdFx0aWYgKHN0YXRlID09IG51bGwpIHtcclxuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbmV3IFNpbXVsYXRvclN0YXRlKG91dGVyQ29udGV4dCwgc3RhdGUsIGZhbHNlLCBvdXRlckNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGlmIChkZmEuczAgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBuZXcgU2ltdWxhdG9yU3RhdGUob3V0ZXJDb250ZXh0LCBkZmEuczAsIGZhbHNlLCBvdXRlckNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLmVuYWJsZV9nbG9iYWxfY29udGV4dF9kZmEpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVtYWluaW5nQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQgPSBvdXRlckNvbnRleHQ7XHJcblx0XHRhc3NlcnQob3V0ZXJDb250ZXh0ICE9IG51bGwpO1xyXG5cdFx0bGV0IHMwOiBERkFTdGF0ZSB8IHVuZGVmaW5lZDtcclxuXHRcdGlmIChkZmEuaXNQcmVjZWRlbmNlRGZhKSB7XHJcblx0XHRcdHMwID0gZGZhLmdldFByZWNlZGVuY2VTdGFydFN0YXRlKHRoaXMuX3BhcnNlci5wcmVjZWRlbmNlLCB0cnVlKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRzMCA9IGRmYS5zMGZ1bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0d2hpbGUgKHJlbWFpbmluZ0NvbnRleHQgIT0gbnVsbCAmJiBzMCAhPSBudWxsICYmIHMwLmlzQ29udGV4dFNlbnNpdGl2ZSkge1xyXG5cdFx0XHRyZW1haW5pbmdDb250ZXh0ID0gdGhpcy5za2lwVGFpbENhbGxzKHJlbWFpbmluZ0NvbnRleHQpO1xyXG5cdFx0XHRzMCA9IHMwLmdldENvbnRleHRUYXJnZXQodGhpcy5nZXRSZXR1cm5TdGF0ZShyZW1haW5pbmdDb250ZXh0KSk7XHJcblx0XHRcdGlmIChyZW1haW5pbmdDb250ZXh0LmlzRW1wdHkpIHtcclxuXHRcdFx0XHRhc3NlcnQoczAgPT0gbnVsbCB8fCAhczAuaXNDb250ZXh0U2Vuc2l0aXZlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRyZW1haW5pbmdDb250ZXh0ID0gcmVtYWluaW5nQ29udGV4dC5wYXJlbnQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoczAgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgU2ltdWxhdG9yU3RhdGUob3V0ZXJDb250ZXh0LCBzMCwgdXNlQ29udGV4dCwgcmVtYWluaW5nQ29udGV4dCk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZXhlY0RGQShcclxuXHRcdEBOb3ROdWxsIGRmYTogREZBLFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IFRva2VuU3RyZWFtLCBzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRATm90TnVsbCBzdGF0ZTogU2ltdWxhdG9yU3RhdGUpOiBudW1iZXIge1xyXG5cdFx0bGV0IG91dGVyQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQgPSBzdGF0ZS5vdXRlckNvbnRleHQ7XHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRmYV9kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkRGQSBkZWNpc2lvbiBcIiArIGRmYS5kZWNpc2lvbiArXHJcblx0XHRcdFx0XCIgZXhlYyBMQSgxKT09XCIgKyB0aGlzLmdldExvb2thaGVhZE5hbWUoaW5wdXQpICtcclxuXHRcdFx0XHRcIiwgb3V0ZXJDb250ZXh0PVwiICsgb3V0ZXJDb250ZXh0LnRvU3RyaW5nKHRoaXMuX3BhcnNlcikpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZmFfZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coZGZhLnRvU3RyaW5nKHRoaXMuX3BhcnNlci52b2NhYnVsYXJ5LCB0aGlzLl9wYXJzZXIucnVsZU5hbWVzKSk7XHJcblx0XHR9XHJcblx0XHRsZXQgczogREZBU3RhdGUgPSBzdGF0ZS5zMDtcclxuXHJcblx0XHRsZXQgdDogbnVtYmVyID0gaW5wdXQuTEEoMSk7XHJcblx0XHRsZXQgcmVtYWluaW5nT3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCA9IHN0YXRlLnJlbWFpbmluZ091dGVyQ29udGV4dDtcclxuXHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRmYV9kZWJ1Zykge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiREZBIHN0YXRlIFwiICsgcy5zdGF0ZU51bWJlciArIFwiIExBKDEpPT1cIiArIHRoaXMuZ2V0TG9va2FoZWFkTmFtZShpbnB1dCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzdGF0ZS51c2VDb250ZXh0KSB7XHJcblx0XHRcdFx0d2hpbGUgKHMuaXNDb250ZXh0U3ltYm9sKHQpKSB7XHJcblx0XHRcdFx0XHRsZXQgbmV4dDogREZBU3RhdGUgfCB1bmRlZmluZWQ7XHJcblx0XHRcdFx0XHRpZiAocmVtYWluaW5nT3V0ZXJDb250ZXh0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0cmVtYWluaW5nT3V0ZXJDb250ZXh0ID0gdGhpcy5za2lwVGFpbENhbGxzKHJlbWFpbmluZ091dGVyQ29udGV4dCk7XHJcblx0XHRcdFx0XHRcdG5leHQgPSBzLmdldENvbnRleHRUYXJnZXQodGhpcy5nZXRSZXR1cm5TdGF0ZShyZW1haW5pbmdPdXRlckNvbnRleHQpKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAobmV4dCA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdC8vIGZhaWwgb3ZlciB0byBBVE5cclxuXHRcdFx0XHRcdFx0bGV0IGluaXRpYWxTdGF0ZTogU2ltdWxhdG9yU3RhdGUgPSBuZXcgU2ltdWxhdG9yU3RhdGUoc3RhdGUub3V0ZXJDb250ZXh0LCBzLCBzdGF0ZS51c2VDb250ZXh0LCByZW1haW5pbmdPdXRlckNvbnRleHQpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5leGVjQVROKGRmYSwgaW5wdXQsIHN0YXJ0SW5kZXgsIGluaXRpYWxTdGF0ZSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YXNzZXJ0KHJlbWFpbmluZ091dGVyQ29udGV4dCAhPSBudWxsKTtcclxuXHRcdFx0XHRcdHJlbWFpbmluZ091dGVyQ29udGV4dCA9IHJlbWFpbmluZ091dGVyQ29udGV4dC5wYXJlbnQ7XHJcblx0XHRcdFx0XHRzID0gbmV4dDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aGlzLmlzQWNjZXB0U3RhdGUocywgc3RhdGUudXNlQ29udGV4dCkpIHtcclxuXHRcdFx0XHRpZiAocy5wcmVkaWNhdGVzICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGZhX2RlYnVnKSB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiYWNjZXB0IFwiICsgcyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZmFfZGVidWcpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJhY2NlcHQ7IHByZWRpY3QgXCIgKyBzLnByZWRpY3Rpb24gKyBcIiBpbiBzdGF0ZSBcIiArIHMuc3RhdGVOdW1iZXIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8ga2VlcCBnb2luZyB1bmxlc3Mgd2UncmUgYXQgRU9GIG9yIHN0YXRlIG9ubHkgaGFzIG9uZSBhbHQgbnVtYmVyXHJcblx0XHRcdFx0Ly8gbWVudGlvbmVkIGluIGNvbmZpZ3M7IGNoZWNrIGlmIHNvbWV0aGluZyBlbHNlIGNvdWxkIG1hdGNoXHJcblx0XHRcdFx0Ly8gVE9ETzogZG9uJ3Qgd2UgYWx3YXlzIHN0b3A/IG9ubHkgbGV4ZXIgd291bGQga2VlcCBnb2luZ1xyXG5cdFx0XHRcdC8vIFRPRE86IHYzIGRmYSBkb24ndCBkbyB0aGlzLlxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0IGlzIG5vdCB1cGRhdGVkIGlmIG9uZSBvZiB0aGVzZSBzdGF0ZXMgaXMgcmVhY2hlZFxyXG5cdFx0XHRhc3NlcnQoIXRoaXMuaXNBY2NlcHRTdGF0ZShzLCBzdGF0ZS51c2VDb250ZXh0KSk7XHJcblxyXG5cdFx0XHQvLyBpZiBubyBlZGdlLCBwb3Agb3ZlciB0byBBVE4gaW50ZXJwcmV0ZXIsIHVwZGF0ZSBERkEgYW5kIHJldHVyblxyXG5cdFx0XHRsZXQgdGFyZ2V0OiBERkFTdGF0ZSB8IHVuZGVmaW5lZCA9IHRoaXMuZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZShzLCB0KTtcclxuXHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XHJcblx0XHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZmFfZGVidWcgJiYgdCA+PSAwKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIm5vIGVkZ2UgZm9yIFwiICsgdGhpcy5fcGFyc2VyLnZvY2FidWxhcnkuZ2V0RGlzcGxheU5hbWUodCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsZXQgYWx0OiBudW1iZXI7XHJcblx0XHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZmFfZGVidWcpIHtcclxuXHRcdFx0XHRcdGxldCBpbnRlcnZhbDogSW50ZXJ2YWwgPSBJbnRlcnZhbC5vZihzdGFydEluZGV4LCB0aGlzLl9wYXJzZXIuaW5wdXRTdHJlYW0uaW5kZXgpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJBVE4gZXhlYyB1cG9uIFwiICtcclxuXHRcdFx0XHRcdFx0dGhpcy5fcGFyc2VyLmlucHV0U3RyZWFtLmdldFRleHQoaW50ZXJ2YWwpICtcclxuXHRcdFx0XHRcdFx0XCIgYXQgREZBIHN0YXRlIFwiICsgcy5zdGF0ZU51bWJlcik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgaW5pdGlhbFN0YXRlOiBTaW11bGF0b3JTdGF0ZSA9IG5ldyBTaW11bGF0b3JTdGF0ZShvdXRlckNvbnRleHQsIHMsIHN0YXRlLnVzZUNvbnRleHQsIHJlbWFpbmluZ091dGVyQ29udGV4dCk7XHJcblx0XHRcdFx0YWx0ID0gdGhpcy5leGVjQVROKGRmYSwgaW5wdXQsIHN0YXJ0SW5kZXgsIGluaXRpYWxTdGF0ZSk7XHJcblx0XHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZmFfZGVidWcpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiYmFjayBmcm9tIERGQSB1cGRhdGUsIGFsdD1cIiArIGFsdCArIFwiLCBkZmE9XFxuXCIgKyBkZmEudG9TdHJpbmcodGhpcy5fcGFyc2VyLnZvY2FidWxhcnksIHRoaXMuX3BhcnNlci5ydWxlTmFtZXMpKTtcclxuXHRcdFx0XHRcdC8vZHVtcChkZmEpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBhY3Rpb24gYWxyZWFkeSBleGVjdXRlZFxyXG5cdFx0XHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGZhX2RlYnVnKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkRGQSBkZWNpc2lvbiBcIiArIGRmYS5kZWNpc2lvbiArXHJcblx0XHRcdFx0XHRcdFwiIHByZWRpY3RzIFwiICsgYWx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGFsdDsgLy8gd2UndmUgdXBkYXRlZCBERkEsIGV4ZWMnZCBhY3Rpb24sIGFuZCBoYXZlIG91ciBkZWVwZXN0IGFuc3dlclxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHRhcmdldCA9PT0gQVROU2ltdWxhdG9yLkVSUk9SKSB7XHJcblx0XHRcdFx0bGV0IGVycm9yU3RhdGU6IFNpbXVsYXRvclN0YXRlID0gbmV3IFNpbXVsYXRvclN0YXRlKG91dGVyQ29udGV4dCwgcywgc3RhdGUudXNlQ29udGV4dCwgcmVtYWluaW5nT3V0ZXJDb250ZXh0KTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVOb1ZpYWJsZUFsdChpbnB1dCwgc3RhcnRJbmRleCwgZXJyb3JTdGF0ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cyA9IHRhcmdldDtcclxuXHRcdFx0aWYgKCF0aGlzLmlzQWNjZXB0U3RhdGUocywgc3RhdGUudXNlQ29udGV4dCkgJiYgdCAhPT0gSW50U3RyZWFtLkVPRikge1xyXG5cdFx0XHRcdGlucHV0LmNvbnN1bWUoKTtcclxuXHRcdFx0XHR0ID0gaW5wdXQuTEEoMSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuLy9cdFx0aWYgKCBhY2NlcHRTdGF0ZT09bnVsbCApIHtcclxuLy9cdFx0XHRpZiAoIGRlYnVnICkgU3lzdGVtLm91dC5wcmludGxuKFwiISEhIG5vIHZpYWJsZSBhbHQgaW4gZGZhXCIpO1xyXG4vL1x0XHRcdHJldHVybiAtMTtcclxuLy9cdFx0fVxyXG5cclxuXHRcdGlmICghc3RhdGUudXNlQ29udGV4dCAmJiBzLmNvbmZpZ3MuY29uZmxpY3RJbmZvICE9IG51bGwpIHtcclxuXHRcdFx0aWYgKGRmYS5hdG5TdGFydFN0YXRlIGluc3RhbmNlb2YgRGVjaXNpb25TdGF0ZSkge1xyXG5cdFx0XHRcdGlmICghdGhpcy51c2VyV2FudHNDdHhTZW5zaXRpdmUgfHxcclxuXHRcdFx0XHRcdCghcy5jb25maWdzLmRpcHNJbnRvT3V0ZXJDb250ZXh0ICYmIHMuY29uZmlncy5pc0V4YWN0Q29uZmxpY3QpIHx8XHJcblx0XHRcdFx0XHQodGhpcy50cmVhdF9zbGxrMV9jb25mbGljdF9hc19hbWJpZ3VpdHkgJiYgaW5wdXQuaW5kZXggPT09IHN0YXJ0SW5kZXgpKSB7XHJcblx0XHRcdFx0XHQvLyB3ZSBkb24ndCByZXBvcnQgdGhlIGFtYmlndWl0eSBhZ2FpblxyXG5cdFx0XHRcdFx0Ly9pZiAoICF0aGlzLmFjY2VwdFN0YXRlLmNvbmZpZ3NldC5oYXNTZW1hbnRpY0NvbnRleHQgKSB7XHJcblx0XHRcdFx0XHQvLyBcdHRoaXMucmVwb3J0QW1iaWd1aXR5KGRmYSwgYWNjZXB0U3RhdGUsIHN0YXJ0SW5kZXgsIGlucHV0LmluZGV4LCBhY2NlcHRTdGF0ZS5jb25maWdzZXQuY29uZmxpY3RpbmdBbHRzLCBhY2NlcHRTdGF0ZS5jb25maWdzZXQpO1xyXG5cdFx0XHRcdFx0Ly99XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0YXNzZXJ0KCFzdGF0ZS51c2VDb250ZXh0KTtcclxuXHJcblx0XHRcdFx0XHQvLyBCZWZvcmUgYXR0ZW1wdGluZyBmdWxsIGNvbnRleHQgcHJlZGljdGlvbiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGFyZVxyXG5cdFx0XHRcdFx0Ly8gZGlzYW1iaWd1YXRpbmcgb3IgdmFsaWRhdGluZyBwcmVkaWNhdGVzIHRvIGV2YWx1YXRlIHdoaWNoIGFsbG93IGFuXHJcblx0XHRcdFx0XHQvLyBpbW1lZGlhdGUgZGVjaXNpb25cclxuXHRcdFx0XHRcdGxldCBjb25mbGljdGluZ0FsdHM6IEJpdFNldCB8IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdGxldCBwcmVkaWNhdGVzOiBERkFTdGF0ZS5QcmVkUHJlZGljdGlvbltdIHwgdW5kZWZpbmVkID0gcy5wcmVkaWNhdGVzO1xyXG5cdFx0XHRcdFx0aWYgKHByZWRpY2F0ZXMgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRsZXQgY29uZmxpY3RJbmRleDogbnVtYmVyID0gaW5wdXQuaW5kZXg7XHJcblx0XHRcdFx0XHRcdGlmIChjb25mbGljdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XHJcblx0XHRcdFx0XHRcdFx0aW5wdXQuc2VlayhzdGFydEluZGV4KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Y29uZmxpY3RpbmdBbHRzID0gdGhpcy5ldmFsU2VtYW50aWNDb250ZXh0KHByZWRpY2F0ZXMsIG91dGVyQ29udGV4dCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdGlmIChjb25mbGljdGluZ0FsdHMuY2FyZGluYWxpdHkoKSA9PT0gMSkge1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBjb25mbGljdGluZ0FsdHMubmV4dFNldEJpdCgwKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGNvbmZsaWN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyByZXN0b3JlIHRoZSBpbmRleCBzbyByZXBvcnRpbmcgdGhlIGZhbGxiYWNrIHRvIGZ1bGxcclxuXHRcdFx0XHRcdFx0XHQvLyBjb250ZXh0IG9jY3VycyB3aXRoIHRoZSBpbmRleCBhdCB0aGUgY29ycmVjdCBzcG90XHJcblx0XHRcdFx0XHRcdFx0aW5wdXQuc2Vlayhjb25mbGljdEluZGV4KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICh0aGlzLnJlcG9ydEFtYmlndWl0aWVzKSB7XHJcblx0XHRcdFx0XHRcdGxldCBjb25mbGljdFN0YXRlOiBTaW11bGF0b3JTdGF0ZSA9IG5ldyBTaW11bGF0b3JTdGF0ZShvdXRlckNvbnRleHQsIHMsIHN0YXRlLnVzZUNvbnRleHQsIHJlbWFpbmluZ091dGVyQ29udGV4dCk7XHJcblx0XHRcdFx0XHRcdHRoaXMucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KGRmYSwgY29uZmxpY3RpbmdBbHRzLCBjb25mbGljdFN0YXRlLCBzdGFydEluZGV4LCBpbnB1dC5pbmRleCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aW5wdXQuc2VlayhzdGFydEluZGV4KTtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFkYXB0aXZlUHJlZGljdChpbnB1dCwgZGZhLmRlY2lzaW9uLCBvdXRlckNvbnRleHQsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJlZm9yZSBqdW1waW5nIHRvIHByZWRpY3Rpb24sIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmVcclxuXHRcdC8vIGRpc2FtYmlndWF0aW5nIG9yIHZhbGlkYXRpbmcgcHJlZGljYXRlcyB0byBldmFsdWF0ZVxyXG5cdFx0bGV0IHByZWRpY2F0ZXM6IERGQVN0YXRlLlByZWRQcmVkaWN0aW9uW10gfCB1bmRlZmluZWQgPSBzLnByZWRpY2F0ZXM7XHJcblx0XHRpZiAocHJlZGljYXRlcyAhPSBudWxsKSB7XHJcblx0XHRcdGxldCBzdG9wSW5kZXg6IG51bWJlciA9IGlucHV0LmluZGV4O1xyXG5cdFx0XHRpZiAoc3RhcnRJbmRleCAhPT0gc3RvcEluZGV4KSB7XHJcblx0XHRcdFx0aW5wdXQuc2VlayhzdGFydEluZGV4KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGFsdHM6IEJpdFNldCA9IHRoaXMuZXZhbFNlbWFudGljQ29udGV4dChwcmVkaWNhdGVzLCBvdXRlckNvbnRleHQsIHRoaXMucmVwb3J0QW1iaWd1aXRpZXMgJiYgdGhpcy5wcmVkaWN0aW9uTW9kZSA9PT0gUHJlZGljdGlvbk1vZGUuTExfRVhBQ1RfQU1CSUdfREVURUNUSU9OKTtcclxuXHRcdFx0c3dpdGNoIChhbHRzLmNhcmRpbmFsaXR5KCkpIHtcclxuXHRcdFx0Y2FzZSAwOlxyXG5cdFx0XHRcdHRocm93IHRoaXMubm9WaWFibGVBbHQoaW5wdXQsIG91dGVyQ29udGV4dCwgcy5jb25maWdzLCBzdGFydEluZGV4KTtcclxuXHJcblx0XHRcdGNhc2UgMTpcclxuXHRcdFx0XHRyZXR1cm4gYWx0cy5uZXh0U2V0Qml0KDApO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHQvLyByZXBvcnQgYW1iaWd1aXR5IGFmdGVyIHByZWRpY2F0ZSBldmFsdWF0aW9uIHRvIG1ha2Ugc3VyZSB0aGUgY29ycmVjdFxyXG5cdFx0XHRcdC8vIHNldCBvZiBhbWJpZyBhbHRzIGlzIHJlcG9ydGVkLlxyXG5cdFx0XHRcdGlmIChzdGFydEluZGV4ICE9PSBzdG9wSW5kZXgpIHtcclxuXHRcdFx0XHRcdGlucHV0LnNlZWsoc3RvcEluZGV4KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMucmVwb3J0QW1iaWd1aXR5KGRmYSwgcywgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBzLmNvbmZpZ3MuaXNFeGFjdENvbmZsaWN0LCBhbHRzLCBzLmNvbmZpZ3MpO1xyXG5cdFx0XHRcdHJldHVybiBhbHRzLm5leHRTZXRCaXQoMCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRmYV9kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkRGQSBkZWNpc2lvbiBcIiArIGRmYS5kZWNpc2lvbiArXHJcblx0XHRcdFx0XCIgcHJlZGljdHMgXCIgKyBzLnByZWRpY3Rpb24pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHMucHJlZGljdGlvbjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZXMgaWYgYSBwYXJ0aWN1bGFyIERGQSBzdGF0ZSBzaG91bGQgYmUgdHJlYXRlZCBhcyBhbiBhY2NlcHQgc3RhdGVcclxuXHQgKiBmb3IgdGhlIGN1cnJlbnQgcHJlZGljdGlvbiBtb2RlLiBJbiBhZGRpdGlvbiB0byB0aGUgYHVzZUNvbnRleHRgXHJcblx0ICogcGFyYW1ldGVyLCB0aGUge0BsaW5rICNnZXRQcmVkaWN0aW9uTW9kZSgpfSBtZXRob2QgcHJvdmlkZXMgdGhlXHJcblx0ICogcHJlZGljdGlvbiBtb2RlIGNvbnRyb2xsaW5nIHRoZSBwcmVkaWN0aW9uIGFsZ29yaXRobSBhcyBhIHdob2xlLlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2ltcGx5IHJldHVybnMgdGhlIHZhbHVlIG9mXHJcblx0ICogYERGQVN0YXRlLmlzQWNjZXB0U3RhdGVgIGV4Y2VwdCBmb3IgY29uZmxpY3Qgc3RhdGVzIHdoZW5cclxuXHQgKiBgdXNlQ29udGV4dGAgaXMgYHRydWVgIGFuZCB7QGxpbmsgI2dldFByZWRpY3Rpb25Nb2RlKCl9IGlzXHJcblx0ICoge0BsaW5rIFByZWRpY3Rpb25Nb2RlI0xMX0VYQUNUX0FNQklHX0RFVEVDVElPTn0uIEluIHRoYXQgY2FzZSwgb25seVxyXG5cdCAqIGNvbmZsaWN0IHN0YXRlcyB3aGVyZSB7QGxpbmsgQVROQ29uZmlnU2V0I2lzRXhhY3RDb25mbGljdH0gaXNcclxuXHQgKiBgdHJ1ZWAgYXJlIGNvbnNpZGVyZWQgYWNjZXB0IHN0YXRlcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBzdGF0ZSBUaGUgREZBIHN0YXRlIHRvIGNoZWNrLlxyXG5cdCAqIEBwYXJhbSB1c2VDb250ZXh0IGB0cnVlYCBpZiB0aGUgcHJlZGljdGlvbiBhbGdvcml0aG0gaXMgY3VycmVudGx5XHJcblx0ICogY29uc2lkZXJpbmcgdGhlIGZ1bGwgcGFyc2VyIGNvbnRleHQ7IG90aGVyd2lzZSwgYGZhbHNlYCBpZiB0aGVcclxuXHQgKiBhbGdvcml0aG0gaXMgY3VycmVudGx5IHBlcmZvcm1pbmcgYSBsb2NhbCBjb250ZXh0IHByZWRpY3Rpb24uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBgc3RhdGVgIGlzIGFuIGFjY2VwdCBzdGF0ZTtcclxuXHQgKiBvdGhlcndpc2UsIGBmYWxzZWAuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGlzQWNjZXB0U3RhdGUoc3RhdGU6IERGQVN0YXRlLCB1c2VDb250ZXh0OiBib29sZWFuKTogYm9vbGVhbiB7XHJcblx0XHRpZiAoIXN0YXRlLmlzQWNjZXB0U3RhdGUpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5jb25maWdzLmNvbmZsaWN0aW5nQWx0cyA9PSBudWxsKSB7XHJcblx0XHRcdC8vIHVuYW1iaWd1b3VzXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1vcmUgcGlja3kgd2hlbiB3ZSBuZWVkIGV4YWN0IGNvbmZsaWN0c1xyXG5cdFx0aWYgKHVzZUNvbnRleHQgJiYgdGhpcy5wcmVkaWN0aW9uTW9kZSA9PT0gUHJlZGljdGlvbk1vZGUuTExfRVhBQ1RfQU1CSUdfREVURUNUSU9OKSB7XHJcblx0XHRcdHJldHVybiBzdGF0ZS5jb25maWdzLmlzRXhhY3RDb25mbGljdDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKiBQZXJmb3JtcyBBVE4gc2ltdWxhdGlvbiB0byBjb21wdXRlIGEgcHJlZGljdGVkIGFsdGVybmF0aXZlIGJhc2VkXHJcblx0ICogIHVwb24gdGhlIHJlbWFpbmluZyBpbnB1dCwgYnV0IGFsc28gdXBkYXRlcyB0aGUgREZBIGNhY2hlIHRvIGF2b2lkXHJcblx0ICogIGhhdmluZyB0byB0cmF2ZXJzZSB0aGUgQVROIGFnYWluIGZvciB0aGUgc2FtZSBpbnB1dCBzZXF1ZW5jZS5cclxuXHQgKlxyXG5cdCAqIFRoZXJlIGFyZSBzb21lIGtleSBjb25kaXRpb25zIHdlJ3JlIGxvb2tpbmcgZm9yIGFmdGVyIGNvbXB1dGluZyBhIG5ld1xyXG5cdCAqIHNldCBvZiBBVE4gY29uZmlncyAocHJvcG9zZWQgREZBIHN0YXRlKTpcclxuXHQgKlxyXG5cdCAqICogaWYgdGhlIHNldCBpcyBlbXB0eSwgdGhlcmUgaXMgbm8gdmlhYmxlIGFsdGVybmF0aXZlIGZvciBjdXJyZW50IHN5bWJvbFxyXG5cdCAqICogZG9lcyB0aGUgc3RhdGUgdW5pcXVlbHkgcHJlZGljdCBhbiBhbHRlcm5hdGl2ZT9cclxuXHQgKiAqIGRvZXMgdGhlIHN0YXRlIGhhdmUgYSBjb25mbGljdCB0aGF0IHdvdWxkIHByZXZlbnQgdXMgZnJvbVxyXG5cdCAqICAgcHV0dGluZyBpdCBvbiB0aGUgd29yayBsaXN0P1xyXG5cdCAqICogaWYgaW4gbm9uLWdyZWVkeSBkZWNpc2lvbiBpcyB0aGVyZSBhIGNvbmZpZyBhdCBhIHJ1bGUgc3RvcCBzdGF0ZT9cclxuXHQgKlxyXG5cdCAqIFdlIGFsc28gaGF2ZSBzb21lIGtleSBvcGVyYXRpb25zIHRvIGRvOlxyXG5cdCAqXHJcblx0ICogKiBhZGQgYW4gZWRnZSBmcm9tIHByZXZpb3VzIERGQSBzdGF0ZSB0byBwb3RlbnRpYWxseSBuZXcgREZBIHN0YXRlLCBELFxyXG5cdCAqICAgdXBvbiBjdXJyZW50IHN5bWJvbCBidXQgb25seSBpZiBhZGRpbmcgdG8gd29yayBsaXN0LCB3aGljaCBtZWFucyBpbiBhbGxcclxuXHQgKiAgIGNhc2VzIGV4Y2VwdCBubyB2aWFibGUgYWx0ZXJuYXRpdmUgKGFuZCBwb3NzaWJseSBub24tZ3JlZWR5IGRlY2lzaW9ucz8pXHJcblx0ICogKiBjb2xsZWN0aW5nIHByZWRpY2F0ZXMgYW5kIGFkZGluZyBzZW1hbnRpYyBjb250ZXh0IHRvIERGQSBhY2NlcHQgc3RhdGVzXHJcblx0ICogKiBhZGRpbmcgcnVsZSBjb250ZXh0IHRvIGNvbnRleHQtc2Vuc2l0aXZlIERGQSBhY2NlcHQgc3RhdGVzXHJcblx0ICogKiBjb25zdW1pbmcgYW4gaW5wdXQgc3ltYm9sXHJcblx0ICogKiByZXBvcnRpbmcgYSBjb25mbGljdFxyXG5cdCAqICogcmVwb3J0aW5nIGFuIGFtYmlndWl0eVxyXG5cdCAqICogcmVwb3J0aW5nIGEgY29udGV4dCBzZW5zaXRpdml0eVxyXG5cdCAqICogcmVwb3J0aW5nIGluc3VmZmljaWVudCBwcmVkaWNhdGVzXHJcblx0ICpcclxuXHQgKiBXZSBzaG91bGQgaXNvbGF0ZSB0aG9zZSBvcGVyYXRpb25zLCB3aGljaCBhcmUgc2lkZS1lZmZlY3RpbmcsIHRvIHRoZVxyXG5cdCAqIG1haW4gd29yayBsb29wLiBXZSBjYW4gaXNvbGF0ZSBsb3RzIG9mIGNvZGUgaW50byBvdGhlciBmdW5jdGlvbnMsIGJ1dFxyXG5cdCAqIHRoZXkgc2hvdWxkIGJlIHNpZGUgZWZmZWN0IGZyZWUuIFRoZXkgY2FuIHJldHVybiBwYWNrYWdlIHRoYXRcclxuXHQgKiBpbmRpY2F0ZXMgd2hldGhlciB3ZSBzaG91bGQgcmVwb3J0IHNvbWV0aGluZywgd2hldGhlciB3ZSBuZWVkIHRvIGFkZCBhXHJcblx0ICogREZBIGVkZ2UsIHdoZXRoZXIgd2UgbmVlZCB0byBhdWdtZW50IGFjY2VwdCBzdGF0ZSB3aXRoIHNlbWFudGljXHJcblx0ICogY29udGV4dCBvciBydWxlIGludm9jYXRpb24gY29udGV4dC4gQWN0dWFsbHksIGl0IHNlZW1zIGxpa2Ugd2UgYWx3YXlzXHJcblx0ICogYWRkIHByZWRpY2F0ZXMgaWYgdGhleSBleGlzdCwgc28gdGhhdCBjYW4gc2ltcGx5IGJlIGRvbmUgaW4gdGhlIG1haW5cclxuXHQgKiBsb29wIGZvciBhbnkgYWNjZXB0IHN0YXRlIGNyZWF0aW9uIG9yIG1vZGlmaWNhdGlvbiByZXF1ZXN0LlxyXG5cdCAqXHJcblx0ICogY292ZXIgdGhlc2UgY2FzZXM6XHJcblx0ICogICBkZWFkIGVuZFxyXG5cdCAqICAgc2luZ2xlIGFsdFxyXG5cdCAqICAgc2luZ2xlIGFsdCArIHByZWRzXHJcblx0ICogICBjb25mbGljdFxyXG5cdCAqICAgY29uZmxpY3QgKyBwcmVkc1xyXG5cdCAqXHJcblx0ICogVE9ETzogZ3JlZWR5ICsgdGhvc2VcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgZXhlY0FUTihcclxuXHRcdEBOb3ROdWxsIGRmYTogREZBLFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IFRva2VuU3RyZWFtLCBzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRATm90TnVsbCBpbml0aWFsU3RhdGU6IFNpbXVsYXRvclN0YXRlKTogbnVtYmVyIHtcclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJleGVjQVROIGRlY2lzaW9uIFwiICsgZGZhLmRlY2lzaW9uICsgXCIgZXhlYyBMQSgxKT09XCIgKyB0aGlzLmdldExvb2thaGVhZE5hbWUoaW5wdXQpKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgb3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCA9IGluaXRpYWxTdGF0ZS5vdXRlckNvbnRleHQ7XHJcblx0XHRsZXQgdXNlQ29udGV4dDogYm9vbGVhbiA9IGluaXRpYWxTdGF0ZS51c2VDb250ZXh0O1xyXG5cclxuXHRcdGxldCB0OiBudW1iZXIgPSBpbnB1dC5MQSgxKTtcclxuXHJcblx0XHRsZXQgcHJldmlvdXM6IFNpbXVsYXRvclN0YXRlID0gaW5pdGlhbFN0YXRlO1xyXG5cclxuXHRcdGxldCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUgPSBuZXcgUHJlZGljdGlvbkNvbnRleHRDYWNoZSgpO1xyXG5cdFx0d2hpbGUgKHRydWUpIHsgLy8gd2hpbGUgbW9yZSB3b3JrXHJcblx0XHRcdGxldCBuZXh0U3RhdGU6IFNpbXVsYXRvclN0YXRlIHwgdW5kZWZpbmVkID0gdGhpcy5jb21wdXRlUmVhY2hTZXQoZGZhLCBwcmV2aW91cywgdCwgY29udGV4dENhY2hlKTtcclxuXHRcdFx0aWYgKG5leHRTdGF0ZSA9PSBudWxsKSB7XHJcblx0XHRcdFx0dGhpcy5zZXRERkFFZGdlKHByZXZpb3VzLnMwLCBpbnB1dC5MQSgxKSwgQVROU2ltdWxhdG9yLkVSUk9SKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVOb1ZpYWJsZUFsdChpbnB1dCwgc3RhcnRJbmRleCwgcHJldmlvdXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgRDogREZBU3RhdGUgPSBuZXh0U3RhdGUuczA7XHJcblxyXG5cdFx0XHQvLyBwcmVkaWN0ZWQgYWx0ID0+IGFjY2VwdCBzdGF0ZVxyXG5cdFx0XHRhc3NlcnQoRC5pc0FjY2VwdFN0YXRlIHx8IEQucHJlZGljdGlvbiA9PT0gQVROLklOVkFMSURfQUxUX05VTUJFUik7XHJcblx0XHRcdC8vIGNvbmZsaWN0ZWQgPT4gYWNjZXB0IHN0YXRlXHJcblx0XHRcdGFzc2VydChELmlzQWNjZXB0U3RhdGUgfHwgRC5jb25maWdzLmNvbmZsaWN0SW5mbyA9PSBudWxsKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmlzQWNjZXB0U3RhdGUoRCwgdXNlQ29udGV4dCkpIHtcclxuXHRcdFx0XHRsZXQgY29uZmxpY3RpbmdBbHRzOiBCaXRTZXQgfCB1bmRlZmluZWQgPSBELmNvbmZpZ3MuY29uZmxpY3RpbmdBbHRzO1xyXG5cdFx0XHRcdGxldCBwcmVkaWN0ZWRBbHQ6IG51bWJlciA9IGNvbmZsaWN0aW5nQWx0cyA9PSBudWxsID8gRC5wcmVkaWN0aW9uIDogQVROLklOVkFMSURfQUxUX05VTUJFUjtcclxuXHRcdFx0XHRpZiAocHJlZGljdGVkQWx0ICE9PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpbWl6ZV9sbDFcclxuXHRcdFx0XHRcdFx0JiYgaW5wdXQuaW5kZXggPT09IHN0YXJ0SW5kZXhcclxuXHRcdFx0XHRcdFx0JiYgIWRmYS5pc1ByZWNlZGVuY2VEZmFcclxuXHRcdFx0XHRcdFx0JiYgbmV4dFN0YXRlLm91dGVyQ29udGV4dCA9PT0gbmV4dFN0YXRlLnJlbWFpbmluZ091dGVyQ29udGV4dFxyXG5cdFx0XHRcdFx0XHQmJiBkZmEuZGVjaXNpb24gPj0gMFxyXG5cdFx0XHRcdFx0XHQmJiAhRC5jb25maWdzLmhhc1NlbWFudGljQ29udGV4dCkge1xyXG5cdFx0XHRcdFx0XHRpZiAodCA+PSAwICYmIHQgPD0gTUFYX1NIT1JUX1ZBTFVFKSB7XHJcblx0XHRcdFx0XHRcdFx0bGV0IGtleTogbnVtYmVyID0gKChkZmEuZGVjaXNpb24gPDwgMTYpID4+PiAwKSArIHQ7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5hdG4uTEwxVGFibGUuc2V0KGtleSwgcHJlZGljdGVkQWx0KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICh1c2VDb250ZXh0ICYmIHRoaXMuYWx3YXlzX3RyeV9sb2NhbF9jb250ZXh0KSB7XHJcblx0XHRcdFx0XHRcdHRoaXMucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KGRmYSwgcHJlZGljdGVkQWx0LCBuZXh0U3RhdGUsIHN0YXJ0SW5kZXgsIGlucHV0LmluZGV4KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHByZWRpY3RlZEFsdCA9IEQucHJlZGljdGlvbjtcclxuLy9cdFx0XHRcdGludCBrID0gaW5wdXQuaW5kZXggLSBzdGFydEluZGV4ICsgMTsgLy8gaG93IG11Y2ggaW5wdXQgd2UgdXNlZFxyXG4vL1x0XHRcdFx0U3lzdGVtLm91dC5wcmludGxuKFwidXNlZCBrPVwiK2spO1xyXG5cdFx0XHRcdGxldCBhdHRlbXB0RnVsbENvbnRleHQ6IGJvb2xlYW4gPSBjb25mbGljdGluZ0FsdHMgIT0gbnVsbCAmJiB0aGlzLnVzZXJXYW50c0N0eFNlbnNpdGl2ZTtcclxuXHRcdFx0XHRpZiAoYXR0ZW1wdEZ1bGxDb250ZXh0KSB7XHJcblx0XHRcdFx0XHQvLyBPbmx5IGV4YWN0IGNvbmZsaWN0cyBhcmUga25vd24gdG8gYmUgYW1iaWd1b3VzIHdoZW4gbG9jYWxcclxuXHRcdFx0XHRcdC8vIHByZWRpY3Rpb24gZG9lcyBub3Qgc3RlcCBvdXQgb2YgdGhlIGRlY2lzaW9uIHJ1bGUuXHJcblx0XHRcdFx0XHRhdHRlbXB0RnVsbENvbnRleHQgPSAhdXNlQ29udGV4dFxyXG5cdFx0XHRcdFx0XHQmJiAoRC5jb25maWdzLmRpcHNJbnRvT3V0ZXJDb250ZXh0IHx8ICFELmNvbmZpZ3MuaXNFeGFjdENvbmZsaWN0KVxyXG5cdFx0XHRcdFx0XHQmJiAoIXRoaXMudHJlYXRfc2xsazFfY29uZmxpY3RfYXNfYW1iaWd1aXR5IHx8IGlucHV0LmluZGV4ICE9PSBzdGFydEluZGV4KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChELmNvbmZpZ3MuaGFzU2VtYW50aWNDb250ZXh0KSB7XHJcblx0XHRcdFx0XHRsZXQgcHJlZFByZWRpY3Rpb25zOiBERkFTdGF0ZS5QcmVkUHJlZGljdGlvbltdIHwgdW5kZWZpbmVkID0gRC5wcmVkaWNhdGVzO1xyXG5cdFx0XHRcdFx0aWYgKHByZWRQcmVkaWN0aW9ucyAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdGxldCBjb25mbGljdEluZGV4OiBudW1iZXIgPSBpbnB1dC5pbmRleDtcclxuXHRcdFx0XHRcdFx0aWYgKGNvbmZsaWN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHRpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB1c2UgY29tcGxldGUgZXZhbHVhdGlvbiBoZXJlIGlmIHdlJ2xsIHdhbnQgdG8gcmV0cnkgd2l0aCBmdWxsIGNvbnRleHQgaWYgc3RpbGwgYW1iaWd1b3VzXHJcblx0XHRcdFx0XHRcdGNvbmZsaWN0aW5nQWx0cyA9IHRoaXMuZXZhbFNlbWFudGljQ29udGV4dChwcmVkUHJlZGljdGlvbnMsIG91dGVyQ29udGV4dCwgYXR0ZW1wdEZ1bGxDb250ZXh0IHx8IHRoaXMucmVwb3J0QW1iaWd1aXRpZXMpO1xyXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKGNvbmZsaWN0aW5nQWx0cy5jYXJkaW5hbGl0eSgpKSB7XHJcblx0XHRcdFx0XHRcdGNhc2UgMDpcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyB0aGlzLm5vVmlhYmxlQWx0KGlucHV0LCBvdXRlckNvbnRleHQsIEQuY29uZmlncywgc3RhcnRJbmRleCk7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlIDE6XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbmZsaWN0aW5nQWx0cy5uZXh0U2V0Qml0KDApO1xyXG5cclxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGNvbmZsaWN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyByZXN0b3JlIHRoZSBpbmRleCBzbyByZXBvcnRpbmcgdGhlIGZhbGxiYWNrIHRvIGZ1bGxcclxuXHRcdFx0XHRcdFx0XHQvLyBjb250ZXh0IG9jY3VycyB3aXRoIHRoZSBpbmRleCBhdCB0aGUgY29ycmVjdCBzcG90XHJcblx0XHRcdFx0XHRcdFx0aW5wdXQuc2Vlayhjb25mbGljdEluZGV4KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCFhdHRlbXB0RnVsbENvbnRleHQpIHtcclxuXHRcdFx0XHRcdGlmIChjb25mbGljdGluZ0FsdHMgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5yZXBvcnRBbWJpZ3VpdGllcyAmJiBjb25mbGljdGluZ0FsdHMuY2FyZGluYWxpdHkoKSA+IDEpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnJlcG9ydEFtYmlndWl0eShkZmEsIEQsIHN0YXJ0SW5kZXgsIGlucHV0LmluZGV4LCBELmNvbmZpZ3MuaXNFeGFjdENvbmZsaWN0LCBjb25mbGljdGluZ0FsdHMsIEQuY29uZmlncyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHByZWRpY3RlZEFsdCA9IGNvbmZsaWN0aW5nQWx0cy5uZXh0U2V0Qml0KDApO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBwcmVkaWN0ZWRBbHQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0YXNzZXJ0KCF1c2VDb250ZXh0KTtcclxuXHRcdFx0XHRcdGFzc2VydCh0aGlzLmlzQWNjZXB0U3RhdGUoRCwgZmFsc2UpKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiUkVUUlkgd2l0aCBvdXRlckNvbnRleHQ9XCIgKyBvdXRlckNvbnRleHQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IGZ1bGxDb250ZXh0U3RhdGU6IFNpbXVsYXRvclN0YXRlID0gdGhpcy5jb21wdXRlU3RhcnRTdGF0ZShkZmEsIG91dGVyQ29udGV4dCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5yZXBvcnRBbWJpZ3VpdGllcykge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dChkZmEsIGNvbmZsaWN0aW5nQWx0cywgbmV4dFN0YXRlLCBzdGFydEluZGV4LCBpbnB1dC5pbmRleCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aW5wdXQuc2VlayhzdGFydEluZGV4KTtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmV4ZWNBVE4oZGZhLCBpbnB1dCwgc3RhcnRJbmRleCwgZnVsbENvbnRleHRTdGF0ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwcmV2aW91cyA9IG5leHRTdGF0ZTtcclxuXHJcblx0XHRcdGlmICh0ICE9PSBJbnRTdHJlYW0uRU9GKSB7XHJcblx0XHRcdFx0aW5wdXQuY29uc3VtZSgpO1xyXG5cdFx0XHRcdHQgPSBpbnB1dC5MQSgxKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBpbXByb3ZlIHRoZSBsb2NhbGl6YXRpb24gb2YgZXJyb3IgbWVzc2FnZXMgYnlcclxuXHQgKiBjaG9vc2luZyBhbiBhbHRlcm5hdGl2ZSByYXRoZXIgdGhhbiB0aHJvd2luZyBhXHJcblx0ICoge0BsaW5rIE5vVmlhYmxlQWx0RXhjZXB0aW9ufSBpbiBwYXJ0aWN1bGFyIHByZWRpY3Rpb24gc2NlbmFyaW9zIHdoZXJlIHRoZVxyXG5cdCAqIHtAbGluayAjRVJST1J9IHN0YXRlIHdhcyByZWFjaGVkIGR1cmluZyBBVE4gc2ltdWxhdGlvbi5cclxuXHQgKlxyXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIHVzZXMgdGhlIGZvbGxvd2luZ1xyXG5cdCAqIGFsZ29yaXRobSB0byBpZGVudGlmeSBhbiBBVE4gY29uZmlndXJhdGlvbiB3aGljaCBzdWNjZXNzZnVsbHkgcGFyc2VkIHRoZVxyXG5cdCAqIGRlY2lzaW9uIGVudHJ5IHJ1bGUuIENob29zaW5nIHN1Y2ggYW4gYWx0ZXJuYXRpdmUgZW5zdXJlcyB0aGF0IHRoZVxyXG5cdCAqIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dH0gcmV0dXJuZWQgYnkgdGhlIGNhbGxpbmcgcnVsZSB3aWxsIGJlIGNvbXBsZXRlXHJcblx0ICogYW5kIHZhbGlkLCBhbmQgdGhlIHN5bnRheCBlcnJvciB3aWxsIGJlIHJlcG9ydGVkIGxhdGVyIGF0IGEgbW9yZVxyXG5cdCAqIGxvY2FsaXplZCBsb2NhdGlvbi5cclxuXHQgKlxyXG5cdCAqICogSWYgbm8gY29uZmlndXJhdGlvbiBpbiBgY29uZmlnc2AgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZVxyXG5cdCAqICAgZGVjaXNpb24gcnVsZSwgcmV0dXJuIHtAbGluayBBVE4jSU5WQUxJRF9BTFRfTlVNQkVSfS5cclxuXHQgKiAqIElmIGFsbCBjb25maWd1cmF0aW9ucyBpbiBgY29uZmlnc2Agd2hpY2ggcmVhY2hlZCB0aGUgZW5kIG9mIHRoZVxyXG5cdCAqICAgZGVjaXNpb24gcnVsZSBwcmVkaWN0IHRoZSBzYW1lIGFsdGVybmF0aXZlLCByZXR1cm4gdGhhdCBhbHRlcm5hdGl2ZS5cclxuXHQgKiAqIElmIHRoZSBjb25maWd1cmF0aW9ucyBpbiBgY29uZmlnc2Agd2hpY2ggcmVhY2hlZCB0aGUgZW5kIG9mIHRoZVxyXG5cdCAqICAgZGVjaXNpb24gcnVsZSBwcmVkaWN0IG11bHRpcGxlIGFsdGVybmF0aXZlcyAoY2FsbCB0aGlzICpTKiksXHJcblx0ICogICBjaG9vc2UgYW4gYWx0ZXJuYXRpdmUgaW4gdGhlIGZvbGxvd2luZyBvcmRlci5cclxuXHQgKlxyXG5cdCAqICAgICAxLiBGaWx0ZXIgdGhlIGNvbmZpZ3VyYXRpb25zIGluIGBjb25maWdzYCB0byBvbmx5IHRob3NlXHJcblx0ICogICAgICAgIGNvbmZpZ3VyYXRpb25zIHdoaWNoIHJlbWFpbiB2aWFibGUgYWZ0ZXIgZXZhbHVhdGluZyBzZW1hbnRpYyBwcmVkaWNhdGVzLlxyXG5cdCAqICAgICAgICBJZiB0aGUgc2V0IG9mIHRoZXNlIGZpbHRlcmVkIGNvbmZpZ3VyYXRpb25zIHdoaWNoIGFsc28gcmVhY2hlZCB0aGUgZW5kIG9mXHJcblx0ICogICAgICAgIHRoZSBkZWNpc2lvbiBydWxlIGlzIG5vdCBlbXB0eSwgcmV0dXJuIHRoZSBtaW5pbXVtIGFsdGVybmF0aXZlXHJcblx0ICogICAgICAgIHJlcHJlc2VudGVkIGluIHRoaXMgc2V0LlxyXG5cdCAqICAgICAxLiBPdGhlcndpc2UsIGNob29zZSB0aGUgbWluaW11bSBhbHRlcm5hdGl2ZSBpbiAqUyouXHJcblx0ICpcclxuXHQgKiBJbiBzb21lIHNjZW5hcmlvcywgdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgYWJvdmUgY291bGQgcHJlZGljdCBhblxyXG5cdCAqIGFsdGVybmF0aXZlIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEge0BsaW5rIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbn0gaW5cclxuXHQgKiBwYXJzZXIuIFNwZWNpZmljYWxseSwgdGhpcyBjb3VsZCBvY2N1ciBpZiB0aGUgKm9ubHkqIGNvbmZpZ3VyYXRpb25cclxuXHQgKiBjYXBhYmxlIG9mIHN1Y2Nlc3NmdWxseSBwYXJzaW5nIHRvIHRoZSBlbmQgb2YgdGhlIGRlY2lzaW9uIHJ1bGUgaXNcclxuXHQgKiBibG9ja2VkIGJ5IGEgc2VtYW50aWMgcHJlZGljYXRlLiBCeSBjaG9vc2luZyB0aGlzIGFsdGVybmF0aXZlIHdpdGhpblxyXG5cdCAqIHtAbGluayAjYWRhcHRpdmVQcmVkaWN0fSBpbnN0ZWFkIG9mIHRocm93aW5nIGFcclxuXHQgKiB7QGxpbmsgTm9WaWFibGVBbHRFeGNlcHRpb259LCB0aGUgcmVzdWx0aW5nXHJcblx0ICoge0BsaW5rIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbn0gaW4gdGhlIHBhcnNlciB3aWxsIGlkZW50aWZ5IHRoZSBzcGVjaWZpY1xyXG5cdCAqIHByZWRpY2F0ZSB3aGljaCBpcyBwcmV2ZW50aW5nIHRoZSBwYXJzZXIgZnJvbSBzdWNjZXNzZnVsbHkgcGFyc2luZyB0aGVcclxuXHQgKiBkZWNpc2lvbiBydWxlLCB3aGljaCBoZWxwcyBkZXZlbG9wZXJzIGlkZW50aWZ5IGFuZCBjb3JyZWN0IGxvZ2ljIGVycm9yc1xyXG5cdCAqIGluIHNlbWFudGljIHByZWRpY2F0ZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHtAbGluayBUb2tlblN0cmVhbX1cclxuXHQgKiBAcGFyYW0gc3RhcnRJbmRleCBUaGUgc3RhcnQgaW5kZXggZm9yIHRoZSBjdXJyZW50IHByZWRpY3Rpb24sIHdoaWNoIGlzXHJcblx0ICogdGhlIGlucHV0IGluZGV4IHdoZXJlIGFueSBzZW1hbnRpYyBjb250ZXh0IGluIGBjb25maWdzYCBzaG91bGQgYmVcclxuXHQgKiBldmFsdWF0ZWRcclxuXHQgKiBAcGFyYW0gcHJldmlvdXMgVGhlIEFUTiBzaW11bGF0aW9uIHN0YXRlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGVcclxuXHQgKiB7QGxpbmsgI0VSUk9SfSBzdGF0ZSB3YXMgcmVhY2hlZFxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHtAbGluayAjYWRhcHRpdmVQcmVkaWN0fSwgb3JcclxuXHQgKiB7QGxpbmsgQVROI0lOVkFMSURfQUxUX05VTUJFUn0gaWYgYSBzdWl0YWJsZSBhbHRlcm5hdGl2ZSB3YXMgbm90XHJcblx0ICogaWRlbnRpZmllZCBhbmQge0BsaW5rICNhZGFwdGl2ZVByZWRpY3R9IHNob3VsZCByZXBvcnQgYW4gZXJyb3IgaW5zdGVhZC5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgaGFuZGxlTm9WaWFibGVBbHQoQE5vdE51bGwgaW5wdXQ6IFRva2VuU3RyZWFtLCBzdGFydEluZGV4OiBudW1iZXIsIEBOb3ROdWxsIHByZXZpb3VzOiBTaW11bGF0b3JTdGF0ZSk6IG51bWJlciB7XHJcblx0XHRpZiAocHJldmlvdXMuczAgIT0gbnVsbCkge1xyXG5cdFx0XHRsZXQgYWx0czogQml0U2V0ID0gbmV3IEJpdFNldCgpO1xyXG5cdFx0XHRsZXQgbWF4QWx0OiBudW1iZXIgPSAwO1xyXG5cdFx0XHRmb3IgKGxldCBjb25maWcgb2YgcHJldmlvdXMuczAuY29uZmlncykge1xyXG5cdFx0XHRcdGlmIChjb25maWcucmVhY2hlc0ludG9PdXRlckNvbnRleHQgfHwgY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xyXG5cdFx0XHRcdFx0YWx0cy5zZXQoY29uZmlnLmFsdCk7XHJcblx0XHRcdFx0XHRtYXhBbHQgPSBNYXRoLm1heChtYXhBbHQsIGNvbmZpZy5hbHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3dpdGNoIChhbHRzLmNhcmRpbmFsaXR5KCkpIHtcclxuXHRcdFx0Y2FzZSAwOlxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdHJldHVybiBhbHRzLm5leHRTZXRCaXQoMCk7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGlmICghcHJldmlvdXMuczAuY29uZmlncy5oYXNTZW1hbnRpY0NvbnRleHQpIHtcclxuXHRcdFx0XHRcdC8vIGNvbmZpZ3MgZG9lc24ndCBjb250YWluIGFueSBwcmVkaWNhdGVzLCBzbyB0aGUgcHJlZGljYXRlXHJcblx0XHRcdFx0XHQvLyBmaWx0ZXJpbmcgY29kZSBiZWxvdyB3b3VsZCBiZSBwb2ludGxlc3NcclxuXHRcdFx0XHRcdHJldHVybiBhbHRzLm5leHRTZXRCaXQoMCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvKlxyXG5cdFx0XHRcdCAqIFRyeSB0byBmaW5kIGEgY29uZmlndXJhdGlvbiBzZXQgdGhhdCBub3Qgb25seSBkaXBwZWQgaW50byB0aGUgb3V0ZXJcclxuXHRcdFx0XHQgKiBjb250ZXh0LCBidXQgYWxzbyBpc24ndCBlbGltaW5hdGVkIGJ5IGEgcHJlZGljYXRlLlxyXG5cdFx0XHRcdCAqL1xyXG5cdFx0XHRcdGxldCBmaWx0ZXJlZENvbmZpZ3M6IEFUTkNvbmZpZ1NldCA9IG5ldyBBVE5Db25maWdTZXQoKTtcclxuXHRcdFx0XHRmb3IgKGxldCBjb25maWcgb2YgcHJldmlvdXMuczAuY29uZmlncykge1xyXG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dCB8fCBjb25maWcuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XHJcblx0XHRcdFx0XHRcdGZpbHRlcmVkQ29uZmlncy5hZGQoY29uZmlnKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8qIFRoZSBmb2xsb3dpbmcgY29kZSBibG9ja3MgYXJlIGFkYXB0ZWQgZnJvbSBwcmVkaWNhdGVERkFTdGF0ZSB3aXRoXHJcblx0XHRcdFx0ICogdGhlIGZvbGxvd2luZyBrZXkgY2hhbmdlcy5cclxuXHRcdFx0XHQgKlxyXG5cdFx0XHRcdCAqICAxLiBUaGUgY29kZSBvcGVyYXRlcyBvbiBhbiBBVE5Db25maWdTZXQgcmF0aGVyIHRoYW4gYSBERkFTdGF0ZS5cclxuXHRcdFx0XHQgKiAgMi4gUHJlZGljYXRlcyBhcmUgY29sbGVjdGVkIGZvciBhbGwgYWx0ZXJuYXRpdmVzIHJlcHJlc2VudGVkIGluXHJcblx0XHRcdFx0ICogICAgIGZpbHRlcmVkQ29uZmlncywgcmF0aGVyIHRoYW4gcmVzdHJpY3RpbmcgdGhlIGV2YWx1YXRpb24gdG9cclxuXHRcdFx0XHQgKiAgICAgY29uZmxpY3RpbmcgYW5kL29yIHVuaXF1ZSBjb25maWd1cmF0aW9ucy5cclxuXHRcdFx0XHQgKi9cclxuXHRcdFx0XHRsZXQgYWx0VG9QcmVkOiBTZW1hbnRpY0NvbnRleHRbXSB8IHVuZGVmaW5lZCA9IHRoaXMuZ2V0UHJlZHNGb3JBbWJpZ0FsdHMoYWx0cywgZmlsdGVyZWRDb25maWdzLCBtYXhBbHQpO1xyXG5cdFx0XHRcdGlmIChhbHRUb1ByZWQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0bGV0IHByZWRpY2F0ZXM6IERGQVN0YXRlLlByZWRQcmVkaWN0aW9uW10gfCB1bmRlZmluZWQgPSB0aGlzLmdldFByZWRpY2F0ZVByZWRpY3Rpb25zKGFsdHMsIGFsdFRvUHJlZCk7XHJcblx0XHRcdFx0XHRpZiAocHJlZGljYXRlcyAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdGxldCBzdG9wSW5kZXg6IG51bWJlciA9IGlucHV0LmluZGV4O1xyXG5cdFx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRcdGlucHV0LnNlZWsoc3RhcnRJbmRleCk7XHJcblx0XHRcdFx0XHRcdFx0bGV0IGZpbHRlcmVkQWx0czogQml0U2V0ID0gdGhpcy5ldmFsU2VtYW50aWNDb250ZXh0KHByZWRpY2F0ZXMsIHByZXZpb3VzLm91dGVyQ29udGV4dCwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0XHRcdGlmICghZmlsdGVyZWRBbHRzLmlzRW1wdHkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmaWx0ZXJlZEFsdHMubmV4dFNldEJpdCgwKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0ZmluYWxseSB7XHJcblx0XHRcdFx0XHRcdFx0aW5wdXQuc2VlayhzdG9wSW5kZXgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gYWx0cy5uZXh0U2V0Qml0KDApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhyb3cgdGhpcy5ub1ZpYWJsZUFsdChpbnB1dCwgcHJldmlvdXMub3V0ZXJDb250ZXh0LCBwcmV2aW91cy5zMC5jb25maWdzLCBzdGFydEluZGV4KTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBjb21wdXRlUmVhY2hTZXQoZGZhOiBERkEsIHByZXZpb3VzOiBTaW11bGF0b3JTdGF0ZSwgdDogbnVtYmVyLCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBTaW11bGF0b3JTdGF0ZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRsZXQgdXNlQ29udGV4dDogYm9vbGVhbiA9IHByZXZpb3VzLnVzZUNvbnRleHQ7XHJcblx0XHRsZXQgcmVtYWluaW5nR2xvYmFsQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQgPSBwcmV2aW91cy5yZW1haW5pbmdPdXRlckNvbnRleHQ7XHJcblxyXG5cdFx0bGV0IHM6IERGQVN0YXRlID0gcHJldmlvdXMuczA7XHJcblx0XHRpZiAodXNlQ29udGV4dCkge1xyXG5cdFx0XHR3aGlsZSAocy5pc0NvbnRleHRTeW1ib2wodCkpIHtcclxuXHRcdFx0XHRsZXQgbmV4dDogREZBU3RhdGUgfCB1bmRlZmluZWQ7XHJcblx0XHRcdFx0aWYgKHJlbWFpbmluZ0dsb2JhbENvbnRleHQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHRoaXMuc2tpcFRhaWxDYWxscyhyZW1haW5pbmdHbG9iYWxDb250ZXh0KTtcclxuXHRcdFx0XHRcdG5leHQgPSBzLmdldENvbnRleHRUYXJnZXQodGhpcy5nZXRSZXR1cm5TdGF0ZShyZW1haW5pbmdHbG9iYWxDb250ZXh0KSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAobmV4dCA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGFzc2VydChyZW1haW5pbmdHbG9iYWxDb250ZXh0ICE9IG51bGwpO1xyXG5cdFx0XHRcdHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSByZW1haW5pbmdHbG9iYWxDb250ZXh0LnBhcmVudDtcclxuXHRcdFx0XHRzID0gbmV4dDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGFzc2VydCghdGhpcy5pc0FjY2VwdFN0YXRlKHMsIHVzZUNvbnRleHQpKTtcclxuXHRcdGlmICh0aGlzLmlzQWNjZXB0U3RhdGUocywgdXNlQ29udGV4dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBTaW11bGF0b3JTdGF0ZShwcmV2aW91cy5vdXRlckNvbnRleHQsIHMsIHVzZUNvbnRleHQsIHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBzMDogREZBU3RhdGUgPSBzO1xyXG5cclxuXHRcdGxldCB0YXJnZXQ6IERGQVN0YXRlIHwgdW5kZWZpbmVkID0gdGhpcy5nZXRFeGlzdGluZ1RhcmdldFN0YXRlKHMwLCB0KTtcclxuXHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xyXG5cdFx0XHRsZXQgcmVzdWx0OiBbREZBU3RhdGUsIFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkXSA9IHRoaXMuY29tcHV0ZVRhcmdldFN0YXRlKGRmYSwgczAsIHJlbWFpbmluZ0dsb2JhbENvbnRleHQsIHQsIHVzZUNvbnRleHQsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdHRhcmdldCA9IHJlc3VsdFswXTtcclxuXHRcdFx0cmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHJlc3VsdFsxXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGFyZ2V0ID09PSBBVE5TaW11bGF0b3IuRVJST1IpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRhc3NlcnQoIXVzZUNvbnRleHQgfHwgIXRhcmdldC5jb25maWdzLmRpcHNJbnRvT3V0ZXJDb250ZXh0KTtcclxuXHRcdHJldHVybiBuZXcgU2ltdWxhdG9yU3RhdGUocHJldmlvdXMub3V0ZXJDb250ZXh0LCB0YXJnZXQsIHVzZUNvbnRleHQsIHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuIGV4aXN0aW5nIHRhcmdldCBzdGF0ZSBmb3IgYW4gZWRnZSBpbiB0aGUgREZBLiBJZiB0aGUgdGFyZ2V0IHN0YXRlXHJcblx0ICogZm9yIHRoZSBlZGdlIGhhcyBub3QgeWV0IGJlZW4gY29tcHV0ZWQgb3IgaXMgb3RoZXJ3aXNlIG5vdCBhdmFpbGFibGUsXHJcblx0ICogdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBzIFRoZSBjdXJyZW50IERGQSBzdGF0ZVxyXG5cdCAqIEBwYXJhbSB0IFRoZSBuZXh0IGlucHV0IHN5bWJvbFxyXG5cdCAqIEByZXR1cm5zIFRoZSBleGlzdGluZyB0YXJnZXQgREZBIHN0YXRlIGZvciB0aGUgZ2l2ZW4gaW5wdXQgc3ltYm9sXHJcblx0ICogYHRgLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgdGFyZ2V0IHN0YXRlIGZvciB0aGlzIGVkZ2UgaXMgbm90XHJcblx0ICogYWxyZWFkeSBjYWNoZWRcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZShATm90TnVsbCBzOiBERkFTdGF0ZSwgdDogbnVtYmVyKTogREZBU3RhdGUgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHMuZ2V0VGFyZ2V0KHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29tcHV0ZSBhIHRhcmdldCBzdGF0ZSBmb3IgYW4gZWRnZSBpbiB0aGUgREZBLCBhbmQgYXR0ZW1wdCB0byBhZGQgdGhlXHJcblx0ICogY29tcHV0ZWQgc3RhdGUgYW5kIGNvcnJlc3BvbmRpbmcgZWRnZSB0byB0aGUgREZBLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGRmYVxyXG5cdCAqIEBwYXJhbSBzIFRoZSBjdXJyZW50IERGQSBzdGF0ZVxyXG5cdCAqIEBwYXJhbSByZW1haW5pbmdHbG9iYWxDb250ZXh0XHJcblx0ICogQHBhcmFtIHQgVGhlIG5leHQgaW5wdXQgc3ltYm9sXHJcblx0ICogQHBhcmFtIHVzZUNvbnRleHRcclxuXHQgKiBAcGFyYW0gY29udGV4dENhY2hlXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgdGFyZ2V0IERGQSBzdGF0ZSBmb3IgdGhlIGdpdmVuIGlucHV0IHN5bWJvbFxyXG5cdCAqIGB0YC4gSWYgYHRgIGRvZXMgbm90IGxlYWQgdG8gYSB2YWxpZCBERkEgc3RhdGUsIHRoaXMgbWV0aG9kXHJcblx0ICogcmV0dXJucyB7QGxpbmsgI0VSUk9SfS5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBjb21wdXRlVGFyZ2V0U3RhdGUoQE5vdE51bGwgZGZhOiBERkEsIEBOb3ROdWxsIHM6IERGQVN0YXRlLCByZW1haW5pbmdHbG9iYWxDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgdDogbnVtYmVyLCB1c2VDb250ZXh0OiBib29sZWFuLCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBbREZBU3RhdGUsIFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkXSB7XHJcblx0XHRsZXQgY2xvc3VyZUNvbmZpZ3M6IEFUTkNvbmZpZ1tdID0gcy5jb25maWdzLnRvQXJyYXkoKTtcclxuXHRcdGxldCBjb250ZXh0RWxlbWVudHM6IEludGVnZXJMaXN0IHwgdW5kZWZpbmVkO1xyXG5cdFx0bGV0IHJlYWNoOiBBVE5Db25maWdTZXQgPSBuZXcgQVROQ29uZmlnU2V0KCk7XHJcblx0XHRsZXQgc3RlcEludG9HbG9iYWw6IGJvb2xlYW47XHJcblx0XHRkbyB7XHJcblx0XHRcdGxldCBoYXNNb3JlQ29udGV4dDogYm9vbGVhbiA9ICF1c2VDb250ZXh0IHx8IHJlbWFpbmluZ0dsb2JhbENvbnRleHQgIT0gbnVsbDtcclxuXHRcdFx0aWYgKCFoYXNNb3JlQ29udGV4dCkge1xyXG5cdFx0XHRcdHJlYWNoLmlzT3V0ZXJtb3N0Q29uZmlnU2V0ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHJlYWNoSW50ZXJtZWRpYXRlOiBBVE5Db25maWdTZXQgPSBuZXcgQVROQ29uZmlnU2V0KCk7XHJcblxyXG5cdFx0XHQvKiBDb25maWd1cmF0aW9ucyBhbHJlYWR5IGluIGEgcnVsZSBzdG9wIHN0YXRlIGluZGljYXRlIHJlYWNoaW5nIHRoZSBlbmRcclxuXHRcdFx0ICogb2YgdGhlIGRlY2lzaW9uIHJ1bGUgKGxvY2FsIGNvbnRleHQpIG9yIGVuZCBvZiB0aGUgc3RhcnQgcnVsZSAoZnVsbFxyXG5cdFx0XHQgKiBjb250ZXh0KS4gT25jZSByZWFjaGVkLCB0aGVzZSBjb25maWd1cmF0aW9ucyBhcmUgbmV2ZXIgdXBkYXRlZCBieSBhXHJcblx0XHRcdCAqIGNsb3N1cmUgb3BlcmF0aW9uLCBzbyB0aGV5IGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkgZm9yIHRoZSBwZXJmb3JtYW5jZVxyXG5cdFx0XHQgKiBhZHZhbnRhZ2Ugb2YgaGF2aW5nIGEgc21hbGxlciBpbnRlcm1lZGlhdGUgc2V0IHdoZW4gY2FsbGluZyBjbG9zdXJlLlxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiBGb3IgZnVsbC1jb250ZXh0IHJlYWNoIG9wZXJhdGlvbnMsIHNlcGFyYXRlIGhhbmRsaW5nIGlzIHJlcXVpcmVkIHRvXHJcblx0XHRcdCAqIGVuc3VyZSB0aGF0IHRoZSBhbHRlcm5hdGl2ZSBtYXRjaGluZyB0aGUgbG9uZ2VzdCBvdmVyYWxsIHNlcXVlbmNlIGlzXHJcblx0XHRcdCAqIGNob3NlbiB3aGVuIG11bHRpcGxlIHN1Y2ggY29uZmlndXJhdGlvbnMgY2FuIG1hdGNoIHRoZSBpbnB1dC5cclxuXHRcdFx0ICovXHJcblx0XHRcdGxldCBza2lwcGVkU3RvcFN0YXRlczogQVROQ29uZmlnW10gfCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBjIG9mIGNsb3N1cmVDb25maWdzKSB7XHJcblx0XHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJ0ZXN0aW5nIFwiICsgdGhpcy5nZXRUb2tlbk5hbWUodCkgKyBcIiBhdCBcIiArIGMudG9TdHJpbmcoKSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoYy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcclxuXHRcdFx0XHRcdGFzc2VydChjLmNvbnRleHQuaXNFbXB0eSk7XHJcblx0XHRcdFx0XHRpZiAodXNlQ29udGV4dCAmJiAhYy5yZWFjaGVzSW50b091dGVyQ29udGV4dCB8fCB0ID09PSBJbnRTdHJlYW0uRU9GKSB7XHJcblx0XHRcdFx0XHRcdGlmIChza2lwcGVkU3RvcFN0YXRlcyA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0c2tpcHBlZFN0b3BTdGF0ZXMgPSBbXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0c2tpcHBlZFN0b3BTdGF0ZXMucHVzaChjKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBuOiBudW1iZXIgPSBjLnN0YXRlLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnM7XHJcblx0XHRcdFx0Zm9yIChsZXQgdGkgPSAwOyB0aSA8IG47IHRpKyspIHsgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBvcHRpbWl6ZWQgdHJhbnNpdGlvblxyXG5cdFx0XHRcdFx0bGV0IHRyYW5zOiBUcmFuc2l0aW9uID0gYy5zdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKHRpKTtcclxuXHRcdFx0XHRcdGxldCB0YXJnZXQ6IEFUTlN0YXRlIHwgdW5kZWZpbmVkID0gdGhpcy5nZXRSZWFjaGFibGVUYXJnZXQoYywgdHJhbnMsIHQpO1xyXG5cdFx0XHRcdFx0aWYgKHRhcmdldCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHJlYWNoSW50ZXJtZWRpYXRlLmFkZChjLnRyYW5zZm9ybSh0YXJnZXQsIGZhbHNlKSwgY29udGV4dENhY2hlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8qIFRoaXMgYmxvY2sgb3B0aW1pemVzIHRoZSByZWFjaCBvcGVyYXRpb24gZm9yIGludGVybWVkaWF0ZSBzZXRzIHdoaWNoXHJcblx0XHRcdCAqIHRyaXZpYWxseSBpbmRpY2F0ZSBhIHRlcm1pbmF0aW9uIHN0YXRlIGZvciB0aGUgb3ZlcmFsbFxyXG5cdFx0XHQgKiBhZGFwdGl2ZVByZWRpY3Qgb3BlcmF0aW9uLlxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiBUaGUgY29uZGl0aW9ucyBhc3N1bWUgdGhhdCBpbnRlcm1lZGlhdGVcclxuXHRcdFx0ICogY29udGFpbnMgYWxsIGNvbmZpZ3VyYXRpb25zIHJlbGV2YW50IHRvIHRoZSByZWFjaCBzZXQsIGJ1dCB0aGlzXHJcblx0XHRcdCAqIGNvbmRpdGlvbiBpcyBub3QgdHJ1ZSB3aGVuIG9uZSBvciBtb3JlIGNvbmZpZ3VyYXRpb25zIGhhdmUgYmVlblxyXG5cdFx0XHQgKiB3aXRoaGVsZCBpbiBza2lwcGVkU3RvcFN0YXRlcywgb3Igd2hlbiB0aGUgY3VycmVudCBzeW1ib2wgaXMgRU9GLlxyXG5cdFx0XHQgKi9cclxuXHRcdFx0aWYgKHRoaXMub3B0aW1pemVfdW5pcXVlX2Nsb3N1cmUgJiYgc2tpcHBlZFN0b3BTdGF0ZXMgPT0gbnVsbCAmJiB0ICE9PSBUb2tlbi5FT0YgJiYgcmVhY2hJbnRlcm1lZGlhdGUudW5pcXVlQWx0ICE9PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcblx0XHRcdFx0cmVhY2hJbnRlcm1lZGlhdGUuaXNPdXRlcm1vc3RDb25maWdTZXQgPSByZWFjaC5pc091dGVybW9zdENvbmZpZ1NldDtcclxuXHRcdFx0XHRyZWFjaCA9IHJlYWNoSW50ZXJtZWRpYXRlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKiBJZiB0aGUgcmVhY2ggc2V0IGNvdWxkIG5vdCBiZSB0cml2aWFsbHkgZGV0ZXJtaW5lZCwgcGVyZm9ybSBhIGNsb3N1cmVcclxuXHRcdFx0ICogb3BlcmF0aW9uIG9uIHRoZSBpbnRlcm1lZGlhdGUgc2V0IHRvIGNvbXB1dGUgaXRzIGluaXRpYWwgdmFsdWUuXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRsZXQgY29sbGVjdFByZWRpY2F0ZXM6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdFx0bGV0IHRyZWF0RW9mQXNFcHNpbG9uOiBib29sZWFuID0gdCA9PT0gVG9rZW4uRU9GO1xyXG5cdFx0XHR0aGlzLmNsb3N1cmUocmVhY2hJbnRlcm1lZGlhdGUsIHJlYWNoLCBjb2xsZWN0UHJlZGljYXRlcywgaGFzTW9yZUNvbnRleHQsIGNvbnRleHRDYWNoZSwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xyXG5cdFx0XHRzdGVwSW50b0dsb2JhbCA9IHJlYWNoLmRpcHNJbnRvT3V0ZXJDb250ZXh0O1xyXG5cclxuXHRcdFx0aWYgKHQgPT09IEludFN0cmVhbS5FT0YpIHtcclxuXHRcdFx0XHQvKiBBZnRlciBjb25zdW1pbmcgRU9GIG5vIGFkZGl0aW9uYWwgaW5wdXQgaXMgcG9zc2libGUsIHNvIHdlIGFyZVxyXG5cdFx0XHRcdCAqIG9ubHkgaW50ZXJlc3RlZCBpbiBjb25maWd1cmF0aW9ucyB3aGljaCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlXHJcblx0XHRcdFx0ICogZGVjaXNpb24gcnVsZSAobG9jYWwgY29udGV4dCkgb3IgZW5kIG9mIHRoZSBzdGFydCBydWxlIChmdWxsXHJcblx0XHRcdFx0ICogY29udGV4dCkuIFVwZGF0ZSByZWFjaCB0byBjb250YWluIG9ubHkgdGhlc2UgY29uZmlndXJhdGlvbnMuIFRoaXNcclxuXHRcdFx0XHQgKiBoYW5kbGVzIGJvdGggZXhwbGljaXQgRU9GIHRyYW5zaXRpb25zIGluIHRoZSBncmFtbWFyIGFuZCBpbXBsaWNpdFxyXG5cdFx0XHRcdCAqIEVPRiB0cmFuc2l0aW9ucyBmb2xsb3dpbmcgdGhlIGVuZCBvZiB0aGUgZGVjaXNpb24gb3Igc3RhcnQgcnVsZS5cclxuXHRcdFx0XHQgKlxyXG5cdFx0XHRcdCAqIFRoaXMgaXMgaGFuZGxlZCBiZWZvcmUgdGhlIGNvbmZpZ3VyYXRpb25zIGluIHNraXBwZWRTdG9wU3RhdGVzLFxyXG5cdFx0XHRcdCAqIGJlY2F1c2UgYW55IGNvbmZpZ3VyYXRpb25zIHBvdGVudGlhbGx5IGFkZGVkIGZyb20gdGhhdCBsaXN0IGFyZVxyXG5cdFx0XHRcdCAqIGFscmVhZHkgZ3VhcmFudGVlZCB0byBtZWV0IHRoaXMgY29uZGl0aW9uIHdoZXRoZXIgb3Igbm90IGl0J3NcclxuXHRcdFx0XHQgKiByZXF1aXJlZC5cclxuXHRcdFx0XHQgKi9cclxuXHRcdFx0XHRyZWFjaCA9IHRoaXMucmVtb3ZlQWxsQ29uZmlnc05vdEluUnVsZVN0b3BTdGF0ZShyZWFjaCwgY29udGV4dENhY2hlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0LyogSWYgc2tpcHBlZFN0b3BTdGF0ZXMgaXMgbm90IHVuZGVmaW5lZCwgdGhlbiBpdCBjb250YWlucyBhdCBsZWFzdCBvbmVcclxuXHRcdFx0ICogY29uZmlndXJhdGlvbi4gRm9yIGZ1bGwtY29udGV4dCByZWFjaCBvcGVyYXRpb25zLCB0aGVzZVxyXG5cdFx0XHQgKiBjb25maWd1cmF0aW9ucyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHN0YXJ0IHJ1bGUsIGluIHdoaWNoIGNhc2Ugd2VcclxuXHRcdFx0ICogb25seSBhZGQgdGhlbSBiYWNrIHRvIHJlYWNoIGlmIG5vIGNvbmZpZ3VyYXRpb24gZHVyaW5nIHRoZSBjdXJyZW50XHJcblx0XHRcdCAqIGNsb3N1cmUgb3BlcmF0aW9uIHJlYWNoZWQgc3VjaCBhIHN0YXRlLiBUaGlzIGVuc3VyZXMgYWRhcHRpdmVQcmVkaWN0XHJcblx0XHRcdCAqIGNob29zZXMgYW4gYWx0ZXJuYXRpdmUgbWF0Y2hpbmcgdGhlIGxvbmdlc3Qgb3ZlcmFsbCBzZXF1ZW5jZSB3aGVuXHJcblx0XHRcdCAqIG11bHRpcGxlIGFsdGVybmF0aXZlcyBhcmUgdmlhYmxlLlxyXG5cdFx0XHQgKi9cclxuXHRcdFx0aWYgKHNraXBwZWRTdG9wU3RhdGVzICE9IG51bGwgJiYgKCF1c2VDb250ZXh0IHx8ICFQcmVkaWN0aW9uTW9kZS5oYXNDb25maWdJblJ1bGVTdG9wU3RhdGUocmVhY2gpKSkge1xyXG5cdFx0XHRcdGFzc2VydChza2lwcGVkU3RvcFN0YXRlcy5sZW5ndGggPiAwKTtcclxuXHRcdFx0XHRmb3IgKGxldCBjIG9mIHNraXBwZWRTdG9wU3RhdGVzKSB7XHJcblx0XHRcdFx0XHRyZWFjaC5hZGQoYywgY29udGV4dENhY2hlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh1c2VDb250ZXh0ICYmIHN0ZXBJbnRvR2xvYmFsKSB7XHJcblx0XHRcdFx0cmVhY2guY2xlYXIoKTtcclxuXHJcblx0XHRcdFx0Ly8gV2Uga25vdyByZW1haW5pbmdHbG9iYWxDb250ZXh0IGlzIG5vdCB1bmRlZmluZWQgYXQgdGhpcyBwb2ludCAod2h5PylcclxuXHRcdFx0XHRyZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gcmVtYWluaW5nR2xvYmFsQ29udGV4dCBhcyBQYXJzZXJSdWxlQ29udGV4dDtcclxuXHJcblx0XHRcdFx0cmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHRoaXMuc2tpcFRhaWxDYWxscyhyZW1haW5pbmdHbG9iYWxDb250ZXh0KTtcclxuXHRcdFx0XHRsZXQgbmV4dENvbnRleHRFbGVtZW50OiBudW1iZXIgPSB0aGlzLmdldFJldHVyblN0YXRlKHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xyXG5cdFx0XHRcdGlmIChjb250ZXh0RWxlbWVudHMgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y29udGV4dEVsZW1lbnRzID0gbmV3IEludGVnZXJMaXN0KCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAocmVtYWluaW5nR2xvYmFsQ29udGV4dC5pc0VtcHR5KSB7XHJcblx0XHRcdFx0XHRyZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gcmVtYWluaW5nR2xvYmFsQ29udGV4dC5wYXJlbnQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb250ZXh0RWxlbWVudHMuYWRkKG5leHRDb250ZXh0RWxlbWVudCk7XHJcblx0XHRcdFx0aWYgKG5leHRDb250ZXh0RWxlbWVudCAhPT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVkpIHtcclxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2xvc3VyZUNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0Y2xvc3VyZUNvbmZpZ3NbaV0gPSBjbG9zdXJlQ29uZmlnc1tpXS5hcHBlbmRDb250ZXh0KG5leHRDb250ZXh0RWxlbWVudCwgY29udGV4dENhY2hlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gd2hpbGUgKHVzZUNvbnRleHQgJiYgc3RlcEludG9HbG9iYWwpO1xyXG5cclxuXHRcdGlmIChyZWFjaC5pc0VtcHR5KSB7XHJcblx0XHRcdHRoaXMuc2V0REZBRWRnZShzLCB0LCBBVE5TaW11bGF0b3IuRVJST1IpO1xyXG5cdFx0XHRyZXR1cm4gW0FUTlNpbXVsYXRvci5FUlJPUiwgcmVtYWluaW5nR2xvYmFsQ29udGV4dF07XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJlc3VsdDogREZBU3RhdGUgPSB0aGlzLmFkZERGQUVkZ2UoZGZhLCBzLCB0LCBjb250ZXh0RWxlbWVudHMsIHJlYWNoLCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0cmV0dXJuIFtyZXN1bHQsIHJlbWFpbmluZ0dsb2JhbENvbnRleHRdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIGEgY29uZmlndXJhdGlvbiBzZXQgY29udGFpbmluZyBvbmx5IHRoZSBjb25maWd1cmF0aW9ucyBmcm9tXHJcblx0ICogYGNvbmZpZ3NgIHdoaWNoIGFyZSBpbiBhIHtAbGluayBSdWxlU3RvcFN0YXRlfS4gSWYgYWxsXHJcblx0ICogY29uZmlndXJhdGlvbnMgaW4gYGNvbmZpZ3NgIGFyZSBhbHJlYWR5IGluIGEgcnVsZSBzdG9wIHN0YXRlLCB0aGlzXHJcblx0ICogbWV0aG9kIHNpbXBseSByZXR1cm5zIGBjb25maWdzYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBjb25maWdzIHRoZSBjb25maWd1cmF0aW9uIHNldCB0byB1cGRhdGVcclxuXHQgKiBAcGFyYW0gY29udGV4dENhY2hlIHRoZSB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHR9IGNhY2hlXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBgY29uZmlnc2AgaWYgYWxsIGNvbmZpZ3VyYXRpb25zIGluIGBjb25maWdzYCBhcmUgaW4gYVxyXG5cdCAqIHJ1bGUgc3RvcCBzdGF0ZSwgb3RoZXJ3aXNlIHJldHVybiBhIG5ldyBjb25maWd1cmF0aW9uIHNldCBjb250YWluaW5nIG9ubHlcclxuXHQgKiB0aGUgY29uZmlndXJhdGlvbnMgZnJvbSBgY29uZmlnc2Agd2hpY2ggYXJlIGluIGEgcnVsZSBzdG9wIHN0YXRlXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgcmVtb3ZlQWxsQ29uZmlnc05vdEluUnVsZVN0b3BTdGF0ZShATm90TnVsbCBjb25maWdzOiBBVE5Db25maWdTZXQsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IEFUTkNvbmZpZ1NldCB7XHJcblx0XHRpZiAoUHJlZGljdGlvbk1vZGUuYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXMoY29uZmlncykpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZ3M7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJlc3VsdDogQVROQ29uZmlnU2V0ID0gbmV3IEFUTkNvbmZpZ1NldCgpO1xyXG5cdFx0Zm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpIHtcclxuXHRcdFx0aWYgKCEoY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmVzdWx0LmFkZChjb25maWcsIGNvbnRleHRDYWNoZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGNvbXB1dGVTdGFydFN0YXRlKFxyXG5cdFx0ZGZhOiBERkEsXHJcblx0XHRnbG9iYWxDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCxcclxuXHRcdHVzZUNvbnRleHQ6IGJvb2xlYW4pOiBTaW11bGF0b3JTdGF0ZSB7XHJcblx0XHRsZXQgczA6IERGQVN0YXRlIHwgdW5kZWZpbmVkID1cclxuXHRcdFx0ZGZhLmlzUHJlY2VkZW5jZURmYSA/IGRmYS5nZXRQcmVjZWRlbmNlU3RhcnRTdGF0ZSh0aGlzLl9wYXJzZXIucHJlY2VkZW5jZSwgdXNlQ29udGV4dCkgOlxyXG5cdFx0XHRcdHVzZUNvbnRleHQgPyBkZmEuczBmdWxsIDpcclxuXHRcdFx0XHRcdGRmYS5zMDtcclxuXHJcblx0XHRpZiAoczAgIT0gbnVsbCkge1xyXG5cdFx0XHRpZiAoIXVzZUNvbnRleHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFNpbXVsYXRvclN0YXRlKGdsb2JhbENvbnRleHQsIHMwLCB1c2VDb250ZXh0LCBnbG9iYWxDb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0czAuc2V0Q29udGV4dFNlbnNpdGl2ZSh0aGlzLmF0bik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGRlY2lzaW9uOiBudW1iZXIgPSBkZmEuZGVjaXNpb247XHJcblx0XHQvLyBATm90TnVsbFxyXG5cdFx0bGV0IHA6IEFUTlN0YXRlID0gZGZhLmF0blN0YXJ0U3RhdGU7XHJcblxyXG5cdFx0bGV0IHByZXZpb3VzQ29udGV4dDogbnVtYmVyID0gMDtcclxuXHRcdGxldCByZW1haW5pbmdHbG9iYWxDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCA9IGdsb2JhbENvbnRleHQ7XHJcblx0XHRsZXQgaW5pdGlhbENvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0ID0gdXNlQ29udGV4dCA/IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTEwgOiBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9MT0NBTDsgLy8gYWx3YXlzIGF0IGxlYXN0IHRoZSBpbXBsaWNpdCBjYWxsIHRvIHN0YXJ0IHJ1bGVcclxuXHRcdGxldCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUgPSBuZXcgUHJlZGljdGlvbkNvbnRleHRDYWNoZSgpO1xyXG5cdFx0aWYgKHVzZUNvbnRleHQpIHtcclxuXHRcdFx0aWYgKCF0aGlzLmVuYWJsZV9nbG9iYWxfY29udGV4dF9kZmEpIHtcclxuXHRcdFx0XHR3aGlsZSAocmVtYWluaW5nR2xvYmFsQ29udGV4dCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRpZiAocmVtYWluaW5nR2xvYmFsQ29udGV4dC5pc0VtcHR5KSB7XHJcblx0XHRcdFx0XHRcdHByZXZpb3VzQ29udGV4dCA9IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZO1xyXG5cdFx0XHRcdFx0XHRyZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdHByZXZpb3VzQ29udGV4dCA9IHRoaXMuZ2V0UmV0dXJuU3RhdGUocmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XHJcblx0XHRcdFx0XHRcdGluaXRpYWxDb250ZXh0ID0gaW5pdGlhbENvbnRleHQuYXBwZW5kU2luZ2xlQ29udGV4dChwcmV2aW91c0NvbnRleHQsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0XHRcdHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSByZW1haW5pbmdHbG9iYWxDb250ZXh0LnBhcmVudDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHdoaWxlIChzMCAhPSBudWxsICYmIHMwLmlzQ29udGV4dFNlbnNpdGl2ZSAmJiByZW1haW5pbmdHbG9iYWxDb250ZXh0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRsZXQgbmV4dDogREZBU3RhdGUgfCB1bmRlZmluZWQ7XHJcblx0XHRcdFx0cmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHRoaXMuc2tpcFRhaWxDYWxscyhyZW1haW5pbmdHbG9iYWxDb250ZXh0KTtcclxuXHRcdFx0XHRpZiAocmVtYWluaW5nR2xvYmFsQ29udGV4dC5pc0VtcHR5KSB7XHJcblx0XHRcdFx0XHRuZXh0ID0gczAuZ2V0Q29udGV4dFRhcmdldChQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSk7XHJcblx0XHRcdFx0XHRwcmV2aW91c0NvbnRleHQgPSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWTtcclxuXHRcdFx0XHRcdHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0cHJldmlvdXNDb250ZXh0ID0gdGhpcy5nZXRSZXR1cm5TdGF0ZShyZW1haW5pbmdHbG9iYWxDb250ZXh0KTtcclxuXHRcdFx0XHRcdG5leHQgPSBzMC5nZXRDb250ZXh0VGFyZ2V0KHByZXZpb3VzQ29udGV4dCk7XHJcblx0XHRcdFx0XHRpbml0aWFsQ29udGV4dCA9IGluaXRpYWxDb250ZXh0LmFwcGVuZFNpbmdsZUNvbnRleHQocHJldmlvdXNDb250ZXh0LCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdFx0cmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHJlbWFpbmluZ0dsb2JhbENvbnRleHQucGFyZW50O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKG5leHQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzMCA9IG5leHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoczAgIT0gbnVsbCAmJiAhczAuaXNDb250ZXh0U2Vuc2l0aXZlKSB7XHJcblx0XHRcdHJldHVybiBuZXcgU2ltdWxhdG9yU3RhdGUoZ2xvYmFsQ29udGV4dCwgczAsIHVzZUNvbnRleHQsIHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjb25maWdzOiBBVE5Db25maWdTZXQgPSBuZXcgQVROQ29uZmlnU2V0KCk7XHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRsZXQgcmVhY2hJbnRlcm1lZGlhdGU6IEFUTkNvbmZpZ1NldCA9IG5ldyBBVE5Db25maWdTZXQoKTtcclxuXHRcdFx0bGV0IG46IG51bWJlciA9IHAubnVtYmVyT2ZUcmFuc2l0aW9ucztcclxuXHRcdFx0Zm9yIChsZXQgdGkgPSAwOyB0aSA8IG47IHRpKyspIHtcclxuXHRcdFx0XHQvLyBmb3IgZWFjaCB0cmFuc2l0aW9uXHJcblx0XHRcdFx0bGV0IHRhcmdldDogQVROU3RhdGUgPSBwLnRyYW5zaXRpb24odGkpLnRhcmdldDtcclxuXHRcdFx0XHRyZWFjaEludGVybWVkaWF0ZS5hZGQoQVROQ29uZmlnLmNyZWF0ZSh0YXJnZXQsIHRpICsgMSwgaW5pdGlhbENvbnRleHQpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGhhc01vcmVDb250ZXh0OiBib29sZWFuID0gcmVtYWluaW5nR2xvYmFsQ29udGV4dCAhPSBudWxsO1xyXG5cdFx0XHRpZiAoIWhhc01vcmVDb250ZXh0KSB7XHJcblx0XHRcdFx0Y29uZmlncy5pc091dGVybW9zdENvbmZpZ1NldCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBjb2xsZWN0UHJlZGljYXRlczogYm9vbGVhbiA9IHRydWU7XHJcblx0XHRcdHRoaXMuY2xvc3VyZShyZWFjaEludGVybWVkaWF0ZSwgY29uZmlncywgY29sbGVjdFByZWRpY2F0ZXMsIGhhc01vcmVDb250ZXh0LCBjb250ZXh0Q2FjaGUsIGZhbHNlKTtcclxuXHRcdFx0bGV0IHN0ZXBJbnRvR2xvYmFsOiBib29sZWFuID0gY29uZmlncy5kaXBzSW50b091dGVyQ29udGV4dDtcclxuXHJcblx0XHRcdGxldCBuZXh0OiBERkFTdGF0ZTtcclxuXHRcdFx0aWYgKHVzZUNvbnRleHQgJiYgIXRoaXMuZW5hYmxlX2dsb2JhbF9jb250ZXh0X2RmYSkge1xyXG5cdFx0XHRcdHMwID0gdGhpcy5hZGRERkFTdGF0ZShkZmEsIGNvbmZpZ3MsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoczAgPT0gbnVsbCkge1xyXG5cdFx0XHRcdGlmICghZGZhLmlzUHJlY2VkZW5jZURmYSkge1xyXG5cdFx0XHRcdFx0bmV4dCA9IHRoaXMuYWRkREZBU3RhdGUoZGZhLCBjb25maWdzLCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdFx0aWYgKHVzZUNvbnRleHQpIHtcclxuXHRcdFx0XHRcdFx0aWYgKCFkZmEuczBmdWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0ZGZhLnMwZnVsbCA9IG5leHQ7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0bmV4dCA9IGRmYS5zMGZ1bGw7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGlmICghZGZhLnMwKSB7XHJcblx0XHRcdFx0XHRcdFx0ZGZhLnMwID0gbmV4dDtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRuZXh0ID0gZGZhLnMwO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0LyogSWYgdGhpcyBpcyBhIHByZWNlZGVuY2UgREZBLCB3ZSB1c2UgYXBwbHlQcmVjZWRlbmNlRmlsdGVyXHJcblx0XHRcdFx0XHQgKiB0byBjb252ZXJ0IHRoZSBjb21wdXRlZCBzdGFydCBzdGF0ZSB0byBhIHByZWNlZGVuY2Ugc3RhcnRcclxuXHRcdFx0XHRcdCAqIHN0YXRlLiBXZSB0aGVuIHVzZSBERkEuc2V0UHJlY2VkZW5jZVN0YXJ0U3RhdGUgdG8gc2V0IHRoZVxyXG5cdFx0XHRcdFx0ICogYXBwcm9wcmlhdGUgc3RhcnQgc3RhdGUgZm9yIHRoZSBwcmVjZWRlbmNlIGxldmVsIHJhdGhlclxyXG5cdFx0XHRcdFx0ICogdGhhbiBzaW1wbHkgc2V0dGluZyBERkEuczAuXHJcblx0XHRcdFx0XHQgKi9cclxuXHRcdFx0XHRcdGNvbmZpZ3MgPSB0aGlzLmFwcGx5UHJlY2VkZW5jZUZpbHRlcihjb25maWdzLCBnbG9iYWxDb250ZXh0LCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdFx0bmV4dCA9IHRoaXMuYWRkREZBU3RhdGUoZGZhLCBjb25maWdzLCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdFx0ZGZhLnNldFByZWNlZGVuY2VTdGFydFN0YXRlKHRoaXMuX3BhcnNlci5wcmVjZWRlbmNlLCB1c2VDb250ZXh0LCBuZXh0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0aWYgKGRmYS5pc1ByZWNlZGVuY2VEZmEpIHtcclxuXHRcdFx0XHRcdGNvbmZpZ3MgPSB0aGlzLmFwcGx5UHJlY2VkZW5jZUZpbHRlcihjb25maWdzLCBnbG9iYWxDb250ZXh0LCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bmV4dCA9IHRoaXMuYWRkREZBU3RhdGUoZGZhLCBjb25maWdzLCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdHMwLnNldENvbnRleHRUYXJnZXQocHJldmlvdXNDb250ZXh0LCBuZXh0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0czAgPSBuZXh0O1xyXG5cclxuXHRcdFx0aWYgKCF1c2VDb250ZXh0IHx8ICFzdGVwSW50b0dsb2JhbCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBUT0RPOiBtYWtlIHN1cmUgaXQgZGlzdGluZ3Vpc2hlcyBlbXB0eSBzdGFjayBzdGF0ZXNcclxuXHRcdFx0bmV4dC5zZXRDb250ZXh0U2Vuc2l0aXZlKHRoaXMuYXRuKTtcclxuXHJcblx0XHRcdC8vIFdlIGtub3cgcmVtYWluaW5nR2xvYmFsQ29udGV4dCBpcyBub3QgdW5kZWZpbmVkIGF0IHRoaXMgcG9pbnQgKHdoeT8pXHJcblx0XHRcdHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSByZW1haW5pbmdHbG9iYWxDb250ZXh0IGFzIFBhcnNlclJ1bGVDb250ZXh0O1xyXG5cclxuXHRcdFx0Y29uZmlncy5jbGVhcigpO1xyXG5cdFx0XHRyZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gdGhpcy5za2lwVGFpbENhbGxzKHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xyXG5cdFx0XHRsZXQgbmV4dENvbnRleHRFbGVtZW50OiBudW1iZXIgPSB0aGlzLmdldFJldHVyblN0YXRlKHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xyXG5cclxuXHRcdFx0aWYgKHJlbWFpbmluZ0dsb2JhbENvbnRleHQuaXNFbXB0eSkge1xyXG5cdFx0XHRcdHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHJlbWFpbmluZ0dsb2JhbENvbnRleHQucGFyZW50O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAobmV4dENvbnRleHRFbGVtZW50ICE9PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSkge1xyXG5cdFx0XHRcdGluaXRpYWxDb250ZXh0ID0gaW5pdGlhbENvbnRleHQuYXBwZW5kU2luZ2xlQ29udGV4dChuZXh0Q29udGV4dEVsZW1lbnQsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHByZXZpb3VzQ29udGV4dCA9IG5leHRDb250ZXh0RWxlbWVudDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IFNpbXVsYXRvclN0YXRlKGdsb2JhbENvbnRleHQsIHMwLCB1c2VDb250ZXh0LCByZW1haW5pbmdHbG9iYWxDb250ZXh0KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgdGhlIHN0YXJ0IHN0YXRlIGNvbXB1dGVkIGJ5XHJcblx0ICoge0BsaW5rICNjb21wdXRlU3RhcnRTdGF0ZX0gdG8gdGhlIHNwZWNpYWwgc3RhcnQgc3RhdGUgdXNlZCBieSBhXHJcblx0ICogcHJlY2VkZW5jZSBERkEgZm9yIGEgcGFydGljdWxhciBwcmVjZWRlbmNlIHZhbHVlLiBUaGUgdHJhbnNmb3JtYXRpb25cclxuXHQgKiBwcm9jZXNzIGFwcGxpZXMgdGhlIGZvbGxvd2luZyBjaGFuZ2VzIHRvIHRoZSBzdGFydCBzdGF0ZSdzIGNvbmZpZ3VyYXRpb25cclxuXHQgKiBzZXQuXHJcblx0ICpcclxuXHQgKiAxLiBFdmFsdWF0ZSB0aGUgcHJlY2VkZW5jZSBwcmVkaWNhdGVzIGZvciBlYWNoIGNvbmZpZ3VyYXRpb24gdXNpbmdcclxuXHQgKiAgICB7QGxpbmsgU2VtYW50aWNDb250ZXh0I2V2YWxQcmVjZWRlbmNlfS5cclxuXHQgKiAxLiBXaGVuIHtAbGluayBBVE5Db25maWcjaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZH0gaXMgYGZhbHNlYCxcclxuXHQgKiAgICByZW1vdmUgYWxsIGNvbmZpZ3VyYXRpb25zIHdoaWNoIHByZWRpY3QgYW4gYWx0ZXJuYXRpdmUgZ3JlYXRlciB0aGFuIDEsXHJcblx0ICogICAgZm9yIHdoaWNoIGFub3RoZXIgY29uZmlndXJhdGlvbiB0aGF0IHByZWRpY3RzIGFsdGVybmF0aXZlIDEgaXMgaW4gdGhlXHJcblx0ICogICAgc2FtZSBBVE4gc3RhdGUgd2l0aCB0aGUgc2FtZSBwcmVkaWN0aW9uIGNvbnRleHQuIFRoaXMgdHJhbnNmb3JtYXRpb24gaXNcclxuXHQgKiAgICB2YWxpZCBmb3IgdGhlIGZvbGxvd2luZyByZWFzb25zOlxyXG5cdCAqXHJcblx0ICogICAgICogVGhlIGNsb3N1cmUgYmxvY2sgY2Fubm90IGNvbnRhaW4gYW55IGVwc2lsb24gdHJhbnNpdGlvbnMgd2hpY2ggYnlwYXNzXHJcblx0ICogICAgICAgdGhlIGJvZHkgb2YgdGhlIGNsb3N1cmUsIHNvIGFsbCBzdGF0ZXMgcmVhY2hhYmxlIHZpYSBhbHRlcm5hdGl2ZSAxIGFyZVxyXG5cdCAqICAgICAgIHBhcnQgb2YgdGhlIHByZWNlZGVuY2UgYWx0ZXJuYXRpdmVzIG9mIHRoZSB0cmFuc2Zvcm1lZCBsZWZ0LXJlY3Vyc2l2ZVxyXG5cdCAqICAgICAgIHJ1bGUuXHJcblx0ICogICAgICogVGhlIFwicHJpbWFyeVwiIHBvcnRpb24gb2YgYSBsZWZ0IHJlY3Vyc2l2ZSBydWxlIGNhbm5vdCBjb250YWluIGFuXHJcblx0ICogICAgICAgZXBzaWxvbiB0cmFuc2l0aW9uLCBzbyB0aGUgb25seSB3YXkgYW4gYWx0ZXJuYXRpdmUgb3RoZXIgdGhhbiAxIGNhbiBleGlzdFxyXG5cdCAqICAgICAgIGluIGEgc3RhdGUgdGhhdCBpcyBhbHNvIHJlYWNoYWJsZSB2aWEgYWx0ZXJuYXRpdmUgMSBpcyBieSBuZXN0aW5nIGNhbGxzXHJcblx0ICogICAgICAgdG8gdGhlIGxlZnQtcmVjdXJzaXZlIHJ1bGUsIHdpdGggdGhlIG91dGVyIGNhbGxzIG5vdCBiZWluZyBhdCB0aGVcclxuXHQgKiAgICAgICBwcmVmZXJyZWQgcHJlY2VkZW5jZSBsZXZlbC4gVGhlXHJcblx0ICogICAgICAge0BsaW5rIEFUTkNvbmZpZyNpc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkfSBwcm9wZXJ0eSBtYXJrcyBBVE5cclxuXHQgKiAgICAgICBjb25maWd1cmF0aW9ucyB3aGljaCBkbyBub3QgbWVldCB0aGlzIGNvbmRpdGlvbiwgYW5kIHRoZXJlZm9yZSBhcmUgbm90XHJcblx0ICogICAgICAgZWxpZ2libGUgZm9yIGVsaW1pbmF0aW9uIGR1cmluZyB0aGUgZmlsdGVyaW5nIHByb2Nlc3MuXHJcblx0ICpcclxuXHQgKiBUaGUgcHJlZGljdGlvbiBjb250ZXh0IG11c3QgYmUgY29uc2lkZXJlZCBieSB0aGlzIGZpbHRlciB0byBhZGRyZXNzXHJcblx0ICogc2l0dWF0aW9ucyBsaWtlIHRoZSBmb2xsb3dpbmcuXHJcblx0ICpcclxuXHQgKiBgYGBhbnRsclxyXG5cdCAqIGdyYW1tYXIgVEE7XHJcblx0ICogcHJvZzogc3RhdGVtZW50KiBFT0Y7XHJcblx0ICogc3RhdGVtZW50OiBsZXR0ZXJBIHwgc3RhdGVtZW50IGxldHRlckEgJ2InIDtcclxuXHQgKiBsZXR0ZXJBOiAnYSc7XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBJZiB0aGUgYWJvdmUgZ3JhbW1hciwgdGhlIEFUTiBzdGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHRva2VuXHJcblx0ICogcmVmZXJlbmNlIGAnYSdgIGluIGBsZXR0ZXJBYCBpcyByZWFjaGFibGUgZnJvbSB0aGUgbGVmdCBlZGdlXHJcblx0ICogb2YgYm90aCB0aGUgcHJpbWFyeSBhbmQgY2xvc3VyZSBibG9ja3Mgb2YgdGhlIGxlZnQtcmVjdXJzaXZlIHJ1bGVcclxuXHQgKiBgc3RhdGVtZW50YC4gVGhlIHByZWRpY3Rpb24gY29udGV4dCBhc3NvY2lhdGVkIHdpdGggZWFjaCBvZiB0aGVzZVxyXG5cdCAqIGNvbmZpZ3VyYXRpb25zIGRpc3Rpbmd1aXNoZXMgYmV0d2VlbiB0aGVtLCBhbmQgcHJldmVudHMgdGhlIGFsdGVybmF0aXZlXHJcblx0ICogd2hpY2ggc3RlcHBlZCBvdXQgdG8gYHByb2dgIChhbmQgdGhlbiBiYWNrIGluIHRvIGBzdGF0ZW1lbnRgXHJcblx0ICogZnJvbSBiZWluZyBlbGltaW5hdGVkIGJ5IHRoZSBmaWx0ZXIuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gY29uZmlncyBUaGUgY29uZmlndXJhdGlvbiBzZXQgY29tcHV0ZWQgYnlcclxuXHQgKiB7QGxpbmsgI2NvbXB1dGVTdGFydFN0YXRlfSBhcyB0aGUgc3RhcnQgc3RhdGUgZm9yIHRoZSBERkEuXHJcblx0ICogQHJldHVybnMgVGhlIHRyYW5zZm9ybWVkIGNvbmZpZ3VyYXRpb24gc2V0IHJlcHJlc2VudGluZyB0aGUgc3RhcnQgc3RhdGVcclxuXHQgKiBmb3IgYSBwcmVjZWRlbmNlIERGQSBhdCBhIHBhcnRpY3VsYXIgcHJlY2VkZW5jZSBsZXZlbCAoZGV0ZXJtaW5lZCBieVxyXG5cdCAqIGNhbGxpbmcge0BsaW5rIFBhcnNlciNnZXRQcmVjZWRlbmNlfSkuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgYXBwbHlQcmVjZWRlbmNlRmlsdGVyKEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCwgZ2xvYmFsQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IEFUTkNvbmZpZ1NldCB7XHJcblx0XHRsZXQgc3RhdGVzRnJvbUFsdDE6IE1hcDxudW1iZXIsIFByZWRpY3Rpb25Db250ZXh0PiA9IG5ldyBNYXA8bnVtYmVyLCBQcmVkaWN0aW9uQ29udGV4dD4oKTtcclxuXHRcdGxldCBjb25maWdTZXQ6IEFUTkNvbmZpZ1NldCA9IG5ldyBBVE5Db25maWdTZXQoKTtcclxuXHRcdGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKSB7XHJcblx0XHRcdC8vIGhhbmRsZSBhbHQgMSBmaXJzdFxyXG5cdFx0XHRpZiAoY29uZmlnLmFsdCAhPT0gMSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgdXBkYXRlZENvbnRleHQ6IFNlbWFudGljQ29udGV4dCB8IHVuZGVmaW5lZCA9IGNvbmZpZy5zZW1hbnRpY0NvbnRleHQuZXZhbFByZWNlZGVuY2UodGhpcy5fcGFyc2VyLCBnbG9iYWxDb250ZXh0KTtcclxuXHRcdFx0aWYgKHVwZGF0ZWRDb250ZXh0ID09IG51bGwpIHtcclxuXHRcdFx0XHQvLyB0aGUgY29uZmlndXJhdGlvbiB3YXMgZWxpbWluYXRlZFxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZXNGcm9tQWx0MS5zZXQoY29uZmlnLnN0YXRlLnN0YXRlTnVtYmVyLCBjb25maWcuY29udGV4dCk7XHJcblx0XHRcdGlmICh1cGRhdGVkQ29udGV4dCAhPT0gY29uZmlnLnNlbWFudGljQ29udGV4dCkge1xyXG5cdFx0XHRcdGNvbmZpZ1NldC5hZGQoY29uZmlnLnRyYW5zZm9ybShjb25maWcuc3RhdGUsIGZhbHNlLCB1cGRhdGVkQ29udGV4dCksIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0Y29uZmlnU2V0LmFkZChjb25maWcsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBjb25maWcgb2YgY29uZmlncykge1xyXG5cdFx0XHRpZiAoY29uZmlnLmFsdCA9PT0gMSkge1xyXG5cdFx0XHRcdC8vIGFscmVhZHkgaGFuZGxlZFxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIWNvbmZpZy5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkKSB7XHJcblx0XHRcdFx0LyogSW4gdGhlIGZ1dHVyZSwgdGhpcyBlbGltaW5hdGlvbiBzdGVwIGNvdWxkIGJlIHVwZGF0ZWQgdG8gYWxzb1xyXG5cdFx0XHRcdCAqIGZpbHRlciB0aGUgcHJlZGljdGlvbiBjb250ZXh0IGZvciBhbHRlcm5hdGl2ZXMgcHJlZGljdGluZyBhbHQ+MVxyXG5cdFx0XHRcdCAqIChiYXNpY2FsbHkgYSBncmFwaCBzdWJ0cmFjdGlvbiBhbGdvcml0aG0pLlxyXG5cdFx0XHRcdCAqL1xyXG5cdFx0XHRcdGxldCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCB8IHVuZGVmaW5lZCA9IHN0YXRlc0Zyb21BbHQxLmdldChjb25maWcuc3RhdGUuc3RhdGVOdW1iZXIpO1xyXG5cdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgY29udGV4dC5lcXVhbHMoY29uZmlnLmNvbnRleHQpKSB7XHJcblx0XHRcdFx0XHQvLyBlbGltaW5hdGVkXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbmZpZ1NldC5hZGQoY29uZmlnLCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb25maWdTZXQ7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0UmVhY2hhYmxlVGFyZ2V0KEBOb3ROdWxsIHNvdXJjZTogQVROQ29uZmlnLCBATm90TnVsbCB0cmFuczogVHJhbnNpdGlvbiwgdHR5cGU6IG51bWJlcik6IEFUTlN0YXRlIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICh0cmFucy5tYXRjaGVzKHR0eXBlLCAwLCB0aGlzLmF0bi5tYXhUb2tlblR5cGUpKSB7XHJcblx0XHRcdHJldHVybiB0cmFucy50YXJnZXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdC8qKiBjb2xsZWN0IGFuZCBzZXQgRCdzIHNlbWFudGljIGNvbnRleHQgKi9cclxuXHRwcm90ZWN0ZWQgcHJlZGljYXRlREZBU3RhdGUoXHJcblx0XHREOiBERkFTdGF0ZSxcclxuXHRcdGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCxcclxuXHRcdG5hbHRzOiBudW1iZXIpOiBERkFTdGF0ZS5QcmVkUHJlZGljdGlvbltdIHwgdW5kZWZpbmVkIHtcclxuXHRcdGxldCBjb25mbGljdGluZ0FsdHM6IEJpdFNldCB8IHVuZGVmaW5lZCA9IHRoaXMuZ2V0Q29uZmxpY3RpbmdBbHRzRnJvbUNvbmZpZ1NldChjb25maWdzKTtcclxuXHRcdGlmICghY29uZmxpY3RpbmdBbHRzKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRoaXMgdW5oYW5kbGVkIHNjZW5hcmlvIGlzIGludGVuZGVkIHRvIGJlIHVucmVhY2hhYmxlLCBidXQgSSdtIGN1cnJlbnRseSBub3Qgc3VyZSBvZiB3aHkgd2Uga25vdyB0aGF0J3MgdGhlIGNhc2UuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJwcmVkaWNhdGVERkFTdGF0ZSBcIiArIEQpO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGFsdFRvUHJlZDogU2VtYW50aWNDb250ZXh0W10gfCB1bmRlZmluZWQgPSB0aGlzLmdldFByZWRzRm9yQW1iaWdBbHRzKGNvbmZsaWN0aW5nQWx0cywgY29uZmlncywgbmFsdHMpO1xyXG5cdFx0Ly8gYWx0VG9QcmVkW3VuaXF1ZUFsdF0gaXMgbm93IG91ciB2YWxpZGF0aW5nIHByZWRpY2F0ZSAoaWYgYW55KVxyXG5cdFx0bGV0IHByZWRQcmVkaWN0aW9uczogREZBU3RhdGUuUHJlZFByZWRpY3Rpb25bXSB8IHVuZGVmaW5lZDtcclxuXHRcdGlmIChhbHRUb1ByZWQgIT0gbnVsbCkge1xyXG5cdFx0XHQvLyB3ZSBoYXZlIGEgdmFsaWRhdGluZyBwcmVkaWNhdGU7IHRlc3QgaXRcclxuXHRcdFx0Ly8gVXBkYXRlIERGQSBzbyByZWFjaCBiZWNvbWVzIGFjY2VwdCBzdGF0ZSB3aXRoIHByZWRpY2F0ZVxyXG5cdFx0XHRwcmVkUHJlZGljdGlvbnMgPSB0aGlzLmdldFByZWRpY2F0ZVByZWRpY3Rpb25zKGNvbmZsaWN0aW5nQWx0cywgYWx0VG9QcmVkKTtcclxuXHRcdFx0RC5wcmVkaWNhdGVzID0gcHJlZFByZWRpY3Rpb25zO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHByZWRQcmVkaWN0aW9ucztcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRQcmVkc0ZvckFtYmlnQWx0cyhcclxuXHRcdEBOb3ROdWxsIGFtYmlnQWx0czogQml0U2V0LFxyXG5cdFx0QE5vdE51bGwgY29uZmlnczogQVROQ29uZmlnU2V0LFxyXG5cdFx0bmFsdHM6IG51bWJlcik6IFNlbWFudGljQ29udGV4dFtdIHwgdW5kZWZpbmVkIHtcclxuXHRcdC8vIFJFQUNIPVsxfDF8W118MDowLCAxfDJ8W118MDoxXVxyXG5cclxuXHRcdC8qIGFsdFRvUHJlZCBzdGFydHMgYXMgYW4gYXJyYXkgb2YgYWxsIHVuZGVmaW5lZCBjb250ZXh0cy4gVGhlIGVudHJ5IGF0IGluZGV4IGlcclxuXHRcdCAqIGNvcnJlc3BvbmRzIHRvIGFsdGVybmF0aXZlIGkuIGFsdFRvUHJlZFtpXSBtYXkgaGF2ZSBvbmUgb2YgdGhyZWUgdmFsdWVzOlxyXG5cdFx0ICogICAxLiB1bmRlZmluZWQ6IG5vIEFUTkNvbmZpZyBjIGlzIGZvdW5kIHN1Y2ggdGhhdCBjLmFsdD09PWlcclxuXHRcdCAqICAgMi4gU2VtYW50aWNDb250ZXh0Lk5PTkU6IEF0IGxlYXN0IG9uZSBBVE5Db25maWcgYyBleGlzdHMgc3VjaCB0aGF0XHJcblx0XHQgKiAgICAgIGMuYWx0PT09aSBhbmQgYy5zZW1hbnRpY0NvbnRleHQ9PT1TZW1hbnRpY0NvbnRleHQuTk9ORS4gSW4gb3RoZXIgd29yZHMsXHJcblx0XHQgKiAgICAgIGFsdCBpIGhhcyBhdCBsZWFzdCBvbmUgdW5wcmVkaWNhdGVkIGNvbmZpZy5cclxuXHRcdCAqICAgMy4gTm9uLU5PTkUgU2VtYW50aWMgQ29udGV4dDogVGhlcmUgZXhpc3RzIGF0IGxlYXN0IG9uZSwgYW5kIGZvciBhbGxcclxuXHRcdCAqICAgICAgQVROQ29uZmlnIGMgc3VjaCB0aGF0IGMuYWx0PT09aSwgYy5zZW1hbnRpY0NvbnRleHQhPT1TZW1hbnRpY0NvbnRleHQuTk9ORS5cclxuXHRcdCAqXHJcblx0XHQgKiBGcm9tIHRoaXMsIGl0IGlzIGNsZWFyIHRoYXQgTk9ORXx8YW55dGhpbmc9PU5PTkUuXHJcblx0XHQgKi9cclxuXHRcdGxldCBhbHRUb1ByZWQ6IEFycmF5PFNlbWFudGljQ29udGV4dCB8IHVuZGVmaW5lZD4gfCB1bmRlZmluZWQgPSBuZXcgQXJyYXk8U2VtYW50aWNDb250ZXh0PihuYWx0cyArIDEpO1xyXG5cdFx0bGV0IG46IG51bWJlciA9IGFsdFRvUHJlZC5sZW5ndGg7XHJcblx0XHRmb3IgKGxldCBjIG9mIGNvbmZpZ3MpIHtcclxuXHRcdFx0aWYgKGFtYmlnQWx0cy5nZXQoYy5hbHQpKSB7XHJcblx0XHRcdFx0YWx0VG9QcmVkW2MuYWx0XSA9IFNlbWFudGljQ29udGV4dC5vcihhbHRUb1ByZWRbYy5hbHRdLCBjLnNlbWFudGljQ29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgblByZWRBbHRzOiBudW1iZXIgPSAwO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0aWYgKGFsdFRvUHJlZFtpXSA9PSBudWxsKSB7XHJcblx0XHRcdFx0YWx0VG9QcmVkW2ldID0gU2VtYW50aWNDb250ZXh0Lk5PTkU7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoYWx0VG9QcmVkW2ldICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xyXG5cdFx0XHRcdG5QcmVkQWx0cysrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IGBhbHRUb1ByZWRgIGRvZXNuJ3QgY29udGFpbiBhbnkgdW5kZWZpbmVkIGVudHJpZXNcclxuXHRcdGxldCByZXN1bHQ6IFNlbWFudGljQ29udGV4dFtdIHwgdW5kZWZpbmVkID0gYWx0VG9QcmVkIGFzIFNlbWFudGljQ29udGV4dFtdO1xyXG5cclxuXHRcdC8vIG5vbmFtYmlnIGFsdHMgYXJlIHVuZGVmaW5lZCBpbiByZXN1bHRcclxuXHRcdGlmIChuUHJlZEFsdHMgPT09IDApIHtcclxuXHRcdFx0cmVzdWx0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcImdldFByZWRzRm9yQW1iaWdBbHRzIHJlc3VsdCBcIiArIChyZXN1bHQgPyBBcnJheXMudG9TdHJpbmcocmVzdWx0KSA6IFwidW5kZWZpbmVkXCIpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0UHJlZGljYXRlUHJlZGljdGlvbnMoYW1iaWdBbHRzOiBCaXRTZXQgfCB1bmRlZmluZWQsIGFsdFRvUHJlZDogU2VtYW50aWNDb250ZXh0W10pOiBERkFTdGF0ZS5QcmVkUHJlZGljdGlvbltdIHwgdW5kZWZpbmVkIHtcclxuXHRcdGxldCBwYWlyczogREZBU3RhdGUuUHJlZFByZWRpY3Rpb25bXSA9IFtdO1xyXG5cdFx0bGV0IGNvbnRhaW5zUHJlZGljYXRlOiBib29sZWFuID0gZmFsc2U7XHJcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IGFsdFRvUHJlZC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgcHJlZDogU2VtYW50aWNDb250ZXh0ID0gYWx0VG9QcmVkW2ldO1xyXG5cclxuXHRcdFx0Ly8gdW5wcmVkaWNhdGVkIGlzIGluZGljYXRlZCBieSBTZW1hbnRpY0NvbnRleHQuTk9ORVxyXG5cdFx0XHRhc3NlcnQocHJlZCAhPSBudWxsKTtcclxuXHJcblx0XHRcdC8vIGZpbmQgZmlyc3QgdW5wcmVkaWNhdGVkIGJ1dCBhbWJpZyBhbHRlcm5hdGl2ZSwgaWYgYW55LlxyXG5cdFx0XHQvLyBPbmx5IGFtYmlndW91cyBhbHRlcm5hdGl2ZXMgd2lsbCBoYXZlIFNlbWFudGljQ29udGV4dC5OT05FLlxyXG5cdFx0XHQvLyBBbnkgdW5hbWJpZyBhbHRzIG9yIGFtYmlnIG5ha2VkIGFsdHMgYWZ0ZXIgZmlyc3QgYW1iaWcgbmFrZWQgYXJlIGlnbm9yZWRcclxuXHRcdFx0Ly8gKHVuZGVmaW5lZCwgaSkgbWVhbnMgYWx0IGkgaXMgdGhlIGRlZmF1bHQgcHJlZGljdGlvblxyXG5cdFx0XHQvLyBpZiBubyAodW5kZWZpbmVkLCBpKSwgdGhlbiBubyBkZWZhdWx0IHByZWRpY3Rpb24uXHJcblx0XHRcdGlmIChhbWJpZ0FsdHMgIT0gbnVsbCAmJiBhbWJpZ0FsdHMuZ2V0KGkpICYmIHByZWQgPT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XHJcblx0XHRcdFx0cGFpcnMucHVzaChuZXcgREZBU3RhdGUuUHJlZFByZWRpY3Rpb24ocHJlZCwgaSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHByZWQgIT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XHJcblx0XHRcdFx0Y29udGFpbnNQcmVkaWNhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdHBhaXJzLnB1c2gobmV3IERGQVN0YXRlLlByZWRQcmVkaWN0aW9uKHByZWQsIGkpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghY29udGFpbnNQcmVkaWNhdGUpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcbi8vXHRcdFN5c3RlbS5vdXQucHJpbnRsbihBcnJheXMudG9TdHJpbmcoYWx0VG9QcmVkKStcIi0+XCIrcGFpcnMpO1xyXG5cdFx0cmV0dXJuIHBhaXJzO1xyXG5cdH1cclxuXHJcblx0LyoqIExvb2sgdGhyb3VnaCBhIGxpc3Qgb2YgcHJlZGljYXRlL2FsdCBwYWlycywgcmV0dXJuaW5nIGFsdHMgZm9yIHRoZVxyXG5cdCAqICBwYWlycyB0aGF0IHdpbi4gQW4gYHVuZGVmaW5lZGAgcHJlZGljYXRlIGluZGljYXRlcyBhbiBhbHQgY29udGFpbmluZyBhblxyXG5cdCAqICB1bnByZWRpY2F0ZWQgY29uZmlnIHdoaWNoIGJlaGF2ZXMgYXMgXCJhbHdheXMgdHJ1ZS5cIlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBldmFsU2VtYW50aWNDb250ZXh0KFxyXG5cdFx0QE5vdE51bGwgcHJlZFByZWRpY3Rpb25zOiBERkFTdGF0ZS5QcmVkUHJlZGljdGlvbltdLFxyXG5cdFx0b3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCxcclxuXHRcdGNvbXBsZXRlOiBib29sZWFuKTogQml0U2V0IHtcclxuXHRcdGxldCBwcmVkaWN0aW9uczogQml0U2V0ID0gbmV3IEJpdFNldCgpO1xyXG5cdFx0Zm9yIChsZXQgcGFpciBvZiBwcmVkUHJlZGljdGlvbnMpIHtcclxuXHRcdFx0aWYgKHBhaXIucHJlZCA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcclxuXHRcdFx0XHRwcmVkaWN0aW9ucy5zZXQocGFpci5hbHQpO1xyXG5cdFx0XHRcdGlmICghY29tcGxldGUpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBldmFsdWF0ZWRSZXN1bHQ6IGJvb2xlYW4gPSB0aGlzLmV2YWxTZW1hbnRpY0NvbnRleHRJbXBsKHBhaXIucHJlZCwgb3V0ZXJDb250ZXh0LCBwYWlyLmFsdCk7XHJcblx0XHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcgfHwgUGFyc2VyQVROU2ltdWxhdG9yLmRmYV9kZWJ1Zykge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiZXZhbCBwcmVkIFwiICsgcGFpciArIFwiPVwiICsgZXZhbHVhdGVkUmVzdWx0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGV2YWx1YXRlZFJlc3VsdCkge1xyXG5cdFx0XHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcgfHwgUGFyc2VyQVROU2ltdWxhdG9yLmRmYV9kZWJ1Zykge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJQUkVESUNUIFwiICsgcGFpci5hbHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRwcmVkaWN0aW9ucy5zZXQocGFpci5hbHQpO1xyXG5cdFx0XHRcdGlmICghY29tcGxldGUpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwcmVkaWN0aW9ucztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV2YWx1YXRlIGEgc2VtYW50aWMgY29udGV4dCB3aXRoaW4gYSBzcGVjaWZpYyBwYXJzZXIgY29udGV4dC5cclxuXHQgKlxyXG5cdCAqIFRoaXMgbWV0aG9kIG1pZ2h0IG5vdCBiZSBjYWxsZWQgZm9yIGV2ZXJ5IHNlbWFudGljIGNvbnRleHQgZXZhbHVhdGVkXHJcblx0ICogZHVyaW5nIHRoZSBwcmVkaWN0aW9uIHByb2Nlc3MuIEluIHBhcnRpY3VsYXIsIHdlIGN1cnJlbnRseSBkbyBub3RcclxuXHQgKiBldmFsdWF0ZSB0aGUgZm9sbG93aW5nIGJ1dCBpdCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmU6XHJcblx0ICpcclxuXHQgKiAqIFByZWNlZGVuY2UgcHJlZGljYXRlcyAocmVwcmVzZW50ZWQgYnlcclxuXHQgKiAgIHtAbGluayBTZW1hbnRpY0NvbnRleHQuUHJlY2VkZW5jZVByZWRpY2F0ZX0pIGFyZSBub3QgY3VycmVudGx5IGV2YWx1YXRlZFxyXG5cdCAqICAgdGhyb3VnaCB0aGlzIG1ldGhvZC5cclxuXHQgKiAqIE9wZXJhdG9yIHByZWRpY2F0ZXMgKHJlcHJlc2VudGVkIGJ5IHtAbGluayBTZW1hbnRpY0NvbnRleHQuQU5EfSBhbmRcclxuXHQgKiAgIHtAbGluayBTZW1hbnRpY0NvbnRleHQuT1J9KSBhcmUgZXZhbHVhdGVkIGFzIGEgc2luZ2xlIHNlbWFudGljXHJcblx0ICogICBjb250ZXh0LCByYXRoZXIgdGhhbiBldmFsdWF0aW5nIHRoZSBvcGVyYW5kcyBpbmRpdmlkdWFsbHkuXHJcblx0ICogICBJbXBsZW1lbnRhdGlvbnMgd2hpY2ggcmVxdWlyZSBldmFsdWF0aW9uIHJlc3VsdHMgZnJvbSBpbmRpdmlkdWFsXHJcblx0ICogICBwcmVkaWNhdGVzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBleHBsaWNpdGx5IGhhbmRsZSBldmFsdWF0aW9uIG9mXHJcblx0ICogICB0aGUgb3BlcmFuZHMgd2l0aGluIG9wZXJhdG9yIHByZWRpY2F0ZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcHJlZCBUaGUgc2VtYW50aWMgY29udGV4dCB0byBldmFsdWF0ZVxyXG5cdCAqIEBwYXJhbSBwYXJzZXJDYWxsU3RhY2sgVGhlIHBhcnNlciBjb250ZXh0IGluIHdoaWNoIHRvIGV2YWx1YXRlIHRoZVxyXG5cdCAqIHNlbWFudGljIGNvbnRleHRcclxuXHQgKiBAcGFyYW0gYWx0IFRoZSBhbHRlcm5hdGl2ZSB3aGljaCBpcyBndWFyZGVkIGJ5IGBwcmVkYFxyXG5cdCAqXHJcblx0ICogQHNpbmNlIDQuM1xyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBldmFsU2VtYW50aWNDb250ZXh0SW1wbChATm90TnVsbCBwcmVkOiBTZW1hbnRpY0NvbnRleHQsIHBhcnNlckNhbGxTdGFjazogUGFyc2VyUnVsZUNvbnRleHQsIGFsdDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gcHJlZC5ldmFsKHRoaXMuX3BhcnNlciwgcGFyc2VyQ2FsbFN0YWNrKTtcclxuXHR9XHJcblxyXG5cdC8qIFRPRE86IElmIHdlIGFyZSBkb2luZyBwcmVkaWNhdGVzLCB0aGVyZSBpcyBubyBwb2ludCBpbiBwdXJzdWluZ1xyXG5cdFx0IGNsb3N1cmUgb3BlcmF0aW9ucyBpZiB3ZSByZWFjaCBhIERGQSBzdGF0ZSB0aGF0IHVuaXF1ZWx5IHByZWRpY3RzXHJcblx0XHQgYWx0ZXJuYXRpdmUuIFdlIHdpbGwgbm90IGJlIGNhY2hpbmcgdGhhdCBERkEgc3RhdGUgYW5kIGl0IGlzIGFcclxuXHRcdCB3YXN0ZSB0byBwdXJzdWUgdGhlIGNsb3N1cmUuIE1pZ2h0IGhhdmUgdG8gYWR2YW5jZSB3aGVuIHdlIGRvXHJcblx0XHQgYW1iaWcgZGV0ZWN0aW9uIHRob3VnaHQgOihcclxuXHRcdCAgKi9cclxuXHJcblx0cHJvdGVjdGVkIGNsb3N1cmUoXHJcblx0XHRzb3VyY2VDb25maWdzOiBBVE5Db25maWdTZXQsXHJcblx0XHRATm90TnVsbCBjb25maWdzOiBBVE5Db25maWdTZXQsXHJcblx0XHRjb2xsZWN0UHJlZGljYXRlczogYm9vbGVhbixcclxuXHRcdGhhc01vcmVDb250ZXh0OiBib29sZWFuLFxyXG5cdFx0QE51bGxhYmxlIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSxcclxuXHRcdHRyZWF0RW9mQXNFcHNpbG9uOiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRpZiAoY29udGV4dENhY2hlID09IG51bGwpIHtcclxuXHRcdFx0Y29udGV4dENhY2hlID0gUHJlZGljdGlvbkNvbnRleHRDYWNoZS5VTkNBQ0hFRDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgY3VycmVudENvbmZpZ3M6IEFUTkNvbmZpZ1NldCA9IHNvdXJjZUNvbmZpZ3M7XHJcblx0XHRsZXQgY2xvc3VyZUJ1c3k6IEFycmF5MkRIYXNoU2V0PEFUTkNvbmZpZz4gPSBuZXcgQXJyYXkyREhhc2hTZXQ8QVROQ29uZmlnPihPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xyXG5cdFx0d2hpbGUgKGN1cnJlbnRDb25maWdzLnNpemUgPiAwKSB7XHJcblx0XHRcdGxldCBpbnRlcm1lZGlhdGU6IEFUTkNvbmZpZ1NldCA9IG5ldyBBVE5Db25maWdTZXQoKTtcclxuXHRcdFx0Zm9yIChsZXQgY29uZmlnIG9mIGN1cnJlbnRDb25maWdzKSB7XHJcblx0XHRcdFx0dGhpcy5jbG9zdXJlSW1wbChjb25maWcsIGNvbmZpZ3MsIGludGVybWVkaWF0ZSwgY2xvc3VyZUJ1c3ksIGNvbGxlY3RQcmVkaWNhdGVzLCBoYXNNb3JlQ29udGV4dCwgY29udGV4dENhY2hlLCAwLCB0cmVhdEVvZkFzRXBzaWxvbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN1cnJlbnRDb25maWdzID0gaW50ZXJtZWRpYXRlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGNsb3N1cmVJbXBsKFxyXG5cdFx0QE5vdE51bGwgY29uZmlnOiBBVE5Db25maWcsXHJcblx0XHRATm90TnVsbCBjb25maWdzOiBBVE5Db25maWdTZXQsXHJcblx0XHRATnVsbGFibGUgaW50ZXJtZWRpYXRlOiBBVE5Db25maWdTZXQsXHJcblx0XHRATm90TnVsbCBjbG9zdXJlQnVzeTogQXJyYXkyREhhc2hTZXQ8QVROQ29uZmlnPixcclxuXHRcdGNvbGxlY3RQcmVkaWNhdGVzOiBib29sZWFuLFxyXG5cdFx0aGFzTW9yZUNvbnRleHRzOiBib29sZWFuLFxyXG5cdFx0QE5vdE51bGwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlLFxyXG5cdFx0ZGVwdGg6IG51bWJlcixcclxuXHRcdHRyZWF0RW9mQXNFcHNpbG9uOiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiY2xvc3VyZShcIiArIGNvbmZpZy50b1N0cmluZyh0aGlzLl9wYXJzZXIsIHRydWUpICsgXCIpXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb25maWcuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XHJcblx0XHRcdC8vIFdlIGhpdCBydWxlIGVuZC4gSWYgd2UgaGF2ZSBjb250ZXh0IGluZm8sIHVzZSBpdFxyXG5cdFx0XHRpZiAoIWNvbmZpZy5jb250ZXh0LmlzRW1wdHkpIHtcclxuXHRcdFx0XHRsZXQgaGFzRW1wdHk6IGJvb2xlYW4gPSBjb25maWcuY29udGV4dC5oYXNFbXB0eTtcclxuXHRcdFx0XHRsZXQgbm9uRW1wdHlTaXplOiBudW1iZXIgPSBjb25maWcuY29udGV4dC5zaXplIC0gKGhhc0VtcHR5ID8gMSA6IDApO1xyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbm9uRW1wdHlTaXplOyBpKyspIHtcclxuXHRcdFx0XHRcdGxldCBuZXdDb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCA9IGNvbmZpZy5jb250ZXh0LmdldFBhcmVudChpKTsgLy8gXCJwb3BcIiByZXR1cm4gc3RhdGVcclxuXHRcdFx0XHRcdGxldCByZXR1cm5TdGF0ZTogQVROU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbY29uZmlnLmNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaSldO1xyXG5cdFx0XHRcdFx0bGV0IGM6IEFUTkNvbmZpZyA9IEFUTkNvbmZpZy5jcmVhdGUocmV0dXJuU3RhdGUsIGNvbmZpZy5hbHQsIG5ld0NvbnRleHQsIGNvbmZpZy5zZW1hbnRpY0NvbnRleHQpO1xyXG5cdFx0XHRcdFx0Ly8gV2hpbGUgd2UgaGF2ZSBjb250ZXh0IHRvIHBvcCBiYWNrIGZyb20sIHdlIG1heSBoYXZlXHJcblx0XHRcdFx0XHQvLyBnb3R0ZW4gdGhhdCBjb250ZXh0IEFGVEVSIGhhdmluZyBmYWxsZW4gb2ZmIGEgcnVsZS5cclxuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSB0cmFjayB0aGF0IHdlIGFyZSBub3cgb3V0IG9mIGNvbnRleHQuXHJcblx0XHRcdFx0XHRjLm91dGVyQ29udGV4dERlcHRoID0gY29uZmlnLm91dGVyQ29udGV4dERlcHRoO1xyXG5cdFx0XHRcdFx0Yy5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkID0gY29uZmlnLmlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQ7XHJcblx0XHRcdFx0XHRhc3NlcnQoZGVwdGggPiBNSU5fSU5URUdFUl9WQUxVRSk7XHJcblx0XHRcdFx0XHR0aGlzLmNsb3N1cmVJbXBsKGMsIGNvbmZpZ3MsIGludGVybWVkaWF0ZSwgY2xvc3VyZUJ1c3ksIGNvbGxlY3RQcmVkaWNhdGVzLCBoYXNNb3JlQ29udGV4dHMsIGNvbnRleHRDYWNoZSwgZGVwdGggLSAxLCB0cmVhdEVvZkFzRXBzaWxvbik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIWhhc0VtcHR5IHx8ICFoYXNNb3JlQ29udGV4dHMpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbmZpZyA9IGNvbmZpZy50cmFuc2Zvcm0oY29uZmlnLnN0YXRlLCBmYWxzZSwgUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfTE9DQUwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKCFoYXNNb3JlQ29udGV4dHMpIHtcclxuXHRcdFx0XHRjb25maWdzLmFkZChjb25maWcsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdC8vIGVsc2UgaWYgd2UgaGF2ZSBubyBjb250ZXh0IGluZm8sIGp1c3QgY2hhc2UgZm9sbG93IGxpbmtzIChpZiBncmVlZHkpXHJcblx0XHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJGQUxMSU5HIG9mZiBydWxlIFwiICtcclxuXHRcdFx0XHRcdFx0dGhpcy5nZXRSdWxlTmFtZShjb25maWcuc3RhdGUucnVsZUluZGV4KSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoY29uZmlnLmNvbnRleHQgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTEwpIHtcclxuXHRcdFx0XHRcdC8vIG5vIG5lZWQgdG8ga2VlcCBmdWxsIGNvbnRleHQgb3ZlcmhlYWQgd2hlbiB3ZSBzdGVwIG91dFxyXG5cdFx0XHRcdFx0Y29uZmlnID0gY29uZmlnLnRyYW5zZm9ybShjb25maWcuc3RhdGUsIGZhbHNlLCBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9MT0NBTCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKCFjb25maWcucmVhY2hlc0ludG9PdXRlckNvbnRleHQgJiYgUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKGNvbmZpZy5jb250ZXh0KSkge1xyXG5cdFx0XHRcdFx0Ly8gYWRkIHN0b3Agc3RhdGUgd2hlbiBsZWF2aW5nIGRlY2lzaW9uIHJ1bGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcblx0XHRcdFx0XHRjb25maWdzLmFkZChjb25maWcsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHA6IEFUTlN0YXRlID0gY29uZmlnLnN0YXRlO1xyXG5cdFx0Ly8gb3B0aW1pemF0aW9uXHJcblx0XHRpZiAoIXAub25seUhhc0Vwc2lsb25UcmFuc2l0aW9ucykge1xyXG5cdFx0XHRjb25maWdzLmFkZChjb25maWcsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdC8vIG1ha2Ugc3VyZSB0byBub3QgcmV0dXJuIGhlcmUsIGJlY2F1c2UgRU9GIHRyYW5zaXRpb25zIGNhbiBhY3QgYXNcclxuXHRcdFx0Ly8gYm90aCBlcHNpbG9uIHRyYW5zaXRpb25zIGFuZCBub24tZXBzaWxvbiB0cmFuc2l0aW9ucy5cclxuXHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiYWRkZWQgY29uZmlnIFwiICsgY29uZmlncyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHAubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9uczsgaSsrKSB7XHJcblx0XHRcdC8vIFRoaXMgYmxvY2sgaW1wbGVtZW50cyBmaXJzdC1lZGdlIGVsaW1pbmF0aW9uIG9mIGFtYmlndW91cyBMUlxyXG5cdFx0XHQvLyBhbHRlcm5hdGl2ZXMgYXMgcGFydCBvZiBkeW5hbWljIGRpc2FtYmlndWF0aW9uIGR1cmluZyBwcmVkaWN0aW9uLlxyXG5cdFx0XHQvLyBTZWUgYW50bHIvYW50bHI0IzEzOTguXHJcblx0XHRcdGlmIChpID09PSAwXHJcblx0XHRcdFx0JiYgcC5zdGF0ZVR5cGUgPT09IEFUTlN0YXRlVHlwZS5TVEFSX0xPT1BfRU5UUllcclxuXHRcdFx0XHQmJiAocCBhcyBTdGFyTG9vcEVudHJ5U3RhdGUpLnByZWNlZGVuY2VSdWxlRGVjaXNpb25cclxuXHRcdFx0XHQmJiAhY29uZmlnLmNvbnRleHQuaGFzRW1wdHkpIHtcclxuXHJcblx0XHRcdFx0bGV0IHByZWNlZGVuY2VEZWNpc2lvbiA9IHAgYXMgU3Rhckxvb3BFbnRyeVN0YXRlO1xyXG5cclxuXHRcdFx0XHQvLyBXaGVuIHN1cHByZXNzIGlzIHRydWUsIGl0IG1lYW5zIHRoZSBvdXRnb2luZyBlZGdlIGk9PTAgaXNcclxuXHRcdFx0XHQvLyBhbWJpZ3VvdXMgd2l0aCB0aGUgb3V0Z29pbmcgZWRnZSBpPT0xLCBhbmQgdGh1cyB0aGUgY2xvc3VyZVxyXG5cdFx0XHRcdC8vIG9wZXJhdGlvbiBjYW4gZHluYW1pY2FsbHkgZGlzYW1iaWd1YXRlIGJ5IHN1cHByZXNzaW5nIHRoaXNcclxuXHRcdFx0XHQvLyBlZGdlIGR1cmluZyB0aGUgY2xvc3VyZSBvcGVyYXRpb24uXHJcblx0XHRcdFx0bGV0IHN1cHByZXNzOiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgY29uZmlnLmNvbnRleHQuc2l6ZTsgaisrKSB7XHJcblx0XHRcdFx0XHRpZiAoIXByZWNlZGVuY2VEZWNpc2lvbi5wcmVjZWRlbmNlTG9vcGJhY2tTdGF0ZXMuZ2V0KGNvbmZpZy5jb250ZXh0LmdldFJldHVyblN0YXRlKGopKSkge1xyXG5cdFx0XHRcdFx0XHRzdXBwcmVzcyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChzdXBwcmVzcykge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgdDogVHJhbnNpdGlvbiA9IHAuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihpKTtcclxuXHRcdFx0bGV0IGNvbnRpbnVlQ29sbGVjdGluZzogYm9vbGVhbiA9XHJcblx0XHRcdFx0ISh0IGluc3RhbmNlb2YgQWN0aW9uVHJhbnNpdGlvbikgJiYgY29sbGVjdFByZWRpY2F0ZXM7XHJcblx0XHRcdGxldCBjOiBBVE5Db25maWcgfCB1bmRlZmluZWQgPSB0aGlzLmdldEVwc2lsb25UYXJnZXQoY29uZmlnLCB0LCBjb250aW51ZUNvbGxlY3RpbmcsIGRlcHRoID09PSAwLCBjb250ZXh0Q2FjaGUsIHRyZWF0RW9mQXNFcHNpbG9uKTtcclxuXHRcdFx0aWYgKGMgIT0gbnVsbCkge1xyXG5cdFx0XHRcdGlmICh0IGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRcdGlmIChpbnRlcm1lZGlhdGUgIT0gbnVsbCAmJiAhY29sbGVjdFByZWRpY2F0ZXMpIHtcclxuXHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlLmFkZChjLCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBuZXdEZXB0aDogbnVtYmVyID0gZGVwdGg7XHJcblx0XHRcdFx0aWYgKGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcclxuXHRcdFx0XHRcdC8vIHRhcmdldCBmZWxsIG9mZiBlbmQgb2YgcnVsZTsgbWFyayByZXN1bHRpbmcgYyBhcyBoYXZpbmcgZGlwcGVkIGludG8gb3V0ZXIgY29udGV4dFxyXG5cdFx0XHRcdFx0Ly8gV2UgY2FuJ3QgZ2V0IGhlcmUgaWYgaW5jb21pbmcgY29uZmlnIHdhcyBydWxlIHN0b3AgYW5kIHdlIGhhZCBjb250ZXh0XHJcblx0XHRcdFx0XHQvLyB0cmFjayBob3cgZmFyIHdlIGRpcCBpbnRvIG91dGVyIGNvbnRleHQuICBNaWdodFxyXG5cdFx0XHRcdFx0Ly8gY29tZSBpbiBoYW5keSBhbmQgd2UgYXZvaWQgZXZhbHVhdGluZyBjb250ZXh0IGRlcGVuZGVudFxyXG5cdFx0XHRcdFx0Ly8gcHJlZHMgaWYgdGhpcyBpcyA+IDAuXHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuZGZhICE9IG51bGwgJiYgdGhpcy5kZmEuaXNQcmVjZWRlbmNlRGZhKSB7XHJcblx0XHRcdFx0XHRcdGxldCBvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuOiBudW1iZXIgPSAodCBhcyBFcHNpbG9uVHJhbnNpdGlvbikub3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybjtcclxuXHRcdFx0XHRcdFx0aWYgKG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4gPT09IHRoaXMuZGZhLmF0blN0YXJ0U3RhdGUucnVsZUluZGV4KSB7XHJcblx0XHRcdFx0XHRcdFx0Yy5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGMub3V0ZXJDb250ZXh0RGVwdGggPSBjLm91dGVyQ29udGV4dERlcHRoICsgMTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIWNsb3N1cmVCdXN5LmFkZChjKSkge1xyXG5cdFx0XHRcdFx0XHQvLyBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb24gZm9yIHJpZ2h0LXJlY3Vyc2l2ZSBydWxlc1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRhc3NlcnQobmV3RGVwdGggPiBNSU5fSU5URUdFUl9WQUxVRSk7XHJcblx0XHRcdFx0XHRuZXdEZXB0aC0tO1xyXG5cdFx0XHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImRpcHMgaW50byBvdXRlciBjdHg6IFwiICsgYyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHQgaW5zdGFuY2VvZiBSdWxlVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMub3B0aW1pemVfdGFpbF9jYWxscyAmJiB0Lm9wdGltaXplZFRhaWxDYWxsICYmICghdGhpcy50YWlsX2NhbGxfcHJlc2VydmVzX3NsbCB8fCAhUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKGNvbmZpZy5jb250ZXh0KSkpIHtcclxuXHRcdFx0XHRcdFx0YXNzZXJ0KGMuY29udGV4dCA9PT0gY29uZmlnLmNvbnRleHQpO1xyXG5cdFx0XHRcdFx0XHRpZiAobmV3RGVwdGggPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHQvLyB0aGUgcG9wL3B1c2ggb2YgYSB0YWlsIGNhbGwgd291bGQga2VlcCB0aGUgZGVwdGhcclxuXHRcdFx0XHRcdFx0XHQvLyBjb25zdGFudCwgZXhjZXB0IHdlIGxhdGNoIGlmIGl0IGdvZXMgbmVnYXRpdmVcclxuXHRcdFx0XHRcdFx0XHRuZXdEZXB0aC0tO1xyXG5cdFx0XHRcdFx0XHRcdGlmICghdGhpcy50YWlsX2NhbGxfcHJlc2VydmVzX3NsbCAmJiBQcmVkaWN0aW9uQ29udGV4dC5pc0VtcHR5TG9jYWwoY29uZmlnLmNvbnRleHQpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhlIFNMTCBjb25maWcgXCJkaXBzIGludG8gdGhlIG91dGVyIGNvbnRleHRcIiBvciBwcmVkaWN0aW9uIG1heSBub3QgZmFsbCBiYWNrIHRvIExMIG9uIGNvbmZsaWN0XHJcblx0XHRcdFx0XHRcdFx0XHRjLm91dGVyQ29udGV4dERlcHRoID0gYy5vdXRlckNvbnRleHREZXB0aCArIDE7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0Ly8gbGF0Y2ggd2hlbiBuZXdEZXB0aCBnb2VzIG5lZ2F0aXZlIC0gb25jZSB3ZSBzdGVwIG91dCBvZiB0aGUgZW50cnkgY29udGV4dCB3ZSBjYW4ndCByZXR1cm5cclxuXHRcdFx0XHRcdFx0aWYgKG5ld0RlcHRoID49IDApIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdEZXB0aCsrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKCF0LmlzRXBzaWxvbiAmJiAhY2xvc3VyZUJ1c3kuYWRkKGMpKSB7XHJcblx0XHRcdFx0XHRcdC8vIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvbiBmb3IgRU9GKiBhbmQgRU9GK1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuY2xvc3VyZUltcGwoYywgY29uZmlncywgaW50ZXJtZWRpYXRlLCBjbG9zdXJlQnVzeSwgY29udGludWVDb2xsZWN0aW5nLCBoYXNNb3JlQ29udGV4dHMsIGNvbnRleHRDYWNoZSwgbmV3RGVwdGgsIHRyZWF0RW9mQXNFcHNpbG9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0UnVsZU5hbWUoaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRpZiAodGhpcy5fcGFyc2VyICE9IG51bGwgJiYgaW5kZXggPj0gMCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fcGFyc2VyLnJ1bGVOYW1lc1tpbmRleF07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gXCI8cnVsZSBcIiArIGluZGV4ICsgXCI+XCI7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0RXBzaWxvblRhcmdldChATm90TnVsbCBjb25maWc6IEFUTkNvbmZpZywgQE5vdE51bGwgdDogVHJhbnNpdGlvbiwgY29sbGVjdFByZWRpY2F0ZXM6IGJvb2xlYW4sIGluQ29udGV4dDogYm9vbGVhbiwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlLCB0cmVhdEVvZkFzRXBzaWxvbjogYm9vbGVhbik6IEFUTkNvbmZpZyB8IHVuZGVmaW5lZCB7XHJcblx0XHRzd2l0Y2ggKHQuc2VyaWFsaXphdGlvblR5cGUpIHtcclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUlVMRTpcclxuXHRcdFx0cmV0dXJuIHRoaXMucnVsZVRyYW5zaXRpb24oY29uZmlnLCB0IGFzIFJ1bGVUcmFuc2l0aW9uLCBjb250ZXh0Q2FjaGUpO1xyXG5cclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUFJFQ0VERU5DRTpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY2VkZW5jZVRyYW5zaXRpb24oY29uZmlnLCB0IGFzIFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uLCBjb2xsZWN0UHJlZGljYXRlcywgaW5Db250ZXh0KTtcclxuXHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlBSRURJQ0FURTpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlZFRyYW5zaXRpb24oY29uZmlnLCB0IGFzIFByZWRpY2F0ZVRyYW5zaXRpb24sIGNvbGxlY3RQcmVkaWNhdGVzLCBpbkNvbnRleHQpO1xyXG5cclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuQUNUSU9OOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hY3Rpb25UcmFuc2l0aW9uKGNvbmZpZywgdCBhcyBBY3Rpb25UcmFuc2l0aW9uKTtcclxuXHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLkVQU0lMT046XHJcblx0XHRcdHJldHVybiBjb25maWcudHJhbnNmb3JtKHQudGFyZ2V0LCBmYWxzZSk7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5BVE9NOlxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5SQU5HRTpcclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuU0VUOlxyXG5cdFx0XHQvLyBFT0YgdHJhbnNpdGlvbnMgYWN0IGxpa2UgZXBzaWxvbiB0cmFuc2l0aW9ucyBhZnRlciB0aGUgZmlyc3QgRU9GXHJcblx0XHRcdC8vIHRyYW5zaXRpb24gaXMgdHJhdmVyc2VkXHJcblx0XHRcdGlmICh0cmVhdEVvZkFzRXBzaWxvbikge1xyXG5cdFx0XHRcdGlmICh0Lm1hdGNoZXMoVG9rZW4uRU9GLCAwLCAxKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGNvbmZpZy50cmFuc2Zvcm0odC50YXJnZXQsIGZhbHNlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGFjdGlvblRyYW5zaXRpb24oQE5vdE51bGwgY29uZmlnOiBBVE5Db25maWcsIEBOb3ROdWxsIHQ6IEFjdGlvblRyYW5zaXRpb24pOiBBVE5Db25maWcge1xyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkFDVElPTiBlZGdlIFwiICsgdC5ydWxlSW5kZXggKyBcIjpcIiArIHQuYWN0aW9uSW5kZXgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNvbmZpZy50cmFuc2Zvcm0odC50YXJnZXQsIGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdEBOdWxsYWJsZVxyXG5cdHByb3RlY3RlZCBwcmVjZWRlbmNlVHJhbnNpdGlvbihcclxuXHRcdEBOb3ROdWxsIGNvbmZpZzogQVROQ29uZmlnLFxyXG5cdFx0QE5vdE51bGwgcHQ6IFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uLFxyXG5cdFx0Y29sbGVjdFByZWRpY2F0ZXM6IGJvb2xlYW4sXHJcblx0XHRpbkNvbnRleHQ6IGJvb2xlYW4pOiBBVE5Db25maWcge1xyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIlBSRUQgKGNvbGxlY3RQcmVkaWNhdGVzPVwiICsgY29sbGVjdFByZWRpY2F0ZXMgKyBcIikgXCIgK1xyXG5cdFx0XHRcdHB0LnByZWNlZGVuY2UgKyBcIj49X3BcIiArXHJcblx0XHRcdFx0XCIsIGN0eCBkZXBlbmRlbnQ9dHJ1ZVwiKTtcclxuXHRcdFx0aWYgKHRoaXMuX3BhcnNlciAhPSBudWxsKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJjb250ZXh0IHN1cnJvdW5kaW5nIHByZWQgaXMgXCIgK1xyXG5cdFx0XHRcdFx0dGhpcy5fcGFyc2VyLmdldFJ1bGVJbnZvY2F0aW9uU3RhY2soKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYzogQVROQ29uZmlnO1xyXG5cdFx0aWYgKGNvbGxlY3RQcmVkaWNhdGVzICYmIGluQ29udGV4dCkge1xyXG5cdFx0XHRsZXQgbmV3U2VtQ3R4OiBTZW1hbnRpY0NvbnRleHQgPSBTZW1hbnRpY0NvbnRleHQuYW5kKGNvbmZpZy5zZW1hbnRpY0NvbnRleHQsIHB0LnByZWRpY2F0ZSk7XHJcblx0XHRcdGMgPSBjb25maWcudHJhbnNmb3JtKHB0LnRhcmdldCwgZmFsc2UsIG5ld1NlbUN0eCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0YyA9IGNvbmZpZy50cmFuc2Zvcm0ocHQudGFyZ2V0LCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcImNvbmZpZyBmcm9tIHByZWQgdHJhbnNpdGlvbj1cIiArIGMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGM7XHJcblx0fVxyXG5cclxuXHRATnVsbGFibGVcclxuXHRwcm90ZWN0ZWQgcHJlZFRyYW5zaXRpb24oXHJcblx0XHRATm90TnVsbCBjb25maWc6IEFUTkNvbmZpZyxcclxuXHRcdEBOb3ROdWxsIHB0OiBQcmVkaWNhdGVUcmFuc2l0aW9uLFxyXG5cdFx0Y29sbGVjdFByZWRpY2F0ZXM6IGJvb2xlYW4sXHJcblx0XHRpbkNvbnRleHQ6IGJvb2xlYW4pOiBBVE5Db25maWcge1xyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIlBSRUQgKGNvbGxlY3RQcmVkaWNhdGVzPVwiICsgY29sbGVjdFByZWRpY2F0ZXMgKyBcIikgXCIgK1xyXG5cdFx0XHRcdHB0LnJ1bGVJbmRleCArIFwiOlwiICsgcHQucHJlZEluZGV4ICtcclxuXHRcdFx0XHRcIiwgY3R4IGRlcGVuZGVudD1cIiArIHB0LmlzQ3R4RGVwZW5kZW50KTtcclxuXHRcdFx0aWYgKHRoaXMuX3BhcnNlciAhPSBudWxsKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJjb250ZXh0IHN1cnJvdW5kaW5nIHByZWQgaXMgXCIgK1xyXG5cdFx0XHRcdFx0dGhpcy5fcGFyc2VyLmdldFJ1bGVJbnZvY2F0aW9uU3RhY2soKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYzogQVROQ29uZmlnO1xyXG5cdFx0aWYgKGNvbGxlY3RQcmVkaWNhdGVzICYmXHJcblx0XHRcdCghcHQuaXNDdHhEZXBlbmRlbnQgfHwgKHB0LmlzQ3R4RGVwZW5kZW50ICYmIGluQ29udGV4dCkpKSB7XHJcblx0XHRcdGxldCBuZXdTZW1DdHg6IFNlbWFudGljQ29udGV4dCA9IFNlbWFudGljQ29udGV4dC5hbmQoY29uZmlnLnNlbWFudGljQ29udGV4dCwgcHQucHJlZGljYXRlKTtcclxuXHRcdFx0YyA9IGNvbmZpZy50cmFuc2Zvcm0ocHQudGFyZ2V0LCBmYWxzZSwgbmV3U2VtQ3R4KTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRjID0gY29uZmlnLnRyYW5zZm9ybShwdC50YXJnZXQsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiY29uZmlnIGZyb20gcHJlZCB0cmFuc2l0aW9uPVwiICsgYyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYztcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIHJ1bGVUcmFuc2l0aW9uKEBOb3ROdWxsIGNvbmZpZzogQVROQ29uZmlnLCBATm90TnVsbCB0OiBSdWxlVHJhbnNpdGlvbiwgQE51bGxhYmxlIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IEFUTkNvbmZpZyB7XHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiQ0FMTCBydWxlIFwiICsgdGhpcy5nZXRSdWxlTmFtZSh0LnRhcmdldC5ydWxlSW5kZXgpICtcclxuXHRcdFx0XHRcIiwgY3R4PVwiICsgY29uZmlnLmNvbnRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZXR1cm5TdGF0ZTogQVROU3RhdGUgPSB0LmZvbGxvd1N0YXRlO1xyXG5cdFx0bGV0IG5ld0NvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0O1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGltaXplX3RhaWxfY2FsbHMgJiYgdC5vcHRpbWl6ZWRUYWlsQ2FsbCAmJiAoIXRoaXMudGFpbF9jYWxsX3ByZXNlcnZlc19zbGwgfHwgIVByZWRpY3Rpb25Db250ZXh0LmlzRW1wdHlMb2NhbChjb25maWcuY29udGV4dCkpKSB7XHJcblx0XHRcdG5ld0NvbnRleHQgPSBjb25maWcuY29udGV4dDtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGNvbnRleHRDYWNoZSAhPSBudWxsKSB7XHJcblx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0Q2FjaGUuZ2V0Q2hpbGQoY29uZmlnLmNvbnRleHQsIHJldHVyblN0YXRlLnN0YXRlTnVtYmVyKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRuZXdDb250ZXh0ID0gY29uZmlnLmNvbnRleHQuZ2V0Q2hpbGQocmV0dXJuU3RhdGUuc3RhdGVOdW1iZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb25maWcudHJhbnNmb3JtKHQudGFyZ2V0LCBmYWxzZSwgbmV3Q29udGV4dCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBTVEFURV9BTFRfU09SVF9DT01QQVJBVE9SOiAobzE6IEFUTkNvbmZpZywgbzI6IEFUTkNvbmZpZykgPT4gbnVtYmVyID1cclxuXHRcdChvMTogQVROQ29uZmlnLCBvMjogQVROQ29uZmlnKTogbnVtYmVyID0+IHtcclxuXHRcdFx0bGV0IGRpZmY6IG51bWJlciA9IG8xLnN0YXRlLm5vblN0b3BTdGF0ZU51bWJlciAtIG8yLnN0YXRlLm5vblN0b3BTdGF0ZU51bWJlcjtcclxuXHRcdFx0aWYgKGRpZmYgIT09IDApIHtcclxuXHRcdFx0XHRyZXR1cm4gZGlmZjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGlmZiA9IG8xLmFsdCAtIG8yLmFsdDtcclxuXHRcdFx0aWYgKGRpZmYgIT09IDApIHtcclxuXHRcdFx0XHRyZXR1cm4gZGlmZjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblxyXG5cdHByaXZhdGUgaXNDb25mbGljdGVkKEBOb3ROdWxsIGNvbmZpZ3NldDogQVROQ29uZmlnU2V0LCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBDb25mbGljdEluZm8gfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKGNvbmZpZ3NldC51bmlxdWVBbHQgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIgfHwgY29uZmlnc2V0LnNpemUgPD0gMSkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjb25maWdzOiBBVE5Db25maWdbXSA9IGNvbmZpZ3NldC50b0FycmF5KCk7XHJcblx0XHRjb25maWdzLnNvcnQoUGFyc2VyQVROU2ltdWxhdG9yLlNUQVRFX0FMVF9TT1JUX0NPTVBBUkFUT1IpO1xyXG5cclxuXHRcdGxldCBleGFjdDogYm9vbGVhbiA9ICFjb25maWdzZXQuZGlwc0ludG9PdXRlckNvbnRleHQ7XHJcblx0XHRsZXQgYWx0czogQml0U2V0ID0gbmV3IEJpdFNldCgpO1xyXG5cdFx0bGV0IG1pbkFsdDogbnVtYmVyID0gY29uZmlnc1swXS5hbHQ7XHJcblx0XHRhbHRzLnNldChtaW5BbHQpO1xyXG5cclxuXHRcdC8qIFF1aWNrIGNoZWNrcyBjb21lIGZpcnN0IChzaW5nbGUgcGFzcywgbm8gY29udGV4dCBqb2luaW5nKTpcclxuXHRcdCAqICAxLiBNYWtlIHN1cmUgZmlyc3QgY29uZmlnIGluIHRoZSBzb3J0ZWQgbGlzdCBwcmVkaWN0cyB0aGUgbWluaW11bVxyXG5cdFx0ICogICAgIHJlcHJlc2VudGVkIGFsdGVybmF0aXZlLlxyXG5cdFx0ICogIDIuIE1ha2Ugc3VyZSBldmVyeSByZXByZXNlbnRlZCBzdGF0ZSBoYXMgYXQgbGVhc3Qgb25lIGNvbmZpZ3VyYXRpb25cclxuXHRcdCAqICAgICB3aGljaCBwcmVkaWN0cyB0aGUgbWluaW11bSByZXByZXNlbnRlZCBhbHRlcm5hdGl2ZS5cclxuXHRcdCAqICAzLiAoZXhhY3Qgb25seSkgbWFrZSBzdXJlIGV2ZXJ5IHJlcHJlc2VudGVkIHN0YXRlIGhhcyBhdCBsZWFzdCBvbmVcclxuXHRcdCAqICAgICBjb25maWd1cmF0aW9uIHdoaWNoIHByZWRpY3RzIGVhY2ggcmVwcmVzZW50ZWQgYWx0ZXJuYXRpdmUuXHJcblx0XHQgKi9cclxuXHJcblx0XHQvLyBxdWljayBjaGVjayAxICYgMiA9PiBpZiB3ZSBhc3N1bWUgIzEgaG9sZHMgYW5kIGNoZWNrICMyIGFnYWluc3QgdGhlXHJcblx0XHQvLyBtaW5BbHQgZnJvbSB0aGUgZmlyc3Qgc3RhdGUsICMyIHdpbGwgZmFpbCBpZiB0aGUgYXNzdW1wdGlvbiB3YXNcclxuXHRcdC8vIGluY29ycmVjdFxyXG5cdFx0bGV0IGN1cnJlbnRTdGF0ZTogbnVtYmVyID0gY29uZmlnc1swXS5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXI7XHJcblx0XHRmb3IgKGxldCBjb25maWcgb2YgY29uZmlncykge1xyXG5cdFx0XHRsZXQgc3RhdGVOdW1iZXI6IG51bWJlciA9IGNvbmZpZy5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXI7XHJcblx0XHRcdGlmIChzdGF0ZU51bWJlciAhPT0gY3VycmVudFN0YXRlKSB7XHJcblx0XHRcdFx0aWYgKGNvbmZpZy5hbHQgIT09IG1pbkFsdCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRTdGF0ZSA9IHN0YXRlTnVtYmVyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJlcHJlc2VudGVkQWx0czogQml0U2V0O1xyXG5cdFx0aWYgKGV4YWN0KSB7XHJcblx0XHRcdGN1cnJlbnRTdGF0ZSA9IGNvbmZpZ3NbMF0uc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyO1xyXG5cclxuXHRcdFx0Ly8gZ2V0IHRoZSByZXByZXNlbnRlZCBhbHRlcm5hdGl2ZXMgb2YgdGhlIGZpcnN0IHN0YXRlXHJcblx0XHRcdHJlcHJlc2VudGVkQWx0cyA9IG5ldyBCaXRTZXQoKTtcclxuXHRcdFx0bGV0IG1heEFsdDogbnVtYmVyID0gbWluQWx0O1xyXG5cdFx0XHRmb3IgKGxldCBjb25maWcgb2YgY29uZmlncykge1xyXG5cdFx0XHRcdGlmIChjb25maWcuc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyICE9PSBjdXJyZW50U3RhdGUpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IGFsdDogbnVtYmVyID0gY29uZmlnLmFsdDtcclxuXHRcdFx0XHRyZXByZXNlbnRlZEFsdHMuc2V0KGFsdCk7XHJcblx0XHRcdFx0bWF4QWx0ID0gYWx0O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBxdWljayBjaGVjayAjMzpcclxuXHRcdFx0Y3VycmVudFN0YXRlID0gY29uZmlnc1swXS5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXI7XHJcblx0XHRcdGxldCBjdXJyZW50QWx0OiBudW1iZXIgPSBtaW5BbHQ7XHJcblx0XHRcdGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKSB7XHJcblx0XHRcdFx0bGV0IHN0YXRlTnVtYmVyOiBudW1iZXIgPSBjb25maWcuc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyO1xyXG5cdFx0XHRcdGxldCBhbHQ6IG51bWJlciA9IGNvbmZpZy5hbHQ7XHJcblx0XHRcdFx0aWYgKHN0YXRlTnVtYmVyICE9PSBjdXJyZW50U3RhdGUpIHtcclxuXHRcdFx0XHRcdGlmIChjdXJyZW50QWx0ICE9PSBtYXhBbHQpIHtcclxuXHRcdFx0XHRcdFx0ZXhhY3QgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y3VycmVudFN0YXRlID0gc3RhdGVOdW1iZXI7XHJcblx0XHRcdFx0XHRjdXJyZW50QWx0ID0gbWluQWx0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmIChhbHQgIT09IGN1cnJlbnRBbHQpIHtcclxuXHRcdFx0XHRcdGlmIChhbHQgIT09IHJlcHJlc2VudGVkQWx0cy5uZXh0U2V0Qml0KGN1cnJlbnRBbHQgKyAxKSkge1xyXG5cdFx0XHRcdFx0XHRleGFjdCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjdXJyZW50QWx0ID0gYWx0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGN1cnJlbnRTdGF0ZSA9IGNvbmZpZ3NbMF0uc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyO1xyXG5cdFx0bGV0IGZpcnN0SW5kZXhDdXJyZW50U3RhdGU6IG51bWJlciA9IDA7XHJcblx0XHRsZXQgbGFzdEluZGV4Q3VycmVudFN0YXRlTWluQWx0OiBudW1iZXIgPSAwO1xyXG5cdFx0bGV0IGpvaW5lZENoZWNrQ29udGV4dDogUHJlZGljdGlvbkNvbnRleHQgPSBjb25maWdzWzBdLmNvbnRleHQ7XHJcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IGNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGNvbmZpZzogQVROQ29uZmlnID0gY29uZmlnc1tpXTtcclxuXHRcdFx0aWYgKGNvbmZpZy5hbHQgIT09IG1pbkFsdCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLnN0YXRlLm5vblN0b3BTdGF0ZU51bWJlciAhPT0gY3VycmVudFN0YXRlKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxhc3RJbmRleEN1cnJlbnRTdGF0ZU1pbkFsdCA9IGk7XHJcblx0XHRcdGpvaW5lZENoZWNrQ29udGV4dCA9IGNvbnRleHRDYWNoZS5qb2luKGpvaW5lZENoZWNrQ29udGV4dCwgY29uZmlnc1tpXS5jb250ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpID0gbGFzdEluZGV4Q3VycmVudFN0YXRlTWluQWx0ICsgMTsgaSA8IGNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGNvbmZpZzogQVROQ29uZmlnID0gY29uZmlnc1tpXTtcclxuXHRcdFx0bGV0IHN0YXRlOiBBVE5TdGF0ZSA9IGNvbmZpZy5zdGF0ZTtcclxuXHRcdFx0YWx0cy5zZXQoY29uZmlnLmFsdCk7XHJcblx0XHRcdGlmIChzdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXIgIT09IGN1cnJlbnRTdGF0ZSkge1xyXG5cdFx0XHRcdGN1cnJlbnRTdGF0ZSA9IHN0YXRlLm5vblN0b3BTdGF0ZU51bWJlcjtcclxuXHRcdFx0XHRmaXJzdEluZGV4Q3VycmVudFN0YXRlID0gaTtcclxuXHRcdFx0XHRsYXN0SW5kZXhDdXJyZW50U3RhdGVNaW5BbHQgPSBpO1xyXG5cdFx0XHRcdGpvaW5lZENoZWNrQ29udGV4dCA9IGNvbmZpZy5jb250ZXh0O1xyXG5cdFx0XHRcdGZvciAobGV0IGogPSBmaXJzdEluZGV4Q3VycmVudFN0YXRlICsgMTsgaiA8IGNvbmZpZ3MubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRcdGxldCBjb25maWcyOiBBVE5Db25maWcgPSBjb25maWdzW2pdO1xyXG5cdFx0XHRcdFx0aWYgKGNvbmZpZzIuYWx0ICE9PSBtaW5BbHQpIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKGNvbmZpZzIuc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyICE9PSBjdXJyZW50U3RhdGUpIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGFzdEluZGV4Q3VycmVudFN0YXRlTWluQWx0ID0gajtcclxuXHRcdFx0XHRcdGpvaW5lZENoZWNrQ29udGV4dCA9IGNvbnRleHRDYWNoZS5qb2luKGpvaW5lZENoZWNrQ29udGV4dCwgY29uZmlnMi5jb250ZXh0KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGkgPSBsYXN0SW5kZXhDdXJyZW50U3RhdGVNaW5BbHQ7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBqb2luZWRDaGVja0NvbnRleHQyOiBQcmVkaWN0aW9uQ29udGV4dCA9IGNvbmZpZy5jb250ZXh0O1xyXG5cdFx0XHRsZXQgY3VycmVudEFsdDogbnVtYmVyID0gY29uZmlnLmFsdDtcclxuXHRcdFx0bGV0IGxhc3RJbmRleEN1cnJlbnRTdGF0ZUN1cnJlbnRBbHQ6IG51bWJlciA9IGk7XHJcblx0XHRcdGZvciAobGV0IGogPSBsYXN0SW5kZXhDdXJyZW50U3RhdGVDdXJyZW50QWx0ICsgMTsgaiA8IGNvbmZpZ3MubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRsZXQgY29uZmlnMjogQVROQ29uZmlnID0gY29uZmlnc1tqXTtcclxuXHRcdFx0XHRpZiAoY29uZmlnMi5hbHQgIT09IGN1cnJlbnRBbHQpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGNvbmZpZzIuc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyICE9PSBjdXJyZW50U3RhdGUpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGFzdEluZGV4Q3VycmVudFN0YXRlQ3VycmVudEFsdCA9IGo7XHJcblx0XHRcdFx0am9pbmVkQ2hlY2tDb250ZXh0MiA9IGNvbnRleHRDYWNoZS5qb2luKGpvaW5lZENoZWNrQ29udGV4dDIsIGNvbmZpZzIuY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGkgPSBsYXN0SW5kZXhDdXJyZW50U3RhdGVDdXJyZW50QWx0O1xyXG5cclxuXHRcdFx0bGV0IGNoZWNrOiBQcmVkaWN0aW9uQ29udGV4dCA9IGNvbnRleHRDYWNoZS5qb2luKGpvaW5lZENoZWNrQ29udGV4dCwgam9pbmVkQ2hlY2tDb250ZXh0Mik7XHJcblx0XHRcdGlmICgham9pbmVkQ2hlY2tDb250ZXh0LmVxdWFscyhjaGVjaykpIHtcclxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgZXhhY3QgaWYgbmVjZXNzYXJ5XHJcblx0XHRcdGV4YWN0ID0gZXhhY3QgJiYgam9pbmVkQ2hlY2tDb250ZXh0LmVxdWFscyhqb2luZWRDaGVja0NvbnRleHQyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IENvbmZsaWN0SW5mbyhhbHRzLCBleGFjdCk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0Q29uZmxpY3RpbmdBbHRzRnJvbUNvbmZpZ1NldChjb25maWdzOiBBVE5Db25maWdTZXQpOiBCaXRTZXQgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IGNvbmZsaWN0aW5nQWx0czogQml0U2V0IHwgdW5kZWZpbmVkID0gY29uZmlncy5jb25mbGljdGluZ0FsdHM7XHJcblx0XHRpZiAoY29uZmxpY3RpbmdBbHRzID09IG51bGwgJiYgY29uZmlncy51bmlxdWVBbHQgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuXHRcdFx0Y29uZmxpY3RpbmdBbHRzID0gbmV3IEJpdFNldCgpO1xyXG5cdFx0XHRjb25mbGljdGluZ0FsdHMuc2V0KGNvbmZpZ3MudW5pcXVlQWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29uZmxpY3RpbmdBbHRzO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0VG9rZW5OYW1lKHQ6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRpZiAodCA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdHJldHVybiBcIkVPRlwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB2b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5ID0gdGhpcy5fcGFyc2VyICE9IG51bGwgPyB0aGlzLl9wYXJzZXIudm9jYWJ1bGFyeSA6IFZvY2FidWxhcnlJbXBsLkVNUFRZX1ZPQ0FCVUxBUlk7XHJcblx0XHRsZXQgZGlzcGxheU5hbWU6IHN0cmluZyA9IHZvY2FidWxhcnkuZ2V0RGlzcGxheU5hbWUodCk7XHJcblx0XHRpZiAoZGlzcGxheU5hbWUgPT09IFN0cmluZyh0KSkge1xyXG5cdFx0XHRyZXR1cm4gZGlzcGxheU5hbWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRpc3BsYXlOYW1lICsgXCI8XCIgKyB0ICsgXCI+XCI7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0TG9va2FoZWFkTmFtZShpbnB1dDogVG9rZW5TdHJlYW0pOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VG9rZW5OYW1lKGlucHV0LkxBKDEpKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBkdW1wRGVhZEVuZENvbmZpZ3MoQE5vdE51bGwgbnZhZTogTm9WaWFibGVBbHRFeGNlcHRpb24pOiB2b2lkIHtcclxuXHRcdGNvbnNvbGUubG9nKFwiZGVhZCBlbmQgY29uZmlnczogXCIpO1xyXG5cdFx0bGV0IGRlYWRFbmRDb25maWdzID0gbnZhZS5kZWFkRW5kQ29uZmlncztcclxuXHRcdGlmICghZGVhZEVuZENvbmZpZ3MpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGMgb2YgZGVhZEVuZENvbmZpZ3MpIHtcclxuXHRcdFx0bGV0IHRyYW5zOiBzdHJpbmcgPSBcIm5vIGVkZ2VzXCI7XHJcblx0XHRcdGlmIChjLnN0YXRlLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgPiAwKSB7XHJcblx0XHRcdFx0bGV0IHQ6IFRyYW5zaXRpb24gPSBjLnN0YXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oMCk7XHJcblx0XHRcdFx0aWYgKHQgaW5zdGFuY2VvZiBBdG9tVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdFx0dHJhbnMgPSBcIkF0b20gXCIgKyB0aGlzLmdldFRva2VuTmFtZSh0Ll9sYWJlbCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHQgaW5zdGFuY2VvZiBTZXRUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0XHRsZXQgbm90OiBib29sZWFuID0gdCBpbnN0YW5jZW9mIE5vdFNldFRyYW5zaXRpb247XHJcblx0XHRcdFx0XHR0cmFucyA9IChub3QgPyBcIn5cIiA6IFwiXCIpICsgXCJTZXQgXCIgKyB0LnNldC50b1N0cmluZygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRjb25zb2xlLmxvZyhjLnRvU3RyaW5nKHRoaXMuX3BhcnNlciwgdHJ1ZSkgKyBcIjpcIiArIHRyYW5zKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIG5vVmlhYmxlQWx0KFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IFRva2VuU3RyZWFtLFxyXG5cdFx0QE5vdE51bGwgb3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCxcclxuXHRcdEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcik6IE5vVmlhYmxlQWx0RXhjZXB0aW9uIHtcclxuXHRcdHJldHVybiBuZXcgTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcy5fcGFyc2VyLCBpbnB1dCxcclxuXHRcdFx0aW5wdXQuZ2V0KHN0YXJ0SW5kZXgpLFxyXG5cdFx0XHRpbnB1dC5MVCgxKSxcclxuXHRcdFx0Y29uZmlncywgb3V0ZXJDb250ZXh0KTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRVbmlxdWVBbHQoQE5vdE51bGwgY29uZmlnczogSXRlcmFibGU8QVROQ29uZmlnPik6IG51bWJlciB7XHJcblx0XHRsZXQgYWx0OiBudW1iZXIgPSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xyXG5cdFx0Zm9yIChsZXQgYyBvZiBjb25maWdzKSB7XHJcblx0XHRcdGlmIChhbHQgPT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuXHRcdFx0XHRhbHQgPSBjLmFsdDsgLy8gZm91bmQgZmlyc3QgYWx0XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoYy5hbHQgIT09IGFsdCkge1xyXG5cdFx0XHRcdHJldHVybiBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYWx0O1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGNvbmZpZ1dpdGhBbHRBdFN0b3BTdGF0ZShATm90TnVsbCBjb25maWdzOiBJdGVyYWJsZTxBVE5Db25maWc+LCBhbHQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Zm9yIChsZXQgYyBvZiBjb25maWdzKSB7XHJcblx0XHRcdGlmIChjLmFsdCA9PT0gYWx0KSB7XHJcblx0XHRcdFx0aWYgKGMuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGFkZERGQUVkZ2UoXHJcblx0XHRATm90TnVsbCBkZmE6IERGQSxcclxuXHRcdEBOb3ROdWxsIGZyb21TdGF0ZTogREZBU3RhdGUsXHJcblx0XHR0OiBudW1iZXIsXHJcblx0XHRjb250ZXh0VHJhbnNpdGlvbnM6IEludGVnZXJMaXN0IHwgdW5kZWZpbmVkLFxyXG5cdFx0QE5vdE51bGwgdG9Db25maWdzOiBBVE5Db25maWdTZXQsXHJcblx0XHRjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBERkFTdGF0ZSB7XHJcblx0XHRhc3NlcnQoY29udGV4dFRyYW5zaXRpb25zID09IG51bGwgfHwgY29udGV4dFRyYW5zaXRpb25zLmlzRW1wdHkgfHwgZGZhLmlzQ29udGV4dFNlbnNpdGl2ZSk7XHJcblxyXG5cdFx0bGV0IGZyb206IERGQVN0YXRlID0gZnJvbVN0YXRlO1xyXG5cdFx0bGV0IHRvOiBERkFTdGF0ZSA9IHRoaXMuYWRkREZBU3RhdGUoZGZhLCB0b0NvbmZpZ3MsIGNvbnRleHRDYWNoZSk7XHJcblxyXG5cdFx0aWYgKGNvbnRleHRUcmFuc2l0aW9ucyAhPSBudWxsKSB7XHJcblx0XHRcdGZvciAobGV0IGNvbnRleHQgb2YgY29udGV4dFRyYW5zaXRpb25zLnRvQXJyYXkoKSkge1xyXG5cdFx0XHRcdGlmIChjb250ZXh0ID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSkge1xyXG5cdFx0XHRcdFx0aWYgKGZyb20uY29uZmlncy5pc091dGVybW9zdENvbmZpZ1NldCkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZyb20uc2V0Q29udGV4dFNlbnNpdGl2ZSh0aGlzLmF0bik7XHJcblx0XHRcdFx0ZnJvbS5zZXRDb250ZXh0U3ltYm9sKHQpO1xyXG5cdFx0XHRcdGxldCBuZXh0OiBERkFTdGF0ZSB8IHVuZGVmaW5lZCA9IGZyb20uZ2V0Q29udGV4dFRhcmdldChjb250ZXh0KTtcclxuXHRcdFx0XHRpZiAobmV4dCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRmcm9tID0gbmV4dDtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bmV4dCA9IHRoaXMuYWRkREZBQ29udGV4dFN0YXRlKGRmYSwgZnJvbS5jb25maWdzLCBjb250ZXh0LCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdGFzc2VydChjb250ZXh0ICE9PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSB8fCBuZXh0LmNvbmZpZ3MuaXNPdXRlcm1vc3RDb25maWdTZXQpO1xyXG5cdFx0XHRcdGZyb20uc2V0Q29udGV4dFRhcmdldChjb250ZXh0LCBuZXh0KTtcclxuXHRcdFx0XHRmcm9tID0gbmV4dDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJFREdFIFwiICsgZnJvbSArIFwiIC0+IFwiICsgdG8gKyBcIiB1cG9uIFwiICsgdGhpcy5nZXRUb2tlbk5hbWUodCkpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5zZXRERkFFZGdlKGZyb20sIHQsIHRvKTtcclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJERkE9XFxuXCIgKyBkZmEudG9TdHJpbmcodGhpcy5fcGFyc2VyICE9IG51bGwgPyB0aGlzLl9wYXJzZXIudm9jYWJ1bGFyeSA6IFZvY2FidWxhcnlJbXBsLkVNUFRZX1ZPQ0FCVUxBUlksIHRoaXMuX3BhcnNlciAhPSBudWxsID8gdGhpcy5fcGFyc2VyLnJ1bGVOYW1lcyA6IHVuZGVmaW5lZCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRvO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHNldERGQUVkZ2UoQE51bGxhYmxlIHA6IERGQVN0YXRlLCB0OiBudW1iZXIsIEBOdWxsYWJsZSBxOiBERkFTdGF0ZSk6IHZvaWQge1xyXG5cdFx0aWYgKHAgIT0gbnVsbCkge1xyXG5cdFx0XHRwLnNldFRhcmdldCh0LCBxKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBTZWUgY29tbWVudCBvbiBMZXhlckludGVycHJldGVyLmFkZERGQVN0YXRlLiAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGFkZERGQUNvbnRleHRTdGF0ZShATm90TnVsbCBkZmE6IERGQSwgQE5vdE51bGwgY29uZmlnczogQVROQ29uZmlnU2V0LCByZXR1cm5Db250ZXh0OiBudW1iZXIsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IERGQVN0YXRlIHtcclxuXHRcdGlmIChyZXR1cm5Db250ZXh0ICE9PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSkge1xyXG5cdFx0XHRsZXQgY29udGV4dENvbmZpZ3M6IEFUTkNvbmZpZ1NldCA9IG5ldyBBVE5Db25maWdTZXQoKTtcclxuXHRcdFx0Zm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpIHtcclxuXHRcdFx0XHRjb250ZXh0Q29uZmlncy5hZGQoY29uZmlnLmFwcGVuZENvbnRleHQocmV0dXJuQ29udGV4dCwgY29udGV4dENhY2hlKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmFkZERGQVN0YXRlKGRmYSwgY29udGV4dENvbmZpZ3MsIGNvbnRleHRDYWNoZSk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0YXNzZXJ0KCFjb25maWdzLmlzT3V0ZXJtb3N0Q29uZmlnU2V0LCBcIlNob3VsZG4ndCBiZSBhZGRpbmcgYSBkdXBsaWNhdGUgZWRnZS5cIik7XHJcblx0XHRcdGNvbmZpZ3MgPSBjb25maWdzLmNsb25lKHRydWUpO1xyXG5cdFx0XHRjb25maWdzLmlzT3V0ZXJtb3N0Q29uZmlnU2V0ID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkREZBU3RhdGUoZGZhLCBjb25maWdzLCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqIFNlZSBjb21tZW50IG9uIExleGVySW50ZXJwcmV0ZXIuYWRkREZBU3RhdGUuICovXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgYWRkREZBU3RhdGUoQE5vdE51bGwgZGZhOiBERkEsIEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogREZBU3RhdGUge1xyXG5cdFx0bGV0IGVuYWJsZURmYTogYm9vbGVhbiA9IHRoaXMuZW5hYmxlX2dsb2JhbF9jb250ZXh0X2RmYSB8fCAhY29uZmlncy5pc091dGVybW9zdENvbmZpZ1NldDtcclxuXHRcdGlmIChlbmFibGVEZmEpIHtcclxuXHRcdFx0aWYgKCFjb25maWdzLmlzUmVhZE9ubHkpIHtcclxuXHRcdFx0XHRjb25maWdzLm9wdGltaXplQ29uZmlncyh0aGlzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHByb3Bvc2VkOiBERkFTdGF0ZSA9IHRoaXMuY3JlYXRlREZBU3RhdGUoZGZhLCBjb25maWdzKTtcclxuXHRcdFx0bGV0IGV4aXN0aW5nOiBERkFTdGF0ZSB8IHVuZGVmaW5lZCA9IGRmYS5zdGF0ZXMuZ2V0KHByb3Bvc2VkKTtcclxuXHRcdFx0aWYgKGV4aXN0aW5nICE9IG51bGwpIHtcclxuXHRcdFx0XHRyZXR1cm4gZXhpc3Rpbmc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNvbmZpZ3MuaXNSZWFkT25seSkge1xyXG5cdFx0XHRpZiAoY29uZmlncy5jb25mbGljdEluZm8gPT0gbnVsbCkge1xyXG5cdFx0XHRcdGNvbmZpZ3MuY29uZmxpY3RJbmZvID0gdGhpcy5pc0NvbmZsaWN0ZWQoY29uZmlncywgY29udGV4dENhY2hlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBuZXdTdGF0ZTogREZBU3RhdGUgPSB0aGlzLmNyZWF0ZURGQVN0YXRlKGRmYSwgY29uZmlncy5jbG9uZSh0cnVlKSk7XHJcblx0XHQvLyBnZXREZWNpc2lvblN0YXRlIHdvbid0IHJldHVybiB1bmRlZmluZWQgd2hlbiB3ZSByZXF1ZXN0IGEga25vd24gdmFsaWQgZGVjaXNpb25cclxuXHRcdGxldCBkZWNpc2lvblN0YXRlOiBEZWNpc2lvblN0YXRlID0gdGhpcy5hdG4uZ2V0RGVjaXNpb25TdGF0ZShkZmEuZGVjaXNpb24pIGFzIERlY2lzaW9uU3RhdGU7XHJcblx0XHRsZXQgcHJlZGljdGVkQWx0OiBudW1iZXIgPSB0aGlzLmdldFVuaXF1ZUFsdChjb25maWdzKTtcclxuXHRcdGlmIChwcmVkaWN0ZWRBbHQgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuXHRcdFx0bmV3U3RhdGUuYWNjZXB0U3RhdGVJbmZvID0gbmV3IEFjY2VwdFN0YXRlSW5mbyhwcmVkaWN0ZWRBbHQpO1xyXG5cdFx0fSBlbHNlIGlmIChjb25maWdzLmNvbmZsaWN0aW5nQWx0cyAhPSBudWxsKSB7XHJcblx0XHRcdGxldCBjb25mbGljdGluZ0FsdHMgPSBjb25maWdzLmNvbmZsaWN0aW5nQWx0cztcclxuXHRcdFx0aWYgKGNvbmZsaWN0aW5nQWx0cykge1xyXG5cdFx0XHRcdG5ld1N0YXRlLmFjY2VwdFN0YXRlSW5mbyA9IG5ldyBBY2NlcHRTdGF0ZUluZm8oY29uZmxpY3RpbmdBbHRzLm5leHRTZXRCaXQoMCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1N0YXRlLmlzQWNjZXB0U3RhdGUgJiYgY29uZmlncy5oYXNTZW1hbnRpY0NvbnRleHQpIHtcclxuXHRcdFx0dGhpcy5wcmVkaWNhdGVERkFTdGF0ZShuZXdTdGF0ZSwgY29uZmlncywgZGVjaXNpb25TdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWVuYWJsZURmYSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3U3RhdGU7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGFkZGVkOiBERkFTdGF0ZSA9IGRmYS5hZGRTdGF0ZShuZXdTdGF0ZSk7XHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnICYmIGFkZGVkID09PSBuZXdTdGF0ZSkge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcImFkZGluZyBuZXcgREZBIHN0YXRlOiBcIiArIG5ld1N0YXRlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhZGRlZDtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGNyZWF0ZURGQVN0YXRlKEBOb3ROdWxsIGRmYTogREZBLCBATm90TnVsbCBjb25maWdzOiBBVE5Db25maWdTZXQpOiBERkFTdGF0ZSB7XHJcblx0XHRyZXR1cm4gbmV3IERGQVN0YXRlKGNvbmZpZ3MpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dChATm90TnVsbCBkZmE6IERGQSwgY29uZmxpY3RpbmdBbHRzOiBCaXRTZXQgfCB1bmRlZmluZWQsIEBOb3ROdWxsIGNvbmZsaWN0U3RhdGU6IFNpbXVsYXRvclN0YXRlLCBzdGFydEluZGV4OiBudW1iZXIsIHN0b3BJbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnIHx8IFBhcnNlckFUTlNpbXVsYXRvci5yZXRyeV9kZWJ1Zykge1xyXG5cdFx0XHRsZXQgaW50ZXJ2YWw6IEludGVydmFsID0gSW50ZXJ2YWwub2Yoc3RhcnRJbmRleCwgc3RvcEluZGV4KTtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJyZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQgZGVjaXNpb249XCIgKyBkZmEuZGVjaXNpb24gKyBcIjpcIiArIGNvbmZsaWN0U3RhdGUuczAuY29uZmlncyArXHJcblx0XHRcdFx0XCIsIGlucHV0PVwiICsgdGhpcy5fcGFyc2VyLmlucHV0U3RyZWFtLmdldFRleHQoaW50ZXJ2YWwpKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9wYXJzZXIgIT0gbnVsbCkge1xyXG5cdFx0XHRsZXQgbGlzdGVuZXIgPSB0aGlzLl9wYXJzZXIuZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCk7XHJcblx0XHRcdGlmIChsaXN0ZW5lci5yZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQpIHtcclxuXHRcdFx0XHRsaXN0ZW5lci5yZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQodGhpcy5fcGFyc2VyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgY29uZmxpY3RpbmdBbHRzLCBjb25mbGljdFN0YXRlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHJlcG9ydENvbnRleHRTZW5zaXRpdml0eShATm90TnVsbCBkZmE6IERGQSwgcHJlZGljdGlvbjogbnVtYmVyLCBATm90TnVsbCBhY2NlcHRTdGF0ZTogU2ltdWxhdG9yU3RhdGUsIHN0YXJ0SW5kZXg6IG51bWJlciwgc3RvcEluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcgfHwgUGFyc2VyQVROU2ltdWxhdG9yLnJldHJ5X2RlYnVnKSB7XHJcblx0XHRcdGxldCBpbnRlcnZhbDogSW50ZXJ2YWwgPSBJbnRlcnZhbC5vZihzdGFydEluZGV4LCBzdG9wSW5kZXgpO1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcInJlcG9ydENvbnRleHRTZW5zaXRpdml0eSBkZWNpc2lvbj1cIiArIGRmYS5kZWNpc2lvbiArIFwiOlwiICsgYWNjZXB0U3RhdGUuczAuY29uZmlncyArXHJcblx0XHRcdFx0XCIsIGlucHV0PVwiICsgdGhpcy5fcGFyc2VyLmlucHV0U3RyZWFtLmdldFRleHQoaW50ZXJ2YWwpKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9wYXJzZXIgIT0gbnVsbCkge1xyXG5cdFx0XHRsZXQgbGlzdGVuZXIgPSB0aGlzLl9wYXJzZXIuZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCk7XHJcblx0XHRcdGlmIChsaXN0ZW5lci5yZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkpIHtcclxuXHRcdFx0XHRsaXN0ZW5lci5yZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkodGhpcy5fcGFyc2VyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgcHJlZGljdGlvbiwgYWNjZXB0U3RhdGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogSWYgY29udGV4dCBzZW5zaXRpdmUgcGFyc2luZywgd2Uga25vdyBpdCdzIGFtYmlndWl0eSBub3QgY29uZmxpY3QgKi9cclxuXHRwcm90ZWN0ZWQgcmVwb3J0QW1iaWd1aXR5KFxyXG5cdFx0QE5vdE51bGwgZGZhOiBERkEsXHJcblx0XHREOiBERkFTdGF0ZSwgIC8vIHRoZSBERkEgc3RhdGUgZnJvbSBleGVjQVROKCk6IHZvaWQgdGhhdCBoYWQgU0xMIGNvbmZsaWN0c1xyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyLFxyXG5cdFx0c3RvcEluZGV4OiBudW1iZXIsXHJcblx0XHRleGFjdDogYm9vbGVhbixcclxuXHRcdEBOb3ROdWxsIGFtYmlnQWx0czogQml0U2V0LFxyXG5cdFx0QE5vdE51bGwgY29uZmlnczogQVROQ29uZmlnU2V0KSAvLyBjb25maWdzIHRoYXQgTEwgbm90IFNMTCBjb25zaWRlcmVkIGNvbmZsaWN0aW5nXHJcblx0e1xyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1ZyB8fCBQYXJzZXJBVE5TaW11bGF0b3IucmV0cnlfZGVidWcpIHtcclxuXHRcdFx0bGV0IGludGVydmFsOiBJbnRlcnZhbCA9IEludGVydmFsLm9mKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCk7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwicmVwb3J0QW1iaWd1aXR5IFwiICtcclxuXHRcdFx0XHRhbWJpZ0FsdHMgKyBcIjpcIiArIGNvbmZpZ3MgK1xyXG5cdFx0XHRcdFwiLCBpbnB1dD1cIiArIHRoaXMuX3BhcnNlci5pbnB1dFN0cmVhbS5nZXRUZXh0KGludGVydmFsKSk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fcGFyc2VyICE9IG51bGwpIHtcclxuXHRcdFx0bGV0IGxpc3RlbmVyID0gdGhpcy5fcGFyc2VyLmdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCgpO1xyXG5cdFx0XHRpZiAobGlzdGVuZXIucmVwb3J0QW1iaWd1aXR5KSB7XHJcblx0XHRcdFx0bGlzdGVuZXIucmVwb3J0QW1iaWd1aXR5KHRoaXMuX3BhcnNlciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGV4YWN0LCBhbWJpZ0FsdHMsIGNvbmZpZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0UmV0dXJuU3RhdGUoY29udGV4dDogUnVsZUNvbnRleHQpOiBudW1iZXIge1xyXG5cdFx0aWYgKGNvbnRleHQuaXNFbXB0eSkge1xyXG5cdFx0XHRyZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHN0YXRlOiBBVE5TdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tjb250ZXh0Lmludm9raW5nU3RhdGVdO1xyXG5cdFx0bGV0IHRyYW5zaXRpb246IFJ1bGVUcmFuc2l0aW9uID0gc3RhdGUudHJhbnNpdGlvbigwKSBhcyBSdWxlVHJhbnNpdGlvbjtcclxuXHRcdHJldHVybiB0cmFuc2l0aW9uLmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHNraXBUYWlsQ2FsbHMoY29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQpOiBQYXJzZXJSdWxlQ29udGV4dCB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW1pemVfdGFpbF9jYWxscykge1xyXG5cdFx0XHRyZXR1cm4gY29udGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHR3aGlsZSAoIWNvbnRleHQuaXNFbXB0eSkge1xyXG5cdFx0XHRsZXQgc3RhdGU6IEFUTlN0YXRlID0gdGhpcy5hdG4uc3RhdGVzW2NvbnRleHQuaW52b2tpbmdTdGF0ZV07XHJcblx0XHRcdGFzc2VydChzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zID09PSAxICYmIHN0YXRlLnRyYW5zaXRpb24oMCkuc2VyaWFsaXphdGlvblR5cGUgPT09IFRyYW5zaXRpb25UeXBlLlJVTEUpO1xyXG5cdFx0XHRsZXQgdHJhbnNpdGlvbjogUnVsZVRyYW5zaXRpb24gPSBzdGF0ZS50cmFuc2l0aW9uKDApIGFzIFJ1bGVUcmFuc2l0aW9uO1xyXG5cdFx0XHRpZiAoIXRyYW5zaXRpb24udGFpbENhbGwpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVGhpcyBtZXRob2QgcmVxdWlyZXMgdGhhdCB0aGUgcm9vdCBhbmNlc3RvciBvZiB0aGUgUGFyc2VyUnVsZUNvbnRleHQgYmUgZW1wdHkuIElmIHdlIG1ha2UgaXQgdG8gdGhpc1xyXG5cdFx0XHQvLyBsaW5lLCB3ZSBrbm93IHRoZSBjdXJyZW50IG5vZGUgaXMgbm90IGVtcHR5LCB3aGljaCBtZWFucyBpdCBkb2VzIGhhdmUgYSBwYXJlbnQuXHJcblx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudCBhcyBQYXJzZXJSdWxlQ29udGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29udGV4dDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBzaW5jZSA0LjNcclxuXHQgKi9cclxuXHRnZXQgcGFyc2VyKCk6IFBhcnNlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFyc2VyO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzQuOTU3MjE0Mi0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IEJsb2NrU3RhcnRTdGF0ZSB9IGZyb20gXCIuL0Jsb2NrU3RhcnRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBsdXNMb29wYmFja1N0YXRlIH0gZnJvbSBcIi4vUGx1c0xvb3BiYWNrU3RhdGVcIjtcclxuXHJcbi8qKiBTdGFydCBvZiBgKEF8QnwuLi4pK2AgbG9vcC4gVGVjaG5pY2FsbHkgYSBkZWNpc2lvbiBzdGF0ZSwgYnV0XHJcbiAqICB3ZSBkb24ndCB1c2UgZm9yIGNvZGUgZ2VuZXJhdGlvbjsgc29tZWJvZHkgbWlnaHQgbmVlZCBpdCwgc28gSSdtIGRlZmluaW5nXHJcbiAqICBpdCBmb3IgY29tcGxldGVuZXNzLiBJbiByZWFsaXR5LCB0aGUge0BsaW5rIFBsdXNMb29wYmFja1N0YXRlfSBub2RlIGlzIHRoZVxyXG4gKiAgcmVhbCBkZWNpc2lvbi1tYWtpbmcgbm90ZSBmb3IgYEErYC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQbHVzQmxvY2tTdGFydFN0YXRlIGV4dGVuZHMgQmxvY2tTdGFydFN0YXRlIHtcclxuXHQvLyBUaGlzIGlzIGFsd2F5cyBzZXQgZHVyaW5nIEFUTiBkZXNlcmlhbGl6YXRpb25cclxuXHRwdWJsaWMgbG9vcEJhY2tTdGF0ZSE6IFBsdXNMb29wYmFja1N0YXRlO1xyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhdGVUeXBlKCk6IEFUTlN0YXRlVHlwZSB7XHJcblx0XHRyZXR1cm4gQVROU3RhdGVUeXBlLlBMVVNfQkxPQ0tfU1RBUlQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNS4wMjU3NzMwLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZVR5cGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVR5cGVcIjtcclxuaW1wb3J0IHsgRGVjaXNpb25TdGF0ZSB9IGZyb20gXCIuL0RlY2lzaW9uU3RhdGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqIERlY2lzaW9uIHN0YXRlIGZvciBgQStgIGFuZCBgKEF8QikrYC4gIEl0IGhhcyB0d28gdHJhbnNpdGlvbnM6XHJcbiAqICBvbmUgdG8gdGhlIGxvb3AgYmFjayB0byBzdGFydCBvZiB0aGUgYmxvY2sgYW5kIG9uZSB0byBleGl0LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBsdXNMb29wYmFja1N0YXRlIGV4dGVuZHMgRGVjaXNpb25TdGF0ZSB7XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdGF0ZVR5cGUoKTogQVROU3RhdGVUeXBlIHtcclxuXHRcdHJldHVybiBBVE5TdGF0ZVR5cGUuUExVU19MT09QX0JBQ0s7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNS4wOTk0MTkxLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9BYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFNlbWFudGljQ29udGV4dCB9IGZyb20gXCIuL1NlbWFudGljQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uIGV4dGVuZHMgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uIHtcclxuXHRwdWJsaWMgcHJlY2VkZW5jZTogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvciggQE5vdE51bGwgdGFyZ2V0OiBBVE5TdGF0ZSwgcHJlY2VkZW5jZTogbnVtYmVyKSB7XHJcblx0XHRzdXBlcih0YXJnZXQpO1xyXG5cdFx0dGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzZXJpYWxpemF0aW9uVHlwZSgpOiBUcmFuc2l0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gVHJhbnNpdGlvblR5cGUuUFJFQ0VERU5DRTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc0Vwc2lsb24oKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBtYXRjaGVzKHN5bWJvbDogbnVtYmVyLCBtaW5Wb2NhYlN5bWJvbDogbnVtYmVyLCBtYXhWb2NhYlN5bWJvbDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRnZXQgcHJlZGljYXRlKCk6IFNlbWFudGljQ29udGV4dC5QcmVjZWRlbmNlUHJlZGljYXRlIHtcclxuXHRcdHJldHVybiBuZXcgU2VtYW50aWNDb250ZXh0LlByZWNlZGVuY2VQcmVkaWNhdGUodGhpcy5wcmVjZWRlbmNlKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJlY2VkZW5jZSArIFwiID49IF9wXCI7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNi41OTU5OTgwLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEludGVydmFsU2V0IH0gZnJvbSBcIi4uL21pc2MvSW50ZXJ2YWxTZXRcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUsIE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUmFuZ2VUcmFuc2l0aW9uIGV4dGVuZHMgVHJhbnNpdGlvbiB7XHJcblx0cHVibGljIGZyb206IG51bWJlcjtcclxuXHRwdWJsaWMgdG86IG51bWJlcjtcclxuXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgdGFyZ2V0OiBBVE5TdGF0ZSwgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKSB7XHJcblx0XHRzdXBlcih0YXJnZXQpO1xyXG5cdFx0dGhpcy5mcm9tID0gZnJvbTtcclxuXHRcdHRoaXMudG8gPSB0bztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzZXJpYWxpemF0aW9uVHlwZSgpOiBUcmFuc2l0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gVHJhbnNpdGlvblR5cGUuUkFOR0U7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRATm90TnVsbFxyXG5cdGdldCBsYWJlbCgpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRyZXR1cm4gSW50ZXJ2YWxTZXQub2YodGhpcy5mcm9tLCB0aGlzLnRvKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBtYXRjaGVzKHN5bWJvbDogbnVtYmVyLCBtaW5Wb2NhYlN5bWJvbDogbnVtYmVyLCBtYXhWb2NhYlN5bWJvbDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gc3ltYm9sID49IHRoaXMuZnJvbSAmJiBzeW1ib2wgPD0gdGhpcy50bztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCInXCIgKyBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLmZyb20pICsgXCInLi4nXCIgKyBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLnRvKSArIFwiJ1wiO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzYuNjgwNjg1MS0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZVR5cGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVR5cGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBSdWxlU3RvcFN0YXRlIH0gZnJvbSBcIi4vUnVsZVN0b3BTdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFJ1bGVTdGFydFN0YXRlIGV4dGVuZHMgQVROU3RhdGUge1xyXG5cdC8vIFRoaXMgaXMgYWx3YXlzIHNldCBkdXJpbmcgQVROIGRlc2VyaWFsaXphdGlvblxyXG5cdHB1YmxpYyBzdG9wU3RhdGUhOiBSdWxlU3RvcFN0YXRlO1xyXG5cdHB1YmxpYyBpc1ByZWNlZGVuY2VSdWxlOiBib29sZWFuID0gZmFsc2U7XHJcblx0cHVibGljIGxlZnRGYWN0b3JlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhdGVUeXBlKCk6IEFUTlN0YXRlVHlwZSB7XHJcblx0XHRyZXR1cm4gQVROU3RhdGVUeXBlLlJVTEVfU1RBUlQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNy41NjU3NDA5LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlVHlwZSB9IGZyb20gXCIuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBCbG9ja1N0YXJ0U3RhdGUgfSBmcm9tIFwiLi9CbG9ja1N0YXJ0U3RhdGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqIFRoZSBibG9jayB0aGF0IGJlZ2lucyBhIGNsb3N1cmUgbG9vcC4gKi9cclxuZXhwb3J0IGNsYXNzIFN0YXJCbG9ja1N0YXJ0U3RhdGUgZXh0ZW5kcyBCbG9ja1N0YXJ0U3RhdGUge1xyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhdGVUeXBlKCk6IEFUTlN0YXRlVHlwZSB7XHJcblx0XHRyZXR1cm4gQVROU3RhdGVUeXBlLlNUQVJfQkxPQ0tfU1RBUlQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNy42MzY4NzI2LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlVHlwZSB9IGZyb20gXCIuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFN0YXJMb29wRW50cnlTdGF0ZSB9IGZyb20gXCIuL1N0YXJMb29wRW50cnlTdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFN0YXJMb29wYmFja1N0YXRlIGV4dGVuZHMgQVROU3RhdGUge1xyXG5cdGdldCBsb29wRW50cnlTdGF0ZSgpOiBTdGFyTG9vcEVudHJ5U3RhdGUge1xyXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNpdGlvbigwKS50YXJnZXQgYXMgU3Rhckxvb3BFbnRyeVN0YXRlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHN0YXRlVHlwZSgpOiBBVE5TdGF0ZVR5cGUge1xyXG5cdFx0cmV0dXJuIEFUTlN0YXRlVHlwZS5TVEFSX0xPT1BfQkFDSztcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM3Ljc4MTQwNDYtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlVHlwZSB9IGZyb20gXCIuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBEZWNpc2lvblN0YXRlIH0gZnJvbSBcIi4vRGVjaXNpb25TdGF0ZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKiogVGhlIFRva2VucyBydWxlIHN0YXJ0IHN0YXRlIGxpbmtpbmcgdG8gZWFjaCBsZXhlciBydWxlIHN0YXJ0IHN0YXRlICovXHJcbmV4cG9ydCBjbGFzcyBUb2tlbnNTdGFydFN0YXRlIGV4dGVuZHMgRGVjaXNpb25TdGF0ZSB7XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdGF0ZVR5cGUoKTogQVROU3RhdGVUeXBlIHtcclxuXHRcdHJldHVybiBBVE5TdGF0ZVR5cGUuVE9LRU5fU1RBUlQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEVxdWF0YWJsZSB9IGZyb20gXCIuL1N0dWJzXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi9NdXJtdXJIYXNoXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVVVJRCBpbXBsZW1lbnRzIEVxdWF0YWJsZSB7XHJcblx0cHJpdmF0ZSByZWFkb25seSBkYXRhOiBVaW50MzJBcnJheTtcclxuXHJcblx0Y29uc3RydWN0b3IobW9zdFNpZ0JpdHM6IG51bWJlciwgbW9yZVNpZ0JpdHM6IG51bWJlciwgbGVzc1NpZ0JpdHM6IG51bWJlciwgbGVhc3RTaWdCaXRzOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuZGF0YSA9IG5ldyBVaW50MzJBcnJheSg0KTtcclxuXHRcdHRoaXMuZGF0YVswXSA9IG1vc3RTaWdCaXRzO1xyXG5cdFx0dGhpcy5kYXRhWzFdID0gbW9yZVNpZ0JpdHM7XHJcblx0XHR0aGlzLmRhdGFbMl0gPSBsZXNzU2lnQml0cztcclxuXHRcdHRoaXMuZGF0YVszXSA9IGxlYXN0U2lnQml0cztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZnJvbVN0cmluZyhkYXRhOiBzdHJpbmcpOiBVVUlEIHtcclxuXHRcdGlmICghL15bYS1mQS1GMC05XXs4fS1bYS1mQS1GMC05XXs0fS1bYS1mQS1GMC05XXs0fS1bYS1mQS1GMC05XXs0fS1bYS1mQS1GMC05XXsxMn0kLy50ZXN0KGRhdGEpKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdGx5IGZvcm1hdHRlZCBVVUlEXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBzZWdtZW50cyA9IGRhdGEuc3BsaXQoXCItXCIpO1xyXG5cdFx0bGV0IG1vc3RTaWdCaXRzID0gcGFyc2VJbnQoc2VnbWVudHNbMF0sIDE2KTtcclxuXHRcdGxldCBtb3JlU2lnQml0cyA9ICgocGFyc2VJbnQoc2VnbWVudHNbMV0sIDE2KSA8PCAxNikgPj4+IDApICsgcGFyc2VJbnQoc2VnbWVudHNbMl0sIDE2KTtcclxuXHRcdGxldCBsZXNzU2lnQml0cyA9ICgocGFyc2VJbnQoc2VnbWVudHNbM10sIDE2KSA8PCAxNikgPj4+IDApICsgcGFyc2VJbnQoc2VnbWVudHNbNF0uc3Vic3RyKDAsIDQpLCAxNik7XHJcblx0XHRsZXQgbGVhc3RTaWdCaXRzID0gcGFyc2VJbnQoc2VnbWVudHNbNF0uc3Vic3RyKC04KSwgMTYpO1xyXG5cdFx0cmV0dXJuIG5ldyBVVUlEKG1vc3RTaWdCaXRzLCBtb3JlU2lnQml0cywgbGVzc1NpZ0JpdHMsIGxlYXN0U2lnQml0cyk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBNdXJtdXJIYXNoLmhhc2hDb2RlKFt0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdLCB0aGlzLmRhdGFbM11dKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChvYmogPT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgVVVJRCkpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmRhdGFbMF0gPT09IG9iai5kYXRhWzBdXHJcblx0XHRcdCYmIHRoaXMuZGF0YVsxXSA9PT0gb2JqLmRhdGFbMV1cclxuXHRcdFx0JiYgdGhpcy5kYXRhWzJdID09PSBvYmouZGF0YVsyXVxyXG5cdFx0XHQmJiB0aGlzLmRhdGFbM10gPT09IG9iai5kYXRhWzNdO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gKFwiMDAwMDAwMDBcIiArIHRoaXMuZGF0YVswXS50b1N0cmluZygxNikpLnN1YnN0cigtOClcclxuXHRcdFx0KyBcIi1cIiArIChcIjAwMDBcIiArICh0aGlzLmRhdGFbMV0gPj4+IDE2KS50b1N0cmluZygxNikpLnN1YnN0cigtNClcclxuXHRcdFx0KyBcIi1cIiArIChcIjAwMDBcIiArIHRoaXMuZGF0YVsxXS50b1N0cmluZygxNikpLnN1YnN0cigtNClcclxuXHRcdFx0KyBcIi1cIiArIChcIjAwMDBcIiArICh0aGlzLmRhdGFbMl0gPj4+IDE2KS50b1N0cmluZygxNikpLnN1YnN0cigtNClcclxuXHRcdFx0KyBcIi1cIiArIChcIjAwMDBcIiArIHRoaXMuZGF0YVsyXS50b1N0cmluZygxNikpLnN1YnN0cigtNClcclxuXHRcdFx0KyAoXCIwMDAwMDAwMFwiICsgdGhpcy5kYXRhWzNdLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC04KTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI1Ljk2ODM0NDctMDc6MDBcclxuXHJcbmltcG9ydCB7IEFjdGlvblRyYW5zaXRpb24gfSBmcm9tIFwiLi9BY3Rpb25UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IEFycmF5MkRIYXNoU2V0IH0gZnJvbSBcIi4uL21pc2MvQXJyYXkyREhhc2hTZXRcIjtcclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vQVROXCI7XHJcbmltcG9ydCB7IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMgfSBmcm9tIFwiLi9BVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IEFUTlR5cGUgfSBmcm9tIFwiLi9BVE5UeXBlXCI7XHJcbmltcG9ydCB7IEF0b21UcmFuc2l0aW9uIH0gZnJvbSBcIi4vQXRvbVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgQmFzaWNCbG9ja1N0YXJ0U3RhdGUgfSBmcm9tIFwiLi9CYXNpY0Jsb2NrU3RhcnRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBCYXNpY1N0YXRlIH0gZnJvbSBcIi4vQmFzaWNTdGF0ZVwiO1xyXG5pbXBvcnQgeyBCaXRTZXQgfSBmcm9tIFwiLi4vbWlzYy9CaXRTZXRcIjtcclxuaW1wb3J0IHsgQmxvY2tFbmRTdGF0ZSB9IGZyb20gXCIuL0Jsb2NrRW5kU3RhdGVcIjtcclxuaW1wb3J0IHsgQmxvY2tTdGFydFN0YXRlIH0gZnJvbSBcIi4vQmxvY2tTdGFydFN0YXRlXCI7XHJcbmltcG9ydCB7IERlY2lzaW9uU3RhdGUgfSBmcm9tIFwiLi9EZWNpc2lvblN0YXRlXCI7XHJcbmltcG9ydCB7IERGQSB9IGZyb20gXCIuLi9kZmEvREZBXCI7XHJcbmltcG9ydCB7IEVwc2lsb25UcmFuc2l0aW9uIH0gZnJvbSBcIi4vRXBzaWxvblRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbFNldCB9IGZyb20gXCIuLi9taXNjL0ludGVydmFsU2V0XCI7XHJcbmltcG9ydCB7IEludmFsaWRTdGF0ZSB9IGZyb20gXCIuL0ludmFsaWRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvbiB9IGZyb20gXCIuL0xleGVyQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uVHlwZSB9IGZyb20gXCIuL0xleGVyQWN0aW9uVHlwZVwiO1xyXG5pbXBvcnQgeyBMZXhlckNoYW5uZWxBY3Rpb24gfSBmcm9tIFwiLi9MZXhlckNoYW5uZWxBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJDdXN0b21BY3Rpb24gfSBmcm9tIFwiLi9MZXhlckN1c3RvbUFjdGlvblwiO1xyXG5pbXBvcnQgeyBMZXhlck1vZGVBY3Rpb24gfSBmcm9tIFwiLi9MZXhlck1vZGVBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJNb3JlQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJNb3JlQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyUG9wTW9kZUFjdGlvbiB9IGZyb20gXCIuL0xleGVyUG9wTW9kZUFjdGlvblwiO1xyXG5pbXBvcnQgeyBMZXhlclB1c2hNb2RlQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJQdXNoTW9kZUFjdGlvblwiO1xyXG5pbXBvcnQgeyBMZXhlclNraXBBY3Rpb24gfSBmcm9tIFwiLi9MZXhlclNraXBBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJUeXBlQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJUeXBlQWN0aW9uXCI7XHJcbmltcG9ydCB7IExvb3BFbmRTdGF0ZSB9IGZyb20gXCIuL0xvb3BFbmRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgTm90U2V0VHJhbnNpdGlvbiB9IGZyb20gXCIuL05vdFNldFRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgUGFyc2VyQVROU2ltdWxhdG9yIH0gZnJvbSBcIi4vUGFyc2VyQVROU2ltdWxhdG9yXCI7XHJcbmltcG9ydCB7IFBsdXNCbG9ja1N0YXJ0U3RhdGUgfSBmcm9tIFwiLi9QbHVzQmxvY2tTdGFydFN0YXRlXCI7XHJcbmltcG9ydCB7IFBsdXNMb29wYmFja1N0YXRlIH0gZnJvbSBcIi4vUGx1c0xvb3BiYWNrU3RhdGVcIjtcclxuaW1wb3J0IHsgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9QcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBQcmVkaWNhdGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vUHJlZGljYXRlVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBSYW5nZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9SYW5nZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgUnVsZVN0YXJ0U3RhdGUgfSBmcm9tIFwiLi9SdWxlU3RhcnRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBSdWxlU3RvcFN0YXRlIH0gZnJvbSBcIi4vUnVsZVN0b3BTdGF0ZVwiO1xyXG5pbXBvcnQgeyBSdWxlVHJhbnNpdGlvbiB9IGZyb20gXCIuL1J1bGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFNldFRyYW5zaXRpb24gfSBmcm9tIFwiLi9TZXRUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFN0YXJCbG9ja1N0YXJ0U3RhdGUgfSBmcm9tIFwiLi9TdGFyQmxvY2tTdGFydFN0YXRlXCI7XHJcbmltcG9ydCB7IFN0YXJMb29wYmFja1N0YXRlIH0gZnJvbSBcIi4vU3Rhckxvb3BiYWNrU3RhdGVcIjtcclxuaW1wb3J0IHsgU3Rhckxvb3BFbnRyeVN0YXRlIH0gZnJvbSBcIi4vU3Rhckxvb3BFbnRyeVN0YXRlXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4uL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2Vuc1N0YXJ0U3RhdGUgfSBmcm9tIFwiLi9Ub2tlbnNTdGFydFN0YXRlXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tIFwiLi9UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25UeXBlIH0gZnJvbSBcIi4vVHJhbnNpdGlvblR5cGVcIjtcclxuaW1wb3J0IHsgVVVJRCB9IGZyb20gXCIuLi9taXNjL1VVSURcIjtcclxuaW1wb3J0IHsgV2lsZGNhcmRUcmFuc2l0aW9uIH0gZnJvbSBcIi4vV2lsZGNhcmRUcmFuc2l0aW9uXCI7XHJcblxyXG5pbnRlcmZhY2UgVW5pY29kZURlc2VyaWFsaXplciB7XHJcblx0Ly8gV3JhcHBlciBmb3IgcmVhZEludCgpIG9yIHJlYWRJbnQzMigpXHJcblx0cmVhZFVuaWNvZGUoZGF0YTogVWludDE2QXJyYXksIHA6IG51bWJlcik6IG51bWJlcjtcclxuXHJcblx0Ly8gV29yayBhcm91bmQgSmF2YSBub3QgYWxsb3dpbmcgbXV0YXRpb24gb2YgY2FwdHVyZWQgdmFyaWFibGVzXHJcblx0Ly8gYnkgcmV0dXJuaW5nIGFtb3VudCBieSB3aGljaCB0byBpbmNyZW1lbnQgcCBhZnRlciBlYWNoIHJlYWRcclxuXHRyZWFkb25seSBzaXplOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IGVudW0gVW5pY29kZURlc2VyaWFsaXppbmdNb2RlIHtcclxuXHRVTklDT0RFX0JNUCxcclxuXHRVTklDT0RFX1NNUCxcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBVE5EZXNlcmlhbGl6ZXIge1xyXG5cdHN0YXRpYyBnZXQgU0VSSUFMSVpFRF9WRVJTSU9OKCk6IG51bWJlciB7XHJcblx0XHQvKiBUaGlzIHZhbHVlIHNob3VsZCBuZXZlciBjaGFuZ2UuIFVwZGF0ZXMgZm9sbG93aW5nIHRoaXMgdmVyc2lvbiBhcmVcclxuXHRcdCAqIHJlZmxlY3RlZCBhcyBjaGFuZ2UgaW4gdGhlIHVuaXF1ZSBJRCBTRVJJQUxJWkVEX1VVSUQuXHJcblx0XHQgKi9cclxuXHRcdHJldHVybiAzO1xyXG5cdH1cclxuXHJcblx0LyogV0FSTklORzogRE8gTk9UIE1FUkdFIFRIRVNFIExJTkVTLiBJZiBVVUlEcyBkaWZmZXIgZHVyaW5nIGEgbWVyZ2UsXHJcblx0ICogcmVzb2x2ZSB0aGUgY29uZmxpY3QgYnkgZ2VuZXJhdGluZyBhIG5ldyBJRCFcclxuXHQgKi9cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgZWFybGllc3Qgc3VwcG9ydGVkIHNlcmlhbGl6ZWQgVVVJRC5cclxuXHQgKi9cclxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBCQVNFX1NFUklBTElaRURfVVVJRDogVVVJRCA9IFVVSUQuZnJvbVN0cmluZyhcIkU0MTc4NDY4LURGOTUtNDREMC1BRDg3LUYyMkE1RDVGQjZEM1wiKTtcclxuXHQvKipcclxuXHQgKiBUaGlzIFVVSUQgaW5kaWNhdGVzIGFuIGV4dGVuc2lvbiBvZiB7QGxpbmsgI0FEREVEX1BSRUNFREVOQ0VfVFJBTlNJVElPTlN9XHJcblx0ICogZm9yIHRoZSBhZGRpdGlvbiBvZiBsZXhlciBhY3Rpb25zIGVuY29kZWQgYXMgYSBzZXF1ZW5jZSBvZlxyXG5cdCAqIHtAbGluayBMZXhlckFjdGlvbn0gaW5zdGFuY2VzLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEFEREVEX0xFWEVSX0FDVElPTlM6IFVVSUQgPSBVVUlELmZyb21TdHJpbmcoXCJBQjM1MTkxQS0xNjAzLTQ4N0UtQjc1QS00NzlCODMxRUFGNkRcIik7XHJcblx0LyoqXHJcblx0ICogVGhpcyBVVUlEIGluZGljYXRlcyB0aGUgc2VyaWFsaXplZCBBVE4gY29udGFpbnMgdHdvIHNldHMgb2ZcclxuXHQgKiBJbnRlcnZhbFNldHMsIHdoZXJlIHRoZSBzZWNvbmQgc2V0J3MgdmFsdWVzIGFyZSBlbmNvZGVkIGFzXHJcblx0ICogMzItYml0IGludGVnZXJzIHRvIHN1cHBvcnQgdGhlIGZ1bGwgVW5pY29kZSBTTVAgcmFuZ2UgdXAgdG8gVSsxMEZGRkYuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQURERURfVU5JQ09ERV9TTVA6IFVVSUQgPSBVVUlELmZyb21TdHJpbmcoXCJDMjNGRUE4OS0wNjA1LTRmNTEtQUZCOC0wNThCQ0FCOEM5MUJcIik7XHJcblx0LyoqXHJcblx0ICogVGhpcyBsaXN0IGNvbnRhaW5zIGFsbCBvZiB0aGUgY3VycmVudGx5IHN1cHBvcnRlZCBVVUlEcywgb3JkZXJlZCBieSB3aGVuXHJcblx0ICogdGhlIGZlYXR1cmUgZmlyc3QgYXBwZWFyZWQgaW4gdGhpcyBicmFuY2guXHJcblx0ICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgU1VQUE9SVEVEX1VVSURTOiBVVUlEW10gPSBbXHJcblx0XHRBVE5EZXNlcmlhbGl6ZXIuQkFTRV9TRVJJQUxJWkVEX1VVSUQsXHJcblx0XHRBVE5EZXNlcmlhbGl6ZXIuQURERURfTEVYRVJfQUNUSU9OUyxcclxuXHRcdEFUTkRlc2VyaWFsaXplci5BRERFRF9VTklDT0RFX1NNUCxcclxuXHRdO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBjdXJyZW50IHNlcmlhbGl6ZWQgVVVJRC5cclxuXHQgKi9cclxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBTRVJJQUxJWkVEX1VVSUQ6IFVVSUQgPSBBVE5EZXNlcmlhbGl6ZXIuQURERURfVU5JQ09ERV9TTVA7XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSByZWFkb25seSBkZXNlcmlhbGl6YXRpb25PcHRpb25zOiBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihkZXNlcmlhbGl6YXRpb25PcHRpb25zPzogQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucykge1xyXG5cdFx0aWYgKGRlc2VyaWFsaXphdGlvbk9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRkZXNlcmlhbGl6YXRpb25PcHRpb25zID0gQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5kZWZhdWx0T3B0aW9ucztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmRlc2VyaWFsaXphdGlvbk9wdGlvbnMgPSBkZXNlcmlhbGl6YXRpb25PcHRpb25zO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lcyBpZiBhIHBhcnRpY3VsYXIgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiBhbiBBVE4gc3VwcG9ydHNcclxuXHQgKiBhIHBhcnRpY3VsYXIgZmVhdHVyZSwgaWRlbnRpZmllZCBieSB0aGUge0BsaW5rIFVVSUR9IHVzZWQgZm9yIHNlcmlhbGl6aW5nXHJcblx0ICogdGhlIEFUTiBhdCB0aGUgdGltZSB0aGUgZmVhdHVyZSB3YXMgZmlyc3QgaW50cm9kdWNlZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBmZWF0dXJlIFRoZSB7QGxpbmsgVVVJRH0gbWFya2luZyB0aGUgZmlyc3QgdGltZSB0aGUgZmVhdHVyZSB3YXNcclxuXHQgKiBzdXBwb3J0ZWQgaW4gdGhlIHNlcmlhbGl6ZWQgQVROLlxyXG5cdCAqIEBwYXJhbSBhY3R1YWxVdWlkIFRoZSB7QGxpbmsgVVVJRH0gb2YgdGhlIGFjdHVhbCBzZXJpYWxpemVkIEFUTiB3aGljaCBpc1xyXG5cdCAqIGN1cnJlbnRseSBiZWluZyBkZXNlcmlhbGl6ZWQuXHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBgYWN0dWFsVXVpZGAgdmFsdWUgcmVwcmVzZW50cyBhXHJcblx0ICogc2VyaWFsaXplZCBBVE4gYXQgb3IgYWZ0ZXIgdGhlIGZlYXR1cmUgaWRlbnRpZmllZCBieSBgZmVhdHVyZWAgd2FzXHJcblx0ICogaW50cm9kdWNlZDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBzdGF0aWMgaXNGZWF0dXJlU3VwcG9ydGVkKGZlYXR1cmU6IFVVSUQsIGFjdHVhbFV1aWQ6IFVVSUQpOiBib29sZWFuIHtcclxuXHRcdGxldCBmZWF0dXJlSW5kZXg6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci5TVVBQT1JURURfVVVJRFMuZmluZEluZGV4KChlKSA9PiBlLmVxdWFscyhmZWF0dXJlKSk7XHJcblx0XHRpZiAoZmVhdHVyZUluZGV4IDwgMCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEFUTkRlc2VyaWFsaXplci5TVVBQT1JURURfVVVJRFMuZmluZEluZGV4KChlKSA9PiBlLmVxdWFscyhhY3R1YWxVdWlkKSkgPj0gZmVhdHVyZUluZGV4O1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgZ2V0VW5pY29kZURlc2VyaWFsaXplcihtb2RlOiBVbmljb2RlRGVzZXJpYWxpemluZ01vZGUpOiBVbmljb2RlRGVzZXJpYWxpemVyIHtcclxuXHRcdGlmIChtb2RlID09PSBVbmljb2RlRGVzZXJpYWxpemluZ01vZGUuVU5JQ09ERV9CTVApIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRyZWFkVW5pY29kZTogKGRhdGE6IFVpbnQxNkFycmF5LCBwOiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG5cdFx0XHRcdFx0cmV0dXJuIEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3BdKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHNpemU6IDEsXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHJlYWRVbmljb2RlOiAoZGF0YTogVWludDE2QXJyYXksIHA6IG51bWJlcik6IG51bWJlciA9PiB7XHJcblx0XHRcdFx0XHRyZXR1cm4gQVRORGVzZXJpYWxpemVyLnRvSW50MzIoZGF0YSwgcCk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRzaXplOiAyLFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGRlc2VyaWFsaXplKEBOb3ROdWxsIGRhdGE6IFVpbnQxNkFycmF5KTogQVROIHtcclxuXHRcdGRhdGEgPSBkYXRhLnNsaWNlKDApO1xyXG5cclxuXHRcdC8vIEVhY2ggVWludDE2IHZhbHVlIGluIGRhdGEgaXMgc2hpZnRlZCBieSArMiBhdCB0aGUgZW50cnkgdG8gdGhpcyBtZXRob2QuIFRoaXMgaXMgYW4gZW5jb2Rpbmcgb3B0aW1pemF0aW9uXHJcblx0XHQvLyB0YXJnZXRpbmcgdGhlIHNlcmlhbGl6ZWQgdmFsdWVzIDAgYW5kIC0xIChzZXJpYWxpemVkIHRvIDB4RkZGRiksIGVhY2ggb2Ygd2hpY2ggYXJlIHZlcnkgY29tbW9uIGluIHRoZVxyXG5cdFx0Ly8gc2VyaWFsaXplZCBmb3JtIG9mIHRoZSBBVE4uIEluIHRoZSBtb2RpZmllZCBVVEYtOCB0aGF0IEphdmEgdXNlcyBmb3IgY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLCB0aGVzZSB0d29cclxuXHRcdC8vIGNoYXJhY3RlciB2YWx1ZXMgaGF2ZSBtdWx0aS1ieXRlIGZvcm1zLiBCeSBzaGlmdGluZyBlYWNoIHZhbHVlIGJ5ICsyLCB0aGV5IGJlY29tZSBjaGFyYWN0ZXJzIDIgYW5kIDEgcHJpb3IgdG9cclxuXHRcdC8vIHdyaXRpbmcgdGhlIHN0cmluZywgZWFjaCBvZiB3aGljaCBoYXZlIHNpbmdsZS1ieXRlIHJlcHJlc2VudGF0aW9ucy4gU2luY2UgdGhlIHNoaWZ0IG9jY3VycyBpbiB0aGUgdG9vbCBkdXJpbmdcclxuXHRcdC8vIEFUTiBzZXJpYWxpemF0aW9uLCBlYWNoIHRhcmdldCBpcyByZXNwb25zaWJsZSBmb3IgYWRqdXN0aW5nIHRoZSB2YWx1ZXMgZHVyaW5nIGRlc2VyaWFsaXphdGlvbi5cclxuXHRcdC8vXHJcblx0XHQvLyBBcyBhIHNwZWNpYWwgY2FzZSwgbm90ZSB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGRhdGEgaXMgbm90IGFkanVzdGVkIGJlY2F1c2UgaXQgY29udGFpbnMgdGhlIG1ham9yIHZlcnNpb25cclxuXHRcdC8vIG51bWJlciBvZiB0aGUgc2VyaWFsaXplZCBBVE4sIHdoaWNoIHdhcyBmaXhlZCBhdCAzIGF0IHRoZSB0aW1lIHRoZSB2YWx1ZSBzaGlmdGluZyB3YXMgaW1wbGVtZW50ZWQuXHJcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0ZGF0YVtpXSA9IChkYXRhW2ldIC0gMikgJiAweEZGRkY7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHA6IG51bWJlciA9IDA7XHJcblx0XHRsZXQgdmVyc2lvbjogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRpZiAodmVyc2lvbiAhPT0gQVRORGVzZXJpYWxpemVyLlNFUklBTElaRURfVkVSU0lPTikge1xyXG5cdFx0XHRsZXQgcmVhc29uID0gYENvdWxkIG5vdCBkZXNlcmlhbGl6ZSBBVE4gd2l0aCB2ZXJzaW9uICR7dmVyc2lvbn0gKGV4cGVjdGVkICR7QVRORGVzZXJpYWxpemVyLlNFUklBTElaRURfVkVSU0lPTn0pLmA7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB1dWlkOiBVVUlEID0gQVRORGVzZXJpYWxpemVyLnRvVVVJRChkYXRhLCBwKTtcclxuXHRcdHAgKz0gODtcclxuXHRcdGlmIChBVE5EZXNlcmlhbGl6ZXIuU1VQUE9SVEVEX1VVSURTLmZpbmRJbmRleCgoZSkgPT4gZS5lcXVhbHModXVpZCkpIDwgMCkge1xyXG5cdFx0XHRsZXQgcmVhc29uID0gYENvdWxkIG5vdCBkZXNlcmlhbGl6ZSBBVE4gd2l0aCBVVUlEICR7dXVpZH0gKGV4cGVjdGVkICR7QVRORGVzZXJpYWxpemVyLlNFUklBTElaRURfVVVJRH0gb3IgYSBsZWdhY3kgVVVJRCkuYDtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHN1cHBvcnRzTGV4ZXJBY3Rpb25zOiBib29sZWFuID0gQVRORGVzZXJpYWxpemVyLmlzRmVhdHVyZVN1cHBvcnRlZChBVE5EZXNlcmlhbGl6ZXIuQURERURfTEVYRVJfQUNUSU9OUywgdXVpZCk7XHJcblxyXG5cdFx0bGV0IGdyYW1tYXJUeXBlOiBBVE5UeXBlID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRsZXQgbWF4VG9rZW5UeXBlOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdGxldCBhdG46IEFUTiA9IG5ldyBBVE4oZ3JhbW1hclR5cGUsIG1heFRva2VuVHlwZSk7XHJcblxyXG5cdFx0Ly9cclxuXHRcdC8vIFNUQVRFU1xyXG5cdFx0Ly9cclxuXHRcdGxldCBsb29wQmFja1N0YXRlTnVtYmVyczogQXJyYXk8W0xvb3BFbmRTdGF0ZSwgbnVtYmVyXT4gPSBbXTtcclxuXHRcdGxldCBlbmRTdGF0ZU51bWJlcnM6IEFycmF5PFtCbG9ja1N0YXJ0U3RhdGUsIG51bWJlcl0+ID0gW107XHJcblx0XHRsZXQgbnN0YXRlczogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5zdGF0ZXM7IGkrKykge1xyXG5cdFx0XHRsZXQgc3R5cGU6IEFUTlN0YXRlVHlwZSA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0XHQvLyBpZ25vcmUgYmFkIHR5cGUgb2Ygc3RhdGVzXHJcblx0XHRcdGlmIChzdHlwZSA9PT0gQVROU3RhdGVUeXBlLklOVkFMSURfVFlQRSkge1xyXG5cdFx0XHRcdGF0bi5hZGRTdGF0ZShuZXcgSW52YWxpZFN0YXRlKCkpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgcnVsZUluZGV4OiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0aWYgKHJ1bGVJbmRleCA9PT0gMHhGRkZGKSB7XHJcblx0XHRcdFx0cnVsZUluZGV4ID0gLTE7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBzOiBBVE5TdGF0ZSA9IHRoaXMuc3RhdGVGYWN0b3J5KHN0eXBlLCBydWxlSW5kZXgpO1xyXG5cdFx0XHRpZiAoc3R5cGUgPT09IEFUTlN0YXRlVHlwZS5MT09QX0VORCkgeyAvLyBzcGVjaWFsIGNhc2VcclxuXHRcdFx0XHRsZXQgbG9vcEJhY2tTdGF0ZU51bWJlcjogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRcdFx0bG9vcEJhY2tTdGF0ZU51bWJlcnMucHVzaChbcyBhcyBMb29wRW5kU3RhdGUsIGxvb3BCYWNrU3RhdGVOdW1iZXJdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChzIGluc3RhbmNlb2YgQmxvY2tTdGFydFN0YXRlKSB7XHJcblx0XHRcdFx0bGV0IGVuZFN0YXRlTnVtYmVyOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0XHRlbmRTdGF0ZU51bWJlcnMucHVzaChbcywgZW5kU3RhdGVOdW1iZXJdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhdG4uYWRkU3RhdGUocyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZGVsYXkgdGhlIGFzc2lnbm1lbnQgb2YgbG9vcCBiYWNrIGFuZCBlbmQgc3RhdGVzIHVudGlsIHdlIGtub3cgYWxsIHRoZSBzdGF0ZSBpbnN0YW5jZXMgaGF2ZSBiZWVuIGluaXRpYWxpemVkXHJcblx0XHRmb3IgKGxldCBwYWlyIG9mIGxvb3BCYWNrU3RhdGVOdW1iZXJzKSB7XHJcblx0XHRcdHBhaXJbMF0ubG9vcEJhY2tTdGF0ZSA9IGF0bi5zdGF0ZXNbcGFpclsxXV07XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgcGFpciBvZiBlbmRTdGF0ZU51bWJlcnMpIHtcclxuXHRcdFx0cGFpclswXS5lbmRTdGF0ZSA9IGF0bi5zdGF0ZXNbcGFpclsxXV0gYXMgQmxvY2tFbmRTdGF0ZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbnVtTm9uR3JlZWR5U3RhdGVzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTm9uR3JlZWR5U3RhdGVzOyBpKyspIHtcclxuXHRcdFx0bGV0IHN0YXRlTnVtYmVyOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0KGF0bi5zdGF0ZXNbc3RhdGVOdW1iZXJdIGFzIERlY2lzaW9uU3RhdGUpLm5vbkdyZWVkeSA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG51bVNsbERlY2lzaW9uczogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG51bVNsbERlY2lzaW9uczsgaSsrKSB7XHJcblx0XHRcdGxldCBzdGF0ZU51bWJlcjogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRcdChhdG4uc3RhdGVzW3N0YXRlTnVtYmVyXSBhcyBEZWNpc2lvblN0YXRlKS5zbGwgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBudW1QcmVjZWRlbmNlU3RhdGVzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUHJlY2VkZW5jZVN0YXRlczsgaSsrKSB7XHJcblx0XHRcdGxldCBzdGF0ZU51bWJlcjogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRcdChhdG4uc3RhdGVzW3N0YXRlTnVtYmVyXSBhcyBSdWxlU3RhcnRTdGF0ZSkuaXNQcmVjZWRlbmNlUnVsZSA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHRcdC8vIFJVTEVTXHJcblx0XHQvL1xyXG5cdFx0bGV0IG5ydWxlczogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRpZiAoYXRuLmdyYW1tYXJUeXBlID09PSBBVE5UeXBlLkxFWEVSKSB7XHJcblx0XHRcdGF0bi5ydWxlVG9Ub2tlblR5cGUgPSBuZXcgSW50MzJBcnJheShucnVsZXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGF0bi5ydWxlVG9TdGFydFN0YXRlID0gbmV3IEFycmF5PFJ1bGVTdGFydFN0YXRlPihucnVsZXMpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBucnVsZXM7IGkrKykge1xyXG5cdFx0XHRsZXQgczogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRcdGxldCBzdGFydFN0YXRlOiBSdWxlU3RhcnRTdGF0ZSA9IGF0bi5zdGF0ZXNbc10gYXMgUnVsZVN0YXJ0U3RhdGU7XHJcblx0XHRcdHN0YXJ0U3RhdGUubGVmdEZhY3RvcmVkID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSkgIT09IDA7XHJcblx0XHRcdGF0bi5ydWxlVG9TdGFydFN0YXRlW2ldID0gc3RhcnRTdGF0ZTtcclxuXHRcdFx0aWYgKGF0bi5ncmFtbWFyVHlwZSA9PT0gQVROVHlwZS5MRVhFUikge1xyXG5cdFx0XHRcdGxldCB0b2tlblR5cGU6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0XHRcdGlmICh0b2tlblR5cGUgPT09IDB4RkZGRikge1xyXG5cdFx0XHRcdFx0dG9rZW5UeXBlID0gVG9rZW4uRU9GO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YXRuLnJ1bGVUb1Rva2VuVHlwZVtpXSA9IHRva2VuVHlwZTtcclxuXHJcblx0XHRcdFx0aWYgKCFBVE5EZXNlcmlhbGl6ZXIuaXNGZWF0dXJlU3VwcG9ydGVkKEFUTkRlc2VyaWFsaXplci5BRERFRF9MRVhFUl9BQ1RJT05TLCB1dWlkKSkge1xyXG5cdFx0XHRcdFx0Ly8gdGhpcyBwaWVjZSBvZiB1bnVzZWQgbWV0YWRhdGEgd2FzIHNlcmlhbGl6ZWQgcHJpb3IgdG8gdGhlXHJcblx0XHRcdFx0XHQvLyBhZGRpdGlvbiBvZiBMZXhlckFjdGlvblxyXG5cdFx0XHRcdFx0bGV0IGFjdGlvbkluZGV4SWdub3JlZDogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRcdFx0XHRpZiAoYWN0aW9uSW5kZXhJZ25vcmVkID09PSAweEZGRkYpIHtcclxuXHRcdFx0XHRcdFx0YWN0aW9uSW5kZXhJZ25vcmVkID0gLTE7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YXRuLnJ1bGVUb1N0b3BTdGF0ZSA9IG5ldyBBcnJheTxSdWxlU3RvcFN0YXRlPihucnVsZXMpO1xyXG5cdFx0Zm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xyXG5cdFx0XHRpZiAoIShzdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGF0bi5ydWxlVG9TdG9wU3RhdGVbc3RhdGUucnVsZUluZGV4XSA9IHN0YXRlO1xyXG5cdFx0XHRhdG4ucnVsZVRvU3RhcnRTdGF0ZVtzdGF0ZS5ydWxlSW5kZXhdLnN0b3BTdGF0ZSA9IHN0YXRlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblx0XHQvLyBNT0RFU1xyXG5cdFx0Ly9cclxuXHRcdGxldCBubW9kZXM6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBubW9kZXM7IGkrKykge1xyXG5cdFx0XHRsZXQgczogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRcdGF0bi5tb2RlVG9TdGFydFN0YXRlLnB1c2goYXRuLnN0YXRlc1tzXSBhcyBUb2tlbnNTdGFydFN0YXRlKTtcclxuXHRcdH1cclxuXHJcblx0XHRhdG4ubW9kZVRvREZBID0gbmV3IEFycmF5PERGQT4obm1vZGVzKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbm1vZGVzOyBpKyspIHtcclxuXHRcdFx0YXRuLm1vZGVUb0RGQVtpXSA9IG5ldyBERkEoYXRuLm1vZGVUb1N0YXJ0U3RhdGVbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblx0XHQvLyBTRVRTXHJcblx0XHQvL1xyXG5cdFx0bGV0IHNldHM6IEludGVydmFsU2V0W10gPSBbXTtcclxuXHJcblx0XHQvLyBGaXJzdCwgcmVhZCBhbGwgc2V0cyB3aXRoIDE2LWJpdCBVbmljb2RlIGNvZGUgcG9pbnRzIDw9IFUrRkZGRi5cclxuXHRcdHAgPSB0aGlzLmRlc2VyaWFsaXplU2V0cyhkYXRhLCBwLCBzZXRzLCBBVE5EZXNlcmlhbGl6ZXIuZ2V0VW5pY29kZURlc2VyaWFsaXplcihVbmljb2RlRGVzZXJpYWxpemluZ01vZGUuVU5JQ09ERV9CTVApKTtcclxuXHJcblx0XHQvLyBOZXh0LCBpZiB0aGUgQVROIHdhcyBzZXJpYWxpemVkIHdpdGggdGhlIFVuaWNvZGUgU01QIGZlYXR1cmUsXHJcblx0XHQvLyBkZXNlcmlhbGl6ZSBzZXRzIHdpdGggMzItYml0IGFyZ3VtZW50cyA8PSBVKzEwRkZGRi5cclxuXHRcdGlmIChBVE5EZXNlcmlhbGl6ZXIuaXNGZWF0dXJlU3VwcG9ydGVkKEFUTkRlc2VyaWFsaXplci5BRERFRF9VTklDT0RFX1NNUCwgdXVpZCkpIHtcclxuXHRcdFx0cCA9IHRoaXMuZGVzZXJpYWxpemVTZXRzKGRhdGEsIHAsIHNldHMsIEFUTkRlc2VyaWFsaXplci5nZXRVbmljb2RlRGVzZXJpYWxpemVyKFVuaWNvZGVEZXNlcmlhbGl6aW5nTW9kZS5VTklDT0RFX1NNUCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblx0XHQvLyBFREdFU1xyXG5cdFx0Ly9cclxuXHRcdGxldCBuZWRnZXM6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuZWRnZXM7IGkrKykge1xyXG5cdFx0XHRsZXQgc3JjOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwXSk7XHJcblx0XHRcdGxldCB0cmc6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3AgKyAxXSk7XHJcblx0XHRcdGxldCB0dHlwZTogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCArIDJdKTtcclxuXHRcdFx0bGV0IGFyZzE6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3AgKyAzXSk7XHJcblx0XHRcdGxldCBhcmcyOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwICsgNF0pO1xyXG5cdFx0XHRsZXQgYXJnMzogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCArIDVdKTtcclxuXHRcdFx0bGV0IHRyYW5zOiBUcmFuc2l0aW9uID0gdGhpcy5lZGdlRmFjdG9yeShhdG4sIHR0eXBlLCBzcmMsIHRyZywgYXJnMSwgYXJnMiwgYXJnMywgc2V0cyk7XHJcblx0XHRcdC8vIGNvbnNvbGUubG9nKGBFREdFICR7dHJhbnMuY29uc3RydWN0b3IubmFtZX0gJHtzcmN9LT4ke3RyZ30gJHtUcmFuc2l0aW9uLnNlcmlhbGl6YXRpb25OYW1lc1t0dHlwZV19ICR7YXJnMX0sJHthcmcyfSwke2FyZzN9YCk7XHJcblx0XHRcdGxldCBzcmNTdGF0ZTogQVROU3RhdGUgPSBhdG4uc3RhdGVzW3NyY107XHJcblx0XHRcdHNyY1N0YXRlLmFkZFRyYW5zaXRpb24odHJhbnMpO1xyXG5cdFx0XHRwICs9IDY7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZWRnZXMgZm9yIHJ1bGUgc3RvcCBzdGF0ZXMgY2FuIGJlIGRlcml2ZWQsIHNvIHRoZXkgYXJlbid0IHNlcmlhbGl6ZWRcclxuXHRcdGludGVyZmFjZSBUIHsgc3RvcFN0YXRlOiBudW1iZXI7IHJldHVyblN0YXRlOiBudW1iZXI7IG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm46IG51bWJlcjsgfVxyXG5cdFx0bGV0IHJldHVyblRyYW5zaXRpb25zU2V0ID0gbmV3IEFycmF5MkRIYXNoU2V0PFQ+KHtcclxuXHRcdFx0aGFzaENvZGU6IChvOiBUKSA9PiBvLnN0b3BTdGF0ZSBeIG8ucmV0dXJuU3RhdGUgXiBvLm91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4sXHJcblxyXG5cdFx0XHRlcXVhbHM6IChhOiBULCBiOiBUKTogYm9vbGVhbiA9PiB7XHJcblx0XHRcdFx0cmV0dXJuIGEuc3RvcFN0YXRlID09PSBiLnN0b3BTdGF0ZVxyXG5cdFx0XHRcdFx0JiYgYS5yZXR1cm5TdGF0ZSA9PT0gYi5yZXR1cm5TdGF0ZVxyXG5cdFx0XHRcdFx0JiYgYS5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuID09PSBiLm91dGVybW9zdFByZWNlZGVuY2VSZXR1cm47XHJcblx0XHRcdH0sXHJcblx0XHR9KTtcclxuXHRcdGxldCByZXR1cm5UcmFuc2l0aW9uczogVFtdID0gW107XHJcblx0XHRmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XHJcblx0XHRcdGxldCByZXR1cm5pbmdUb0xlZnRGYWN0b3JlZDogYm9vbGVhbiA9IHN0YXRlLnJ1bGVJbmRleCA+PSAwICYmIGF0bi5ydWxlVG9TdGFydFN0YXRlW3N0YXRlLnJ1bGVJbmRleF0ubGVmdEZhY3RvcmVkO1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xyXG5cdFx0XHRcdGxldCB0OiBUcmFuc2l0aW9uID0gc3RhdGUudHJhbnNpdGlvbihpKTtcclxuXHRcdFx0XHRpZiAoISh0IGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb24pKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBydWxlVHJhbnNpdGlvbjogUnVsZVRyYW5zaXRpb24gPSB0O1xyXG5cdFx0XHRcdGxldCByZXR1cm5pbmdGcm9tTGVmdEZhY3RvcmVkOiBib29sZWFuID0gYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbcnVsZVRyYW5zaXRpb24udGFyZ2V0LnJ1bGVJbmRleF0ubGVmdEZhY3RvcmVkO1xyXG5cdFx0XHRcdGlmICghcmV0dXJuaW5nRnJvbUxlZnRGYWN0b3JlZCAmJiByZXR1cm5pbmdUb0xlZnRGYWN0b3JlZCkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybjogbnVtYmVyID0gLTE7XHJcblx0XHRcdFx0aWYgKGF0bi5ydWxlVG9TdGFydFN0YXRlW3J1bGVUcmFuc2l0aW9uLnRhcmdldC5ydWxlSW5kZXhdLmlzUHJlY2VkZW5jZVJ1bGUpIHtcclxuXHRcdFx0XHRcdGlmIChydWxlVHJhbnNpdGlvbi5wcmVjZWRlbmNlID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4gPSBydWxlVHJhbnNpdGlvbi50YXJnZXQucnVsZUluZGV4O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IGN1cnJlbnQgPSB7IHN0b3BTdGF0ZTogcnVsZVRyYW5zaXRpb24udGFyZ2V0LnJ1bGVJbmRleCwgcmV0dXJuU3RhdGU6IHJ1bGVUcmFuc2l0aW9uLmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyLCBvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuIH07XHJcblx0XHRcdFx0aWYgKHJldHVyblRyYW5zaXRpb25zU2V0LmFkZChjdXJyZW50KSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuVHJhbnNpdGlvbnMucHVzaChjdXJyZW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBBZGQgYWxsIGVsZW1lbnRzIGZyb20gcmV0dXJuVHJhbnNpdGlvbnMgdG8gdGhlIEFUTlxyXG5cdFx0Zm9yIChsZXQgcmV0dXJuVHJhbnNpdGlvbiBvZiByZXR1cm5UcmFuc2l0aW9ucykge1xyXG5cdFx0XHRsZXQgdHJhbnNpdGlvbiA9IG5ldyBFcHNpbG9uVHJhbnNpdGlvbihhdG4uc3RhdGVzW3JldHVyblRyYW5zaXRpb24ucmV0dXJuU3RhdGVdLCByZXR1cm5UcmFuc2l0aW9uLm91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4pO1xyXG5cdFx0XHRhdG4ucnVsZVRvU3RvcFN0YXRlW3JldHVyblRyYW5zaXRpb24uc3RvcFN0YXRlXS5hZGRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IHN0YXRlIG9mIGF0bi5zdGF0ZXMpIHtcclxuXHRcdFx0aWYgKHN0YXRlIGluc3RhbmNlb2YgQmxvY2tTdGFydFN0YXRlKSB7XHJcblx0XHRcdFx0Ly8gd2UgbmVlZCB0byBrbm93IHRoZSBlbmQgc3RhdGUgdG8gc2V0IGl0cyBzdGFydCBzdGF0ZVxyXG5cdFx0XHRcdGlmIChzdGF0ZS5lbmRTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsU3RhdGVFeGNlcHRpb25cIik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBibG9jayBlbmQgc3RhdGVzIGNhbiBvbmx5IGJlIGFzc29jaWF0ZWQgdG8gYSBzaW5nbGUgYmxvY2sgc3RhcnQgc3RhdGVcclxuXHRcdFx0XHRpZiAoc3RhdGUuZW5kU3RhdGUuc3RhcnRTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsU3RhdGVFeGNlcHRpb25cIik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGF0ZS5lbmRTdGF0ZS5zdGFydFN0YXRlID0gc3RhdGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChzdGF0ZSBpbnN0YW5jZW9mIFBsdXNMb29wYmFja1N0YXRlKSB7XHJcblx0XHRcdFx0bGV0IGxvb3BiYWNrU3RhdGU6IFBsdXNMb29wYmFja1N0YXRlID0gc3RhdGU7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsb29wYmFja1N0YXRlLm51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xyXG5cdFx0XHRcdFx0bGV0IHRhcmdldDogQVROU3RhdGUgPSBsb29wYmFja1N0YXRlLnRyYW5zaXRpb24oaSkudGFyZ2V0O1xyXG5cdFx0XHRcdFx0aWYgKHRhcmdldCBpbnN0YW5jZW9mIFBsdXNCbG9ja1N0YXJ0U3RhdGUpIHtcclxuXHRcdFx0XHRcdFx0dGFyZ2V0Lmxvb3BCYWNrU3RhdGUgPSBsb29wYmFja1N0YXRlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChzdGF0ZSBpbnN0YW5jZW9mIFN0YXJMb29wYmFja1N0YXRlKSB7XHJcblx0XHRcdFx0bGV0IGxvb3BiYWNrU3RhdGU6IFN0YXJMb29wYmFja1N0YXRlID0gc3RhdGU7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsb29wYmFja1N0YXRlLm51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xyXG5cdFx0XHRcdFx0bGV0IHRhcmdldDogQVROU3RhdGUgPSBsb29wYmFja1N0YXRlLnRyYW5zaXRpb24oaSkudGFyZ2V0O1xyXG5cdFx0XHRcdFx0aWYgKHRhcmdldCBpbnN0YW5jZW9mIFN0YXJMb29wRW50cnlTdGF0ZSkge1xyXG5cdFx0XHRcdFx0XHR0YXJnZXQubG9vcEJhY2tTdGF0ZSA9IGxvb3BiYWNrU3RhdGU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHRcdC8vIERFQ0lTSU9OU1xyXG5cdFx0Ly9cclxuXHRcdGxldCBuZGVjaXNpb25zOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDw9IG5kZWNpc2lvbnM7IGkrKykge1xyXG5cdFx0XHRsZXQgczogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRcdGxldCBkZWNTdGF0ZTogRGVjaXNpb25TdGF0ZSA9IGF0bi5zdGF0ZXNbc10gYXMgRGVjaXNpb25TdGF0ZTtcclxuXHRcdFx0YXRuLmRlY2lzaW9uVG9TdGF0ZS5wdXNoKGRlY1N0YXRlKTtcclxuXHRcdFx0ZGVjU3RhdGUuZGVjaXNpb24gPSBpIC0gMTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cdFx0Ly8gTEVYRVIgQUNUSU9OU1xyXG5cdFx0Ly9cclxuXHRcdGlmIChhdG4uZ3JhbW1hclR5cGUgPT09IEFUTlR5cGUuTEVYRVIpIHtcclxuXHRcdFx0aWYgKHN1cHBvcnRzTGV4ZXJBY3Rpb25zKSB7XHJcblx0XHRcdFx0YXRuLmxleGVyQWN0aW9ucyA9IG5ldyBBcnJheTxMZXhlckFjdGlvbj4oQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSkpO1xyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXRuLmxleGVyQWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0bGV0IGFjdGlvblR5cGU6IExleGVyQWN0aW9uVHlwZSA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0XHRcdFx0bGV0IGRhdGExOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0XHRcdGlmIChkYXRhMSA9PT0gMHhGRkZGKSB7XHJcblx0XHRcdFx0XHRcdGRhdGExID0gLTE7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0IGRhdGEyOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0XHRcdGlmIChkYXRhMiA9PT0gMHhGRkZGKSB7XHJcblx0XHRcdFx0XHRcdGRhdGEyID0gLTE7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0IGxleGVyQWN0aW9uOiBMZXhlckFjdGlvbiA9IHRoaXMubGV4ZXJBY3Rpb25GYWN0b3J5KGFjdGlvblR5cGUsIGRhdGExLCBkYXRhMik7XHJcblxyXG5cdFx0XHRcdFx0YXRuLmxleGVyQWN0aW9uc1tpXSA9IGxleGVyQWN0aW9uO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHQvLyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIHNlcmlhbGl6ZWQgQVROcywgY29udmVydCB0aGUgb2xkXHJcblx0XHRcdFx0Ly8gc2VyaWFsaXplZCBhY3Rpb24gaW5kZXggZm9yIGFjdGlvbiB0cmFuc2l0aW9ucyB0byB0aGUgbmV3XHJcblx0XHRcdFx0Ly8gZm9ybSwgd2hpY2ggaXMgdGhlIGluZGV4IG9mIGEgTGV4ZXJDdXN0b21BY3Rpb25cclxuXHRcdFx0XHRsZXQgbGVnYWN5TGV4ZXJBY3Rpb25zOiBMZXhlckFjdGlvbltdID0gW107XHJcblx0XHRcdFx0Zm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0bGV0IHRyYW5zaXRpb246IFRyYW5zaXRpb24gPSBzdGF0ZS50cmFuc2l0aW9uKGkpO1xyXG5cdFx0XHRcdFx0XHRpZiAoISh0cmFuc2l0aW9uIGluc3RhbmNlb2YgQWN0aW9uVHJhbnNpdGlvbikpIHtcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0bGV0IHJ1bGVJbmRleDogbnVtYmVyID0gdHJhbnNpdGlvbi5ydWxlSW5kZXg7XHJcblx0XHRcdFx0XHRcdGxldCBhY3Rpb25JbmRleDogbnVtYmVyID0gdHJhbnNpdGlvbi5hY3Rpb25JbmRleDtcclxuXHRcdFx0XHRcdFx0bGV0IGxleGVyQWN0aW9uOiBMZXhlckN1c3RvbUFjdGlvbiA9IG5ldyBMZXhlckN1c3RvbUFjdGlvbihydWxlSW5kZXgsIGFjdGlvbkluZGV4KTtcclxuXHRcdFx0XHRcdFx0c3RhdGUuc2V0VHJhbnNpdGlvbihpLCBuZXcgQWN0aW9uVHJhbnNpdGlvbih0cmFuc2l0aW9uLnRhcmdldCwgcnVsZUluZGV4LCBsZWdhY3lMZXhlckFjdGlvbnMubGVuZ3RoLCBmYWxzZSkpO1xyXG5cdFx0XHRcdFx0XHRsZWdhY3lMZXhlckFjdGlvbnMucHVzaChsZXhlckFjdGlvbik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhdG4ubGV4ZXJBY3Rpb25zID0gbGVnYWN5TGV4ZXJBY3Rpb25zO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tYXJrUHJlY2VkZW5jZURlY2lzaW9ucyhhdG4pO1xyXG5cclxuXHRcdGF0bi5kZWNpc2lvblRvREZBID0gbmV3IEFycmF5PERGQT4obmRlY2lzaW9ucyk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5kZWNpc2lvbnM7IGkrKykge1xyXG5cdFx0XHRhdG4uZGVjaXNpb25Ub0RGQVtpXSA9IG5ldyBERkEoYXRuLmRlY2lzaW9uVG9TdGF0ZVtpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuZGVzZXJpYWxpemF0aW9uT3B0aW9ucy5pc1ZlcmlmeUFUTikge1xyXG5cdFx0XHR0aGlzLnZlcmlmeUFUTihhdG4pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmRlc2VyaWFsaXphdGlvbk9wdGlvbnMuaXNHZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyAmJiBhdG4uZ3JhbW1hclR5cGUgPT09IEFUTlR5cGUuUEFSU0VSKSB7XHJcblx0XHRcdGF0bi5ydWxlVG9Ub2tlblR5cGUgPSBuZXcgSW50MzJBcnJheShhdG4ucnVsZVRvU3RhcnRTdGF0ZS5sZW5ndGgpO1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGF0bi5ydWxlVG9TdGFydFN0YXRlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0YXRuLnJ1bGVUb1Rva2VuVHlwZVtpXSA9IGF0bi5tYXhUb2tlblR5cGUgKyBpICsgMTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhdG4ucnVsZVRvU3RhcnRTdGF0ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGxldCBieXBhc3NTdGFydDogQmFzaWNCbG9ja1N0YXJ0U3RhdGUgPSBuZXcgQmFzaWNCbG9ja1N0YXJ0U3RhdGUoKTtcclxuXHRcdFx0XHRieXBhc3NTdGFydC5ydWxlSW5kZXggPSBpO1xyXG5cdFx0XHRcdGF0bi5hZGRTdGF0ZShieXBhc3NTdGFydCk7XHJcblxyXG5cdFx0XHRcdGxldCBieXBhc3NTdG9wOiBCbG9ja0VuZFN0YXRlID0gbmV3IEJsb2NrRW5kU3RhdGUoKTtcclxuXHRcdFx0XHRieXBhc3NTdG9wLnJ1bGVJbmRleCA9IGk7XHJcblx0XHRcdFx0YXRuLmFkZFN0YXRlKGJ5cGFzc1N0b3ApO1xyXG5cclxuXHRcdFx0XHRieXBhc3NTdGFydC5lbmRTdGF0ZSA9IGJ5cGFzc1N0b3A7XHJcblx0XHRcdFx0YXRuLmRlZmluZURlY2lzaW9uU3RhdGUoYnlwYXNzU3RhcnQpO1xyXG5cclxuXHRcdFx0XHRieXBhc3NTdG9wLnN0YXJ0U3RhdGUgPSBieXBhc3NTdGFydDtcclxuXHJcblx0XHRcdFx0bGV0IGVuZFN0YXRlOiBBVE5TdGF0ZSB8IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRsZXQgZXhjbHVkZVRyYW5zaXRpb246IFRyYW5zaXRpb24gfCB1bmRlZmluZWQ7XHJcblx0XHRcdFx0aWYgKGF0bi5ydWxlVG9TdGFydFN0YXRlW2ldLmlzUHJlY2VkZW5jZVJ1bGUpIHtcclxuXHRcdFx0XHRcdC8vIHdyYXAgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBydWxlIHRvIHRoZSBTdGFyTG9vcEVudHJ5U3RhdGVcclxuXHRcdFx0XHRcdGVuZFN0YXRlID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xyXG5cdFx0XHRcdFx0XHRpZiAoc3RhdGUucnVsZUluZGV4ICE9PSBpKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICghKHN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKSkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRsZXQgbWF5YmVMb29wRW5kU3RhdGU6IEFUTlN0YXRlID0gc3RhdGUudHJhbnNpdGlvbihzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zIC0gMSkudGFyZ2V0O1xyXG5cdFx0XHRcdFx0XHRpZiAoIShtYXliZUxvb3BFbmRTdGF0ZSBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZSkpIHtcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKG1heWJlTG9vcEVuZFN0YXRlLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgJiYgbWF5YmVMb29wRW5kU3RhdGUudHJhbnNpdGlvbigwKS50YXJnZXQgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XHJcblx0XHRcdFx0XHRcdFx0ZW5kU3RhdGUgPSBzdGF0ZTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICghZW5kU3RhdGUpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgaWRlbnRpZnkgZmluYWwgc3RhdGUgb2YgdGhlIHByZWNlZGVuY2UgcnVsZSBwcmVmaXggc2VjdGlvbi5cIik7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZXhjbHVkZVRyYW5zaXRpb24gPSAoZW5kU3RhdGUgYXMgU3Rhckxvb3BFbnRyeVN0YXRlKS5sb29wQmFja1N0YXRlLnRyYW5zaXRpb24oMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0ZW5kU3RhdGUgPSBhdG4ucnVsZVRvU3RvcFN0YXRlW2ldO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gYWxsIG5vbi1leGNsdWRlZCB0cmFuc2l0aW9ucyB0aGF0IGN1cnJlbnRseSB0YXJnZXQgZW5kIHN0YXRlIG5lZWQgdG8gdGFyZ2V0IGJsb2NrRW5kIGluc3RlYWRcclxuXHRcdFx0XHRmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRsZXQgdHJhbnNpdGlvbiA9IHN0YXRlLnRyYW5zaXRpb24oaSk7XHJcblx0XHRcdFx0XHRcdGlmICh0cmFuc2l0aW9uID09PSBleGNsdWRlVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAodHJhbnNpdGlvbi50YXJnZXQgPT09IGVuZFN0YXRlKSB7XHJcblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbi50YXJnZXQgPSBieXBhc3NTdG9wO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBhbGwgdHJhbnNpdGlvbnMgbGVhdmluZyB0aGUgcnVsZSBzdGFydCBzdGF0ZSBuZWVkIHRvIGxlYXZlIGJsb2NrU3RhcnQgaW5zdGVhZFxyXG5cdFx0XHRcdHdoaWxlIChhdG4ucnVsZVRvU3RhcnRTdGF0ZVtpXS5udW1iZXJPZlRyYW5zaXRpb25zID4gMCkge1xyXG5cdFx0XHRcdFx0bGV0IHRyYW5zaXRpb246IFRyYW5zaXRpb24gPSBhdG4ucnVsZVRvU3RhcnRTdGF0ZVtpXS5yZW1vdmVUcmFuc2l0aW9uKGF0bi5ydWxlVG9TdGFydFN0YXRlW2ldLm51bWJlck9mVHJhbnNpdGlvbnMgLSAxKTtcclxuXHRcdFx0XHRcdGJ5cGFzc1N0YXJ0LmFkZFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBsaW5rIHRoZSBuZXcgc3RhdGVzXHJcblx0XHRcdFx0YXRuLnJ1bGVUb1N0YXJ0U3RhdGVbaV0uYWRkVHJhbnNpdGlvbihuZXcgRXBzaWxvblRyYW5zaXRpb24oYnlwYXNzU3RhcnQpKTtcclxuXHRcdFx0XHRieXBhc3NTdG9wLmFkZFRyYW5zaXRpb24obmV3IEVwc2lsb25UcmFuc2l0aW9uKGVuZFN0YXRlKSk7XHJcblxyXG5cdFx0XHRcdGxldCBtYXRjaFN0YXRlOiBBVE5TdGF0ZSA9IG5ldyBCYXNpY1N0YXRlKCk7XHJcblx0XHRcdFx0YXRuLmFkZFN0YXRlKG1hdGNoU3RhdGUpO1xyXG5cdFx0XHRcdG1hdGNoU3RhdGUuYWRkVHJhbnNpdGlvbihuZXcgQXRvbVRyYW5zaXRpb24oYnlwYXNzU3RvcCwgYXRuLnJ1bGVUb1Rva2VuVHlwZVtpXSkpO1xyXG5cdFx0XHRcdGJ5cGFzc1N0YXJ0LmFkZFRyYW5zaXRpb24obmV3IEVwc2lsb25UcmFuc2l0aW9uKG1hdGNoU3RhdGUpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXMuZGVzZXJpYWxpemF0aW9uT3B0aW9ucy5pc1ZlcmlmeUFUTikge1xyXG5cdFx0XHRcdC8vIHJldmVyaWZ5IGFmdGVyIG1vZGlmaWNhdGlvblxyXG5cdFx0XHRcdHRoaXMudmVyaWZ5QVROKGF0bik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5kZXNlcmlhbGl6YXRpb25PcHRpb25zLmlzT3B0aW1pemUpIHtcclxuXHRcdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0XHRsZXQgb3B0aW1pemF0aW9uQ291bnQ6IG51bWJlciA9IDA7XHJcblx0XHRcdFx0b3B0aW1pemF0aW9uQ291bnQgKz0gQVRORGVzZXJpYWxpemVyLmlubGluZVNldFJ1bGVzKGF0bik7XHJcblx0XHRcdFx0b3B0aW1pemF0aW9uQ291bnQgKz0gQVRORGVzZXJpYWxpemVyLmNvbWJpbmVDaGFpbmVkRXBzaWxvbnMoYXRuKTtcclxuXHRcdFx0XHRsZXQgcHJlc2VydmVPcmRlcjogYm9vbGVhbiA9IGF0bi5ncmFtbWFyVHlwZSA9PT0gQVROVHlwZS5MRVhFUjtcclxuXHRcdFx0XHRvcHRpbWl6YXRpb25Db3VudCArPSBBVE5EZXNlcmlhbGl6ZXIub3B0aW1pemVTZXRzKGF0biwgcHJlc2VydmVPcmRlcik7XHJcblx0XHRcdFx0aWYgKG9wdGltaXphdGlvbkNvdW50ID09PSAwKSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aGlzLmRlc2VyaWFsaXphdGlvbk9wdGlvbnMuaXNWZXJpZnlBVE4pIHtcclxuXHRcdFx0XHQvLyByZXZlcmlmeSBhZnRlciBtb2RpZmljYXRpb25cclxuXHRcdFx0XHR0aGlzLnZlcmlmeUFUTihhdG4pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0QVRORGVzZXJpYWxpemVyLmlkZW50aWZ5VGFpbENhbGxzKGF0bik7XHJcblxyXG5cdFx0cmV0dXJuIGF0bjtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgZGVzZXJpYWxpemVTZXRzKGRhdGE6IFVpbnQxNkFycmF5LCBwOiBudW1iZXIsIHNldHM6IEludGVydmFsU2V0W10sIHVuaWNvZGVEZXNlcmlhbGl6ZXI6IFVuaWNvZGVEZXNlcmlhbGl6ZXIpOiBudW1iZXIge1xyXG5cdFx0bGV0IG5zZXRzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnNldHM7IGkrKykge1xyXG5cdFx0XHRsZXQgbmludGVydmFsczogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcF0pO1xyXG5cdFx0XHRwKys7XHJcblx0XHRcdGxldCBzZXQ6IEludGVydmFsU2V0ID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHRcdHNldHMucHVzaChzZXQpO1xyXG5cclxuXHRcdFx0bGV0IGNvbnRhaW5zRW9mOiBib29sZWFuID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSkgIT09IDA7XHJcblx0XHRcdGlmIChjb250YWluc0VvZikge1xyXG5cdFx0XHRcdHNldC5hZGQoLTEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgbmludGVydmFsczsgaisrKSB7XHJcblx0XHRcdFx0bGV0IGE6IG51bWJlciA9IHVuaWNvZGVEZXNlcmlhbGl6ZXIucmVhZFVuaWNvZGUoZGF0YSwgcCk7XHJcblx0XHRcdFx0cCArPSB1bmljb2RlRGVzZXJpYWxpemVyLnNpemU7XHJcblx0XHRcdFx0bGV0IGI6IG51bWJlciA9IHVuaWNvZGVEZXNlcmlhbGl6ZXIucmVhZFVuaWNvZGUoZGF0YSwgcCk7XHJcblx0XHRcdFx0cCArPSB1bmljb2RlRGVzZXJpYWxpemVyLnNpemU7XHJcblx0XHRcdFx0c2V0LmFkZChhLCBiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQW5hbHl6ZSB0aGUge0BsaW5rIFN0YXJMb29wRW50cnlTdGF0ZX0gc3RhdGVzIGluIHRoZSBzcGVjaWZpZWQgQVROIHRvIHNldFxyXG5cdCAqIHRoZSB7QGxpbmsgU3Rhckxvb3BFbnRyeVN0YXRlI3ByZWNlZGVuY2VSdWxlRGVjaXNpb259IGZpZWxkIHRvIHRoZVxyXG5cdCAqIGNvcnJlY3QgdmFsdWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gYXRuIFRoZSBBVE4uXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIG1hcmtQcmVjZWRlbmNlRGVjaXNpb25zKEBOb3ROdWxsIGF0bjogQVROKTogdm9pZCB7XHJcblx0XHQvLyBNYXAgcnVsZSBpbmRleCAtPiBwcmVjZWRlbmNlIGRlY2lzaW9uIGZvciB0aGF0IHJ1bGVcclxuXHRcdGxldCBydWxlUHJlY2VkZW5jZURlY2lzaW9ucyA9IG5ldyBNYXA8bnVtYmVyLCBTdGFyTG9vcEVudHJ5U3RhdGU+KCk7XHJcblxyXG5cdFx0Zm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xyXG5cdFx0XHRpZiAoIShzdGF0ZSBpbnN0YW5jZW9mIFN0YXJMb29wRW50cnlTdGF0ZSkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0LyogV2UgYW5hbHl6ZSB0aGUgQVROIHRvIGRldGVybWluZSBpZiB0aGlzIEFUTiBkZWNpc2lvbiBzdGF0ZSBpcyB0aGVcclxuXHRcdFx0ICogZGVjaXNpb24gZm9yIHRoZSBjbG9zdXJlIGJsb2NrIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIGFcclxuXHRcdFx0ICogcHJlY2VkZW5jZSBydWxlIHNob3VsZCBjb250aW51ZSBvciBjb21wbGV0ZS5cclxuXHRcdFx0ICovXHJcblx0XHRcdGlmIChhdG4ucnVsZVRvU3RhcnRTdGF0ZVtzdGF0ZS5ydWxlSW5kZXhdLmlzUHJlY2VkZW5jZVJ1bGUpIHtcclxuXHRcdFx0XHRsZXQgbWF5YmVMb29wRW5kU3RhdGU6IEFUTlN0YXRlID0gc3RhdGUudHJhbnNpdGlvbihzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zIC0gMSkudGFyZ2V0O1xyXG5cdFx0XHRcdGlmIChtYXliZUxvb3BFbmRTdGF0ZSBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZSkge1xyXG5cdFx0XHRcdFx0aWYgKG1heWJlTG9vcEVuZFN0YXRlLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgJiYgbWF5YmVMb29wRW5kU3RhdGUudHJhbnNpdGlvbigwKS50YXJnZXQgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XHJcblx0XHRcdFx0XHRcdHJ1bGVQcmVjZWRlbmNlRGVjaXNpb25zLnNldChzdGF0ZS5ydWxlSW5kZXgsIHN0YXRlKTtcclxuXHRcdFx0XHRcdFx0c3RhdGUucHJlY2VkZW5jZVJ1bGVEZWNpc2lvbiA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHN0YXRlLnByZWNlZGVuY2VMb29wYmFja1N0YXRlcyA9IG5ldyBCaXRTZXQoYXRuLnN0YXRlcy5sZW5ndGgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFmdGVyIG1hcmtpbmcgcHJlY2VkZW5jZSBkZWNpc2lvbnMsIHdlIGdvIGJhY2sgdGhyb3VnaCBhbmQgZmlsbCBpblxyXG5cdFx0Ly8gU3Rhckxvb3BFbnRyeVN0YXRlLnByZWNlZGVuY2VMb29wYmFja1N0YXRlcy5cclxuXHRcdGZvciAobGV0IHByZWNlZGVuY2VEZWNpc2lvbiBvZiBydWxlUHJlY2VkZW5jZURlY2lzaW9ucykge1xyXG5cdFx0XHRmb3IgKGxldCB0cmFuc2l0aW9uIG9mIGF0bi5ydWxlVG9TdG9wU3RhdGVbcHJlY2VkZW5jZURlY2lzaW9uWzBdXS5nZXRUcmFuc2l0aW9ucygpKSB7XHJcblx0XHRcdFx0aWYgKHRyYW5zaXRpb24uc2VyaWFsaXphdGlvblR5cGUgIT09IFRyYW5zaXRpb25UeXBlLkVQU0lMT04pIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IGVwc2lsb25UcmFuc2l0aW9uID0gdHJhbnNpdGlvbiBhcyBFcHNpbG9uVHJhbnNpdGlvbjtcclxuXHRcdFx0XHRpZiAoZXBzaWxvblRyYW5zaXRpb24ub3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cHJlY2VkZW5jZURlY2lzaW9uWzFdLnByZWNlZGVuY2VMb29wYmFja1N0YXRlcy5zZXQodHJhbnNpdGlvbi50YXJnZXQuc3RhdGVOdW1iZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgdmVyaWZ5QVROKGF0bjogQVROKTogdm9pZCB7XHJcblx0XHQvLyB2ZXJpZnkgYXNzdW1wdGlvbnNcclxuXHRcdGZvciAobGV0IHN0YXRlIG9mIGF0bi5zdGF0ZXMpIHtcclxuXHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZSAhPT0gdW5kZWZpbmVkLCBcIkFUTiBzdGF0ZXMgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQuXCIpO1xyXG5cdFx0XHRpZiAoc3RhdGUuc3RhdGVUeXBlID09PSBBVE5TdGF0ZVR5cGUuSU5WQUxJRF9UWVBFKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUub25seUhhc0Vwc2lsb25UcmFuc2l0aW9ucyB8fCBzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zIDw9IDEpO1xyXG5cclxuXHRcdFx0aWYgKHN0YXRlIGluc3RhbmNlb2YgUGx1c0Jsb2NrU3RhcnRTdGF0ZSkge1xyXG5cdFx0XHRcdHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUubG9vcEJhY2tTdGF0ZSAhPT0gdW5kZWZpbmVkKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKSB7XHJcblx0XHRcdFx0bGV0IHN0YXJMb29wRW50cnlTdGF0ZTogU3Rhckxvb3BFbnRyeVN0YXRlID0gc3RhdGU7XHJcblx0XHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbihzdGFyTG9vcEVudHJ5U3RhdGUubG9vcEJhY2tTdGF0ZSAhPT0gdW5kZWZpbmVkKTtcclxuXHRcdFx0XHR0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXJMb29wRW50cnlTdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zID09PSAyKTtcclxuXHJcblx0XHRcdFx0aWYgKHN0YXJMb29wRW50cnlTdGF0ZS50cmFuc2l0aW9uKDApLnRhcmdldCBpbnN0YW5jZW9mIFN0YXJCbG9ja1N0YXJ0U3RhdGUpIHtcclxuXHRcdFx0XHRcdHRoaXMuY2hlY2tDb25kaXRpb24oc3Rhckxvb3BFbnRyeVN0YXRlLnRyYW5zaXRpb24oMSkudGFyZ2V0IGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKTtcclxuXHRcdFx0XHRcdHRoaXMuY2hlY2tDb25kaXRpb24oIXN0YXJMb29wRW50cnlTdGF0ZS5ub25HcmVlZHkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmIChzdGFyTG9vcEVudHJ5U3RhdGUudHJhbnNpdGlvbigwKS50YXJnZXQgaW5zdGFuY2VvZiBMb29wRW5kU3RhdGUpIHtcclxuXHRcdFx0XHRcdHRoaXMuY2hlY2tDb25kaXRpb24oc3Rhckxvb3BFbnRyeVN0YXRlLnRyYW5zaXRpb24oMSkudGFyZ2V0IGluc3RhbmNlb2YgU3RhckJsb2NrU3RhcnRTdGF0ZSk7XHJcblx0XHRcdFx0XHR0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXJMb29wRW50cnlTdGF0ZS5ub25HcmVlZHkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIklsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChzdGF0ZSBpbnN0YW5jZW9mIFN0YXJMb29wYmFja1N0YXRlKSB7XHJcblx0XHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zID09PSAxKTtcclxuXHRcdFx0XHR0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnRyYW5zaXRpb24oMCkudGFyZ2V0IGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHN0YXRlIGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKSB7XHJcblx0XHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5sb29wQmFja1N0YXRlICE9PSB1bmRlZmluZWQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RhcnRTdGF0ZSkge1xyXG5cdFx0XHRcdHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUuc3RvcFN0YXRlICE9PSB1bmRlZmluZWQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoc3RhdGUgaW5zdGFuY2VvZiBCbG9ja1N0YXJ0U3RhdGUpIHtcclxuXHRcdFx0XHR0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLmVuZFN0YXRlICE9PSB1bmRlZmluZWQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoc3RhdGUgaW5zdGFuY2VvZiBCbG9ja0VuZFN0YXRlKSB7XHJcblx0XHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5zdGFydFN0YXRlICE9PSB1bmRlZmluZWQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoc3RhdGUgaW5zdGFuY2VvZiBEZWNpc2lvblN0YXRlKSB7XHJcblx0XHRcdFx0bGV0IGRlY2lzaW9uU3RhdGU6IERlY2lzaW9uU3RhdGUgPSBzdGF0ZTtcclxuXHRcdFx0XHR0aGlzLmNoZWNrQ29uZGl0aW9uKGRlY2lzaW9uU3RhdGUubnVtYmVyT2ZUcmFuc2l0aW9ucyA8PSAxIHx8IGRlY2lzaW9uU3RhdGUuZGVjaXNpb24gPj0gMCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zIDw9IDEgfHwgc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGNoZWNrQ29uZGl0aW9uKGNvbmRpdGlvbjogYm9vbGVhbiwgbWVzc2FnZT86IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0aWYgKCFjb25kaXRpb24pIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbFN0YXRlRXhjZXB0aW9uOiBcIiArIG1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgaW5saW5lU2V0UnVsZXMoYXRuOiBBVE4pOiBudW1iZXIge1xyXG5cdFx0bGV0IGlubGluZWRDYWxsczogbnVtYmVyID0gMDtcclxuXHJcblx0XHRsZXQgcnVsZVRvSW5saW5lVHJhbnNpdGlvbiA9IG5ldyBBcnJheTxUcmFuc2l0aW9uIHwgdW5kZWZpbmVkPihhdG4ucnVsZVRvU3RhcnRTdGF0ZS5sZW5ndGgpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhdG4ucnVsZVRvU3RhcnRTdGF0ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgc3RhcnRTdGF0ZTogUnVsZVN0YXJ0U3RhdGUgPSBhdG4ucnVsZVRvU3RhcnRTdGF0ZVtpXTtcclxuXHRcdFx0bGV0IG1pZGRsZVN0YXRlOiBBVE5TdGF0ZSA9IHN0YXJ0U3RhdGU7XHJcblx0XHRcdHdoaWxlIChtaWRkbGVTdGF0ZS5vbmx5SGFzRXBzaWxvblRyYW5zaXRpb25zXHJcblx0XHRcdFx0JiYgbWlkZGxlU3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyA9PT0gMVxyXG5cdFx0XHRcdCYmIG1pZGRsZVN0YXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oMCkuc2VyaWFsaXphdGlvblR5cGUgPT09IFRyYW5zaXRpb25UeXBlLkVQU0lMT04pIHtcclxuXHRcdFx0XHRtaWRkbGVTdGF0ZSA9IG1pZGRsZVN0YXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oMCkudGFyZ2V0O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAobWlkZGxlU3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyAhPT0gMSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgbWF0Y2hUcmFuc2l0aW9uOiBUcmFuc2l0aW9uID0gbWlkZGxlU3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbigwKTtcclxuXHRcdFx0bGV0IG1hdGNoVGFyZ2V0OiBBVE5TdGF0ZSA9IG1hdGNoVHJhbnNpdGlvbi50YXJnZXQ7XHJcblx0XHRcdGlmIChtYXRjaFRyYW5zaXRpb24uaXNFcHNpbG9uXHJcblx0XHRcdFx0fHwgIW1hdGNoVGFyZ2V0Lm9ubHlIYXNFcHNpbG9uVHJhbnNpdGlvbnNcclxuXHRcdFx0XHR8fCBtYXRjaFRhcmdldC5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zICE9PSAxXHJcblx0XHRcdFx0fHwgIShtYXRjaFRhcmdldC5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKDApLnRhcmdldCBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN3aXRjaCAobWF0Y2hUcmFuc2l0aW9uLnNlcmlhbGl6YXRpb25UeXBlKSB7XHJcblx0XHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuQVRPTTpcclxuXHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5SQU5HRTpcclxuXHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5TRVQ6XHJcblx0XHRcdFx0cnVsZVRvSW5saW5lVHJhbnNpdGlvbltpXSA9IG1hdGNoVHJhbnNpdGlvbjtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuTk9UX1NFVDpcclxuXHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5XSUxEQ0FSRDpcclxuXHRcdFx0XHQvLyBub3QgaW1wbGVtZW50ZWQgeWV0XHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xyXG5cdFx0XHRpZiAoc3RhdGUucnVsZUluZGV4IDwgMCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgb3B0aW1pemVkVHJhbnNpdGlvbnM6IFRyYW5zaXRpb25bXSB8IHVuZGVmaW5lZDtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zOyBpKyspIHtcclxuXHRcdFx0XHRsZXQgdHJhbnNpdGlvbjogVHJhbnNpdGlvbiA9IHN0YXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oaSk7XHJcblx0XHRcdFx0aWYgKCEodHJhbnNpdGlvbiBpbnN0YW5jZW9mIFJ1bGVUcmFuc2l0aW9uKSkge1xyXG5cdFx0XHRcdFx0aWYgKG9wdGltaXplZFRyYW5zaXRpb25zICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0b3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBydWxlVHJhbnNpdGlvbjogUnVsZVRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xyXG5cdFx0XHRcdGxldCBlZmZlY3RpdmU6IFRyYW5zaXRpb24gfCB1bmRlZmluZWQgPSBydWxlVG9JbmxpbmVUcmFuc2l0aW9uW3J1bGVUcmFuc2l0aW9uLnRhcmdldC5ydWxlSW5kZXhdO1xyXG5cdFx0XHRcdGlmIChlZmZlY3RpdmUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0aWYgKG9wdGltaXplZFRyYW5zaXRpb25zICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0b3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChvcHRpbWl6ZWRUcmFuc2l0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRvcHRpbWl6ZWRUcmFuc2l0aW9ucyA9IFtdO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspIHtcclxuXHRcdFx0XHRcdFx0b3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaChzdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKGkpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlubGluZWRDYWxscysrO1xyXG5cdFx0XHRcdGxldCB0YXJnZXQ6IEFUTlN0YXRlID0gcnVsZVRyYW5zaXRpb24uZm9sbG93U3RhdGU7XHJcblx0XHRcdFx0bGV0IGludGVybWVkaWF0ZVN0YXRlOiBBVE5TdGF0ZSA9IG5ldyBCYXNpY1N0YXRlKCk7XHJcblx0XHRcdFx0aW50ZXJtZWRpYXRlU3RhdGUuc2V0UnVsZUluZGV4KHRhcmdldC5ydWxlSW5kZXgpO1xyXG5cdFx0XHRcdGF0bi5hZGRTdGF0ZShpbnRlcm1lZGlhdGVTdGF0ZSk7XHJcblx0XHRcdFx0b3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaChuZXcgRXBzaWxvblRyYW5zaXRpb24oaW50ZXJtZWRpYXRlU3RhdGUpKTtcclxuXHJcblx0XHRcdFx0c3dpdGNoIChlZmZlY3RpdmUuc2VyaWFsaXphdGlvblR5cGUpIHtcclxuXHRcdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLkFUT006XHJcblx0XHRcdFx0XHRpbnRlcm1lZGlhdGVTdGF0ZS5hZGRUcmFuc2l0aW9uKG5ldyBBdG9tVHJhbnNpdGlvbih0YXJnZXQsIChlZmZlY3RpdmUgYXMgQXRvbVRyYW5zaXRpb24pLl9sYWJlbCkpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUkFOR0U6XHJcblx0XHRcdFx0XHRpbnRlcm1lZGlhdGVTdGF0ZS5hZGRUcmFuc2l0aW9uKG5ldyBSYW5nZVRyYW5zaXRpb24odGFyZ2V0LCAoZWZmZWN0aXZlIGFzIFJhbmdlVHJhbnNpdGlvbikuZnJvbSwgKGVmZmVjdGl2ZSBhcyBSYW5nZVRyYW5zaXRpb24pLnRvKSk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5TRVQ6XHJcblx0XHRcdFx0XHRpbnRlcm1lZGlhdGVTdGF0ZS5hZGRUcmFuc2l0aW9uKG5ldyBTZXRUcmFuc2l0aW9uKHRhcmdldCwgKGVmZmVjdGl2ZSBhcyBTZXRUcmFuc2l0aW9uKS5sYWJlbCkpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvblwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvcHRpbWl6ZWRUcmFuc2l0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0aWYgKHN0YXRlLmlzT3B0aW1pemVkKSB7XHJcblx0XHRcdFx0XHR3aGlsZSAoc3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyA+IDApIHtcclxuXHRcdFx0XHRcdFx0c3RhdGUucmVtb3ZlT3B0aW1pemVkVHJhbnNpdGlvbihzdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zIC0gMSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKGxldCB0cmFuc2l0aW9uIG9mIG9wdGltaXplZFRyYW5zaXRpb25zKSB7XHJcblx0XHRcdFx0XHRzdGF0ZS5hZGRPcHRpbWl6ZWRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJBVE4gcnVudGltZSBvcHRpbWl6ZXIgcmVtb3ZlZCBcIiArIGlubGluZWRDYWxscyArIFwiIHJ1bGUgaW52b2NhdGlvbnMgYnkgaW5saW5pbmcgc2V0cy5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlubGluZWRDYWxscztcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGNvbWJpbmVDaGFpbmVkRXBzaWxvbnMoYXRuOiBBVE4pOiBudW1iZXIge1xyXG5cdFx0bGV0IHJlbW92ZWRFZGdlczogbnVtYmVyID0gMDtcclxuXHJcblx0XHRmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XHJcblx0XHRcdGlmICghc3RhdGUub25seUhhc0Vwc2lsb25UcmFuc2l0aW9ucyB8fCBzdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IG9wdGltaXplZFRyYW5zaXRpb25zOiBUcmFuc2l0aW9uW10gfCB1bmRlZmluZWQ7XHJcblx0XHRcdG5leHRUcmFuc2l0aW9uOlxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnM7IGkrKykge1xyXG5cdFx0XHRcdGxldCB0cmFuc2l0aW9uOiBUcmFuc2l0aW9uID0gc3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihpKTtcclxuXHRcdFx0XHRsZXQgaW50ZXJtZWRpYXRlOiBBVE5TdGF0ZSA9IHRyYW5zaXRpb24udGFyZ2V0O1xyXG5cdFx0XHRcdGlmICh0cmFuc2l0aW9uLnNlcmlhbGl6YXRpb25UeXBlICE9PSBUcmFuc2l0aW9uVHlwZS5FUFNJTE9OXHJcblx0XHRcdFx0XHR8fCAodHJhbnNpdGlvbiBhcyBFcHNpbG9uVHJhbnNpdGlvbikub3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiAhPT0gLTFcclxuXHRcdFx0XHRcdHx8IGludGVybWVkaWF0ZS5zdGF0ZVR5cGUgIT09IEFUTlN0YXRlVHlwZS5CQVNJQ1xyXG5cdFx0XHRcdFx0fHwgIWludGVybWVkaWF0ZS5vbmx5SGFzRXBzaWxvblRyYW5zaXRpb25zKSB7XHJcblx0XHRcdFx0XHRpZiAob3B0aW1pemVkVHJhbnNpdGlvbnMgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKHRyYW5zaXRpb24pO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnRpbnVlIG5leHRUcmFuc2l0aW9uO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBpbnRlcm1lZGlhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9uczsgaisrKSB7XHJcblx0XHRcdFx0XHRpZiAoaW50ZXJtZWRpYXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oaikuc2VyaWFsaXphdGlvblR5cGUgIT09IFRyYW5zaXRpb25UeXBlLkVQU0lMT05cclxuXHRcdFx0XHRcdFx0fHwgKGludGVybWVkaWF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKGopIGFzIEVwc2lsb25UcmFuc2l0aW9uKS5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRpZiAob3B0aW1pemVkVHJhbnNpdGlvbnMgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdG9wdGltaXplZFRyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlIG5leHRUcmFuc2l0aW9uO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmVtb3ZlZEVkZ2VzKys7XHJcblx0XHRcdFx0aWYgKG9wdGltaXplZFRyYW5zaXRpb25zID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdG9wdGltaXplZFRyYW5zaXRpb25zID0gW107XHJcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKykge1xyXG5cdFx0XHRcdFx0XHRvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKHN0YXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oaikpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBpbnRlcm1lZGlhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9uczsgaisrKSB7XHJcblx0XHRcdFx0XHRsZXQgdGFyZ2V0OiBBVE5TdGF0ZSA9IGludGVybWVkaWF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKGopLnRhcmdldDtcclxuXHRcdFx0XHRcdG9wdGltaXplZFRyYW5zaXRpb25zLnB1c2gobmV3IEVwc2lsb25UcmFuc2l0aW9uKHRhcmdldCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG9wdGltaXplZFRyYW5zaXRpb25zICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRpZiAoc3RhdGUuaXNPcHRpbWl6ZWQpIHtcclxuXHRcdFx0XHRcdHdoaWxlIChzdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zID4gMCkge1xyXG5cdFx0XHRcdFx0XHRzdGF0ZS5yZW1vdmVPcHRpbWl6ZWRUcmFuc2l0aW9uKHN0YXRlLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgLSAxKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IHRyYW5zaXRpb24gb2Ygb3B0aW1pemVkVHJhbnNpdGlvbnMpIHtcclxuXHRcdFx0XHRcdHN0YXRlLmFkZE9wdGltaXplZFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkFUTiBydW50aW1lIG9wdGltaXplciByZW1vdmVkIFwiICsgcmVtb3ZlZEVkZ2VzICsgXCIgdHJhbnNpdGlvbnMgYnkgY29tYmluaW5nIGNoYWluZWQgZXBzaWxvbiB0cmFuc2l0aW9ucy5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlbW92ZWRFZGdlcztcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIG9wdGltaXplU2V0cyhhdG46IEFUTiwgcHJlc2VydmVPcmRlcjogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRpZiAocHJlc2VydmVPcmRlcikge1xyXG5cdFx0XHQvLyB0aGlzIG9wdGltaXphdGlvbiBjdXJyZW50bHkgZG9lc24ndCBwcmVzZXJ2ZSBlZGdlIG9yZGVyLlxyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVtb3ZlZFBhdGhzOiBudW1iZXIgPSAwO1xyXG5cdFx0bGV0IGRlY2lzaW9uczogRGVjaXNpb25TdGF0ZVtdID0gYXRuLmRlY2lzaW9uVG9TdGF0ZTtcclxuXHRcdGZvciAobGV0IGRlY2lzaW9uIG9mIGRlY2lzaW9ucykge1xyXG5cdFx0XHRsZXQgc2V0VHJhbnNpdGlvbnM6IEludGVydmFsU2V0ID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGVjaXNpb24ubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9uczsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IGVwc1RyYW5zaXRpb246IFRyYW5zaXRpb24gPSBkZWNpc2lvbi5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKGkpO1xyXG5cdFx0XHRcdGlmICghKGVwc1RyYW5zaXRpb24gaW5zdGFuY2VvZiBFcHNpbG9uVHJhbnNpdGlvbikpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGVwc1RyYW5zaXRpb24udGFyZ2V0Lm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgIT09IDEpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IHRyYW5zaXRpb246IFRyYW5zaXRpb24gPSBlcHNUcmFuc2l0aW9uLnRhcmdldC5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKDApO1xyXG5cdFx0XHRcdGlmICghKHRyYW5zaXRpb24udGFyZ2V0IGluc3RhbmNlb2YgQmxvY2tFbmRTdGF0ZSkpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBOb3RTZXRUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0XHQvLyBUT0RPOiBub3QgeWV0IGltcGxlbWVudGVkXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgQXRvbVRyYW5zaXRpb25cclxuXHRcdFx0XHRcdHx8IHRyYW5zaXRpb24gaW5zdGFuY2VvZiBSYW5nZVRyYW5zaXRpb25cclxuXHRcdFx0XHRcdHx8IHRyYW5zaXRpb24gaW5zdGFuY2VvZiBTZXRUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0XHRzZXRUcmFuc2l0aW9ucy5hZGQoaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoc2V0VHJhbnNpdGlvbnMuc2l6ZSA8PSAxKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBvcHRpbWl6ZWRUcmFuc2l0aW9uczogVHJhbnNpdGlvbltdID0gW107XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGVjaXNpb24ubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9uczsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKCFzZXRUcmFuc2l0aW9ucy5jb250YWlucyhpKSkge1xyXG5cdFx0XHRcdFx0b3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaChkZWNpc2lvbi5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKGkpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBibG9ja0VuZFN0YXRlOiBBVE5TdGF0ZSA9IGRlY2lzaW9uLmdldE9wdGltaXplZFRyYW5zaXRpb24oc2V0VHJhbnNpdGlvbnMubWluRWxlbWVudCkudGFyZ2V0LmdldE9wdGltaXplZFRyYW5zaXRpb24oMCkudGFyZ2V0O1xyXG5cdFx0XHRsZXQgbWF0Y2hTZXQ6IEludGVydmFsU2V0ID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHRcdGZvciAobGV0IGludGVydmFsIG9mIHNldFRyYW5zaXRpb25zLmludGVydmFscykge1xyXG5cdFx0XHRcdGZvciAobGV0IGogPSBpbnRlcnZhbC5hOyBqIDw9IGludGVydmFsLmI7IGorKykge1xyXG5cdFx0XHRcdFx0bGV0IG1hdGNoVHJhbnNpdGlvbjogVHJhbnNpdGlvbiA9IGRlY2lzaW9uLmdldE9wdGltaXplZFRyYW5zaXRpb24oaikudGFyZ2V0LmdldE9wdGltaXplZFRyYW5zaXRpb24oMCk7XHJcblx0XHRcdFx0XHRpZiAobWF0Y2hUcmFuc2l0aW9uIGluc3RhbmNlb2YgTm90U2V0VHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdG1hdGNoU2V0LmFkZEFsbChtYXRjaFRyYW5zaXRpb24ubGFiZWwgYXMgSW50ZXJ2YWxTZXQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IG5ld1RyYW5zaXRpb246IFRyYW5zaXRpb247XHJcblx0XHRcdGlmIChtYXRjaFNldC5pbnRlcnZhbHMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdFx0aWYgKG1hdGNoU2V0LnNpemUgPT09IDEpIHtcclxuXHRcdFx0XHRcdG5ld1RyYW5zaXRpb24gPSBuZXcgQXRvbVRyYW5zaXRpb24oYmxvY2tFbmRTdGF0ZSwgbWF0Y2hTZXQubWluRWxlbWVudCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGxldCBtYXRjaEludGVydmFsOiBJbnRlcnZhbCA9IG1hdGNoU2V0LmludGVydmFsc1swXTtcclxuXHRcdFx0XHRcdG5ld1RyYW5zaXRpb24gPSBuZXcgUmFuZ2VUcmFuc2l0aW9uKGJsb2NrRW5kU3RhdGUsIG1hdGNoSW50ZXJ2YWwuYSwgbWF0Y2hJbnRlcnZhbC5iKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bmV3VHJhbnNpdGlvbiA9IG5ldyBTZXRUcmFuc2l0aW9uKGJsb2NrRW5kU3RhdGUsIG1hdGNoU2V0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHNldE9wdGltaXplZFN0YXRlOiBBVE5TdGF0ZSA9IG5ldyBCYXNpY1N0YXRlKCk7XHJcblx0XHRcdHNldE9wdGltaXplZFN0YXRlLnNldFJ1bGVJbmRleChkZWNpc2lvbi5ydWxlSW5kZXgpO1xyXG5cdFx0XHRhdG4uYWRkU3RhdGUoc2V0T3B0aW1pemVkU3RhdGUpO1xyXG5cclxuXHRcdFx0c2V0T3B0aW1pemVkU3RhdGUuYWRkVHJhbnNpdGlvbihuZXdUcmFuc2l0aW9uKTtcclxuXHRcdFx0b3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaChuZXcgRXBzaWxvblRyYW5zaXRpb24oc2V0T3B0aW1pemVkU3RhdGUpKTtcclxuXHJcblx0XHRcdHJlbW92ZWRQYXRocyArPSBkZWNpc2lvbi5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zIC0gb3B0aW1pemVkVHJhbnNpdGlvbnMubGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKGRlY2lzaW9uLmlzT3B0aW1pemVkKSB7XHJcblx0XHRcdFx0d2hpbGUgKGRlY2lzaW9uLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgPiAwKSB7XHJcblx0XHRcdFx0XHRkZWNpc2lvbi5yZW1vdmVPcHRpbWl6ZWRUcmFuc2l0aW9uKGRlY2lzaW9uLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgLSAxKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAobGV0IHRyYW5zaXRpb24gb2Ygb3B0aW1pemVkVHJhbnNpdGlvbnMpIHtcclxuXHRcdFx0XHRkZWNpc2lvbi5hZGRPcHRpbWl6ZWRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkFUTiBydW50aW1lIG9wdGltaXplciByZW1vdmVkIFwiICsgcmVtb3ZlZFBhdGhzICsgXCIgcGF0aHMgYnkgY29sbGFwc2luZyBzZXRzLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVtb3ZlZFBhdGhzO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgaWRlbnRpZnlUYWlsQ2FsbHMoYXRuOiBBVE4pOiB2b2lkIHtcclxuXHRcdGZvciAobGV0IHN0YXRlIG9mIGF0bi5zdGF0ZXMpIHtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zOyBpKyspIHtcclxuXHRcdFx0XHRsZXQgdHJhbnNpdGlvbiA9IHN0YXRlLnRyYW5zaXRpb24oaSk7XHJcblx0XHRcdFx0aWYgKCEodHJhbnNpdGlvbiBpbnN0YW5jZW9mIFJ1bGVUcmFuc2l0aW9uKSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0cmFuc2l0aW9uLnRhaWxDYWxsID0gdGhpcy50ZXN0VGFpbENhbGwoYXRuLCB0cmFuc2l0aW9uLCBmYWxzZSk7XHJcblx0XHRcdFx0dHJhbnNpdGlvbi5vcHRpbWl6ZWRUYWlsQ2FsbCA9IHRoaXMudGVzdFRhaWxDYWxsKGF0biwgdHJhbnNpdGlvbiwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghc3RhdGUuaXNPcHRpbWl6ZWQpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zOyBpKyspIHtcclxuXHRcdFx0XHRsZXQgdHJhbnNpdGlvbiA9IHN0YXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oaSk7XHJcblx0XHRcdFx0aWYgKCEodHJhbnNpdGlvbiBpbnN0YW5jZW9mIFJ1bGVUcmFuc2l0aW9uKSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0cmFuc2l0aW9uLnRhaWxDYWxsID0gdGhpcy50ZXN0VGFpbENhbGwoYXRuLCB0cmFuc2l0aW9uLCBmYWxzZSk7XHJcblx0XHRcdFx0dHJhbnNpdGlvbi5vcHRpbWl6ZWRUYWlsQ2FsbCA9IHRoaXMudGVzdFRhaWxDYWxsKGF0biwgdHJhbnNpdGlvbiwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIHRlc3RUYWlsQ2FsbChhdG46IEFUTiwgdHJhbnNpdGlvbjogUnVsZVRyYW5zaXRpb24sIG9wdGltaXplZFBhdGg6IGJvb2xlYW4pOiBib29sZWFuIHtcclxuXHRcdGlmICghb3B0aW1pemVkUGF0aCAmJiB0cmFuc2l0aW9uLnRhaWxDYWxsKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG9wdGltaXplZFBhdGggJiYgdHJhbnNpdGlvbi5vcHRpbWl6ZWRUYWlsQ2FsbCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVhY2hhYmxlOiBCaXRTZXQgPSBuZXcgQml0U2V0KGF0bi5zdGF0ZXMubGVuZ3RoKTtcclxuXHRcdGxldCB3b3JrbGlzdDogQVROU3RhdGVbXSA9IFtdO1xyXG5cdFx0d29ya2xpc3QucHVzaCh0cmFuc2l0aW9uLmZvbGxvd1N0YXRlKTtcclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGxldCBzdGF0ZSA9IHdvcmtsaXN0LnBvcCgpO1xyXG5cdFx0XHRpZiAoIXN0YXRlKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChyZWFjaGFibGUuZ2V0KHN0YXRlLnN0YXRlTnVtYmVyKSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghc3RhdGUub25seUhhc0Vwc2lsb25UcmFuc2l0aW9ucykge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHRyYW5zaXRpb25Db3VudCA9IG9wdGltaXplZFBhdGggPyBzdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zIDogc3RhdGUubnVtYmVyT2ZUcmFuc2l0aW9ucztcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2l0aW9uQ291bnQ7IGkrKykge1xyXG5cdFx0XHRcdGxldCB0ID0gb3B0aW1pemVkUGF0aCA/IHN0YXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oaSkgOiBzdGF0ZS50cmFuc2l0aW9uKGkpO1xyXG5cdFx0XHRcdGlmICh0LnNlcmlhbGl6YXRpb25UeXBlICE9PSBUcmFuc2l0aW9uVHlwZS5FUFNJTE9OKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR3b3JrbGlzdC5wdXNoKHQudGFyZ2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHN0YXRpYyB0b0ludChjOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIGM7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgc3RhdGljIHRvSW50MzIoZGF0YTogVWludDE2QXJyYXksIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiAoZGF0YVtvZmZzZXRdIHwgKGRhdGFbb2Zmc2V0ICsgMV0gPDwgMTYpKSA+Pj4gMDtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBzdGF0aWMgdG9VVUlEKGRhdGE6IFVpbnQxNkFycmF5LCBvZmZzZXQ6IG51bWJlcik6IFVVSUQge1xyXG5cdFx0bGV0IGxlYXN0U2lnQml0czogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50MzIoZGF0YSwgb2Zmc2V0KTtcclxuXHRcdGxldCBsZXNzU2lnQml0czogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50MzIoZGF0YSwgb2Zmc2V0ICsgMik7XHJcblx0XHRsZXQgbW9yZVNpZ0JpdHM6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludDMyKGRhdGEsIG9mZnNldCArIDQpO1xyXG5cdFx0bGV0IG1vc3RTaWdCaXRzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQzMihkYXRhLCBvZmZzZXQgKyA2KTtcclxuXHRcdHJldHVybiBuZXcgVVVJRChtb3N0U2lnQml0cywgbW9yZVNpZ0JpdHMsIGxlc3NTaWdCaXRzLCBsZWFzdFNpZ0JpdHMpO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgZWRnZUZhY3RvcnkoXHJcblx0XHRATm90TnVsbCBhdG46IEFUTixcclxuXHRcdHR5cGU6IFRyYW5zaXRpb25UeXBlLCBzcmM6IG51bWJlciwgdHJnOiBudW1iZXIsXHJcblx0XHRhcmcxOiBudW1iZXIsIGFyZzI6IG51bWJlciwgYXJnMzogbnVtYmVyLFxyXG5cdFx0c2V0czogSW50ZXJ2YWxTZXRbXSk6IFRyYW5zaXRpb24ge1xyXG5cdFx0bGV0IHRhcmdldDogQVROU3RhdGUgPSBhdG4uc3RhdGVzW3RyZ107XHJcblx0XHRzd2l0Y2ggKHR5cGUpIHtcclxuXHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5FUFNJTE9OOiByZXR1cm4gbmV3IEVwc2lsb25UcmFuc2l0aW9uKHRhcmdldCk7XHJcblx0XHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUkFOR0U6XHJcblx0XHRcdFx0aWYgKGFyZzMgIT09IDApIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgUmFuZ2VUcmFuc2l0aW9uKHRhcmdldCwgVG9rZW4uRU9GLCBhcmcyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFJhbmdlVHJhbnNpdGlvbih0YXJnZXQsIGFyZzEsIGFyZzIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5SVUxFOlxyXG5cdFx0XHRcdGxldCBydDogUnVsZVRyYW5zaXRpb24gPSBuZXcgUnVsZVRyYW5zaXRpb24oYXRuLnN0YXRlc1thcmcxXSBhcyBSdWxlU3RhcnRTdGF0ZSwgYXJnMiwgYXJnMywgdGFyZ2V0KTtcclxuXHRcdFx0XHRyZXR1cm4gcnQ7XHJcblx0XHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUFJFRElDQVRFOlxyXG5cdFx0XHRcdGxldCBwdDogUHJlZGljYXRlVHJhbnNpdGlvbiA9IG5ldyBQcmVkaWNhdGVUcmFuc2l0aW9uKHRhcmdldCwgYXJnMSwgYXJnMiwgYXJnMyAhPT0gMCk7XHJcblx0XHRcdFx0cmV0dXJuIHB0O1xyXG5cdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlBSRUNFREVOQ0U6XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbih0YXJnZXQsIGFyZzEpO1xyXG5cdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLkFUT006XHJcblx0XHRcdFx0aWYgKGFyZzMgIT09IDApIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgQXRvbVRyYW5zaXRpb24odGFyZ2V0LCBUb2tlbi5FT0YpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgQXRvbVRyYW5zaXRpb24odGFyZ2V0LCBhcmcxKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuQUNUSU9OOlxyXG5cdFx0XHRcdGxldCBhOiBBY3Rpb25UcmFuc2l0aW9uID0gbmV3IEFjdGlvblRyYW5zaXRpb24odGFyZ2V0LCBhcmcxLCBhcmcyLCBhcmczICE9PSAwKTtcclxuXHRcdFx0XHRyZXR1cm4gYTtcclxuXHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5TRVQ6IHJldHVybiBuZXcgU2V0VHJhbnNpdGlvbih0YXJnZXQsIHNldHNbYXJnMV0pO1xyXG5cdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLk5PVF9TRVQ6IHJldHVybiBuZXcgTm90U2V0VHJhbnNpdGlvbih0YXJnZXQsIHNldHNbYXJnMV0pO1xyXG5cdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLldJTERDQVJEOiByZXR1cm4gbmV3IFdpbGRjYXJkVHJhbnNpdGlvbih0YXJnZXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSBzcGVjaWZpZWQgdHJhbnNpdGlvbiB0eXBlIGlzIG5vdCB2YWxpZC5cIik7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgc3RhdGVGYWN0b3J5KHR5cGU6IEFUTlN0YXRlVHlwZSwgcnVsZUluZGV4OiBudW1iZXIpOiBBVE5TdGF0ZSB7XHJcblx0XHRsZXQgczogQVROU3RhdGU7XHJcblx0XHRzd2l0Y2ggKHR5cGUpIHtcclxuXHRcdFx0Y2FzZSBBVE5TdGF0ZVR5cGUuSU5WQUxJRF9UWVBFOiByZXR1cm4gbmV3IEludmFsaWRTdGF0ZSgpO1xyXG5cdFx0XHRjYXNlIEFUTlN0YXRlVHlwZS5CQVNJQzogcyA9IG5ldyBCYXNpY1N0YXRlKCk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIEFUTlN0YXRlVHlwZS5SVUxFX1NUQVJUOiBzID0gbmV3IFJ1bGVTdGFydFN0YXRlKCk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIEFUTlN0YXRlVHlwZS5CTE9DS19TVEFSVDogcyA9IG5ldyBCYXNpY0Jsb2NrU3RhcnRTdGF0ZSgpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBBVE5TdGF0ZVR5cGUuUExVU19CTE9DS19TVEFSVDogcyA9IG5ldyBQbHVzQmxvY2tTdGFydFN0YXRlKCk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIEFUTlN0YXRlVHlwZS5TVEFSX0JMT0NLX1NUQVJUOiBzID0gbmV3IFN0YXJCbG9ja1N0YXJ0U3RhdGUoKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgQVROU3RhdGVUeXBlLlRPS0VOX1NUQVJUOiBzID0gbmV3IFRva2Vuc1N0YXJ0U3RhdGUoKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgQVROU3RhdGVUeXBlLlJVTEVfU1RPUDogcyA9IG5ldyBSdWxlU3RvcFN0YXRlKCk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIEFUTlN0YXRlVHlwZS5CTE9DS19FTkQ6IHMgPSBuZXcgQmxvY2tFbmRTdGF0ZSgpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBBVE5TdGF0ZVR5cGUuU1RBUl9MT09QX0JBQ0s6IHMgPSBuZXcgU3Rhckxvb3BiYWNrU3RhdGUoKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgQVROU3RhdGVUeXBlLlNUQVJfTE9PUF9FTlRSWTogcyA9IG5ldyBTdGFyTG9vcEVudHJ5U3RhdGUoKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgQVROU3RhdGVUeXBlLlBMVVNfTE9PUF9CQUNLOiBzID0gbmV3IFBsdXNMb29wYmFja1N0YXRlKCk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIEFUTlN0YXRlVHlwZS5MT09QX0VORDogcyA9IG5ldyBMb29wRW5kU3RhdGUoKTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0bGV0IG1lc3NhZ2U6IHN0cmluZyA9IGBUaGUgc3BlY2lmaWVkIHN0YXRlIHR5cGUgJHt0eXBlfSBpcyBub3QgdmFsaWQuYDtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XHJcblx0XHRyZXR1cm4gcztcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBsZXhlckFjdGlvbkZhY3RvcnkodHlwZTogTGV4ZXJBY3Rpb25UeXBlLCBkYXRhMTogbnVtYmVyLCBkYXRhMjogbnVtYmVyKTogTGV4ZXJBY3Rpb24ge1xyXG5cdFx0c3dpdGNoICh0eXBlKSB7XHJcblx0XHRjYXNlIExleGVyQWN0aW9uVHlwZS5DSEFOTkVMOlxyXG5cdFx0XHRyZXR1cm4gbmV3IExleGVyQ2hhbm5lbEFjdGlvbihkYXRhMSk7XHJcblxyXG5cdFx0Y2FzZSBMZXhlckFjdGlvblR5cGUuQ1VTVE9NOlxyXG5cdFx0XHRyZXR1cm4gbmV3IExleGVyQ3VzdG9tQWN0aW9uKGRhdGExLCBkYXRhMik7XHJcblxyXG5cdFx0Y2FzZSBMZXhlckFjdGlvblR5cGUuTU9ERTpcclxuXHRcdFx0cmV0dXJuIG5ldyBMZXhlck1vZGVBY3Rpb24oZGF0YTEpO1xyXG5cclxuXHRcdGNhc2UgTGV4ZXJBY3Rpb25UeXBlLk1PUkU6XHJcblx0XHRcdHJldHVybiBMZXhlck1vcmVBY3Rpb24uSU5TVEFOQ0U7XHJcblxyXG5cdFx0Y2FzZSBMZXhlckFjdGlvblR5cGUuUE9QX01PREU6XHJcblx0XHRcdHJldHVybiBMZXhlclBvcE1vZGVBY3Rpb24uSU5TVEFOQ0U7XHJcblxyXG5cdFx0Y2FzZSBMZXhlckFjdGlvblR5cGUuUFVTSF9NT0RFOlxyXG5cdFx0XHRyZXR1cm4gbmV3IExleGVyUHVzaE1vZGVBY3Rpb24oZGF0YTEpO1xyXG5cclxuXHRcdGNhc2UgTGV4ZXJBY3Rpb25UeXBlLlNLSVA6XHJcblx0XHRcdHJldHVybiBMZXhlclNraXBBY3Rpb24uSU5TVEFOQ0U7XHJcblxyXG5cdFx0Y2FzZSBMZXhlckFjdGlvblR5cGUuVFlQRTpcclxuXHRcdFx0cmV0dXJuIG5ldyBMZXhlclR5cGVBY3Rpb24oZGF0YTEpO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdGxldCBtZXNzYWdlOiBzdHJpbmcgPSBgVGhlIHNwZWNpZmllZCBsZXhlciBhY3Rpb24gdHlwZSAke3R5cGV9IGlzIG5vdCB2YWxpZC5gO1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozMS4wMzQ5NjA1LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBEZWNpc2lvbkluZm8gfSBmcm9tIFwiLi9EZWNpc2lvbkluZm9cIjtcclxuaW1wb3J0IHsgREZBIH0gZnJvbSBcIi4uL2RmYS9ERkFcIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFByb2ZpbGluZ0FUTlNpbXVsYXRvciB9IGZyb20gXCIuL1Byb2ZpbGluZ0FUTlNpbXVsYXRvclwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYWNjZXNzIHRvIHNwZWNpZmljIGFuZCBhZ2dyZWdhdGUgc3RhdGlzdGljcyBnYXRoZXJlZFxyXG4gKiBkdXJpbmcgcHJvZmlsaW5nIG9mIGEgcGFyc2VyLlxyXG4gKlxyXG4gKiBAc2luY2UgNC4zXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGFyc2VJbmZvIHtcclxuXHRwcm90ZWN0ZWQgYXRuU2ltdWxhdG9yOiBQcm9maWxpbmdBVE5TaW11bGF0b3I7XHJcblxyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIGF0blNpbXVsYXRvcjogUHJvZmlsaW5nQVROU2ltdWxhdG9yKSB7XHJcblx0XHR0aGlzLmF0blNpbXVsYXRvciA9IGF0blNpbXVsYXRvcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgYW4gYXJyYXkgb2Yge0BsaW5rIERlY2lzaW9uSW5mb30gaW5zdGFuY2VzIGNvbnRhaW5pbmcgdGhlIHByb2ZpbGluZ1xyXG5cdCAqIGluZm9ybWF0aW9uIGdhdGhlcmVkIGZvciBlYWNoIGRlY2lzaW9uIGluIHRoZSBBVE4uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB7QGxpbmsgRGVjaXNpb25JbmZvfSBpbnN0YW5jZXMsIGluZGV4ZWQgYnkgZGVjaXNpb25cclxuXHQgKiBudW1iZXIuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0RGVjaXNpb25JbmZvKCk6IERlY2lzaW9uSW5mb1tdIHtcclxuXHRcdHJldHVybiB0aGlzLmF0blNpbXVsYXRvci5nZXREZWNpc2lvbkluZm8oKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGRlY2lzaW9uIG51bWJlcnMgZm9yIGRlY2lzaW9ucyB0aGF0IHJlcXVpcmVkIG9uZSBvciBtb3JlXHJcblx0ICogZnVsbC1jb250ZXh0IHByZWRpY3Rpb25zIGR1cmluZyBwYXJzaW5nLiBUaGVzZSBhcmUgZGVjaXNpb25zIGZvciB3aGljaFxyXG5cdCAqIHtAbGluayBEZWNpc2lvbkluZm8jTExfRmFsbGJhY2t9IGlzIG5vbi16ZXJvLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgQSBsaXN0IG9mIGRlY2lzaW9uIG51bWJlcnMgd2hpY2ggcmVxdWlyZWQgb25lIG9yIG1vcmVcclxuXHQgKiBmdWxsLWNvbnRleHQgcHJlZGljdGlvbnMgZHVyaW5nIHBhcnNpbmcuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0TExEZWNpc2lvbnMoKTogbnVtYmVyW10ge1xyXG5cdFx0bGV0IGRlY2lzaW9uczogRGVjaXNpb25JbmZvW10gPSB0aGlzLmF0blNpbXVsYXRvci5nZXREZWNpc2lvbkluZm8oKTtcclxuXHRcdGxldCBMTDogbnVtYmVyW10gPSBbXTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGVjaXNpb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBmYWxsQmFjazogbnVtYmVyID0gZGVjaXNpb25zW2ldLkxMX0ZhbGxiYWNrO1xyXG5cdFx0XHRpZiAoZmFsbEJhY2sgPiAwKSB7XHJcblx0XHRcdFx0TEwucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBMTDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHRvdGFsIHRpbWUgc3BlbnQgZHVyaW5nIHByZWRpY3Rpb24gYWNyb3NzIGFsbCBkZWNpc2lvbnMgbWFkZVxyXG5cdCAqIGR1cmluZyBwYXJzaW5nLiBUaGlzIHZhbHVlIGlzIHRoZSBzdW0gb2ZcclxuXHQgKiB7QGxpbmsgRGVjaXNpb25JbmZvI3RpbWVJblByZWRpY3Rpb259IGZvciBhbGwgZGVjaXNpb25zLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRUb3RhbFRpbWVJblByZWRpY3Rpb24oKTogbnVtYmVyIHtcclxuXHRcdGxldCBkZWNpc2lvbnM6IERlY2lzaW9uSW5mb1tdID0gdGhpcy5hdG5TaW11bGF0b3IuZ2V0RGVjaXNpb25JbmZvKCk7XHJcblx0XHRsZXQgdDogbnVtYmVyID0gMDtcclxuXHRcdGZvciAobGV0IGRlY2lzaW9uIG9mIGRlY2lzaW9ucykge1xyXG5cdFx0XHR0ICs9IGRlY2lzaW9uLnRpbWVJblByZWRpY3Rpb247XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2YgU0xMIGxvb2thaGVhZCBvcGVyYXRpb25zIGFjcm9zcyBhbGwgZGVjaXNpb25zXHJcblx0ICogbWFkZSBkdXJpbmcgcGFyc2luZy4gVGhpcyB2YWx1ZSBpcyB0aGUgc3VtIG9mXHJcblx0ICoge0BsaW5rIERlY2lzaW9uSW5mbyNTTExfVG90YWxMb29rfSBmb3IgYWxsIGRlY2lzaW9ucy5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0VG90YWxTTExMb29rYWhlYWRPcHMoKTogbnVtYmVyIHtcclxuXHRcdGxldCBkZWNpc2lvbnM6IERlY2lzaW9uSW5mb1tdID0gdGhpcy5hdG5TaW11bGF0b3IuZ2V0RGVjaXNpb25JbmZvKCk7XHJcblx0XHRsZXQgazogbnVtYmVyID0gMDtcclxuXHRcdGZvciAobGV0IGRlY2lzaW9uIG9mIGRlY2lzaW9ucykge1xyXG5cdFx0XHRrICs9IGRlY2lzaW9uLlNMTF9Ub3RhbExvb2s7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGs7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2YgTEwgbG9va2FoZWFkIG9wZXJhdGlvbnMgYWNyb3NzIGFsbCBkZWNpc2lvbnNcclxuXHQgKiBtYWRlIGR1cmluZyBwYXJzaW5nLiBUaGlzIHZhbHVlIGlzIHRoZSBzdW0gb2ZcclxuXHQgKiB7QGxpbmsgRGVjaXNpb25JbmZvI0xMX1RvdGFsTG9va30gZm9yIGFsbCBkZWNpc2lvbnMuXHJcblx0ICovXHJcblx0cHVibGljIGdldFRvdGFsTExMb29rYWhlYWRPcHMoKTogbnVtYmVyIHtcclxuXHRcdGxldCBkZWNpc2lvbnM6IERlY2lzaW9uSW5mb1tdID0gdGhpcy5hdG5TaW11bGF0b3IuZ2V0RGVjaXNpb25JbmZvKCk7XHJcblx0XHRsZXQgazogbnVtYmVyID0gMDtcclxuXHRcdGZvciAobGV0IGRlY2lzaW9uIG9mIGRlY2lzaW9ucykge1xyXG5cdFx0XHRrICs9IGRlY2lzaW9uLkxMX1RvdGFsTG9vaztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBBVE4gbG9va2FoZWFkIG9wZXJhdGlvbnMgZm9yIFNMTCBwcmVkaWN0aW9uXHJcblx0ICogYWNyb3NzIGFsbCBkZWNpc2lvbnMgbWFkZSBkdXJpbmcgcGFyc2luZy5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0VG90YWxTTExBVE5Mb29rYWhlYWRPcHMoKTogbnVtYmVyIHtcclxuXHRcdGxldCBkZWNpc2lvbnM6IERlY2lzaW9uSW5mb1tdID0gdGhpcy5hdG5TaW11bGF0b3IuZ2V0RGVjaXNpb25JbmZvKCk7XHJcblx0XHRsZXQgazogbnVtYmVyID0gMDtcclxuXHRcdGZvciAobGV0IGRlY2lzaW9uIG9mIGRlY2lzaW9ucykge1xyXG5cdFx0XHRrICs9IGRlY2lzaW9uLlNMTF9BVE5UcmFuc2l0aW9ucztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBBVE4gbG9va2FoZWFkIG9wZXJhdGlvbnMgZm9yIExMIHByZWRpY3Rpb25cclxuXHQgKiBhY3Jvc3MgYWxsIGRlY2lzaW9ucyBtYWRlIGR1cmluZyBwYXJzaW5nLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRUb3RhbExMQVROTG9va2FoZWFkT3BzKCk6IG51bWJlciB7XHJcblx0XHRsZXQgZGVjaXNpb25zOiBEZWNpc2lvbkluZm9bXSA9IHRoaXMuYXRuU2ltdWxhdG9yLmdldERlY2lzaW9uSW5mbygpO1xyXG5cdFx0bGV0IGs6IG51bWJlciA9IDA7XHJcblx0XHRmb3IgKGxldCBkZWNpc2lvbiBvZiBkZWNpc2lvbnMpIHtcclxuXHRcdFx0ayArPSBkZWNpc2lvbi5MTF9BVE5UcmFuc2l0aW9ucztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBBVE4gbG9va2FoZWFkIG9wZXJhdGlvbnMgZm9yIFNMTCBhbmQgTExcclxuXHQgKiBwcmVkaWN0aW9uIGFjcm9zcyBhbGwgZGVjaXNpb25zIG1hZGUgZHVyaW5nIHBhcnNpbmcuXHJcblx0ICpcclxuXHQgKiBUaGlzIHZhbHVlIGlzIHRoZSBzdW0gb2Yge0BsaW5rICNnZXRUb3RhbFNMTEFUTkxvb2thaGVhZE9wc30gYW5kXHJcblx0ICoge0BsaW5rICNnZXRUb3RhbExMQVROTG9va2FoZWFkT3BzfS5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0VG90YWxBVE5Mb29rYWhlYWRPcHMoKTogbnVtYmVyIHtcclxuXHRcdGxldCBkZWNpc2lvbnM6IERlY2lzaW9uSW5mb1tdID0gdGhpcy5hdG5TaW11bGF0b3IuZ2V0RGVjaXNpb25JbmZvKCk7XHJcblx0XHRsZXQgazogbnVtYmVyID0gMDtcclxuXHRcdGZvciAobGV0IGRlY2lzaW9uIG9mIGRlY2lzaW9ucykge1xyXG5cdFx0XHRrICs9IGRlY2lzaW9uLlNMTF9BVE5UcmFuc2l0aW9ucztcclxuXHRcdFx0ayArPSBkZWNpc2lvbi5MTF9BVE5UcmFuc2l0aW9ucztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBERkEgc3RhdGVzIHN0b3JlZCBpbiB0aGUgREZBIGNhY2hlIGZvciBhbGxcclxuXHQgKiBkZWNpc2lvbnMgaW4gdGhlIEFUTi5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0REZBU2l6ZSgpOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBERkEgc3RhdGVzIHN0b3JlZCBpbiB0aGUgREZBIGNhY2hlIGZvciBhXHJcblx0ICogcGFydGljdWxhciBkZWNpc2lvbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0REZBU2l6ZShkZWNpc2lvbjogbnVtYmVyKTogbnVtYmVyO1xyXG5cclxuXHRwdWJsaWMgZ2V0REZBU2l6ZShkZWNpc2lvbj86IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRpZiAoZGVjaXNpb24pIHtcclxuXHRcdFx0bGV0IGRlY2lzaW9uVG9ERkE6IERGQSA9IHRoaXMuYXRuU2ltdWxhdG9yLmF0bi5kZWNpc2lvblRvREZBW2RlY2lzaW9uXTtcclxuXHRcdFx0cmV0dXJuIGRlY2lzaW9uVG9ERkEuc3RhdGVzLnNpemU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgbjogbnVtYmVyID0gMDtcclxuXHRcdFx0bGV0IGRlY2lzaW9uVG9ERkE6IERGQVtdID0gdGhpcy5hdG5TaW11bGF0b3IuYXRuLmRlY2lzaW9uVG9ERkE7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGVjaXNpb25Ub0RGQS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdG4gKz0gdGhpcy5nZXRERkFTaXplKGkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbjtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU2Ljk4MTIyODQtMDc6MDBcclxuaW1wb3J0IHsgQU5UTFJFcnJvckxpc3RlbmVyIH0gZnJvbSBcIi4vQU5UTFJFcnJvckxpc3RlbmVyXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuL2F0bi9BVE5Db25maWdTZXRcIjtcclxuaW1wb3J0IHsgQml0U2V0IH0gZnJvbSBcIi4vbWlzYy9CaXRTZXRcIjtcclxuaW1wb3J0IHsgREZBIH0gZnJvbSBcIi4vZGZhL0RGQVwiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi9QYXJzZXJcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4vUmVjb2duaXplclwiO1xyXG5pbXBvcnQgeyBQcm94eUVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi9Qcm94eUVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VyRXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL1BhcnNlckVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgU2ltdWxhdG9yU3RhdGUgfSBmcm9tIFwiLi9hdG4vU2ltdWxhdG9yU3RhdGVcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUHJveHlQYXJzZXJFcnJvckxpc3RlbmVyIGV4dGVuZHMgUHJveHlFcnJvckxpc3RlbmVyPFRva2VuLCBQYXJzZXJFcnJvckxpc3RlbmVyPlxyXG5cdGltcGxlbWVudHMgUGFyc2VyRXJyb3JMaXN0ZW5lciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGRlbGVnYXRlczogUGFyc2VyRXJyb3JMaXN0ZW5lcltdKSB7XHJcblx0XHRzdXBlcihkZWxlZ2F0ZXMpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlcG9ydEFtYmlndWl0eShcclxuXHRcdHJlY29nbml6ZXI6IFBhcnNlcixcclxuXHRcdGRmYTogREZBLFxyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyLFxyXG5cdFx0c3RvcEluZGV4OiBudW1iZXIsXHJcblx0XHRleGFjdDogYm9vbGVhbixcclxuXHRcdGFtYmlnQWx0czogQml0U2V0IHwgdW5kZWZpbmVkLFxyXG5cdFx0Y29uZmlnczogQVROQ29uZmlnU2V0KTogdm9pZCB7XHJcblx0XHR0aGlzLmdldERlbGVnYXRlcygpXHJcblx0XHRcdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xyXG5cdFx0XHRcdGlmIChsaXN0ZW5lci5yZXBvcnRBbWJpZ3VpdHkpIHtcclxuXHRcdFx0XHRcdGxpc3RlbmVyLnJlcG9ydEFtYmlndWl0eShcclxuXHRcdFx0XHRcdFx0cmVjb2duaXplcixcclxuXHRcdFx0XHRcdFx0ZGZhLFxyXG5cdFx0XHRcdFx0XHRzdGFydEluZGV4LFxyXG5cdFx0XHRcdFx0XHRzdG9wSW5kZXgsXHJcblx0XHRcdFx0XHRcdGV4YWN0LFxyXG5cdFx0XHRcdFx0XHRhbWJpZ0FsdHMsXHJcblx0XHRcdFx0XHRcdGNvbmZpZ3MpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0pO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dChcclxuXHRcdHJlY29nbml6ZXI6IFBhcnNlcixcclxuXHRcdGRmYTogREZBLFxyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyLFxyXG5cdFx0c3RvcEluZGV4OiBudW1iZXIsXHJcblx0XHRjb25mbGljdGluZ0FsdHM6IEJpdFNldCB8IHVuZGVmaW5lZCxcclxuXHRcdGNvbmZsaWN0U3RhdGU6IFNpbXVsYXRvclN0YXRlKTogdm9pZCB7XHJcblx0XHR0aGlzLmdldERlbGVnYXRlcygpXHJcblx0XHRcdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xyXG5cdFx0XHRcdGlmIChsaXN0ZW5lci5yZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQpIHtcclxuXHRcdFx0XHRcdGxpc3RlbmVyLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dChcclxuXHRcdFx0XHRcdFx0cmVjb2duaXplcixcclxuXHRcdFx0XHRcdFx0ZGZhLFxyXG5cdFx0XHRcdFx0XHRzdGFydEluZGV4LFxyXG5cdFx0XHRcdFx0XHRzdG9wSW5kZXgsXHJcblx0XHRcdFx0XHRcdGNvbmZsaWN0aW5nQWx0cyxcclxuXHRcdFx0XHRcdFx0Y29uZmxpY3RTdGF0ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkoXHJcblx0XHRyZWNvZ25pemVyOiBQYXJzZXIsXHJcblx0XHRkZmE6IERGQSxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyLFxyXG5cdFx0cHJlZGljdGlvbjogbnVtYmVyLFxyXG5cdFx0YWNjZXB0U3RhdGU6IFNpbXVsYXRvclN0YXRlKTogdm9pZCB7XHJcblx0XHR0aGlzLmdldERlbGVnYXRlcygpXHJcblx0XHRcdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xyXG5cdFx0XHRcdGlmIChsaXN0ZW5lci5yZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkpIHtcclxuXHRcdFx0XHRcdGxpc3RlbmVyLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eShcclxuXHRcdFx0XHRcdFx0cmVjb2duaXplcixcclxuXHRcdFx0XHRcdFx0ZGZhLFxyXG5cdFx0XHRcdFx0XHRzdGFydEluZGV4LFxyXG5cdFx0XHRcdFx0XHRzdG9wSW5kZXgsXHJcblx0XHRcdFx0XHRcdHByZWRpY3Rpb24sXHJcblx0XHRcdFx0XHRcdGFjY2VwdFN0YXRlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNIaWdoU3Vycm9nYXRlKGNoOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRyZXR1cm4gY2ggPj0gMHhEODAwICYmIGNoIDw9IDB4REJGRjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTG93U3Vycm9nYXRlKGNoOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRyZXR1cm4gY2ggPj0gMHhEQzAwICYmIGNoIDw9IDB4REZGRjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU3VwcGxlbWVudGFyeUNvZGVQb2ludChjaDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0cmV0dXJuIGNoID49IDB4MTAwMDA7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcclxuaW1wb3J0ICogYXMgQ2hhcmFjdGVyIGZyb20gXCIuL21pc2MvQ2hhcmFjdGVyXCI7XHJcblxyXG4vKipcclxuICogV3JhcHBlciBmb3IgYFVpbnQ4QXJyYXlgIC8gYFVpbnQxNkFycmF5YCAvIGBJbnQzMkFycmF5YC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb2RlUG9pbnRCdWZmZXIge1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgYnVmZmVyOiBVaW50OEFycmF5IHwgVWludDE2QXJyYXkgfCBJbnQzMkFycmF5O1xyXG5cdHByaXZhdGUgX3Bvc2l0aW9uOiBudW1iZXI7XHJcblx0cHJpdmF0ZSBfc2l6ZTogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihidWZmZXI6IFVpbnQ4QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDMyQXJyYXksIHNpemU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5idWZmZXIgPSBidWZmZXI7XHJcblx0XHR0aGlzLl9wb3NpdGlvbiA9IDA7XHJcblx0XHR0aGlzLl9zaXplID0gc2l6ZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgd2l0aEFycmF5KGJ1ZmZlcjogVWludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MzJBcnJheSk6IENvZGVQb2ludEJ1ZmZlciB7XHJcblx0XHRyZXR1cm4gbmV3IENvZGVQb2ludEJ1ZmZlcihidWZmZXIsIGJ1ZmZlci5sZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldCBwb3NpdGlvbigpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldCBwb3NpdGlvbihuZXdQb3NpdGlvbjogbnVtYmVyKSB7XHJcblx0XHRpZiAobmV3UG9zaXRpb24gPCAwIHx8IG5ld1Bvc2l0aW9uID4gdGhpcy5fc2l6ZSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3Bvc2l0aW9uID0gbmV3UG9zaXRpb247XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0IHJlbWFpbmluZygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUgLSB0aGlzLnBvc2l0aW9uO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldChvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5idWZmZXJbb2Zmc2V0XTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhcnJheSgpOiBVaW50OEFycmF5IHwgVWludDE2QXJyYXkgfCBJbnQzMkFycmF5IHtcclxuXHRcdHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLl9zaXplKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgYnVpbGRlcihpbml0aWFsQnVmZmVyU2l6ZTogbnVtYmVyKTogQ29kZVBvaW50QnVmZmVyLkJ1aWxkZXIge1xyXG5cdFx0cmV0dXJuIG5ldyBDb2RlUG9pbnRCdWZmZXIuQnVpbGRlcihpbml0aWFsQnVmZmVyU2l6ZSk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIENvZGVQb2ludEJ1ZmZlciB7XHJcblx0Y29uc3QgZW51bSBUeXBlIHtcclxuXHRcdEJZVEUsXHJcblx0XHRDSEFSLFxyXG5cdFx0SU5ULFxyXG5cdH1cclxuXHJcblx0ZXhwb3J0IGNsYXNzIEJ1aWxkZXIge1xyXG5cdFx0cHJpdmF0ZSB0eXBlOiBUeXBlO1xyXG5cdFx0cHJpdmF0ZSBidWZmZXI6IFVpbnQ4QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDMyQXJyYXk7XHJcblx0XHRwcml2YXRlIHByZXZIaWdoU3Vycm9nYXRlOiBudW1iZXI7XHJcblx0XHRwcml2YXRlIHBvc2l0aW9uOiBudW1iZXI7XHJcblxyXG5cdFx0Y29uc3RydWN0b3IoaW5pdGlhbEJ1ZmZlclNpemU6IG51bWJlcikge1xyXG5cdFx0XHR0aGlzLnR5cGUgPSBUeXBlLkJZVEU7XHJcblx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoaW5pdGlhbEJ1ZmZlclNpemUpO1xyXG5cdFx0XHR0aGlzLnByZXZIaWdoU3Vycm9nYXRlID0gLTE7XHJcblx0XHRcdHRoaXMucG9zaXRpb24gPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHB1YmxpYyBidWlsZCgpOiBDb2RlUG9pbnRCdWZmZXIge1xyXG5cdFx0XHRyZXR1cm4gbmV3IENvZGVQb2ludEJ1ZmZlcih0aGlzLmJ1ZmZlciwgdGhpcy5wb3NpdGlvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0cHJpdmF0ZSBzdGF0aWMgcm91bmRVcFRvTmV4dFBvd2VyT2ZUd28oaTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdFx0bGV0IG5leHRQb3dlck9mVHdvOiBudW1iZXIgPSAzMiAtIE1hdGguY2x6MzIoaSAtIDEpO1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coMiwgbmV4dFBvd2VyT2ZUd28pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHB1YmxpYyBlbnN1cmVSZW1haW5pbmcocmVtYWluaW5nTmVlZGVkOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdFx0c3dpdGNoICh0aGlzLnR5cGUpIHtcclxuXHRcdFx0XHRjYXNlIFR5cGUuQllURTpcclxuXHRcdFx0XHRcdGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggLSB0aGlzLnBvc2l0aW9uIDwgcmVtYWluaW5nTmVlZGVkKSB7XHJcblx0XHRcdFx0XHRcdGxldCBuZXdDYXBhY2l0eTogbnVtYmVyID0gQnVpbGRlci5yb3VuZFVwVG9OZXh0UG93ZXJPZlR3byh0aGlzLmJ1ZmZlci5sZW5ndGggKyByZW1haW5pbmdOZWVkZWQpO1xyXG5cdFx0XHRcdFx0XHRsZXQgbmV3QnVmZmVyOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpO1xyXG5cdFx0XHRcdFx0XHRuZXdCdWZmZXIuc2V0KHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMucG9zaXRpb24pLCAwKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFR5cGUuQ0hBUjpcclxuXHRcdFx0XHRcdGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggLSB0aGlzLnBvc2l0aW9uIDwgcmVtYWluaW5nTmVlZGVkKSB7XHJcblx0XHRcdFx0XHRcdGxldCBuZXdDYXBhY2l0eTogbnVtYmVyID0gQnVpbGRlci5yb3VuZFVwVG9OZXh0UG93ZXJPZlR3byh0aGlzLmJ1ZmZlci5sZW5ndGggKyByZW1haW5pbmdOZWVkZWQpO1xyXG5cdFx0XHRcdFx0XHRsZXQgbmV3QnVmZmVyOiBVaW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheShuZXdDYXBhY2l0eSk7XHJcblx0XHRcdFx0XHRcdG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbiksIDApO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmJ1ZmZlciA9IG5ld0J1ZmZlcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgVHlwZS5JTlQ6XHJcblx0XHRcdFx0XHRpZiAodGhpcy5idWZmZXIubGVuZ3RoIC0gdGhpcy5wb3NpdGlvbiA8IHJlbWFpbmluZ05lZWRlZCkge1xyXG5cdFx0XHRcdFx0XHRsZXQgbmV3Q2FwYWNpdHk6IG51bWJlciA9IEJ1aWxkZXIucm91bmRVcFRvTmV4dFBvd2VyT2ZUd28odGhpcy5idWZmZXIubGVuZ3RoICsgcmVtYWluaW5nTmVlZGVkKTtcclxuXHRcdFx0XHRcdFx0bGV0IG5ld0J1ZmZlcjogSW50MzJBcnJheSA9IG5ldyBJbnQzMkFycmF5KG5ld0NhcGFjaXR5KTtcclxuXHRcdFx0XHRcdFx0bmV3QnVmZmVyLnNldCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSwgMCk7XHJcblx0XHRcdFx0XHRcdHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRwdWJsaWMgYXBwZW5kKHV0ZjE2SW46IFVpbnQxNkFycmF5KTogdm9pZCB7XHJcblx0XHRcdHRoaXMuZW5zdXJlUmVtYWluaW5nKHV0ZjE2SW4ubGVuZ3RoKTtcclxuXHRcdFx0dGhpcy5hcHBlbmRBcnJheSh1dGYxNkluKTtcclxuXHRcdH1cclxuXHJcblx0XHRwcml2YXRlIGFwcGVuZEFycmF5KHV0ZjE2SW46IFVpbnQxNkFycmF5KTogdm9pZCB7XHJcblx0XHRcdHN3aXRjaCAodGhpcy50eXBlKSB7XHJcblx0XHRcdFx0Y2FzZSBUeXBlLkJZVEU6XHJcblx0XHRcdFx0XHR0aGlzLmFwcGVuZEFycmF5Qnl0ZSh1dGYxNkluKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgVHlwZS5DSEFSOlxyXG5cdFx0XHRcdFx0dGhpcy5hcHBlbmRBcnJheUNoYXIodXRmMTZJbik7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFR5cGUuSU5UOlxyXG5cdFx0XHRcdFx0dGhpcy5hcHBlbmRBcnJheUludCh1dGYxNkluKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cHJpdmF0ZSBhcHBlbmRBcnJheUJ5dGUodXRmMTZJbjogVWludDE2QXJyYXkpOiB2b2lkIHtcclxuXHRcdFx0YXNzZXJ0KHRoaXMucHJldkhpZ2hTdXJyb2dhdGUgPT09IC0xKTtcclxuXHJcblx0XHRcdGxldCBpbnB1dDogVWludDE2QXJyYXkgPSB1dGYxNkluO1xyXG5cdFx0XHRsZXQgaW5PZmZzZXQ6IG51bWJlciA9IDA7XHJcblx0XHRcdGxldCBpbkxpbWl0OiBudW1iZXIgPSB1dGYxNkluLmxlbmd0aDtcclxuXHJcblx0XHRcdGxldCBvdXRCeXRlID0gdGhpcy5idWZmZXI7XHJcblx0XHRcdGxldCBvdXRPZmZzZXQ6IG51bWJlciA9IHRoaXMucG9zaXRpb247XHJcblxyXG5cdFx0XHR3aGlsZSAoaW5PZmZzZXQgPCBpbkxpbWl0KSB7XHJcblx0XHRcdFx0bGV0IGM6IG51bWJlciA9IGlucHV0W2luT2Zmc2V0XTtcclxuXHRcdFx0XHRpZiAoYyA8PSAweEZGKSB7XHJcblx0XHRcdFx0XHRvdXRCeXRlW291dE9mZnNldF0gPSBjO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR1dGYxNkluID0gdXRmMTZJbi5zdWJhcnJheShpbk9mZnNldCwgaW5MaW1pdCk7XHJcblx0XHRcdFx0XHR0aGlzLnBvc2l0aW9uID0gb3V0T2Zmc2V0O1xyXG5cdFx0XHRcdFx0aWYgKCFDaGFyYWN0ZXIuaXNIaWdoU3Vycm9nYXRlKGMpKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuYnl0ZVRvQ2hhckJ1ZmZlcih1dGYxNkluLmxlbmd0aCk7XHJcblx0XHRcdFx0XHRcdHRoaXMuYXBwZW5kQXJyYXlDaGFyKHV0ZjE2SW4pO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmJ5dGVUb0ludEJ1ZmZlcih1dGYxNkluLmxlbmd0aCk7XHJcblx0XHRcdFx0XHRcdHRoaXMuYXBwZW5kQXJyYXlJbnQodXRmMTZJbik7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGluT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3V0T2Zmc2V0Kys7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucG9zaXRpb24gPSBvdXRPZmZzZXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cHJpdmF0ZSBhcHBlbmRBcnJheUNoYXIodXRmMTZJbjogVWludDE2QXJyYXkpOiB2b2lkIHtcclxuXHRcdFx0YXNzZXJ0KHRoaXMucHJldkhpZ2hTdXJyb2dhdGUgPT09IC0xKTtcclxuXHJcblx0XHRcdGxldCBpbnB1dDogVWludDE2QXJyYXkgPSB1dGYxNkluO1xyXG5cdFx0XHRsZXQgaW5PZmZzZXQ6IG51bWJlciA9IDA7XHJcblx0XHRcdGxldCBpbkxpbWl0OiBudW1iZXIgPSB1dGYxNkluLmxlbmd0aDtcclxuXHJcblx0XHRcdGxldCBvdXRDaGFyID0gdGhpcy5idWZmZXI7XHJcblx0XHRcdGxldCBvdXRPZmZzZXQ6IG51bWJlciA9IHRoaXMucG9zaXRpb247XHJcblxyXG5cdFx0XHR3aGlsZSAoaW5PZmZzZXQgPCBpbkxpbWl0KSB7XHJcblx0XHRcdFx0bGV0IGM6IG51bWJlciA9IGlucHV0W2luT2Zmc2V0XTtcclxuXHRcdFx0XHRpZiAoIUNoYXJhY3Rlci5pc0hpZ2hTdXJyb2dhdGUoYykpIHtcclxuXHRcdFx0XHRcdG91dENoYXJbb3V0T2Zmc2V0XSA9IGM7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHV0ZjE2SW4gPSB1dGYxNkluLnN1YmFycmF5KGluT2Zmc2V0LCBpbkxpbWl0KTtcclxuXHRcdFx0XHRcdHRoaXMucG9zaXRpb24gPSBvdXRPZmZzZXQ7XHJcblx0XHRcdFx0XHR0aGlzLmNoYXJUb0ludEJ1ZmZlcih1dGYxNkluLmxlbmd0aCk7XHJcblx0XHRcdFx0XHR0aGlzLmFwcGVuZEFycmF5SW50KHV0ZjE2SW4pO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aW5PZmZzZXQrKztcclxuXHRcdFx0XHRvdXRPZmZzZXQrKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5wb3NpdGlvbiA9IG91dE9mZnNldDtcclxuXHRcdH1cclxuXHJcblx0XHRwcml2YXRlIGFwcGVuZEFycmF5SW50KHV0ZjE2SW46IFVpbnQxNkFycmF5KTogdm9pZCB7XHJcblx0XHRcdGxldCBpbnB1dDogVWludDE2QXJyYXkgPSB1dGYxNkluO1xyXG5cdFx0XHRsZXQgaW5PZmZzZXQ6IG51bWJlciA9IDA7XHJcblx0XHRcdGxldCBpbkxpbWl0OiBudW1iZXIgPSB1dGYxNkluLmxlbmd0aDtcclxuXHJcblx0XHRcdGxldCBvdXRJbnQgPSB0aGlzLmJ1ZmZlcjtcclxuXHRcdFx0bGV0IG91dE9mZnNldCA9IHRoaXMucG9zaXRpb247XHJcblxyXG5cdFx0XHR3aGlsZSAoaW5PZmZzZXQgPCBpbkxpbWl0KSB7XHJcblx0XHRcdFx0bGV0IGM6IG51bWJlciA9IGlucHV0W2luT2Zmc2V0XTtcclxuXHRcdFx0XHRpbk9mZnNldCsrO1xyXG5cdFx0XHRcdGlmICh0aGlzLnByZXZIaWdoU3Vycm9nYXRlICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0aWYgKENoYXJhY3Rlci5pc0xvd1N1cnJvZ2F0ZShjKSkge1xyXG5cdFx0XHRcdFx0XHRvdXRJbnRbb3V0T2Zmc2V0XSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZSwgYykuY29kZVBvaW50QXQoMCkhO1xyXG5cdFx0XHRcdFx0XHRvdXRPZmZzZXQrKztcclxuXHRcdFx0XHRcdFx0dGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZSA9IC0xO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Ly8gRGFuZ2xpbmcgaGlnaCBzdXJyb2dhdGVcclxuXHRcdFx0XHRcdFx0b3V0SW50W291dE9mZnNldF0gPSB0aGlzLnByZXZIaWdoU3Vycm9nYXRlO1xyXG5cdFx0XHRcdFx0XHRvdXRPZmZzZXQrKztcclxuXHRcdFx0XHRcdFx0aWYgKENoYXJhY3Rlci5pc0hpZ2hTdXJyb2dhdGUoYykpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnByZXZIaWdoU3Vycm9nYXRlID0gYztcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRvdXRJbnRbb3V0T2Zmc2V0XSA9IGM7XHJcblx0XHRcdFx0XHRcdFx0b3V0T2Zmc2V0Kys7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZSA9IC0xO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmIChDaGFyYWN0ZXIuaXNIaWdoU3Vycm9nYXRlKGMpKSB7XHJcblx0XHRcdFx0XHR0aGlzLnByZXZIaWdoU3Vycm9nYXRlID0gYztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0b3V0SW50W291dE9mZnNldF0gPSBjO1xyXG5cdFx0XHRcdFx0b3V0T2Zmc2V0Kys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZSAhPT0gLTEpIHtcclxuXHRcdFx0XHQvLyBEYW5nbGluZyBoaWdoIHN1cnJvZ2F0ZVxyXG5cdFx0XHRcdG91dEludFtvdXRPZmZzZXRdID0gdGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZTtcclxuXHRcdFx0XHRvdXRPZmZzZXQrKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5wb3NpdGlvbiA9IG91dE9mZnNldDtcclxuXHRcdH1cclxuXHJcblx0XHRwcml2YXRlIGJ5dGVUb0NoYXJCdWZmZXIodG9BcHBlbmQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0XHQvLyBDaGFyQnVmZmVycyBob2xkIHR3aWNlIGFzIG11Y2ggcGVyIHVuaXQgYXMgQnl0ZUJ1ZmZlcnMsIHNvIHN0YXJ0IHdpdGggaGFsZiB0aGUgY2FwYWNpdHkuXHJcblx0XHRcdGxldCBuZXdCdWZmZXI6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KE1hdGgubWF4KHRoaXMucG9zaXRpb24gKyB0b0FwcGVuZCwgdGhpcy5idWZmZXIubGVuZ3RoID4+IDEpKTtcclxuXHRcdFx0bmV3QnVmZmVyLnNldCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSwgMCk7XHJcblxyXG5cdFx0XHR0aGlzLnR5cGUgPSBUeXBlLkNIQVI7XHJcblx0XHRcdHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHByaXZhdGUgYnl0ZVRvSW50QnVmZmVyKHRvQXBwZW5kOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdFx0Ly8gSW50QnVmZmVycyBob2xkIGZvdXIgdGltZXMgYXMgbXVjaCBwZXIgdW5pdCBhcyBCeXRlQnVmZmVycywgc28gc3RhcnQgd2l0aCBvbmUgcXVhcnRlciB0aGUgY2FwYWNpdHkuXHJcblx0XHRcdGxldCBuZXdCdWZmZXI6IEludDMyQXJyYXkgPSBuZXcgSW50MzJBcnJheShNYXRoLm1heCh0aGlzLnBvc2l0aW9uICsgdG9BcHBlbmQsIHRoaXMuYnVmZmVyLmxlbmd0aCA+PiAyKSk7XHJcblx0XHRcdG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbiksIDApO1xyXG5cclxuXHRcdFx0dGhpcy50eXBlID0gVHlwZS5JTlQ7XHJcblx0XHRcdHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHByaXZhdGUgY2hhclRvSW50QnVmZmVyKHRvQXBwZW5kOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdFx0Ly8gSW50QnVmZmVycyBob2xkIHR3byB0aW1lcyBhcyBtdWNoIHBlciB1bml0IGFzIEJ5dGVCdWZmZXJzLCBzbyBzdGFydCB3aXRoIG9uZSBoYWxmIHRoZSBjYXBhY2l0eS5cclxuXHRcdFx0bGV0IG5ld0J1ZmZlcjogSW50MzJBcnJheSA9IG5ldyBJbnQzMkFycmF5KE1hdGgubWF4KHRoaXMucG9zaXRpb24gKyB0b0FwcGVuZCwgdGhpcy5idWZmZXIubGVuZ3RoID4+IDEpKTtcclxuXHRcdFx0bmV3QnVmZmVyLnNldCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSwgMCk7XHJcblxyXG5cdFx0XHR0aGlzLnR5cGUgPSBUeXBlLklOVDtcclxuXHRcdFx0dGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XHJcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiLi9DaGFyU3RyZWFtXCI7XHJcbmltcG9ydCB7IENvZGVQb2ludEJ1ZmZlciB9IGZyb20gXCIuL0NvZGVQb2ludEJ1ZmZlclwiO1xyXG5pbXBvcnQgeyBJbnRTdHJlYW0gfSBmcm9tIFwiLi9JbnRTdHJlYW1cIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIEFsdGVybmF0aXZlIHRvIHtAbGluayBBTlRMUklucHV0U3RyZWFtfSB3aGljaCB0cmVhdHMgdGhlIGlucHV0XHJcbiAqIGFzIGEgc2VyaWVzIG9mIFVuaWNvZGUgY29kZSBwb2ludHMsIGluc3RlYWQgb2YgYSBzZXJpZXMgb2YgVVRGLTE2XHJcbiAqIGNvZGUgdW5pdHMuXHJcbiAqXHJcbiAqIFVzZSB0aGlzIGlmIHlvdSBuZWVkIHRvIHBhcnNlIGlucHV0IHdoaWNoIHBvdGVudGlhbGx5IGNvbnRhaW5zXHJcbiAqIFVuaWNvZGUgdmFsdWVzID4gVStGRkZGLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvZGVQb2ludENoYXJTdHJlYW0gaW1wbGVtZW50cyBDaGFyU3RyZWFtIHtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9hcnJheTogVWludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MzJBcnJheTtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9zaXplOiBudW1iZXI7XHJcblx0cHJpdmF0ZSByZWFkb25seSBfbmFtZTogc3RyaW5nO1xyXG5cclxuXHRwcml2YXRlIF9wb3NpdGlvbjogbnVtYmVyO1xyXG5cclxuXHQvLyBVc2UgdGhlIGZhY3RvcnkgbWV0aG9kIHtAbGluayAjZnJvbUJ1ZmZlcihDb2RlUG9pbnRCdWZmZXIpfSB0b1xyXG5cdC8vIGNvbnN0cnVjdCBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxyXG5cdHByb3RlY3RlZCBjb25zdHJ1Y3RvcihhcnJheTogVWludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MzJBcnJheSwgcG9zaXRpb246IG51bWJlciwgcmVtYWluaW5nOiBudW1iZXIsIG5hbWU6IHN0cmluZykge1xyXG5cdFx0Ly8gVE9ET1xyXG5cdFx0YXNzZXJ0KHBvc2l0aW9uID09PSAwKTtcclxuXHRcdHRoaXMuX2FycmF5ID0gYXJyYXk7XHJcblx0XHR0aGlzLl9zaXplID0gcmVtYWluaW5nO1xyXG5cdFx0dGhpcy5fbmFtZSA9IG5hbWU7XHJcblx0XHR0aGlzLl9wb3NpdGlvbiA9IDA7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0IGludGVybmFsU3RvcmFnZSgpOiBVaW50OEFycmF5IHwgVWludDE2QXJyYXkgfCBJbnQzMkFycmF5IHtcclxuXHRcdHJldHVybiB0aGlzLl9hcnJheTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgQ29kZVBvaW50Q2hhclN0cmVhbX0gd2hpY2ggcHJvdmlkZXMgYWNjZXNzXHJcblx0ICogdG8gdGhlIFVuaWNvZGUgY29kZSBwb2ludHMgc3RvcmVkIGluIHtAY29kZSBjb2RlUG9pbnRCdWZmZXJ9LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgZnJvbUJ1ZmZlcihjb2RlUG9pbnRCdWZmZXI6IENvZGVQb2ludEJ1ZmZlcik6IENvZGVQb2ludENoYXJTdHJlYW07XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuYW1lZCB7QGxpbmsgQ29kZVBvaW50Q2hhclN0cmVhbX0gd2hpY2ggcHJvdmlkZXMgYWNjZXNzXHJcblx0ICogdG8gdGhlIFVuaWNvZGUgY29kZSBwb2ludHMgc3RvcmVkIGluIHtAY29kZSBjb2RlUG9pbnRCdWZmZXJ9LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgZnJvbUJ1ZmZlcihjb2RlUG9pbnRCdWZmZXI6IENvZGVQb2ludEJ1ZmZlciwgbmFtZTogc3RyaW5nKTogQ29kZVBvaW50Q2hhclN0cmVhbTtcclxuXHRwdWJsaWMgc3RhdGljIGZyb21CdWZmZXIoY29kZVBvaW50QnVmZmVyOiBDb2RlUG9pbnRCdWZmZXIsIG5hbWU/OiBzdHJpbmcpOiBDb2RlUG9pbnRDaGFyU3RyZWFtIHtcclxuXHRcdGlmIChuYW1lID09PSB1bmRlZmluZWQgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0bmFtZSA9IEludFN0cmVhbS5VTktOT1dOX1NPVVJDRV9OQU1FO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEphdmEgbGFja3MgZ2VuZXJpY3Mgb24gcHJpbWl0aXZlIHR5cGVzLlxyXG5cdFx0Ly9cclxuXHRcdC8vIFRvIGF2b2lkIGxvdHMgb2YgY2FsbHMgdG8gdmlydHVhbCBtZXRob2RzIGluIHRoZVxyXG5cdFx0Ly8gdmVyeSBob3QgY29kZXBhdGggb2YgTEEoKSBiZWxvdywgd2UgY29uc3RydWN0IG9uZVxyXG5cdFx0Ly8gb2YgdGhyZWUgY29uY3JldGUgc3ViY2xhc3Nlcy5cclxuXHRcdC8vXHJcblx0XHQvLyBUaGUgY29uY3JldGUgc3ViY2xhc3NlcyBkaXJlY3RseSBhY2Nlc3MgdGhlIGNvZGVcclxuXHRcdC8vIHBvaW50cyBzdG9yZWQgaW4gdGhlIHVuZGVybHlpbmcgYXJyYXkgKGJ5dGVbXSxcclxuXHRcdC8vIGNoYXJbXSwgb3IgaW50W10pLCBzbyB3ZSBjYW4gYXZvaWQgbG90cyBvZiB2aXJ0dWFsXHJcblx0XHQvLyBtZXRob2QgY2FsbHMgdG8gQnl0ZUJ1ZmZlci5nZXQob2Zmc2V0KS5cclxuXHRcdHJldHVybiBuZXcgQ29kZVBvaW50Q2hhclN0cmVhbShcclxuXHRcdFx0Y29kZVBvaW50QnVmZmVyLmFycmF5KCksXHJcblx0XHRcdGNvZGVQb2ludEJ1ZmZlci5wb3NpdGlvbixcclxuXHRcdFx0Y29kZVBvaW50QnVmZmVyLnJlbWFpbmluZyxcclxuXHRcdFx0bmFtZSk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgY29uc3VtZSgpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLl9zaXplIC0gdGhpcy5fcG9zaXRpb24gPT09IDApIHtcclxuXHRcdFx0YXNzZXJ0KHRoaXMuTEEoMSkgPT09IEludFN0cmVhbS5FT0YpO1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbm5vdCBjb25zdW1lIEVPRlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wb3NpdGlvbisrO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGdldCBpbmRleCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGdldCBzaXplKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZTtcclxuXHR9XHJcblxyXG5cdC8qKiBtYXJrL3JlbGVhc2UgZG8gbm90aGluZzsgd2UgaGF2ZSBlbnRpcmUgYnVmZmVyICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG1hcmsoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZWxlYXNlKG1hcmtlcjogbnVtYmVyKTogdm9pZCB7XHJcblx0XHQvLyBObyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNpbmNlIHRoaXMgc3RyZWFtIGJ1ZmZlcnMgdGhlIGVudGlyZSBpbnB1dFxyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHNlZWsoaW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5fcG9zaXRpb24gPSBpbmRleDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXQgc291cmNlTmFtZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25hbWU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFRleHQoSW50ZXJ2YWwub2YoMCwgdGhpcy5zaXplIC0gMSkpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIExBKGk6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRsZXQgb2Zmc2V0OiBudW1iZXI7XHJcblx0XHRzd2l0Y2ggKE1hdGguc2lnbihpKSkge1xyXG5cdFx0XHRjYXNlIC0xOlxyXG5cdFx0XHRcdG9mZnNldCA9IHRoaXMuaW5kZXggKyBpO1xyXG5cdFx0XHRcdGlmIChvZmZzZXQgPCAwKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gSW50U3RyZWFtLkVPRjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9hcnJheVtvZmZzZXRdO1xyXG5cclxuXHRcdFx0Y2FzZSAwOlxyXG5cdFx0XHRcdC8vIFVuZGVmaW5lZFxyXG5cdFx0XHRcdHJldHVybiAwO1xyXG5cclxuXHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdG9mZnNldCA9IHRoaXMuaW5kZXggKyBpIC0gMTtcclxuXHRcdFx0XHRpZiAob2Zmc2V0ID49IHRoaXMuc2l6ZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIEludFN0cmVhbS5FT0Y7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fYXJyYXlbb2Zmc2V0XTtcclxuXHRcdH1cclxuXHJcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vdCByZWFjaGVkXCIpO1xyXG5cdH1cclxuXHJcblx0LyoqIFJldHVybiB0aGUgVVRGLTE2IGVuY29kZWQgc3RyaW5nIGZvciB0aGUgZ2l2ZW4gaW50ZXJ2YWwgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0VGV4dChpbnRlcnZhbDogSW50ZXJ2YWwpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3Qgc3RhcnRJZHg6IG51bWJlciA9IE1hdGgubWluKGludGVydmFsLmEsIHRoaXMuc2l6ZSk7XHJcblx0XHRjb25zdCBsZW46IG51bWJlciA9IE1hdGgubWluKGludGVydmFsLmIgLSBpbnRlcnZhbC5hICsgMSwgdGhpcy5zaXplIC0gc3RhcnRJZHgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9hcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcclxuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLkFycmF5LmZyb20odGhpcy5fYXJyYXkuc3ViYXJyYXkoc3RhcnRJZHgsIHN0YXJ0SWR4ICsgbGVuKSkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uQXJyYXkuZnJvbSh0aGlzLl9hcnJheS5zdWJhcnJheShzdGFydElkeCwgc3RhcnRJZHggKyBsZW4pKSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IENvZGVQb2ludEJ1ZmZlciB9IGZyb20gXCIuL0NvZGVQb2ludEJ1ZmZlclwiO1xyXG5pbXBvcnQgeyBDb2RlUG9pbnRDaGFyU3RyZWFtIH0gZnJvbSBcIi4vQ29kZVBvaW50Q2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBJbnRTdHJlYW0gfSBmcm9tIFwiLi9JbnRTdHJlYW1cIjtcclxuXHJcbi8vIGNvbnN0IERFRkFVTFRfQlVGRkVSX1NJWkU6IG51bWJlciA9IDQwOTY7XHJcblxyXG4vKiogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBwcmltYXJ5IGludGVyZmFjZSBmb3IgY3JlYXRpbmcge0BsaW5rIENoYXJTdHJlYW19c1xyXG4gKiAgZnJvbSBhIHZhcmlldHkgb2Ygc291cmNlcyBhcyBvZiA0LjcuICBUaGUgbW90aXZhdGlvbiB3YXMgdG8gc3VwcG9ydFxyXG4gKiAgVW5pY29kZSBjb2RlIHBvaW50cyA+IFUrRkZGRi4gIHtAbGluayBBTlRMUklucHV0U3RyZWFtfSBhbmRcclxuICogIHtAbGluayBBTlRMUkZpbGVTdHJlYW19IGFyZSBub3cgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUgc3RyZWFtcyBjcmVhdGVkXHJcbiAqICBieSB0aGlzIGludGVyZmFjZS5cclxuICpcclxuICogIERFUFJFQ0FURUQ6IHtAY29kZSBuZXcgQU5UTFJGaWxlU3RyZWFtKFwibXlpbnB1dGZpbGVcIil9XHJcbiAqICBORVc6ICAgICAgICB7QGNvZGUgQ2hhclN0cmVhbXMuZnJvbUZpbGVOYW1lKFwibXlpbnB1dGZpbGVcIil9XHJcbiAqXHJcbiAqICBXQVJOSU5HOiBJZiB5b3UgdXNlIGJvdGggdGhlIGRlcHJlY2F0ZWQgYW5kIHRoZSBuZXcgc3RyZWFtcywgeW91IHdpbGwgc2VlXHJcbiAqICBhIG5vbnRyaXZpYWwgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24uIFRoaXMgc3BlZWQgaGl0IGlzIGJlY2F1c2UgdGhlXHJcbiAqICB7QGxpbmsgTGV4ZXJ9J3MgaW50ZXJuYWwgY29kZSBnb2VzIGZyb20gYSBtb25vbW9ycGhpYyB0byBtZWdhbW9ycGhpY1xyXG4gKiAgZHluYW1pYyBkaXNwYXRjaCB0byBnZXQgY2hhcmFjdGVycyBmcm9tIHRoZSBpbnB1dCBzdHJlYW0uIEphdmEnc1xyXG4gKiAgb24tdGhlLWZseSBjb21waWxlciAoSklUKSBpcyB1bmFibGUgdG8gcGVyZm9ybSB0aGUgc2FtZSBvcHRpbWl6YXRpb25zXHJcbiAqICBzbyBzdGljayB3aXRoIGVpdGhlciB0aGUgb2xkIG9yIHRoZSBuZXcgc3RyZWFtcywgaWYgcGVyZm9ybWFuY2UgaXNcclxuICogIGEgcHJpbWFyeSBjb25jZXJuLiBTZWUgdGhlIGV4dHJlbWUgZGVidWdnaW5nIGFuZCBzcGVsdW5raW5nXHJcbiAqICBuZWVkZWQgdG8gaWRlbnRpZnkgdGhpcyBpc3N1ZSBpbiBvdXIgdGltaW5nIHJpZzpcclxuICpcclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vYW50bHIvYW50bHI0L3B1bGwvMTc4MVxyXG4gKlxyXG4gKiAgVGhlIEFOVExSIGNoYXJhY3RlciBzdHJlYW1zIHN0aWxsIGJ1ZmZlciBhbGwgdGhlIGlucHV0IHdoZW4geW91IGNyZWF0ZVxyXG4gKiAgdGhlIHN0cmVhbSwgYXMgdGhleSBoYXZlIGRvbmUgZm9yIH4yMCB5ZWFycy4gSWYgeW91IG5lZWQgdW5idWZmZXJlZFxyXG4gKiAgYWNjZXNzLCBwbGVhc2Ugbm90ZSB0aGF0IGl0IGJlY29tZXMgY2hhbGxlbmdpbmcgdG8gY3JlYXRlXHJcbiAqICBwYXJzZSB0cmVlcy4gVGhlIHBhcnNlIHRyZWUgaGFzIHRvIHBvaW50IHRvIHRva2VucyB3aGljaCB3aWxsIGVpdGhlclxyXG4gKiAgcG9pbnQgaW50byBhIHN0YWxlIGxvY2F0aW9uIGluIGFuIHVuYnVmZmVyZWQgc3RyZWFtIG9yIHlvdSBoYXZlIHRvIGNvcHlcclxuICogIHRoZSBjaGFyYWN0ZXJzIG91dCBvZiB0aGUgYnVmZmVyIGludG8gdGhlIHRva2VuLiBUaGF0IGRlZmVhdHMgdGhlIHB1cnBvc2VcclxuICogIG9mIHVuYnVmZmVyZWQgaW5wdXQuIFBlciB0aGUgQU5UTFIgYm9vaywgdW5idWZmZXJlZCBzdHJlYW1zIGFyZSBwcmltYXJpbHlcclxuICogIHVzZWZ1bCBmb3IgcHJvY2Vzc2luZyBpbmZpbml0ZSBzdHJlYW1zICpkdXJpbmcgdGhlIHBhcnNlLipcclxuICpcclxuICogIFRoZSBuZXcgc3RyZWFtcyBhbHNvIHVzZSA4LWJpdCBidWZmZXJzIHdoZW4gcG9zc2libGUgc28gdGhpcyBuZXdcclxuICogIGludGVyZmFjZSBzdXBwb3J0cyBjaGFyYWN0ZXIgc3RyZWFtcyB0aGF0IHVzZSBoYWxmIGFzIG11Y2ggbWVtb3J5XHJcbiAqICBhcyB0aGUgb2xkIHtAbGluayBBTlRMUkZpbGVTdHJlYW19LCB3aGljaCBhc3N1bWVkIDE2LWJpdCBjaGFyYWN0ZXJzLlxyXG4gKlxyXG4gKiAgQSBiaWcgc2hvdXQgb3V0IHRvIEJlbiBIYW1pbHRvbiAoZ2l0aHViIGJoYW1pbHRvbmN4KSBmb3IgaGlzIHN1cGVyaHVtYW5cclxuICogIGVmZm9ydHMgYWNyb3NzIGFsbCB0YXJnZXRzIHRvIGdldCB0cnVlIFVuaWNvZGUgMy4xIHN1cHBvcnQgZm9yIFUrMTBGRkZGLlxyXG4gKlxyXG4gKiAgQHNpbmNlIDQuN1xyXG4gKi9cclxuZXhwb3J0IG5hbWVzcGFjZSBDaGFyU3RyZWFtcyB7XHJcblx0Ly8gLyoqXHJcblx0Ly8gICogQ3JlYXRlcyBhIHtAbGluayBDaGFyU3RyZWFtfSBnaXZlbiBhIHBhdGggdG8gYSBVVEYtOFxyXG5cdC8vICAqIGVuY29kZWQgZmlsZSBvbiBkaXNrLlxyXG5cdC8vICAqXHJcblx0Ly8gICogUmVhZHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUgZmlsZSBpbnRvIHRoZSByZXN1bHQgYmVmb3JlIHJldHVybmluZy5cclxuXHQvLyAgKi9cclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbUZpbGUoZmlsZTogRmlsZSk6IENoYXJTdHJlYW07XHJcblx0Ly8gZXhwb3J0IGZ1bmN0aW9uIGZyb21GaWxlKGZpbGU6IEZpbGUsIGNoYXJzZXQ6IENoYXJzZXQpOiBDaGFyU3RyZWFtO1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tRmlsZShmaWxlOiBGaWxlLCBjaGFyc2V0PzogQ2hhcnNldCk6IENoYXJTdHJlYW0ge1xyXG5cdC8vIFx0aWYgKGNoYXJzZXQgPT09IHVuZGVmaW5lZCkge1xyXG5cdC8vIFx0XHRjaGFyc2V0ID0gQ2hhcnNldC5mb3JOYW1lKFwiVVRGLThcIik7XHJcblx0Ly8gXHR9XHJcblxyXG5cdC8vIFx0bGV0IHNpemU6IG51bWJlciA9IGZpbGUubGVuZ3RoKCk7XHJcblx0Ly8gXHRyZXR1cm4gZnJvbVN0cmVhbShuZXcgRmlsZUlucHV0U3RyZWFtKGZpbGUpLCBjaGFyc2V0LCBmaWxlLnRvU3RyaW5nKCksIHNpemUpO1xyXG5cdC8vIH1cclxuXHJcblx0Ly8gLyoqXHJcblx0Ly8gICogQ3JlYXRlcyBhIHtAbGluayBDaGFyU3RyZWFtfSBnaXZlbiBhIHN0cmluZyBjb250YWluaW5nIGFcclxuXHQvLyAgKiBwYXRoIHRvIGEgVVRGLTggZmlsZSBvbiBkaXNrLlxyXG5cdC8vICAqXHJcblx0Ly8gICogUmVhZHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUgZmlsZSBpbnRvIHRoZSByZXN1bHQgYmVmb3JlIHJldHVybmluZy5cclxuXHQvLyAgKi9cclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbUZpbGVOYW1lKGZpbGVOYW1lOiBzdHJpbmcpOiBDaGFyU3RyZWFtO1xyXG5cclxuXHQvLyAvKipcclxuXHQvLyAgKiBDcmVhdGVzIGEge0BsaW5rIENoYXJTdHJlYW19IGdpdmVuIGEgc3RyaW5nIGNvbnRhaW5pbmcgYVxyXG5cdC8vICAqIHBhdGggdG8gYSBmaWxlIG9uIGRpc2sgYW5kIHRoZSBjaGFyc2V0IG9mIHRoZSBieXRlc1xyXG5cdC8vICAqIGNvbnRhaW5lZCBpbiB0aGUgZmlsZS5cclxuXHQvLyAgKlxyXG5cdC8vICAqIFJlYWRzIHRoZSBlbnRpcmUgY29udGVudHMgb2YgdGhlIGZpbGUgaW50byB0aGUgcmVzdWx0IGJlZm9yZSByZXR1cm5pbmcuXHJcblx0Ly8gICovXHJcblx0Ly8gZXhwb3J0IGZ1bmN0aW9uIGZyb21GaWxlTmFtZShmaWxlTmFtZTogc3RyaW5nLCBjaGFyc2V0OiBDaGFyc2V0KTogQ2hhclN0cmVhbTtcclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbUZpbGVOYW1lKGZpbGVOYW1lOiBzdHJpbmcsIGNoYXJzZXQ/OiBDaGFyc2V0KTogQ2hhclN0cmVhbSB7XHJcblx0Ly8gXHRpZiAoY2hhcnNldCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0Ly8gXHRcdGNoYXJzZXQgPSBDaGFyc2V0LmZvck5hbWUoXCJVVEYtOFwiKTtcclxuXHQvLyBcdH1cclxuXHJcblx0Ly8gXHRyZXR1cm4gZnJvbUZpbGUobmV3IEZpbGUoZmlsZU5hbWUpLCBjaGFyc2V0KTtcclxuXHQvLyB9XHJcblxyXG5cdC8vIC8qKlxyXG5cdC8vICAqIENyZWF0ZXMgYSB7QGxpbmsgQ2hhclN0cmVhbX0gZ2l2ZW4gYW4gb3BlbmVkIHtAbGluayBJbnB1dFN0cmVhbX1cclxuXHQvLyAgKiBjb250YWluaW5nIFVURi04IGJ5dGVzLlxyXG5cdC8vICAqXHJcblx0Ly8gICogUmVhZHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUge0Bjb2RlIElucHV0U3RyZWFtfSBpbnRvXHJcblx0Ly8gICogdGhlIHJlc3VsdCBiZWZvcmUgcmV0dXJuaW5nLCB0aGVuIGNsb3NlcyB0aGUge0Bjb2RlIElucHV0U3RyZWFtfS5cclxuXHQvLyAgKi9cclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbVN0cmVhbShpczogSW5wdXRTdHJlYW0pOiBDaGFyU3RyZWFtO1xyXG5cclxuXHQvLyAvKipcclxuXHQvLyAgKiBDcmVhdGVzIGEge0BsaW5rIENoYXJTdHJlYW19IGdpdmVuIGFuIG9wZW5lZCB7QGxpbmsgSW5wdXRTdHJlYW19IGFuZCB0aGVcclxuXHQvLyAgKiBjaGFyc2V0IG9mIHRoZSBieXRlcyBjb250YWluZWQgaW4gdGhlIHN0cmVhbS5cclxuXHQvLyAgKlxyXG5cdC8vICAqIFJlYWRzIHRoZSBlbnRpcmUgY29udGVudHMgb2YgdGhlIHtAY29kZSBJbnB1dFN0cmVhbX0gaW50b1xyXG5cdC8vICAqIHRoZSByZXN1bHQgYmVmb3JlIHJldHVybmluZywgdGhlbiBjbG9zZXMgdGhlIHtAY29kZSBJbnB1dFN0cmVhbX0uXHJcblx0Ly8gICovXHJcblx0Ly8gZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJlYW0oaXM6IElucHV0U3RyZWFtLCBjaGFyc2V0OiBDaGFyc2V0KTogQ2hhclN0cmVhbTtcclxuXHJcblx0Ly8gZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJlYW0oaXM6IElucHV0U3RyZWFtLCBjaGFyc2V0OiBDaGFyc2V0LCBzb3VyY2VOYW1lOiBzdHJpbmcsIGlucHV0U2l6ZTogbnVtYmVyKTogQ2hhclN0cmVhbTtcclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbVN0cmVhbShpczogSW5wdXRTdHJlYW0sIGNoYXJzZXQ/OiBDaGFyc2V0LCBzb3VyY2VOYW1lPzogc3RyaW5nLCBpbnB1dFNpemU/OiBudW1iZXIpOiBDaGFyU3RyZWFtIHtcclxuXHQvLyBcdGlmIChjaGFyc2V0ID09PSB1bmRlZmluZWQpIHtcclxuXHQvLyBcdFx0Y2hhcnNldCA9IENoYXJzZXQuZm9yTmFtZShcIlVURi04XCIpO1xyXG5cdC8vIFx0fVxyXG5cclxuXHQvLyBcdGlmIChzb3VyY2VOYW1lID09PSB1bmRlZmluZWQpIHtcclxuXHQvLyBcdFx0c291cmNlTmFtZSA9IEludFN0cmVhbS5VTktOT1dOX1NPVVJDRV9OQU1FO1xyXG5cdC8vIFx0fVxyXG5cclxuXHQvLyBcdGlmIChpbnB1dFNpemUgPT09IHVuZGVmaW5lZCkge1xyXG5cdC8vIFx0XHRpbnB1dFNpemUgPSAtMTtcclxuXHQvLyBcdH1cclxuXHJcblx0Ly8gXHRyZXR1cm4gZnJvbUNoYW5uZWwoXHJcblx0Ly8gXHRcdENoYW5uZWxzLm5ld0NoYW5uZWwoaXMpLFxyXG5cdC8vIFx0XHRjaGFyc2V0LFxyXG5cdC8vIFx0XHRERUZBVUxUX0JVRkZFUl9TSVpFLFxyXG5cdC8vIFx0XHRDb2RpbmdFcnJvckFjdGlvbi5SRVBMQUNFLFxyXG5cdC8vIFx0XHRzb3VyY2VOYW1lLFxyXG5cdC8vIFx0XHRpbnB1dFNpemUpO1xyXG5cdC8vIH1cclxuXHJcblx0Ly8gLyoqXHJcblx0Ly8gICogQ3JlYXRlcyBhIHtAbGluayBDaGFyU3RyZWFtfSBnaXZlbiBhbiBvcGVuZWQge0BsaW5rIFJlYWRhYmxlQnl0ZUNoYW5uZWx9XHJcblx0Ly8gICogY29udGFpbmluZyBVVEYtOCBieXRlcy5cclxuXHQvLyAgKlxyXG5cdC8vICAqIFJlYWRzIHRoZSBlbnRpcmUgY29udGVudHMgb2YgdGhlIHtAY29kZSBjaGFubmVsfSBpbnRvXHJcblx0Ly8gICogdGhlIHJlc3VsdCBiZWZvcmUgcmV0dXJuaW5nLCB0aGVuIGNsb3NlcyB0aGUge0Bjb2RlIGNoYW5uZWx9LlxyXG5cdC8vICAqL1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tQ2hhbm5lbChjaGFubmVsOiBSZWFkYWJsZUJ5dGVDaGFubmVsKTogQ2hhclN0cmVhbTtcclxuXHJcblx0Ly8gLyoqXHJcblx0Ly8gICogQ3JlYXRlcyBhIHtAbGluayBDaGFyU3RyZWFtfSBnaXZlbiBhbiBvcGVuZWQge0BsaW5rIFJlYWRhYmxlQnl0ZUNoYW5uZWx9IGFuZCB0aGVcclxuXHQvLyAgKiBjaGFyc2V0IG9mIHRoZSBieXRlcyBjb250YWluZWQgaW4gdGhlIGNoYW5uZWwuXHJcblx0Ly8gICpcclxuXHQvLyAgKiBSZWFkcyB0aGUgZW50aXJlIGNvbnRlbnRzIG9mIHRoZSB7QGNvZGUgY2hhbm5lbH0gaW50b1xyXG5cdC8vICAqIHRoZSByZXN1bHQgYmVmb3JlIHJldHVybmluZywgdGhlbiBjbG9zZXMgdGhlIHtAY29kZSBjaGFubmVsfS5cclxuXHQvLyAgKi9cclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbUNoYW5uZWwoY2hhbm5lbDogUmVhZGFibGVCeXRlQ2hhbm5lbCwgY2hhcnNldDogQ2hhcnNldCk6IENoYXJTdHJlYW07XHJcblxyXG5cdC8vIC8qKlxyXG5cdC8vICAqIENyZWF0ZXMgYSB7QGxpbmsgQ2hhclN0cmVhbX0gZ2l2ZW4gYW4gb3BlbmVkIHtAbGluayBSZWFkYWJsZUJ5dGVDaGFubmVsfVxyXG5cdC8vICAqIGNvbnRhaW5pbmcgVVRGLTggYnl0ZXMuXHJcblx0Ly8gICpcclxuXHQvLyAgKiBSZWFkcyB0aGUgZW50aXJlIGNvbnRlbnRzIG9mIHRoZSB7QGNvZGUgY2hhbm5lbH0gaW50b1xyXG5cdC8vICAqIHRoZSByZXN1bHQgYmVmb3JlIHJldHVybmluZywgdGhlbiBjbG9zZXMgdGhlIHtAY29kZSBjaGFubmVsfS5cclxuXHQvLyAgKi9cclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbUNoYW5uZWwoXHJcblx0Ly8gXHRjaGFubmVsOiBSZWFkYWJsZUJ5dGVDaGFubmVsLFxyXG5cdC8vIFx0Y2hhcnNldDogQ2hhcnNldCxcclxuXHQvLyBcdGJ1ZmZlclNpemU6IG51bWJlcixcclxuXHQvLyBcdGRlY29kaW5nRXJyb3JBY3Rpb246IENvZGluZ0Vycm9yQWN0aW9uLFxyXG5cdC8vIFx0c291cmNlTmFtZTogc3RyaW5nKTogQ29kZVBvaW50Q2hhclN0cmVhbTtcclxuXHJcblx0Ly8gZXhwb3J0IGZ1bmN0aW9uIGZyb21DaGFubmVsKFxyXG5cdC8vIFx0Y2hhbm5lbDogUmVhZGFibGVCeXRlQ2hhbm5lbCxcclxuXHQvLyBcdGNoYXJzZXQ6IENoYXJzZXQsXHJcblx0Ly8gXHRidWZmZXJTaXplOiBudW1iZXIsXHJcblx0Ly8gXHRkZWNvZGluZ0Vycm9yQWN0aW9uOiBDb2RpbmdFcnJvckFjdGlvbixcclxuXHQvLyBcdHNvdXJjZU5hbWU6IHN0cmluZyxcclxuXHQvLyBcdGlucHV0U2l6ZTogbnVtYmVyKTogQ29kZVBvaW50Q2hhclN0cmVhbTtcclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbUNoYW5uZWwoXHJcblx0Ly8gXHRjaGFubmVsOiBSZWFkYWJsZUJ5dGVDaGFubmVsLFxyXG5cdC8vIFx0Y2hhcnNldD86IENoYXJzZXQsXHJcblx0Ly8gXHRidWZmZXJTaXplPzogbnVtYmVyLFxyXG5cdC8vIFx0ZGVjb2RpbmdFcnJvckFjdGlvbj86IENvZGluZ0Vycm9yQWN0aW9uLFxyXG5cdC8vIFx0c291cmNlTmFtZT86IHN0cmluZyxcclxuXHQvLyBcdGlucHV0U2l6ZT86IG51bWJlcik6IENvZGVQb2ludENoYXJTdHJlYW1cclxuXHQvLyB7XHJcblx0Ly8gXHRpZiAoY2hhcnNldCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0Ly8gXHRcdGNoYXJzZXQgPSBDaGFyc2V0LmZvck5hbWUoXCJVVEYtOFwiKTtcclxuXHQvLyBcdH1cclxuXHJcblx0Ly8gXHRpZiAoYnVmZmVyU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0Ly8gXHRcdGJ1ZmZlclNpemUgPSBERUZBVUxUX0JVRkZFUl9TSVpFO1xyXG5cdC8vIFx0fVxyXG5cclxuXHQvLyBcdGlmIChkZWNvZGluZ0Vycm9yQWN0aW9uID09PSB1bmRlZmluZWQpIHtcclxuXHQvLyBcdFx0ZGVjb2RpbmdFcnJvckFjdGlvbiA9IENvZGluZ0Vycm9yQWN0aW9uLlJFUExBQ0U7XHJcblx0Ly8gXHR9XHJcblxyXG5cdC8vIFx0aWYgKHNvdXJjZU5hbWUgPT09IHVuZGVmaW5lZCB8fCBzb3VyY2VOYW1lLmxlbmd0aCA9PT0gMCkge1xyXG5cdC8vIFx0XHRzb3VyY2VOYW1lID0gSW50U3RyZWFtLlVOS05PV05fU09VUkNFX05BTUU7XHJcblx0Ly8gXHR9XHJcblxyXG5cdC8vIFx0aWYgKGlucHV0U2l6ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0Ly8gXHRcdGlucHV0U2l6ZSA9IC0xO1xyXG5cdC8vIFx0fVxyXG5cclxuXHQvLyBcdGxldCBjb2RlUG9pbnRCdWZmZXI6IENvZGVQb2ludEJ1ZmZlciA9IGJ1ZmZlckZyb21DaGFubmVsKGNoYW5uZWwsIGNoYXJzZXQsIGJ1ZmZlclNpemUsIGRlY29kaW5nRXJyb3JBY3Rpb24sIGlucHV0U2l6ZSk7XHJcblx0Ly8gXHRyZXR1cm4gQ29kZVBvaW50Q2hhclN0cmVhbS5mcm9tQnVmZmVyKGNvZGVQb2ludEJ1ZmZlciwgc291cmNlTmFtZSk7XHJcblx0Ly8gfVxyXG5cclxuXHQvLyAvKipcclxuXHQvLyAgKiBDcmVhdGVzIGEge0BsaW5rIENoYXJTdHJlYW19IGdpdmVuIGEge0BsaW5rIFJlYWRlcn0uIENsb3Nlc1xyXG5cdC8vICAqIHRoZSByZWFkZXIgYmVmb3JlIHJldHVybmluZy5cclxuXHQvLyAgKi9cclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbVJlYWRlcihyOiBSZWFkZXIpOiBDb2RlUG9pbnRDaGFyU3RyZWFtO1xyXG5cclxuXHQvLyAvKipcclxuXHQvLyAgKiBDcmVhdGVzIGEge0BsaW5rIENoYXJTdHJlYW19IGdpdmVuIGEge0BsaW5rIFJlYWRlcn0gYW5kIGl0c1xyXG5cdC8vICAqIHNvdXJjZSBuYW1lLiBDbG9zZXMgdGhlIHJlYWRlciBiZWZvcmUgcmV0dXJuaW5nLlxyXG5cdC8vICAqL1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tUmVhZGVyKHI6IFJlYWRlciwgc291cmNlTmFtZTogc3RyaW5nKTogQ29kZVBvaW50Q2hhclN0cmVhbTtcclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbVJlYWRlcihyOiBSZWFkZXIsIHNvdXJjZU5hbWU/OiBzdHJpbmcpOiBDb2RlUG9pbnRDaGFyU3RyZWFtIHtcclxuXHQvLyBcdGlmIChzb3VyY2VOYW1lID09PSB1bmRlZmluZWQpIHtcclxuXHQvLyBcdFx0c291cmNlTmFtZSA9IEludFN0cmVhbS5VTktOT1dOX1NPVVJDRV9OQU1FO1xyXG5cdC8vIFx0fVxyXG5cclxuXHQvLyBcdHRyeSB7XHJcblx0Ly8gXHRcdGxldCBjb2RlUG9pbnRCdWZmZXJCdWlsZGVyOiBDb2RlUG9pbnRCdWZmZXIuQnVpbGRlciA9IENvZGVQb2ludEJ1ZmZlci5idWlsZGVyKERFRkFVTFRfQlVGRkVSX1NJWkUpO1xyXG5cdC8vIFx0XHRsZXQgY2hhckJ1ZmZlcjogQ2hhckJ1ZmZlciA9IENoYXJCdWZmZXIuYWxsb2NhdGUoREVGQVVMVF9CVUZGRVJfU0laRSk7XHJcblx0Ly8gXHRcdHdoaWxlICgoci5yZWFkKGNoYXJCdWZmZXIpKSAhPT0gLTEpIHtcclxuXHQvLyBcdFx0XHRjaGFyQnVmZmVyLmZsaXAoKTtcclxuXHQvLyBcdFx0XHRjb2RlUG9pbnRCdWZmZXJCdWlsZGVyLmFwcGVuZChjaGFyQnVmZmVyKTtcclxuXHQvLyBcdFx0XHRjaGFyQnVmZmVyLmNvbXBhY3QoKTtcclxuXHQvLyBcdFx0fVxyXG5cclxuXHQvLyBcdFx0cmV0dXJuIENvZGVQb2ludENoYXJTdHJlYW0uZnJvbUJ1ZmZlcihjb2RlUG9pbnRCdWZmZXJCdWlsZGVyLmJ1aWxkKCksIHNvdXJjZU5hbWUpO1xyXG5cdC8vIFx0fSBmaW5hbGx5IHtcclxuXHQvLyBcdFx0ci5jbG9zZSgpO1xyXG5cdC8vIFx0fVxyXG5cdC8vIH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIHtAbGluayBDaGFyU3RyZWFtfSBnaXZlbiBhIHtAbGluayBTdHJpbmd9LlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHM6IHN0cmluZyk6IENvZGVQb2ludENoYXJTdHJlYW07XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSB7QGxpbmsgQ2hhclN0cmVhbX0gZ2l2ZW4gYSB7QGxpbmsgU3RyaW5nfSBhbmQgdGhlIHtAY29kZSBzb3VyY2VOYW1lfVxyXG5cdCAqIGZyb20gd2hpY2ggaXQgY2FtZS5cclxuXHQgKi9cclxuXHRleHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyhzOiBzdHJpbmcsIHNvdXJjZU5hbWU6IHN0cmluZyk6IENvZGVQb2ludENoYXJTdHJlYW07XHJcblx0ZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcoczogc3RyaW5nLCBzb3VyY2VOYW1lPzogc3RyaW5nKTogQ29kZVBvaW50Q2hhclN0cmVhbSB7XHJcblx0XHRpZiAoc291cmNlTmFtZSA9PT0gdW5kZWZpbmVkIHx8IHNvdXJjZU5hbWUubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHNvdXJjZU5hbWUgPSBJbnRTdHJlYW0uVU5LTk9XTl9TT1VSQ0VfTkFNRTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbml0aWFsIGd1ZXNzIGFzc3VtZXMgbm8gY29kZSBwb2ludHMgPiBVK0ZGRkY6IG9uZSBjb2RlXHJcblx0XHQvLyBwb2ludCBmb3IgZWFjaCBjb2RlIHVuaXQgaW4gdGhlIHN0cmluZ1xyXG5cdFx0bGV0IGNvZGVQb2ludEJ1ZmZlckJ1aWxkZXI6IENvZGVQb2ludEJ1ZmZlci5CdWlsZGVyID0gQ29kZVBvaW50QnVmZmVyLmJ1aWxkZXIocy5sZW5ndGgpO1xyXG5cclxuXHRcdC8vIFRPRE86IENoYXJCdWZmZXIud3JhcChTdHJpbmcpIHJpZ2h0ZnVsbHkgcmV0dXJucyBhIHJlYWQtb25seSBidWZmZXJcclxuXHRcdC8vIHdoaWNoIGRvZXNuJ3QgZXhwb3NlIGl0cyBhcnJheSwgc28gd2UgbWFrZSBhIGNvcHkuXHJcblx0XHRsZXQgY2I6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHMubGVuZ3RoKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjYltpXSA9IHMuY2hhckNvZGVBdChpKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb2RlUG9pbnRCdWZmZXJCdWlsZGVyLmFwcGVuZChjYik7XHJcblx0XHRyZXR1cm4gQ29kZVBvaW50Q2hhclN0cmVhbS5mcm9tQnVmZmVyKGNvZGVQb2ludEJ1ZmZlckJ1aWxkZXIuYnVpbGQoKSwgc291cmNlTmFtZSk7XHJcblx0fVxyXG5cclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gYnVmZmVyRnJvbUNoYW5uZWwoXHJcblx0Ly8gXHRjaGFubmVsOiBSZWFkYWJsZUJ5dGVDaGFubmVsLFxyXG5cdC8vIFx0Y2hhcnNldDogQ2hhcnNldCxcclxuXHQvLyBcdGJ1ZmZlclNpemU6IG51bWJlcixcclxuXHQvLyBcdGRlY29kaW5nRXJyb3JBY3Rpb246IENvZGluZ0Vycm9yQWN0aW9uLFxyXG5cdC8vIFx0aW5wdXRTaXplOiBudW1iZXIpOiBDb2RlUG9pbnRCdWZmZXIge1xyXG5cdC8vIFx0dHJ5IHtcclxuXHQvLyBcdFx0bGV0IHV0ZjhCeXRlc0luOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyU2l6ZSk7XHJcblx0Ly8gXHRcdGxldCB1dGYxNkNvZGVVbml0c091dDogVWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyU2l6ZSk7XHJcblx0Ly8gXHRcdGlmIChpbnB1dFNpemUgPT09IC0xKSB7XHJcblx0Ly8gXHRcdFx0aW5wdXRTaXplID0gYnVmZmVyU2l6ZTtcclxuXHQvLyBcdFx0fSBlbHNlIGlmIChpbnB1dFNpemUgPiBJbnRlZ2VyLk1BWF9WQUxVRSkge1xyXG5cdC8vIFx0XHRcdC8vIEJ5dGVCdWZmZXIgZXQgYWwgZG9uJ3Qgc3VwcG9ydCBsb25nIHNpemVzXHJcblx0Ly8gXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoYGlucHV0U2l6ZSAke2lucHV0U2l6ZX0gbGFyZ2VyIHRoYW4gbWF4ICR7SW50ZWdlci5NQVhfVkFMVUV9YCk7XHJcblx0Ly8gXHRcdH1cclxuXHJcblx0Ly8gXHRcdGxldCBjb2RlUG9pbnRCdWZmZXJCdWlsZGVyOiBDb2RlUG9pbnRCdWZmZXIuQnVpbGRlciA9IENvZGVQb2ludEJ1ZmZlci5idWlsZGVyKGlucHV0U2l6ZSk7XHJcblx0Ly8gXHRcdGxldCBkZWNvZGVyOiBDaGFyc2V0RGVjb2RlciA9IGNoYXJzZXRcclxuXHQvLyBcdFx0XHRcdC5uZXdEZWNvZGVyKClcclxuXHQvLyBcdFx0XHRcdC5vbk1hbGZvcm1lZElucHV0KGRlY29kaW5nRXJyb3JBY3Rpb24pXHJcblx0Ly8gXHRcdFx0XHQub25Vbm1hcHBhYmxlQ2hhcmFjdGVyKGRlY29kaW5nRXJyb3JBY3Rpb24pO1xyXG5cclxuXHQvLyBcdFx0bGV0IGVuZE9mSW5wdXQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHQvLyBcdFx0d2hpbGUgKCFlbmRPZklucHV0KSB7XHJcblx0Ly8gXHRcdFx0bGV0IGJ5dGVzUmVhZDogbnVtYmVyID0gY2hhbm5lbC5yZWFkKHV0ZjhCeXRlc0luKTtcclxuXHQvLyBcdFx0XHRlbmRPZklucHV0ID0gKGJ5dGVzUmVhZCA9PT0gLTEpO1xyXG5cdC8vIFx0XHRcdHV0ZjhCeXRlc0luLmZsaXAoKTtcclxuXHQvLyBcdFx0XHRsZXQgcmVzdWx0OiBDb2RlclJlc3VsdCA9IGRlY29kZXIuZGVjb2RlKFxyXG5cdC8vIFx0XHRcdFx0dXRmOEJ5dGVzSW4sXHJcblx0Ly8gXHRcdFx0XHR1dGYxNkNvZGVVbml0c091dCxcclxuXHQvLyBcdFx0XHRcdGVuZE9mSW5wdXQpO1xyXG5cdC8vIFx0XHRcdGlmIChyZXN1bHQuaXNFcnJvcigpICYmIGRlY29kaW5nRXJyb3JBY3Rpb24gPT09IENvZGluZ0Vycm9yQWN0aW9uLlJFUE9SVCkge1xyXG5cdC8vIFx0XHRcdFx0cmVzdWx0LnRocm93RXhjZXB0aW9uKCk7XHJcblx0Ly8gXHRcdFx0fVxyXG5cclxuXHQvLyBcdFx0XHR1dGYxNkNvZGVVbml0c091dC5mbGlwKCk7XHJcblx0Ly8gXHRcdFx0Y29kZVBvaW50QnVmZmVyQnVpbGRlci5hcHBlbmQodXRmMTZDb2RlVW5pdHNPdXQpO1xyXG5cdC8vIFx0XHRcdHV0ZjhCeXRlc0luLmNvbXBhY3QoKTtcclxuXHQvLyBcdFx0XHR1dGYxNkNvZGVVbml0c091dC5jb21wYWN0KCk7XHJcblx0Ly8gXHRcdH1cclxuXHQvLyBcdFx0Ly8gSGFuZGxlIGFueSBieXRlcyBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlIHdoaWNoIG5lZWQgdG9cclxuXHQvLyBcdFx0Ly8gYmUgcmVwcmVzZW50ZWQgYXMgZXJyb3JzIG9yIHN1YnN0aXR1dGlvbiBjaGFyYWN0ZXJzLlxyXG5cdC8vIFx0XHRsZXQgZmx1c2hSZXN1bHQ6IENvZGVyUmVzdWx0ID0gZGVjb2Rlci5mbHVzaCh1dGYxNkNvZGVVbml0c091dCk7XHJcblx0Ly8gXHRcdGlmIChmbHVzaFJlc3VsdC5pc0Vycm9yKCkgJiYgZGVjb2RpbmdFcnJvckFjdGlvbiA9PT0gQ29kaW5nRXJyb3JBY3Rpb24uUkVQT1JUKSB7XHJcblx0Ly8gXHRcdFx0Zmx1c2hSZXN1bHQudGhyb3dFeGNlcHRpb24oKTtcclxuXHQvLyBcdFx0fVxyXG5cclxuXHQvLyBcdFx0dXRmMTZDb2RlVW5pdHNPdXQuZmxpcCgpO1xyXG5cdC8vIFx0XHRjb2RlUG9pbnRCdWZmZXJCdWlsZGVyLmFwcGVuZCh1dGYxNkNvZGVVbml0c091dCk7XHJcblxyXG5cdC8vIFx0XHRyZXR1cm4gY29kZVBvaW50QnVmZmVyQnVpbGRlci5idWlsZCgpO1xyXG5cdC8vIFx0fVxyXG5cdC8vIFx0ZmluYWxseSB7XHJcblx0Ly8gXHRcdGNoYW5uZWwuY2xvc2UoKTtcclxuXHQvLyBcdH1cclxuXHQvLyB9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ5LjYwNzQzNjUtMDc6MDBcclxuXHJcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XHJcbmltcG9ydCB7IENvbW1vblRva2VuIH0gZnJvbSBcIi4vQ29tbW9uVG9rZW5cIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4vTGV4ZXJcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBUb2tlblNvdXJjZSB9IGZyb20gXCIuL1Rva2VuU291cmNlXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4vVG9rZW5TdHJlYW1cIjtcclxuaW1wb3J0IHsgV3JpdGFibGVUb2tlbiB9IGZyb20gXCIuL1dyaXRhYmxlVG9rZW5cIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBUb2tlblN0cmVhbX0gbG9hZHMgdG9rZW5zIGZyb20gYVxyXG4gKiB7QGxpbmsgVG9rZW5Tb3VyY2V9IG9uLWRlbWFuZCwgYW5kIHBsYWNlcyB0aGUgdG9rZW5zIGluIGEgYnVmZmVyIHRvIHByb3ZpZGVcclxuICogYWNjZXNzIHRvIGFueSBwcmV2aW91cyB0b2tlbiBieSBpbmRleC5cclxuICpcclxuICogVGhpcyB0b2tlbiBzdHJlYW0gaWdub3JlcyB0aGUgdmFsdWUgb2Yge0BsaW5rIFRva2VuI2dldENoYW5uZWx9LiBJZiB5b3VyXHJcbiAqIHBhcnNlciByZXF1aXJlcyB0aGUgdG9rZW4gc3RyZWFtIGZpbHRlciB0b2tlbnMgdG8gb25seSB0aG9zZSBvbiBhIHBhcnRpY3VsYXJcclxuICogY2hhbm5lbCwgc3VjaCBhcyB7QGxpbmsgVG9rZW4jREVGQVVMVF9DSEFOTkVMfSBvclxyXG4gKiB7QGxpbmsgVG9rZW4jSElEREVOX0NIQU5ORUx9LCB1c2UgYSBmaWx0ZXJpbmcgdG9rZW4gc3RyZWFtIHN1Y2ggYVxyXG4gKiB7QGxpbmsgQ29tbW9uVG9rZW5TdHJlYW19LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJ1ZmZlcmVkVG9rZW5TdHJlYW0gaW1wbGVtZW50cyBUb2tlblN0cmVhbSB7XHJcblx0LyoqXHJcblx0ICogVGhlIHtAbGluayBUb2tlblNvdXJjZX0gZnJvbSB3aGljaCB0b2tlbnMgZm9yIHRoaXMgc3RyZWFtIGFyZSBmZXRjaGVkLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSBfdG9rZW5Tb3VyY2U6IFRva2VuU291cmNlO1xyXG5cclxuXHQvKipcclxuXHQgKiBBIGNvbGxlY3Rpb24gb2YgYWxsIHRva2VucyBmZXRjaGVkIGZyb20gdGhlIHRva2VuIHNvdXJjZS4gVGhlIGxpc3QgaXNcclxuXHQgKiBjb25zaWRlcmVkIGEgY29tcGxldGUgdmlldyBvZiB0aGUgaW5wdXQgb25jZSB7QGxpbmsgI2ZldGNoZWRFT0Z9IGlzIHNldFxyXG5cdCAqIHRvIGB0cnVlYC5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgdG9rZW5zOiBUb2tlbltdID0gW107XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBpbmRleCBpbnRvIHtAbGluayAjdG9rZW5zfSBvZiB0aGUgY3VycmVudCB0b2tlbiAobmV4dCB0b2tlbiB0b1xyXG5cdCAqIHtAbGluayAjY29uc3VtZX0pLiB7QGxpbmsgI3Rva2Vuc31gW2B7QGxpbmsgI3B9YF1gIHNob3VsZCBiZVxyXG5cdCAqIHtAbGluayAjTFQgTFQoMSl9LlxyXG5cdCAqXHJcblx0ICogVGhpcyBmaWVsZCBpcyBzZXQgdG8gLTEgd2hlbiB0aGUgc3RyZWFtIGlzIGZpcnN0IGNvbnN0cnVjdGVkIG9yIHdoZW5cclxuXHQgKiB7QGxpbmsgI3NldFRva2VuU291cmNlfSBpcyBjYWxsZWQsIGluZGljYXRpbmcgdGhhdCB0aGUgZmlyc3QgdG9rZW4gaGFzXHJcblx0ICogbm90IHlldCBiZWVuIGZldGNoZWQgZnJvbSB0aGUgdG9rZW4gc291cmNlLiBGb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbixcclxuXHQgKiBzZWUgdGhlIGRvY3VtZW50YXRpb24gb2Yge0BsaW5rIEludFN0cmVhbX0gZm9yIGEgZGVzY3JpcHRpb24gb2ZcclxuXHQgKiBJbml0aWFsaXppbmcgTWV0aG9kcy5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcDogbnVtYmVyID0gLTE7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB7QGxpbmsgVG9rZW4jRU9GfSB0b2tlbiBoYXMgYmVlbiBmZXRjaGVkIGZyb21cclxuXHQgKiB7QGxpbmsgI3Rva2VuU291cmNlfSBhbmQgYWRkZWQgdG8ge0BsaW5rICN0b2tlbnN9LiBUaGlzIGZpZWxkIGltcHJvdmVzXHJcblx0ICogcGVyZm9ybWFuY2UgZm9yIHRoZSBmb2xsb3dpbmcgY2FzZXM6XHJcblx0ICpcclxuXHQgKiAqIHtAbGluayAjY29uc3VtZX06IFRoZSBsb29rYWhlYWQgY2hlY2sgaW4ge0BsaW5rICNjb25zdW1lfSB0byBwcmV2ZW50XHJcblx0ICogICBjb25zdW1pbmcgdGhlIEVPRiBzeW1ib2wgaXMgb3B0aW1pemVkIGJ5IGNoZWNraW5nIHRoZSB2YWx1ZXMgb2ZcclxuXHQgKiAgIHtAbGluayAjZmV0Y2hlZEVPRn0gYW5kIHtAbGluayAjcH0gaW5zdGVhZCBvZiBjYWxsaW5nIHtAbGluayAjTEF9LlxyXG5cdCAqICoge0BsaW5rICNmZXRjaH06IFRoZSBjaGVjayB0byBwcmV2ZW50IGFkZGluZyBtdWx0aXBsZSBFT0Ygc3ltYm9scyBpbnRvXHJcblx0ICogICB7QGxpbmsgI3Rva2Vuc30gaXMgdHJpdmlhbCB3aXRoIHRoaXMgZmllbGQuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGZldGNoZWRFT0Y6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgdG9rZW5Tb3VyY2U6IFRva2VuU291cmNlKSB7XHJcblx0XHRpZiAodG9rZW5Tb3VyY2UgPT0gbnVsbCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0b2tlblNvdXJjZSBjYW5ub3QgYmUgbnVsbFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl90b2tlblNvdXJjZSA9IHRva2VuU291cmNlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHRva2VuU291cmNlKCk6IFRva2VuU291cmNlIHtcclxuXHRcdHJldHVybiB0aGlzLl90b2tlblNvdXJjZTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZXNldCB0aGlzIHRva2VuIHN0cmVhbSBieSBzZXR0aW5nIGl0cyB0b2tlbiBzb3VyY2UuICovXHJcblx0c2V0IHRva2VuU291cmNlKHRva2VuU291cmNlOiBUb2tlblNvdXJjZSkge1xyXG5cdFx0dGhpcy5fdG9rZW5Tb3VyY2UgPSB0b2tlblNvdXJjZTtcclxuXHRcdHRoaXMudG9rZW5zLmxlbmd0aCA9IDA7XHJcblx0XHR0aGlzLnAgPSAtMTtcclxuXHRcdHRoaXMuZmV0Y2hlZEVPRiA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5wO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG1hcmsoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiAwO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlbGVhc2UobWFya2VyOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdC8vIG5vIHJlc291cmNlcyB0byByZWxlYXNlXHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgc2VlayhpbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLmxhenlJbml0KCk7XHJcblx0XHR0aGlzLnAgPSB0aGlzLmFkanVzdFNlZWtJbmRleChpbmRleCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMudG9rZW5zLmxlbmd0aDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjb25zdW1lKCk6IHZvaWQge1xyXG5cdFx0bGV0IHNraXBFb2ZDaGVjazogYm9vbGVhbjtcclxuXHRcdGlmICh0aGlzLnAgPj0gMCkge1xyXG5cdFx0XHRpZiAodGhpcy5mZXRjaGVkRU9GKSB7XHJcblx0XHRcdFx0Ly8gdGhlIGxhc3QgdG9rZW4gaW4gdG9rZW5zIGlzIEVPRi4gc2tpcCBjaGVjayBpZiBwIGluZGV4ZXMgYW55XHJcblx0XHRcdFx0Ly8gZmV0Y2hlZCB0b2tlbiBleGNlcHQgdGhlIGxhc3QuXHJcblx0XHRcdFx0c2tpcEVvZkNoZWNrID0gdGhpcy5wIDwgdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBubyBFT0YgdG9rZW4gaW4gdG9rZW5zLiBza2lwIGNoZWNrIGlmIHAgaW5kZXhlcyBhIGZldGNoZWQgdG9rZW4uXHJcblx0XHRcdFx0c2tpcEVvZkNoZWNrID0gdGhpcy5wIDwgdGhpcy50b2tlbnMubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBub3QgeWV0IGluaXRpYWxpemVkXHJcblx0XHRcdHNraXBFb2ZDaGVjayA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc2tpcEVvZkNoZWNrICYmIHRoaXMuTEEoMSkgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29uc3VtZSBFT0ZcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuc3luYyh0aGlzLnAgKyAxKSkge1xyXG5cdFx0XHR0aGlzLnAgPSB0aGlzLmFkanVzdFNlZWtJbmRleCh0aGlzLnAgKyAxKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBNYWtlIHN1cmUgaW5kZXggYGlgIGluIHRva2VucyBoYXMgYSB0b2tlbi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIGB0cnVlYCBpZiBhIHRva2VuIGlzIGxvY2F0ZWQgYXQgaW5kZXggYGlgLCBvdGhlcndpc2VcclxuXHQgKiAgICBgZmFsc2VgLlxyXG5cdCAqIEBzZWUgI2dldChpbnQgaSlcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgc3luYyhpOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGFzc2VydChpID49IDApO1xyXG5cdFx0bGV0IG46IG51bWJlciA9IGkgLSB0aGlzLnRva2Vucy5sZW5ndGggKyAxOyAvLyBob3cgbWFueSBtb3JlIGVsZW1lbnRzIHdlIG5lZWQ/XHJcblx0XHQvL1N5c3RlbS5vdXQucHJpbnRsbihcInN5bmMoXCIraStcIikgbmVlZHMgXCIrbik7XHJcblx0XHRpZiAobiA+IDApIHtcclxuXHRcdFx0bGV0IGZldGNoZWQ6IG51bWJlciA9IHRoaXMuZmV0Y2gobik7XHJcblx0XHRcdHJldHVybiBmZXRjaGVkID49IG47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHQvKiogQWRkIGBuYCBlbGVtZW50cyB0byBidWZmZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgYWN0dWFsIG51bWJlciBvZiBlbGVtZW50cyBhZGRlZCB0byB0aGUgYnVmZmVyLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBmZXRjaChuOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0aWYgKHRoaXMuZmV0Y2hlZEVPRikge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRsZXQgdDogVG9rZW4gPSB0aGlzLnRva2VuU291cmNlLm5leHRUb2tlbigpO1xyXG5cdFx0XHRpZiAodGhpcy5pc1dyaXRhYmxlVG9rZW4odCkpIHtcclxuXHRcdFx0XHR0LnRva2VuSW5kZXggPSB0aGlzLnRva2Vucy5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMudG9rZW5zLnB1c2godCk7XHJcblx0XHRcdGlmICh0LnR5cGUgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHRcdHRoaXMuZmV0Y2hlZEVPRiA9IHRydWU7XHJcblx0XHRcdFx0cmV0dXJuIGkgKyAxO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG47XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0KGk6IG51bWJlcik6IFRva2VuIHtcclxuXHRcdGlmIChpIDwgMCB8fCBpID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRva2VuIGluZGV4IFwiICsgaSArIFwiIG91dCBvZiByYW5nZSAwLi5cIiArICh0aGlzLnRva2Vucy5sZW5ndGggLSAxKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudG9rZW5zW2ldO1xyXG5cdH1cclxuXHJcblx0LyoqIEdldCBhbGwgdG9rZW5zIGZyb20gc3RhcnQuLnN0b3AgaW5jbHVzaXZlbHkuICovXHJcblx0cHVibGljIGdldFJhbmdlKHN0YXJ0OiBudW1iZXIsIHN0b3A6IG51bWJlcik6IFRva2VuW10ge1xyXG5cdFx0aWYgKHN0YXJ0IDwgMCB8fCBzdG9wIDwgMCkge1xyXG5cdFx0XHRyZXR1cm4gW107XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5sYXp5SW5pdCgpO1xyXG5cdFx0bGV0IHN1YnNldDogVG9rZW5bXSA9IG5ldyBBcnJheTxUb2tlbj4oKTtcclxuXHRcdGlmIChzdG9wID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHRzdG9wID0gdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gc3RvcDsgaSsrKSB7XHJcblx0XHRcdGxldCB0OiBUb2tlbiA9IHRoaXMudG9rZW5zW2ldO1xyXG5cdFx0XHRpZiAodC50eXBlID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3Vic2V0LnB1c2godCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN1YnNldDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBMQShpOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0bGV0IHRva2VuID0gdGhpcy5MVChpKTtcclxuXHRcdGlmICghdG9rZW4pIHtcclxuXHRcdFx0cmV0dXJuIFRva2VuLklOVkFMSURfVFlQRTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdG9rZW4udHlwZTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCB0cnlMQihrOiBudW1iZXIpOiBUb2tlbiB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAoKHRoaXMucCAtIGspIDwgMCkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnAgLSBrXTtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIExUKGs6IG51bWJlcik6IFRva2VuIHtcclxuXHRcdGxldCByZXN1bHQgPSB0aGlzLnRyeUxUKGspO1xyXG5cdFx0aWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwicmVxdWVzdGVkIGxvb2tiYWNrIGluZGV4IG91dCBvZiByYW5nZVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRyeUxUKGs6IG51bWJlcik6IFRva2VuIHwgdW5kZWZpbmVkIHtcclxuXHRcdHRoaXMubGF6eUluaXQoKTtcclxuXHRcdGlmIChrID09PSAwKSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiMCBpcyBub3QgYSB2YWxpZCBsb29rYWhlYWQgaW5kZXhcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGsgPCAwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRyeUxCKC1rKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgaTogbnVtYmVyID0gdGhpcy5wICsgayAtIDE7XHJcblx0XHR0aGlzLnN5bmMoaSk7XHJcblx0XHRpZiAoaSA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcclxuXHRcdFx0Ly8gcmV0dXJuIEVPRiB0b2tlblxyXG5cdFx0XHQvLyBFT0YgbXVzdCBiZSBsYXN0IHRva2VuXHJcblx0XHRcdHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1x0XHRpZiAoIGk+cmFuZ2UgKSByYW5nZSA9IGk7XHJcblx0XHRyZXR1cm4gdGhpcy50b2tlbnNbaV07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBbGxvd2VkIGRlcml2ZWQgY2xhc3NlcyB0byBtb2RpZnkgdGhlIGJlaGF2aW9yIG9mIG9wZXJhdGlvbnMgd2hpY2ggY2hhbmdlXHJcblx0ICogdGhlIGN1cnJlbnQgc3RyZWFtIHBvc2l0aW9uIGJ5IGFkanVzdGluZyB0aGUgdGFyZ2V0IHRva2VuIGluZGV4IG9mIGEgc2Vla1xyXG5cdCAqIG9wZXJhdGlvbi4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2ltcGx5IHJldHVybnMgYGlgLiBJZiBhblxyXG5cdCAqIGV4Y2VwdGlvbiBpcyB0aHJvd24gaW4gdGhpcyBtZXRob2QsIHRoZSBjdXJyZW50IHN0cmVhbSBpbmRleCBzaG91bGQgbm90IGJlXHJcblx0ICogY2hhbmdlZC5cclxuXHQgKlxyXG5cdCAqIEZvciBleGFtcGxlLCB7QGxpbmsgQ29tbW9uVG9rZW5TdHJlYW19IG92ZXJyaWRlcyB0aGlzIG1ldGhvZCB0byBlbnN1cmUgdGhhdFxyXG5cdCAqIHRoZSBzZWVrIHRhcmdldCBpcyBhbHdheXMgYW4gb24tY2hhbm5lbCB0b2tlbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBpIFRoZSB0YXJnZXQgdG9rZW4gaW5kZXguXHJcblx0ICogQHJldHVybnMgVGhlIGFkanVzdGVkIHRhcmdldCB0b2tlbiBpbmRleC5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWRqdXN0U2Vla0luZGV4KGk6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gaTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBsYXp5SW5pdCgpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLnAgPT09IC0xKSB7XHJcblx0XHRcdHRoaXMuc2V0dXAoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBzZXR1cCgpOiB2b2lkIHtcclxuXHRcdHRoaXMuc3luYygwKTtcclxuXHRcdHRoaXMucCA9IHRoaXMuYWRqdXN0U2Vla0luZGV4KDApO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldFRva2VucygpOiBUb2tlbltdO1xyXG5cclxuXHRwdWJsaWMgZ2V0VG9rZW5zKHN0YXJ0OiBudW1iZXIsIHN0b3A6IG51bWJlcik6IFRva2VuW107XHJcblxyXG5cdHB1YmxpYyBnZXRUb2tlbnMoc3RhcnQ6IG51bWJlciwgc3RvcDogbnVtYmVyLCB0eXBlczogU2V0PG51bWJlcj4pOiBUb2tlbltdO1xyXG5cclxuXHRwdWJsaWMgZ2V0VG9rZW5zKHN0YXJ0OiBudW1iZXIsIHN0b3A6IG51bWJlciwgdHR5cGU6IG51bWJlcik6IFRva2VuW107XHJcblxyXG5cdC8qKiBHaXZlbiBhIHN0YXJ0IGFuZCBzdG9wIGluZGV4LCByZXR1cm4gYSBgTGlzdGAgb2YgYWxsIHRva2VucyBpblxyXG5cdCAqICB0aGUgdG9rZW4gdHlwZSBgQml0U2V0YC4gIFJldHVybiBhbiBlbXB0eSBhcnJheSBpZiBubyB0b2tlbnMgd2VyZSBmb3VuZC4gIFRoaXNcclxuXHQgKiAgbWV0aG9kIGxvb2tzIGF0IGJvdGggb24gYW5kIG9mZiBjaGFubmVsIHRva2Vucy5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0VG9rZW5zKHN0YXJ0PzogbnVtYmVyLCBzdG9wPzogbnVtYmVyLCB0eXBlcz86IFNldDxudW1iZXI+IHwgbnVtYmVyKTogVG9rZW5bXSB7XHJcblx0XHR0aGlzLmxhenlJbml0KCk7XHJcblxyXG5cdFx0aWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0YXNzZXJ0KHN0b3AgPT09IHVuZGVmaW5lZCAmJiB0eXBlcyA9PT0gdW5kZWZpbmVkKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9rZW5zO1xyXG5cdFx0fSBlbHNlIGlmIChzdG9wID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c3RvcCA9IHRoaXMudG9rZW5zLmxlbmd0aCAtIDE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0YXJ0IDwgMCB8fCBzdG9wID49IHRoaXMudG9rZW5zLmxlbmd0aCB8fCBzdG9wIDwgMCB8fCBzdGFydCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzdGFydCBcIiArIHN0YXJ0ICsgXCIgb3Igc3RvcCBcIiArIHN0b3AgKyBcIiBub3QgaW4gMC4uXCIgKyAodGhpcy50b2tlbnMubGVuZ3RoIC0gMSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGFydCA+IHN0b3ApIHtcclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlcyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRva2Vucy5zbGljZShzdGFydCwgc3RvcCArIDEpO1xyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0dHlwZXMgPSBuZXcgU2V0PG51bWJlcj4oKS5hZGQodHlwZXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0eXBlc1NldCA9IHR5cGVzO1xyXG5cclxuXHRcdC8vIGxpc3QgPSB0b2tlbnNbc3RhcnQ6c3RvcF06e1QgdCwgdC50eXBlIGluIHR5cGVzfVxyXG5cdFx0bGV0IGZpbHRlcmVkVG9rZW5zOiBUb2tlbltdID0gdGhpcy50b2tlbnMuc2xpY2Uoc3RhcnQsIHN0b3AgKyAxKTtcclxuXHRcdGZpbHRlcmVkVG9rZW5zID0gZmlsdGVyZWRUb2tlbnMuZmlsdGVyKCh2YWx1ZSkgPT4gdHlwZXNTZXQuaGFzKHZhbHVlLnR5cGUpKTtcclxuXHJcblx0XHRyZXR1cm4gZmlsdGVyZWRUb2tlbnM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHaXZlbiBhIHN0YXJ0aW5nIGluZGV4LCByZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBuZXh0IHRva2VuIG9uIGNoYW5uZWwuXHJcblx0ICogUmV0dXJuIGBpYCBpZiBgdG9rZW5zW2ldYCBpcyBvbiBjaGFubmVsLiBSZXR1cm4gdGhlIGluZGV4IG9mXHJcblx0ICogdGhlIEVPRiB0b2tlbiBpZiB0aGVyZSBhcmUgbm8gdG9rZW5zIG9uIGNoYW5uZWwgYmV0d2VlbiBgaWAgYW5kXHJcblx0ICogRU9GLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBuZXh0VG9rZW5PbkNoYW5uZWwoaTogbnVtYmVyLCBjaGFubmVsOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0dGhpcy5zeW5jKGkpO1xyXG5cdFx0aWYgKGkgPj0gdGhpcy5zaXplKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnNpemUgLSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0b2tlbjogVG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcclxuXHRcdHdoaWxlICh0b2tlbi5jaGFubmVsICE9PSBjaGFubmVsKSB7XHJcblx0XHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0XHRyZXR1cm4gaTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aSsrO1xyXG5cdFx0XHR0aGlzLnN5bmMoaSk7XHJcblx0XHRcdHRva2VuID0gdGhpcy50b2tlbnNbaV07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHaXZlbiBhIHN0YXJ0aW5nIGluZGV4LCByZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBwcmV2aW91cyB0b2tlbiBvblxyXG5cdCAqIGNoYW5uZWwuIFJldHVybiBgaWAgaWYgYHRva2Vuc1tpXWAgaXMgb24gY2hhbm5lbC4gUmV0dXJuIC0xXHJcblx0ICogaWYgdGhlcmUgYXJlIG5vIHRva2VucyBvbiBjaGFubmVsIGJldHdlZW4gYGlgIGFuZCAwLlxyXG5cdCAqXHJcblx0ICogSWYgYGlgIHNwZWNpZmllcyBhbiBpbmRleCBhdCBvciBhZnRlciB0aGUgRU9GIHRva2VuLCB0aGUgRU9GIHRva2VuXHJcblx0ICogaW5kZXggaXMgcmV0dXJuZWQuIFRoaXMgaXMgZHVlIHRvIHRoZSBmYWN0IHRoYXQgdGhlIEVPRiB0b2tlbiBpcyB0cmVhdGVkXHJcblx0ICogYXMgdGhvdWdoIGl0IHdlcmUgb24gZXZlcnkgY2hhbm5lbC5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcHJldmlvdXNUb2tlbk9uQ2hhbm5lbChpOiBudW1iZXIsIGNoYW5uZWw6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHR0aGlzLnN5bmMoaSk7XHJcblx0XHRpZiAoaSA+PSB0aGlzLnNpemUpIHtcclxuXHRcdFx0Ly8gdGhlIEVPRiB0b2tlbiBpcyBvbiBldmVyeSBjaGFubmVsXHJcblx0XHRcdHJldHVybiB0aGlzLnNpemUgLSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdHdoaWxlIChpID49IDApIHtcclxuXHRcdFx0bGV0IHRva2VuOiBUb2tlbiA9IHRoaXMudG9rZW5zW2ldO1xyXG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GIHx8IHRva2VuLmNoYW5uZWwgPT09IGNoYW5uZWwpIHtcclxuXHRcdFx0XHRyZXR1cm4gaTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aS0tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpO1xyXG5cdH1cclxuXHJcblx0LyoqIENvbGxlY3QgYWxsIHRva2VucyBvbiBzcGVjaWZpZWQgY2hhbm5lbCB0byB0aGUgcmlnaHQgb2ZcclxuXHQgKiAgdGhlIGN1cnJlbnQgdG9rZW4gdXAgdW50aWwgd2Ugc2VlIGEgdG9rZW4gb24ge0BsaW5rIExleGVyI0RFRkFVTFRfVE9LRU5fQ0hBTk5FTH0gb3JcclxuXHQgKiAgRU9GLiBJZiBgY2hhbm5lbGAgaXMgYC0xYCwgZmluZCBhbnkgbm9uIGRlZmF1bHQgY2hhbm5lbCB0b2tlbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0SGlkZGVuVG9rZW5zVG9SaWdodCh0b2tlbkluZGV4OiBudW1iZXIsIGNoYW5uZWw6IG51bWJlciA9IC0xKTogVG9rZW5bXSB7XHJcblx0XHR0aGlzLmxhenlJbml0KCk7XHJcblx0XHRpZiAodG9rZW5JbmRleCA8IDAgfHwgdG9rZW5JbmRleCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IodG9rZW5JbmRleCArIFwiIG5vdCBpbiAwLi5cIiArICh0aGlzLnRva2Vucy5sZW5ndGggLSAxKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG5leHRPbkNoYW5uZWw6IG51bWJlciA9IHRoaXMubmV4dFRva2VuT25DaGFubmVsKHRva2VuSW5kZXggKyAxLCBMZXhlci5ERUZBVUxUX1RPS0VOX0NIQU5ORUwpO1xyXG5cdFx0bGV0IHRvOiBudW1iZXI7XHJcblx0XHRsZXQgZnJvbTogbnVtYmVyID0gdG9rZW5JbmRleCArIDE7XHJcblx0XHQvLyBpZiBub25lIG9uY2hhbm5lbCB0byByaWdodCwgbmV4dE9uQ2hhbm5lbD0tMSBzbyBzZXQgdG8gPSBsYXN0IHRva2VuXHJcblx0XHRpZiAobmV4dE9uQ2hhbm5lbCA9PT0gLTEpIHtcclxuXHRcdFx0dG8gPSB0aGlzLnNpemUgLSAxO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dG8gPSBuZXh0T25DaGFubmVsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpbHRlckZvckNoYW5uZWwoZnJvbSwgdG8sIGNoYW5uZWwpO1xyXG5cdH1cclxuXHJcblx0LyoqIENvbGxlY3QgYWxsIHRva2VucyBvbiBzcGVjaWZpZWQgY2hhbm5lbCB0byB0aGUgbGVmdCBvZlxyXG5cdCAqICB0aGUgY3VycmVudCB0b2tlbiB1cCB1bnRpbCB3ZSBzZWUgYSB0b2tlbiBvbiB7QGxpbmsgTGV4ZXIjREVGQVVMVF9UT0tFTl9DSEFOTkVMfS5cclxuXHQgKiAgSWYgYGNoYW5uZWxgIGlzIGAtMWAsIGZpbmQgYW55IG5vbiBkZWZhdWx0IGNoYW5uZWwgdG9rZW4uXHJcblx0ICovXHJcblx0cHVibGljIGdldEhpZGRlblRva2Vuc1RvTGVmdCh0b2tlbkluZGV4OiBudW1iZXIsIGNoYW5uZWw6IG51bWJlciA9IC0xKTogVG9rZW5bXSB7XHJcblx0XHR0aGlzLmxhenlJbml0KCk7XHJcblx0XHRpZiAodG9rZW5JbmRleCA8IDAgfHwgdG9rZW5JbmRleCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IodG9rZW5JbmRleCArIFwiIG5vdCBpbiAwLi5cIiArICh0aGlzLnRva2Vucy5sZW5ndGggLSAxKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRva2VuSW5kZXggPT09IDApIHtcclxuXHRcdFx0Ly8gb2J2aW91c2x5IG5vIHRva2VucyBjYW4gYXBwZWFyIGJlZm9yZSB0aGUgZmlyc3QgdG9rZW5cclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBwcmV2T25DaGFubmVsOiBudW1iZXIgPSB0aGlzLnByZXZpb3VzVG9rZW5PbkNoYW5uZWwodG9rZW5JbmRleCAtIDEsIExleGVyLkRFRkFVTFRfVE9LRU5fQ0hBTk5FTCk7XHJcblx0XHRpZiAocHJldk9uQ2hhbm5lbCA9PT0gdG9rZW5JbmRleCAtIDEpIHtcclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIG5vbmUgb25jaGFubmVsIHRvIGxlZnQsIHByZXZPbkNoYW5uZWw9LTEgdGhlbiBmcm9tPTBcclxuXHRcdGxldCBmcm9tOiBudW1iZXIgPSBwcmV2T25DaGFubmVsICsgMTtcclxuXHRcdGxldCB0bzogbnVtYmVyID0gdG9rZW5JbmRleCAtIDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyRm9yQ2hhbm5lbChmcm9tLCB0bywgY2hhbm5lbCk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZmlsdGVyRm9yQ2hhbm5lbChmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIGNoYW5uZWw6IG51bWJlcik6IFRva2VuW10ge1xyXG5cdFx0bGV0IGhpZGRlbjogVG9rZW5bXSA9IG5ldyBBcnJheTxUb2tlbj4oKTtcclxuXHRcdGZvciAobGV0IGkgPSBmcm9tOyBpIDw9IHRvOyBpKyspIHtcclxuXHRcdFx0bGV0IHQ6IFRva2VuID0gdGhpcy50b2tlbnNbaV07XHJcblx0XHRcdGlmIChjaGFubmVsID09PSAtMSkge1xyXG5cdFx0XHRcdGlmICh0LmNoYW5uZWwgIT09IExleGVyLkRFRkFVTFRfVE9LRU5fQ0hBTk5FTCkge1xyXG5cdFx0XHRcdFx0aGlkZGVuLnB1c2godCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICh0LmNoYW5uZWwgPT09IGNoYW5uZWwpIHtcclxuXHRcdFx0XHRcdGhpZGRlbi5wdXNoKHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBoaWRkZW47XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc291cmNlTmFtZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMudG9rZW5Tb3VyY2Uuc291cmNlTmFtZTtcclxuXHR9XHJcblxyXG5cdC8qKiBHZXQgdGhlIHRleHQgb2YgYWxsIHRva2VucyBpbiB0aGlzIGJ1ZmZlci4gKi9cclxuXHRwdWJsaWMgZ2V0VGV4dCgpOiBzdHJpbmc7XHJcblx0cHVibGljIGdldFRleHQoaW50ZXJ2YWw6IEludGVydmFsKTogc3RyaW5nO1xyXG5cdHB1YmxpYyBnZXRUZXh0KGNvbnRleHQ6IFJ1bGVDb250ZXh0KTogc3RyaW5nO1xyXG5cdEBOb3ROdWxsXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGdldFRleHQoaW50ZXJ2YWw/OiBJbnRlcnZhbCB8IFJ1bGVDb250ZXh0KTogc3RyaW5nIHtcclxuXHRcdGlmIChpbnRlcnZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGludGVydmFsID0gSW50ZXJ2YWwub2YoMCwgdGhpcy5zaXplIC0gMSk7XHJcblx0XHR9IGVsc2UgaWYgKCEoaW50ZXJ2YWwgaW5zdGFuY2VvZiBJbnRlcnZhbCkpIHtcclxuXHRcdFx0Ly8gTm90ZTogdGhlIG1vcmUgb2J2aW91cyBjaGVjayBmb3IgJ2luc3RhbmNlb2YgUnVsZUNvbnRleHQnIHJlc3VsdHMgaW4gYSBjaXJjdWxhciBkZXBlbmRlbmN5IHByb2JsZW1cclxuXHRcdFx0aW50ZXJ2YWwgPSBpbnRlcnZhbC5zb3VyY2VJbnRlcnZhbDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgc3RhcnQ6IG51bWJlciA9IGludGVydmFsLmE7XHJcblx0XHRsZXQgc3RvcDogbnVtYmVyID0gaW50ZXJ2YWwuYjtcclxuXHRcdGlmIChzdGFydCA8IDAgfHwgc3RvcCA8IDApIHtcclxuXHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5maWxsKCk7XHJcblx0XHRpZiAoc3RvcCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcclxuXHRcdFx0c3RvcCA9IHRoaXMudG9rZW5zLmxlbmd0aCAtIDE7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGJ1Zjogc3RyaW5nID0gXCJcIjtcclxuXHRcdGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBzdG9wOyBpKyspIHtcclxuXHRcdFx0bGV0IHQ6IFRva2VuID0gdGhpcy50b2tlbnNbaV07XHJcblx0XHRcdGlmICh0LnR5cGUgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRidWYgKz0gdC50ZXh0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBidWYudG9TdHJpbmcoKTtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGdldFRleHRGcm9tUmFuZ2Uoc3RhcnQ6IGFueSwgc3RvcDogYW55KTogc3RyaW5nIHtcclxuXHRcdGlmICh0aGlzLmlzVG9rZW4oc3RhcnQpICYmIHRoaXMuaXNUb2tlbihzdG9wKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUZXh0KEludGVydmFsLm9mKHN0YXJ0LnRva2VuSW5kZXgsIHN0b3AudG9rZW5JbmRleCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBcIlwiO1xyXG5cdH1cclxuXHJcblx0LyoqIEdldCBhbGwgdG9rZW5zIGZyb20gbGV4ZXIgdW50aWwgRU9GLiAqL1xyXG5cdHB1YmxpYyBmaWxsKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5sYXp5SW5pdCgpO1xyXG5cdFx0Y29uc3QgYmxvY2tTaXplOiBudW1iZXIgPSAxMDAwO1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0bGV0IGZldGNoZWQ6IG51bWJlciA9IHRoaXMuZmV0Y2goYmxvY2tTaXplKTtcclxuXHRcdFx0aWYgKGZldGNoZWQgPCBibG9ja1NpemUpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIFRPRE86IEZpZ3VyZSBvdXQgYSB3YXkgdG8gbWFrZSB0aGlzIG1vcmUgZmxleGlibGU/XHJcblx0cHJpdmF0ZSBpc1dyaXRhYmxlVG9rZW4odDogVG9rZW4pOiB0IGlzIFdyaXRhYmxlVG9rZW4ge1xyXG5cdFx0cmV0dXJuIHQgaW5zdGFuY2VvZiBDb21tb25Ub2tlbjtcclxuXHR9XHJcblxyXG5cdC8vIFRPRE86IEZpZ3VyZSBvdXQgYSB3YXkgdG8gbWFrZSB0aGlzIG1vcmUgZmxleGlibGU/XHJcblx0cHJpdmF0ZSBpc1Rva2VuKHQ6IGFueSk6IHQgaXMgVG9rZW4ge1xyXG5cdFx0cmV0dXJuIHQgaW5zdGFuY2VvZiBDb21tb25Ub2tlbjtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUwLjM5NTMxNTctMDc6MDBcclxuXHJcbmltcG9ydCB7IEJ1ZmZlcmVkVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi9CdWZmZXJlZFRva2VuU3RyZWFtXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuU291cmNlIH0gZnJvbSBcIi4vVG9rZW5Tb3VyY2VcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGV4dGVuZHMge0BsaW5rIEJ1ZmZlcmVkVG9rZW5TdHJlYW19IHdpdGggZnVuY3Rpb25hbGl0eSB0byBmaWx0ZXJcclxuICogdG9rZW4gc3RyZWFtcyB0byB0b2tlbnMgb24gYSBwYXJ0aWN1bGFyIGNoYW5uZWwgKHRva2VucyB3aGVyZVxyXG4gKiB7QGxpbmsgVG9rZW4jZ2V0Q2hhbm5lbH0gcmV0dXJucyBhIHBhcnRpY3VsYXIgdmFsdWUpLlxyXG4gKlxyXG4gKiBUaGlzIHRva2VuIHN0cmVhbSBwcm92aWRlcyBhY2Nlc3MgdG8gYWxsIHRva2VucyBieSBpbmRleCBvciB3aGVuIGNhbGxpbmdcclxuICogbWV0aG9kcyBsaWtlIHtAbGluayAjZ2V0VGV4dH0uIFRoZSBjaGFubmVsIGZpbHRlcmluZyBpcyBvbmx5IHVzZWQgZm9yIGNvZGVcclxuICogYWNjZXNzaW5nIHRva2VucyB2aWEgdGhlIGxvb2thaGVhZCBtZXRob2RzIHtAbGluayAjTEF9LCB7QGxpbmsgI0xUfSwgYW5kXHJcbiAqIHtAbGluayAjTEJ9LlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCB0b2tlbnMgYXJlIHBsYWNlZCBvbiB0aGUgZGVmYXVsdCBjaGFubmVsXHJcbiAqICh7QGxpbmsgVG9rZW4jREVGQVVMVF9DSEFOTkVMfSksIGJ1dCBtYXkgYmUgcmVhc3NpZ25lZCBieSB1c2luZyB0aGVcclxuICogYC0+Y2hhbm5lbChISURERU4pYCBsZXhlciBjb21tYW5kLCBvciBieSB1c2luZyBhbiBlbWJlZGRlZCBhY3Rpb24gdG9cclxuICogY2FsbCB7QGxpbmsgTGV4ZXIjc2V0Q2hhbm5lbH0uXHJcbiAqXHJcbiAqIE5vdGU6IGxleGVyIHJ1bGVzIHdoaWNoIHVzZSB0aGUgYC0+c2tpcGAgbGV4ZXIgY29tbWFuZCBvciBjYWxsXHJcbiAqIHtAbGluayBMZXhlciNza2lwfSBkbyBub3QgcHJvZHVjZSB0b2tlbnMgYXQgYWxsLCBzbyBpbnB1dCB0ZXh0IG1hdGNoZWQgYnlcclxuICogc3VjaCBhIHJ1bGUgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGFzIHBhcnQgb2YgdGhlIHRva2VuIHN0cmVhbSwgcmVnYXJkbGVzcyBvZlxyXG4gKiBjaGFubmVsLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbW1vblRva2VuU3RyZWFtIGV4dGVuZHMgQnVmZmVyZWRUb2tlblN0cmVhbSB7XHJcblx0LyoqXHJcblx0ICogU3BlY2lmaWVzIHRoZSBjaGFubmVsIHRvIHVzZSBmb3IgZmlsdGVyaW5nIHRva2Vucy5cclxuXHQgKlxyXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHtAbGluayBUb2tlbiNERUZBVUxUX0NIQU5ORUx9LCB3aGljaCBtYXRjaGVzIHRoZVxyXG5cdCAqIGRlZmF1bHQgY2hhbm5lbCBhc3NpZ25lZCB0byB0b2tlbnMgY3JlYXRlZCBieSB0aGUgbGV4ZXIuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGNoYW5uZWw6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyB7QGxpbmsgQ29tbW9uVG9rZW5TdHJlYW19IHVzaW5nIHRoZSBzcGVjaWZpZWQgdG9rZW5cclxuXHQgKiBzb3VyY2UgYW5kIGZpbHRlcmluZyB0b2tlbnMgdG8gdGhlIHNwZWNpZmllZCBjaGFubmVsLiBPbmx5IHRva2VucyB3aG9zZVxyXG5cdCAqIHtAbGluayBUb2tlbiNnZXRDaGFubmVsfSBtYXRjaGVzIGBjaGFubmVsYCBvciBoYXZlIHRoZVxyXG5cdCAqIGBUb2tlbi50eXBlYCBlcXVhbCB0byB7QGxpbmsgVG9rZW4jRU9GfSB3aWxsIGJlIHJldHVybmVkIGJ5IHRoZVxyXG5cdCAqIHRva2VuIHN0cmVhbSBsb29rYWhlYWQgbWV0aG9kcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0b2tlblNvdXJjZSBUaGUgdG9rZW4gc291cmNlLlxyXG5cdCAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHVzZSBmb3IgZmlsdGVyaW5nIHRva2Vucy5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCB0b2tlblNvdXJjZTogVG9rZW5Tb3VyY2UsIGNoYW5uZWw6IG51bWJlciA9IFRva2VuLkRFRkFVTFRfQ0hBTk5FTCkge1xyXG5cdFx0c3VwZXIodG9rZW5Tb3VyY2UpO1xyXG5cdFx0dGhpcy5jaGFubmVsID0gY2hhbm5lbDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCBhZGp1c3RTZWVrSW5kZXgoaTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLm5leHRUb2tlbk9uQ2hhbm5lbChpLCB0aGlzLmNoYW5uZWwpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIHRyeUxCKGs6IG51bWJlcik6IFRva2VuIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICgodGhpcy5wIC0gaykgPCAwKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGk6IG51bWJlciA9IHRoaXMucDtcclxuXHRcdGxldCBuOiBudW1iZXIgPSAxO1xyXG5cdFx0Ly8gZmluZCBrIGdvb2QgdG9rZW5zIGxvb2tpbmcgYmFja3dhcmRzXHJcblx0XHR3aGlsZSAobiA8PSBrICYmIGkgPiAwKSB7XHJcblx0XHRcdC8vIHNraXAgb2ZmLWNoYW5uZWwgdG9rZW5zXHJcblx0XHRcdGkgPSB0aGlzLnByZXZpb3VzVG9rZW5PbkNoYW5uZWwoaSAtIDEsIHRoaXMuY2hhbm5lbCk7XHJcblx0XHRcdG4rKztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaSA8IDApIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy50b2tlbnNbaV07XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdHJ5TFQoazogbnVtYmVyKTogVG9rZW4gfCB1bmRlZmluZWQge1xyXG5cdFx0Ly9TeXN0ZW0ub3V0LnByaW50bG4oXCJlbnRlciBMVChcIitrK1wiKVwiKTtcclxuXHRcdHRoaXMubGF6eUluaXQoKTtcclxuXHRcdGlmIChrID09PSAwKSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiMCBpcyBub3QgYSB2YWxpZCBsb29rYWhlYWQgaW5kZXhcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGsgPCAwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRyeUxCKC1rKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgaTogbnVtYmVyID0gdGhpcy5wO1xyXG5cdFx0bGV0IG46IG51bWJlciA9IDE7IC8vIHdlIGtub3cgdG9rZW5zW3BdIGlzIGEgZ29vZCBvbmVcclxuXHRcdC8vIGZpbmQgayBnb29kIHRva2Vuc1xyXG5cdFx0d2hpbGUgKG4gPCBrKSB7XHJcblx0XHRcdC8vIHNraXAgb2ZmLWNoYW5uZWwgdG9rZW5zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBsb29rIHBhc3QgRU9GXHJcblx0XHRcdGlmICh0aGlzLnN5bmMoaSArIDEpKSB7XHJcblx0XHRcdFx0aSA9IHRoaXMubmV4dFRva2VuT25DaGFubmVsKGkgKyAxLCB0aGlzLmNoYW5uZWwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG4rKztcclxuXHRcdH1cclxuXHJcblx0XHQvL1x0XHRpZiAoIGk+cmFuZ2UgKSByYW5nZSA9IGk7XHJcblx0XHRyZXR1cm4gdGhpcy50b2tlbnNbaV07XHJcblx0fVxyXG5cclxuXHQvKiogQ291bnQgRU9GIGp1c3Qgb25jZS4gKi9cclxuXHRwdWJsaWMgZ2V0TnVtYmVyT2ZPbkNoYW5uZWxUb2tlbnMoKTogbnVtYmVyIHtcclxuXHRcdGxldCBuOiBudW1iZXIgPSAwO1xyXG5cdFx0dGhpcy5maWxsKCk7XHJcblx0XHRmb3IgKGxldCB0IG9mIHRoaXMudG9rZW5zKSB7XHJcblx0XHRcdGlmICh0LmNoYW5uZWwgPT09IHRoaXMuY2hhbm5lbCkge1xyXG5cdFx0XHRcdG4rKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbjtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUyLjE5MTY5NTUtMDc6MDBcclxuXHJcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiLi9DaGFyU3RyZWFtXCI7XHJcbmltcG9ydCB7IENvbW1vblRva2VuRmFjdG9yeSB9IGZyb20gXCIuL0NvbW1vblRva2VuRmFjdG9yeVwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBUb2tlbkZhY3RvcnkgfSBmcm9tIFwiLi9Ub2tlbkZhY3RvcnlcIjtcclxuaW1wb3J0IHsgVG9rZW5Tb3VyY2UgfSBmcm9tIFwiLi9Ub2tlblNvdXJjZVwiO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBUb2tlblNvdXJjZX0gYXMgYSB3cmFwcGVyIGFyb3VuZCBhIGxpc3RcclxuICogb2Yge0BsaW5rIFRva2VufSBvYmplY3RzLlxyXG4gKlxyXG4gKiBJZiB0aGUgZmluYWwgdG9rZW4gaW4gdGhlIGxpc3QgaXMgYW4ge0BsaW5rIFRva2VuI0VPRn0gdG9rZW4sIGl0IHdpbGwgYmUgdXNlZFxyXG4gKiBhcyB0aGUgRU9GIHRva2VuIGZvciBldmVyeSBjYWxsIHRvIHtAbGluayAjbmV4dFRva2VufSBhZnRlciB0aGUgZW5kIG9mIHRoZVxyXG4gKiBsaXN0IGlzIHJlYWNoZWQuIE90aGVyd2lzZSwgYW4gRU9GIHRva2VuIHdpbGwgYmUgY3JlYXRlZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBMaXN0VG9rZW5Tb3VyY2UgaW1wbGVtZW50cyBUb2tlblNvdXJjZSB7XHJcblx0LyoqXHJcblx0ICogVGhlIHdyYXBwZWQgY29sbGVjdGlvbiBvZiB7QGxpbmsgVG9rZW59IG9iamVjdHMgdG8gcmV0dXJuLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCB0b2tlbnM6IFRva2VuW107XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCBzb3VyY2UuIElmIHRoaXMgdmFsdWUgaXMgYHVuZGVmaW5lZGAsIGEgY2FsbCB0b1xyXG5cdCAqIHtAbGluayAjZ2V0U291cmNlTmFtZX0gc2hvdWxkIHJldHVybiB0aGUgc291cmNlIG5hbWUgdXNlZCB0byBjcmVhdGUgdGhlXHJcblx0ICogdGhlIG5leHQgdG9rZW4gaW4ge0BsaW5rICN0b2tlbnN9IChvciB0aGUgcHJldmlvdXMgdG9rZW4gaWYgdGhlIGVuZCBvZlxyXG5cdCAqIHRoZSBpbnB1dCBoYXMgYmVlbiByZWFjaGVkKS5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9zb3VyY2VOYW1lPzogc3RyaW5nO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgaW5kZXggaW50byB7QGxpbmsgI3Rva2Vuc30gb2YgdG9rZW4gdG8gcmV0dXJuIGJ5IHRoZSBuZXh0IGNhbGwgdG9cclxuXHQgKiB7QGxpbmsgI25leHRUb2tlbn0uIFRoZSBlbmQgb2YgdGhlIGlucHV0IGlzIGluZGljYXRlZCBieSB0aGlzIHZhbHVlXHJcblx0ICogYmVpbmcgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4ge0BsaW5rICN0b2tlbnN9LlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBpOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGZpZWxkIGNhY2hlcyB0aGUgRU9GIHRva2VuIGZvciB0aGUgdG9rZW4gc291cmNlLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBlb2ZUb2tlbj86IFRva2VuO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciB7QGxpbmsgI2dldFRva2VuRmFjdG9yeX0gYW5kXHJcblx0ICoge0BsaW5rIHNldFRva2VuRmFjdG9yeX0uXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfZmFjdG9yeTogVG9rZW5GYWN0b3J5ID0gQ29tbW9uVG9rZW5GYWN0b3J5LkRFRkFVTFQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcge0BsaW5rIExpc3RUb2tlblNvdXJjZX0gaW5zdGFuY2UgZnJvbSB0aGUgc3BlY2lmaWVkXHJcblx0ICogY29sbGVjdGlvbiBvZiB7QGxpbmsgVG9rZW59IG9iamVjdHMgYW5kIHNvdXJjZSBuYW1lLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHRva2VucyBUaGUgY29sbGVjdGlvbiBvZiB7QGxpbmsgVG9rZW59IG9iamVjdHMgdG8gcHJvdmlkZSBhcyBhXHJcblx0ICoge0BsaW5rIFRva2VuU291cmNlfS5cclxuXHQgKiBAcGFyYW0gc291cmNlTmFtZSBUaGUgbmFtZSBvZiB0aGUge0BsaW5rIFRva2VuU291cmNlfS4gSWYgdGhpcyB2YWx1ZSBpc1xyXG5cdCAqIGB1bmRlZmluZWRgLCB7QGxpbmsgI2dldFNvdXJjZU5hbWV9IHdpbGwgYXR0ZW1wdCB0byBpbmZlciB0aGUgbmFtZSBmcm9tXHJcblx0ICogdGhlIG5leHQge0BsaW5rIFRva2VufSAob3IgdGhlIHByZXZpb3VzIHRva2VuIGlmIHRoZSBlbmQgb2YgdGhlIGlucHV0IGhhc1xyXG5cdCAqIGJlZW4gcmVhY2hlZCkuXHJcblx0ICpcclxuXHQgKiBAZXhjZXB0aW9uIE51bGxQb2ludGVyRXhjZXB0aW9uIGlmIGB0b2tlbnNgIGlzIGB1bmRlZmluZWRgXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgdG9rZW5zOiBUb2tlbltdLCBzb3VyY2VOYW1lPzogc3RyaW5nKSB7XHJcblx0XHRpZiAodG9rZW5zID09IG51bGwpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidG9rZW5zIGNhbm5vdCBiZSBudWxsXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudG9rZW5zID0gdG9rZW5zO1xyXG5cdFx0dGhpcy5fc291cmNlTmFtZSA9IHNvdXJjZU5hbWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGNoYXJQb3NpdGlvbkluTGluZSgpOiBudW1iZXIge1xyXG5cdFx0aWYgKHRoaXMuaSA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pXS5jaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMuZW9mVG9rZW4gIT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lb2ZUb2tlbi5jaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMudG9rZW5zLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0Ly8gaGF2ZSB0byBjYWxjdWxhdGUgdGhlIHJlc3VsdCBmcm9tIHRoZSBsaW5lL2NvbHVtbiBvZiB0aGUgcHJldmlvdXNcclxuXHRcdFx0Ly8gdG9rZW4sIGFsb25nIHdpdGggdGhlIHRleHQgb2YgdGhlIHRva2VuLlxyXG5cdFx0XHRsZXQgbGFzdFRva2VuOiBUb2tlbiA9IHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRsZXQgdG9rZW5UZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQgPSBsYXN0VG9rZW4udGV4dDtcclxuXHRcdFx0aWYgKHRva2VuVGV4dCAhPSBudWxsKSB7XHJcblx0XHRcdFx0bGV0IGxhc3ROZXdMaW5lOiBudW1iZXIgPSB0b2tlblRleHQubGFzdEluZGV4T2YoXCJcXG5cIik7XHJcblx0XHRcdFx0aWYgKGxhc3ROZXdMaW5lID49IDApIHtcclxuXHRcdFx0XHRcdHJldHVybiB0b2tlblRleHQubGVuZ3RoIC0gbGFzdE5ld0xpbmUgLSAxO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGxhc3RUb2tlbi5jaGFyUG9zaXRpb25JbkxpbmUgKyBsYXN0VG9rZW4uc3RvcEluZGV4IC0gbGFzdFRva2VuLnN0YXJ0SW5kZXggKyAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG9ubHkgcmVhY2ggdGhpcyBpZiB0b2tlbnMgaXMgZW1wdHksIG1lYW5pbmcgRU9GIG9jY3VycyBhdCB0aGUgZmlyc3RcclxuXHRcdC8vIHBvc2l0aW9uIGluIHRoZSBpbnB1dFxyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG5leHRUb2tlbigpOiBUb2tlbiB7XHJcblx0XHRpZiAodGhpcy5pID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAodGhpcy5lb2ZUb2tlbiA9PSBudWxsKSB7XHJcblx0XHRcdFx0bGV0IHN0YXJ0OiBudW1iZXIgPSAtMTtcclxuXHRcdFx0XHRpZiAodGhpcy50b2tlbnMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0bGV0IHByZXZpb3VzU3RvcDogbnVtYmVyID0gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0uc3RvcEluZGV4O1xyXG5cdFx0XHRcdFx0aWYgKHByZXZpb3VzU3RvcCAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0c3RhcnQgPSBwcmV2aW91c1N0b3AgKyAxO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IHN0b3A6IG51bWJlciA9IE1hdGgubWF4KC0xLCBzdGFydCAtIDEpO1xyXG5cdFx0XHRcdHRoaXMuZW9mVG9rZW4gPSB0aGlzLl9mYWN0b3J5LmNyZWF0ZSh7IHNvdXJjZTogdGhpcywgc3RyZWFtOiB0aGlzLmlucHV0U3RyZWFtIH0sIFRva2VuLkVPRiwgXCJFT0ZcIiwgVG9rZW4uREVGQVVMVF9DSEFOTkVMLCBzdGFydCwgc3RvcCwgdGhpcy5saW5lLCB0aGlzLmNoYXJQb3NpdGlvbkluTGluZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmVvZlRva2VuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0OiBUb2tlbiA9IHRoaXMudG9rZW5zW3RoaXMuaV07XHJcblx0XHRpZiAodGhpcy5pID09PSB0aGlzLnRva2Vucy5sZW5ndGggLSAxICYmIHQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdHRoaXMuZW9mVG9rZW4gPSB0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuaSsrO1xyXG5cdFx0cmV0dXJuIHQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGxpbmUoKTogbnVtYmVyIHtcclxuXHRcdGlmICh0aGlzLmkgPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaV0ubGluZTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5lb2ZUb2tlbiAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVvZlRva2VuLmxpbmU7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMudG9rZW5zLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0Ly8gaGF2ZSB0byBjYWxjdWxhdGUgdGhlIHJlc3VsdCBmcm9tIHRoZSBsaW5lL2NvbHVtbiBvZiB0aGUgcHJldmlvdXNcclxuXHRcdFx0Ly8gdG9rZW4sIGFsb25nIHdpdGggdGhlIHRleHQgb2YgdGhlIHRva2VuLlxyXG5cdFx0XHRsZXQgbGFzdFRva2VuOiBUb2tlbiA9IHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRsZXQgbGluZTogbnVtYmVyID0gbGFzdFRva2VuLmxpbmU7XHJcblxyXG5cdFx0XHRsZXQgdG9rZW5UZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQgPSBsYXN0VG9rZW4udGV4dDtcclxuXHRcdFx0aWYgKHRva2VuVGV4dCAhPSBudWxsKSB7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlblRleHQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmICh0b2tlblRleHQuY2hhckF0KGkpID09PSBcIlxcblwiKSB7XHJcblx0XHRcdFx0XHRcdGxpbmUrKztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGlmIG5vIHRleHQgaXMgYXZhaWxhYmxlLCBhc3N1bWUgdGhlIHRva2VuIGRpZCBub3QgY29udGFpbiBhbnkgbmV3bGluZSBjaGFyYWN0ZXJzLlxyXG5cdFx0XHRyZXR1cm4gbGluZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvbmx5IHJlYWNoIHRoaXMgaWYgdG9rZW5zIGlzIGVtcHR5LCBtZWFuaW5nIEVPRiBvY2N1cnMgYXQgdGhlIGZpcnN0XHJcblx0XHQvLyBwb3NpdGlvbiBpbiB0aGUgaW5wdXRcclxuXHRcdHJldHVybiAxO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpbnB1dFN0cmVhbSgpOiBDaGFyU3RyZWFtIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICh0aGlzLmkgPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaV0uaW5wdXRTdHJlYW07XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMuZW9mVG9rZW4gIT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lb2ZUb2tlbi5pbnB1dFN0cmVhbTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy50b2tlbnMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0uaW5wdXRTdHJlYW07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbm8gaW5wdXQgc3RyZWFtIGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZVxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc291cmNlTmFtZSgpOiBzdHJpbmcge1xyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZU5hbWUpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX3NvdXJjZU5hbWU7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGlucHV0U3RyZWFtOiBDaGFyU3RyZWFtIHwgdW5kZWZpbmVkID0gdGhpcy5pbnB1dFN0cmVhbTtcclxuXHRcdGlmIChpbnB1dFN0cmVhbSAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBpbnB1dFN0cmVhbS5zb3VyY2VOYW1lO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBcIkxpc3RcIjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKi9cclxuXHQvLyBAT3ZlcnJpZGVcclxuXHRzZXQgdG9rZW5GYWN0b3J5KEBOb3ROdWxsIGZhY3Rvcnk6IFRva2VuRmFjdG9yeSkge1xyXG5cdFx0dGhpcy5fZmFjdG9yeSA9IGZhY3Rvcnk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0QE5vdE51bGxcclxuXHRnZXQgdG9rZW5GYWN0b3J5KCk6IFRva2VuRmFjdG9yeSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZmFjdG9yeTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQyLjEzNDY5NTEtMDc6MDBcclxuXHJcbmV4cG9ydCBjbGFzcyBNdWx0aU1hcDxLLCBWPiBleHRlbmRzIE1hcDxLLCBWW10+IHtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHN1cGVyKCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgbWFwKGtleTogSywgdmFsdWU6IFYpOiB2b2lkIHtcclxuXHRcdGxldCBlbGVtZW50c0ZvcktleSA9IHN1cGVyLmdldChrZXkpO1xyXG5cdFx0aWYgKCFlbGVtZW50c0ZvcktleSkge1xyXG5cdFx0XHRlbGVtZW50c0ZvcktleSA9IFtdIGFzIFZbXTtcclxuXHRcdFx0c3VwZXIuc2V0KGtleSwgZWxlbWVudHNGb3JLZXkpO1xyXG5cdFx0fVxyXG5cdFx0ZWxlbWVudHNGb3JLZXkucHVzaCh2YWx1ZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0UGFpcnMoKTogQXJyYXk8W0ssIFZdPiB7XHJcblx0XHRsZXQgcGFpcnM6IEFycmF5PFtLLCBWXT4gPSBbXTtcclxuXHRcdHRoaXMuZm9yRWFjaCgodmFsdWVzOiBWW10sIGtleTogSykgPT4ge1xyXG5cdFx0XHR2YWx1ZXMuZm9yRWFjaCgodikgPT4ge1xyXG5cdFx0XHRcdHBhaXJzLnB1c2goW2tleSwgdl0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHBhaXJzO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDIuNTQ0NzA4NS0wNzowMFxyXG5cclxuLyoqXHJcbiAqIFRoaXMgZXhjZXB0aW9uIGlzIHRocm93biB0byBjYW5jZWwgYSBwYXJzaW5nIG9wZXJhdGlvbi4gVGhpcyBleGNlcHRpb24gZG9lc1xyXG4gKiBub3QgZXh0ZW5kIHtAbGluayBSZWNvZ25pdGlvbkV4Y2VwdGlvbn0sIGFsbG93aW5nIGl0IHRvIGJ5cGFzcyB0aGUgc3RhbmRhcmRcclxuICogZXJyb3IgcmVjb3ZlcnkgbWVjaGFuaXNtcy4ge0BsaW5rIEJhaWxFcnJvclN0cmF0ZWd5fSB0aHJvd3MgdGhpcyBleGNlcHRpb24gaW5cclxuICogcmVzcG9uc2UgdG8gYSBwYXJzZSBlcnJvci5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xyXG5cdC8vIHByaXZhdGUgc3RhdGljIHNlcmlhbFZlcnNpb25VSUQ6IG51bWJlciA9ICAtMzUyOTU1MjA5OTM2Njk3OTY4M0w7XHJcblx0cHVibGljIHJlYWRvbmx5IHN0YWNrPzogc3RyaW5nO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihwdWJsaWMgY2F1c2U6IEVycm9yKSB7XHJcblx0XHRzdXBlcihjYXVzZS5tZXNzYWdlKTtcclxuXHRcdHRoaXMuc3RhY2sgPSBjYXVzZS5zdGFjaztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRDYXVzZSgpOiBFcnJvciB7XHJcblx0XHRyZXR1cm4gdGhpcy5jYXVzZTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUxLjU4OTg1NDYtMDc6MDBcclxuXHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuL1BhcnNlclJ1bGVDb250ZXh0XCI7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBleHRlbmRzIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dH0gYnkgYWxsb3dpbmcgdGhlIHZhbHVlIG9mXHJcbiAqIHtAbGluayAjZ2V0UnVsZUluZGV4fSB0byBiZSBleHBsaWNpdGx5IHNldCBmb3IgdGhlIGNvbnRleHQuXHJcbiAqXHJcbiAqIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dH0gZG9lcyBub3QgaW5jbHVkZSBmaWVsZCBzdG9yYWdlIGZvciB0aGUgcnVsZSBpbmRleFxyXG4gKiBzaW5jZSB0aGUgY29udGV4dCBjbGFzc2VzIGNyZWF0ZWQgYnkgdGhlIGNvZGUgZ2VuZXJhdG9yIG92ZXJyaWRlIHRoZVxyXG4gKiB7QGxpbmsgI2dldFJ1bGVJbmRleH0gbWV0aG9kIHRvIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSBmb3IgdGhhdCBjb250ZXh0LlxyXG4gKiBTaW5jZSB0aGUgcGFyc2VyIGludGVycHJldGVyIGRvZXMgbm90IHVzZSB0aGUgY29udGV4dCBjbGFzc2VzIGdlbmVyYXRlZCBmb3IgYVxyXG4gKiBwYXJzZXIsIHRoaXMgY2xhc3MgKHdpdGggc2xpZ2h0bHkgbW9yZSBtZW1vcnkgb3ZlcmhlYWQgcGVyIG5vZGUpIGlzIHVzZWQgdG9cclxuICogcHJvdmlkZSBlcXVpdmFsZW50IGZ1bmN0aW9uYWxpdHkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW50ZXJwcmV0ZXJSdWxlQ29udGV4dCBleHRlbmRzIFBhcnNlclJ1bGVDb250ZXh0IHtcclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciB7QGxpbmsgI2dldFJ1bGVJbmRleH0uXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfcnVsZUluZGV4OiBudW1iZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHJ1bGVJbmRleDogbnVtYmVyKTtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyB7QGxpbmsgSW50ZXJwcmV0ZXJSdWxlQ29udGV4dH0gd2l0aCB0aGUgc3BlY2lmaWVkXHJcblx0ICogcGFyZW50LCBpbnZva2luZyBzdGF0ZSwgYW5kIHJ1bGUgaW5kZXguXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcnVsZUluZGV4IFRoZSBydWxlIGluZGV4IGZvciB0aGUgY3VycmVudCBjb250ZXh0LlxyXG5cdCAqIEBwYXJhbSBwYXJlbnQgVGhlIHBhcmVudCBjb250ZXh0LlxyXG5cdCAqIEBwYXJhbSBpbnZva2luZ1N0YXRlTnVtYmVyIFRoZSBpbnZva2luZyBzdGF0ZSBudW1iZXIuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IocnVsZUluZGV4OiBudW1iZXIsIHBhcmVudDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsIGludm9raW5nU3RhdGVOdW1iZXI6IG51bWJlcik7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHJ1bGVJbmRleDogbnVtYmVyLCBwYXJlbnQ/OiBQYXJzZXJSdWxlQ29udGV4dCwgaW52b2tpbmdTdGF0ZU51bWJlcj86IG51bWJlcikge1xyXG5cdFx0aWYgKGludm9raW5nU3RhdGVOdW1iZXIgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGVOdW1iZXIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3VwZXIoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9ydWxlSW5kZXggPSBydWxlSW5kZXg7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgcnVsZUluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcnVsZUluZGV4O1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTMuMTA0MzQ1MS0wNzowMFxyXG5cclxuaW1wb3J0IHsgQWN0aW9uVHJhbnNpdGlvbiB9IGZyb20gXCIuL2F0bi9BY3Rpb25UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuL2F0bi9BVE5cIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9hdG4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vYXRuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBBdG9tVHJhbnNpdGlvbiB9IGZyb20gXCIuL2F0bi9BdG9tVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBCaXRTZXQgfSBmcm9tIFwiLi9taXNjL0JpdFNldFwiO1xyXG5pbXBvcnQgeyBEZWNpc2lvblN0YXRlIH0gZnJvbSBcIi4vYXRuL0RlY2lzaW9uU3RhdGVcIjtcclxuaW1wb3J0IHsgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uIH0gZnJvbSBcIi4vRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IElucHV0TWlzbWF0Y2hFeGNlcHRpb24gfSBmcm9tIFwiLi9JbnB1dE1pc21hdGNoRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IEludGVycHJldGVyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9JbnRlcnByZXRlclJ1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IExvb3BFbmRTdGF0ZSB9IGZyb20gXCIuL2F0bi9Mb29wRW5kU3RhdGVcIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJBVE5TaW11bGF0b3IgfSBmcm9tIFwiLi9hdG4vUGFyc2VyQVROU2ltdWxhdG9yXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9hdG4vUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgUHJlZGljYXRlVHJhbnNpdGlvbiB9IGZyb20gXCIuL2F0bi9QcmVkaWNhdGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFJlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4vUmVjb2duaXRpb25FeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgUnVsZVN0YXJ0U3RhdGUgfSBmcm9tIFwiLi9hdG4vUnVsZVN0YXJ0U3RhdGVcIjtcclxuaW1wb3J0IHsgUnVsZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9hdG4vUnVsZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgU3Rhckxvb3BFbnRyeVN0YXRlIH0gZnJvbSBcIi4vYXRuL1N0YXJMb29wRW50cnlTdGF0ZVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4vVG9rZW5TdHJlYW1cIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCIuL2F0bi9UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25UeXBlIH0gZnJvbSBcIi4vYXRuL1RyYW5zaXRpb25UeXBlXCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnkgfSBmcm9tIFwiLi9Wb2NhYnVsYXJ5XCI7XHJcblxyXG4vKiogQSBwYXJzZXIgc2ltdWxhdG9yIHRoYXQgbWltaWNzIHdoYXQgQU5UTFIncyBnZW5lcmF0ZWRcclxuICogIHBhcnNlciBjb2RlIGRvZXMuIEEgUGFyc2VyQVROU2ltdWxhdG9yIGlzIHVzZWQgdG8gbWFrZVxyXG4gKiAgcHJlZGljdGlvbnMgdmlhIGFkYXB0aXZlUHJlZGljdCBidXQgdGhpcyBjbGFzcyBtb3ZlcyBhIHBvaW50ZXIgdGhyb3VnaCB0aGVcclxuICogIEFUTiB0byBzaW11bGF0ZSBwYXJzaW5nLiBQYXJzZXJBVE5TaW11bGF0b3IganVzdFxyXG4gKiAgbWFrZXMgdXMgZWZmaWNpZW50IHJhdGhlciB0aGFuIGhhdmluZyB0byBiYWNrdHJhY2ssIGZvciBleGFtcGxlLlxyXG4gKlxyXG4gKiAgVGhpcyBwcm9wZXJseSBjcmVhdGVzIHBhcnNlIHRyZWVzIGV2ZW4gZm9yIGxlZnQgcmVjdXJzaXZlIHJ1bGVzLlxyXG4gKlxyXG4gKiAgV2UgcmVseSBvbiB0aGUgbGVmdCByZWN1cnNpdmUgcnVsZSBpbnZvY2F0aW9uIGFuZCBzcGVjaWFsIHByZWRpY2F0ZVxyXG4gKiAgdHJhbnNpdGlvbnMgdG8gbWFrZSBsZWZ0IHJlY3Vyc2l2ZSBydWxlcyB3b3JrLlxyXG4gKlxyXG4gKiAgU2VlIFRlc3RQYXJzZXJJbnRlcnByZXRlciBmb3IgZXhhbXBsZXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGFyc2VySW50ZXJwcmV0ZXIgZXh0ZW5kcyBQYXJzZXIge1xyXG5cdHByb3RlY3RlZCBfZ3JhbW1hckZpbGVOYW1lOiBzdHJpbmc7XHJcblx0cHJvdGVjdGVkIF9hdG46IEFUTjtcclxuXHQvKiogVGhpcyBpZGVudGlmaWVzIFN0YXJMb29wRW50cnlTdGF0ZSdzIHRoYXQgYmVnaW4gdGhlICguLi4pKlxyXG5cdCAqICBwcmVjZWRlbmNlIGxvb3BzIG9mIGxlZnQgcmVjdXJzaXZlIHJ1bGVzLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBwdXNoUmVjdXJzaW9uQ29udGV4dFN0YXRlczogQml0U2V0O1xyXG5cclxuXHRwcm90ZWN0ZWQgX3J1bGVOYW1lczogc3RyaW5nW107XHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIF92b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5O1xyXG5cclxuXHQvKiogVGhpcyBzdGFjayBjb3JyZXNwb25kcyB0byB0aGUgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlIHBhaXIgb2YgbG9jYWxzXHJcblx0ICogIHRoYXQgd291bGQgZXhpc3Qgb24gY2FsbCBzdGFjayBmcmFtZXMgd2l0aCBhIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlcjtcclxuXHQgKiAgaW4gdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBmb3IgYSBsZWZ0LXJlY3Vyc2l2ZSBydWxlIHlvdSdkIHNlZTpcclxuXHQgKlxyXG5cdCAqICBwcml2YXRlIEVDb250ZXh0IGUoaW50IF9wKSB7XHJcblx0ICogICAgICBQYXJzZXJSdWxlQ29udGV4dCBfcGFyZW50Y3R4ID0gX2N0eDsgICAgLy8gUGFpci5hXHJcblx0ICogICAgICBpbnQgX3BhcmVudFN0YXRlID0gc3RhdGU7ICAgICAgICAgIC8vIFBhaXIuYlxyXG5cdCAqICAgICAgLi4uXHJcblx0ICogIH1cclxuXHQgKlxyXG5cdCAqICBUaG9zZSB2YWx1ZXMgYXJlIHVzZWQgdG8gY3JlYXRlIG5ldyByZWN1cnNpdmUgcnVsZSBpbnZvY2F0aW9uIGNvbnRleHRzXHJcblx0ICogIGFzc29jaWF0ZWQgd2l0aCBsZWZ0IG9wZXJhbmQgb2YgYW4gYWx0IGxpa2UgXCJleHByICcqJyBleHByXCIuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHJlYWRvbmx5IF9wYXJlbnRDb250ZXh0U3RhY2s6IEFycmF5PFtQYXJzZXJSdWxlQ29udGV4dCwgbnVtYmVyXT4gPSBbXTtcclxuXHJcblx0LyoqIFdlIG5lZWQgYSBtYXAgZnJvbSAoZGVjaXNpb24saW5wdXRJbmRleCktPmZvcmNlZCBhbHQgZm9yIGNvbXB1dGluZyBhbWJpZ3VvdXNcclxuXHQgKiAgcGFyc2UgdHJlZXMuIEZvciBub3csIHdlIGFsbG93IGV4YWN0bHkgb25lIG92ZXJyaWRlLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBvdmVycmlkZURlY2lzaW9uOiBudW1iZXIgPSAtMTtcclxuXHRwcm90ZWN0ZWQgb3ZlcnJpZGVEZWNpc2lvbklucHV0SW5kZXg6IG51bWJlciA9IC0xO1xyXG5cdHByb3RlY3RlZCBvdmVycmlkZURlY2lzaW9uQWx0OiBudW1iZXIgPSAtMTtcclxuXHRwcm90ZWN0ZWQgb3ZlcnJpZGVEZWNpc2lvblJlYWNoZWQ6IGJvb2xlYW4gPSBmYWxzZTsgLy8gbGF0Y2ggYW5kIG9ubHkgb3ZlcnJpZGUgb25jZTsgZXJyb3IgbWlnaHQgdHJpZ2dlciBpbmZpbml0ZSBsb29wXHJcblxyXG5cdC8qKiBXaGF0IGlzIHRoZSBjdXJyZW50IGNvbnRleHQgd2hlbiB3ZSBvdmVycmlkZSBhIGRlY2lzaW9ucz8gIFRoaXMgdGVsbHNcclxuXHQgKiAgdXMgd2hhdCB0aGUgcm9vdCBvZiB0aGUgcGFyc2UgdHJlZSBpcyB3aGVuIHVzaW5nIG92ZXJyaWRlXHJcblx0ICogIGZvciBhbiBhbWJpZ3VpdHkvbG9va2FoZWFkIGNoZWNrLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBfb3ZlcnJpZGVEZWNpc2lvblJvb3Q/OiBJbnRlcnByZXRlclJ1bGVDb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cclxuXHRwcm90ZWN0ZWQgX3Jvb3RDb250ZXh0ITogSW50ZXJwcmV0ZXJSdWxlQ29udGV4dDtcclxuXHJcblx0LyoqIEEgY29weSBjb25zdHJ1Y3RvciB0aGF0IGNyZWF0ZXMgYSBuZXcgcGFyc2VyIGludGVycHJldGVyIGJ5IHJldXNpbmdcclxuXHQgKiAgdGhlIGZpZWxkcyBvZiBhIHByZXZpb3VzIGludGVycHJldGVyLlxyXG5cdCAqXHJcblx0ICogIEBwYXJhbSBvbGQgVGhlIGludGVycHJldGVyIHRvIGNvcHlcclxuXHQgKlxyXG5cdCAqICBAc2luY2UgNC41XHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoLypATm90TnVsbCovIG9sZDogUGFyc2VySW50ZXJwcmV0ZXIpO1xyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0Z3JhbW1hckZpbGVOYW1lOiBzdHJpbmcsIC8qQE5vdE51bGwqLyB2b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5LFxyXG5cdFx0cnVsZU5hbWVzOiBzdHJpbmdbXSwgYXRuOiBBVE4sIGlucHV0OiBUb2tlblN0cmVhbSk7XHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRncmFtbWFyRmlsZU5hbWU6IFBhcnNlckludGVycHJldGVyIHwgc3RyaW5nLCBATm90TnVsbCB2b2NhYnVsYXJ5PzogVm9jYWJ1bGFyeSxcclxuXHRcdHJ1bGVOYW1lcz86IHN0cmluZ1tdLCBhdG4/OiBBVE4sIGlucHV0PzogVG9rZW5TdHJlYW0pIHtcclxuXHRcdHN1cGVyKGdyYW1tYXJGaWxlTmFtZSBpbnN0YW5jZW9mIFBhcnNlckludGVycHJldGVyID8gZ3JhbW1hckZpbGVOYW1lLmlucHV0U3RyZWFtIDogaW5wdXQhKTtcclxuXHRcdGlmIChncmFtbWFyRmlsZU5hbWUgaW5zdGFuY2VvZiBQYXJzZXJJbnRlcnByZXRlcikge1xyXG5cdFx0XHRsZXQgb2xkOiBQYXJzZXJJbnRlcnByZXRlciA9IGdyYW1tYXJGaWxlTmFtZTtcclxuXHRcdFx0dGhpcy5fZ3JhbW1hckZpbGVOYW1lID0gb2xkLl9ncmFtbWFyRmlsZU5hbWU7XHJcblx0XHRcdHRoaXMuX2F0biA9IG9sZC5fYXRuO1xyXG5cdFx0XHR0aGlzLnB1c2hSZWN1cnNpb25Db250ZXh0U3RhdGVzID0gb2xkLnB1c2hSZWN1cnNpb25Db250ZXh0U3RhdGVzO1xyXG5cdFx0XHR0aGlzLl9ydWxlTmFtZXMgPSBvbGQuX3J1bGVOYW1lcztcclxuXHRcdFx0dGhpcy5fdm9jYWJ1bGFyeSA9IG9sZC5fdm9jYWJ1bGFyeTtcclxuXHRcdFx0dGhpcy5pbnRlcnByZXRlciA9IG5ldyBQYXJzZXJBVE5TaW11bGF0b3IodGhpcy5fYXRuLCB0aGlzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIFRoZSBzZWNvbmQgY29uc3RydWN0b3IgcmVxdWlyZXMgbm9uLW51bGwgYXJndW1lbnRzXHJcblx0XHRcdHZvY2FidWxhcnkgPSB2b2NhYnVsYXJ5ITtcclxuXHRcdFx0cnVsZU5hbWVzID0gcnVsZU5hbWVzITtcclxuXHRcdFx0YXRuID0gYXRuITtcclxuXHJcblx0XHRcdHRoaXMuX2dyYW1tYXJGaWxlTmFtZSA9IGdyYW1tYXJGaWxlTmFtZTtcclxuXHRcdFx0dGhpcy5fYXRuID0gYXRuO1xyXG5cdFx0XHR0aGlzLl9ydWxlTmFtZXMgPSBydWxlTmFtZXMuc2xpY2UoMCk7XHJcblx0XHRcdHRoaXMuX3ZvY2FidWxhcnkgPSB2b2NhYnVsYXJ5O1xyXG5cclxuXHRcdFx0Ly8gaWRlbnRpZnkgdGhlIEFUTiBzdGF0ZXMgd2hlcmUgcHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQoKSBtdXN0IGJlIGNhbGxlZFxyXG5cdFx0XHR0aGlzLnB1c2hSZWN1cnNpb25Db250ZXh0U3RhdGVzID0gbmV3IEJpdFNldChhdG4uc3RhdGVzLmxlbmd0aCk7XHJcblx0XHRcdGZvciAobGV0IHN0YXRlIG9mIGF0bi5zdGF0ZXMpIHtcclxuXHRcdFx0XHRpZiAoIShzdGF0ZSBpbnN0YW5jZW9mIFN0YXJMb29wRW50cnlTdGF0ZSkpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHN0YXRlLnByZWNlZGVuY2VSdWxlRGVjaXNpb24pIHtcclxuXHRcdFx0XHRcdHRoaXMucHVzaFJlY3Vyc2lvbkNvbnRleHRTdGF0ZXMuc2V0KHN0YXRlLnN0YXRlTnVtYmVyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGdldCBhdG4gc2ltdWxhdG9yIHRoYXQga25vd3MgaG93IHRvIGRvIHByZWRpY3Rpb25zXHJcblx0XHRcdHRoaXMuaW50ZXJwcmV0ZXIgPSBuZXcgUGFyc2VyQVROU2ltdWxhdG9yKGF0biwgdGhpcyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVzZXQocmVzZXRJbnB1dD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGlmIChyZXNldElucHV0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c3VwZXIucmVzZXQoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN1cGVyLnJlc2V0KHJlc2V0SW5wdXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3ZlcnJpZGVEZWNpc2lvblJlYWNoZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX292ZXJyaWRlRGVjaXNpb25Sb290ID0gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGF0bigpOiBBVE4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2F0bjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCB2b2NhYnVsYXJ5KCk6IFZvY2FidWxhcnkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3ZvY2FidWxhcnk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgcnVsZU5hbWVzKCk6IHN0cmluZ1tdIHtcclxuXHRcdHJldHVybiB0aGlzLl9ydWxlTmFtZXM7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgZ3JhbW1hckZpbGVOYW1lKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ3JhbW1hckZpbGVOYW1lO1xyXG5cdH1cclxuXHJcblx0LyoqIEJlZ2luIHBhcnNpbmcgYXQgc3RhcnRSdWxlSW5kZXggKi9cclxuXHRwdWJsaWMgcGFyc2Uoc3RhcnRSdWxlSW5kZXg6IG51bWJlcik6IFBhcnNlclJ1bGVDb250ZXh0IHtcclxuXHRcdGxldCBzdGFydFJ1bGVTdGFydFN0YXRlOiBSdWxlU3RhcnRTdGF0ZSA9IHRoaXMuX2F0bi5ydWxlVG9TdGFydFN0YXRlW3N0YXJ0UnVsZUluZGV4XTtcclxuXHJcblx0XHR0aGlzLl9yb290Q29udGV4dCA9IHRoaXMuY3JlYXRlSW50ZXJwcmV0ZXJSdWxlQ29udGV4dCh1bmRlZmluZWQsIEFUTlN0YXRlLklOVkFMSURfU1RBVEVfTlVNQkVSLCBzdGFydFJ1bGVJbmRleCk7XHJcblx0XHRpZiAoc3RhcnRSdWxlU3RhcnRTdGF0ZS5pc1ByZWNlZGVuY2VSdWxlKSB7XHJcblx0XHRcdHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKHRoaXMuX3Jvb3RDb250ZXh0LCBzdGFydFJ1bGVTdGFydFN0YXRlLnN0YXRlTnVtYmVyLCBzdGFydFJ1bGVJbmRleCwgMCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5lbnRlclJ1bGUodGhpcy5fcm9vdENvbnRleHQsIHN0YXJ0UnVsZVN0YXJ0U3RhdGUuc3RhdGVOdW1iZXIsIHN0YXJ0UnVsZUluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRsZXQgcDogQVROU3RhdGUgPSB0aGlzLmF0blN0YXRlO1xyXG5cdFx0XHRzd2l0Y2ggKHAuc3RhdGVUeXBlKSB7XHJcblx0XHRcdGNhc2UgQVROU3RhdGVUeXBlLlJVTEVfU1RPUDpcclxuXHRcdFx0XHQvLyBwb3A7IHJldHVybiBmcm9tIHJ1bGVcclxuXHRcdFx0XHRpZiAodGhpcy5fY3R4LmlzRW1wdHkpIHtcclxuXHRcdFx0XHRcdGlmIChzdGFydFJ1bGVTdGFydFN0YXRlLmlzUHJlY2VkZW5jZVJ1bGUpIHtcclxuXHRcdFx0XHRcdFx0bGV0IHJlc3VsdDogUGFyc2VyUnVsZUNvbnRleHQgPSB0aGlzLl9jdHg7XHJcblx0XHRcdFx0XHRcdGxldCBwYXJlbnRDb250ZXh0OiBbUGFyc2VyUnVsZUNvbnRleHQsIG51bWJlcl0gPSB0aGlzLl9wYXJlbnRDb250ZXh0U3RhY2sucG9wKCkgITtcclxuXHRcdFx0XHRcdFx0dGhpcy51bnJvbGxSZWN1cnNpb25Db250ZXh0cyhwYXJlbnRDb250ZXh0WzBdKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmV4aXRSdWxlKCk7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLl9yb290Q29udGV4dDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMudmlzaXRSdWxlU3RvcFN0YXRlKHApO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0dGhpcy52aXNpdFN0YXRlKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYXRjaCAoZSkge1xyXG5cdFx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBSZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlID0gdGhpcy5fYXRuLnJ1bGVUb1N0b3BTdGF0ZVtwLnJ1bGVJbmRleF0uc3RhdGVOdW1iZXI7XHJcblx0XHRcdFx0XHRcdHRoaXMuY29udGV4dC5leGNlcHRpb24gPSBlO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5yZWNvdmVyKGUpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4OiBQYXJzZXJSdWxlQ29udGV4dCwgc3RhdGU6IG51bWJlciwgcnVsZUluZGV4OiBudW1iZXIsIHByZWNlZGVuY2U6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5fcGFyZW50Q29udGV4dFN0YWNrLnB1c2goW3RoaXMuX2N0eCwgbG9jYWxjdHguaW52b2tpbmdTdGF0ZV0pO1xyXG5cdFx0c3VwZXIuZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCBzdGF0ZSwgcnVsZUluZGV4LCBwcmVjZWRlbmNlKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXQgYXRuU3RhdGUoKTogQVROU3RhdGUge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2F0bi5zdGF0ZXNbdGhpcy5zdGF0ZV07XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgdmlzaXRTdGF0ZShwOiBBVE5TdGF0ZSk6IHZvaWQge1xyXG5cdFx0bGV0IHByZWRpY3RlZEFsdDogbnVtYmVyID0gMTtcclxuXHRcdGlmIChwLm51bWJlck9mVHJhbnNpdGlvbnMgPiAxKSB7XHJcblx0XHRcdHByZWRpY3RlZEFsdCA9IHRoaXMudmlzaXREZWNpc2lvblN0YXRlKHAgYXMgRGVjaXNpb25TdGF0ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHRyYW5zaXRpb246IFRyYW5zaXRpb24gPSBwLnRyYW5zaXRpb24ocHJlZGljdGVkQWx0IC0gMSk7XHJcblx0XHRzd2l0Y2ggKHRyYW5zaXRpb24uc2VyaWFsaXphdGlvblR5cGUpIHtcclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuRVBTSUxPTjpcclxuXHRcdFx0aWYgKHRoaXMucHVzaFJlY3Vyc2lvbkNvbnRleHRTdGF0ZXMuZ2V0KHAuc3RhdGVOdW1iZXIpICYmXHJcblx0XHRcdFx0ISh0cmFuc2l0aW9uLnRhcmdldCBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZSkpIHtcclxuXHRcdFx0XHQvLyBXZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIGEgbGVmdCByZWN1cnNpdmUgcnVsZSdzICguLi4pKiBsb29wXHJcblx0XHRcdFx0Ly8gYW5kIHdlJ3JlIG5vdCB0YWtpbmcgdGhlIGV4aXQgYnJhbmNoIG9mIGxvb3AuXHJcblx0XHRcdFx0bGV0IHBhcmVudENvbnRleHQgPSB0aGlzLl9wYXJlbnRDb250ZXh0U3RhY2tbdGhpcy5fcGFyZW50Q29udGV4dFN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRcdGxldCBsb2NhbGN0eDogSW50ZXJwcmV0ZXJSdWxlQ29udGV4dCA9XHJcblx0XHRcdFx0XHR0aGlzLmNyZWF0ZUludGVycHJldGVyUnVsZUNvbnRleHQocGFyZW50Q29udGV4dFswXSwgcGFyZW50Q29udGV4dFsxXSwgdGhpcy5fY3R4LnJ1bGVJbmRleCk7XHJcblx0XHRcdFx0dGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCxcclxuXHRcdFx0XHRcdHRoaXMuX2F0bi5ydWxlVG9TdGFydFN0YXRlW3AucnVsZUluZGV4XS5zdGF0ZU51bWJlcixcclxuXHRcdFx0XHRcdHRoaXMuX2N0eC5ydWxlSW5kZXgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuQVRPTTpcclxuXHRcdFx0dGhpcy5tYXRjaCgodHJhbnNpdGlvbiBhcyBBdG9tVHJhbnNpdGlvbikuX2xhYmVsKTtcclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5SQU5HRTpcclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuU0VUOlxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5OT1RfU0VUOlxyXG5cdFx0XHRpZiAoIXRyYW5zaXRpb24ubWF0Y2hlcyh0aGlzLl9pbnB1dC5MQSgxKSwgVG9rZW4uTUlOX1VTRVJfVE9LRU5fVFlQRSwgNjU1MzUpKSB7XHJcblx0XHRcdFx0dGhpcy5yZWNvdmVySW5saW5lKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5tYXRjaFdpbGRjYXJkKCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuV0lMRENBUkQ6XHJcblx0XHRcdHRoaXMubWF0Y2hXaWxkY2FyZCgpO1xyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlJVTEU6XHJcblx0XHRcdGxldCBydWxlU3RhcnRTdGF0ZTogUnVsZVN0YXJ0U3RhdGUgPSB0cmFuc2l0aW9uLnRhcmdldCBhcyBSdWxlU3RhcnRTdGF0ZTtcclxuXHRcdFx0bGV0IHJ1bGVJbmRleDogbnVtYmVyID0gcnVsZVN0YXJ0U3RhdGUucnVsZUluZGV4O1xyXG5cdFx0XHRsZXQgbmV3Y3R4OiBJbnRlcnByZXRlclJ1bGVDb250ZXh0ID0gdGhpcy5jcmVhdGVJbnRlcnByZXRlclJ1bGVDb250ZXh0KHRoaXMuX2N0eCwgcC5zdGF0ZU51bWJlciwgcnVsZUluZGV4KTtcclxuXHRcdFx0aWYgKHJ1bGVTdGFydFN0YXRlLmlzUHJlY2VkZW5jZVJ1bGUpIHtcclxuXHRcdFx0XHR0aGlzLmVudGVyUmVjdXJzaW9uUnVsZShuZXdjdHgsIHJ1bGVTdGFydFN0YXRlLnN0YXRlTnVtYmVyLCBydWxlSW5kZXgsICh0cmFuc2l0aW9uIGFzIFJ1bGVUcmFuc2l0aW9uKS5wcmVjZWRlbmNlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmVudGVyUnVsZShuZXdjdHgsIHRyYW5zaXRpb24udGFyZ2V0LnN0YXRlTnVtYmVyLCBydWxlSW5kZXgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUFJFRElDQVRFOlxyXG5cdFx0XHRsZXQgcHJlZGljYXRlVHJhbnNpdGlvbjogUHJlZGljYXRlVHJhbnNpdGlvbiA9IHRyYW5zaXRpb24gYXMgUHJlZGljYXRlVHJhbnNpdGlvbjtcclxuXHRcdFx0aWYgKCF0aGlzLnNlbXByZWQodGhpcy5fY3R4LCBwcmVkaWNhdGVUcmFuc2l0aW9uLnJ1bGVJbmRleCwgcHJlZGljYXRlVHJhbnNpdGlvbi5wcmVkSW5kZXgpKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5BQ1RJT046XHJcblx0XHRcdGxldCBhY3Rpb25UcmFuc2l0aW9uOiBBY3Rpb25UcmFuc2l0aW9uID0gdHJhbnNpdGlvbiBhcyBBY3Rpb25UcmFuc2l0aW9uO1xyXG5cdFx0XHR0aGlzLmFjdGlvbih0aGlzLl9jdHgsIGFjdGlvblRyYW5zaXRpb24ucnVsZUluZGV4LCBhY3Rpb25UcmFuc2l0aW9uLmFjdGlvbkluZGV4KTtcclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5QUkVDRURFTkNFOlxyXG5cdFx0XHRpZiAoIXRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAodHJhbnNpdGlvbiBhcyBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbikucHJlY2VkZW5jZSkpIHtcclxuXHRcdFx0XHRsZXQgcHJlY2VkZW5jZSA9ICh0cmFuc2l0aW9uIGFzIFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uKS5wcmVjZWRlbmNlO1xyXG5cdFx0XHRcdHRocm93IG5ldyBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgYHByZWNwcmVkKF9jdHgsICR7cHJlY2VkZW5jZX0pYCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb246IFVucmVjb2duaXplZCBBVE4gdHJhbnNpdGlvbiB0eXBlLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnN0YXRlID0gdHJhbnNpdGlvbi50YXJnZXQuc3RhdGVOdW1iZXI7XHJcblx0fVxyXG5cclxuXHQvKiogTWV0aG9kIHZpc2l0RGVjaXNpb25TdGF0ZSgpIGlzIGNhbGxlZCB3aGVuIHRoZSBpbnRlcnByZXRlciByZWFjaGVzXHJcblx0ICogIGEgZGVjaXNpb24gc3RhdGUgKGluc3RhbmNlIG9mIERlY2lzaW9uU3RhdGUpLiBJdCBnaXZlcyBhbiBvcHBvcnR1bml0eVxyXG5cdCAqICBmb3Igc3ViY2xhc3NlcyB0byB0cmFjayBpbnRlcmVzdGluZyB0aGluZ3MuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHZpc2l0RGVjaXNpb25TdGF0ZShwOiBEZWNpc2lvblN0YXRlKTogbnVtYmVyIHtcclxuXHRcdGxldCBwcmVkaWN0ZWRBbHQ6IG51bWJlcjtcclxuXHRcdHRoaXMuZXJyb3JIYW5kbGVyLnN5bmModGhpcyk7XHJcblx0XHRsZXQgZGVjaXNpb246IG51bWJlciA9IHAuZGVjaXNpb247XHJcblx0XHRpZiAoZGVjaXNpb24gPT09IHRoaXMub3ZlcnJpZGVEZWNpc2lvbiAmJiB0aGlzLl9pbnB1dC5pbmRleCA9PT0gdGhpcy5vdmVycmlkZURlY2lzaW9uSW5wdXRJbmRleCAmJiAhdGhpcy5vdmVycmlkZURlY2lzaW9uUmVhY2hlZCkge1xyXG5cdFx0XHRwcmVkaWN0ZWRBbHQgPSB0aGlzLm92ZXJyaWRlRGVjaXNpb25BbHQ7XHJcblx0XHRcdHRoaXMub3ZlcnJpZGVEZWNpc2lvblJlYWNoZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHByZWRpY3RlZEFsdCA9IHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCBkZWNpc2lvbiwgdGhpcy5fY3R4KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwcmVkaWN0ZWRBbHQ7XHJcblx0fVxyXG5cclxuXHQvKiogUHJvdmlkZSBzaW1wbGUgXCJmYWN0b3J5XCIgZm9yIEludGVycHJldGVyUnVsZUNvbnRleHQncy5cclxuXHQgKiAgQHNpbmNlIDQuNS4xXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGNyZWF0ZUludGVycHJldGVyUnVsZUNvbnRleHQoXHJcblx0XHRwYXJlbnQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLFxyXG5cdFx0aW52b2tpbmdTdGF0ZU51bWJlcjogbnVtYmVyLFxyXG5cdFx0cnVsZUluZGV4OiBudW1iZXIpOiBJbnRlcnByZXRlclJ1bGVDb250ZXh0IHtcclxuXHRcdHJldHVybiBuZXcgSW50ZXJwcmV0ZXJSdWxlQ29udGV4dChydWxlSW5kZXgsIHBhcmVudCwgaW52b2tpbmdTdGF0ZU51bWJlcik7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgdmlzaXRSdWxlU3RvcFN0YXRlKHA6IEFUTlN0YXRlKTogdm9pZCB7XHJcblx0XHRsZXQgcnVsZVN0YXJ0U3RhdGU6IFJ1bGVTdGFydFN0YXRlID0gdGhpcy5fYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbcC5ydWxlSW5kZXhdO1xyXG5cdFx0aWYgKHJ1bGVTdGFydFN0YXRlLmlzUHJlY2VkZW5jZVJ1bGUpIHtcclxuXHRcdFx0bGV0IHBhcmVudENvbnRleHQ6IFtQYXJzZXJSdWxlQ29udGV4dCwgbnVtYmVyXSA9IHRoaXMuX3BhcmVudENvbnRleHRTdGFjay5wb3AoKSE7XHJcblx0XHRcdHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMocGFyZW50Q29udGV4dFswXSk7XHJcblx0XHRcdHRoaXMuc3RhdGUgPSBwYXJlbnRDb250ZXh0WzFdO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuZXhpdFJ1bGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcnVsZVRyYW5zaXRpb246IFJ1bGVUcmFuc2l0aW9uID0gdGhpcy5fYXRuLnN0YXRlc1t0aGlzLnN0YXRlXS50cmFuc2l0aW9uKDApIGFzIFJ1bGVUcmFuc2l0aW9uO1xyXG5cdFx0dGhpcy5zdGF0ZSA9IHJ1bGVUcmFuc2l0aW9uLmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyO1xyXG5cdH1cclxuXHJcblx0LyoqIE92ZXJyaWRlIHRoaXMgcGFyc2VyIGludGVycHJldGVycyBub3JtYWwgZGVjaXNpb24tbWFraW5nIHByb2Nlc3NcclxuXHQgKiAgYXQgYSBwYXJ0aWN1bGFyIGRlY2lzaW9uIGFuZCBpbnB1dCB0b2tlbiBpbmRleC4gSW5zdGVhZCBvZlxyXG5cdCAqICBhbGxvd2luZyB0aGUgYWRhcHRpdmUgcHJlZGljdGlvbiBtZWNoYW5pc20gdG8gY2hvb3NlIHRoZVxyXG5cdCAqICBmaXJzdCBhbHRlcm5hdGl2ZSB3aXRoaW4gYSBibG9jayB0aGF0IGxlYWRzIHRvIGEgc3VjY2Vzc2Z1bCBwYXJzZSxcclxuXHQgKiAgZm9yY2UgaXQgdG8gdGFrZSB0aGUgYWx0ZXJuYXRpdmUsIDEuLm4gZm9yIG4gYWx0ZXJuYXRpdmVzLlxyXG5cdCAqXHJcblx0ICogIEFzIGFuIGltcGxlbWVudGF0aW9uIGxpbWl0YXRpb24gcmlnaHQgbm93LCB5b3UgY2FuIG9ubHkgc3BlY2lmeSBvbmVcclxuXHQgKiAgb3ZlcnJpZGUuIFRoaXMgaXMgc3VmZmljaWVudCB0byBhbGxvdyBjb25zdHJ1Y3Rpb24gb2YgZGlmZmVyZW50XHJcblx0ICogIHBhcnNlIHRyZWVzIGZvciBhbWJpZ3VvdXMgaW5wdXQuIEl0IG1lYW5zIHJlLXBhcnNpbmcgdGhlIGVudGlyZSBpbnB1dFxyXG5cdCAqICBpbiBnZW5lcmFsIGJlY2F1c2UgeW91J3JlIG5ldmVyIHN1cmUgd2hlcmUgYW4gYW1iaWd1b3VzIHNlcXVlbmNlIHdvdWxkXHJcblx0ICogIGxpdmUgaW4gdGhlIHZhcmlvdXMgcGFyc2UgdHJlZXMuIEZvciBleGFtcGxlLCBpbiBvbmUgaW50ZXJwcmV0YXRpb24sXHJcblx0ICogIGFuIGFtYmlndW91cyBpbnB1dCBzZXF1ZW5jZSB3b3VsZCBiZSBtYXRjaGVkIGNvbXBsZXRlbHkgaW4gZXhwcmVzc2lvblxyXG5cdCAqICBidXQgaW4gYW5vdGhlciBpdCBjb3VsZCBtYXRjaCBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSByb290LlxyXG5cdCAqXHJcblx0ICogIHMgOiBlICchJz8gO1xyXG5cdCAqICBlIDogSURcclxuXHQgKiAgICB8IElEICchJ1xyXG5cdCAqICAgIDtcclxuXHQgKlxyXG5cdCAqICBIZXJlLCB4ISBjYW4gYmUgbWF0Y2hlZCBhcyAocyAoZSBJRCkgISkgb3IgKHMgKGUgSUQgISkpLiBJbiB0aGUgZmlyc3RcclxuXHQgKiAgY2FzZSwgdGhlIGFtYmlndW91cyBzZXF1ZW5jZSBpcyBmdWxseSBjb250YWluZWQgb25seSBieSB0aGUgcm9vdC5cclxuXHQgKiAgSW4gdGhlIHNlY29uZCBjYXNlLCB0aGUgYW1iaWd1b3VzIHNlcXVlbmNlcyBmdWxseSBjb250YWluZWQgd2l0aGluIGp1c3RcclxuXHQgKiAgZSwgYXMgaW46IChlIElEICEpLlxyXG5cdCAqXHJcblx0ICogIFJhdGhlciB0aGFuIHRyeWluZyB0byBvcHRpbWl6ZSB0aGlzIGFuZCBtYWtlXHJcblx0ICogIHNvbWUgaW50ZWxsaWdlbnQgZGVjaXNpb25zIGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMsIEkgc2V0dGxlZCBvblxyXG5cdCAqICBqdXN0IHJlLXBhcnNpbmcgdGhlIHdob2xlIGlucHV0IGFuZCB0aGVuIHVzaW5nXHJcblx0ICogIHtsaW5rIFRyZWVzI2dldFJvb3RPZlN1YnRyZWVFbmNsb3NpbmdSZWdpb259IHRvIGZpbmQgdGhlIG1pbmltYWxcclxuXHQgKiAgc3VidHJlZSB0aGF0IGNvbnRhaW5zIHRoZSBhbWJpZ3VvdXMgc2VxdWVuY2UuIEkgb3JpZ2luYWxseSB0cmllZCB0b1xyXG5cdCAqICByZWNvcmQgdGhlIGNhbGwgc3RhY2sgYXQgdGhlIHBvaW50IHRoZSBwYXJzZXIgZGV0ZWN0ZWQgYW5kIGFtYmlndWl0eSBidXRcclxuXHQgKiAgbGVmdCByZWN1cnNpdmUgcnVsZXMgY3JlYXRlIGEgcGFyc2UgdHJlZSBzdGFjayB0aGF0IGRvZXMgbm90IHJlZmxlY3RcclxuXHQgKiAgdGhlIGFjdHVhbCBjYWxsIHN0YWNrLiBUaGF0IGltcGVkYW5jZSBtaXNtYXRjaCB3YXMgZW5vdWdoIHRvIG1ha2VcclxuXHQgKiAgaXQgaXQgY2hhbGxlbmdpbmcgdG8gcmVzdGFydCB0aGUgcGFyc2VyIGF0IGEgZGVlcGx5IG5lc3RlZCBydWxlXHJcblx0ICogIGludm9jYXRpb24uXHJcblx0ICpcclxuXHQgKiAgT25seSBwYXJzZXIgaW50ZXJwcmV0ZXJzIGNhbiBvdmVycmlkZSBkZWNpc2lvbnMgc28gYXMgdG8gYXZvaWQgaW5zZXJ0aW5nXHJcblx0ICogIG92ZXJyaWRlIGNoZWNraW5nIGNvZGUgaW4gdGhlIGNyaXRpY2FsIEFMTCgqKSBwcmVkaWN0aW9uIGV4ZWN1dGlvbiBwYXRoLlxyXG5cdCAqXHJcblx0ICogIEBzaW5jZSA0LjVcclxuXHQgKi9cclxuXHRwdWJsaWMgYWRkRGVjaXNpb25PdmVycmlkZShkZWNpc2lvbjogbnVtYmVyLCB0b2tlbkluZGV4OiBudW1iZXIsIGZvcmNlZEFsdDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLm92ZXJyaWRlRGVjaXNpb24gPSBkZWNpc2lvbjtcclxuXHRcdHRoaXMub3ZlcnJpZGVEZWNpc2lvbklucHV0SW5kZXggPSB0b2tlbkluZGV4O1xyXG5cdFx0dGhpcy5vdmVycmlkZURlY2lzaW9uQWx0ID0gZm9yY2VkQWx0O1xyXG5cdH1cclxuXHJcblx0Z2V0IG92ZXJyaWRlRGVjaXNpb25Sb290KCk6IEludGVycHJldGVyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX292ZXJyaWRlRGVjaXNpb25Sb290O1xyXG5cdH1cclxuXHJcblx0LyoqIFJlbHkgb24gdGhlIGVycm9yIGhhbmRsZXIgZm9yIHRoaXMgcGFyc2VyIGJ1dCwgaWYgbm8gdG9rZW5zIGFyZSBjb25zdW1lZFxyXG5cdCAqICB0byByZWNvdmVyLCBhZGQgYW4gZXJyb3Igbm9kZS4gT3RoZXJ3aXNlLCBub3RoaW5nIGlzIHNlZW4gaW4gdGhlIHBhcnNlXHJcblx0ICogIHRyZWUuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHJlY292ZXIoZTogUmVjb2duaXRpb25FeGNlcHRpb24pOiB2b2lkIHtcclxuXHRcdGxldCBpOiBudW1iZXIgPSB0aGlzLl9pbnB1dC5pbmRleDtcclxuXHRcdHRoaXMuZXJyb3JIYW5kbGVyLnJlY292ZXIodGhpcywgZSk7XHJcblx0XHRpZiAodGhpcy5faW5wdXQuaW5kZXggPT09IGkpIHtcclxuXHRcdFx0Ly8gbm8gaW5wdXQgY29uc3VtZWQsIGJldHRlciBhZGQgYW4gZXJyb3Igbm9kZVxyXG5cdFx0XHRsZXQgdG9rOiBUb2tlbiB8IHVuZGVmaW5lZCA9IGUuZ2V0T2ZmZW5kaW5nVG9rZW4oKTtcclxuXHRcdFx0aWYgKCF0b2spIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBleGNlcHRpb24gdG8gaGF2ZSBhbiBvZmZlbmRpbmcgdG9rZW5cIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBzb3VyY2UgPSB0b2sudG9rZW5Tb3VyY2U7XHJcblx0XHRcdGxldCBzdHJlYW0gPSBzb3VyY2UgIT09IHVuZGVmaW5lZCA/IHNvdXJjZS5pbnB1dFN0cmVhbSA6IHVuZGVmaW5lZDtcclxuXHRcdFx0bGV0IHNvdXJjZVBhaXIgPSB7IHNvdXJjZSwgc3RyZWFtIH07XHJcblxyXG5cdFx0XHRpZiAoZSBpbnN0YW5jZW9mIElucHV0TWlzbWF0Y2hFeGNlcHRpb24pIHtcclxuXHRcdFx0XHRsZXQgZXhwZWN0ZWRUb2tlbnMgPSBlLmV4cGVjdGVkVG9rZW5zO1xyXG5cdFx0XHRcdGlmIChleHBlY3RlZFRva2VucyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB0aGUgZXhjZXB0aW9uIHRvIHByb3ZpZGUgZXhwZWN0ZWQgdG9rZW5zXCIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IGV4cGVjdGVkVG9rZW5UeXBlOiBudW1iZXIgPSBUb2tlbi5JTlZBTElEX1RZUEU7XHJcblx0XHRcdFx0aWYgKCFleHBlY3RlZFRva2Vucy5pc05pbCkge1xyXG5cdFx0XHRcdFx0Ly8gZ2V0IGFueSBlbGVtZW50XHJcblx0XHRcdFx0XHRleHBlY3RlZFRva2VuVHlwZSA9IGV4cGVjdGVkVG9rZW5zLm1pbkVsZW1lbnQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgZXJyVG9rZW46IFRva2VuID1cclxuXHRcdFx0XHRcdHRoaXMudG9rZW5GYWN0b3J5LmNyZWF0ZShzb3VyY2VQYWlyLFxyXG5cdFx0XHRcdFx0XHRleHBlY3RlZFRva2VuVHlwZSwgdG9rLnRleHQsXHJcblx0XHRcdFx0XHRcdFRva2VuLkRFRkFVTFRfQ0hBTk5FTCxcclxuXHRcdFx0XHRcdFx0LTEsIC0xLCAvLyBpbnZhbGlkIHN0YXJ0L3N0b3BcclxuXHRcdFx0XHRcdFx0dG9rLmxpbmUsIHRvay5jaGFyUG9zaXRpb25JbkxpbmUpO1xyXG5cdFx0XHRcdHRoaXMuX2N0eC5hZGRFcnJvck5vZGUodGhpcy5jcmVhdGVFcnJvck5vZGUodGhpcy5fY3R4LCBlcnJUb2tlbikpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgeyAvLyBOb1ZpYWJsZUFsdFxyXG5cdFx0XHRcdGxldCBzb3VyY2UgPSB0b2sudG9rZW5Tb3VyY2U7XHJcblx0XHRcdFx0bGV0IGVyclRva2VuOiBUb2tlbiA9XHJcblx0XHRcdFx0XHR0aGlzLnRva2VuRmFjdG9yeS5jcmVhdGUoc291cmNlUGFpcixcclxuXHRcdFx0XHRcdFx0VG9rZW4uSU5WQUxJRF9UWVBFLCB0b2sudGV4dCxcclxuXHRcdFx0XHRcdFx0VG9rZW4uREVGQVVMVF9DSEFOTkVMLFxyXG5cdFx0XHRcdFx0XHQtMSwgLTEsIC8vIGludmFsaWQgc3RhcnQvc3RvcFxyXG5cdFx0XHRcdFx0XHR0b2subGluZSwgdG9rLmNoYXJQb3NpdGlvbkluTGluZSk7XHJcblx0XHRcdFx0dGhpcy5fY3R4LmFkZEVycm9yTm9kZSh0aGlzLmNyZWF0ZUVycm9yTm9kZSh0aGlzLl9jdHgsIGVyclRva2VuKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCByZWNvdmVySW5saW5lKCk6IFRva2VuIHtcclxuXHRcdHJldHVybiB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIHRoZSByb290IG9mIHRoZSBwYXJzZSwgd2hpY2ggY2FuIGJlIHVzZWZ1bCBpZiB0aGUgcGFyc2VyXHJcblx0ICogIGJhaWxzIG91dC4gWW91IHN0aWxsIGNhbiBhY2Nlc3MgdGhlIHRvcCBub2RlLiBOb3RlIHRoYXQsXHJcblx0ICogIGJlY2F1c2Ugb2YgdGhlIHdheSBsZWZ0IHJlY3Vyc2l2ZSBydWxlcyBhZGQgY2hpbGRyZW4sIGl0J3MgcG9zc2libGVcclxuXHQgKiAgdGhhdCB0aGUgcm9vdCB3aWxsIG5vdCBoYXZlIGFueSBjaGlsZHJlbiBpZiB0aGUgc3RhcnQgcnVsZSBpbW1lZGlhdGVseVxyXG5cdCAqICBjYWxsZWQgYW5kIGxlZnQgcmVjdXJzaXZlIHJ1bGUgdGhhdCBmYWlscy5cclxuXHQgKlxyXG5cdCAqIEBzaW5jZSA0LjUuMVxyXG5cdCAqL1xyXG5cdGdldCByb290Q29udGV4dCgpOiBJbnRlcnByZXRlclJ1bGVDb250ZXh0IHtcclxuXHRcdHJldHVybiB0aGlzLl9yb290Q29udGV4dDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ09OVkVSU1RJT04gY29tcGxldGUsIEJ1cnQgSGFycmlzIDEwLzE0LzIwMTZcclxuaW1wb3J0IHsgTXVsdGlNYXAgfSBmcm9tIFwiLi4vLi4vbWlzYy9NdWx0aU1hcFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuLi9QYXJzZVRyZWVcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlUGF0dGVybiB9IGZyb20gXCIuL1BhcnNlVHJlZVBhdHRlcm5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSByZXN1bHQgb2YgbWF0Y2hpbmcgYSB7QGxpbmsgUGFyc2VUcmVlfSBhZ2FpbnN0IGEgdHJlZSBwYXR0ZXJuLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBhcnNlVHJlZU1hdGNoIHtcclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgdHJlZWAuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfdHJlZTogUGFyc2VUcmVlO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgcGF0dGVybmAuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfcGF0dGVybjogUGFyc2VUcmVlUGF0dGVybjtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3IgYGxhYmVsc2AuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfbGFiZWxzOiBNdWx0aU1hcDxzdHJpbmcsIFBhcnNlVHJlZT47XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBtaXNtYXRjaGVkTm9kZWAuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfbWlzbWF0Y2hlZE5vZGU/OiBQYXJzZVRyZWU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFBhcnNlVHJlZU1hdGNofSBmcm9tIHRoZSBzcGVjaWZpZWRcclxuXHQgKiBwYXJzZSB0cmVlIGFuZCBwYXR0ZXJuLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHRyZWUgVGhlIHBhcnNlIHRyZWUgdG8gbWF0Y2ggYWdhaW5zdCB0aGUgcGF0dGVybi5cclxuXHQgKiBAcGFyYW0gcGF0dGVybiBUaGUgcGFyc2UgdHJlZSBwYXR0ZXJuLlxyXG5cdCAqIEBwYXJhbSBsYWJlbHMgQSBtYXBwaW5nIGZyb20gbGFiZWwgbmFtZXMgdG8gY29sbGVjdGlvbnMgb2ZcclxuXHQgKiB7QGxpbmsgUGFyc2VUcmVlfSBvYmplY3RzIGxvY2F0ZWQgYnkgdGhlIHRyZWUgcGF0dGVybiBtYXRjaGluZyBwcm9jZXNzLlxyXG5cdCAqIEBwYXJhbSBtaXNtYXRjaGVkTm9kZSBUaGUgZmlyc3Qgbm9kZSB3aGljaCBmYWlsZWQgdG8gbWF0Y2ggdGhlIHRyZWVcclxuXHQgKiBwYXR0ZXJuIGR1cmluZyB0aGUgbWF0Y2hpbmcgcHJvY2Vzcy5cclxuXHQgKlxyXG5cdCAqIEB0aHJvd3Mge0BsaW5rIEVycm9yfSBpZiBgdHJlZWAgaXMgbm90IGRlZmluZWRcclxuXHQgKiBAdGhyb3dzIHtAbGluayBFcnJvcn0gaWYgYHBhdHRlcm5gIGlzIG5vdCBkZWZpbmVkXHJcblx0ICogQHRocm93cyB7QGxpbmsgRXJyb3J9IGlmIGBsYWJlbHNgIGlzIG5vdCBkZWZpbmVkXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRATm90TnVsbCB0cmVlOiBQYXJzZVRyZWUsXHJcblx0XHRATm90TnVsbCBwYXR0ZXJuOiBQYXJzZVRyZWVQYXR0ZXJuLFxyXG5cdFx0QE5vdE51bGwgbGFiZWxzOiBNdWx0aU1hcDxzdHJpbmcsIFBhcnNlVHJlZT4sXHJcblx0XHRtaXNtYXRjaGVkTm9kZTogUGFyc2VUcmVlIHwgdW5kZWZpbmVkKSB7XHJcblx0XHRpZiAoIXRyZWUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidHJlZSBjYW5ub3QgYmUgbnVsbFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXBhdHRlcm4pIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwicGF0dGVybiBjYW5ub3QgYmUgbnVsbFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxhYmVscykge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJsYWJlbHMgY2Fubm90IGJlIG51bGxcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdHJlZSA9IHRyZWU7XHJcblx0XHR0aGlzLl9wYXR0ZXJuID0gcGF0dGVybjtcclxuXHRcdHRoaXMuX2xhYmVscyA9IGxhYmVscztcclxuXHRcdHRoaXMuX21pc21hdGNoZWROb2RlID0gbWlzbWF0Y2hlZE5vZGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGxhc3Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggYSBzcGVjaWZpYyBgbGFiZWxgLlxyXG5cdCAqXHJcblx0ICogRm9yIGV4YW1wbGUsIGZvciBwYXR0ZXJuIGA8aWQ6SUQ+YCwgYGdldChcImlkXCIpYCByZXR1cm5zIHRoZVxyXG5cdCAqIG5vZGUgbWF0Y2hlZCBmb3IgdGhhdCBgSURgLiBJZiBtb3JlIHRoYW4gb25lIG5vZGVcclxuXHQgKiBtYXRjaGVkIHRoZSBzcGVjaWZpZWQgbGFiZWwsIG9ubHkgdGhlIGxhc3QgaXMgcmV0dXJuZWQuIElmIHRoZXJlIGlzXHJcblx0ICogbm8gbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhlIGxhYmVsLCB0aGlzIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcblx0ICpcclxuXHQgKiBQYXR0ZXJuIHRhZ3MgbGlrZSBgPElEPmAgYW5kIGA8ZXhwcj5gIHdpdGhvdXQgbGFiZWxzIGFyZVxyXG5cdCAqIGNvbnNpZGVyZWQgdG8gYmUgbGFiZWxlZCB3aXRoIGBJRGAgYW5kIGBleHByYCwgcmVzcGVjdGl2ZWx5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCB0byBjaGVjay5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBsYXN0IHtAbGluayBQYXJzZVRyZWV9IHRvIG1hdGNoIGEgdGFnIHdpdGggdGhlIHNwZWNpZmllZFxyXG5cdCAqIGxhYmVsLCBvciBgdW5kZWZpbmVkYCBpZiBubyBwYXJzZSB0cmVlIG1hdGNoZWQgYSB0YWcgd2l0aCB0aGUgbGFiZWwuXHJcblx0ICovXHJcblx0cHVibGljIGdldChsYWJlbDogc3RyaW5nKTogUGFyc2VUcmVlIHwgdW5kZWZpbmVkIHtcclxuXHRcdGxldCBwYXJzZVRyZWVzID0gdGhpcy5fbGFiZWxzLmdldChsYWJlbCk7XHJcblx0XHRpZiAoIXBhcnNlVHJlZXMgfHwgcGFyc2VUcmVlcy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFyc2VUcmVlc1twYXJzZVRyZWVzLmxlbmd0aCAtIDFdOyAvLyByZXR1cm4gbGFzdCBpZiBtdWx0aXBsZVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIGFsbCBub2RlcyBtYXRjaGluZyBhIHJ1bGUgb3IgdG9rZW4gdGFnIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSBgbGFiZWxgIGlzIHRoZSBuYW1lIG9mIGEgcGFyc2VyIHJ1bGUgb3IgdG9rZW4gaW4gdGhlXHJcblx0ICogZ3JhbW1hciwgdGhlIHJlc3VsdGluZyBsaXN0IHdpbGwgY29udGFpbiBib3RoIHRoZSBwYXJzZSB0cmVlcyBtYXRjaGluZ1xyXG5cdCAqIHJ1bGUgb3IgdGFncyBleHBsaWNpdGx5IGxhYmVsZWQgd2l0aCB0aGUgbGFiZWwgYW5kIHRoZSBjb21wbGV0ZSBzZXQgb2ZcclxuXHQgKiBwYXJzZSB0cmVlcyBtYXRjaGluZyB0aGUgbGFiZWxlZCBhbmQgdW5sYWJlbGVkIHRhZ3MgaW4gdGhlIHBhdHRlcm4gZm9yXHJcblx0ICogdGhlIHBhcnNlciBydWxlIG9yIHRva2VuLiBGb3IgZXhhbXBsZSwgaWYgYGxhYmVsYCBpcyBgXCJmb29cImAsXHJcblx0ICogdGhlIHJlc3VsdCB3aWxsIGNvbnRhaW4gKmFsbCogb2YgdGhlIGZvbGxvd2luZy5cclxuXHQgKlxyXG5cdCAqICogUGFyc2UgdHJlZSBub2RlcyBtYXRjaGluZyB0YWdzIG9mIHRoZSBmb3JtIGA8Zm9vOmFueVJ1bGVOYW1lPmAgYW5kXHJcblx0ICogICBgPGZvbzpBbnlUb2tlbk5hbWU+YC5cclxuXHQgKiAqIFBhcnNlIHRyZWUgbm9kZXMgbWF0Y2hpbmcgdGFncyBvZiB0aGUgZm9ybSBgPGFueUxhYmVsOmZvbz5gLlxyXG5cdCAqICogUGFyc2UgdHJlZSBub2RlcyBtYXRjaGluZyB0YWdzIG9mIHRoZSBmb3JtIGA8Zm9vPmAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgQSBjb2xsZWN0aW9uIG9mIGFsbCB7QGxpbmsgUGFyc2VUcmVlfSBub2RlcyBtYXRjaGluZyB0YWdzIHdpdGhcclxuXHQgKiB0aGUgc3BlY2lmaWVkIGBsYWJlbGAuIElmIG5vIG5vZGVzIG1hdGNoZWQgdGhlIGxhYmVsLCBhbiBlbXB0eSBsaXN0XHJcblx0ICogaXMgcmV0dXJuZWQuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0QWxsKEBOb3ROdWxsIGxhYmVsOiBzdHJpbmcpOiBQYXJzZVRyZWVbXSB7XHJcblx0XHRjb25zdCBub2RlcyA9IHRoaXMuX2xhYmVscy5nZXQobGFiZWwpO1xyXG5cdFx0aWYgKCFub2Rlcykge1xyXG5cdFx0XHRyZXR1cm4gW107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbm9kZXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gYSBtYXBwaW5nIGZyb20gbGFiZWwgJnJhcnI7IFtsaXN0IG9mIG5vZGVzXS5cclxuXHQgKlxyXG5cdCAqIFRoZSBtYXAgaW5jbHVkZXMgc3BlY2lhbCBlbnRyaWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG5hbWVzIG9mIHJ1bGVzIGFuZFxyXG5cdCAqIHRva2VucyByZWZlcmVuY2VkIGluIHRhZ3MgaW4gdGhlIG9yaWdpbmFsIHBhdHRlcm4uIEZvciBhZGRpdGlvbmFsXHJcblx0ICogaW5mb3JtYXRpb24sIHNlZSB0aGUgZGVzY3JpcHRpb24gb2Yge0BsaW5rICNnZXRBbGwoU3RyaW5nKX0uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBBIG1hcHBpbmcgZnJvbSBsYWJlbHMgdG8gcGFyc2UgdHJlZSBub2Rlcy4gSWYgdGhlIHBhcnNlIHRyZWVcclxuXHQgKiBwYXR0ZXJuIGRpZCBub3QgY29udGFpbiBhbnkgcnVsZSBvciB0b2tlbiB0YWdzLCB0aGlzIG1hcCB3aWxsIGJlIGVtcHR5LlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGxhYmVscygpOiBNdWx0aU1hcDxzdHJpbmcsIFBhcnNlVHJlZT4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhYmVscztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbm9kZSBhdCB3aGljaCB3ZSBmaXJzdCBkZXRlY3RlZCBhIG1pc21hdGNoLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgdGhlIG5vZGUgYXQgd2hpY2ggd2UgZmlyc3QgZGV0ZWN0ZWQgYSBtaXNtYXRjaCwgb3IgYHVuZGVmaW5lZGBcclxuXHQgKiBpZiB0aGUgbWF0Y2ggd2FzIHN1Y2Nlc3NmdWwuXHJcblx0ICovXHJcblx0Z2V0IG1pc21hdGNoZWROb2RlKCk6IFBhcnNlVHJlZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbWlzbWF0Y2hlZE5vZGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBtYXRjaCBvcGVyYXRpb24gc3VjY2VlZGVkLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtYXRjaCBvcGVyYXRpb24gc3VjY2VlZGVkOyBvdGhlcndpc2UsXHJcblx0ICogYGZhbHNlYC5cclxuXHQgKi9cclxuXHRnZXQgc3VjY2VlZGVkKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuICF0aGlzLl9taXNtYXRjaGVkTm9kZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdHJlZSBwYXR0ZXJuIHdlIGFyZSBtYXRjaGluZyBhZ2FpbnN0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIHRyZWUgcGF0dGVybiB3ZSBhcmUgbWF0Y2hpbmcgYWdhaW5zdC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBwYXR0ZXJuKCk6IFBhcnNlVHJlZVBhdHRlcm4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhdHRlcm47XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHBhcnNlIHRyZWUgd2UgYXJlIHRyeWluZyB0byBtYXRjaCB0byBhIHBhdHRlcm4uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUge0BsaW5rIFBhcnNlVHJlZX0gd2UgYXJlIHRyeWluZyB0byBtYXRjaCB0byBhIHBhdHRlcm4uXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRnZXQgdHJlZSgpOiBQYXJzZVRyZWUge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3RyZWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gYE1hdGNoICR7XHJcblx0XHRcdHRoaXMuc3VjY2VlZGVkID8gXCJzdWNjZWVkZWRcIiA6IFwiZmFpbGVkXCJ9OyBmb3VuZCAke1xyXG5cdFx0XHR0aGlzLmxhYmVscy5zaXplfSBsYWJlbHNgO1xyXG5cdH1cclxufVxyXG4iLCAiLy8gR2VuZXJhdGVkIGZyb20gWFBhdGhMZXhlci5nNCBieSBBTlRMUiA0LjkuMC1TTkFQU0hPVFxyXG5cclxuXHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuLi8uLi9hdG4vQVROXCI7XHJcbmltcG9ydCB7IEFUTkRlc2VyaWFsaXplciB9IGZyb20gXCIuLi8uLi9hdG4vQVRORGVzZXJpYWxpemVyXCI7XHJcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiLi4vLi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi8uLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMZXhlckFUTlNpbXVsYXRvciB9IGZyb20gXCIuLi8uLi9hdG4vTGV4ZXJBVE5TaW11bGF0b3JcIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uLy4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vLi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgVm9jYWJ1bGFyeSB9IGZyb20gXCIuLi8uLi9Wb2NhYnVsYXJ5XCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnlJbXBsIH0gZnJvbSBcIi4uLy4uL1ZvY2FidWxhcnlJbXBsXCI7XHJcblxyXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiLi4vLi4vbWlzYy9VdGlsc1wiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBYUGF0aExleGVyIGV4dGVuZHMgTGV4ZXIge1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVE9LRU5fUkVGID0gMTtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJVTEVfUkVGID0gMjtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFOWVdIRVJFID0gMztcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJPT1QgPSA0O1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgV0lMRENBUkQgPSA1O1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQkFORyA9IDY7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBJRCA9IDc7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBTVFJJTkcgPSA4O1xyXG5cclxuXHQvLyB0c2xpbnQ6ZGlzYWJsZTpuby10cmFpbGluZy13aGl0ZXNwYWNlXHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBjaGFubmVsTmFtZXM6IHN0cmluZ1tdID0gW1xyXG5cdFx0XCJERUZBVUxUX1RPS0VOX0NIQU5ORUxcIiwgXCJISURERU5cIixcclxuXHRdO1xyXG5cclxuXHQvLyB0c2xpbnQ6ZGlzYWJsZTpuby10cmFpbGluZy13aGl0ZXNwYWNlXHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBtb2RlTmFtZXM6IHN0cmluZ1tdID0gW1xyXG5cdFx0XCJERUZBVUxUX01PREVcIixcclxuXHRdO1xyXG5cclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHJ1bGVOYW1lczogc3RyaW5nW10gPSBbXHJcblx0XHRcIkFOWVdIRVJFXCIsIFwiUk9PVFwiLCBcIldJTERDQVJEXCIsIFwiQkFOR1wiLCBcIklEXCIsIFwiTmFtZUNoYXJcIiwgXCJOYW1lU3RhcnRDaGFyXCIsIFxyXG5cdFx0XCJTVFJJTkdcIixcclxuXHRdO1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBfTElURVJBTF9OQU1FUzogQXJyYXk8c3RyaW5nIHwgdW5kZWZpbmVkPiA9IFtcclxuXHRcdHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiJy8vJ1wiLCBcIicvJ1wiLCBcIicqJ1wiLCBcIichJ1wiLFxyXG5cdF07XHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgX1NZTUJPTElDX05BTUVTOiBBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0gW1xyXG5cdFx0dW5kZWZpbmVkLCBcIlRPS0VOX1JFRlwiLCBcIlJVTEVfUkVGXCIsIFwiQU5ZV0hFUkVcIiwgXCJST09UXCIsIFwiV0lMRENBUkRcIiwgXCJCQU5HXCIsIFxyXG5cdFx0XCJJRFwiLCBcIlNUUklOR1wiLFxyXG5cdF07XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBWT0NBQlVMQVJZOiBWb2NhYnVsYXJ5ID0gbmV3IFZvY2FidWxhcnlJbXBsKFhQYXRoTGV4ZXIuX0xJVEVSQUxfTkFNRVMsIFhQYXRoTGV4ZXIuX1NZTUJPTElDX05BTUVTLCBbXSk7XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdC8vIEBOb3ROdWxsXHJcblx0cHVibGljIGdldCB2b2NhYnVsYXJ5KCk6IFZvY2FidWxhcnkge1xyXG5cdFx0cmV0dXJuIFhQYXRoTGV4ZXIuVk9DQUJVTEFSWTtcclxuXHR9XHJcblx0Ly8gdHNsaW50OmVuYWJsZTpuby10cmFpbGluZy13aGl0ZXNwYWNlXHJcblxyXG5cclxuXHRjb25zdHJ1Y3RvcihpbnB1dDogQ2hhclN0cmVhbSkge1xyXG5cdFx0c3VwZXIoaW5wdXQpO1xyXG5cdFx0dGhpcy5faW50ZXJwID0gbmV3IExleGVyQVROU2ltdWxhdG9yKFhQYXRoTGV4ZXIuX0FUTiwgdGhpcyk7XHJcblx0fVxyXG5cclxuXHQvLyBAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0IGdyYW1tYXJGaWxlTmFtZSgpOiBzdHJpbmcgeyByZXR1cm4gXCJYUGF0aExleGVyLmc0XCI7IH1cclxuXHJcblx0Ly8gQE92ZXJyaWRlXHJcblx0cHVibGljIGdldCBydWxlTmFtZXMoKTogc3RyaW5nW10geyByZXR1cm4gWFBhdGhMZXhlci5ydWxlTmFtZXM7IH1cclxuXHJcblx0Ly8gQE92ZXJyaWRlXHJcblx0cHVibGljIGdldCBzZXJpYWxpemVkQVROKCk6IHN0cmluZyB7IHJldHVybiBYUGF0aExleGVyLl9zZXJpYWxpemVkQVROOyB9XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXQgY2hhbm5lbE5hbWVzKCk6IHN0cmluZ1tdIHsgcmV0dXJuIFhQYXRoTGV4ZXIuY2hhbm5lbE5hbWVzOyB9XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXQgbW9kZU5hbWVzKCk6IHN0cmluZ1tdIHsgcmV0dXJuIFhQYXRoTGV4ZXIubW9kZU5hbWVzOyB9XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHB1YmxpYyBhY3Rpb24oX2xvY2FsY3R4OiBSdWxlQ29udGV4dCwgcnVsZUluZGV4OiBudW1iZXIsIGFjdGlvbkluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHN3aXRjaCAocnVsZUluZGV4KSB7XHJcblx0XHRjYXNlIDQ6XHJcblx0XHRcdHRoaXMuSURfYWN0aW9uKF9sb2NhbGN0eCwgYWN0aW9uSW5kZXgpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHR9XHJcblx0cHJpdmF0ZSBJRF9hY3Rpb24oX2xvY2FsY3R4OiBSdWxlQ29udGV4dCwgYWN0aW9uSW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0c3dpdGNoIChhY3Rpb25JbmRleCkge1xyXG5cdFx0Y2FzZSAwOlxyXG5cclxuXHRcdFx0bGV0IHRleHQgPSB0aGlzLnRleHQ7XHJcblx0XHRcdGlmICh0ZXh0LmNoYXJBdCgwKSA9PT0gdGV4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSkge1xyXG5cdFx0XHRcdHRoaXMudHlwZSA9IFhQYXRoTGV4ZXIuVE9LRU5fUkVGO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMudHlwZSA9IFhQYXRoTGV4ZXIuUlVMRV9SRUY7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgX3NlcmlhbGl6ZWRBVE5TZWdtZW50czogbnVtYmVyID0gMjtcclxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBfc2VyaWFsaXplZEFUTlNlZ21lbnQwOiBzdHJpbmcgPVxyXG5cdFx0XCJcXHgwM1xcdUM5MURcXHVDQUJBXFx1MDU4RFxcdUFGQkFcXHU0RjUzXFx1MDYwN1xcdUVBOEJcXHVDMjQxXFx4MDJcXG4yXFxiXFx4MDFcXHgwNFwiICtcclxuXHRcdFwiXFx4MDJcXHRcXHgwMlxceDA0XFx4MDNcXHRcXHgwM1xceDA0XFx4MDRcXHRcXHgwNFxceDA0XFx4MDVcXHRcXHgwNVxceDA0XFx4MDZcXHRcXHgwNlxceDA0XCIgK1xyXG5cdFx0XCJcXHgwN1xcdFxceDA3XFx4MDRcXGJcXHRcXGJcXHgwNFxcdFxcdFxcdFxceDAzXFx4MDJcXHgwM1xceDAyXFx4MDNcXHgwMlxceDAzXFx4MDNcXHgwM1xceDAzXCIgK1xyXG5cdFx0XCJcXHgwM1xceDA0XFx4MDNcXHgwNFxceDAzXFx4MDVcXHgwM1xceDA1XFx4MDNcXHgwNlxceDAzXFx4MDZcXHgwN1xceDA2XFx4MUZcXG5cXHgwNlxcZlxceDA2XCIgK1xyXG5cdFx0XCJcXHgwRVxceDA2XFxcIlxcdlxceDA2XFx4MDNcXHgwNlxceDAzXFx4MDZcXHgwM1xceDA3XFx4MDNcXHgwN1xceDAzXFxiXFx4MDNcXGJcXHgwM1xcdFxceDAzXCIgK1xyXG5cdFx0XCJcXHRcXHgwN1xcdCxcXG5cXHRcXGZcXHRcXHgwRVxcdC9cXHZcXHRcXHgwM1xcdFxceDAzXFx0XFx4MDMtXFx4MDJcXHgwMlxcblxceDAzXFx4MDJcXHgwNVxceDA1XCIgK1xyXG5cdFx0XCJcXHgwMlxceDA2XFx4MDdcXHgwMlxceDA3XFx0XFx4MDJcXGJcXHZcXHgwMlxcdFxcclxceDAyXFx4MDJcXHgwRlxceDAyXFx4MDJcXHgxMVxceDAyXFxuXFx4MDNcIiArXHJcblx0XHRcIlxceDAyXFx4MDJcXHgwNFxcdTAyQjZcXHgwMlxceDAyXFx4MDJcXG5cXHgwMlxceDEwXFx4MDJcXHgxRFxceDAyMlxceDAyO1xceDAyQ1xceDAyXFxcXFwiICtcclxuXHRcdFwiXFx4MDJhXFx4MDJhXFx4MDJjXFx4MDJ8XFx4MDJcXHg4MVxceDAyXFx4QTFcXHgwMlxceEFDXFx4MDJcXHhBQ1xceDAyXFx4QUZcXHgwMlxceEFGXFx4MDJcIiArXHJcblx0XHRcIlxceEI3XFx4MDJcXHhCN1xceDAyXFx4QkNcXHgwMlxceEJDXFx4MDJcXHhDMlxceDAyXFx4RDhcXHgwMlxceERBXFx4MDJcXHhGOFxceDAyXFx4RkFcXHgwMlwiICtcclxuXHRcdFwiXFx1MDJDM1xceDAyXFx1MDJDOFxceDAyXFx1MDJEM1xceDAyXFx1MDJFMlxceDAyXFx1MDJFNlxceDAyXFx1MDJFRVxceDAyXFx1MDJFRVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwMkYwXFx4MDJcXHUwMkYwXFx4MDJcXHUwMzAyXFx4MDJcXHUwMzc2XFx4MDJcXHUwMzc4XFx4MDJcXHUwMzc5XFx4MDJcXHUwMzdDXFx4MDJcIiArXHJcblx0XHRcIlxcdTAzN0ZcXHgwMlxcdTAzODFcXHgwMlxcdTAzODFcXHgwMlxcdTAzODhcXHgwMlxcdTAzODhcXHgwMlxcdTAzOEFcXHgwMlxcdTAzOENcXHgwMlwiICtcclxuXHRcdFwiXFx1MDM4RVxceDAyXFx1MDM4RVxceDAyXFx1MDM5MFxceDAyXFx1MDNBM1xceDAyXFx1MDNBNVxceDAyXFx1MDNGN1xceDAyXFx1MDNGOVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwNDgzXFx4MDJcXHUwNDg1XFx4MDJcXHUwNDg5XFx4MDJcXHUwNDhDXFx4MDJcXHUwNTMxXFx4MDJcXHUwNTMzXFx4MDJcXHUwNTU4XFx4MDJcIiArXHJcblx0XHRcIlxcdTA1NUJcXHgwMlxcdTA1NUJcXHgwMlxcdTA1NjNcXHgwMlxcdTA1ODlcXHgwMlxcdTA1OTNcXHgwMlxcdTA1QkZcXHgwMlxcdTA1QzFcXHgwMlwiICtcclxuXHRcdFwiXFx1MDVDMVxceDAyXFx1MDVDM1xceDAyXFx1MDVDNFxceDAyXFx1MDVDNlxceDAyXFx1MDVDN1xceDAyXFx1MDVDOVxceDAyXFx1MDVDOVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwNUQyXFx4MDJcXHUwNUVDXFx4MDJcXHUwNUYyXFx4MDJcXHUwNUY0XFx4MDJcXHUwNjAyXFx4MDJcXHUwNjA3XFx4MDJcXHUwNjEyXFx4MDJcIiArXHJcblx0XHRcIlxcdTA2MUNcXHgwMlxcdTA2MUVcXHgwMlxcdTA2MUVcXHgwMlxcdTA2MjJcXHgwMlxcdTA2NkJcXHgwMlxcdTA2NzBcXHgwMlxcdTA2RDVcXHgwMlwiICtcclxuXHRcdFwiXFx1MDZEN1xceDAyXFx1MDZERlxceDAyXFx1MDZFMVxceDAyXFx1MDZFQVxceDAyXFx1MDZFQ1xceDAyXFx1MDZGRVxceDAyXFx1MDcwMVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwNzAxXFx4MDJcXHUwNzExXFx4MDJcXHUwNzRDXFx4MDJcXHUwNzRGXFx4MDJcXHUwN0IzXFx4MDJcXHUwN0MyXFx4MDJcXHUwN0Y3XFx4MDJcIiArXHJcblx0XHRcIlxcdTA3RkNcXHgwMlxcdTA3RkNcXHgwMlxcdTA4MDJcXHgwMlxcdTA4MkZcXHgwMlxcdTA4NDJcXHgwMlxcdTA4NURcXHgwMlxcdTA4QTJcXHgwMlwiICtcclxuXHRcdFwiXFx1MDhCNlxceDAyXFx1MDhCOFxceDAyXFx1MDhCRlxceDAyXFx1MDhENlxceDAyXFx1MDk2NVxceDAyXFx1MDk2OFxceDAyXFx1MDk3MVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwOTczXFx4MDJcXHUwOTg1XFx4MDJcXHUwOTg3XFx4MDJcXHUwOThFXFx4MDJcXHUwOTkxXFx4MDJcXHUwOTkyXFx4MDJcXHUwOTk1XFx4MDJcIiArXHJcblx0XHRcIlxcdTA5QUFcXHgwMlxcdTA5QUNcXHgwMlxcdTA5QjJcXHgwMlxcdTA5QjRcXHgwMlxcdTA5QjRcXHgwMlxcdTA5QjhcXHgwMlxcdTA5QkJcXHgwMlwiICtcclxuXHRcdFwiXFx1MDlCRVxceDAyXFx1MDlDNlxceDAyXFx1MDlDOVxceDAyXFx1MDlDQVxceDAyXFx1MDlDRFxceDAyXFx1MDlEMFxceDAyXFx1MDlEOVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwOUQ5XFx4MDJcXHUwOURFXFx4MDJcXHUwOURGXFx4MDJcXHUwOUUxXFx4MDJcXHUwOUU1XFx4MDJcXHUwOUU4XFx4MDJcXHUwOUYzXFx4MDJcIiArXHJcblx0XHRcIlxcdTBBMDNcXHgwMlxcdTBBMDVcXHgwMlxcdTBBMDdcXHgwMlxcdTBBMENcXHgwMlxcdTBBMTFcXHgwMlxcdTBBMTJcXHgwMlxcdTBBMTVcXHgwMlwiICtcclxuXHRcdFwiXFx1MEEyQVxceDAyXFx1MEEyQ1xceDAyXFx1MEEzMlxceDAyXFx1MEEzNFxceDAyXFx1MEEzNVxceDAyXFx1MEEzN1xceDAyXFx1MEEzOFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQTNBXFx4MDJcXHUwQTNCXFx4MDJcXHUwQTNFXFx4MDJcXHUwQTNFXFx4MDJcXHUwQTQwXFx4MDJcXHUwQTQ0XFx4MDJcXHUwQTQ5XFx4MDJcIiArXHJcblx0XHRcIlxcdTBBNEFcXHgwMlxcdTBBNERcXHgwMlxcdTBBNEZcXHgwMlxcdTBBNTNcXHgwMlxcdTBBNTNcXHgwMlxcdTBBNUJcXHgwMlxcdTBBNUVcXHgwMlwiICtcclxuXHRcdFwiXFx1MEE2MFxceDAyXFx1MEE2MFxceDAyXFx1MEE2OFxceDAyXFx1MEE3N1xceDAyXFx1MEE4M1xceDAyXFx1MEE4NVxceDAyXFx1MEE4N1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwQThGXFx4MDJcXHUwQTkxXFx4MDJcXHUwQTkzXFx4MDJcXHUwQTk1XFx4MDJcXHUwQUFBXFx4MDJcXHUwQUFDXFx4MDJcXHUwQUIyXFx4MDJcIiArXHJcblx0XHRcIlxcdTBBQjRcXHgwMlxcdTBBQjVcXHgwMlxcdTBBQjdcXHgwMlxcdTBBQkJcXHgwMlxcdTBBQkVcXHgwMlxcdTBBQzdcXHgwMlxcdTBBQzlcXHgwMlwiICtcclxuXHRcdFwiXFx1MEFDQlxceDAyXFx1MEFDRFxceDAyXFx1MEFDRlxceDAyXFx1MEFEMlxceDAyXFx1MEFEMlxceDAyXFx1MEFFMlxceDAyXFx1MEFFNVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQUU4XFx4MDJcXHUwQUYxXFx4MDJcXHUwQUZCXFx4MDJcXHUwQUZCXFx4MDJcXHUwQjAzXFx4MDJcXHUwQjA1XFx4MDJcXHUwQjA3XFx4MDJcIiArXHJcblx0XHRcIlxcdTBCMEVcXHgwMlxcdTBCMTFcXHgwMlxcdTBCMTJcXHgwMlxcdTBCMTVcXHgwMlxcdTBCMkFcXHgwMlxcdTBCMkNcXHgwMlxcdTBCMzJcXHgwMlwiICtcclxuXHRcdFwiXFx1MEIzNFxceDAyXFx1MEIzNVxceDAyXFx1MEIzN1xceDAyXFx1MEIzQlxceDAyXFx1MEIzRVxceDAyXFx1MEI0NlxceDAyXFx1MEI0OVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQjRBXFx4MDJcXHUwQjREXFx4MDJcXHUwQjRGXFx4MDJcXHUwQjU4XFx4MDJcXHUwQjU5XFx4MDJcXHUwQjVFXFx4MDJcXHUwQjVGXFx4MDJcIiArXHJcblx0XHRcIlxcdTBCNjFcXHgwMlxcdTBCNjVcXHgwMlxcdTBCNjhcXHgwMlxcdTBCNzFcXHgwMlxcdTBCNzNcXHgwMlxcdTBCNzNcXHgwMlxcdTBCODRcXHgwMlwiICtcclxuXHRcdFwiXFx1MEI4NVxceDAyXFx1MEI4N1xceDAyXFx1MEI4Q1xceDAyXFx1MEI5MFxceDAyXFx1MEI5MlxceDAyXFx1MEI5NFxceDAyXFx1MEI5N1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwQjlCXFx4MDJcXHUwQjlDXFx4MDJcXHUwQjlFXFx4MDJcXHUwQjlFXFx4MDJcXHUwQkEwXFx4MDJcXHUwQkExXFx4MDJcXHUwQkE1XFx4MDJcIiArXHJcblx0XHRcIlxcdTBCQTZcXHgwMlxcdTBCQUFcXHgwMlxcdTBCQUNcXHgwMlxcdTBCQjBcXHgwMlxcdTBCQkJcXHgwMlxcdTBCQzBcXHgwMlxcdTBCQzRcXHgwMlwiICtcclxuXHRcdFwiXFx1MEJDOFxceDAyXFx1MEJDQVxceDAyXFx1MEJDQ1xceDAyXFx1MEJDRlxceDAyXFx1MEJEMlxceDAyXFx1MEJEMlxceDAyXFx1MEJEOVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQkQ5XFx4MDJcXHUwQkU4XFx4MDJcXHUwQkYxXFx4MDJcXHUwQzAyXFx4MDJcXHUwQzA1XFx4MDJcXHUwQzA3XFx4MDJcXHUwQzBFXFx4MDJcIiArXHJcblx0XHRcIlxcdTBDMTBcXHgwMlxcdTBDMTJcXHgwMlxcdTBDMTRcXHgwMlxcdTBDMkFcXHgwMlxcdTBDMkNcXHgwMlxcdTBDM0JcXHgwMlxcdTBDM0ZcXHgwMlwiICtcclxuXHRcdFwiXFx1MEM0NlxceDAyXFx1MEM0OFxceDAyXFx1MEM0QVxceDAyXFx1MEM0Q1xceDAyXFx1MEM0RlxceDAyXFx1MEM1N1xceDAyXFx1MEM1OFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQzVBXFx4MDJcXHUwQzVDXFx4MDJcXHUwQzYyXFx4MDJcXHUwQzY1XFx4MDJcXHUwQzY4XFx4MDJcXHUwQzcxXFx4MDJcXHUwQzgyXFx4MDJcIiArXHJcblx0XHRcIlxcdTBDODVcXHgwMlxcdTBDODdcXHgwMlxcdTBDOEVcXHgwMlxcdTBDOTBcXHgwMlxcdTBDOTJcXHgwMlxcdTBDOTRcXHgwMlxcdTBDQUFcXHgwMlwiICtcclxuXHRcdFwiXFx1MENBQ1xceDAyXFx1MENCNVxceDAyXFx1MENCN1xceDAyXFx1MENCQlxceDAyXFx1MENCRVxceDAyXFx1MENDNlxceDAyXFx1MENDOFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQ0NBXFx4MDJcXHUwQ0NDXFx4MDJcXHUwQ0NGXFx4MDJcXHUwQ0Q3XFx4MDJcXHUwQ0Q4XFx4MDJcXHUwQ0UwXFx4MDJcXHUwQ0UwXFx4MDJcIiArXHJcblx0XHRcIlxcdTBDRTJcXHgwMlxcdTBDRTVcXHgwMlxcdTBDRThcXHgwMlxcdTBDRjFcXHgwMlxcdTBDRjNcXHgwMlxcdTBDRjRcXHgwMlxcdTBEMDNcXHgwMlwiICtcclxuXHRcdFwiXFx1MEQwNVxceDAyXFx1MEQwN1xceDAyXFx1MEQwRVxceDAyXFx1MEQxMFxceDAyXFx1MEQxMlxceDAyXFx1MEQxNFxceDAyXFx1MEQzQ1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwRDNGXFx4MDJcXHUwRDQ2XFx4MDJcXHUwRDQ4XFx4MDJcXHUwRDRBXFx4MDJcXHUwRDRDXFx4MDJcXHUwRDUwXFx4MDJcXHUwRDU2XFx4MDJcIiArXHJcblx0XHRcIlxcdTBENTlcXHgwMlxcdTBENjFcXHgwMlxcdTBENjVcXHgwMlxcdTBENjhcXHgwMlxcdTBENzFcXHgwMlxcdTBEN0NcXHgwMlxcdTBEODFcXHgwMlwiICtcclxuXHRcdFwiXFx1MEQ4NFxceDAyXFx1MEQ4NVxceDAyXFx1MEQ4N1xceDAyXFx1MEQ5OFxceDAyXFx1MEQ5Q1xceDAyXFx1MERCM1xceDAyXFx1MERCNVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwREJEXFx4MDJcXHUwREJGXFx4MDJcXHUwREJGXFx4MDJcXHUwREMyXFx4MDJcXHUwREM4XFx4MDJcXHUwRENDXFx4MDJcXHUwRENDXFx4MDJcIiArXHJcblx0XHRcIlxcdTBERDFcXHgwMlxcdTBERDZcXHgwMlxcdTBERDhcXHgwMlxcdTBERDhcXHgwMlxcdTBEREFcXHgwMlxcdTBERTFcXHgwMlxcdTBERThcXHgwMlwiICtcclxuXHRcdFwiXFx1MERGMVxceDAyXFx1MERGNFxceDAyXFx1MERGNVxceDAyXFx1MEUwM1xceDAyXFx1MEUzQ1xceDAyXFx1MEU0MlxceDAyXFx1MEU1MFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRTUyXFx4MDJcXHUwRTVCXFx4MDJcXHUwRTgzXFx4MDJcXHUwRTg0XFx4MDJcXHUwRTg2XFx4MDJcXHUwRTg2XFx4MDJcXHUwRTg5XFx4MDJcIiArXHJcblx0XHRcIlxcdTBFOEFcXHgwMlxcdTBFOENcXHgwMlxcdTBFOENcXHgwMlxcdTBFOEZcXHgwMlxcdTBFOEZcXHgwMlxcdTBFOTZcXHgwMlxcdTBFOTlcXHgwMlwiICtcclxuXHRcdFwiXFx1MEU5QlxceDAyXFx1MEVBMVxceDAyXFx1MEVBM1xceDAyXFx1MEVBNVxceDAyXFx1MEVBN1xceDAyXFx1MEVBN1xceDAyXFx1MEVBOVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRUE5XFx4MDJcXHUwRUFDXFx4MDJcXHUwRUFEXFx4MDJcXHUwRUFGXFx4MDJcXHUwRUJCXFx4MDJcXHUwRUJEXFx4MDJcXHUwRUJGXFx4MDJcIiArXHJcblx0XHRcIlxcdTBFQzJcXHgwMlxcdTBFQzZcXHgwMlxcdTBFQzhcXHgwMlxcdTBFQzhcXHgwMlxcdTBFQ0FcXHgwMlxcdTBFQ0ZcXHgwMlxcdTBFRDJcXHgwMlwiICtcclxuXHRcdFwiXFx1MEVEQlxceDAyXFx1MEVERVxceDAyXFx1MEVFMVxceDAyXFx1MEYwMlxceDAyXFx1MEYwMlxceDAyXFx1MEYxQVxceDAyXFx1MEYxQlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRjIyXFx4MDJcXHUwRjJCXFx4MDJcXHUwRjM3XFx4MDJcXHUwRjM3XFx4MDJcXHUwRjM5XFx4MDJcXHUwRjM5XFx4MDJcXHUwRjNCXFx4MDJcIiArXHJcblx0XHRcIlxcdTBGM0JcXHgwMlxcdTBGNDBcXHgwMlxcdTBGNDlcXHgwMlxcdTBGNEJcXHgwMlxcdTBGNkVcXHgwMlxcdTBGNzNcXHgwMlxcdTBGODZcXHgwMlwiICtcclxuXHRcdFwiXFx1MEY4OFxceDAyXFx1MEY5OVxceDAyXFx1MEY5QlxceDAyXFx1MEZCRVxceDAyXFx1MEZDOFxceDAyXFx1MEZDOFxceDAyXFx1MTAwMlxceDAyXCIgK1xyXG5cdFx0XCJcXHUxMDRCXFx4MDJcXHUxMDUyXFx4MDJcXHUxMDlGXFx4MDJcXHUxMEEyXFx4MDJcXHUxMEM3XFx4MDJcXHUxMEM5XFx4MDJcXHUxMEM5XFx4MDJcIiArXHJcblx0XHRcIlxcdTEwQ0ZcXHgwMlxcdTEwQ0ZcXHgwMlxcdTEwRDJcXHgwMlxcdTEwRkNcXHgwMlxcdTEwRkVcXHgwMlxcdTEyNEFcXHgwMlxcdTEyNENcXHgwMlwiICtcclxuXHRcdFwiXFx1MTI0RlxceDAyXFx1MTI1MlxceDAyXFx1MTI1OFxceDAyXFx1MTI1QVxceDAyXFx1MTI1QVxceDAyXFx1MTI1Q1xceDAyXFx1MTI1RlxceDAyXCIgK1xyXG5cdFx0XCJcXHUxMjYyXFx4MDJcXHUxMjhBXFx4MDJcXHUxMjhDXFx4MDJcXHUxMjhGXFx4MDJcXHUxMjkyXFx4MDJcXHUxMkIyXFx4MDJcXHUxMkI0XFx4MDJcIiArXHJcblx0XHRcIlxcdTEyQjdcXHgwMlxcdTEyQkFcXHgwMlxcdTEyQzBcXHgwMlxcdTEyQzJcXHgwMlxcdTEyQzJcXHgwMlxcdTEyQzRcXHgwMlxcdTEyQzdcXHgwMlwiICtcclxuXHRcdFwiXFx1MTJDQVxceDAyXFx1MTJEOFxceDAyXFx1MTJEQVxceDAyXFx1MTMxMlxceDAyXFx1MTMxNFxceDAyXFx1MTMxN1xceDAyXFx1MTMxQVxceDAyXCIgK1xyXG5cdFx0XCJcXHUxMzVDXFx4MDJcXHUxMzVGXFx4MDJcXHUxMzYxXFx4MDJcXHUxMzgyXFx4MDJcXHUxMzkxXFx4MDJcXHUxM0EyXFx4MDJcXHUxM0Y3XFx4MDJcIiArXHJcblx0XHRcIlxcdTEzRkFcXHgwMlxcdTEzRkZcXHgwMlxcdTE0MDNcXHgwMlxcdTE2NkVcXHgwMlxcdTE2NzFcXHgwMlxcdTE2ODFcXHgwMlxcdTE2ODNcXHgwMlwiICtcclxuXHRcdFwiXFx1MTY5Q1xceDAyXFx1MTZBMlxceDAyXFx1MTZFQ1xceDAyXFx1MTZGMFxceDAyXFx1MTZGQVxceDAyXFx1MTcwMlxceDAyXFx1MTcwRVxceDAyXCIgK1xyXG5cdFx0XCJcXHUxNzEwXFx4MDJcXHUxNzE2XFx4MDJcXHUxNzIyXFx4MDJcXHUxNzM2XFx4MDJcXHUxNzQyXFx4MDJcXHUxNzU1XFx4MDJcXHUxNzYyXFx4MDJcIiArXHJcblx0XHRcIlxcdTE3NkVcXHgwMlxcdTE3NzBcXHgwMlxcdTE3NzJcXHgwMlxcdTE3NzRcXHgwMlxcdTE3NzVcXHgwMlxcdTE3ODJcXHgwMlxcdTE3RDVcXHgwMlwiICtcclxuXHRcdFwiXFx1MTdEOVxceDAyXFx1MTdEOVxceDAyXFx1MTdERVxceDAyXFx1MTdERlxceDAyXFx1MTdFMlxceDAyXFx1MTdFQlxceDAyXFx1MTgwRFxceDAyXCIgK1xyXG5cdFx0XCJcXHUxODEwXFx4MDJcXHUxODEyXFx4MDJcXHUxODFCXFx4MDJcXHUxODIyXFx4MDJcXHUxODc5XFx4MDJcXHUxODgyXFx4MDJcXHUxOEFDXFx4MDJcIiArXHJcblx0XHRcIlxcdTE4QjJcXHgwMlxcdTE4RjdcXHgwMlxcdTE5MDJcXHgwMlxcdTE5MjBcXHgwMlxcdTE5MjJcXHgwMlxcdTE5MkRcXHgwMlxcdTE5MzJcXHgwMlwiICtcclxuXHRcdFwiXFx1MTkzRFxceDAyXFx1MTk0OFxceDAyXFx1MTk2RlxceDAyXFx1MTk3MlxceDAyXFx1MTk3NlxceDAyXFx1MTk4MlxceDAyXFx1MTlBRFxceDAyXCIgK1xyXG5cdFx0XCJcXHUxOUIyXFx4MDJcXHUxOUNCXFx4MDJcXHUxOUQyXFx4MDJcXHUxOURCXFx4MDJcXHUxQTAyXFx4MDJcXHUxQTFEXFx4MDJcXHUxQTIyXFx4MDJcIiArXHJcblx0XHRcIlxcdTFBNjBcXHgwMlxcdTFBNjJcXHgwMlxcdTFBN0VcXHgwMlxcdTFBODFcXHgwMlxcdTFBOEJcXHgwMlxcdTFBOTJcXHgwMlxcdTFBOUJcXHgwMlwiICtcclxuXHRcdFwiXFx1MUFBOVxceDAyXFx1MUFBOVxceDAyXFx1MUFCMlxceDAyXFx1MUFCRlxceDAyXFx1MUIwMlxceDAyXFx1MUI0RFxceDAyXFx1MUI1MlxceDAyXCIgK1xyXG5cdFx0XCJcXHUxQjVCXFx4MDJcXHUxQjZEXFx4MDJcXHUxQjc1XFx4MDJcXHUxQjgyXFx4MDJcXHUxQkY1XFx4MDJcXHUxQzAyXFx4MDJcXHUxQzM5XFx4MDJcIiArXHJcblx0XHRcIlxcdTFDNDJcXHgwMlxcdTFDNEJcXHgwMlxcdTFDNEZcXHgwMlxcdTFDN0ZcXHgwMlxcdTFDODJcXHgwMlxcdTFDOEFcXHgwMlxcdTFDRDJcXHgwMlwiICtcclxuXHRcdFwiXFx1MUNENFxceDAyXFx1MUNENlxceDAyXFx1MUNGOFxceDAyXFx1MUNGQVxceDAyXFx1MUNGQlxceDAyXFx1MUQwMlxceDAyXFx1MURGN1xceDAyXCIgK1xyXG5cdFx0XCJcXHUxREZEXFx4MDJcXHUxRjE3XFx4MDJcXHUxRjFBXFx4MDJcXHUxRjFGXFx4MDJcXHUxRjIyXFx4MDJcXHUxRjQ3XFx4MDJcXHUxRjRBXFx4MDJcIiArXHJcblx0XHRcIlxcdTFGNEZcXHgwMlxcdTFGNTJcXHgwMlxcdTFGNTlcXHgwMlxcdTFGNUJcXHgwMlxcdTFGNUJcXHgwMlxcdTFGNURcXHgwMlxcdTFGNURcXHgwMlwiICtcclxuXHRcdFwiXFx1MUY1RlxceDAyXFx1MUY1RlxceDAyXFx1MUY2MVxceDAyXFx1MUY3RlxceDAyXFx1MUY4MlxceDAyXFx1MUZCNlxceDAyXFx1MUZCOFxceDAyXCIgK1xyXG5cdFx0XCJcXHUxRkJFXFx4MDJcXHUxRkMwXFx4MDJcXHUxRkMwXFx4MDJcXHUxRkM0XFx4MDJcXHUxRkM2XFx4MDJcXHUxRkM4XFx4MDJcXHUxRkNFXFx4MDJcIiArXHJcblx0XHRcIlxcdTFGRDJcXHgwMlxcdTFGRDVcXHgwMlxcdTFGRDhcXHgwMlxcdTFGRERcXHgwMlxcdTFGRTJcXHgwMlxcdTFGRUVcXHgwMlxcdTFGRjRcXHgwMlwiICtcclxuXHRcdFwiXFx1MUZGNlxceDAyXFx1MUZGOFxceDAyXFx1MUZGRVxceDAyXFx1MjAwRFxceDAyXFx1MjAxMVxceDAyXFx1MjAyQ1xceDAyXFx1MjAzMFxceDAyXCIgK1xyXG5cdFx0XCJcXHUyMDQxXFx4MDJcXHUyMDQyXFx4MDJcXHUyMDU2XFx4MDJcXHUyMDU2XFx4MDJcXHUyMDYyXFx4MDJcXHUyMDY2XFx4MDJcXHUyMDY4XFx4MDJcIiArXHJcblx0XHRcIlxcdTIwNzFcXHgwMlxcdTIwNzNcXHgwMlxcdTIwNzNcXHgwMlxcdTIwODFcXHgwMlxcdTIwODFcXHgwMlxcdTIwOTJcXHgwMlxcdTIwOUVcXHgwMlwiICtcclxuXHRcdFwiXFx1MjBEMlxceDAyXFx1MjBERVxceDAyXFx1MjBFM1xceDAyXFx1MjBFM1xceDAyXFx1MjBFN1xceDAyXFx1MjBGMlxceDAyXFx1MjEwNFxceDAyXCIgK1xyXG5cdFx0XCJcXHUyMTA0XFx4MDJcXHUyMTA5XFx4MDJcXHUyMTA5XFx4MDJcXHUyMTBDXFx4MDJcXHUyMTE1XFx4MDJcXHUyMTE3XFx4MDJcXHUyMTE3XFx4MDJcIiArXHJcblx0XHRcIlxcdTIxMUJcXHgwMlxcdTIxMUZcXHgwMlxcdTIxMjZcXHgwMlxcdTIxMjZcXHgwMlxcdTIxMjhcXHgwMlxcdTIxMjhcXHgwMlxcdTIxMkFcXHgwMlwiICtcclxuXHRcdFwiXFx1MjEyQVxceDAyXFx1MjEyQ1xceDAyXFx1MjEyRlxceDAyXFx1MjEzMVxceDAyXFx1MjEzQlxceDAyXFx1MjEzRVxceDAyXFx1MjE0MVxceDAyXCIgK1xyXG5cdFx0XCJcXHUyMTQ3XFx4MDJcXHUyMTRCXFx4MDJcXHUyMTUwXFx4MDJcXHUyMTUwXFx4MDJcXHUyMTYyXFx4MDJcXHUyMThBXFx4MDJcXHUyQzAyXFx4MDJcIiArXHJcblx0XHRcIlxcdTJDMzBcXHgwMlxcdTJDMzJcXHgwMlxcdTJDNjBcXHgwMlxcdTJDNjJcXHgwMlxcdTJDRTZcXHgwMlxcdTJDRURcXHgwMlxcdTJDRjVcXHgwMlwiICtcclxuXHRcdFwiXFx1MkQwMlxceDAyXFx1MkQyN1xceDAyXFx1MkQyOVxceDAyXFx1MkQyOVxceDAyXFx1MkQyRlxceDAyXFx1MkQyRlxceDAyXFx1MkQzMlxceDAyXCIgK1xyXG5cdFx0XCJcXHUyRDY5XFx4MDJcXHUyRDcxXFx4MDJcXHUyRDcxXFx4MDJcXHUyRDgxXFx4MDJcXHUyRDk4XFx4MDJcXHUyREEyXFx4MDJcXHUyREE4XFx4MDJcIiArXHJcblx0XHRcIlxcdTJEQUFcXHgwMlxcdTJEQjBcXHgwMlxcdTJEQjJcXHgwMlxcdTJEQjhcXHgwMlxcdTJEQkFcXHgwMlxcdTJEQzBcXHgwMlxcdTJEQzJcXHgwMlwiICtcclxuXHRcdFwiXFx1MkRDOFxceDAyXFx1MkRDQVxceDAyXFx1MkREMFxceDAyXFx1MkREMlxceDAyXFx1MkREOFxceDAyXFx1MkREQVxceDAyXFx1MkRFMFxceDAyXCIgK1xyXG5cdFx0XCJcXHUyREUyXFx4MDJcXHUyRTAxXFx4MDJcXHUyRTMxXFx4MDJcXHUyRTMxXFx4MDJcXHUzMDA3XFx4MDJcXHUzMDA5XFx4MDJcXHUzMDIzXFx4MDJcIiArXHJcblx0XHRcIlxcdTMwMzFcXHgwMlxcdTMwMzNcXHgwMlxcdTMwMzdcXHgwMlxcdTMwM0FcXHgwMlxcdTMwM0VcXHgwMlxcdTMwNDNcXHgwMlxcdTMwOThcXHgwMlwiICtcclxuXHRcdFwiXFx1MzA5QlxceDAyXFx1MzA5Q1xceDAyXFx1MzA5RlxceDAyXFx1MzBBMVxceDAyXFx1MzBBM1xceDAyXFx1MzBGQ1xceDAyXFx1MzBGRVxceDAyXCIgK1xyXG5cdFx0XCJcXHUzMTAxXFx4MDJcXHUzMTA3XFx4MDJcXHUzMTJGXFx4MDJcXHUzMTMzXFx4MDJcXHUzMTkwXFx4MDJcXHUzMUEyXFx4MDJcXHUzMUJDXFx4MDJcIiArXHJcblx0XHRcIlxcdTMxRjJcXHgwMlxcdTMyMDFcXHgwMlxcdTM0MDJcXHgwMlxcdTREQjdcXHgwMlxcdTRFMDJcXHgwMlxcdTlGRDdcXHgwMlxcdUEwMDJcXHgwMlwiICtcclxuXHRcdFwiXFx1QTQ4RVxceDAyXFx1QTREMlxceDAyXFx1QTRGRlxceDAyXFx1QTUwMlxceDAyXFx1QTYwRVxceDAyXFx1QTYxMlxceDAyXFx1QTYyRFxceDAyXCIgK1xyXG5cdFx0XCJcXHVBNjQyXFx4MDJcXHVBNjcxXFx4MDJcXHVBNjc2XFx4MDJcXHVBNjdGXFx4MDJcXHVBNjgxXFx4MDJcXHVBNkYzXFx4MDJcXHVBNzE5XFx4MDJcIiArXHJcblx0XHRcIlxcdUE3MjFcXHgwMlxcdUE3MjRcXHgwMlxcdUE3OEFcXHgwMlxcdUE3OERcXHgwMlxcdUE3QjBcXHgwMlxcdUE3QjJcXHgwMlxcdUE3QjlcXHgwMlwiICtcclxuXHRcdFwiXFx1QTdGOVxceDAyXFx1QTgyOVxceDAyXFx1QTg0MlxceDAyXFx1QTg3NVxceDAyXFx1QTg4MlxceDAyXFx1QThDN1xceDAyXFx1QThEMlxceDAyXCIgK1xyXG5cdFx0XCJcXHVBOERCXFx4MDJcXHVBOEUyXFx4MDJcXHVBOEY5XFx4MDJcXHVBOEZEXFx4MDJcXHVBOEZEXFx4MDJcXHVBOEZGXFx4MDJcXHVBOEZGXFx4MDJcIiArXHJcblx0XHRcIlxcdUE5MDJcXHgwMlxcdUE5MkZcXHgwMlxcdUE5MzJcXHgwMlxcdUE5NTVcXHgwMlxcdUE5NjJcXHgwMlxcdUE5N0VcXHgwMlxcdUE5ODJcXHgwMlwiICtcclxuXHRcdFwiXFx1QTlDMlxceDAyXFx1QTlEMVxceDAyXFx1QTlEQlxceDAyXFx1QTlFMlxceDAyXFx1QUEwMFxceDAyXFx1QUEwMlxceDAyXFx1QUEzOFxceDAyXCIgK1xyXG5cdFx0XCJcXHVBQTQyXFx4MDJcXHVBQTRGXFx4MDJcXHVBQTUyXFx4MDJcXHVBQTVCXFx4MDJcXHVBQTYyXFx4MDJcXHVBQTc4XFx4MDJcXHVBQTdDXFx4MDJcIiArXHJcblx0XHRcIlxcdUFBQzRcXHgwMlxcdUFBRERcXHgwMlxcdUFBREZcXHgwMlxcdUFBRTJcXHgwMlxcdUFBRjFcXHgwMlxcdUFBRjRcXHgwMlxcdUFBRjhcXHgwMlwiICtcclxuXHRcdFwiXFx1QUIwM1xceDAyXFx1QUIwOFxceDAyXFx1QUIwQlxceDAyXFx1QUIxMFxceDAyXFx1QUIxM1xceDAyXFx1QUIxOFxceDAyXFx1QUIyMlxceDAyXCIgK1xyXG5cdFx0XCJcXHVBQjI4XFx4MDJcXHVBQjJBXFx4MDJcXHVBQjMwXFx4MDJcXHVBQjMyXFx4MDJcXHVBQjVDXFx4MDJcXHVBQjVFXFx4MDJcXHVBQjY3XFx4MDJcIiArXHJcblx0XHRcIlxcdUFCNzJcXHgwMlxcdUFCRUNcXHgwMlxcdUFCRUVcXHgwMlxcdUFCRUZcXHgwMlxcdUFCRjJcXHgwMlxcdUFCRkJcXHgwMlxcdUFDMDJcXHgwMlwiICtcclxuXHRcdFwiXFx1RDdBNVxceDAyXFx1RDdCMlxceDAyXFx1RDdDOFxceDAyXFx1RDdDRFxceDAyXFx1RDdGRFxceDAyXFx1RjkwMlxceDAyXFx1RkE2RlxceDAyXCIgK1xyXG5cdFx0XCJcXHVGQTcyXFx4MDJcXHVGQURCXFx4MDJcXHVGQjAyXFx4MDJcXHVGQjA4XFx4MDJcXHVGQjE1XFx4MDJcXHVGQjE5XFx4MDJcXHVGQjFGXFx4MDJcIiArXHJcblx0XHRcIlxcdUZCMkFcXHgwMlxcdUZCMkNcXHgwMlxcdUZCMzhcXHgwMlxcdUZCM0FcXHgwMlxcdUZCM0VcXHgwMlxcdUZCNDBcXHgwMlxcdUZCNDBcXHgwMlwiICtcclxuXHRcdFwiXFx1RkI0MlxceDAyXFx1RkI0M1xceDAyXFx1RkI0NVxceDAyXFx1RkI0NlxceDAyXFx1RkI0OFxceDAyXFx1RkJCM1xceDAyXFx1RkJENVxceDAyXCIgK1xyXG5cdFx0XCJcXHVGRDNGXFx4MDJcXHVGRDUyXFx4MDJcXHVGRDkxXFx4MDJcXHVGRDk0XFx4MDJcXHVGREM5XFx4MDJcXHVGREYyXFx4MDJcXHVGREZEXFx4MDJcIiArXHJcblx0XHRcIlxcdUZFMDJcXHgwMlxcdUZFMTFcXHgwMlxcdUZFMjJcXHgwMlxcdUZFMzFcXHgwMlxcdUZFMzVcXHgwMlxcdUZFMzZcXHgwMlxcdUZFNEZcXHgwMlwiICtcclxuXHRcdFwiXFx1RkU1MVxceDAyXFx1RkU3MlxceDAyXFx1RkU3NlxceDAyXFx1RkU3OFxceDAyXFx1RkVGRVxceDAyXFx1RkYwMVxceDAyXFx1RkYwMVxceDAyXCIgK1xyXG5cdFx0XCJcXHVGRjEyXFx4MDJcXHVGRjFCXFx4MDJcXHVGRjIzXFx4MDJcXHVGRjNDXFx4MDJcXHVGRjQxXFx4MDJcXHVGRjQxXFx4MDJcXHVGRjQzXFx4MDJcIiArXHJcblx0XHRcIlxcdUZGNUNcXHgwMlxcdUZGNjhcXHgwMlxcdUZGQzBcXHgwMlxcdUZGQzRcXHgwMlxcdUZGQzlcXHgwMlxcdUZGQ0NcXHgwMlxcdUZGRDFcXHgwMlwiICtcclxuXHRcdFwiXFx1RkZENFxceDAyXFx1RkZEOVxceDAyXFx1RkZEQ1xceDAyXFx1RkZERVxceDAyXFx1RkZGQlxceDAyXFx1RkZGRFxceDAyXFx4MDJcXHgwM1xcclwiICtcclxuXHRcdFwiXFx4MDNcXHgwRlxceDAzKFxceDAzKlxceDAzPFxceDAzPlxceDAzP1xceDAzQVxceDAzT1xceDAzUlxceDAzX1xceDAzXFx4ODJcXHgwM1xceEZDXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTAxNDJcXHgwM1xcdTAxNzZcXHgwM1xcdTAxRkZcXHgwM1xcdTAxRkZcXHgwM1xcdTAyODJcXHgwM1xcdTAyOUVcXHgwM1xcdTAyQTJcIiArXHJcblx0XHRcIlxceDAzXFx1MDJEMlxceDAzXFx1MDJFMlxceDAzXFx1MDJFMlxceDAzXFx1MDMwMlxceDAzXFx1MDMyMVxceDAzXFx1MDMzMlxceDAzXFx1MDM0Q1wiICtcclxuXHRcdFwiXFx4MDNcXHUwMzUyXFx4MDNcXHUwMzdDXFx4MDNcXHUwMzgyXFx4MDNcXHUwMzlGXFx4MDNcXHUwM0EyXFx4MDNcXHUwM0M1XFx4MDNcXHUwM0NBXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTAzRDFcXHgwM1xcdTAzRDNcXHgwM1xcdTAzRDdcXHgwM1xcdTA0MDJcXHgwM1xcdTA0OUZcXHgwM1xcdTA0QTJcXHgwM1xcdTA0QUJcIiArXHJcblx0XHRcIlxceDAzXFx1MDRCMlxceDAzXFx1MDRENVxceDAzXFx1MDREQVxceDAzXFx1MDRGRFxceDAzXFx1MDUwMlxceDAzXFx1MDUyOVxceDAzXFx1MDUzMlwiICtcclxuXHRcdFwiXFx4MDNcXHUwNTY1XFx4MDNcXHUwNjAyXFx4MDNcXHUwNzM4XFx4MDNcXHUwNzQyXFx4MDNcXHUwNzU3XFx4MDNcXHUwNzYyXFx4MDNcXHUwNzY5XCIgK1xyXG5cdFx0XCJcXHgwM1xcdTA4MDJcXHgwM1xcdTA4MDdcXHgwM1xcdTA4MEFcXHgwM1xcdTA4MEFcXHgwM1xcdTA4MENcXHgwM1xcdTA4MzdcXHgwM1xcdTA4MzlcIiArXHJcblx0XHRcIlxceDAzXFx1MDgzQVxceDAzXFx1MDgzRVxceDAzXFx1MDgzRVxceDAzXFx1MDg0MVxceDAzXFx1MDg1N1xceDAzXFx1MDg2MlxceDAzXFx1MDg3OFwiICtcclxuXHRcdFwiXFx4MDNcXHUwODgyXFx4MDNcXHUwOEEwXFx4MDNcXHUwOEUyXFx4MDNcXHUwOEY0XFx4MDNcXHUwOEY2XFx4MDNcXHUwOEY3XFx4MDNcXHUwOTAyXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTA5MTdcXHgwM1xcdTA5MjJcXHgwM1xcdTA5M0JcXHgwM1xcdTA5ODJcXHgwM1xcdTA5QjlcXHgwM1xcdTA5QzBcXHgwM1xcdTA5QzFcIiArXHJcblx0XHRcIlxceDAzXFx1MEEwMlxceDAzXFx1MEEwNVxceDAzXFx1MEEwN1xceDAzXFx1MEEwOFxceDAzXFx1MEEwRVxceDAzXFx1MEExNVxceDAzXFx1MEExN1wiICtcclxuXHRcdFwiXFx4MDNcXHUwQTE5XFx4MDNcXHUwQTFCXFx4MDNcXHUwQTM1XFx4MDNcXHUwQTNBXFx4MDNcXHUwQTNDXFx4MDNcXHUwQTQxXFx4MDNcXHUwQTQxXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTBBNjJcXHgwM1xcdTBBN0VcXHgwM1xcdTBBODJcXHgwM1xcdTBBOUVcXHgwM1xcdTBBQzJcXHgwM1xcdTBBQzlcXHgwM1xcdTBBQ0JcIiArXHJcblx0XHRcIlxceDAzXFx1MEFFOFxceDAzXFx1MEIwMlxceDAzXFx1MEIzN1xceDAzXFx1MEI0MlxceDAzXFx1MEI1N1xceDAzXFx1MEI2MlxceDAzXFx1MEI3NFwiICtcclxuXHRcdFwiXFx4MDNcXHUwQjgyXFx4MDNcXHUwQjkzXFx4MDNcXHUwQzAyXFx4MDNcXHUwQzRBXFx4MDNcXHUwQzgyXFx4MDNcXHUwQ0I0XFx4MDNcXHUwQ0MyXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTBDRjRcXHgwM1xcdTEwMDJcXHgwM1xcdTEwNDhcXHgwM1xcdTEwNjhcXHgwM1xcdTEwNzFcXHgwM1xcdTEwODFcXHgwM1xcdTEwQkNcIiArXHJcblx0XHRcIlxceDAzXFx1MTBCRlxceDAzXFx1MTBCRlxceDAzXFx1MTBEMlxceDAzXFx1MTBFQVxceDAzXFx1MTBGMlxceDAzXFx1MTBGQlxceDAzXFx1MTEwMlwiICtcclxuXHRcdFwiXFx4MDNcXHUxMTM2XFx4MDNcXHUxMTM4XFx4MDNcXHUxMTQxXFx4MDNcXHUxMTUyXFx4MDNcXHUxMTc1XFx4MDNcXHUxMTc4XFx4MDNcXHUxMTc4XCIgK1xyXG5cdFx0XCJcXHgwM1xcdTExODJcXHgwM1xcdTExQzZcXHgwM1xcdTExQ0NcXHgwM1xcdTExQ0VcXHgwM1xcdTExRDJcXHgwM1xcdTExRENcXHgwM1xcdTExREVcIiArXHJcblx0XHRcIlxceDAzXFx1MTFERVxceDAzXFx1MTIwMlxceDAzXFx1MTIxM1xceDAzXFx1MTIxNVxceDAzXFx1MTIzOVxceDAzXFx1MTI0MFxceDAzXFx1MTI0MFwiICtcclxuXHRcdFwiXFx4MDNcXHUxMjgyXFx4MDNcXHUxMjg4XFx4MDNcXHUxMjhBXFx4MDNcXHUxMjhBXFx4MDNcXHUxMjhDXFx4MDNcXHUxMjhGXFx4MDNcXHUxMjkxXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTEyOUZcXHgwM1xcdTEyQTFcXHgwM1xcdTEyQUFcXHgwM1xcdTEyQjJcXHgwM1xcdTEyRUNcXHgwM1xcdTEyRjJcXHgwM1xcdTEyRkJcIiArXHJcblx0XHRcIlxceDAzXFx1MTMwMlxceDAzXFx1MTMwNVxceDAzXFx1MTMwN1xceDAzXFx1MTMwRVxceDAzXFx1MTMxMVxceDAzXFx1MTMxMlxceDAzXFx1MTMxNVwiICtcclxuXHRcdFwiXFx4MDNcXHUxMzJBXFx4MDNcXHUxMzJDXFx4MDNcXHUxMzMyXFx4MDNcXHUxMzM0XFx4MDNcXHUxMzM1XFx4MDNcXHUxMzM3XFx4MDNcXHUxMzNCXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTEzM0VcXHgwM1xcdTEzNDZcXHgwM1xcdTEzNDlcXHgwM1xcdTEzNEFcXHgwM1xcdTEzNERcXHgwM1xcdTEzNEZcXHgwM1xcdTEzNTJcIiArXHJcblx0XHRcIlxceDAzXFx1MTM1MlxceDAzXFx1MTM1OVxceDAzXFx1MTM1OVxceDAzXFx1MTM1RlxceDAzXFx1MTM2NVxceDAzXFx1MTM2OFxceDAzXFx1MTM2RVwiICtcclxuXHRcdFwiXFx4MDNcXHUxMzcyXFx4MDNcXHUxMzc2XFx4MDNcXHUxNDAyXFx4MDNcXHUxNDRDXFx4MDNcXHUxNDUyXFx4MDNcXHUxNDVCXFx4MDNcXHUxNDgyXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTE0QzdcXHgwM1xcdTE0QzlcXHgwM1xcdTE0QzlcXHgwM1xcdTE0RDJcXHgwM1xcdTE0REJcXHgwM1xcdTE1ODJcXHgwM1xcdTE1QjdcIiArXHJcblx0XHRcIlxceDAzXFx1MTVCQVxceDAzXFx1MTVDMlxceDAzXFx1MTVEQVxceDAzXFx1MTVERlxceDAzXFx1MTYwMlxceDAzXFx1MTY0MlxceDAzXFx1MTY0NlwiICtcclxuXHRcdFwiXFx4MDNcXHUxNjQ2XFx4MDNcXHUxNjUyXFx4MDNcXHUxNjVCXFx4MDNcXHUxNjgyXFx4MDNcXHUxNkI5XFx4MDNcXHUxNkMyXFx4MDNcXHUxNkNCXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTE3MDJcXHgwM1xcdTE3MUJcXHgwM1xcdTE3MUZcXHgwM1xcdTE3MkRcXHgwM1xcdTE3MzJcXHgwM1xcdTE3M0JcXHgwM1xcdTE4QTJcIiArXHJcblx0XHRcIlxceDAzXFx1MThFQlxceDAzXFx1MTkwMVxceDAzXFx1MTkwMVxceDAzXFx1MUFDMlxceDAzXFx1MUFGQVxceDAzXFx1MUMwMlxceDAzXFx1MUMwQVwiICtcclxuXHRcdFwiXFx4MDNcXHUxQzBDXFx4MDNcXHUxQzM4XFx4MDNcXHUxQzNBXFx4MDNcXHUxQzQyXFx4MDNcXHUxQzUyXFx4MDNcXHUxQzVCXFx4MDNcXHUxQzc0XCIgK1xyXG5cdFx0XCJcXHgwM1xcdTFDOTFcXHgwM1xcdTFDOTRcXHgwM1xcdTFDQTlcXHgwM1xcdTFDQUJcXHgwM1xcdTFDQjhcXHgwM1xcdTIwMDJcXHgwM1xcdTIzOUJcIiArXHJcblx0XHRcIlxceDAzXFx1MjQwMlxceDAzXFx1MjQ3MFxceDAzXFx1MjQ4MlxceDAzXFx1MjU0NVxceDAzXFx1MzAwMlxceDAzXFx1MzQzMFxceDAzXFx1NDQwMlwiICtcclxuXHRcdFwiXFx4MDNcXHU0NjQ4XFx4MDNcXHU2ODAyXFx4MDNcXHU2QTNBXFx4MDNcXHU2QTQyXFx4MDNcXHU2QTYwXFx4MDNcXHU2QTYyXFx4MDNcXHU2QTZCXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTZBRDJcXHgwM1xcdTZBRUZcXHgwM1xcdTZBRjJcXHgwM1xcdTZBRjZcXHgwM1xcdTZCMDJcXHgwM1xcdTZCMzhcXHgwM1xcdTZCNDJcIiArXHJcblx0XHRcIlxceDAzXFx1NkI0NVxceDAzXFx1NkI1MlxceDAzXFx1NkI1QlxceDAzXFx1NkI2NVxceDAzXFx1NkI3OVxceDAzXFx1NkI3RlxceDAzXFx1NkI5MVwiICtcclxuXHRcdFwiXFx4MDNcXHU2RjAyXFx4MDNcXHU2RjQ2XFx4MDNcXHU2RjUyXFx4MDNcXHU2RjgwXFx4MDNcXHU2RjkxXFx4MDNcXHU2RkExXFx4MDNcXHU2RkUyXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTZGRTJcXHgwM1xcdTcwMDJcXHgwM1xcdTg3RUVcXHgwM1xcdTg4MDJcXHgwM1xcdThBRjRcXHgwM1xcdUIwMDJcXHgwM1xcdUIwMDNcIiArXHJcblx0XHRcIlxceDAzXFx1QkMwMlxceDAzXFx1QkM2Q1xceDAzXFx1QkM3MlxceDAzXFx1QkM3RVxceDAzXFx1QkM4MlxceDAzXFx1QkM4QVxceDAzXFx1QkM5MlwiICtcclxuXHRcdFwiXFx4MDNcXHVCQzlCXFx4MDNcXHVCQzlGXFx4MDNcXHVCQ0EwXFx4MDNcXHVCQ0EyXFx4MDNcXHVCQ0E1XFx4MDNcXHVEMTY3XFx4MDNcXHVEMTZCXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUQxNkZcXHgwM1xcdUQxODRcXHgwM1xcdUQxODdcXHgwM1xcdUQxOERcXHgwM1xcdUQxQUNcXHgwM1xcdUQxQUZcXHgwM1xcdUQyNDRcIiArXHJcblx0XHRcIlxceDAzXFx1RDI0NlxceDAzXFx1RDQwMlxceDAzXFx1RDQ1NlxceDAzXFx1RDQ1OFxceDAzXFx1RDQ5RVxceDAzXFx1RDRBMFxceDAzXFx1RDRBMVwiICtcclxuXHRcdFwiXFx4MDNcXHVENEE0XFx4MDNcXHVENEE0XFx4MDNcXHVENEE3XFx4MDNcXHVENEE4XFx4MDNcXHVENEFCXFx4MDNcXHVENEFFXFx4MDNcXHVENEIwXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUQ0QkJcXHgwM1xcdUQ0QkRcXHgwM1xcdUQ0QkRcXHgwM1xcdUQ0QkZcXHgwM1xcdUQ0QzVcXHgwM1xcdUQ0QzdcXHgwM1xcdUQ1MDdcIiArXHJcblx0XHRcIlxceDAzXFx1RDUwOVxceDAzXFx1RDUwQ1xceDAzXFx1RDUwRlxceDAzXFx1RDUxNlxceDAzXFx1RDUxOFxceDAzXFx1RDUxRVxceDAzXFx1RDUyMFwiICtcclxuXHRcdFwiXFx4MDNcXHVENTNCXFx4MDNcXHVENTNEXFx4MDNcXHVENTQwXFx4MDNcXHVENTQyXFx4MDNcXHVENTQ2XFx4MDNcXHVENTQ4XFx4MDNcXHVENTQ4XCIgK1xyXG5cdFx0XCJcXHgwM1xcdUQ1NENcXHgwM1xcdUQ1NTJcXHgwM1xcdUQ1NTRcXHgwM1xcdUQ2QTdcXHgwM1xcdUQ2QUFcXHgwM1xcdUQ2QzJcXHgwM1xcdUQ2QzRcIiArXHJcblx0XHRcIlxceDAzXFx1RDZEQ1xceDAzXFx1RDZERVxceDAzXFx1RDZGQ1xceDAzXFx1RDZGRVxceDAzXFx1RDcxNlxceDAzXFx1RDcxOFxceDAzXFx1RDczNlwiICtcclxuXHRcdFwiXFx4MDNcXHVENzM4XFx4MDNcXHVENzUwXFx4MDNcXHVENzUyXFx4MDNcXHVENzcwXFx4MDNcXHVENzcyXFx4MDNcXHVENzhBXFx4MDNcXHVENzhDXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUQ3QUFcXHgwM1xcdUQ3QUNcXHgwM1xcdUQ3QzRcXHgwM1xcdUQ3QzZcXHgwM1xcdUQ3Q0RcXHgwM1xcdUQ3RDBcXHgwM1xcdUQ4MDFcIiArXHJcblx0XHRcIlxceDAzXFx1REEwMlxceDAzXFx1REEzOFxceDAzXFx1REEzRFxceDAzXFx1REE2RVxceDAzXFx1REE3N1xceDAzXFx1REE3N1xceDAzXFx1REE4NlwiICtcclxuXHRcdFwiXFx4MDNcXHVEQTg2XFx4MDNcXHVEQTlEXFx4MDNcXHVEQUExXFx4MDNcXHVEQUEzXFx4MDNcXHVEQUIxXFx4MDNcXHVFMDAyXFx4MDNcXHVFMDA4XCIgK1xyXG5cdFx0XCJcXHgwM1xcdUUwMEFcXHgwM1xcdUUwMUFcXHgwM1xcdUUwMURcXHgwM1xcdUUwMjNcXHgwM1xcdUUwMjVcXHgwM1xcdUUwMjZcXHgwM1xcdUUwMjhcIiArXHJcblx0XHRcIlxceDAzXFx1RTAyQ1xceDAzXFx1RTgwMlxceDAzXFx1RThDNlxceDAzXFx1RThEMlxceDAzXFx1RThEOFxceDAzXFx1RTkwMlxceDAzXFx1RTk0Q1wiICtcclxuXHRcdFwiXFx4MDNcXHVFOTUyXFx4MDNcXHVFOTVCXFx4MDNcXHVFRTAyXFx4MDNcXHVFRTA1XFx4MDNcXHVFRTA3XFx4MDNcXHVFRTIxXFx4MDNcXHVFRTIzXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFMjRcXHgwM1xcdUVFMjZcXHgwM1xcdUVFMjZcXHgwM1xcdUVFMjlcXHgwM1xcdUVFMjlcXHgwM1xcdUVFMkJcXHgwM1xcdUVFMzRcIiArXHJcblx0XHRcIlxceDAzXFx1RUUzNlxceDAzXFx1RUUzOVxceDAzXFx1RUUzQlxceDAzXFx1RUUzQlxceDAzXFx1RUUzRFxceDAzXFx1RUUzRFxceDAzXFx1RUU0NFwiICtcclxuXHRcdFwiXFx4MDNcXHVFRTQ0XFx4MDNcXHVFRTQ5XFx4MDNcXHVFRTQ5XFx4MDNcXHVFRTRCXFx4MDNcXHVFRTRCXFx4MDNcXHVFRTREXFx4MDNcXHVFRTREXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFNEZcXHgwM1xcdUVFNTFcXHgwM1xcdUVFNTNcXHgwM1xcdUVFNTRcXHgwM1xcdUVFNTZcXHgwM1xcdUVFNTZcXHgwM1xcdUVFNTlcIiArXHJcblx0XHRcIlxceDAzXFx1RUU1OVxceDAzXFx1RUU1QlxceDAzXFx1RUU1QlxceDAzXFx1RUU1RFxceDAzXFx1RUU1RFxceDAzXFx1RUU1RlxceDAzXFx1RUU1RlwiICtcclxuXHRcdFwiXFx4MDNcXHVFRTYxXFx4MDNcXHVFRTYxXFx4MDNcXHVFRTYzXFx4MDNcXHVFRTY0XFx4MDNcXHVFRTY2XFx4MDNcXHVFRTY2XFx4MDNcXHVFRTY5XCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFNkNcXHgwM1xcdUVFNkVcXHgwM1xcdUVFNzRcXHgwM1xcdUVFNzZcXHgwM1xcdUVFNzlcXHgwM1xcdUVFN0JcXHgwM1xcdUVFN0VcIiArXHJcblx0XHRcIlxceDAzXFx1RUU4MFxceDAzXFx1RUU4MFxceDAzXFx1RUU4MlxceDAzXFx1RUU4QlxceDAzXFx1RUU4RFxceDAzXFx1RUU5RFxceDAzXFx1RUVBM1wiICtcclxuXHRcdFwiXFx4MDNcXHVFRUE1XFx4MDNcXHVFRUE3XFx4MDNcXHVFRUFCXFx4MDNcXHVFRUFEXFx4MDNcXHVFRUJEXFx4MDNcXHgwMlxceDA0XFx1QTZEOFxceDA0XCIgK1xyXG5cdFx0XCJcXHVBNzAyXFx4MDRcXHVCNzM2XFx4MDRcXHVCNzQyXFx4MDRcXHVCODFGXFx4MDRcXHVCODIyXFx4MDRcXHVDRUEzXFx4MDRcXHVGODAyXFx4MDRcIiArXHJcblx0XHRcIlxcdUZBMUZcXHgwNFxceDAzXFx4MTBcXHgwM1xceDEwXFxcIlxceDEwXFx4ODFcXHgxMFxcdTAxMDJcXHgxMFxcdTAxRjFcXHgxMFxcdTAyNDBcXHgwMlwiICtcclxuXHRcdFwiQ1xceDAyXFxcXFxceDAyY1xceDAyfFxceDAyXFx4QUNcXHgwMlxceEFDXFx4MDJcXHhCN1xceDAyXFx4QjdcXHgwMlxceEJDXFx4MDJcXHhCQ1xceDAyXCIgK1xyXG5cdFx0XCJcXHhDMlxceDAyXFx4RDhcXHgwMlxceERBXFx4MDJcXHhGOFxceDAyXFx4RkFcXHgwMlxcdTAyQzNcXHgwMlxcdTAyQzhcXHgwMlxcdTAyRDNcXHgwMlwiICtcclxuXHRcdFwiXFx1MDJFMlxceDAyXFx1MDJFNlxceDAyXFx1MDJFRVxceDAyXFx1MDJFRVxceDAyXFx1MDJGMFxceDAyXFx1MDJGMFxceDAyXFx1MDM3MlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwMzc2XFx4MDJcXHUwMzc4XFx4MDJcXHUwMzc5XFx4MDJcXHUwMzdDXFx4MDJcXHUwMzdGXFx4MDJcXHUwMzgxXFx4MDJcXHUwMzgxXFx4MDJcIiArXHJcblx0XHRcIlxcdTAzODhcXHgwMlxcdTAzODhcXHgwMlxcdTAzOEFcXHgwMlxcdTAzOENcXHgwMlxcdTAzOEVcXHgwMlxcdTAzOEVcXHgwMlxcdTAzOTBcXHgwMlwiICtcclxuXHRcdFwiXFx1MDNBM1xceDAyXFx1MDNBNVxceDAyXFx1MDNGN1xceDAyXFx1MDNGOVxceDAyXFx1MDQ4M1xceDAyXFx1MDQ4Q1xceDAyXFx1MDUzMVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwNTMzXFx4MDJcXHUwNTU4XFx4MDJcXHUwNTVCXFx4MDJcXHUwNTVCXFx4MDJcXHUwNTYzXFx4MDJcXHUwNTg5XFx4MDJcXHUwNUQyXFx4MDJcIiArXHJcblx0XHRcIlxcdTA1RUNcXHgwMlxcdTA1RjJcXHgwMlxcdTA1RjRcXHgwMlxcdTA2MjJcXHgwMlxcdTA2NENcXHgwMlxcdTA2NzBcXHgwMlxcdTA2NzFcXHgwMlwiICtcclxuXHRcdFwiXFx1MDY3M1xceDAyXFx1MDZENVxceDAyXFx1MDZEN1xceDAyXFx1MDZEN1xceDAyXFx1MDZFN1xceDAyXFx1MDZFOFxceDAyXFx1MDZGMFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwNkYxXFx4MDJcXHUwNkZDXFx4MDJcXHUwNkZFXFx4MDJcXHUwNzAxXFx4MDJcXHUwNzAxXFx4MDJcXHUwNzEyXFx4MDJcXHUwNzEyXFx4MDJcIiArXHJcblx0XHRcIlxcdTA3MTRcXHgwMlxcdTA3MzFcXHgwMlxcdTA3NEZcXHgwMlxcdTA3QTdcXHgwMlxcdTA3QjNcXHgwMlxcdTA3QjNcXHgwMlxcdTA3Q0NcXHgwMlwiICtcclxuXHRcdFwiXFx1MDdFQ1xceDAyXFx1MDdGNlxceDAyXFx1MDdGN1xceDAyXFx1MDdGQ1xceDAyXFx1MDdGQ1xceDAyXFx1MDgwMlxceDAyXFx1MDgxN1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwODFDXFx4MDJcXHUwODFDXFx4MDJcXHUwODI2XFx4MDJcXHUwODI2XFx4MDJcXHUwODJBXFx4MDJcXHUwODJBXFx4MDJcXHUwODQyXFx4MDJcIiArXHJcblx0XHRcIlxcdTA4NUFcXHgwMlxcdTA4QTJcXHgwMlxcdTA4QjZcXHgwMlxcdTA4QjhcXHgwMlxcdTA4QkZcXHgwMlxcdTA5MDZcXHgwMlxcdTA5M0JcXHgwMlwiICtcclxuXHRcdFwiXFx1MDkzRlxceDAyXFx1MDkzRlxceDAyXFx1MDk1MlxceDAyXFx1MDk1MlxceDAyXFx1MDk1QVxceDAyXFx1MDk2M1xceDAyXFx1MDk3M1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwOTgyXFx4MDJcXHUwOTg3XFx4MDJcXHUwOThFXFx4MDJcXHUwOTkxXFx4MDJcXHUwOTkyXFx4MDJcXHUwOTk1XFx4MDJcXHUwOUFBXFx4MDJcIiArXHJcblx0XHRcIlxcdTA5QUNcXHgwMlxcdTA5QjJcXHgwMlxcdTA5QjRcXHgwMlxcdTA5QjRcXHgwMlxcdTA5QjhcXHgwMlxcdTA5QkJcXHgwMlxcdTA5QkZcXHgwMlwiICtcclxuXHRcdFwiXFx1MDlCRlxceDAyXFx1MDlEMFxceDAyXFx1MDlEMFxceDAyXFx1MDlERVxceDAyXFx1MDlERlxceDAyXFx1MDlFMVxceDAyXFx1MDlFM1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwOUYyXFx4MDJcXHUwOUYzXFx4MDJcXHUwQTA3XFx4MDJcXHUwQTBDXFx4MDJcXHUwQTExXFx4MDJcXHUwQTEyXFx4MDJcXHUwQTE1XFx4MDJcIiArXHJcblx0XHRcIlxcdTBBMkFcXHgwMlxcdTBBMkNcXHgwMlxcdTBBMzJcXHgwMlxcdTBBMzRcXHgwMlxcdTBBMzVcXHgwMlxcdTBBMzdcXHgwMlxcdTBBMzhcXHgwMlwiICtcclxuXHRcdFwiXFx1MEEzQVxceDAyXFx1MEEzQlxceDAyXFx1MEE1QlxceDAyXFx1MEE1RVxceDAyXFx1MEE2MFxceDAyXFx1MEE2MFxceDAyXFx1MEE3NFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQTc2XFx4MDJcXHUwQTg3XFx4MDJcXHUwQThGXFx4MDJcXHUwQTkxXFx4MDJcXHUwQTkzXFx4MDJcXHUwQTk1XFx4MDJcXHUwQUFBXFx4MDJcIiArXHJcblx0XHRcIlxcdTBBQUNcXHgwMlxcdTBBQjJcXHgwMlxcdTBBQjRcXHgwMlxcdTBBQjVcXHgwMlxcdTBBQjdcXHgwMlxcdTBBQkJcXHgwMlxcdTBBQkZcXHgwMlwiICtcclxuXHRcdFwiXFx1MEFCRlxceDAyXFx1MEFEMlxceDAyXFx1MEFEMlxceDAyXFx1MEFFMlxceDAyXFx1MEFFM1xceDAyXFx1MEFGQlxceDAyXFx1MEFGQlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQjA3XFx4MDJcXHUwQjBFXFx4MDJcXHUwQjExXFx4MDJcXHUwQjEyXFx4MDJcXHUwQjE1XFx4MDJcXHUwQjJBXFx4MDJcXHUwQjJDXFx4MDJcIiArXHJcblx0XHRcIlxcdTBCMzJcXHgwMlxcdTBCMzRcXHgwMlxcdTBCMzVcXHgwMlxcdTBCMzdcXHgwMlxcdTBCM0JcXHgwMlxcdTBCM0ZcXHgwMlxcdTBCM0ZcXHgwMlwiICtcclxuXHRcdFwiXFx1MEI1RVxceDAyXFx1MEI1RlxceDAyXFx1MEI2MVxceDAyXFx1MEI2M1xceDAyXFx1MEI3M1xceDAyXFx1MEI3M1xceDAyXFx1MEI4NVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQjg1XFx4MDJcXHUwQjg3XFx4MDJcXHUwQjhDXFx4MDJcXHUwQjkwXFx4MDJcXHUwQjkyXFx4MDJcXHUwQjk0XFx4MDJcXHUwQjk3XFx4MDJcIiArXHJcblx0XHRcIlxcdTBCOUJcXHgwMlxcdTBCOUNcXHgwMlxcdTBCOUVcXHgwMlxcdTBCOUVcXHgwMlxcdTBCQTBcXHgwMlxcdTBCQTFcXHgwMlxcdTBCQTVcXHgwMlwiICtcclxuXHRcdFwiXFx1MEJBNlxceDAyXFx1MEJBQVxceDAyXFx1MEJBQ1xceDAyXFx1MEJCMFxceDAyXFx1MEJCQlxceDAyXFx1MEJEMlxceDAyXFx1MEJEMlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQzA3XFx4MDJcXHUwQzBFXFx4MDJcXHUwQzEwXFx4MDJcXHUwQzEyXFx4MDJcXHUwQzE0XFx4MDJcXHUwQzJBXFx4MDJcXHUwQzJDXFx4MDJcIiArXHJcblx0XHRcIlxcdTBDM0JcXHgwMlxcdTBDM0ZcXHgwMlxcdTBDM0ZcXHgwMlxcdTBDNUFcXHgwMlxcdTBDNUNcXHgwMlxcdTBDNjJcXHgwMlxcdTBDNjNcXHgwMlwiICtcclxuXHRcdFwiXFx1MEM4MlxceDAyXFx1MEM4MlxceDAyXFx1MEM4N1xceDAyXFx1MEM4RVxceDAyXFx1MEM5MFxceDAyXFx1MEM5MlxceDAyXFx1MEM5NFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQ0FBXFx4MDJcXHUwQ0FDXFx4MDJcXHUwQ0I1XFx4MDJcXHUwQ0I3XFx4MDJcXHUwQ0JCXFx4MDJcXHUwQ0JGXFx4MDJcXHUwQ0JGXFx4MDJcIiArXHJcblx0XHRcIlxcdTBDRTBcXHgwMlxcdTBDRTBcXHgwMlxcdTBDRTJcXHgwMlxcdTBDRTNcXHgwMlxcdTBDRjNcXHgwMlxcdTBDRjRcXHgwMlxcdTBEMDdcXHgwMlwiICtcclxuXHRcdFwiXFx1MEQwRVxceDAyXFx1MEQxMFxceDAyXFx1MEQxMlxceDAyXFx1MEQxNFxceDAyXFx1MEQzQ1xceDAyXFx1MEQzRlxceDAyXFx1MEQzRlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRDUwXFx4MDJcXHUwRDUwXFx4MDJcXHUwRDU2XFx4MDJcXHUwRDU4XFx4MDJcXHUwRDYxXFx4MDJcXHUwRDYzXFx4MDJcXHUwRDdDXFx4MDJcIiArXHJcblx0XHRcIlxcdTBEODFcXHgwMlxcdTBEODdcXHgwMlxcdTBEOThcXHgwMlxcdTBEOUNcXHgwMlxcdTBEQjNcXHgwMlxcdTBEQjVcXHgwMlxcdTBEQkRcXHgwMlwiICtcclxuXHRcdFwiXFx1MERCRlxceDAyXFx1MERCRlxceDAyXFx1MERDMlxceDAyXFx1MERDOFxceDAyXFx1MEUwM1xceDAyXFx1MEUzMlxceDAyXFx1MEUzNFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRTM1XFx4MDJcXHUwRTQyXFx4MDJcXHUwRTQ4XFx4MDJcXHUwRTgzXFx4MDJcXHUwRTg0XFx4MDJcXHUwRTg2XFx4MDJcXHUwRTg2XFx4MDJcIiArXHJcblx0XHRcIlxcdTBFODlcXHgwMlxcdTBFOEFcXHgwMlxcdTBFOENcXHgwMlxcdTBFOENcXHgwMlxcdTBFOEZcXHgwMlxcdTBFOEZcXHgwMlxcdTBFOTZcXHgwMlwiICtcclxuXHRcdFwiXFx1MEU5OVxceDAyXFx1MEU5QlxceDAyXFx1MEVBMVxceDAyXFx1MEVBM1xceDAyXFx1MEVBNVxceDAyXFx1MEVBN1xceDAyXFx1MEVBN1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwRUE5XFx4MDJcXHUwRUE5XFx4MDJcXHUwRUFDXFx4MDJcXHUwRUFEXFx4MDJcXHUwRUFGXFx4MDJcXHUwRUIyXFx4MDJcXHUwRUI0XFx4MDJcIiArXHJcblx0XHRcIlxcdTBFQjVcXHgwMlxcdTBFQkZcXHgwMlxcdTBFQkZcXHgwMlxcdTBFQzJcXHgwMlxcdTBFQzZcXHgwMlxcdTBFQzhcXHgwMlxcdTBFQzhcXHgwMlwiICtcclxuXHRcdFwiXFx1MEVERVxceDAyXFx1MEVFMVxceDAyXFx1MEYwMlxceDAyXFx1MEYwMlxceDAyXFx1MEY0MlxceDAyXFx1MEY0OVxceDAyXFx1MEY0QlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRjZFXFx4MDJcXHUwRjhBXFx4MDJcXHUwRjhFXFx4MDJcXHUxMDAyXFx4MDJcXHUxMDJDXFx4MDJcXHUxMDQxXFx4MDJcXHUxMDQxXFx4MDJcIiArXHJcblx0XHRcIlxcdTEwNTJcXHgwMlxcdTEwNTdcXHgwMlxcdTEwNUNcXHgwMlxcdTEwNUZcXHgwMlxcdTEwNjNcXHgwMlxcdTEwNjNcXHgwMlxcdTEwNjdcXHgwMlwiICtcclxuXHRcdFwiXFx1MTA2OFxceDAyXFx1MTA3MFxceDAyXFx1MTA3MlxceDAyXFx1MTA3N1xceDAyXFx1MTA4M1xceDAyXFx1MTA5MFxceDAyXFx1MTA5MFxceDAyXCIgK1xyXG5cdFx0XCJcXHUxMEEyXFx4MDJcXHUxMEM3XFx4MDJcXHUxMEM5XFx4MDJcXHUxMEM5XFx4MDJcXHUxMENGXFx4MDJcXHUxMENGXFx4MDJcXHUxMEQyXFx4MDJcIiArXHJcblx0XHRcIlxcdTEwRkNcXHgwMlxcdTEwRkVcXHgwMlxcdTEyNEFcXHgwMlxcdTEyNENcXHgwMlxcdTEyNEZcXHgwMlxcdTEyNTJcXHgwMlxcdTEyNThcXHgwMlwiICtcclxuXHRcdFwiXFx1MTI1QVxceDAyXFx1MTI1QVxceDAyXFx1MTI1Q1xceDAyXFx1MTI1RlxceDAyXFx1MTI2MlxceDAyXFx1MTI4QVxceDAyXFx1MTI4Q1xceDAyXCIgK1xyXG5cdFx0XCJcXHUxMjhGXFx4MDJcXHUxMjkyXFx4MDJcXHUxMkIyXFx4MDJcXHUxMkI0XFx4MDJcXHUxMkI3XFx4MDJcXHUxMkJBXFx4MDJcXHUxMkMwXFx4MDJcIiArXHJcblx0XHRcIlxcdTEyQzJcXHgwMlxcdTEyQzJcXHgwMlxcdTEyQzRcXHgwMlxcdTEyQzdcXHgwMlxcdTEyQ0FcXHgwMlxcdTEyRDhcXHgwMlxcdTEyREFcXHgwMlwiICtcclxuXHRcdFwiXFx1MTMxMlxceDAyXFx1MTMxNFxceDAyXFx1MTMxN1xceDAyXFx1MTMxQVxceDAyXFx1MTM1Q1xceDAyXFx1MTM4MlxceDAyXFx1MTM5MVxceDAyXCIgK1xyXG5cdFx0XCJcXHUxM0EyXFx4MDJcXHUxM0Y3XFx4MDJcXHUxM0ZBXFx4MDJcXHUxM0ZGXFx4MDJcXHUxNDAzXFx4MDJcXHUxNjZFXFx4MDJcXHUxNjcxXFx4MDJcIiArXHJcblx0XHRcIlxcdTE2ODFcXHgwMlxcdTE2ODNcXHgwMlxcdTE2OUNcXHgwMlxcdTE2QTJcXHgwMlxcdTE2RUNcXHgwMlxcdTE2RjBcXHgwMlxcdTE2RkFcXHgwMlwiICtcclxuXHRcdFwiXFx1MTcwMlxceDAyXFx1MTcwRVxceDAyXFx1MTcxMFxceDAyXFx1MTcxM1xceDAyXFx1MTcyMlxceDAyXFx1MTczM1xceDAyXFx1MTc0MlxceDAyXCIgK1xyXG5cdFx0XCJcXHUxNzUzXFx4MDJcXHUxNzYyXFx4MDJcXHUxNzZFXFx4MDJcXHUxNzcwXFx4MDJcXHUxNzcyXFx4MDJcXHUxNzgyXFx4MDJcXHUxN0I1XFx4MDJcIiArXHJcblx0XHRcIlxcdTE3RDlcXHgwMlxcdTE3RDlcXHgwMlxcdTE3REVcXHgwMlxcdTE3REVcXHgwMlxcdTE4MjJcXHgwMlxcdTE4NzlcXHgwMlxcdTE4ODJcXHgwMlwiICtcclxuXHRcdFwiXFx1MTg4NlxceDAyXFx1MTg4OVxceDAyXFx1MThBQVxceDAyXFx1MThBQ1xceDAyXFx1MThBQ1xceDAyXFx1MThCMlxceDAyXFx1MThGN1xceDAyXCIgK1xyXG5cdFx0XCJcXHUxOTAyXFx4MDJcXHUxOTIwXFx4MDJcXHUxOTUyXFx4MDJcXHUxOTZGXFx4MDJcXHUxOTcyXFx4MDJcXHUxOTc2XFx4MDJcXHUxOTgyXFx4MDJcIiArXHJcblx0XHRcIlxcdTE5QURcXHgwMlxcdTE5QjJcXHgwMlxcdTE5Q0JcXHgwMlxcdTFBMDJcXHgwMlxcdTFBMThcXHgwMlxcdTFBMjJcXHgwMlxcdTFBNTZcXHgwMlwiICtcclxuXHRcdFwiXFx1MUFBOVxceDAyXFx1MUFBOVxceDAyXFx1MUIwN1xceDAyXFx1MUIzNVxceDAyXFx1MUI0N1xceDAyXFx1MUI0RFxceDAyXFx1MUI4NVxceDAyXCIgK1xyXG5cdFx0XCJcXHUxQkEyXFx4MDJcXHUxQkIwXFx4MDJcXHUxQkIxXFx4MDJcXHUxQkJDXFx4MDJcXHUxQkU3XFx4MDJcXHUxQzAyXFx4MDJcXHUxQzI1XFx4MDJcIiArXHJcblx0XHRcIlxcdTFDNEZcXHgwMlxcdTFDNTFcXHgwMlxcdTFDNUNcXHgwMlxcdTFDN0ZcXHgwMlxcdTFDODJcXHgwMlxcdTFDOEFcXHgwMlxcdTFDRUJcXHgwMlwiICtcclxuXHRcdFwiXFx1MUNFRVxceDAyXFx1MUNGMFxceDAyXFx1MUNGM1xceDAyXFx1MUNGN1xceDAyXFx1MUNGOFxceDAyXFx1MUQwMlxceDAyXFx1MURDMVxceDAyXCIgK1xyXG5cdFx0XCJcXHUxRTAyXFx4MDJcXHUxRjE3XFx4MDJcXHUxRjFBXFx4MDJcXHUxRjFGXFx4MDJcXHUxRjIyXFx4MDJcXHUxRjQ3XFx4MDJcXHUxRjRBXFx4MDJcIiArXHJcblx0XHRcIlxcdTFGNEZcXHgwMlxcdTFGNTJcXHgwMlxcdTFGNTlcXHgwMlxcdTFGNUJcXHgwMlxcdTFGNUJcXHgwMlxcdTFGNURcXHgwMlxcdTFGNURcXHgwMlwiICtcclxuXHRcdFwiXFx1MUY1RlxceDAyXFx1MUY1RlxceDAyXFx1MUY2MVxceDAyXFx1MUY3RlxceDAyXFx1MUY4MlxceDAyXFx1MUZCNlxceDAyXFx1MUZCOFxceDAyXCIgK1xyXG5cdFx0XCJcXHUxRkJFXFx4MDJcXHUxRkMwXFx4MDJcXHUxRkMwXFx4MDJcXHUxRkM0XFx4MDJcXHUxRkM2XFx4MDJcXHUxRkM4XFx4MDJcXHUxRkNFXFx4MDJcIiArXHJcblx0XHRcIlxcdTFGRDJcXHgwMlxcdTFGRDVcXHgwMlxcdTFGRDhcXHgwMlxcdTFGRERcXHgwMlxcdTFGRTJcXHgwMlxcdTFGRUVcXHgwMlxcdTFGRjRcXHgwMlwiICtcclxuXHRcdFwiXFx1MUZGNlxceDAyXFx1MUZGOFxceDAyXFx1MUZGRVxceDAyXFx1MjA3M1xceDAyXFx1MjA3M1xceDAyXFx1MjA4MVxceDAyXFx1MjA4MVxceDAyXCIgK1xyXG5cdFx0XCJcXHUyMDkyXFx4MDJcXHUyMDlFXFx4MDJcXHUyMTA0XFx4MDJcXHUyMTA0XFx4MDJcXHUyMTA5XFx4MDJcXHUyMTA5XFx4MDJcXHUyMTBDXFx4MDJcIiArXHJcblx0XHRcIlxcdTIxMTVcXHgwMlxcdTIxMTdcXHgwMlxcdTIxMTdcXHgwMlxcdTIxMUJcXHgwMlxcdTIxMUZcXHgwMlxcdTIxMjZcXHgwMlxcdTIxMjZcXHgwMlwiICtcclxuXHRcdFwiXFx1MjEyOFxceDAyXFx1MjEyOFxceDAyXFx1MjEyQVxceDAyXFx1MjEyQVxceDAyXFx1MjEyQ1xceDAyXFx1MjEyRlxceDAyXFx1MjEzMVxceDAyXCIgK1xyXG5cdFx0XCJcXHUyMTNCXFx4MDJcXHUyMTNFXFx4MDJcXHUyMTQxXFx4MDJcXHUyMTQ3XFx4MDJcXHUyMTRCXFx4MDJcXHUyMTUwXFx4MDJcXHUyMTUwXFx4MDJcIiArXHJcblx0XHRcIlxcdTIxNjJcXHgwMlxcdTIxOEFcXHgwMlxcdTJDMDJcXHgwMlxcdTJDMzBcXHgwMlxcdTJDMzJcXHgwMlxcdTJDNjBcXHgwMlxcdTJDNjJcXHgwMlwiICtcclxuXHRcdFwiXFx1MkNFNlxceDAyXFx1MkNFRFxceDAyXFx1MkNGMFxceDAyXFx1MkNGNFxceDAyXFx1MkNGNVxceDAyXFx1MkQwMlxceDAyXFx1MkQyN1xceDAyXCIgK1xyXG5cdFx0XCJcXHUyRDI5XFx4MDJcXHUyRDI5XFx4MDJcXHUyRDJGXFx4MDJcXHUyRDJGXFx4MDJcXHUyRDMyXFx4MDJcXHUyRDY5XFx4MDJcXHUyRDcxXFx4MDJcIiArXHJcblx0XHRcIlxcdTJENzFcXHgwMlxcdTJEODJcXHgwMlxcdTJEOThcXHgwMlxcdTJEQTJcXHgwMlxcdTJEQThcXHgwMlxcdTJEQUFcXHgwMlxcdTJEQjBcXHgwMlwiICtcclxuXHRcdFwiXFx1MkRCMlxceDAyXFx1MkRCOFxceDAyXFx1MkRCQVxceDAyXFx1MkRDMFxceDAyXFx1MkRDMlxceDAyXFx1MkRDOFxceDAyXFx1MkRDQVxceDAyXCIgK1xyXG5cdFx0XCJcXHUyREQwXFx4MDJcXHUyREQyXFx4MDJcXHUyREQ4XFx4MDJcXHUyRERBXFx4MDJcXHUyREUwXFx4MDJcXHUyRTMxXFx4MDJcXHUyRTMxXFx4MDJcIiArXHJcblx0XHRcIlxcdTMwMDdcXHgwMlxcdTMwMDlcXHgwMlxcdTMwMjNcXHgwMlxcdTMwMkJcXHgwMlxcdTMwMzNcXHgwMlxcdTMwMzdcXHgwMlxcdTMwM0FcXHgwMlwiICtcclxuXHRcdFwiXFx1MzAzRVxceDAyXFx1MzA0M1xceDAyXFx1MzA5OFxceDAyXFx1MzA5RlxceDAyXFx1MzBBMVxceDAyXFx1MzBBM1xceDAyXFx1MzBGQ1xceDAyXCIgK1xyXG5cdFx0XCJcXHUzMEZFXFx4MDJcXHUzMTAxXFx4MDJcXHUzMTA3XFx4MDJcXHUzMTJGXFx4MDJcXHUzMTMzXFx4MDJcXHUzMTkwXFx4MDJcXHUzMUEyXFx4MDJcIiArXHJcblx0XHRcIlxcdTMxQkNcXHgwMlxcdTMxRjJcXHgwMlxcdTMyMDFcXHgwMlxcdTM0MDJcXHgwMlxcdTREQjdcXHgwMlxcdTRFMDJcXHgwMlxcdTlGRDdcXHgwMlwiICtcclxuXHRcdFwiXFx1QTAwMlxceDAyXFx1QTQ4RVxceDAyXFx1QTREMlxceDAyXFx1QTRGRlxceDAyXFx1QTUwMlxceDAyXFx1QTYwRVxceDAyXFx1QTYxMlxceDAyXCIgK1xyXG5cdFx0XCJcXHVBNjIxXFx4MDJcXHVBNjJDXFx4MDJcXHVBNjJEXFx4MDJcXHVBNjQyXFx4MDJcXHVBNjcwXFx4MDJcXHVBNjgxXFx4MDJcXHVBNjlGXFx4MDJcIiArXHJcblx0XHRcIlxcdUE2QTJcXHgwMlxcdUE2RjFcXHgwMlxcdUE3MTlcXHgwMlxcdUE3MjFcXHgwMlxcdUE3MjRcXHgwMlxcdUE3OEFcXHgwMlxcdUE3OERcXHgwMlwiICtcclxuXHRcdFwiXFx1QTdCMFxceDAyXFx1QTdCMlxceDAyXFx1QTdCOVxceDAyXFx1QTdGOVxceDAyXFx1QTgwM1xceDAyXFx1QTgwNVxceDAyXFx1QTgwN1xceDAyXCIgK1xyXG5cdFx0XCJcXHVBODA5XFx4MDJcXHVBODBDXFx4MDJcXHVBODBFXFx4MDJcXHVBODI0XFx4MDJcXHVBODQyXFx4MDJcXHVBODc1XFx4MDJcXHVBODg0XFx4MDJcIiArXHJcblx0XHRcIlxcdUE4QjVcXHgwMlxcdUE4RjRcXHgwMlxcdUE4RjlcXHgwMlxcdUE4RkRcXHgwMlxcdUE4RkRcXHgwMlxcdUE4RkZcXHgwMlxcdUE4RkZcXHgwMlwiICtcclxuXHRcdFwiXFx1QTkwQ1xceDAyXFx1QTkyN1xceDAyXFx1QTkzMlxceDAyXFx1QTk0OFxceDAyXFx1QTk2MlxceDAyXFx1QTk3RVxceDAyXFx1QTk4NlxceDAyXCIgK1xyXG5cdFx0XCJcXHVBOUI0XFx4MDJcXHVBOUQxXFx4MDJcXHVBOUQxXFx4MDJcXHVBOUUyXFx4MDJcXHVBOUU2XFx4MDJcXHVBOUU4XFx4MDJcXHVBOUYxXFx4MDJcIiArXHJcblx0XHRcIlxcdUE5RkNcXHgwMlxcdUFBMDBcXHgwMlxcdUFBMDJcXHgwMlxcdUFBMkFcXHgwMlxcdUFBNDJcXHgwMlxcdUFBNDRcXHgwMlxcdUFBNDZcXHgwMlwiICtcclxuXHRcdFwiXFx1QUE0RFxceDAyXFx1QUE2MlxceDAyXFx1QUE3OFxceDAyXFx1QUE3Q1xceDAyXFx1QUE3Q1xceDAyXFx1QUE4MFxceDAyXFx1QUFCMVxceDAyXCIgK1xyXG5cdFx0XCJcXHVBQUIzXFx4MDJcXHVBQUIzXFx4MDJcXHVBQUI3XFx4MDJcXHVBQUI4XFx4MDJcXHVBQUJCXFx4MDJcXHVBQUJGXFx4MDJcXHVBQUMyXFx4MDJcIiArXHJcblx0XHRcIlxcdUFBQzJcXHgwMlxcdUFBQzRcXHgwMlxcdUFBQzRcXHgwMlxcdUFBRERcXHgwMlxcdUFBREZcXHgwMlxcdUFBRTJcXHgwMlxcdUFBRUNcXHgwMlwiICtcclxuXHRcdFwiXFx1QUFGNFxceDAyXFx1QUFGNlxceDAyXFx1QUIwM1xceDAyXFx1QUIwOFxceDAyXFx1QUIwQlxceDAyXFx1QUIxMFxceDAyXFx1QUIxM1xceDAyXCIgK1xyXG5cdFx0XCJcXHVBQjE4XFx4MDJcXHVBQjIyXFx4MDJcXHVBQjI4XFx4MDJcXHVBQjJBXFx4MDJcXHVBQjMwXFx4MDJcXHVBQjMyXFx4MDJcXHVBQjVDXFx4MDJcIiArXHJcblx0XHRcIlxcdUFCNUVcXHgwMlxcdUFCNjdcXHgwMlxcdUFCNzJcXHgwMlxcdUFCRTRcXHgwMlxcdUFDMDJcXHgwMlxcdUQ3QTVcXHgwMlxcdUQ3QjJcXHgwMlwiICtcclxuXHRcdFwiXFx1RDdDOFxceDAyXFx1RDdDRFxceDAyXFx1RDdGRFxceDAyXFx1RjkwMlxceDAyXFx1RkE2RlxceDAyXFx1RkE3MlxceDAyXFx1RkFEQlxceDAyXCIgK1xyXG5cdFx0XCJcXHVGQjAyXFx4MDJcXHVGQjA4XFx4MDJcXHVGQjE1XFx4MDJcXHVGQjE5XFx4MDJcXHVGQjFGXFx4MDJcXHVGQjFGXFx4MDJcXHVGQjIxXFx4MDJcIiArXHJcblx0XHRcIlxcdUZCMkFcXHgwMlxcdUZCMkNcXHgwMlxcdUZCMzhcXHgwMlxcdUZCM0FcXHgwMlxcdUZCM0VcXHgwMlxcdUZCNDBcXHgwMlxcdUZCNDBcXHgwMlwiICtcclxuXHRcdFwiXFx1RkI0MlxceDAyXFx1RkI0M1xceDAyXFx1RkI0NVxceDAyXFx1RkI0NlxceDAyXFx1RkI0OFxceDAyXFx1RkJCM1xceDAyXFx1RkJENVxceDAyXCIgK1xyXG5cdFx0XCJcXHVGRDNGXFx4MDJcXHVGRDUyXFx4MDJcXHVGRDkxXFx4MDJcXHVGRDk0XFx4MDJcXHVGREM5XFx4MDJcXHVGREYyXFx4MDJcXHVGREZEXFx4MDJcIiArXHJcblx0XHRcIlxcdUZFNzJcXHgwMlxcdUZFNzZcXHgwMlxcdUZFNzhcXHgwMlxcdUZFRkVcXHgwMlxcdUZGMjNcXHgwMlxcdUZGM0NcXHgwMlxcdUZGNDNcXHgwMlwiICtcclxuXHRcdFwiXFx1RkY1Q1xceDAyXFx1RkY2OFxceDAyXFx1RkZDMFxceDAyXFx1RkZDNFxceDAyXFx1RkZDOVxceDAyXFx1RkZDQ1xceDAyXFx1RkZEMVxceDAyXCIgK1xyXG5cdFx0XCJcXHVGRkQ0XFx4MDJcXHVGRkQ5XFx4MDJcXHVGRkRDXFx4MDJcXHVGRkRFXFx4MDJcXHgwMlxceDAzXFxyXFx4MDNcXHgwRlxceDAzKFxceDAzKlxceDAzXCIgK1xyXG5cdFx0XCI8XFx4MDM+XFx4MDM/XFx4MDNBXFx4MDNPXFx4MDNSXFx4MDNfXFx4MDNcXHg4MlxceDAzXFx4RkNcXHgwM1xcdTAxNDJcXHgwM1xcdTAxNzZcXHgwM1wiICtcclxuXHRcdFwiXFx1MDI4MlxceDAzXFx1MDI5RVxceDAzXFx1MDJBMlxceDAzXFx1MDJEMlxceDAzXFx1MDMwMlxceDAzXFx1MDMyMVxceDAzXFx1MDMzMlxceDAzXCIgK1xyXG5cdFx0XCJcXHUwMzRDXFx4MDNcXHUwMzUyXFx4MDNcXHUwMzc3XFx4MDNcXHUwMzgyXFx4MDNcXHUwMzlGXFx4MDNcXHUwM0EyXFx4MDNcXHUwM0M1XFx4MDNcIiArXHJcblx0XHRcIlxcdTAzQ0FcXHgwM1xcdTAzRDFcXHgwM1xcdTAzRDNcXHgwM1xcdTAzRDdcXHgwM1xcdTA0MDJcXHgwM1xcdTA0OUZcXHgwM1xcdTA0QjJcXHgwM1wiICtcclxuXHRcdFwiXFx1MDRENVxceDAzXFx1MDREQVxceDAzXFx1MDRGRFxceDAzXFx1MDUwMlxceDAzXFx1MDUyOVxceDAzXFx1MDUzMlxceDAzXFx1MDU2NVxceDAzXCIgK1xyXG5cdFx0XCJcXHUwNjAyXFx4MDNcXHUwNzM4XFx4MDNcXHUwNzQyXFx4MDNcXHUwNzU3XFx4MDNcXHUwNzYyXFx4MDNcXHUwNzY5XFx4MDNcXHUwODAyXFx4MDNcIiArXHJcblx0XHRcIlxcdTA4MDdcXHgwM1xcdTA4MEFcXHgwM1xcdTA4MEFcXHgwM1xcdTA4MENcXHgwM1xcdTA4MzdcXHgwM1xcdTA4MzlcXHgwM1xcdTA4M0FcXHgwM1wiICtcclxuXHRcdFwiXFx1MDgzRVxceDAzXFx1MDgzRVxceDAzXFx1MDg0MVxceDAzXFx1MDg1N1xceDAzXFx1MDg2MlxceDAzXFx1MDg3OFxceDAzXFx1MDg4MlxceDAzXCIgK1xyXG5cdFx0XCJcXHUwOEEwXFx4MDNcXHUwOEUyXFx4MDNcXHUwOEY0XFx4MDNcXHUwOEY2XFx4MDNcXHUwOEY3XFx4MDNcXHUwOTAyXFx4MDNcXHUwOTE3XFx4MDNcIiArXHJcblx0XHRcIlxcdTA5MjJcXHgwM1xcdTA5M0JcXHgwM1xcdTA5ODJcXHgwM1xcdTA5QjlcXHgwM1xcdTA5QzBcXHgwM1xcdTA5QzFcXHgwM1xcdTBBMDJcXHgwM1wiICtcclxuXHRcdFwiXFx1MEEwMlxceDAzXFx1MEExMlxceDAzXFx1MEExNVxceDAzXFx1MEExN1xceDAzXFx1MEExOVxceDAzXFx1MEExQlxceDAzXFx1MEEzNVxceDAzXCIgK1xyXG5cdFx0XCJcXHUwQTYyXFx4MDNcXHUwQTdFXFx4MDNcXHUwQTgyXFx4MDNcXHUwQTlFXFx4MDNcXHUwQUMyXFx4MDNcXHUwQUM5XFx4MDNcXHUwQUNCXFx4MDNcIiArXHJcblx0XHRcIlxcdTBBRTZcXHgwM1xcdTBCMDJcXHgwM1xcdTBCMzdcXHgwM1xcdTBCNDJcXHgwM1xcdTBCNTdcXHgwM1xcdTBCNjJcXHgwM1xcdTBCNzRcXHgwM1wiICtcclxuXHRcdFwiXFx1MEI4MlxceDAzXFx1MEI5M1xceDAzXFx1MEMwMlxceDAzXFx1MEM0QVxceDAzXFx1MEM4MlxceDAzXFx1MENCNFxceDAzXFx1MENDMlxceDAzXCIgK1xyXG5cdFx0XCJcXHUwQ0Y0XFx4MDNcXHUxMDA1XFx4MDNcXHUxMDM5XFx4MDNcXHUxMDg1XFx4MDNcXHUxMEIxXFx4MDNcXHUxMEQyXFx4MDNcXHUxMEVBXFx4MDNcIiArXHJcblx0XHRcIlxcdTExMDVcXHgwM1xcdTExMjhcXHgwM1xcdTExNTJcXHgwM1xcdTExNzRcXHgwM1xcdTExNzhcXHgwM1xcdTExNzhcXHgwM1xcdTExODVcXHgwM1wiICtcclxuXHRcdFwiXFx1MTFCNFxceDAzXFx1MTFDM1xceDAzXFx1MTFDNlxceDAzXFx1MTFEQ1xceDAzXFx1MTFEQ1xceDAzXFx1MTFERVxceDAzXFx1MTFERVxceDAzXCIgK1xyXG5cdFx0XCJcXHUxMjAyXFx4MDNcXHUxMjEzXFx4MDNcXHUxMjE1XFx4MDNcXHUxMjJEXFx4MDNcXHUxMjgyXFx4MDNcXHUxMjg4XFx4MDNcXHUxMjhBXFx4MDNcIiArXHJcblx0XHRcIlxcdTEyOEFcXHgwM1xcdTEyOENcXHgwM1xcdTEyOEZcXHgwM1xcdTEyOTFcXHgwM1xcdTEyOUZcXHgwM1xcdTEyQTFcXHgwM1xcdTEyQUFcXHgwM1wiICtcclxuXHRcdFwiXFx1MTJCMlxceDAzXFx1MTJFMFxceDAzXFx1MTMwN1xceDAzXFx1MTMwRVxceDAzXFx1MTMxMVxceDAzXFx1MTMxMlxceDAzXFx1MTMxNVxceDAzXCIgK1xyXG5cdFx0XCJcXHUxMzJBXFx4MDNcXHUxMzJDXFx4MDNcXHUxMzMyXFx4MDNcXHUxMzM0XFx4MDNcXHUxMzM1XFx4MDNcXHUxMzM3XFx4MDNcXHUxMzNCXFx4MDNcIiArXHJcblx0XHRcIlxcdTEzM0ZcXHgwM1xcdTEzM0ZcXHgwM1xcdTEzNTJcXHgwM1xcdTEzNTJcXHgwM1xcdTEzNUZcXHgwM1xcdTEzNjNcXHgwM1xcdTE0MDJcXHgwM1wiICtcclxuXHRcdFwiXFx1MTQzNlxceDAzXFx1MTQ0OVxceDAzXFx1MTQ0Q1xceDAzXFx1MTQ4MlxceDAzXFx1MTRCMVxceDAzXFx1MTRDNlxceDAzXFx1MTRDN1xceDAzXCIgK1xyXG5cdFx0XCJcXHUxNEM5XFx4MDNcXHUxNEM5XFx4MDNcXHUxNTgyXFx4MDNcXHUxNUIwXFx4MDNcXHUxNURBXFx4MDNcXHUxNUREXFx4MDNcXHUxNjAyXFx4MDNcIiArXHJcblx0XHRcIlxcdTE2MzFcXHgwM1xcdTE2NDZcXHgwM1xcdTE2NDZcXHgwM1xcdTE2ODJcXHgwM1xcdTE2QUNcXHgwM1xcdTE3MDJcXHgwM1xcdTE3MUJcXHgwM1wiICtcclxuXHRcdFwiXFx1MThBMlxceDAzXFx1MThFMVxceDAzXFx1MTkwMVxceDAzXFx1MTkwMVxceDAzXFx1MUFDMlxceDAzXFx1MUFGQVxceDAzXFx1MUMwMlxceDAzXCIgK1xyXG5cdFx0XCJcXHUxQzBBXFx4MDNcXHUxQzBDXFx4MDNcXHUxQzMwXFx4MDNcXHUxQzQyXFx4MDNcXHUxQzQyXFx4MDNcXHUxQzc0XFx4MDNcXHUxQzkxXFx4MDNcIiArXHJcblx0XHRcIlxcdTIwMDJcXHgwM1xcdTIzOUJcXHgwM1xcdTI0MDJcXHgwM1xcdTI0NzBcXHgwM1xcdTI0ODJcXHgwM1xcdTI1NDVcXHgwM1xcdTMwMDJcXHgwM1wiICtcclxuXHRcdFwiXFx1MzQzMFxceDAzXFx1NDQwMlxceDAzXFx1NDY0OFxceDAzXFx1NjgwMlxceDAzXFx1NkEzQVxceDAzXFx1NkE0MlxceDAzXFx1NkE2MFxceDAzXCIgK1xyXG5cdFx0XCJcXHU2QUQyXFx4MDNcXHU2QUVGXFx4MDNcXHU2QjAyXFx4MDNcXHU2QjMxXFx4MDNcXHU2QjQyXFx4MDNcXHU2QjQ1XFx4MDNcXHU2QjY1XFx4MDNcIiArXHJcblx0XHRcIlxcdTZCNzlcXHgwM1xcdTZCN0ZcXHgwM1xcdTZCOTFcXHgwM1xcdTZGMDJcXHgwM1xcdTZGNDZcXHgwM1xcdTZGNTJcXHgwM1xcdTZGNTJcXHgwM1wiICtcclxuXHRcdFwiXFx1NkY5NVxceDAzXFx1NkZBMVxceDAzXFx1NkZFMlxceDAzXFx1NkZFMlxceDAzXFx1NzAwMlxceDAzXFx1ODdFRVxceDAzXFx1ODgwMlxceDAzXCIgK1xyXG5cdFx0XCJcXHU4QUY0XFx4MDNcXHVCMDAyXFx4MDNcXHVCMDAzXFx4MDNcXHVCQzAyXFx4MDNcXHVCQzZDXFx4MDNcXHVCQzcyXFx4MDNcXHVCQzdFXFx4MDNcIiArXHJcblx0XHRcIlxcdUJDODJcXHgwM1xcdUJDOEFcXHgwM1xcdUJDOTJcXHgwM1xcdUJDOUJcXHgwM1xcdUQ0MDJcXHgwM1xcdUQ0NTZcXHgwM1xcdUQ0NThcXHgwM1wiICtcclxuXHRcdFwiXFx1RDQ5RVxceDAzXFx1RDRBMFxceDAzXFx1RDRBMVxceDAzXFx1RDRBNFxceDAzXFx1RDRBNFxceDAzXFx1RDRBN1xceDAzXFx1RDRBOFxceDAzXCIgK1xyXG5cdFx0XCJcXHVENEFCXFx4MDNcXHVENEFFXFx4MDNcXHVENEIwXFx4MDNcXHVENEJCXFx4MDNcXHVENEJEXFx4MDNcXHVENEJEXFx4MDNcXHVENEJGXFx4MDNcIiArXHJcblx0XHRcIlxcdUQ0QzVcXHgwM1xcdUQ0QzdcXHgwM1xcdUQ1MDdcXHgwM1xcdUQ1MDlcXHgwM1xcdUQ1MENcXHgwM1xcdUQ1MEZcXHgwM1xcdUQ1MTZcXHgwM1wiICtcclxuXHRcdFwiXFx1RDUxOFxceDAzXFx1RDUxRVxceDAzXFx1RDUyMFxceDAzXFx1RDUzQlxceDAzXFx1RDUzRFxceDAzXFx1RDU0MFxceDAzXFx1RDU0MlxceDAzXCIgK1xyXG5cdFx0XCJcXHVENTQ2XFx4MDNcXHVENTQ4XFx4MDNcXHVENTQ4XCI7XHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgX3NlcmlhbGl6ZWRBVE5TZWdtZW50MTogc3RyaW5nID1cclxuXHRcdFwiXFx4MDNcXHVENTRDXFx4MDNcXHVENTUyXFx4MDNcXHVENTU0XFx4MDNcXHVENkE3XFx4MDNcXHVENkFBXFx4MDNcXHVENkMyXFx4MDNcXHVENkM0XCIgK1xyXG5cdFx0XCJcXHgwM1xcdUQ2RENcXHgwM1xcdUQ2REVcXHgwM1xcdUQ2RkNcXHgwM1xcdUQ2RkVcXHgwM1xcdUQ3MTZcXHgwM1xcdUQ3MThcXHgwM1xcdUQ3MzZcIiArXHJcblx0XHRcIlxceDAzXFx1RDczOFxceDAzXFx1RDc1MFxceDAzXFx1RDc1MlxceDAzXFx1RDc3MFxceDAzXFx1RDc3MlxceDAzXFx1RDc4QVxceDAzXFx1RDc4Q1wiICtcclxuXHRcdFwiXFx4MDNcXHVEN0FBXFx4MDNcXHVEN0FDXFx4MDNcXHVEN0M0XFx4MDNcXHVEN0M2XFx4MDNcXHVEN0NEXFx4MDNcXHVFODAyXFx4MDNcXHVFOEM2XCIgK1xyXG5cdFx0XCJcXHgwM1xcdUU5MDJcXHgwM1xcdUU5NDVcXHgwM1xcdUVFMDJcXHgwM1xcdUVFMDVcXHgwM1xcdUVFMDdcXHgwM1xcdUVFMjFcXHgwM1xcdUVFMjNcIiArXHJcblx0XHRcIlxceDAzXFx1RUUyNFxceDAzXFx1RUUyNlxceDAzXFx1RUUyNlxceDAzXFx1RUUyOVxceDAzXFx1RUUyOVxceDAzXFx1RUUyQlxceDAzXFx1RUUzNFwiICtcclxuXHRcdFwiXFx4MDNcXHVFRTM2XFx4MDNcXHVFRTM5XFx4MDNcXHVFRTNCXFx4MDNcXHVFRTNCXFx4MDNcXHVFRTNEXFx4MDNcXHVFRTNEXFx4MDNcXHVFRTQ0XCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFNDRcXHgwM1xcdUVFNDlcXHgwM1xcdUVFNDlcXHgwM1xcdUVFNEJcXHgwM1xcdUVFNEJcXHgwM1xcdUVFNERcXHgwM1xcdUVFNERcIiArXHJcblx0XHRcIlxceDAzXFx1RUU0RlxceDAzXFx1RUU1MVxceDAzXFx1RUU1M1xceDAzXFx1RUU1NFxceDAzXFx1RUU1NlxceDAzXFx1RUU1NlxceDAzXFx1RUU1OVwiICtcclxuXHRcdFwiXFx4MDNcXHVFRTU5XFx4MDNcXHVFRTVCXFx4MDNcXHVFRTVCXFx4MDNcXHVFRTVEXFx4MDNcXHVFRTVEXFx4MDNcXHVFRTVGXFx4MDNcXHVFRTVGXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFNjFcXHgwM1xcdUVFNjFcXHgwM1xcdUVFNjNcXHgwM1xcdUVFNjRcXHgwM1xcdUVFNjZcXHgwM1xcdUVFNjZcXHgwM1xcdUVFNjlcIiArXHJcblx0XHRcIlxceDAzXFx1RUU2Q1xceDAzXFx1RUU2RVxceDAzXFx1RUU3NFxceDAzXFx1RUU3NlxceDAzXFx1RUU3OVxceDAzXFx1RUU3QlxceDAzXFx1RUU3RVwiICtcclxuXHRcdFwiXFx4MDNcXHVFRTgwXFx4MDNcXHVFRTgwXFx4MDNcXHVFRTgyXFx4MDNcXHVFRThCXFx4MDNcXHVFRThEXFx4MDNcXHVFRTlEXFx4MDNcXHVFRUEzXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFQTVcXHgwM1xcdUVFQTdcXHgwM1xcdUVFQUJcXHgwM1xcdUVFQURcXHgwM1xcdUVFQkRcXHgwM1xceDAyXFx4MDRcXHVBNkQ4XFx4MDRcIiArXHJcblx0XHRcIlxcdUE3MDJcXHgwNFxcdUI3MzZcXHgwNFxcdUI3NDJcXHgwNFxcdUI4MUZcXHgwNFxcdUI4MjJcXHgwNFxcdUNFQTNcXHgwNFxcdUY4MDJcXHgwNFwiICtcclxuXHRcdFwiXFx1RkExRlxceDA0MVxceDAyXFx4MDNcXHgwM1xceDAyXFx4MDJcXHgwMlxceDAyXFx4MDVcXHgwM1xceDAyXFx4MDJcXHgwMlxceDAyXFx4MDdcXHgwM1wiICtcclxuXHRcdFwiXFx4MDJcXHgwMlxceDAyXFx4MDJcXHRcXHgwM1xceDAyXFx4MDJcXHgwMlxceDAyXFx2XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDExXFx4MDNcXHgwMlwiICtcclxuXHRcdFwiXFx4MDJcXHgwMlxceDAzXFx4MTNcXHgwM1xceDAyXFx4MDJcXHgwMlxceDA1XFx4MTZcXHgwM1xceDAyXFx4MDJcXHgwMlxceDA3XFx4MThcXHgwM1xceDAyXCIgK1xyXG5cdFx0XCJcXHgwMlxceDAyXFx0XFx4MUFcXHgwM1xceDAyXFx4MDJcXHgwMlxcdlxceDFDXFx4MDNcXHgwMlxceDAyXFx4MDJcXHIlXFx4MDNcXHgwMlxceDAyXFx4MDJcIiArXHJcblx0XHRcIlxceDBGXFwnXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxMSlcXHgwM1xceDAyXFx4MDJcXHgwMlxceDEzXFx4MTRcXHgwNzFcXHgwMlxceDAyXFx4MTRcXHgxNVwiICtcclxuXHRcdFwiXFx4MDcxXFx4MDJcXHgwMlxceDE1XFx4MDRcXHgwM1xceDAyXFx4MDJcXHgwMlxceDE2XFx4MTdcXHgwNzFcXHgwMlxceDAyXFx4MTdcXHgwNlxceDAzXCIgK1xyXG5cdFx0XCJcXHgwMlxceDAyXFx4MDJcXHgxOFxceDE5XFx4MDcsXFx4MDJcXHgwMlxceDE5XFxiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxQVxceDFCXFx4MDcjXFx4MDJcIiArXHJcblx0XHRcIlxceDAyXFx4MUJcXG5cXHgwM1xceDAyXFx4MDJcXHgwMlxceDFDIFxceDA1XFx4MEZcXGJcXHgwMlxceDFEXFx4MUZcXHgwNVxcclxceDA3XFx4MDJcXHgxRVwiICtcclxuXHRcdFwiXFx4MURcXHgwM1xceDAyXFx4MDJcXHgwMlxceDFGXFxcIlxceDAzXFx4MDJcXHgwMlxceDAyIFxceDFFXFx4MDNcXHgwMlxceDAyXFx4MDIgIVxceDAzXCIgK1xyXG5cdFx0XCJcXHgwMlxceDAyXFx4MDIhI1xceDAzXFx4MDJcXHgwMlxceDAyXFxcIiBcXHgwM1xceDAyXFx4MDJcXHgwMiMkXFxiXFx4MDZcXHgwMlxceDAyJFxcZlxceDAzXCIgK1xyXG5cdFx0XCJcXHgwMlxceDAyXFx4MDIlJlxcdFxceDAyXFx4MDJcXHgwMiZcXHgwRVxceDAzXFx4MDJcXHgwMlxceDAyXFwnKFxcdFxceDAzXFx4MDJcXHgwMihcXHgxMFwiICtcclxuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDIpLVxceDA3KVxceDAyXFx4MDIqLFxcdlxceDAyXFx4MDJcXHgwMisqXFx4MDNcXHgwMlxceDAyXFx4MDIsL1xceDAzXCIgK1xyXG5cdFx0XCJcXHgwMlxceDAyXFx4MDItLlxceDAzXFx4MDJcXHgwMlxceDAyLStcXHgwM1xceDAyXFx4MDJcXHgwMi4wXFx4MDNcXHgwMlxceDAyXFx4MDIvLVxceDAzXCIgK1xyXG5cdFx0XCJcXHgwMlxceDAyXFx4MDIwMVxceDA3KVxceDAyXFx4MDIxXFx4MTJcXHgwM1xceDAyXFx4MDJcXHgwMlxceDA1XFx4MDIgLVxceDAzXFx4MDNcXHgwNlwiICtcclxuXHRcdFwiXFx4MDJcIjtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IF9zZXJpYWxpemVkQVROOiBzdHJpbmcgPSBVdGlscy5qb2luKFxyXG5cdFx0W1xyXG5cdFx0XHRYUGF0aExleGVyLl9zZXJpYWxpemVkQVROU2VnbWVudDAsXHJcblx0XHRcdFhQYXRoTGV4ZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50MSxcclxuXHRcdF0sXHJcblx0XHRcIlwiLFxyXG5cdCk7XHJcblx0cHVibGljIHN0YXRpYyBfX0FUTjogQVROO1xyXG5cdHB1YmxpYyBzdGF0aWMgZ2V0IF9BVE4oKTogQVROIHtcclxuXHRcdGlmICghWFBhdGhMZXhlci5fX0FUTikge1xyXG5cdFx0XHRYUGF0aExleGVyLl9fQVROID0gbmV3IEFUTkRlc2VyaWFsaXplcigpLmRlc2VyaWFsaXplKFV0aWxzLnRvQ2hhckFycmF5KFhQYXRoTGV4ZXIuX3NlcmlhbGl6ZWRBVE4pKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gWFBhdGhMZXhlci5fX0FUTjtcclxuXHR9XHJcblxyXG59XHJcblxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDT05WRVJTVElPTiBjb21wbGV0ZSwgQnVydCBIYXJyaXMgMTAvMTQvMjAxNlxyXG5cclxuaW1wb3J0IHsgQU5UTFJFcnJvckxpc3RlbmVyIH0gZnJvbSBcIi4uLy4uL0FOVExSRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi4vLi4vUmVjb2duaXplclwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuLi8uLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFhQYXRoTGV4ZXJFcnJvckxpc3RlbmVyIGltcGxlbWVudHMgQU5UTFJFcnJvckxpc3RlbmVyPG51bWJlcj4ge1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBzeW50YXhFcnJvcjxUIGV4dGVuZHMgbnVtYmVyPihcclxuXHRcdHJlY29nbml6ZXI6IFJlY29nbml6ZXI8VCwgYW55Piwgb2ZmZW5kaW5nU3ltYm9sOiBUIHwgdW5kZWZpbmVkLFxyXG5cdFx0bGluZTogbnVtYmVyLCBjaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlciwgbXNnOiBzdHJpbmcsXHJcblx0XHRlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB8IHVuZGVmaW5lZCk6IHZvaWQge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDT05WRVJTVElPTiBjb21wbGV0ZSwgQnVydCBIYXJyaXMgMTAvMTQvMjAxNlxyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuLi9QYXJzZVRyZWVcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBYUGF0aEVsZW1lbnQge1xyXG5cdHByb3RlY3RlZCBub2RlTmFtZTogc3RyaW5nO1xyXG5cdHB1YmxpYyBpbnZlcnQ6IGJvb2xlYW47XHJcblxyXG5cdC8qKiBDb25zdHJ1Y3QgZWxlbWVudCBsaWtlIGAvSURgIG9yIGBJRGAgb3IgYC8qYCBldGMuLi5cclxuXHQgKiAgb3AgaXMgbnVsbCBpZiBqdXN0IG5vZGVcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcihub2RlTmFtZTogc3RyaW5nKSB7XHJcblx0XHR0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XHJcblx0XHR0aGlzLmludmVydCA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2l2ZW4gdHJlZSByb290ZWQgYXQgYHRgIHJldHVybiBhbGwgbm9kZXMgbWF0Y2hlZCBieSB0aGlzIHBhdGhcclxuXHQgKiBlbGVtZW50LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBhYnN0cmFjdCBldmFsdWF0ZSh0OiBQYXJzZVRyZWUpOiBQYXJzZVRyZWVbXTtcclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRsZXQgaW52OiBzdHJpbmcgPSB0aGlzLmludmVydCA/IFwiIVwiIDogXCJcIjtcclxuXHRcdGxldCBjbGFzc05hbWU6IHN0cmluZyA9IE9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lO1xyXG5cdFx0cmV0dXJuIGNsYXNzTmFtZSArIFwiW1wiICsgaW52ICsgdGhpcy5ub2RlTmFtZSArIFwiXVwiO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDT05WRVJTVElPTiBjb21wbGV0ZSwgQnVydCBIYXJyaXMgMTAvMTQvMjAxNlxyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuLi8uLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuLi9QYXJzZVRyZWVcIjtcclxuaW1wb3J0IHsgVHJlZXMgfSBmcm9tIFwiLi4vVHJlZXNcIjtcclxuaW1wb3J0IHsgWFBhdGhFbGVtZW50IH0gZnJvbSBcIi4vWFBhdGhFbGVtZW50XCI7XHJcblxyXG4vKipcclxuICogRWl0aGVyIGBJRGAgYXQgc3RhcnQgb2YgcGF0aCBvciBgLi4uLy9JRGAgaW4gbWlkZGxlIG9mIHBhdGguXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgWFBhdGhSdWxlQW55d2hlcmVFbGVtZW50IGV4dGVuZHMgWFBhdGhFbGVtZW50IHtcclxuXHRwcm90ZWN0ZWQgcnVsZUluZGV4OiBudW1iZXI7XHJcblx0Y29uc3RydWN0b3IocnVsZU5hbWU6IHN0cmluZywgcnVsZUluZGV4OiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKHJ1bGVOYW1lKTtcclxuXHRcdHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGV2YWx1YXRlKHQ6IFBhcnNlVHJlZSk6IFBhcnNlVHJlZVtdIHtcclxuXHRcdHJldHVybiBUcmVlcy5maW5kQWxsUnVsZU5vZGVzKHQsIHRoaXMucnVsZUluZGV4KTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ09OVkVSU1RJT04gY29tcGxldGUsIEJ1cnQgSGFycmlzIDEwLzE0LzIwMTZcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vLi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWUgfSBmcm9tIFwiLi4vUGFyc2VUcmVlXCI7XHJcbmltcG9ydCB7IFRyZWVzIH0gZnJvbSBcIi4uL1RyZWVzXCI7XHJcbmltcG9ydCB7IFhQYXRoRWxlbWVudCB9IGZyb20gXCIuL1hQYXRoRWxlbWVudFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFhQYXRoUnVsZUVsZW1lbnQgZXh0ZW5kcyBYUGF0aEVsZW1lbnQge1xyXG5cdHByb3RlY3RlZCBydWxlSW5kZXg6IG51bWJlcjtcclxuXHRjb25zdHJ1Y3RvcihydWxlTmFtZTogc3RyaW5nLCBydWxlSW5kZXg6IG51bWJlcikge1xyXG5cdFx0c3VwZXIocnVsZU5hbWUpO1xyXG5cdFx0dGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXZhbHVhdGUodDogUGFyc2VUcmVlKTogUGFyc2VUcmVlW10ge1xyXG5cdFx0Ly8gcmV0dXJuIGFsbCBjaGlsZHJlbiBvZiB0IHRoYXQgbWF0Y2ggbm9kZU5hbWVcclxuXHRcdGxldCBub2RlczogUGFyc2VUcmVlW10gPSBbXTtcclxuXHRcdGZvciAobGV0IGMgb2YgVHJlZXMuZ2V0Q2hpbGRyZW4odCkpIHtcclxuXHRcdFx0aWYgKGMgaW5zdGFuY2VvZiBQYXJzZXJSdWxlQ29udGV4dCkge1xyXG5cdFx0XHRcdGlmICgoYy5ydWxlSW5kZXggPT09IHRoaXMucnVsZUluZGV4ICYmICF0aGlzLmludmVydCkgfHxcclxuXHRcdFx0XHRcdChjLnJ1bGVJbmRleCAhPT0gdGhpcy5ydWxlSW5kZXggJiYgdGhpcy5pbnZlcnQpKSB7XHJcblx0XHRcdFx0XHRub2Rlcy5wdXNoKGMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5vZGVzO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDT05WRVJTVElPTiBjb21wbGV0ZSwgQnVydCBIYXJyaXMgMTAvMTQvMjAxNlxyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuLi9QYXJzZVRyZWVcIjtcclxuaW1wb3J0IHsgVHJlZXMgfSBmcm9tIFwiLi4vVHJlZXNcIjtcclxuaW1wb3J0IHsgWFBhdGhFbGVtZW50IH0gZnJvbSBcIi4vWFBhdGhFbGVtZW50XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgWFBhdGhUb2tlbkFueXdoZXJlRWxlbWVudCBleHRlbmRzIFhQYXRoRWxlbWVudCB7XHJcblx0cHJvdGVjdGVkIHRva2VuVHlwZTogbnVtYmVyO1xyXG5cdGNvbnN0cnVjdG9yKHRva2VuTmFtZTogc3RyaW5nLCB0b2tlblR5cGU6IG51bWJlcikge1xyXG5cdFx0c3VwZXIodG9rZW5OYW1lKTtcclxuXHRcdHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGV2YWx1YXRlKHQ6IFBhcnNlVHJlZSk6IFBhcnNlVHJlZVtdIHtcclxuXHRcdHJldHVybiBUcmVlcy5maW5kQWxsVG9rZW5Ob2Rlcyh0LCB0aGlzLnRva2VuVHlwZSk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENPTlZFUlNUSU9OIGNvbXBsZXRlLCBCdXJ0IEhhcnJpcyAxMC8xNC8yMDE2XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uLy4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlIH0gZnJvbSBcIi4uL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBUZXJtaW5hbE5vZGUgfSBmcm9tIFwiLi4vVGVybWluYWxOb2RlXCI7XHJcbmltcG9ydCB7IFRyZWVzIH0gZnJvbSBcIi4uL1RyZWVzXCI7XHJcbmltcG9ydCB7IFhQYXRoRWxlbWVudCB9IGZyb20gXCIuL1hQYXRoRWxlbWVudFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFhQYXRoVG9rZW5FbGVtZW50IGV4dGVuZHMgWFBhdGhFbGVtZW50IHtcclxuXHRwcm90ZWN0ZWQgdG9rZW5UeXBlOiBudW1iZXI7XHJcblx0Y29uc3RydWN0b3IodG9rZW5OYW1lOiBzdHJpbmcsIHRva2VuVHlwZTogbnVtYmVyKSB7XHJcblx0XHRzdXBlcih0b2tlbk5hbWUpO1xyXG5cdFx0dGhpcy50b2tlblR5cGUgPSB0b2tlblR5cGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXZhbHVhdGUodDogUGFyc2VUcmVlKTogUGFyc2VUcmVlW10ge1xyXG5cdFx0Ly8gcmV0dXJuIGFsbCBjaGlsZHJlbiBvZiB0IHRoYXQgbWF0Y2ggbm9kZU5hbWVcclxuXHRcdGxldCBub2RlczogUGFyc2VUcmVlW10gPSBbXTtcclxuXHRcdGZvciAobGV0IGMgb2YgVHJlZXMuZ2V0Q2hpbGRyZW4odCkpIHtcclxuXHRcdFx0aWYgKGMgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcclxuXHRcdFx0XHRpZiAoKGMuc3ltYm9sLnR5cGUgPT09IHRoaXMudG9rZW5UeXBlICYmICF0aGlzLmludmVydCkgfHxcclxuXHRcdFx0XHRcdChjLnN5bWJvbC50eXBlICE9PSB0aGlzLnRva2VuVHlwZSAmJiB0aGlzLmludmVydCkpIHtcclxuXHRcdFx0XHRcdG5vZGVzLnB1c2goYyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbm9kZXM7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENPTlZFUlNUSU9OIGNvbXBsZXRlLCBCdXJ0IEhhcnJpcyAxMC8xNC8yMDE2XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uLy4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlIH0gZnJvbSBcIi4uL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBUZXJtaW5hbE5vZGUgfSBmcm9tIFwiLi4vVGVybWluYWxOb2RlXCI7XHJcbmltcG9ydCB7IFRyZWVzIH0gZnJvbSBcIi4uL1RyZWVzXCI7XHJcbmltcG9ydCB7IFhQYXRoIH0gZnJvbSBcIi4vWFBhdGhcIjtcclxuaW1wb3J0IHsgWFBhdGhFbGVtZW50IH0gZnJvbSBcIi4vWFBhdGhFbGVtZW50XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgWFBhdGhXaWxkY2FyZEFueXdoZXJlRWxlbWVudCBleHRlbmRzIFhQYXRoRWxlbWVudCB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRzdXBlcihYUGF0aC5XSUxEQ0FSRCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXZhbHVhdGUodDogUGFyc2VUcmVlKTogUGFyc2VUcmVlW10ge1xyXG5cdFx0aWYgKHRoaXMuaW52ZXJ0KSB7XHJcblx0XHRcdC8vICEqIGlzIHdlaXJkIGJ1dCB2YWxpZCAoZW1wdHkpXHJcblx0XHRcdHJldHVybiBbXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBUcmVlcy5nZXREZXNjZW5kYW50cyh0KTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ09OVkVSU1RJT04gY29tcGxldGUsIEJ1cnQgSGFycmlzIDEwLzE0LzIwMTZcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWUgfSBmcm9tIFwiLi4vUGFyc2VUcmVlXCI7XHJcbmltcG9ydCB7IFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuLi9UZXJtaW5hbE5vZGVcIjtcclxuaW1wb3J0IHsgVHJlZXMgfSBmcm9tIFwiLi4vVHJlZXNcIjtcclxuaW1wb3J0IHsgWFBhdGggfSBmcm9tIFwiLi9YUGF0aFwiO1xyXG5pbXBvcnQgeyBYUGF0aEVsZW1lbnQgfSBmcm9tIFwiLi9YUGF0aEVsZW1lbnRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBYUGF0aFdpbGRjYXJkRWxlbWVudCBleHRlbmRzIFhQYXRoRWxlbWVudCB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRzdXBlcihYUGF0aC5XSUxEQ0FSRCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXZhbHVhdGUodDogUGFyc2VUcmVlKTogUGFyc2VUcmVlW10ge1xyXG5cdFx0bGV0IGtpZHM6IFBhcnNlVHJlZVtdID0gW107XHJcblx0XHRpZiAodGhpcy5pbnZlcnQpIHtcclxuXHRcdFx0Ly8gISogaXMgd2VpcmQgYnV0IHZhbGlkIChlbXB0eSlcclxuXHRcdFx0cmV0dXJuIGtpZHM7XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCBjIG9mIFRyZWVzLmdldENoaWxkcmVuKHQpKSB7XHJcblx0XHRcdGtpZHMucHVzaChjKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBraWRzO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDYuNDM3Mzg4OC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQ2hhclN0cmVhbXMgfSBmcm9tIFwiLi4vLi4vQ2hhclN0cmVhbXNcIjtcclxuaW1wb3J0IHsgQ29tbW9uVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi4vLi4vQ29tbW9uVG9rZW5TdHJlYW1cIjtcclxuaW1wb3J0IHsgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbiB9IGZyb20gXCIuLi8uLi9MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuLi8uLi9QYXJzZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vLi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlIH0gZnJvbSBcIi4uL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuLi8uLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBYUGF0aEVsZW1lbnQgfSBmcm9tIFwiLi9YUGF0aEVsZW1lbnRcIjtcclxuaW1wb3J0IHsgWFBhdGhMZXhlciB9IGZyb20gXCIuL1hQYXRoTGV4ZXJcIjtcclxuaW1wb3J0IHsgWFBhdGhMZXhlckVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi9YUGF0aExleGVyRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBYUGF0aFJ1bGVBbnl3aGVyZUVsZW1lbnQgfSBmcm9tIFwiLi9YUGF0aFJ1bGVBbnl3aGVyZUVsZW1lbnRcIjtcclxuaW1wb3J0IHsgWFBhdGhSdWxlRWxlbWVudCB9IGZyb20gXCIuL1hQYXRoUnVsZUVsZW1lbnRcIjtcclxuaW1wb3J0IHsgWFBhdGhUb2tlbkFueXdoZXJlRWxlbWVudCB9IGZyb20gXCIuL1hQYXRoVG9rZW5Bbnl3aGVyZUVsZW1lbnRcIjtcclxuaW1wb3J0IHsgWFBhdGhUb2tlbkVsZW1lbnQgfSBmcm9tIFwiLi9YUGF0aFRva2VuRWxlbWVudFwiO1xyXG5pbXBvcnQgeyBYUGF0aFdpbGRjYXJkQW55d2hlcmVFbGVtZW50IH0gZnJvbSBcIi4vWFBhdGhXaWxkY2FyZEFueXdoZXJlRWxlbWVudFwiO1xyXG5pbXBvcnQgeyBYUGF0aFdpbGRjYXJkRWxlbWVudCB9IGZyb20gXCIuL1hQYXRoV2lsZGNhcmRFbGVtZW50XCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50IGEgc3Vic2V0IG9mIFhQYXRoIFhNTCBwYXRoIHN5bnRheCBmb3IgdXNlIGluIGlkZW50aWZ5aW5nIG5vZGVzIGluXHJcbiAqIHBhcnNlIHRyZWVzLlxyXG4gKlxyXG4gKiBTcGxpdCBwYXRoIGludG8gd29yZHMgYW5kIHNlcGFyYXRvcnMgYC9gIGFuZCBgLy9gIHZpYSBBTlRMUlxyXG4gKiBpdHNlbGYgdGhlbiB3YWxrIHBhdGggZWxlbWVudHMgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBBdCBlYWNoIHNlcGFyYXRvci13b3JkXHJcbiAqIHBhaXIsIGZpbmQgc2V0IG9mIG5vZGVzLiBOZXh0IHN0YWdlIHVzZXMgdGhvc2UgYXMgd29yayBsaXN0LlxyXG4gKlxyXG4gKiBUaGUgYmFzaWMgaW50ZXJmYWNlIGlzXHJcbiAqIHtAbGluayBYUGF0aCNmaW5kQWxsIFBhcnNlVHJlZS5maW5kQWxsfWAodHJlZSwgcGF0aFN0cmluZywgcGFyc2VyKWAuXHJcbiAqIEJ1dCB0aGF0IGlzIGp1c3Qgc2hvcnRoYW5kIGZvcjpcclxuICpcclxuICogYGBgXHJcbiAqIGxldCBwID0gbmV3IFhQYXRoKHBhcnNlciwgcGF0aFN0cmluZyk7XHJcbiAqIHJldHVybiBwLmV2YWx1YXRlKHRyZWUpO1xyXG4gKiBgYGBcclxuICpcclxuICogU2VlIGBUZXN0WFBhdGhgIGZvciBkZXNjcmlwdGlvbnMuIEluIHNob3J0LCB0aGlzXHJcbiAqIGFsbG93cyBvcGVyYXRvcnM6XHJcbiAqXHJcbiAqIHwgfCB8XHJcbiAqIHwgLS0tIHwgLS0tIHxcclxuICogfCBgL2AgfCByb290IHxcclxuICogfCBgLy9gIHwgYW55d2hlcmUgfFxyXG4gKiB8IGAhYCB8IGludmVydDsgdGhpcyBtdWNoIGFwcGVhciBkaXJlY3RseSBhZnRlciByb290IG9yIGFueXdoZXJlIG9wZXJhdG9yIHxcclxuICpcclxuICogYW5kIHBhdGggZWxlbWVudHM6XHJcbiAqXHJcbiAqIHwgfCB8XHJcbiAqIHwgLS0tIHwgLS0tIHxcclxuICogfCBgSURgIHwgdG9rZW4gbmFtZSB8XHJcbiAqIHwgYCdzdHJpbmcnYCB8IGFueSBzdHJpbmcgbGl0ZXJhbCB0b2tlbiBmcm9tIHRoZSBncmFtbWFyIHxcclxuICogfCBgZXhwcmAgfCBydWxlIG5hbWUgfFxyXG4gKiB8IGAqYCB8IHdpbGRjYXJkIG1hdGNoaW5nIGFueSBub2RlIHxcclxuICpcclxuICogV2hpdGVzcGFjZSBpcyBub3QgYWxsb3dlZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBYUGF0aCB7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBXSUxEQ0FSRDogc3RyaW5nID0gXCIqXCI7IC8vIHdvcmQgbm90IG9wZXJhdG9yL3NlcGFyYXRvclxyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTk9UOiBzdHJpbmcgPSBcIiFcIjsgXHQgICAvLyB3b3JkIGZvciBpbnZlcnQgb3BlcmF0b3JcclxuXHJcblx0cHJvdGVjdGVkIHBhdGg6IHN0cmluZztcclxuXHRwcm90ZWN0ZWQgZWxlbWVudHM6IFhQYXRoRWxlbWVudFtdO1xyXG5cdHByb3RlY3RlZCBwYXJzZXI6IFBhcnNlcjtcclxuXHJcblx0Y29uc3RydWN0b3IocGFyc2VyOiBQYXJzZXIsIHBhdGg6IHN0cmluZykge1xyXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xyXG5cdFx0dGhpcy5lbGVtZW50cyA9IHRoaXMuc3BsaXQocGF0aCk7XHJcblx0XHQvLyBjb25zb2xlLmxvZyh0aGlzLmVsZW1lbnRzLnRvU3RyaW5nKCkpO1xyXG5cdH1cclxuXHJcblx0Ly8gVE9ETzogY2hlY2sgZm9yIGludmFsaWQgdG9rZW4vcnVsZSBuYW1lcywgYmFkIHN5bnRheFxyXG5cclxuXHRwdWJsaWMgc3BsaXQocGF0aDogc3RyaW5nKTogWFBhdGhFbGVtZW50W10ge1xyXG5cdFx0bGV0IGxleGVyID0gbmV3IFhQYXRoTGV4ZXIoQ2hhclN0cmVhbXMuZnJvbVN0cmluZyhwYXRoKSk7XHJcblx0XHRsZXhlci5yZWNvdmVyID0gKGU6IExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24pID0+IHsgdGhyb3cgZTsgfTtcclxuXHJcblx0XHRsZXhlci5yZW1vdmVFcnJvckxpc3RlbmVycygpO1xyXG5cdFx0bGV4ZXIuYWRkRXJyb3JMaXN0ZW5lcihuZXcgWFBhdGhMZXhlckVycm9yTGlzdGVuZXIoKSk7XHJcblx0XHRsZXQgdG9rZW5TdHJlYW0gPSBuZXcgQ29tbW9uVG9rZW5TdHJlYW0obGV4ZXIpO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0dG9rZW5TdHJlYW0uZmlsbCgpO1xyXG5cdFx0fVxyXG5cdFx0Y2F0Y2ggKGUpIHtcclxuXHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKSB7XHJcblx0XHRcdFx0bGV0IHBvczogbnVtYmVyID0gbGV4ZXIuY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdFx0XHRcdGxldCBtc2c6IHN0cmluZyA9IFwiSW52YWxpZCB0b2tlbnMgb3IgY2hhcmFjdGVycyBhdCBpbmRleCBcIiArIHBvcyArIFwiIGluIHBhdGggJ1wiICsgcGF0aCArIFwiJyAtLSBcIiArIGUubWVzc2FnZTtcclxuXHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihtc2cpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRocm93IGU7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHRva2VuczogVG9rZW5bXSA9IHRva2VuU3RyZWFtLmdldFRva2VucygpO1xyXG5cdFx0Ly8gY29uc29sZS5sb2coXCJwYXRoPVwiICsgcGF0aCArIFwiPT5cIiArIHRva2Vucyk7XHJcblx0XHRsZXQgZWxlbWVudHM6IFhQYXRoRWxlbWVudFtdID0gW107XHJcblx0XHRsZXQgbjogbnVtYmVyID0gdG9rZW5zLmxlbmd0aDtcclxuXHRcdGxldCBpOiBudW1iZXIgPSAwO1xyXG5cdFx0bG9vcDpcclxuXHRcdHdoaWxlIChpIDwgbikge1xyXG5cdFx0XHRsZXQgZWw6IFRva2VuID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRsZXQgbmV4dDogVG9rZW4gfCB1bmRlZmluZWQ7XHJcblx0XHRcdHN3aXRjaCAoZWwudHlwZSkge1xyXG5cdFx0XHRcdGNhc2UgWFBhdGhMZXhlci5ST09UOlxyXG5cdFx0XHRcdGNhc2UgWFBhdGhMZXhlci5BTllXSEVSRTpcclxuXHRcdFx0XHRcdGxldCBhbnl3aGVyZTogYm9vbGVhbiA9IGVsLnR5cGUgPT09IFhQYXRoTGV4ZXIuQU5ZV0hFUkU7XHJcblx0XHRcdFx0XHRpKys7XHJcblx0XHRcdFx0XHRuZXh0ID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRcdFx0bGV0IGludmVydDogYm9vbGVhbiA9IG5leHQudHlwZSA9PT0gWFBhdGhMZXhlci5CQU5HO1xyXG5cdFx0XHRcdFx0aWYgKGludmVydCkge1xyXG5cdFx0XHRcdFx0XHRpKys7XHJcblx0XHRcdFx0XHRcdG5leHQgPSB0b2tlbnNbaV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsZXQgcGF0aEVsZW1lbnQ6IFhQYXRoRWxlbWVudCA9IHRoaXMuZ2V0WFBhdGhFbGVtZW50KG5leHQsIGFueXdoZXJlKTtcclxuXHRcdFx0XHRcdHBhdGhFbGVtZW50LmludmVydCA9IGludmVydDtcclxuXHRcdFx0XHRcdGVsZW1lbnRzLnB1c2gocGF0aEVsZW1lbnQpO1xyXG5cdFx0XHRcdFx0aSsrO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgWFBhdGhMZXhlci5UT0tFTl9SRUY6XHJcblx0XHRcdFx0Y2FzZSBYUGF0aExleGVyLlJVTEVfUkVGOlxyXG5cdFx0XHRcdGNhc2UgWFBhdGhMZXhlci5XSUxEQ0FSRDpcclxuXHRcdFx0XHRcdGVsZW1lbnRzLnB1c2godGhpcy5nZXRYUGF0aEVsZW1lbnQoZWwsIGZhbHNlKSk7XHJcblx0XHRcdFx0XHRpKys7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBUb2tlbi5FT0Y6XHJcblx0XHRcdFx0XHRicmVhayBsb29wO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93dGggcGF0aCBlbGVtZW50IFwiICsgZWwpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZWxlbWVudHM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IHdvcmQgbGlrZSBgKmAgb3IgYElEYCBvciBgZXhwcmAgdG8gYSBwYXRoXHJcblx0ICogZWxlbWVudC4gYGFueXdoZXJlYCBpcyBgdHJ1ZWAgaWYgYC8vYCBwcmVjZWRlcyB0aGVcclxuXHQgKiB3b3JkLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBnZXRYUGF0aEVsZW1lbnQod29yZFRva2VuOiBUb2tlbiwgYW55d2hlcmU6IGJvb2xlYW4pOiBYUGF0aEVsZW1lbnQge1xyXG5cdFx0aWYgKHdvcmRUb2tlbi50eXBlID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBwYXRoIGVsZW1lbnQgYXQgZW5kIG9mIHBhdGhcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHdvcmQgPSB3b3JkVG9rZW4udGV4dDtcclxuXHRcdGlmICh3b3JkID09IG51bGwpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgd29yZFRva2VuIHRvIGhhdmUgdGV4dCBjb250ZW50LlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdHR5cGU6IG51bWJlciA9IHRoaXMucGFyc2VyLmdldFRva2VuVHlwZSh3b3JkKTtcclxuXHRcdGxldCBydWxlSW5kZXg6IG51bWJlciA9IHRoaXMucGFyc2VyLmdldFJ1bGVJbmRleCh3b3JkKTtcclxuXHRcdHN3aXRjaCAod29yZFRva2VuLnR5cGUpIHtcclxuXHRcdFx0Y2FzZSBYUGF0aExleGVyLldJTERDQVJEOlxyXG5cdFx0XHRcdHJldHVybiBhbnl3aGVyZSA/XHJcblx0XHRcdFx0XHRuZXcgWFBhdGhXaWxkY2FyZEFueXdoZXJlRWxlbWVudCgpIDpcclxuXHRcdFx0XHRcdG5ldyBYUGF0aFdpbGRjYXJkRWxlbWVudCgpO1xyXG5cdFx0XHRjYXNlIFhQYXRoTGV4ZXIuVE9LRU5fUkVGOlxyXG5cdFx0XHRjYXNlIFhQYXRoTGV4ZXIuU1RSSU5HOlxyXG5cdFx0XHRcdGlmICh0dHlwZSA9PT0gVG9rZW4uSU5WQUxJRF9UWVBFKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3Iod29yZCArIFwiIGF0IGluZGV4IFwiICtcclxuXHRcdFx0XHRcdFx0d29yZFRva2VuLnN0YXJ0SW5kZXggK1xyXG5cdFx0XHRcdFx0XHRcIiBpc24ndCBhIHZhbGlkIHRva2VuIG5hbWVcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBhbnl3aGVyZSA/XHJcblx0XHRcdFx0XHRuZXcgWFBhdGhUb2tlbkFueXdoZXJlRWxlbWVudCh3b3JkLCB0dHlwZSkgOlxyXG5cdFx0XHRcdFx0bmV3IFhQYXRoVG9rZW5FbGVtZW50KHdvcmQsIHR0eXBlKTtcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRpZiAocnVsZUluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKHdvcmQgKyBcIiBhdCBpbmRleCBcIiArXHJcblx0XHRcdFx0XHRcdHdvcmRUb2tlbi5zdGFydEluZGV4ICtcclxuXHRcdFx0XHRcdFx0XCIgaXNuJ3QgYSB2YWxpZCBydWxlIG5hbWVcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBhbnl3aGVyZSA/XHJcblx0XHRcdFx0XHRuZXcgWFBhdGhSdWxlQW55d2hlcmVFbGVtZW50KHdvcmQsIHJ1bGVJbmRleCkgOlxyXG5cdFx0XHRcdFx0bmV3IFhQYXRoUnVsZUVsZW1lbnQod29yZCwgcnVsZUluZGV4KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZmluZEFsbCh0cmVlOiBQYXJzZVRyZWUsIHhwYXRoOiBzdHJpbmcsIHBhcnNlcjogUGFyc2VyKTogU2V0PFBhcnNlVHJlZT4ge1xyXG5cdFx0bGV0IHA6IFhQYXRoID0gbmV3IFhQYXRoKHBhcnNlciwgeHBhdGgpO1xyXG5cdFx0cmV0dXJuIHAuZXZhbHVhdGUodHJlZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gYSBsaXN0IG9mIGFsbCBub2RlcyBzdGFydGluZyBhdCBgdGAgYXMgcm9vdCB0aGF0IHNhdGlzZnkgdGhlXHJcblx0ICogcGF0aC4gVGhlIHJvb3QgYC9gIGlzIHJlbGF0aXZlIHRvIHRoZSBub2RlIHBhc3NlZCB0byB7QGxpbmsgZXZhbHVhdGV9LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBldmFsdWF0ZSh0OiBQYXJzZVRyZWUpOiBTZXQ8UGFyc2VUcmVlPiB7XHJcblx0XHRsZXQgZHVtbXlSb290ID0gbmV3IFBhcnNlclJ1bGVDb250ZXh0KCk7XHJcblx0XHRkdW1teVJvb3QuYWRkQ2hpbGQodCBhcyBQYXJzZXJSdWxlQ29udGV4dCk7XHJcblxyXG5cdFx0bGV0IHdvcmsgPSBuZXcgU2V0PFBhcnNlVHJlZT4oW2R1bW15Um9vdF0pO1xyXG5cclxuXHRcdGxldCBpOiBudW1iZXIgPSAwO1xyXG5cdFx0d2hpbGUgKGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgbmV4dCA9IG5ldyBTZXQ8UGFyc2VUcmVlPigpO1xyXG5cdFx0XHRmb3IgKGxldCBub2RlIG9mIHdvcmspIHtcclxuXHRcdFx0XHRpZiAobm9kZS5jaGlsZENvdW50ID4gMCkge1xyXG5cdFx0XHRcdFx0Ly8gb25seSB0cnkgdG8gbWF0Y2ggbmV4dCBlbGVtZW50IGlmIGl0IGhhcyBjaGlsZHJlblxyXG5cdFx0XHRcdFx0Ly8gZS5nLiwgLy9mdW5jLyovc3RhdCBtaWdodCBoYXZlIGEgdG9rZW4gbm9kZSBmb3Igd2hpY2hcclxuXHRcdFx0XHRcdC8vIHdlIGNhbid0IGdvIGxvb2tpbmcgZm9yIHN0YXQgbm9kZXMuXHJcblx0XHRcdFx0XHRsZXQgbWF0Y2hpbmcgPSB0aGlzLmVsZW1lbnRzW2ldLmV2YWx1YXRlKG5vZGUpO1xyXG5cdFx0XHRcdFx0bWF0Y2hpbmcuZm9yRWFjaChuZXh0LmFkZCwgbmV4dCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGkrKztcclxuXHRcdFx0d29yayA9IG5leHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHdvcms7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENPTlZFUlNUSU9OIGNvbXBsZXRlLCBCdXJ0IEhhcnJpcyAxMC8xNC8yMDE2XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWUgfSBmcm9tIFwiLi4vUGFyc2VUcmVlXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZU1hdGNoIH0gZnJvbSBcIi4vUGFyc2VUcmVlTWF0Y2hcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIgfSBmcm9tIFwiLi9QYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlclwiO1xyXG5pbXBvcnQgeyBYUGF0aCB9IGZyb20gXCIuLi94cGF0aC9YUGF0aFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgcGF0dGVybiBsaWtlIGA8SUQ+ID0gPGV4cHI+O2AgY29udmVydGVkIHRvIGEge0BsaW5rIFBhcnNlVHJlZX0gYnlcclxuICoge0BsaW5rIFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyI2NvbXBpbGUoU3RyaW5nLCBpbnQpfS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQYXJzZVRyZWVQYXR0ZXJuIHtcclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgcGF0dGVyblJ1bGVJbmRleGAuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfcGF0dGVyblJ1bGVJbmRleDogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgcGF0dGVybmAuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIF9wYXR0ZXJuOiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBwYXR0ZXJuVHJlZWAuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIF9wYXR0ZXJuVHJlZTogUGFyc2VUcmVlO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgbWF0Y2hlcmAuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIF9tYXRjaGVyOiBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0IGEgbmV3IGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgUGFyc2VUcmVlUGF0dGVybn0gY2xhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gbWF0Y2hlciBUaGUge0BsaW5rIFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyfSB3aGljaCBjcmVhdGVkIHRoaXNcclxuXHQgKiB0cmVlIHBhdHRlcm4uXHJcblx0ICogQHBhcmFtIHBhdHRlcm4gVGhlIHRyZWUgcGF0dGVybiBpbiBjb25jcmV0ZSBzeW50YXggZm9ybS5cclxuXHQgKiBAcGFyYW0gcGF0dGVyblJ1bGVJbmRleCBUaGUgcGFyc2VyIHJ1bGUgd2hpY2ggc2VydmVzIGFzIHRoZSByb290IG9mIHRoZVxyXG5cdCAqIHRyZWUgcGF0dGVybi5cclxuXHQgKiBAcGFyYW0gcGF0dGVyblRyZWUgVGhlIHRyZWUgcGF0dGVybiBpbiB7QGxpbmsgUGFyc2VUcmVlfSBmb3JtLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0QE5vdE51bGwgbWF0Y2hlcjogUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIsXHJcblx0XHRATm90TnVsbCBwYXR0ZXJuOiBzdHJpbmcsXHJcblx0XHRwYXR0ZXJuUnVsZUluZGV4OiBudW1iZXIsXHJcblx0XHRATm90TnVsbCBwYXR0ZXJuVHJlZTogUGFyc2VUcmVlKSB7XHJcblx0XHR0aGlzLl9tYXRjaGVyID0gbWF0Y2hlcjtcclxuXHRcdHRoaXMuX3BhdHRlcm5SdWxlSW5kZXggPSBwYXR0ZXJuUnVsZUluZGV4O1xyXG5cdFx0dGhpcy5fcGF0dGVybiA9IHBhdHRlcm47XHJcblx0XHR0aGlzLl9wYXR0ZXJuVHJlZSA9IHBhdHRlcm5UcmVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTWF0Y2ggYSBzcGVjaWZpYyBwYXJzZSB0cmVlIGFnYWluc3QgdGhpcyB0cmVlIHBhdHRlcm4uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gdHJlZSBUaGUgcGFyc2UgdHJlZSB0byBtYXRjaCBhZ2FpbnN0IHRoaXMgdHJlZSBwYXR0ZXJuLlxyXG5cdCAqIEByZXR1cm5zIEEge0BsaW5rIFBhcnNlVHJlZU1hdGNofSBvYmplY3QgZGVzY3JpYmluZyB0aGUgcmVzdWx0IG9mIHRoZVxyXG5cdCAqIG1hdGNoIG9wZXJhdGlvbi4gVGhlIGBQYXJzZVRyZWVNYXRjaC5zdWNjZWVkZWRgIG1ldGhvZCBjYW4gYmVcclxuXHQgKiB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0Y2ggd2FzIHN1Y2Nlc3NmdWwuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgbWF0Y2goQE5vdE51bGwgdHJlZTogUGFyc2VUcmVlKTogUGFyc2VUcmVlTWF0Y2gge1xyXG5cdFx0cmV0dXJuIHRoaXMuX21hdGNoZXIubWF0Y2godHJlZSwgdGhpcyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBwYXJzZSB0cmVlIG1hdGNoZXMgdGhpcyB0cmVlIHBhdHRlcm4uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gdHJlZSBUaGUgcGFyc2UgdHJlZSB0byBtYXRjaCBhZ2FpbnN0IHRoaXMgdHJlZSBwYXR0ZXJuLlxyXG5cdCAqIEByZXR1cm5zIGB0cnVlYCBpZiBgdHJlZWAgaXMgYSBtYXRjaCBmb3IgdGhlIGN1cnJlbnQgdHJlZVxyXG5cdCAqIHBhdHRlcm47IG90aGVyd2lzZSwgYGZhbHNlYC5cclxuXHQgKi9cclxuXHRwdWJsaWMgbWF0Y2hlcyhATm90TnVsbCB0cmVlOiBQYXJzZVRyZWUpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLl9tYXRjaGVyLm1hdGNoKHRyZWUsIHRoaXMpLnN1Y2NlZWRlZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEZpbmQgYWxsIG5vZGVzIHVzaW5nIFhQYXRoIGFuZCB0aGVuIHRyeSB0byBtYXRjaCB0aG9zZSBzdWJ0cmVlcyBhZ2FpbnN0XHJcblx0ICogdGhpcyB0cmVlIHBhdHRlcm4uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gdHJlZSBUaGUge0BsaW5rIFBhcnNlVHJlZX0gdG8gbWF0Y2ggYWdhaW5zdCB0aGlzIHBhdHRlcm4uXHJcblx0ICogQHBhcmFtIHhwYXRoIEFuIGV4cHJlc3Npb24gbWF0Y2hpbmcgdGhlIG5vZGVzXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIFBhcnNlVHJlZU1hdGNofSBvYmplY3RzIGRlc2NyaWJpbmcgdGhlXHJcblx0ICogc3VjY2Vzc2Z1bCBtYXRjaGVzLiBVbnN1Y2Nlc3NmdWwgbWF0Y2hlcyBhcmUgb21pdHRlZCBmcm9tIHRoZSByZXN1bHQsXHJcblx0ICogcmVnYXJkbGVzcyBvZiB0aGUgcmVhc29uIGZvciB0aGUgZmFpbHVyZS5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBmaW5kQWxsKEBOb3ROdWxsIHRyZWU6IFBhcnNlVHJlZSwgQE5vdE51bGwgeHBhdGg6IHN0cmluZyk6IFBhcnNlVHJlZU1hdGNoW10ge1xyXG5cdFx0bGV0IHN1YnRyZWVzOiBTZXQ8UGFyc2VUcmVlPiA9IFhQYXRoLmZpbmRBbGwodHJlZSwgeHBhdGgsIHRoaXMuX21hdGNoZXIucGFyc2VyKTtcclxuXHRcdGxldCBtYXRjaGVzOiBQYXJzZVRyZWVNYXRjaFtdID0gW107XHJcblx0XHRmb3IgKGxldCB0IG9mIHN1YnRyZWVzKSB7XHJcblx0XHRcdGxldCBtYXRjaDogUGFyc2VUcmVlTWF0Y2ggPSB0aGlzLm1hdGNoKHQpO1xyXG5cdFx0XHRpZiAobWF0Y2guc3VjY2VlZGVkKSB7XHJcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKG1hdGNoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1hdGNoZXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcn0gd2hpY2ggY3JlYXRlZCB0aGlzIHRyZWUgcGF0dGVybi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSB7QGxpbmsgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXJ9IHdoaWNoIGNyZWF0ZWQgdGhpcyB0cmVlXHJcblx0ICogcGF0dGVybi5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBtYXRjaGVyKCk6IFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9tYXRjaGVyO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSB0cmVlIHBhdHRlcm4gaW4gY29uY3JldGUgc3ludGF4IGZvcm0uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgdHJlZSBwYXR0ZXJuIGluIGNvbmNyZXRlIHN5bnRheCBmb3JtLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IHBhdHRlcm4oKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYXR0ZXJuO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBwYXJzZXIgcnVsZSB3aGljaCBzZXJ2ZXMgYXMgdGhlIG91dGVybW9zdCBydWxlIGZvciB0aGUgdHJlZVxyXG5cdCAqIHBhdHRlcm4uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgcGFyc2VyIHJ1bGUgd2hpY2ggc2VydmVzIGFzIHRoZSBvdXRlcm1vc3QgcnVsZSBmb3IgdGhlIHRyZWVcclxuXHQgKiBwYXR0ZXJuLlxyXG5cdCAqL1xyXG5cdGdldCBwYXR0ZXJuUnVsZUluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGF0dGVyblJ1bGVJbmRleDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdHJlZSBwYXR0ZXJuIGFzIGEge0BsaW5rIFBhcnNlVHJlZX0uIFRoZSBydWxlIGFuZCB0b2tlbiB0YWdzIGZyb21cclxuXHQgKiB0aGUgcGF0dGVybiBhcmUgcHJlc2VudCBpbiB0aGUgcGFyc2UgdHJlZSBhcyB0ZXJtaW5hbCBub2RlcyB3aXRoIGEgc3ltYm9sXHJcblx0ICogb2YgdHlwZSB7QGxpbmsgUnVsZVRhZ1Rva2VufSBvciB7QGxpbmsgVG9rZW5UYWdUb2tlbn0uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgdHJlZSBwYXR0ZXJuIGFzIGEge0BsaW5rIFBhcnNlVHJlZX0uXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRnZXQgcGF0dGVyblRyZWUoKTogUGFyc2VUcmVlIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYXR0ZXJuVHJlZTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ2LjAzNDM1MDAtMDc6MDBcclxuXHJcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiLi4vLi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4uLy4uL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuU291cmNlIH0gZnJvbSBcIi4uLy4uL1Rva2VuU291cmNlXCI7XHJcblxyXG4vKipcclxuICogQSB7QGxpbmsgVG9rZW59IG9iamVjdCByZXByZXNlbnRpbmcgYW4gZW50aXJlIHN1YnRyZWUgbWF0Y2hlZCBieSBhIHBhcnNlclxyXG4gKiBydWxlOyBlLmcuLCBgPGV4cHI+YC4gVGhlc2UgdG9rZW5zIGFyZSBjcmVhdGVkIGZvciB7QGxpbmsgVGFnQ2h1bmt9XHJcbiAqIGNodW5rcyB3aGVyZSB0aGUgdGFnIGNvcnJlc3BvbmRzIHRvIGEgcGFyc2VyIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVRhZ1Rva2VuIGltcGxlbWVudHMgVG9rZW4ge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBydWxlTmFtZWAuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfcnVsZU5hbWU6IHN0cmluZztcclxuXHQvKipcclxuXHQgKiBUaGUgdG9rZW4gdHlwZSBmb3IgdGhlIGN1cnJlbnQgdG9rZW4uIFRoaXMgaXMgdGhlIHRva2VuIHR5cGUgYXNzaWduZWQgdG9cclxuXHQgKiB0aGUgYnlwYXNzIGFsdGVybmF0aXZlIGZvciB0aGUgcnVsZSBkdXJpbmcgQVROIGRlc2VyaWFsaXphdGlvbi5cclxuXHQgKi9cclxuXHRwcml2YXRlIGJ5cGFzc1Rva2VuVHlwZTogbnVtYmVyO1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBsYWJlbGAuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfbGFiZWw/OiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFJ1bGVUYWdUb2tlbn0gd2l0aCB0aGUgc3BlY2lmaWVkIHJ1bGVcclxuXHQgKiBuYW1lLCBieXBhc3MgdG9rZW4gdHlwZSwgYW5kIGxhYmVsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJ1bGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXJzZXIgcnVsZSB0aGlzIHJ1bGUgdGFnIG1hdGNoZXMuXHJcblx0ICogQHBhcmFtIGJ5cGFzc1Rva2VuVHlwZSBUaGUgYnlwYXNzIHRva2VuIHR5cGUgYXNzaWduZWQgdG8gdGhlIHBhcnNlciBydWxlLlxyXG5cdCAqIEBwYXJhbSBsYWJlbCBUaGUgbGFiZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBydWxlIHRhZywgb3IgYHVuZGVmaW5lZGAgaWZcclxuXHQgKiB0aGUgcnVsZSB0YWcgaXMgdW5sYWJlbGVkLlxyXG5cdCAqXHJcblx0ICogQGV4Y2VwdGlvbiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYHJ1bGVOYW1lYCBpcyBub3QgZGVmaW5lZFxyXG5cdCAqIG9yIGVtcHR5LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHJ1bGVOYW1lOiBzdHJpbmcsIGJ5cGFzc1Rva2VuVHlwZTogbnVtYmVyLCBsYWJlbD86IHN0cmluZykge1xyXG5cdFx0aWYgKHJ1bGVOYW1lID09IG51bGwgfHwgcnVsZU5hbWUubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInJ1bGVOYW1lIGNhbm5vdCBiZSBudWxsIG9yIGVtcHR5LlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9ydWxlTmFtZSA9IHJ1bGVOYW1lO1xyXG5cdFx0dGhpcy5ieXBhc3NUb2tlblR5cGUgPSBieXBhc3NUb2tlblR5cGU7XHJcblx0XHR0aGlzLl9sYWJlbCA9IGxhYmVsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgcnVsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBydWxlIHRhZy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSBwYXJzZXIgcnVsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBydWxlIHRhZy5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBydWxlTmFtZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3J1bGVOYW1lO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgbGFiZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBydWxlIHRhZy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSBsYWJlbCBhc3NvY2lhdGVkIHdpdGggdGhlIHJ1bGUgdGFnLCBvclxyXG5cdCAqIGB1bmRlZmluZWRgIGlmIHRoaXMgaXMgYW4gdW5sYWJlbGVkIHJ1bGUgdGFnLlxyXG5cdCAqL1xyXG5cdGdldCBsYWJlbCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhYmVsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogUnVsZSB0YWcgdG9rZW5zIGFyZSBhbHdheXMgcGxhY2VkIG9uIHRoZSB7QGxpbmsgI0RFRkFVTFRfQ0hBTk5FTH0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGNoYW5uZWwoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBUb2tlbi5ERUZBVUxUX0NIQU5ORUw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBydWxlIHRhZyBmb3JtYXR0ZWQgd2l0aCBgPGAgYW5kIGA+YFxyXG5cdCAqIGRlbGltaXRlcnMuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHRleHQoKTogc3RyaW5nIHtcclxuXHRcdGlmICh0aGlzLl9sYWJlbCAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBcIjxcIiArIHRoaXMuX2xhYmVsICsgXCI6XCIgKyB0aGlzLl9ydWxlTmFtZSArIFwiPlwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBcIjxcIiArIHRoaXMuX3J1bGVOYW1lICsgXCI+XCI7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBSdWxlIHRhZyB0b2tlbnMgaGF2ZSB0eXBlcyBhc3NpZ25lZCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGUgYnlwYXNzXHJcblx0ICogdHJhbnNpdGlvbnMgY3JlYXRlZCBkdXJpbmcgQVROIGRlc2VyaWFsaXphdGlvbi5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgdHlwZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuYnlwYXNzVG9rZW5UeXBlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGltcGxlbWVudGF0aW9uIGZvciB7QGxpbmsgUnVsZVRhZ1Rva2VufSBhbHdheXMgcmV0dXJucyAwLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBsaW5lKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoZSBpbXBsZW1lbnRhdGlvbiBmb3Ige0BsaW5rIFJ1bGVUYWdUb2tlbn0gYWx3YXlzIHJldHVybnMgLTEuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGNoYXJQb3NpdGlvbkluTGluZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGltcGxlbWVudGF0aW9uIGZvciB7QGxpbmsgUnVsZVRhZ1Rva2VufSBhbHdheXMgcmV0dXJucyAtMS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgdG9rZW5JbmRleCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGltcGxlbWVudGF0aW9uIGZvciB7QGxpbmsgUnVsZVRhZ1Rva2VufSBhbHdheXMgcmV0dXJucyAtMS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhcnRJbmRleCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGltcGxlbWVudGF0aW9uIGZvciB7QGxpbmsgUnVsZVRhZ1Rva2VufSBhbHdheXMgcmV0dXJucyAtMS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RvcEluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBSdWxlVGFnVG9rZW59IGFsd2F5cyByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCB0b2tlblNvdXJjZSgpOiBUb2tlblNvdXJjZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGltcGxlbWVudGF0aW9uIGZvciB7QGxpbmsgUnVsZVRhZ1Rva2VufSBhbHdheXMgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaW5wdXRTdHJlYW0oKTogQ2hhclN0cmVhbSB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGltcGxlbWVudGF0aW9uIGZvciB7QGxpbmsgUnVsZVRhZ1Rva2VufSByZXR1cm5zIGEgc3RyaW5nIG9mIHRoZSBmb3JtXHJcblx0ICogYHJ1bGVOYW1lOmJ5cGFzc1Rva2VuVHlwZWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcnVsZU5hbWUgKyBcIjpcIiArIHRoaXMuYnlwYXNzVG9rZW5UeXBlO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDUuMjc5OTA2MC0wNzowMFxyXG5cclxuLyoqXHJcbiAqIEEgY2h1bmsgaXMgZWl0aGVyIGEgdG9rZW4gdGFnLCBhIHJ1bGUgdGFnLCBvciBhIHNwYW4gb2YgbGl0ZXJhbCB0ZXh0IHdpdGhpbiBhXHJcbiAqIHRyZWUgcGF0dGVybi5cclxuICpcclxuICogVGhlIG1ldGhvZCB7QGxpbmsgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIjc3BsaXQoU3RyaW5nKX0gcmV0dXJucyBhIGxpc3Qgb2ZcclxuICogY2h1bmtzIGluIHByZXBhcmF0aW9uIGZvciBjcmVhdGluZyBhIHRva2VuIHN0cmVhbSBieVxyXG4gKiB7QGxpbmsgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIjdG9rZW5pemUoU3RyaW5nKX0uIEZyb20gdGhlcmUsIHdlIGdldCBhIHBhcnNlXHJcbiAqIHRyZWUgZnJvbSB3aXRoIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlciNjb21waWxlKFN0cmluZywgaW50KX0uIFRoZXNlXHJcbiAqIGNodW5rcyBhcmUgY29udmVydGVkIHRvIHtAbGluayBSdWxlVGFnVG9rZW59LCB7QGxpbmsgVG9rZW5UYWdUb2tlbn0sIG9yIHRoZVxyXG4gKiByZWd1bGFyIHRva2VucyBvZiB0aGUgdGV4dCBzdXJyb3VuZGluZyB0aGUgdGFncy5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDaHVuayB7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ2LjE2NzA2NjktMDc6MDBcclxuXHJcbmltcG9ydCB7IENodW5rIH0gZnJvbSBcIi4vQ2h1bmtcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBwbGFjZWhvbGRlciB0YWcgaW4gYSB0cmVlIHBhdHRlcm4uIEEgdGFnIGNhbiBoYXZlIGFueSBvZiB0aGVcclxuICogZm9sbG93aW5nIGZvcm1zLlxyXG4gKlxyXG4gKiAqIGBleHByYDogQW4gdW5sYWJlbGVkIHBsYWNlaG9sZGVyIGZvciBhIHBhcnNlciBydWxlIGBleHByYC5cclxuICogKiBgSURgOiBBbiB1bmxhYmVsZWQgcGxhY2Vob2xkZXIgZm9yIGEgdG9rZW4gb2YgdHlwZSBgSURgLlxyXG4gKiAqIGBlOmV4cHJgOiBBIGxhYmVsZWQgcGxhY2Vob2xkZXIgZm9yIGEgcGFyc2VyIHJ1bGUgYGV4cHJgLlxyXG4gKiAqIGBpZDpJRGA6IEEgbGFiZWxlZCBwbGFjZWhvbGRlciBmb3IgYSB0b2tlbiBvZiB0eXBlIGBJRGAuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgZG9lcyBub3QgcGVyZm9ybSBhbnkgdmFsaWRhdGlvbiBvbiB0aGUgdGFnIG9yIGxhYmVsIG5hbWVzIGFzaWRlXHJcbiAqIGZyb20gZW5zdXJpbmcgdGhhdCB0aGUgdGFnIGlzIGEgZGVmaW5lZCwgbm9uLWVtcHR5IHN0cmluZy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUYWdDaHVuayBleHRlbmRzIENodW5rIHtcclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgdGFnYC5cclxuXHQgKi9cclxuXHRwcml2YXRlIF90YWc6IHN0cmluZztcclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgbGFiZWxgLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX2xhYmVsPzogc3RyaW5nO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3QgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFRhZ0NodW5rfSB1c2luZyB0aGUgc3BlY2lmaWVkIGxhYmVsXHJcblx0ICogYW5kIHRhZy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBsYWJlbCBUaGUgbGFiZWwgZm9yIHRoZSB0YWcuIElmIHRoaXMgaXMgYHVuZGVmaW5lZGAsIHRoZVxyXG5cdCAqIHtAbGluayBUYWdDaHVua30gcmVwcmVzZW50cyBhbiB1bmxhYmVsZWQgdGFnLlxyXG5cdCAqIEBwYXJhbSB0YWcgVGhlIHRhZywgd2hpY2ggc2hvdWxkIGJlIHRoZSBuYW1lIG9mIGEgcGFyc2VyIHJ1bGUgb3IgdG9rZW5cclxuXHQgKiB0eXBlLlxyXG5cdCAqXHJcblx0ICogQGV4Y2VwdGlvbiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYHRhZ2AgaXMgbm90IGRlZmluZWQgb3JcclxuXHQgKiBlbXB0eS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcih0YWc6IHN0cmluZywgbGFiZWw/OiBzdHJpbmcpIHtcclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0aWYgKHRhZyA9PSBudWxsIHx8IHRhZy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidGFnIGNhbm5vdCBiZSBudWxsIG9yIGVtcHR5XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3RhZyA9IHRhZztcclxuXHRcdHRoaXMuX2xhYmVsID0gbGFiZWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHRhZyBmb3IgdGhpcyBjaHVuay5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSB0YWcgZm9yIHRoZSBjaHVuay5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCB0YWcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLl90YWc7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGxhYmVsLCBpZiBhbnksIGFzc2lnbmVkIHRvIHRoaXMgY2h1bmsuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgbGFiZWwgYXNzaWduZWQgdG8gdGhpcyBjaHVuaywgb3IgYHVuZGVmaW5lZGAgaWYgbm8gbGFiZWwgaXNcclxuXHQgKiBhc3NpZ25lZCB0byB0aGUgY2h1bmsuXHJcblx0ICovXHJcblx0Z2V0IGxhYmVsKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGFiZWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGFnIGNodW5rLiBMYWJlbGVkIHRhZ3NcclxuXHQgKiBhcmUgcmV0dXJuZWQgaW4gdGhlIGZvcm0gYGxhYmVsOnRhZ2AsIGFuZCB1bmxhYmVsZWQgdGFncyBhcmVcclxuXHQgKiByZXR1cm5lZCBhcyBqdXN0IHRoZSB0YWcgbmFtZS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGlmICh0aGlzLl9sYWJlbCAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9sYWJlbCArIFwiOlwiICsgdGhpcy5fdGFnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl90YWc7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0Ni4yNTIxNDQ4LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBDaHVuayB9IGZyb20gXCIuL0NodW5rXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uLy4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc3BhbiBvZiByYXcgdGV4dCAoY29uY3JldGUgc3ludGF4KSBiZXR3ZWVuIHRhZ3MgaW4gYSB0cmVlXHJcbiAqIHBhdHRlcm4gc3RyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRleHRDaHVuayBleHRlbmRzIENodW5rIHtcclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciB7QGxpbmsgI2dldFRleHR9LlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSBfdGV4dDogc3RyaW5nO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUZXh0Q2h1bmt9IHdpdGggdGhlIHNwZWNpZmllZCB0ZXh0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHRleHQgVGhlIHRleHQgb2YgdGhpcyBjaHVuay5cclxuXHQgKiBAZXhjZXB0aW9uIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBgdGV4dGAgaXMgbm90IGRlZmluZWQuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgdGV4dDogc3RyaW5nKSB7XHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdGlmICh0ZXh0ID09IG51bGwpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidGV4dCBjYW5ub3QgYmUgbnVsbFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl90ZXh0ID0gdGV4dDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHJhdyB0ZXh0IG9mIHRoaXMgY2h1bmsuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgdGV4dCBvZiB0aGUgY2h1bmsuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRnZXQgdGV4dCgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3RleHQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBUZXh0Q2h1bmt9IHJldHVybnMgdGhlIHJlc3VsdCBvZlxyXG5cdCAqIGB0ZXh0YCBpbiBzaW5nbGUgcXVvdGVzLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiJ1wiICsgdGhpcy5fdGV4dCArIFwiJ1wiO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDYuMzI4MTk4OC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQ29tbW9uVG9rZW4gfSBmcm9tIFwiLi4vLi4vQ29tbW9uVG9rZW5cIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEge0BsaW5rIFRva2VufSBvYmplY3QgcmVwcmVzZW50aW5nIGEgdG9rZW4gb2YgYSBwYXJ0aWN1bGFyIHR5cGU7IGUuZy4sXHJcbiAqIGA8SUQ+YC4gVGhlc2UgdG9rZW5zIGFyZSBjcmVhdGVkIGZvciB7QGxpbmsgVGFnQ2h1bmt9IGNodW5rcyB3aGVyZSB0aGVcclxuICogdGFnIGNvcnJlc3BvbmRzIHRvIGEgbGV4ZXIgcnVsZSBvciB0b2tlbiB0eXBlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRva2VuVGFnVG9rZW4gZXh0ZW5kcyBDb21tb25Ub2tlbiB7XHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3IgYHRva2VuTmFtZWAuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIF90b2tlbk5hbWU6IHN0cmluZztcclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgbGFiZWxgLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX2xhYmVsOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFRva2VuVGFnVG9rZW59IHdpdGggdGhlIHNwZWNpZmllZFxyXG5cdCAqIHRva2VuIG5hbWUsIHR5cGUsIGFuZCBsYWJlbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0b2tlbk5hbWUgVGhlIHRva2VuIG5hbWUuXHJcblx0ICogQHBhcmFtIHR5cGUgVGhlIHRva2VuIHR5cGUuXHJcblx0ICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCBhc3NvY2lhdGVkIHdpdGggdGhlIHRva2VuIHRhZywgb3IgYHVuZGVmaW5lZGAgaWZcclxuXHQgKiB0aGUgdG9rZW4gdGFnIGlzIHVubGFiZWxlZC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCB0b2tlbk5hbWU6IHN0cmluZywgdHlwZTogbnVtYmVyLCBsYWJlbD86IHN0cmluZykge1xyXG5cdFx0c3VwZXIodHlwZSk7XHJcblx0XHR0aGlzLl90b2tlbk5hbWUgPSB0b2tlbk5hbWU7XHJcblx0XHR0aGlzLl9sYWJlbCA9IGxhYmVsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgdG9rZW4gbmFtZS5cclxuXHQgKiBAcmV0dXJucyBUaGUgdG9rZW4gbmFtZS5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCB0b2tlbk5hbWUoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLl90b2tlbk5hbWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBsYWJlbCBhc3NvY2lhdGVkIHdpdGggdGhlIHJ1bGUgdGFnLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIGxhYmVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgcnVsZSB0YWcsIG9yXHJcblx0ICogYHVuZGVmaW5lZGAgaWYgdGhpcyBpcyBhbiB1bmxhYmVsZWQgcnVsZSB0YWcuXHJcblx0ICovXHJcblx0Z2V0IGxhYmVsKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGFiZWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBUb2tlblRhZ1Rva2VufSByZXR1cm5zIHRoZSB0b2tlbiB0YWdcclxuXHQgKiBmb3JtYXR0ZWQgd2l0aCBgPGAgYW5kIGA+YCBkZWxpbWl0ZXJzLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCB0ZXh0KCk6IHN0cmluZyB7XHJcblx0XHRpZiAodGhpcy5fbGFiZWwgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gXCI8XCIgKyB0aGlzLl9sYWJlbCArIFwiOlwiICsgdGhpcy5fdG9rZW5OYW1lICsgXCI+XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFwiPFwiICsgdGhpcy5fdG9rZW5OYW1lICsgXCI+XCI7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBUb2tlblRhZ1Rva2VufSByZXR1cm5zIGEgc3RyaW5nIG9mIHRoZSBmb3JtXHJcblx0ICogYHRva2VuTmFtZTp0eXBlYC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLl90b2tlbk5hbWUgKyBcIjpcIiArIHRoaXMudHlwZTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ09OVkVSU1RJT04gY29tcGxldGUsIEJ1cnQgSGFycmlzIDEwLzE0LzIwMTZcclxuXHJcbmltcG9ydCB7IEJhaWxFcnJvclN0cmF0ZWd5IH0gZnJvbSBcIi4uLy4uL0JhaWxFcnJvclN0cmF0ZWd5XCI7XHJcbmltcG9ydCB7IENoYXJTdHJlYW1zIH0gZnJvbSBcIi4uLy4uL0NoYXJTdHJlYW1zXCI7XHJcbmltcG9ydCB7IENodW5rIH0gZnJvbSBcIi4vQ2h1bmtcIjtcclxuaW1wb3J0IHsgQ29tbW9uVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi4vLi4vQ29tbW9uVG9rZW5TdHJlYW1cIjtcclxuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi4vLi4vTGV4ZXJcIjtcclxuaW1wb3J0IHsgTGlzdFRva2VuU291cmNlIH0gZnJvbSBcIi4uLy4uL0xpc3RUb2tlblNvdXJjZVwiO1xyXG5pbXBvcnQgeyBNdWx0aU1hcCB9IGZyb20gXCIuLi8uLi9taXNjL011bHRpTWFwXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuLi8uLi9taXNjL1BhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuLi8uLi9QYXJzZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VySW50ZXJwcmV0ZXIgfSBmcm9tIFwiLi4vLi4vUGFyc2VySW50ZXJwcmV0ZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vLi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlIH0gZnJvbSBcIi4uL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWVNYXRjaCB9IGZyb20gXCIuL1BhcnNlVHJlZU1hdGNoXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZVBhdHRlcm4gfSBmcm9tIFwiLi9QYXJzZVRyZWVQYXR0ZXJuXCI7XHJcbmltcG9ydCB7IFJlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFJ1bGVOb2RlIH0gZnJvbSBcIi4uL1J1bGVOb2RlXCI7XHJcbmltcG9ydCB7IFJ1bGVUYWdUb2tlbiB9IGZyb20gXCIuL1J1bGVUYWdUb2tlblwiO1xyXG5pbXBvcnQgeyBUYWdDaHVuayB9IGZyb20gXCIuL1RhZ0NodW5rXCI7XHJcbmltcG9ydCB7IFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuLi9UZXJtaW5hbE5vZGVcIjtcclxuaW1wb3J0IHsgVGV4dENodW5rIH0gZnJvbSBcIi4vVGV4dENodW5rXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4uLy4uL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuVGFnVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblRhZ1Rva2VuXCI7XHJcblxyXG4vKipcclxuICogQSB0cmVlIHBhdHRlcm4gbWF0Y2hpbmcgbWVjaGFuaXNtIGZvciBBTlRMUiB7QGxpbmsgUGFyc2VUcmVlfXMuXHJcbiAqXHJcbiAqIFBhdHRlcm5zIGFyZSBzdHJpbmdzIG9mIHNvdXJjZSBpbnB1dCB0ZXh0IHdpdGggc3BlY2lhbCB0YWdzIHJlcHJlc2VudGluZ1xyXG4gKiB0b2tlbiBvciBydWxlIHJlZmVyZW5jZXMgc3VjaCBhczpcclxuICpcclxuICogYGBgXHJcbiAqIDxJRD4gPSA8ZXhwcj47XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBHaXZlbiBhIHBhdHRlcm4gc3RhcnQgcnVsZSBzdWNoIGFzIGBzdGF0ZW1lbnRgLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RzXHJcbiAqIGEge0BsaW5rIFBhcnNlVHJlZX0gd2l0aCBwbGFjZWhvbGRlcnMgZm9yIHRoZSBgSURgIGFuZCBgZXhwcmBcclxuICogc3VidHJlZS4gVGhlbiB0aGUge0BsaW5rICNtYXRjaH0gcm91dGluZXMgY2FuIGNvbXBhcmUgYW4gYWN0dWFsXHJcbiAqIHtAbGluayBQYXJzZVRyZWV9IGZyb20gYSBwYXJzZSB3aXRoIHRoaXMgcGF0dGVybi4gVGFnIGA8SUQ+YCBtYXRjaGVzXHJcbiAqIGFueSBgSURgIHRva2VuIGFuZCB0YWcgYDxleHByPmAgcmVmZXJlbmNlcyB0aGUgcmVzdWx0IG9mIHRoZVxyXG4gKiBgZXhwcmAgcnVsZSAoZ2VuZXJhbGx5IGFuIGluc3RhbmNlIG9mIGBFeHByQ29udGV4dGAuXHJcbiAqXHJcbiAqIFBhdHRlcm4gYHggPSAwO2AgaXMgYSBzaW1pbGFyIHBhdHRlcm4gdGhhdCBtYXRjaGVzIHRoZSBzYW1lIHBhdHRlcm5cclxuICogZXhjZXB0IHRoYXQgaXQgcmVxdWlyZXMgdGhlIGlkZW50aWZpZXIgdG8gYmUgYHhgIGFuZCB0aGUgZXhwcmVzc2lvbiB0b1xyXG4gKiBiZSBgMGAuXHJcbiAqXHJcbiAqIFRoZSB7QGxpbmsgI21hdGNoZXN9IHJvdXRpbmVzIHJldHVybiBgdHJ1ZWAgb3IgYGZhbHNlYCBiYXNlZFxyXG4gKiB1cG9uIGEgbWF0Y2ggZm9yIHRoZSB0cmVlIHJvb3RlZCBhdCB0aGUgcGFyYW1ldGVyIHNlbnQgaW4uIFRoZVxyXG4gKiB7QGxpbmsgI21hdGNofSByb3V0aW5lcyByZXR1cm4gYSB7QGxpbmsgUGFyc2VUcmVlTWF0Y2h9IG9iamVjdCB0aGF0XHJcbiAqIGNvbnRhaW5zIHRoZSBwYXJzZSB0cmVlLCB0aGUgcGFyc2UgdHJlZSBwYXR0ZXJuLCBhbmQgYSBtYXAgZnJvbSB0YWcgbmFtZSB0b1xyXG4gKiBtYXRjaGVkIG5vZGVzIChtb3JlIGJlbG93KS4gQSBzdWJ0cmVlIHRoYXQgZmFpbHMgdG8gbWF0Y2gsIHJldHVybnMgd2l0aFxyXG4gKiB7QGxpbmsgUGFyc2VUcmVlTWF0Y2gjbWlzbWF0Y2hlZE5vZGV9IHNldCB0byB0aGUgZmlyc3QgdHJlZSBub2RlIHRoYXQgZGlkIG5vdFxyXG4gKiBtYXRjaC5cclxuICpcclxuICogRm9yIGVmZmljaWVuY3ksIHlvdSBjYW4gY29tcGlsZSBhIHRyZWUgcGF0dGVybiBpbiBzdHJpbmcgZm9ybSB0byBhXHJcbiAqIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJufSBvYmplY3QuXHJcbiAqXHJcbiAqIFNlZSBgVGVzdFBhcnNlVHJlZU1hdGNoZXJgIGZvciBsb3RzIG9mIGV4YW1wbGVzLlxyXG4gKiB7QGxpbmsgUGFyc2VUcmVlUGF0dGVybn0gaGFzIHR3byBzdGF0aWMgaGVscGVyIG1ldGhvZHM6XHJcbiAqIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJuI2ZpbmRBbGx9IGFuZCB7QGxpbmsgUGFyc2VUcmVlUGF0dGVybiNtYXRjaH0gdGhhdFxyXG4gKiBhcmUgZWFzeSB0byB1c2UgYnV0IG5vdCBzdXBlciBlZmZpY2llbnQgYmVjYXVzZSB0aGV5IGNyZWF0ZSBuZXdcclxuICoge0BsaW5rIFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyfSBvYmplY3RzIGVhY2ggdGltZSBhbmQgaGF2ZSB0byBjb21waWxlIHRoZVxyXG4gKiBwYXR0ZXJuIGluIHN0cmluZyBmb3JtIGJlZm9yZSB1c2luZyBpdC5cclxuICpcclxuICogVGhlIGxleGVyIGFuZCBwYXJzZXIgdGhhdCB5b3UgcGFzcyBpbnRvIHRoZSB7QGxpbmsgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXJ9XHJcbiAqIGNvbnN0cnVjdG9yIGFyZSB1c2VkIHRvIHBhcnNlIHRoZSBwYXR0ZXJuIGluIHN0cmluZyBmb3JtLiBUaGUgbGV4ZXIgY29udmVydHNcclxuICogdGhlIGA8SUQ+ID0gPGV4cHI+O2AgaW50byBhIHNlcXVlbmNlIG9mIGZvdXIgdG9rZW5zIChhc3N1bWluZyBsZXhlclxyXG4gKiB0aHJvd3Mgb3V0IHdoaXRlc3BhY2Ugb3IgcHV0cyBpdCBvbiBhIGhpZGRlbiBjaGFubmVsKS4gQmUgYXdhcmUgdGhhdCB0aGVcclxuICogaW5wdXQgc3RyZWFtIGlzIHJlc2V0IGZvciB0aGUgbGV4ZXIgKGJ1dCBub3QgdGhlIHBhcnNlcjsgYVxyXG4gKiB7QGxpbmsgUGFyc2VySW50ZXJwcmV0ZXJ9IGlzIGNyZWF0ZWQgdG8gcGFyc2UgdGhlIGlucHV0LikuIEFueSB1c2VyLWRlZmluZWRcclxuICogZmllbGRzIHlvdSBoYXZlIHB1dCBpbnRvIHRoZSBsZXhlciBtaWdodCBnZXQgY2hhbmdlZCB3aGVuIHRoaXMgbWVjaGFuaXNtIGFza3NcclxuICogaXQgdG8gc2NhbiB0aGUgcGF0dGVybiBzdHJpbmcuXHJcbiAqXHJcbiAqIE5vcm1hbGx5IGEgcGFyc2VyIGRvZXMgbm90IGFjY2VwdCB0b2tlbiBgPGV4cHI+YCBhcyBhIHZhbGlkXHJcbiAqIGBleHByYCBidXQsIGZyb20gdGhlIHBhcnNlciBwYXNzZWQgaW4sIHdlIGNyZWF0ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZlxyXG4gKiB0aGUgdW5kZXJseWluZyBncmFtbWFyIHJlcHJlc2VudGF0aW9uIChhbiB7QGxpbmsgQVROfSkgdGhhdCBhbGxvd3MgaW1hZ2luYXJ5XHJcbiAqIHRva2VucyByZXByZXNlbnRpbmcgcnVsZXMgKGA8ZXhwcj5gKSB0byBtYXRjaCBlbnRpcmUgcnVsZXMuIFdlIGNhbGxcclxuICogdGhlc2UgKmJ5cGFzcyBhbHRlcm5hdGl2ZXMqLlxyXG4gKlxyXG4gKiBEZWxpbWl0ZXJzIGFyZSBgPGB9IGFuZCBgPmB9LCB3aXRoIGBcXGAgYXMgdGhlIGVzY2FwZSBzdHJpbmdcclxuICogYnkgZGVmYXVsdCwgYnV0IHlvdSBjYW4gc2V0IHRoZW0gdG8gd2hhdGV2ZXIgeW91IHdhbnQgdXNpbmdcclxuICoge0BsaW5rICNzZXREZWxpbWl0ZXJzfS4gWW91IG11c3QgZXNjYXBlIGJvdGggc3RhcnQgYW5kIHN0b3Agc3RyaW5nc1xyXG4gKiBgXFw8YCBhbmQgYFxcPmAuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBsZXhlcmAuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfbGV4ZXI6IExleGVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgcGFyc2VyYC5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9wYXJzZXI6IFBhcnNlcjtcclxuXHJcblx0cHJvdGVjdGVkIHN0YXJ0ID0gXCI8XCI7XHJcblx0cHJvdGVjdGVkIHN0b3AgPSBcIj5cIjtcclxuXHRwcm90ZWN0ZWQgZXNjYXBlID0gXCJcXFxcXCI7IC8vIGUuZy4sIFxcPCBhbmQgXFw+IG11c3QgZXNjYXBlIEJPVEghXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBjb3JyZXNwb25kaW5nIHRvIGVzY2FwZSwgZm9yIGdsb2JhbCByZXBsYWNlXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGVzY2FwZVJFID0gL1xcXFwvZztcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcn0gb3IgZnJvbSBhIHtAbGluayBMZXhlcn0gYW5kXHJcblx0ICoge0BsaW5rIFBhcnNlcn0gb2JqZWN0LiBUaGUgbGV4ZXIgaW5wdXQgc3RyZWFtIGlzIGFsdGVyZWQgZm9yIHRva2VuaXppbmdcclxuXHQgKiB0aGUgdHJlZSBwYXR0ZXJucy4gVGhlIHBhcnNlciBpcyB1c2VkIGFzIGEgY29udmVuaWVudCBtZWNoYW5pc20gdG8gZ2V0XHJcblx0ICogdGhlIGdyYW1tYXIgbmFtZSwgcGx1cyB0b2tlbiwgcnVsZSBuYW1lcy5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihsZXhlcjogTGV4ZXIsIHBhcnNlcjogUGFyc2VyKSB7XHJcblx0XHR0aGlzLl9sZXhlciA9IGxleGVyO1xyXG5cdFx0dGhpcy5fcGFyc2VyID0gcGFyc2VyO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSBkZWxpbWl0ZXJzIHVzZWQgZm9yIG1hcmtpbmcgcnVsZSBhbmQgdG9rZW4gdGFncyB3aXRoaW4gY29uY3JldGVcclxuXHQgKiBzeW50YXggdXNlZCBieSB0aGUgdHJlZSBwYXR0ZXJuIHBhcnNlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBzdGFydCBUaGUgc3RhcnQgZGVsaW1pdGVyLlxyXG5cdCAqIEBwYXJhbSBzdG9wIFRoZSBzdG9wIGRlbGltaXRlci5cclxuXHQgKiBAcGFyYW0gZXNjYXBlTGVmdCBUaGUgZXNjYXBlIHNlcXVlbmNlIHRvIHVzZSBmb3IgZXNjYXBpbmcgYSBzdGFydCBvciBzdG9wIGRlbGltaXRlci5cclxuXHQgKlxyXG5cdCAqIEB0aHJvd3Mge0BsaW5rIEVycm9yfSBpZiBgc3RhcnRgIGlzIG5vdCBkZWZpbmVkIG9yIGVtcHR5LlxyXG5cdCAqIEB0aHJvd3Mge0BsaW5rIEVycm9yfSBpZiBgc3RvcGAgaXMgbm90IGRlZmluZWQgb3IgZW1wdHkuXHJcblx0ICovXHJcblx0cHVibGljIHNldERlbGltaXRlcnMoc3RhcnQ6IHN0cmluZywgc3RvcDogc3RyaW5nLCBlc2NhcGVMZWZ0OiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdGlmICghc3RhcnQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic3RhcnQgY2Fubm90IGJlIG51bGwgb3IgZW1wdHlcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFzdG9wKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInN0b3AgY2Fubm90IGJlIG51bGwgb3IgZW1wdHlcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zdGFydCA9IHN0YXJ0O1xyXG5cdFx0dGhpcy5zdG9wID0gc3RvcDtcclxuXHRcdHRoaXMuZXNjYXBlID0gZXNjYXBlTGVmdDtcclxuXHRcdHRoaXMuZXNjYXBlUkUgPSBuZXcgUmVnRXhwKGVzY2FwZUxlZnQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpLCBcImdcIik7XHJcblx0fVxyXG5cclxuXHQvKiogRG9lcyBgcGF0dGVybmAgbWF0Y2hlZCBhcyBydWxlIGBwYXR0ZXJuUnVsZUluZGV4YCBtYXRjaCBgdHJlZWA/ICovXHJcblx0cHVibGljIG1hdGNoZXModHJlZTogUGFyc2VUcmVlLCBwYXR0ZXJuOiBzdHJpbmcsIHBhdHRlcm5SdWxlSW5kZXg6IG51bWJlcik6IGJvb2xlYW47XHJcblxyXG5cdC8qKiBEb2VzIGBwYXR0ZXJuYCBtYXRjaGVkIGFzIHJ1bGUgcGF0dGVyblJ1bGVJbmRleCBtYXRjaCB0cmVlPyBQYXNzIGluIGFcclxuXHQgKiAgY29tcGlsZWQgcGF0dGVybiBpbnN0ZWFkIG9mIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdHJlZSBwYXR0ZXJuLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBtYXRjaGVzKHRyZWU6IFBhcnNlVHJlZSwgcGF0dGVybjogUGFyc2VUcmVlUGF0dGVybik6IGJvb2xlYW47XHJcblxyXG5cdHB1YmxpYyBtYXRjaGVzKHRyZWU6IFBhcnNlVHJlZSwgcGF0dGVybjogc3RyaW5nIHwgUGFyc2VUcmVlUGF0dGVybiwgcGF0dGVyblJ1bGVJbmRleDogbnVtYmVyID0gMCk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdGxldCBwOiBQYXJzZVRyZWVQYXR0ZXJuID0gdGhpcy5jb21waWxlKHBhdHRlcm4sIHBhdHRlcm5SdWxlSW5kZXgpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tYXRjaGVzKHRyZWUsIHApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGxhYmVscyA9IG5ldyBNdWx0aU1hcDxzdHJpbmcsIFBhcnNlVHJlZT4oKTtcclxuXHRcdFx0bGV0IG1pc21hdGNoZWROb2RlID0gdGhpcy5tYXRjaEltcGwodHJlZSwgcGF0dGVybi5wYXR0ZXJuVHJlZSwgbGFiZWxzKTtcclxuXHRcdFx0cmV0dXJuICFtaXNtYXRjaGVkTm9kZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXBhcmUgYHBhdHRlcm5gIG1hdGNoZWQgYXMgcnVsZSBgcGF0dGVyblJ1bGVJbmRleGAgYWdhaW5zdFxyXG5cdCAqIGB0cmVlYCBhbmQgcmV0dXJuIGEge0BsaW5rIFBhcnNlVHJlZU1hdGNofSBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcclxuXHQgKiBtYXRjaGVkIGVsZW1lbnRzLCBvciB0aGUgbm9kZSBhdCB3aGljaCB0aGUgbWF0Y2ggZmFpbGVkLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBtYXRjaCh0cmVlOiBQYXJzZVRyZWUsIHBhdHRlcm46IHN0cmluZywgcGF0dGVyblJ1bGVJbmRleDogbnVtYmVyKTogUGFyc2VUcmVlTWF0Y2g7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXBhcmUgYHBhdHRlcm5gIG1hdGNoZWQgYWdhaW5zdCBgdHJlZWAgYW5kIHJldHVybiBhXHJcblx0ICoge0BsaW5rIFBhcnNlVHJlZU1hdGNofSBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbWF0Y2hlZCBlbGVtZW50cywgb3IgdGhlXHJcblx0ICogbm9kZSBhdCB3aGljaCB0aGUgbWF0Y2ggZmFpbGVkLiBQYXNzIGluIGEgY29tcGlsZWQgcGF0dGVybiBpbnN0ZWFkIG9mIGFcclxuXHQgKiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB0cmVlIHBhdHRlcm4uXHJcblx0ICovXHJcblx0cHVibGljIG1hdGNoKHRyZWU6IFBhcnNlVHJlZSwgcGF0dGVybjogUGFyc2VUcmVlUGF0dGVybik6IFBhcnNlVHJlZU1hdGNoO1xyXG5cclxuXHQvLyBJbXBsZW1lbnRhdGlvbiBvZiBtYXRjaFxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIG1hdGNoKHRyZWU6IFBhcnNlVHJlZSwgQE5vdE51bGwgcGF0dGVybjogc3RyaW5nIHwgUGFyc2VUcmVlUGF0dGVybiwgcGF0dGVyblJ1bGVJbmRleDogbnVtYmVyID0gMCk6IFBhcnNlVHJlZU1hdGNoIHtcclxuXHRcdGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRsZXQgcDogUGFyc2VUcmVlUGF0dGVybiA9IHRoaXMuY29tcGlsZShwYXR0ZXJuLCBwYXR0ZXJuUnVsZUluZGV4KTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubWF0Y2godHJlZSwgcCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgbGFiZWxzID0gbmV3IE11bHRpTWFwPHN0cmluZywgUGFyc2VUcmVlPigpO1xyXG5cdFx0XHRsZXQgbWlzbWF0Y2hlZE5vZGUgPSB0aGlzLm1hdGNoSW1wbCh0cmVlLCBwYXR0ZXJuLnBhdHRlcm5UcmVlLCBsYWJlbHMpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFBhcnNlVHJlZU1hdGNoKHRyZWUsIHBhdHRlcm4sIGxhYmVscywgbWlzbWF0Y2hlZE5vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRm9yIHJlcGVhdGVkIHVzZSBvZiBhIHRyZWUgcGF0dGVybiwgY29tcGlsZSBpdCB0byBhXHJcblx0ICoge0BsaW5rIFBhcnNlVHJlZVBhdHRlcm59IHVzaW5nIHRoaXMgbWV0aG9kLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjb21waWxlKHBhdHRlcm46IHN0cmluZywgcGF0dGVyblJ1bGVJbmRleDogbnVtYmVyKTogUGFyc2VUcmVlUGF0dGVybiB7XHJcblx0XHRsZXQgdG9rZW5MaXN0ID0gdGhpcy50b2tlbml6ZShwYXR0ZXJuKTtcclxuXHRcdGxldCB0b2tlblNyYyA9IG5ldyBMaXN0VG9rZW5Tb3VyY2UodG9rZW5MaXN0KTtcclxuXHRcdGxldCB0b2tlbnMgPSBuZXcgQ29tbW9uVG9rZW5TdHJlYW0odG9rZW5TcmMpO1xyXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5fcGFyc2VyO1xyXG5cclxuXHRcdGxldCBwYXJzZXJJbnRlcnAgPSBuZXcgUGFyc2VySW50ZXJwcmV0ZXIoXHJcblx0XHRcdHBhcnNlci5ncmFtbWFyRmlsZU5hbWUsXHJcblx0XHRcdHBhcnNlci52b2NhYnVsYXJ5LFxyXG5cdFx0XHRwYXJzZXIucnVsZU5hbWVzLFxyXG5cdFx0XHRwYXJzZXIuZ2V0QVROV2l0aEJ5cGFzc0FsdHMoKSxcclxuXHRcdFx0dG9rZW5zKTtcclxuXHJcblx0XHRsZXQgdHJlZTogUGFyc2VUcmVlO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0cGFyc2VySW50ZXJwLmVycm9ySGFuZGxlciA9IG5ldyBCYWlsRXJyb3JTdHJhdGVneSgpO1xyXG5cdFx0XHR0cmVlID0gcGFyc2VySW50ZXJwLnBhcnNlKHBhdHRlcm5SdWxlSW5kZXgpO1xyXG4vL1x0XHRcdFN5c3RlbS5vdXQucHJpbnRsbihcInBhdHRlcm4gdHJlZSA9IFwiK3RyZWUudG9TdHJpbmdUcmVlKHBhcnNlckludGVycCkpO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRpZiAoZSBpbnN0YW5jZW9mIFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uKSB7XHJcblx0XHRcdFx0dGhyb3cgZS5nZXRDYXVzZSgpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBSZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdFx0XHRcdHRocm93IGU7XHJcblx0XHRcdH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyLkNhbm5vdEludm9rZVN0YXJ0UnVsZShlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIHRyZWUgcGF0dGVybiBjb21waWxhdGlvbiBjaGVja3MgZm9yIGEgY29tcGxldGUgcGFyc2VcclxuXHRcdGlmICh0b2tlbnMuTEEoMSkgIT09IFRva2VuLkVPRikge1xyXG5cdFx0XHR0aHJvdyBuZXcgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIuU3RhcnRSdWxlRG9lc05vdENvbnN1bWVGdWxsUGF0dGVybigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgUGFyc2VUcmVlUGF0dGVybih0aGlzLCBwYXR0ZXJuLCBwYXR0ZXJuUnVsZUluZGV4LCB0cmVlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVzZWQgdG8gY29udmVydCB0aGUgdHJlZSBwYXR0ZXJuIHN0cmluZyBpbnRvIGEgc2VyaWVzIG9mIHRva2Vucy4gVGhlXHJcblx0ICogaW5wdXQgc3RyZWFtIGlzIHJlc2V0LlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGxleGVyKCk6IExleGVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9sZXhlcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVzZWQgdG8gY29sbGVjdCB0byB0aGUgZ3JhbW1hciBmaWxlIG5hbWUsIHRva2VuIG5hbWVzLCBydWxlIG5hbWVzIGZvclxyXG5cdCAqIHVzZWQgdG8gcGFyc2UgdGhlIHBhdHRlcm4gaW50byBhIHBhcnNlIHRyZWUuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRnZXQgcGFyc2VyKCk6IFBhcnNlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFyc2VyO1xyXG5cdH1cclxuXHJcblx0Ly8gLS0tLSBTVVBQT1JUIENPREUgLS0tLVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWN1cnNpdmVseSB3YWxrIGB0cmVlYCBhZ2FpbnN0IGBwYXR0ZXJuVHJlZWAsIGZpbGxpbmdcclxuXHQgKiBgbWF0Y2guYHtAbGluayBQYXJzZVRyZWVNYXRjaCNsYWJlbHMgbGFiZWxzfS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHRoZSBmaXJzdCBub2RlIGVuY291bnRlcmVkIGluIGB0cmVlYCB3aGljaCBkb2VzIG5vdCBtYXRjaFxyXG5cdCAqIGEgY29ycmVzcG9uZGluZyBub2RlIGluIGBwYXR0ZXJuVHJlZWAsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBtYXRjaFxyXG5cdCAqIHdhcyBzdWNjZXNzZnVsLiBUaGUgc3BlY2lmaWMgbm9kZSByZXR1cm5lZCBkZXBlbmRzIG9uIHRoZSBtYXRjaGluZ1xyXG5cdCAqIGFsZ29yaXRobSB1c2VkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiwgYW5kIG1heSBiZSBvdmVycmlkZGVuLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBtYXRjaEltcGwoXHJcblx0XHRATm90TnVsbCB0cmVlOiBQYXJzZVRyZWUsXHJcblx0XHRATm90TnVsbCBwYXR0ZXJuVHJlZTogUGFyc2VUcmVlLFxyXG5cdFx0QE5vdE51bGwgbGFiZWxzOiBNdWx0aU1hcDxzdHJpbmcsIFBhcnNlVHJlZT4pOiBQYXJzZVRyZWUgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKCF0cmVlKSB7XHJcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0cmVlIGNhbm5vdCBiZSBudWxsXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghcGF0dGVyblRyZWUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcInBhdHRlcm5UcmVlIGNhbm5vdCBiZSBudWxsXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHggYW5kIDxJRD4sIHggYW5kIHksIG9yIHggYW5kIHg7IG9yIGNvdWxkIGJlIG1pc21hdGNoZWQgdHlwZXNcclxuXHRcdGlmICh0cmVlIGluc3RhbmNlb2YgVGVybWluYWxOb2RlICYmIHBhdHRlcm5UcmVlIGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XHJcblx0XHRcdGxldCBtaXNtYXRjaGVkTm9kZTogUGFyc2VUcmVlIHwgdW5kZWZpbmVkO1xyXG5cdFx0XHQvLyBib3RoIGFyZSB0b2tlbnMgYW5kIHRoZXkgaGF2ZSBzYW1lIHR5cGVcclxuXHRcdFx0aWYgKHRyZWUuc3ltYm9sLnR5cGUgPT09IHBhdHRlcm5UcmVlLnN5bWJvbC50eXBlKSB7XHJcblx0XHRcdFx0aWYgKHBhdHRlcm5UcmVlLnN5bWJvbCBpbnN0YW5jZW9mIFRva2VuVGFnVG9rZW4pIHsgLy8geCBhbmQgPElEPlxyXG5cdFx0XHRcdFx0bGV0IHRva2VuVGFnVG9rZW4gPSBwYXR0ZXJuVHJlZS5zeW1ib2w7XHJcblx0XHRcdFx0XHQvLyB0cmFjayBsYWJlbC0+bGlzdC1vZi1ub2RlcyBmb3IgYm90aCB0b2tlbiBuYW1lIGFuZCBsYWJlbCAoaWYgYW55KVxyXG5cdFx0XHRcdFx0bGFiZWxzLm1hcCh0b2tlblRhZ1Rva2VuLnRva2VuTmFtZSwgdHJlZSk7XHJcblx0XHRcdFx0XHRjb25zdCBsID0gdG9rZW5UYWdUb2tlbi5sYWJlbDtcclxuXHRcdFx0XHRcdGlmIChsKSB7XHJcblx0XHRcdFx0XHRcdGxhYmVscy5tYXAobCwgdHJlZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHRyZWUudGV4dCA9PT0gcGF0dGVyblRyZWUudGV4dCkge1xyXG5cdFx0XHRcdFx0Ly8geCBhbmQgeFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdC8vIHggYW5kIHlcclxuXHRcdFx0XHRcdGlmICghbWlzbWF0Y2hlZE5vZGUpIHtcclxuXHRcdFx0XHRcdFx0bWlzbWF0Y2hlZE5vZGUgPSB0cmVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRpZiAoIW1pc21hdGNoZWROb2RlKSB7XHJcblx0XHRcdFx0XHRtaXNtYXRjaGVkTm9kZSA9IHRyZWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWlzbWF0Y2hlZE5vZGU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRyZWUgaW5zdGFuY2VvZiBQYXJzZXJSdWxlQ29udGV4dFxyXG5cdFx0XHQmJiBwYXR0ZXJuVHJlZSBpbnN0YW5jZW9mIFBhcnNlclJ1bGVDb250ZXh0KSB7XHJcblx0XHRcdGxldCBtaXNtYXRjaGVkTm9kZTogUGFyc2VUcmVlIHwgdW5kZWZpbmVkO1xyXG5cdFx0XHQvLyAoZXhwciAuLi4pIGFuZCA8ZXhwcj5cclxuXHRcdFx0bGV0IHJ1bGVUYWdUb2tlbiA9IHRoaXMuZ2V0UnVsZVRhZ1Rva2VuKHBhdHRlcm5UcmVlKTtcclxuXHRcdFx0aWYgKHJ1bGVUYWdUb2tlbikge1xyXG5cdFx0XHRcdGxldCBtOiBQYXJzZVRyZWVNYXRjaDtcclxuXHRcdFx0XHRpZiAodHJlZS5ydWxlQ29udGV4dC5ydWxlSW5kZXggPT09IHBhdHRlcm5UcmVlLnJ1bGVDb250ZXh0LnJ1bGVJbmRleCkge1xyXG5cdFx0XHRcdFx0Ly8gdHJhY2sgbGFiZWwtPmxpc3Qtb2Ytbm9kZXMgZm9yIGJvdGggcnVsZSBuYW1lIGFuZCBsYWJlbCAoaWYgYW55KVxyXG5cdFx0XHRcdFx0bGFiZWxzLm1hcChydWxlVGFnVG9rZW4ucnVsZU5hbWUsIHRyZWUpO1xyXG5cdFx0XHRcdFx0Y29uc3QgbCA9IHJ1bGVUYWdUb2tlbi5sYWJlbDtcclxuXHRcdFx0XHRcdGlmIChsKSB7XHJcblx0XHRcdFx0XHRcdGxhYmVscy5tYXAobCwgdHJlZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKCFtaXNtYXRjaGVkTm9kZSkge1xyXG5cdFx0XHRcdFx0XHRtaXNtYXRjaGVkTm9kZSA9IHRyZWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbWlzbWF0Y2hlZE5vZGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIChleHByIC4uLikgYW5kIChleHByIC4uLilcclxuXHRcdFx0aWYgKHRyZWUuY2hpbGRDb3VudCAhPT0gcGF0dGVyblRyZWUuY2hpbGRDb3VudCkge1xyXG5cdFx0XHRcdGlmICghbWlzbWF0Y2hlZE5vZGUpIHtcclxuXHRcdFx0XHRcdG1pc21hdGNoZWROb2RlID0gdHJlZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBtaXNtYXRjaGVkTm9kZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IG46IG51bWJlciA9IHRyZWUuY2hpbGRDb3VudDtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0XHRsZXQgY2hpbGRNYXRjaCA9IHRoaXMubWF0Y2hJbXBsKHRyZWUuZ2V0Q2hpbGQoaSksIHBhdHRlcm5UcmVlLmdldENoaWxkKGkpLCBsYWJlbHMpO1xyXG5cdFx0XHRcdGlmIChjaGlsZE1hdGNoKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gY2hpbGRNYXRjaDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtaXNtYXRjaGVkTm9kZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiBub2RlcyBhcmVuJ3QgYm90aCB0b2tlbnMgb3IgYm90aCBydWxlIG5vZGVzLCBjYW4ndCBtYXRjaFxyXG5cdFx0cmV0dXJuIHRyZWU7XHJcblx0fVxyXG5cclxuXHQvKiogSXMgYHRgIGAoZXhwciA8ZXhwcj4pYCBzdWJ0cmVlPyAqL1xyXG5cdHByb3RlY3RlZCBnZXRSdWxlVGFnVG9rZW4odDogUGFyc2VUcmVlKTogUnVsZVRhZ1Rva2VuIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICh0IGluc3RhbmNlb2YgUnVsZU5vZGUpIHtcclxuXHRcdFx0aWYgKHQuY2hpbGRDb3VudCA9PT0gMSAmJiB0LmdldENoaWxkKDApIGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XHJcblx0XHRcdFx0bGV0IGMgPSB0LmdldENoaWxkKDApIGFzIFRlcm1pbmFsTm9kZTtcclxuXHRcdFx0XHRpZiAoYy5zeW1ib2wgaW5zdGFuY2VvZiBSdWxlVGFnVG9rZW4pIHtcclxuLy9cdFx0XHRcdFx0U3lzdGVtLm91dC5wcmludGxuKFwicnVsZSB0YWcgc3VidHJlZSBcIit0LnRvU3RyaW5nVHJlZShwYXJzZXIpKTtcclxuXHRcdFx0XHRcdHJldHVybiBjLnN5bWJvbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdG9rZW5pemUocGF0dGVybjogc3RyaW5nKTogVG9rZW5bXSB7XHJcblx0XHQvLyBzcGxpdCBwYXR0ZXJuIGludG8gY2h1bmtzOiBzZWEgKHJhdyBpbnB1dCkgYW5kIGlzbGFuZHMgKDxJRD4sIDxleHByPilcclxuXHRcdGxldCBjaHVua3MgPSB0aGlzLnNwbGl0KHBhdHRlcm4pO1xyXG5cclxuXHRcdC8vIGNyZWF0ZSB0b2tlbiBzdHJlYW0gZnJvbSB0ZXh0IGFuZCB0YWdzXHJcblx0XHRsZXQgdG9rZW5zOiBUb2tlbltdID0gW107XHJcblxyXG5cdFx0Zm9yIChsZXQgY2h1bmsgb2YgY2h1bmtzKSB7XHJcblx0XHRcdGlmIChjaHVuayBpbnN0YW5jZW9mIFRhZ0NodW5rKSB7XHJcblx0XHRcdFx0bGV0IHRhZ0NodW5rID0gY2h1bms7XHJcblx0XHRcdFx0Y29uc3QgZmlyc3RDaGFyID0gdGFnQ2h1bmsudGFnLnN1YnN0cigwLCAxKTtcclxuXHRcdFx0XHQvLyBhZGQgc3BlY2lhbCBydWxlIHRva2VuIG9yIGNvbmp1cmUgdXAgbmV3IHRva2VuIGZyb20gbmFtZVxyXG5cdFx0XHRcdGlmIChmaXJzdENoYXIgPT09IGZpcnN0Q2hhci50b1VwcGVyQ2FzZSgpKSB7XHJcblx0XHRcdFx0XHRsZXQgdHR5cGU6IG51bWJlciA9IHRoaXMuX3BhcnNlci5nZXRUb2tlblR5cGUodGFnQ2h1bmsudGFnKTtcclxuXHRcdFx0XHRcdGlmICh0dHlwZSA9PT0gVG9rZW4uSU5WQUxJRF9UWVBFKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdG9rZW4gXCIgKyB0YWdDaHVuay50YWcgKyBcIiBpbiBwYXR0ZXJuOiBcIiArIHBhdHRlcm4pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IHQ6IFRva2VuVGFnVG9rZW4gPSBuZXcgVG9rZW5UYWdUb2tlbih0YWdDaHVuay50YWcsIHR0eXBlLCB0YWdDaHVuay5sYWJlbCk7XHJcblx0XHRcdFx0XHR0b2tlbnMucHVzaCh0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoZmlyc3RDaGFyID09PSBmaXJzdENoYXIudG9Mb3dlckNhc2UoKSkge1xyXG5cdFx0XHRcdFx0bGV0IHJ1bGVJbmRleDogbnVtYmVyID0gdGhpcy5fcGFyc2VyLmdldFJ1bGVJbmRleCh0YWdDaHVuay50YWcpO1xyXG5cdFx0XHRcdFx0aWYgKHJ1bGVJbmRleCA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBydWxlIFwiICsgdGFnQ2h1bmsudGFnICsgXCIgaW4gcGF0dGVybjogXCIgKyBwYXR0ZXJuKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxldCBydWxlSW1hZ2luYXJ5VG9rZW5UeXBlOiBudW1iZXIgPSB0aGlzLl9wYXJzZXIuZ2V0QVROV2l0aEJ5cGFzc0FsdHMoKS5ydWxlVG9Ub2tlblR5cGVbcnVsZUluZGV4XTtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKG5ldyBSdWxlVGFnVG9rZW4odGFnQ2h1bmsudGFnLCBydWxlSW1hZ2luYXJ5VG9rZW5UeXBlLCB0YWdDaHVuay5sYWJlbCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdGFnOiBcIiArIHRhZ0NodW5rLnRhZyArIFwiIGluIHBhdHRlcm46IFwiICsgcGF0dGVybik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGxldCB0ZXh0Q2h1bmsgPSBjaHVuayBhcyBUZXh0Q2h1bms7XHJcblx0XHRcdFx0dGhpcy5fbGV4ZXIuaW5wdXRTdHJlYW0gPSBDaGFyU3RyZWFtcy5mcm9tU3RyaW5nKHRleHRDaHVuay50ZXh0KTtcclxuXHRcdFx0XHRsZXQgdDogVG9rZW4gPSB0aGlzLl9sZXhlci5uZXh0VG9rZW4oKTtcclxuXHRcdFx0XHR3aGlsZSAodC50eXBlICE9PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHQpO1xyXG5cdFx0XHRcdFx0dCA9IHRoaXMuX2xleGVyLm5leHRUb2tlbigpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuLy9cdFx0U3lzdGVtLm91dC5wcmludGxuKFwidG9rZW5zPVwiK3Rva2Vucyk7XHJcblx0XHRyZXR1cm4gdG9rZW5zO1xyXG5cdH1cclxuXHJcblx0LyoqIFNwbGl0IGA8SUQ+ID0gPGU6ZXhwcj4gO2AgaW50byA0IGNodW5rcyBmb3IgdG9rZW5pemluZyBieSB7QGxpbmsgI3Rva2VuaXplfS4gKi9cclxuXHRwdWJsaWMgc3BsaXQocGF0dGVybjogc3RyaW5nKTogQ2h1bmtbXSB7XHJcblx0XHRsZXQgcDogbnVtYmVyID0gMDtcclxuXHRcdGxldCBuOiBudW1iZXIgPSBwYXR0ZXJuLmxlbmd0aDtcclxuXHRcdGxldCBjaHVua3M6IENodW5rW10gPSBbXTtcclxuXHRcdGxldCBidWY6IFwiXCI7XHJcblx0XHQvLyBmaW5kIGFsbCBzdGFydCBhbmQgc3RvcCBpbmRleGVzIGZpcnN0LCB0aGVuIGNvbGxlY3RcclxuXHRcdGxldCBzdGFydHM6IG51bWJlcltdID0gW107XHJcblx0XHRsZXQgc3RvcHM6IG51bWJlcltdID0gW107XHJcblx0XHR3aGlsZSAocCA8IG4pIHtcclxuXHRcdFx0aWYgKHAgPT09IHBhdHRlcm4uaW5kZXhPZih0aGlzLmVzY2FwZSArIHRoaXMuc3RhcnQsIHApKSB7XHJcblx0XHRcdFx0cCArPSB0aGlzLmVzY2FwZS5sZW5ndGggKyB0aGlzLnN0YXJ0Lmxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChwID09PSBwYXR0ZXJuLmluZGV4T2YodGhpcy5lc2NhcGUgKyB0aGlzLnN0b3AsIHApKSB7XHJcblx0XHRcdFx0cCArPSB0aGlzLmVzY2FwZS5sZW5ndGggKyB0aGlzLnN0b3AubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHAgPT09IHBhdHRlcm4uaW5kZXhPZih0aGlzLnN0YXJ0LCBwKSkge1xyXG5cdFx0XHRcdHN0YXJ0cy5wdXNoKHApO1xyXG5cdFx0XHRcdHAgKz0gdGhpcy5zdGFydC5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAocCA9PT0gcGF0dGVybi5pbmRleE9mKHRoaXMuc3RvcCwgcCkpIHtcclxuXHRcdFx0XHRzdG9wcy5wdXNoKHApO1xyXG5cdFx0XHRcdHAgKz0gdGhpcy5zdG9wLmxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRwKys7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcbi8vXHRcdFN5c3RlbS5vdXQucHJpbnRsbihcIlwiKTtcclxuLy9cdFx0U3lzdGVtLm91dC5wcmludGxuKHN0YXJ0cyk7XHJcbi8vXHRcdFN5c3RlbS5vdXQucHJpbnRsbihzdG9wcyk7XHJcblx0XHRpZiAoc3RhcnRzLmxlbmd0aCA+IHN0b3BzLmxlbmd0aCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bnRlcm1pbmF0ZWQgdGFnIGluIHBhdHRlcm46IFwiICsgcGF0dGVybik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0YXJ0cy5sZW5ndGggPCBzdG9wcy5sZW5ndGgpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzdGFydCB0YWcgaW4gcGF0dGVybjogXCIgKyBwYXR0ZXJuKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbnRhZ3M6IG51bWJlciA9IHN0YXJ0cy5sZW5ndGg7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG50YWdzOyBpKyspIHtcclxuXHRcdFx0aWYgKHN0YXJ0c1tpXSA+PSBzdG9wc1tpXSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInRhZyBkZWxpbWl0ZXJzIG91dCBvZiBvcmRlciBpbiBwYXR0ZXJuOiBcIiArIHBhdHRlcm4pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29sbGVjdCBpbnRvIGNodW5rcyBub3dcclxuXHRcdGlmIChudGFncyA9PT0gMCkge1xyXG5cdFx0XHRsZXQgdGV4dDogc3RyaW5nID0gcGF0dGVybi5zdWJzdHJpbmcoMCwgbik7XHJcblx0XHRcdGNodW5rcy5wdXNoKG5ldyBUZXh0Q2h1bmsodGV4dCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChudGFncyA+IDAgJiYgc3RhcnRzWzBdID4gMCkgeyAvLyBjb3B5IHRleHQgdXAgdG8gZmlyc3QgdGFnIGludG8gY2h1bmtzXHJcblx0XHRcdGxldCB0ZXh0OiBzdHJpbmcgPSBwYXR0ZXJuLnN1YnN0cmluZygwLCBzdGFydHNbMF0pO1xyXG5cdFx0XHRjaHVua3MucHVzaChuZXcgVGV4dENodW5rKHRleHQpKTtcclxuXHRcdH1cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnRhZ3M7IGkrKykge1xyXG5cdFx0XHQvLyBjb3B5IGluc2lkZSBvZiA8dGFnPlxyXG5cdFx0XHRsZXQgdGFnOiBzdHJpbmcgPSBwYXR0ZXJuLnN1YnN0cmluZyhzdGFydHNbaV0gKyB0aGlzLnN0YXJ0Lmxlbmd0aCwgc3RvcHNbaV0pO1xyXG5cdFx0XHRsZXQgcnVsZU9yVG9rZW46IHN0cmluZyA9IHRhZztcclxuXHRcdFx0bGV0IGxhYmVsOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcblx0XHRcdGxldCBjb2xvbjogbnVtYmVyID0gdGFnLmluZGV4T2YoXCI6XCIpO1xyXG5cdFx0XHRpZiAoY29sb24gPj0gMCkge1xyXG5cdFx0XHRcdGxhYmVsID0gdGFnLnN1YnN0cmluZygwLCBjb2xvbik7XHJcblx0XHRcdFx0cnVsZU9yVG9rZW4gPSB0YWcuc3Vic3RyaW5nKGNvbG9uICsgMSwgdGFnLmxlbmd0aCk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2h1bmtzLnB1c2gobmV3IFRhZ0NodW5rKHJ1bGVPclRva2VuLCBsYWJlbCkpO1xyXG5cdFx0XHRpZiAoaSArIDEgPCBudGFncykge1xyXG5cdFx0XHRcdC8vIGNvcHkgZnJvbSBlbmQgb2YgPHRhZz4gdG8gc3RhcnQgb2YgbmV4dFxyXG5cdFx0XHRcdGxldCB0ZXh0OiBzdHJpbmcgPSBwYXR0ZXJuLnN1YnN0cmluZyhzdG9wc1tpXSArIHRoaXMuc3RvcC5sZW5ndGgsIHN0YXJ0c1tpICsgMV0pO1xyXG5cdFx0XHRcdGNodW5rcy5wdXNoKG5ldyBUZXh0Q2h1bmsodGV4dCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAobnRhZ3MgPiAwKSB7XHJcblx0XHRcdGxldCBhZnRlckxhc3RUYWc6IG51bWJlciA9IHN0b3BzW250YWdzIC0gMV0gKyB0aGlzLnN0b3AubGVuZ3RoO1xyXG5cdFx0XHRpZiAoYWZ0ZXJMYXN0VGFnIDwgbikgeyAvLyBjb3B5IHRleHQgZnJvbSBlbmQgb2YgbGFzdCB0YWcgdG8gZW5kXHJcblx0XHRcdFx0bGV0IHRleHQ6IHN0cmluZyA9IHBhdHRlcm4uc3Vic3RyaW5nKGFmdGVyTGFzdFRhZywgbik7XHJcblx0XHRcdFx0Y2h1bmtzLnB1c2gobmV3IFRleHRDaHVuayh0ZXh0KSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzdHJpcCBvdXQgdGhlIGVzY2FwZSBzZXF1ZW5jZXMgZnJvbSB0ZXh0IGNodW5rcyBidXQgbm90IHRhZ3NcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjOiBDaHVuayA9IGNodW5rc1tpXTtcclxuXHRcdFx0aWYgKGMgaW5zdGFuY2VvZiBUZXh0Q2h1bmspIHtcclxuXHRcdFx0XHRsZXQgdW5lc2NhcGVkOiBzdHJpbmcgPSBjLnRleHQucmVwbGFjZSh0aGlzLmVzY2FwZVJFLCBcIlwiKTtcclxuXHRcdFx0XHRpZiAodW5lc2NhcGVkLmxlbmd0aCA8IGMudGV4dC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGNodW5rc1tpXSA9IG5ldyBUZXh0Q2h1bmsodW5lc2NhcGVkKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2h1bmtzO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IG5hbWVzcGFjZSBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlciB7XHJcblx0ZXhwb3J0IGNsYXNzIENhbm5vdEludm9rZVN0YXJ0UnVsZSBleHRlbmRzIEVycm9yIHtcclxuXHRcdHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgZXJyb3I6IEVycm9yKSB7XHJcblx0XHRcdHN1cGVyKGBDYW5ub3RJbnZva2VTdGFydFJ1bGU6ICR7ZXJyb3J9YCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vYW50bHIvYW50bHI0L2lzc3Vlcy80MTNcclxuXHQvLyBcIlRyZWUgcGF0dGVybiBjb21waWxhdGlvbiBkb2Vzbid0IGNoZWNrIGZvciBhIGNvbXBsZXRlIHBhcnNlXCJcclxuXHRleHBvcnQgY2xhc3MgU3RhcnRSdWxlRG9lc05vdENvbnN1bWVGdWxsUGF0dGVybiBleHRlbmRzIEVycm9yIHtcclxuXHRcdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0XHRzdXBlcihcIlN0YXJ0UnVsZURvZXNOb3RDb25zdW1lRnVsbFBhdHRlcm5cIik7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOC4yNDAxMDMyLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgU2ltdWxhdG9yU3RhdGUgfSBmcm9tIFwiLi9TaW11bGF0b3JTdGF0ZVwiO1xyXG5pbXBvcnQgeyBUb2tlblN0cmVhbSB9IGZyb20gXCIuLi9Ub2tlblN0cmVhbVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGdhdGhlcmluZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBwcmVkaWN0aW9uXHJcbiAqIGV2ZW50cyB3aGljaCBvY2N1ciBkdXJpbmcgcGFyc2luZy5cclxuICpcclxuICogTm90ZSB0aGF0IHdlIGNvdWxkIHJlY29yZCB0aGUgcGFyc2VyIGNhbGwgc3RhY2sgYXQgdGhlIHRpbWUgdGhpcyBldmVudFxyXG4gKiBvY2N1cnJlZCBidXQgaW4gdGhlIHByZXNlbmNlIG9mIGxlZnQgcmVjdXJzaXZlIHJ1bGVzLCB0aGUgc3RhY2sgaXMga2luZCBvZlxyXG4gKiBtZWFuaW5nbGVzcy4gSXQncyBiZXR0ZXIgdG8gbG9vayBhdCB0aGUgaW5kaXZpZHVhbCBjb25maWd1cmF0aW9ucyBmb3IgdGhlaXJcclxuICogaW5kaXZpZHVhbCBzdGFja3MuIE9mIGNvdXJzZSB0aGF0IGlzIGEge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0fSBvYmplY3RcclxuICogbm90IGEgcGFyc2UgdHJlZSBub2RlIGFuZCBzbyBpdCBkb2VzIG5vdCBoYXZlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBleHRlbnRcclxuICogKHN0YXJ0Li4uc3RvcCkgb2YgdGhlIHZhcmlvdXMgc3VidHJlZXMuIEV4YW1pbmluZyB0aGUgc3RhY2sgdG9wcyBvZiBhbGxcclxuICogY29uZmlndXJhdGlvbnMgcHJvdmlkZSB0aGUgcmV0dXJuIHN0YXRlcyBmb3IgdGhlIHJ1bGUgaW52b2NhdGlvbnMuXHJcbiAqIEZyb20gdGhlcmUgeW91IGNhbiBnZXQgdGhlIGVuY2xvc2luZyBydWxlLlxyXG4gKlxyXG4gKiBAc2luY2UgNC4zXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGVjaXNpb25FdmVudEluZm8ge1xyXG5cdC8qKlxyXG5cdCAqIFRoZSBpbnZva2VkIGRlY2lzaW9uIG51bWJlciB3aGljaCB0aGlzIGV2ZW50IGlzIHJlbGF0ZWQgdG8uXHJcblx0ICpcclxuXHQgKiBAc2VlIEFUTiNkZWNpc2lvblRvU3RhdGVcclxuXHQgKi9cclxuXHRwdWJsaWMgZGVjaXNpb246IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHNpbXVsYXRvciBzdGF0ZSBjb250YWluaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVsZXZhbnQgdG8gdGhlXHJcblx0ICogcHJlZGljdGlvbiBzdGF0ZSB3aGVuIHRoZSBjdXJyZW50IGV2ZW50IG9jY3VycmVkLCBvciBgdW5kZWZpbmVkYCBpZiBub1xyXG5cdCAqIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaXMgcmVsZXZhbnQgb3IgYXZhaWxhYmxlLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGF0ZTogU2ltdWxhdG9yU3RhdGUgfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBpbnB1dCB0b2tlbiBzdHJlYW0gd2hpY2ggaXMgYmVpbmcgcGFyc2VkLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGlucHV0OiBUb2tlblN0cmVhbTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHRva2VuIGluZGV4IGluIHRoZSBpbnB1dCBzdHJlYW0gYXQgd2hpY2ggdGhlIGN1cnJlbnQgcHJlZGljdGlvbiB3YXNcclxuXHQgKiBvcmlnaW5hbGx5IGludm9rZWQuXHJcblx0ICovXHJcblx0cHVibGljIHN0YXJ0SW5kZXg6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHRva2VuIGluZGV4IGluIHRoZSBpbnB1dCBzdHJlYW0gYXQgd2hpY2ggdGhlIGN1cnJlbnQgZXZlbnQgb2NjdXJyZWQuXHJcblx0ICovXHJcblx0cHVibGljIHN0b3BJbmRleDogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgZXZlbnQgb2NjdXJyZWQgZHVyaW5nIExMIHByZWRpY3Rpb247XHJcblx0ICogb3RoZXJ3aXNlLCBgZmFsc2VgIGlmIHRoZSBpbnB1dCBvY2N1cnJlZCBkdXJpbmcgU0xMIHByZWRpY3Rpb24uXHJcblx0ICovXHJcblx0cHVibGljIGZ1bGxDdHg6IGJvb2xlYW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0ZGVjaXNpb246IG51bWJlcixcclxuXHRcdHN0YXRlOiBTaW11bGF0b3JTdGF0ZSB8IHVuZGVmaW5lZCxcclxuXHRcdEBOb3ROdWxsIGlucHV0OiBUb2tlblN0cmVhbSxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyLFxyXG5cdFx0ZnVsbEN0eDogYm9vbGVhbikge1xyXG5cclxuXHRcdHRoaXMuZGVjaXNpb24gPSBkZWNpc2lvbjtcclxuXHRcdHRoaXMuZnVsbEN0eCA9IGZ1bGxDdHg7XHJcblx0XHR0aGlzLnN0b3BJbmRleCA9IHN0b3BJbmRleDtcclxuXHRcdHRoaXMuaW5wdXQgPSBpbnB1dDtcclxuXHRcdHRoaXMuc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XHJcblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyNC44MjI5Mjc5LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBCaXRTZXQgfSBmcm9tIFwiLi4vbWlzYy9CaXRTZXRcIjtcclxuaW1wb3J0IHsgRGVjaXNpb25FdmVudEluZm8gfSBmcm9tIFwiLi9EZWNpc2lvbkV2ZW50SW5mb1wiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgU2ltdWxhdG9yU3RhdGUgfSBmcm9tIFwiLi9TaW11bGF0b3JTdGF0ZVwiO1xyXG5pbXBvcnQgeyBUb2tlblN0cmVhbSB9IGZyb20gXCIuLi9Ub2tlblN0cmVhbVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBwcm9maWxpbmcgZXZlbnQgaW5mb3JtYXRpb24gZm9yIGFuIGFtYmlndWl0eS5cclxuICogQW1iaWd1aXRpZXMgYXJlIGRlY2lzaW9ucyB3aGVyZSBhIHBhcnRpY3VsYXIgaW5wdXQgcmVzdWx0ZWQgaW4gYW4gU0xMXHJcbiAqIGNvbmZsaWN0LCBmb2xsb3dlZCBieSBMTCBwcmVkaWN0aW9uIGFsc28gcmVhY2hpbmcgYSBjb25mbGljdCBzdGF0ZVxyXG4gKiAoaW5kaWNhdGluZyBhIHRydWUgYW1iaWd1aXR5IGluIHRoZSBncmFtbWFyKS5cclxuICpcclxuICogVGhpcyBldmVudCBtYXkgYmUgcmVwb3J0ZWQgZHVyaW5nIFNMTCBwcmVkaWN0aW9uIGluIGNhc2VzIHdoZXJlIHRoZVxyXG4gKiBjb25mbGljdGluZyBTTEwgY29uZmlndXJhdGlvbiBzZXQgcHJvdmlkZXMgc3VmZmljaWVudCBpbmZvcm1hdGlvbiB0b1xyXG4gKiBkZXRlcm1pbmUgdGhhdCB0aGUgU0xMIGNvbmZsaWN0IGlzIHRydWx5IGFuIGFtYmlndWl0eS4gRm9yIGV4YW1wbGUsIGlmIG5vbmVcclxuICogb2YgdGhlIEFUTiBjb25maWd1cmF0aW9ucyBpbiB0aGUgY29uZmxpY3RpbmcgU0xMIGNvbmZpZ3VyYXRpb24gc2V0IGhhdmVcclxuICogdHJhdmVyc2VkIGEgZ2xvYmFsIGZvbGxvdyB0cmFuc2l0aW9uIChpLmUuXHJcbiAqIHtAbGluayBBVE5Db25maWcjZ2V0UmVhY2hlc0ludG9PdXRlckNvbnRleHR9IGlzIGBmYWxzZWAgZm9yIGFsbFxyXG4gKiBjb25maWd1cmF0aW9ucyksIHRoZW4gdGhlIHJlc3VsdCBvZiBTTEwgcHJlZGljdGlvbiBmb3IgdGhhdCBpbnB1dCBpcyBrbm93biB0b1xyXG4gKiBiZSBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQgb2YgTEwgcHJlZGljdGlvbiBmb3IgdGhhdCBpbnB1dC5cclxuICpcclxuICogSW4gc29tZSBjYXNlcywgdGhlIG1pbmltdW0gcmVwcmVzZW50ZWQgYWx0ZXJuYXRpdmUgaW4gdGhlIGNvbmZsaWN0aW5nIExMXHJcbiAqIGNvbmZpZ3VyYXRpb24gc2V0IGlzIG5vdCBlcXVhbCB0byB0aGUgbWluaW11bSByZXByZXNlbnRlZCBhbHRlcm5hdGl2ZSBpbiB0aGVcclxuICogY29uZmxpY3RpbmcgU0xMIGNvbmZpZ3VyYXRpb24gc2V0LiBHcmFtbWFycyBhbmQgaW5wdXRzIHdoaWNoIHJlc3VsdCBpbiB0aGlzXHJcbiAqIHNjZW5hcmlvIGFyZSB1bmFibGUgdG8gdXNlIHtAbGluayBQcmVkaWN0aW9uTW9kZSNTTEx9LCB3aGljaCBpbiB0dXJuIG1lYW5zXHJcbiAqIHRoZXkgY2Fubm90IHVzZSB0aGUgdHdvLXN0YWdlIHBhcnNpbmcgc3RyYXRlZ3kgdG8gaW1wcm92ZSBwYXJzaW5nIHBlcmZvcm1hbmNlXHJcbiAqIGZvciB0aGF0IGlucHV0LlxyXG4gKlxyXG4gKiBAc2VlIFBhcnNlckFUTlNpbXVsYXRvciNyZXBvcnRBbWJpZ3VpdHlcclxuICogQHNlZSBQYXJzZXJFcnJvckxpc3RlbmVyI3JlcG9ydEFtYmlndWl0eVxyXG4gKlxyXG4gKiBAc2luY2UgNC4zXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQW1iaWd1aXR5SW5mbyBleHRlbmRzIERlY2lzaW9uRXZlbnRJbmZvIHtcclxuXHQvKiogVGhlIHNldCBvZiBhbHRlcm5hdGl2ZSBudW1iZXJzIGZvciB0aGlzIGRlY2lzaW9uIGV2ZW50IHRoYXQgbGVhZCB0byBhIHZhbGlkIHBhcnNlLiAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSBhbWJpZ0FsdHM6IEJpdFNldDtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEFtYmlndWl0eUluZm99IGNsYXNzIHdpdGggdGhlXHJcblx0ICogc3BlY2lmaWVkIGRldGFpbGVkIGFtYmlndWl0eSBpbmZvcm1hdGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBkZWNpc2lvbiBUaGUgZGVjaXNpb24gbnVtYmVyXHJcblx0ICogQHBhcmFtIHN0YXRlIFRoZSBmaW5hbCBzaW11bGF0b3Igc3RhdGUgaWRlbnRpZnlpbmcgdGhlIGFtYmlndW91c1xyXG5cdCAqIGFsdGVybmF0aXZlcyBmb3IgdGhlIGN1cnJlbnQgaW5wdXRcclxuXHQgKiBAcGFyYW0gYW1iaWdBbHRzIFRoZSBzZXQgb2YgYWx0ZXJuYXRpdmVzIGluIHRoZSBkZWNpc2lvbiB0aGF0IGxlYWQgdG8gYSB2YWxpZCBwYXJzZS5cclxuXHQgKiAgICAgICAgICAgICAgICAgIFRoZSBwcmVkaWN0ZWQgYWx0IGlzIHRoZSBtaW4oYW1iaWdBbHRzKVxyXG5cdCAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG9rZW4gc3RyZWFtXHJcblx0ICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IGZvciB0aGUgY3VycmVudCBwcmVkaWN0aW9uXHJcblx0ICogQHBhcmFtIHN0b3BJbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdGhlIGFtYmlndWl0eSB3YXMgaWRlbnRpZmllZCBkdXJpbmdcclxuXHQgKiBwcmVkaWN0aW9uXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRkZWNpc2lvbjogbnVtYmVyLFxyXG5cdFx0QE5vdE51bGwgc3RhdGU6IFNpbXVsYXRvclN0YXRlLFxyXG5cdFx0QE5vdE51bGwgYW1iaWdBbHRzOiBCaXRTZXQsXHJcblx0XHRATm90TnVsbCBpbnB1dDogVG9rZW5TdHJlYW0sXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcikge1xyXG5cdFx0c3VwZXIoZGVjaXNpb24sIHN0YXRlLCBpbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBzdGF0ZS51c2VDb250ZXh0KTtcclxuXHRcdHRoaXMuYW1iaWdBbHRzID0gYW1iaWdBbHRzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgc2V0IG9mIGFsdGVybmF0aXZlcyBpbiB0aGUgZGVjaXNpb24gdGhhdCBsZWFkIHRvIGEgdmFsaWQgcGFyc2UuXHJcblx0ICpcclxuXHQgKiBAc2luY2UgNC41XHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRnZXQgYW1iaWd1b3VzQWx0ZXJuYXRpdmVzKCk6IEJpdFNldCB7XHJcblx0XHRyZXR1cm4gdGhpcy5hbWJpZ0FsdHM7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOC4xNTc1OTMzLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBEZWNpc2lvbkV2ZW50SW5mbyB9IGZyb20gXCIuL0RlY2lzaW9uRXZlbnRJbmZvXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBTaW11bGF0b3JTdGF0ZSB9IGZyb20gXCIuL1NpbXVsYXRvclN0YXRlXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4uL1Rva2VuU3RyZWFtXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHByb2ZpbGluZyBldmVudCBpbmZvcm1hdGlvbiBmb3IgYSBjb250ZXh0IHNlbnNpdGl2aXR5LlxyXG4gKiBDb250ZXh0IHNlbnNpdGl2aXRpZXMgYXJlIGRlY2lzaW9ucyB3aGVyZSBhIHBhcnRpY3VsYXIgaW5wdXQgcmVzdWx0ZWQgaW4gYW5cclxuICogU0xMIGNvbmZsaWN0LCBidXQgTEwgcHJlZGljdGlvbiBwcm9kdWNlZCBhIHNpbmdsZSB1bmlxdWUgYWx0ZXJuYXRpdmUuXHJcbiAqXHJcbiAqIEluIHNvbWUgY2FzZXMsIHRoZSB1bmlxdWUgYWx0ZXJuYXRpdmUgaWRlbnRpZmllZCBieSBMTCBwcmVkaWN0aW9uIGlzIG5vdFxyXG4gKiBlcXVhbCB0byB0aGUgbWluaW11bSByZXByZXNlbnRlZCBhbHRlcm5hdGl2ZSBpbiB0aGUgY29uZmxpY3RpbmcgU0xMXHJcbiAqIGNvbmZpZ3VyYXRpb24gc2V0LiBHcmFtbWFycyBhbmQgaW5wdXRzIHdoaWNoIHJlc3VsdCBpbiB0aGlzIHNjZW5hcmlvIGFyZVxyXG4gKiB1bmFibGUgdG8gdXNlIHtAbGluayBQcmVkaWN0aW9uTW9kZSNTTEx9LCB3aGljaCBpbiB0dXJuIG1lYW5zIHRoZXkgY2Fubm90IHVzZVxyXG4gKiB0aGUgdHdvLXN0YWdlIHBhcnNpbmcgc3RyYXRlZ3kgdG8gaW1wcm92ZSBwYXJzaW5nIHBlcmZvcm1hbmNlIGZvciB0aGF0XHJcbiAqIGlucHV0LlxyXG4gKlxyXG4gKiBAc2VlIFBhcnNlckFUTlNpbXVsYXRvciNyZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHlcclxuICogQHNlZSBQYXJzZXJFcnJvckxpc3RlbmVyI3JlcG9ydENvbnRleHRTZW5zaXRpdml0eVxyXG4gKlxyXG4gKiBAc2luY2UgNC4zXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ29udGV4dFNlbnNpdGl2aXR5SW5mbyBleHRlbmRzIERlY2lzaW9uRXZlbnRJbmZvIHtcclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQ29udGV4dFNlbnNpdGl2aXR5SW5mb30gY2xhc3NcclxuXHQgKiB3aXRoIHRoZSBzcGVjaWZpZWQgZGV0YWlsZWQgY29udGV4dCBzZW5zaXRpdml0eSBpbmZvcm1hdGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBkZWNpc2lvbiBUaGUgZGVjaXNpb24gbnVtYmVyXHJcblx0ICogQHBhcmFtIHN0YXRlIFRoZSBmaW5hbCBzaW11bGF0b3Igc3RhdGUgY29udGFpbmluZyB0aGUgdW5pcXVlXHJcblx0ICogYWx0ZXJuYXRpdmUgaWRlbnRpZmllZCBieSBmdWxsLWNvbnRleHQgcHJlZGljdGlvblxyXG5cdCAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG9rZW4gc3RyZWFtXHJcblx0ICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IGZvciB0aGUgY3VycmVudCBwcmVkaWN0aW9uXHJcblx0ICogQHBhcmFtIHN0b3BJbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdGhlIGNvbnRleHQgc2Vuc2l0aXZpdHkgd2FzXHJcblx0ICogaWRlbnRpZmllZCBkdXJpbmcgZnVsbC1jb250ZXh0IHByZWRpY3Rpb25cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdGRlY2lzaW9uOiBudW1iZXIsXHJcblx0XHRATm90TnVsbCBzdGF0ZTogU2ltdWxhdG9yU3RhdGUsXHJcblx0XHRATm90TnVsbCBpbnB1dDogVG9rZW5TdHJlYW0sXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcikge1xyXG5cclxuXHRcdHN1cGVyKGRlY2lzaW9uLCBzdGF0ZSwgaW5wdXQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgdHJ1ZSk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOC4zMzMwNjczLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBbWJpZ3VpdHlJbmZvIH0gZnJvbSBcIi4vQW1iaWd1aXR5SW5mb1wiO1xyXG5pbXBvcnQgeyBDb250ZXh0U2Vuc2l0aXZpdHlJbmZvIH0gZnJvbSBcIi4vQ29udGV4dFNlbnNpdGl2aXR5SW5mb1wiO1xyXG5pbXBvcnQgeyBFcnJvckluZm8gfSBmcm9tIFwiLi9FcnJvckluZm9cIjtcclxuaW1wb3J0IHsgTG9va2FoZWFkRXZlbnRJbmZvIH0gZnJvbSBcIi4vTG9va2FoZWFkRXZlbnRJbmZvXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUHJlZGljYXRlRXZhbEluZm8gfSBmcm9tIFwiLi9QcmVkaWNhdGVFdmFsSW5mb1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgY29udGFpbnMgcHJvZmlsaW5nIGdhdGhlcmVkIGZvciBhIHBhcnRpY3VsYXIgZGVjaXNpb24uXHJcbiAqXHJcbiAqIFBhcnNpbmcgcGVyZm9ybWFuY2UgaW4gQU5UTFIgNCBpcyBoZWF2aWx5IGluZmx1ZW5jZWQgYnkgYm90aCBzdGF0aWMgZmFjdG9yc1xyXG4gKiAoZS5nLiB0aGUgZm9ybSBvZiB0aGUgcnVsZXMgaW4gdGhlIGdyYW1tYXIpIGFuZCBkeW5hbWljIGZhY3RvcnMgKGUuZy4gdGhlXHJcbiAqIGNob2ljZSBvZiBpbnB1dCBhbmQgdGhlIHN0YXRlIG9mIHRoZSBERkEgY2FjaGUgYXQgdGhlIHRpbWUgcHJvZmlsaW5nXHJcbiAqIG9wZXJhdGlvbnMgYXJlIHN0YXJ0ZWQpLiBGb3IgYmVzdCByZXN1bHRzLCBnYXRoZXIgYW5kIHVzZSBhZ2dyZWdhdGVcclxuICogc3RhdGlzdGljcyBmcm9tIGEgbGFyZ2Ugc2FtcGxlIG9mIGlucHV0cyByZXByZXNlbnRpbmcgdGhlIGlucHV0cyBleHBlY3RlZCBpblxyXG4gKiBwcm9kdWN0aW9uIGJlZm9yZSB1c2luZyB0aGUgcmVzdWx0cyB0byBtYWtlIGNoYW5nZXMgaW4gdGhlIGdyYW1tYXIuXHJcbiAqXHJcbiAqIEBzaW5jZSA0LjNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBEZWNpc2lvbkluZm8ge1xyXG5cdC8qKlxyXG5cdCAqIFRoZSBkZWNpc2lvbiBudW1iZXIsIHdoaWNoIGlzIGFuIGluZGV4IGludG8ge0BsaW5rIEFUTiNkZWNpc2lvblRvU3RhdGV9LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBkZWNpc2lvbjogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgdG90YWwgbnVtYmVyIG9mIHRpbWVzIHtAbGluayBQYXJzZXJBVE5TaW11bGF0b3IjYWRhcHRpdmVQcmVkaWN0fSB3YXNcclxuXHQgKiBpbnZva2VkIGZvciB0aGlzIGRlY2lzaW9uLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBpbnZvY2F0aW9uczogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHRvdGFsIHRpbWUgc3BlbnQgaW4ge0BsaW5rIFBhcnNlckFUTlNpbXVsYXRvciNhZGFwdGl2ZVByZWRpY3R9IGZvclxyXG5cdCAqIHRoaXMgZGVjaXNpb24sIGluIG5hbm9zZWNvbmRzLlxyXG5cdCAqXHJcblx0ICogVGhlIHZhbHVlIG9mIHRoaXMgZmllbGQgY29udGFpbnMgdGhlIHN1bSBvZiBkaWZmZXJlbnRpYWwgcmVzdWx0cyBvYnRhaW5lZFxyXG5cdCAqIGJ5IHtAbGluayBTeXN0ZW0jbmFub1RpbWUoKX0sIGFuZCBpcyBub3QgYWRqdXN0ZWQgdG8gY29tcGVuc2F0ZSBmb3IgSklUXHJcblx0ICogYW5kL29yIGdhcmJhZ2UgY29sbGVjdGlvbiBvdmVyaGVhZC4gRm9yIGJlc3QgYWNjdXJhY3ksIHVzZSBhIG1vZGVybiBKVk1cclxuXHQgKiBpbXBsZW1lbnRhdGlvbiB0aGF0IHByb3ZpZGVzIHByZWNpc2UgcmVzdWx0cyBmcm9tXHJcblx0ICoge0BsaW5rIFN5c3RlbSNuYW5vVGltZSgpfSwgYW5kIHBlcmZvcm0gcHJvZmlsaW5nIGluIGEgc2VwYXJhdGUgcHJvY2Vzc1xyXG5cdCAqIHdoaWNoIGlzIHdhcm1lZCB1cCBieSBwYXJzaW5nIHRoZSBpbnB1dCBwcmlvciB0byBwcm9maWxpbmcuIElmIGRlc2lyZWQsXHJcblx0ICogY2FsbCB7QGxpbmsgQVROU2ltdWxhdG9yI2NsZWFyREZBfSB0byByZXNldCB0aGUgREZBIGNhY2hlIHRvIGl0cyBpbml0aWFsXHJcblx0ICogc3RhdGUgYmVmb3JlIHN0YXJ0aW5nIHRoZSBwcm9maWxpbmcgbWVhc3VyZW1lbnQgcGFzcy5cclxuXHQgKi9cclxuXHRwdWJsaWMgdGltZUluUHJlZGljdGlvbjogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHN1bSBvZiB0aGUgbG9va2FoZWFkIHJlcXVpcmVkIGZvciBTTEwgcHJlZGljdGlvbiBmb3IgdGhpcyBkZWNpc2lvbi5cclxuXHQgKiBOb3RlIHRoYXQgU0xMIHByZWRpY3Rpb24gaXMgdXNlZCBiZWZvcmUgTEwgcHJlZGljdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHQgKiByZWFzb25zIGV2ZW4gd2hlbiB7QGxpbmsgUHJlZGljdGlvbk1vZGUjTEx9IG9yXHJcblx0ICoge0BsaW5rIFByZWRpY3Rpb25Nb2RlI0xMX0VYQUNUX0FNQklHX0RFVEVDVElPTn0gaXMgdXNlZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgU0xMX1RvdGFsTG9vazogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgbWluaW11bSBsb29rYWhlYWQgcmVxdWlyZWQgZm9yIGFueSBzaW5nbGUgU0xMIHByZWRpY3Rpb24gdG9cclxuXHQgKiBjb21wbGV0ZSBmb3IgdGhpcyBkZWNpc2lvbiwgYnkgcmVhY2hpbmcgYSB1bmlxdWUgcHJlZGljdGlvbiwgcmVhY2hpbmcgYW5cclxuXHQgKiBTTEwgY29uZmxpY3Qgc3RhdGUsIG9yIGVuY291bnRlcmluZyBhIHN5bnRheCBlcnJvci5cclxuXHQgKi9cclxuXHRwdWJsaWMgU0xMX01pbkxvb2s6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIG1heGltdW0gbG9va2FoZWFkIHJlcXVpcmVkIGZvciBhbnkgc2luZ2xlIFNMTCBwcmVkaWN0aW9uIHRvXHJcblx0ICogY29tcGxldGUgZm9yIHRoaXMgZGVjaXNpb24sIGJ5IHJlYWNoaW5nIGEgdW5pcXVlIHByZWRpY3Rpb24sIHJlYWNoaW5nIGFuXHJcblx0ICogU0xMIGNvbmZsaWN0IHN0YXRlLCBvciBlbmNvdW50ZXJpbmcgYSBzeW50YXggZXJyb3IuXHJcblx0ICovXHJcblx0cHVibGljIFNMTF9NYXhMb29rOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB7QGxpbmsgTG9va2FoZWFkRXZlbnRJbmZvfSBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50IHdoZXJlIHRoZVxyXG5cdCAqIHtAbGluayAjU0xMX01heExvb2t9IHZhbHVlIHdhcyBzZXQuXHJcblx0ICovXHJcblx0cHVibGljIFNMTF9NYXhMb29rRXZlbnQ/OiBMb29rYWhlYWRFdmVudEluZm87XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBzdW0gb2YgdGhlIGxvb2thaGVhZCByZXF1aXJlZCBmb3IgTEwgcHJlZGljdGlvbiBmb3IgdGhpcyBkZWNpc2lvbi5cclxuXHQgKiBOb3RlIHRoYXQgTEwgcHJlZGljdGlvbiBpcyBvbmx5IHVzZWQgd2hlbiBTTEwgcHJlZGljdGlvbiByZWFjaGVzIGFcclxuXHQgKiBjb25mbGljdCBzdGF0ZS5cclxuXHQgKi9cclxuXHRwdWJsaWMgTExfVG90YWxMb29rOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBtaW5pbXVtIGxvb2thaGVhZCByZXF1aXJlZCBmb3IgYW55IHNpbmdsZSBMTCBwcmVkaWN0aW9uIHRvXHJcblx0ICogY29tcGxldGUgZm9yIHRoaXMgZGVjaXNpb24uIEFuIExMIHByZWRpY3Rpb24gY29tcGxldGVzIHdoZW4gdGhlIGFsZ29yaXRobVxyXG5cdCAqIHJlYWNoZXMgYSB1bmlxdWUgcHJlZGljdGlvbiwgYSBjb25mbGljdCBzdGF0ZSAoZm9yXHJcblx0ICoge0BsaW5rIFByZWRpY3Rpb25Nb2RlI0xMfSwgYW4gYW1iaWd1aXR5IHN0YXRlIChmb3JcclxuXHQgKiB7QGxpbmsgUHJlZGljdGlvbk1vZGUjTExfRVhBQ1RfQU1CSUdfREVURUNUSU9OfSwgb3IgYSBzeW50YXggZXJyb3IuXHJcblx0ICovXHJcblx0cHVibGljIExMX01pbkxvb2s6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIG1heGltdW0gbG9va2FoZWFkIHJlcXVpcmVkIGZvciBhbnkgc2luZ2xlIExMIHByZWRpY3Rpb24gdG9cclxuXHQgKiBjb21wbGV0ZSBmb3IgdGhpcyBkZWNpc2lvbi4gQW4gTEwgcHJlZGljdGlvbiBjb21wbGV0ZXMgd2hlbiB0aGUgYWxnb3JpdGhtXHJcblx0ICogcmVhY2hlcyBhIHVuaXF1ZSBwcmVkaWN0aW9uLCBhIGNvbmZsaWN0IHN0YXRlIChmb3JcclxuXHQgKiB7QGxpbmsgUHJlZGljdGlvbk1vZGUjTEx9LCBhbiBhbWJpZ3VpdHkgc3RhdGUgKGZvclxyXG5cdCAqIHtAbGluayBQcmVkaWN0aW9uTW9kZSNMTF9FWEFDVF9BTUJJR19ERVRFQ1RJT059LCBvciBhIHN5bnRheCBlcnJvci5cclxuXHQgKi9cclxuXHRwdWJsaWMgTExfTWF4TG9vazogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUge0BsaW5rIExvb2thaGVhZEV2ZW50SW5mb30gYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudCB3aGVyZSB0aGVcclxuXHQgKiB7QGxpbmsgI0xMX01heExvb2t9IHZhbHVlIHdhcyBzZXQuXHJcblx0ICovXHJcblx0cHVibGljIExMX01heExvb2tFdmVudD86IExvb2thaGVhZEV2ZW50SW5mbztcclxuXHJcblx0LyoqXHJcblx0ICogQSBjb2xsZWN0aW9uIG9mIHtAbGluayBDb250ZXh0U2Vuc2l0aXZpdHlJbmZvfSBpbnN0YW5jZXMgZGVzY3JpYmluZyB0aGVcclxuXHQgKiBjb250ZXh0IHNlbnNpdGl2aXRpZXMgZW5jb3VudGVyZWQgZHVyaW5nIExMIHByZWRpY3Rpb24gZm9yIHRoaXMgZGVjaXNpb24uXHJcblx0ICpcclxuXHQgKiBAc2VlIENvbnRleHRTZW5zaXRpdml0eUluZm9cclxuXHQgKi9cclxuXHRwdWJsaWMgY29udGV4dFNlbnNpdGl2aXRpZXM6IENvbnRleHRTZW5zaXRpdml0eUluZm9bXSA9IFtdO1xyXG5cclxuXHQvKipcclxuXHQgKiBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEVycm9ySW5mb30gaW5zdGFuY2VzIGRlc2NyaWJpbmcgdGhlIHBhcnNlIGVycm9yc1xyXG5cdCAqIGlkZW50aWZpZWQgZHVyaW5nIGNhbGxzIHRvIHtAbGluayBQYXJzZXJBVE5TaW11bGF0b3IjYWRhcHRpdmVQcmVkaWN0fSBmb3JcclxuXHQgKiB0aGlzIGRlY2lzaW9uLlxyXG5cdCAqXHJcblx0ICogQHNlZSBFcnJvckluZm9cclxuXHQgKi9cclxuXHRwdWJsaWMgZXJyb3JzOiBFcnJvckluZm9bXSA9IFtdO1xyXG5cclxuXHQvKipcclxuXHQgKiBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFtYmlndWl0eUluZm99IGluc3RhbmNlcyBkZXNjcmliaW5nIHRoZVxyXG5cdCAqIGFtYmlndWl0aWVzIGVuY291bnRlcmVkIGR1cmluZyBMTCBwcmVkaWN0aW9uIGZvciB0aGlzIGRlY2lzaW9uLlxyXG5cdCAqXHJcblx0ICogQHNlZSBBbWJpZ3VpdHlJbmZvXHJcblx0ICovXHJcblx0cHVibGljIGFtYmlndWl0aWVzOiBBbWJpZ3VpdHlJbmZvW10gPSBbXTtcclxuXHJcblx0LyoqXHJcblx0ICogQSBjb2xsZWN0aW9uIG9mIHtAbGluayBQcmVkaWNhdGVFdmFsSW5mb30gaW5zdGFuY2VzIGRlc2NyaWJpbmcgdGhlXHJcblx0ICogcmVzdWx0cyBvZiBldmFsdWF0aW5nIGluZGl2aWR1YWwgcHJlZGljYXRlcyBkdXJpbmcgcHJlZGljdGlvbiBmb3IgdGhpc1xyXG5cdCAqIGRlY2lzaW9uLlxyXG5cdCAqXHJcblx0ICogQHNlZSBQcmVkaWNhdGVFdmFsSW5mb1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBwcmVkaWNhdGVFdmFsczogUHJlZGljYXRlRXZhbEluZm9bXSA9IFtdO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgdG90YWwgbnVtYmVyIG9mIEFUTiB0cmFuc2l0aW9ucyByZXF1aXJlZCBkdXJpbmcgU0xMIHByZWRpY3Rpb24gZm9yXHJcblx0ICogdGhpcyBkZWNpc2lvbi4gQW4gQVROIHRyYW5zaXRpb24gaXMgZGV0ZXJtaW5lZCBieSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZVxyXG5cdCAqIERGQSBkb2VzIG5vdCBjb250YWluIGFuIGVkZ2UgdGhhdCBpcyByZXF1aXJlZCBmb3IgcHJlZGljdGlvbiwgcmVzdWx0aW5nXHJcblx0ICogaW4gb24tdGhlLWZseSBjb21wdXRhdGlvbiBvZiB0aGF0IGVkZ2UuXHJcblx0ICpcclxuXHQgKiBJZiBERkEgY2FjaGluZyBvZiBTTEwgdHJhbnNpdGlvbnMgaXMgZW1wbG95ZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uLCBBVE5cclxuXHQgKiBjb21wdXRhdGlvbiBtYXkgY2FjaGUgdGhlIGNvbXB1dGVkIGVkZ2UgZm9yIGVmZmljaWVudCBsb29rdXAgZHVyaW5nXHJcblx0ICogZnV0dXJlIHBhcnNpbmcgb2YgdGhpcyBkZWNpc2lvbi4gT3RoZXJ3aXNlLCB0aGUgU0xMIHBhcnNpbmcgYWxnb3JpdGhtXHJcblx0ICogd2lsbCB1c2UgQVROIHRyYW5zaXRpb25zIGV4Y2x1c2l2ZWx5LlxyXG5cdCAqXHJcblx0ICogQHNlZSAjU0xMX0FUTlRyYW5zaXRpb25zXHJcblx0ICogQHNlZSBQYXJzZXJBVE5TaW11bGF0b3IjY29tcHV0ZVRhcmdldFN0YXRlXHJcblx0ICogQHNlZSBMZXhlckFUTlNpbXVsYXRvciNjb21wdXRlVGFyZ2V0U3RhdGVcclxuXHQgKi9cclxuXHRwdWJsaWMgU0xMX0FUTlRyYW5zaXRpb25zOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgdG90YWwgbnVtYmVyIG9mIERGQSB0cmFuc2l0aW9ucyByZXF1aXJlZCBkdXJpbmcgU0xMIHByZWRpY3Rpb24gZm9yXHJcblx0ICogdGhpcyBkZWNpc2lvbi5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSBBVE4gc2ltdWxhdG9yIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHVzZSBERkEgY2FjaGluZyBmb3IgU0xMXHJcblx0ICogdHJhbnNpdGlvbnMsIHRoaXMgdmFsdWUgd2lsbCBiZSAwLlxyXG5cdCAqXHJcblx0ICogQHNlZSBQYXJzZXJBVE5TaW11bGF0b3IjZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZVxyXG5cdCAqIEBzZWUgTGV4ZXJBVE5TaW11bGF0b3IjZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBTTExfREZBVHJhbnNpdGlvbnM6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiB0aW1lcyBTTEwgcHJlZGljdGlvbiBjb21wbGV0ZWQgaW4gYSBjb25mbGljdFxyXG5cdCAqIHN0YXRlLCByZXN1bHRpbmcgaW4gZmFsbGJhY2sgdG8gTEwgcHJlZGljdGlvbi5cclxuXHQgKlxyXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHZhbHVlIGlzIG5vdCByZWxhdGVkIHRvIHdoZXRoZXIgb3Igbm90XHJcblx0ICoge0BsaW5rIFByZWRpY3Rpb25Nb2RlI1NMTH0gbWF5IGJlIHVzZWQgc3VjY2Vzc2Z1bGx5IHdpdGggYSBwYXJ0aWN1bGFyXHJcblx0ICogZ3JhbW1hci4gSWYgdGhlIGFtYmlndWl0eSByZXNvbHV0aW9uIGFsZ29yaXRobSBhcHBsaWVkIHRvIHRoZSBTTExcclxuXHQgKiBjb25mbGljdHMgZm9yIHRoaXMgZGVjaXNpb24gcHJvZHVjZSB0aGUgc2FtZSByZXN1bHQgYXMgTEwgcHJlZGljdGlvbiBmb3JcclxuXHQgKiB0aGlzIGRlY2lzaW9uLCB7QGxpbmsgUHJlZGljdGlvbk1vZGUjU0xMfSB3b3VsZCBwcm9kdWNlIHRoZSBzYW1lIG92ZXJhbGxcclxuXHQgKiBwYXJzaW5nIHJlc3VsdCBhcyB7QGxpbmsgUHJlZGljdGlvbk1vZGUjTEx9LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBMTF9GYWxsYmFjazogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHRvdGFsIG51bWJlciBvZiBBVE4gdHJhbnNpdGlvbnMgcmVxdWlyZWQgZHVyaW5nIExMIHByZWRpY3Rpb24gZm9yXHJcblx0ICogdGhpcyBkZWNpc2lvbi4gQW4gQVROIHRyYW5zaXRpb24gaXMgZGV0ZXJtaW5lZCBieSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZVxyXG5cdCAqIERGQSBkb2VzIG5vdCBjb250YWluIGFuIGVkZ2UgdGhhdCBpcyByZXF1aXJlZCBmb3IgcHJlZGljdGlvbiwgcmVzdWx0aW5nXHJcblx0ICogaW4gb24tdGhlLWZseSBjb21wdXRhdGlvbiBvZiB0aGF0IGVkZ2UuXHJcblx0ICpcclxuXHQgKiBJZiBERkEgY2FjaGluZyBvZiBMTCB0cmFuc2l0aW9ucyBpcyBlbXBsb3llZCBieSB0aGUgaW1wbGVtZW50YXRpb24sIEFUTlxyXG5cdCAqIGNvbXB1dGF0aW9uIG1heSBjYWNoZSB0aGUgY29tcHV0ZWQgZWRnZSBmb3IgZWZmaWNpZW50IGxvb2t1cCBkdXJpbmdcclxuXHQgKiBmdXR1cmUgcGFyc2luZyBvZiB0aGlzIGRlY2lzaW9uLiBPdGhlcndpc2UsIHRoZSBMTCBwYXJzaW5nIGFsZ29yaXRobSB3aWxsXHJcblx0ICogdXNlIEFUTiB0cmFuc2l0aW9ucyBleGNsdXNpdmVseS5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI0xMX0RGQVRyYW5zaXRpb25zXHJcblx0ICogQHNlZSBQYXJzZXJBVE5TaW11bGF0b3IjY29tcHV0ZVRhcmdldFN0YXRlXHJcblx0ICogQHNlZSBMZXhlckFUTlNpbXVsYXRvciNjb21wdXRlVGFyZ2V0U3RhdGVcclxuXHQgKi9cclxuXHRwdWJsaWMgTExfQVROVHJhbnNpdGlvbnM6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSB0b3RhbCBudW1iZXIgb2YgREZBIHRyYW5zaXRpb25zIHJlcXVpcmVkIGR1cmluZyBMTCBwcmVkaWN0aW9uIGZvclxyXG5cdCAqIHRoaXMgZGVjaXNpb24uXHJcblx0ICpcclxuXHQgKiBJZiB0aGUgQVROIHNpbXVsYXRvciBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCB1c2UgREZBIGNhY2hpbmcgZm9yIExMXHJcblx0ICogdHJhbnNpdGlvbnMsIHRoaXMgdmFsdWUgd2lsbCBiZSAwLlxyXG5cdCAqXHJcblx0ICogQHNlZSBQYXJzZXJBVE5TaW11bGF0b3IjZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZVxyXG5cdCAqIEBzZWUgTGV4ZXJBVE5TaW11bGF0b3IjZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBMTF9ERkFUcmFuc2l0aW9uczogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIERlY2lzaW9uSW5mb30gY2xhc3MgdG8gY29udGFpblxyXG5cdCAqIHN0YXRpc3RpY3MgZm9yIGEgcGFydGljdWxhciBkZWNpc2lvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBkZWNpc2lvbiBUaGUgZGVjaXNpb24gbnVtYmVyXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoZGVjaXNpb246IG51bWJlcikge1xyXG5cdFx0dGhpcy5kZWNpc2lvbiA9IGRlY2lzaW9uO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCJ7XCIgK1xyXG5cdFx0XHRcImRlY2lzaW9uPVwiICsgdGhpcy5kZWNpc2lvbiArXHJcblx0XHRcdFwiLCBjb250ZXh0U2Vuc2l0aXZpdGllcz1cIiArIHRoaXMuY29udGV4dFNlbnNpdGl2aXRpZXMubGVuZ3RoICtcclxuXHRcdFx0XCIsIGVycm9ycz1cIiArIHRoaXMuZXJyb3JzLmxlbmd0aCArXHJcblx0XHRcdFwiLCBhbWJpZ3VpdGllcz1cIiArIHRoaXMuYW1iaWd1aXRpZXMubGVuZ3RoICtcclxuXHRcdFx0XCIsIFNMTF9sb29rYWhlYWQ9XCIgKyB0aGlzLlNMTF9Ub3RhbExvb2sgK1xyXG5cdFx0XHRcIiwgU0xMX0FUTlRyYW5zaXRpb25zPVwiICsgdGhpcy5TTExfQVROVHJhbnNpdGlvbnMgK1xyXG5cdFx0XHRcIiwgU0xMX0RGQVRyYW5zaXRpb25zPVwiICsgdGhpcy5TTExfREZBVHJhbnNpdGlvbnMgK1xyXG5cdFx0XHRcIiwgTExfRmFsbGJhY2s9XCIgKyB0aGlzLkxMX0ZhbGxiYWNrICtcclxuXHRcdFx0XCIsIExMX2xvb2thaGVhZD1cIiArIHRoaXMuTExfVG90YWxMb29rICtcclxuXHRcdFx0XCIsIExMX0FUTlRyYW5zaXRpb25zPVwiICsgdGhpcy5MTF9BVE5UcmFuc2l0aW9ucyArXHJcblx0XHRcdFwifVwiO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjguNzIxMzY0Ny0wNzowMFxyXG5cclxuaW1wb3J0IHsgRGVjaXNpb25FdmVudEluZm8gfSBmcm9tIFwiLi9EZWNpc2lvbkV2ZW50SW5mb1wiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgU2ltdWxhdG9yU3RhdGUgfSBmcm9tIFwiLi9TaW11bGF0b3JTdGF0ZVwiO1xyXG5pbXBvcnQgeyBUb2tlblN0cmVhbSB9IGZyb20gXCIuLi9Ub2tlblN0cmVhbVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBwcm9maWxpbmcgZXZlbnQgaW5mb3JtYXRpb24gZm9yIGEgc3ludGF4IGVycm9yXHJcbiAqIGlkZW50aWZpZWQgZHVyaW5nIHByZWRpY3Rpb24uIFN5bnRheCBlcnJvcnMgb2NjdXIgd2hlbiB0aGUgcHJlZGljdGlvblxyXG4gKiBhbGdvcml0aG0gaXMgdW5hYmxlIHRvIGlkZW50aWZ5IGFuIGFsdGVybmF0aXZlIHdoaWNoIHdvdWxkIGxlYWQgdG8gYVxyXG4gKiBzdWNjZXNzZnVsIHBhcnNlLlxyXG4gKlxyXG4gKiBAc2VlIFBhcnNlciNub3RpZnlFcnJvckxpc3RlbmVycyhUb2tlbiwgU3RyaW5nLCBSZWNvZ25pdGlvbkV4Y2VwdGlvbilcclxuICogQHNlZSBBTlRMUkVycm9yTGlzdGVuZXIjc3ludGF4RXJyb3JcclxuICpcclxuICogQHNpbmNlIDQuM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVycm9ySW5mbyBleHRlbmRzIERlY2lzaW9uRXZlbnRJbmZvIHtcclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXJyb3JJbmZvfSBjbGFzcyB3aXRoIHRoZVxyXG5cdCAqIHNwZWNpZmllZCBkZXRhaWxlZCBzeW50YXggZXJyb3IgaW5mb3JtYXRpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gZGVjaXNpb24gVGhlIGRlY2lzaW9uIG51bWJlclxyXG5cdCAqIEBwYXJhbSBzdGF0ZSBUaGUgZmluYWwgc2ltdWxhdG9yIHN0YXRlIHJlYWNoZWQgZHVyaW5nIHByZWRpY3Rpb25cclxuXHQgKiBwcmlvciB0byByZWFjaGluZyB0aGUge0BsaW5rIEFUTlNpbXVsYXRvciNFUlJPUn0gc3RhdGVcclxuXHQgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRva2VuIHN0cmVhbVxyXG5cdCAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCBmb3IgdGhlIGN1cnJlbnQgcHJlZGljdGlvblxyXG5cdCAqIEBwYXJhbSBzdG9wSW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRoZSBzeW50YXggZXJyb3Igd2FzIGlkZW50aWZpZWRcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdGRlY2lzaW9uOiBudW1iZXIsXHJcblx0XHRATm90TnVsbCBzdGF0ZTogU2ltdWxhdG9yU3RhdGUsXHJcblx0XHRATm90TnVsbCBpbnB1dDogVG9rZW5TdHJlYW0sXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcikge1xyXG5cclxuXHRcdHN1cGVyKGRlY2lzaW9uLCBzdGF0ZSwgaW5wdXQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgc3RhdGUudXNlQ29udGV4dCk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozMC42ODUyNTY1LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBEZWNpc2lvbkV2ZW50SW5mbyB9IGZyb20gXCIuL0RlY2lzaW9uRXZlbnRJbmZvXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBTaW11bGF0b3JTdGF0ZSB9IGZyb20gXCIuL1NpbXVsYXRvclN0YXRlXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4uL1Rva2VuU3RyZWFtXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHByb2ZpbGluZyBldmVudCBpbmZvcm1hdGlvbiBmb3IgdHJhY2tpbmcgdGhlIGxvb2thaGVhZFxyXG4gKiBkZXB0aCByZXF1aXJlZCBpbiBvcmRlciB0byBtYWtlIGEgcHJlZGljdGlvbi5cclxuICpcclxuICogQHNpbmNlIDQuM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExvb2thaGVhZEV2ZW50SW5mbyBleHRlbmRzIERlY2lzaW9uRXZlbnRJbmZvIHtcclxuXHQvKiogVGhlIGFsdGVybmF0aXZlIGNob3NlbiBieSBhZGFwdGl2ZVByZWRpY3QoKSwgbm90IG5lY2Vzc2FyaWx5XHJcblx0ICogIHRoZSBvdXRlcm1vc3QgYWx0IHNob3duIGZvciBhIHJ1bGU7IGxlZnQtcmVjdXJzaXZlIHJ1bGVzIGhhdmVcclxuXHQgKiAgdXNlci1sZXZlbCBhbHRzIHRoYXQgZGlmZmVyIGZyb20gdGhlIHJld3JpdHRlbiBydWxlIHdpdGggYSAoLi4uKSBibG9ja1xyXG5cdCAqICBhbmQgYSAoLi4pKiBsb29wLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBwcmVkaWN0ZWRBbHQ6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIExvb2thaGVhZEV2ZW50SW5mb30gY2xhc3Mgd2l0aFxyXG5cdCAqIHRoZSBzcGVjaWZpZWQgZGV0YWlsZWQgbG9va2FoZWFkIGluZm9ybWF0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGRlY2lzaW9uIFRoZSBkZWNpc2lvbiBudW1iZXJcclxuXHQgKiBAcGFyYW0gc3RhdGUgVGhlIGZpbmFsIHNpbXVsYXRvciBzdGF0ZSBjb250YWluaW5nIHRoZSBuZWNlc3NhcnlcclxuXHQgKiBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgdGhlIHJlc3VsdCBvZiBhIHByZWRpY3Rpb24sIG9yIGB1bmRlZmluZWRgIGlmXHJcblx0ICogdGhlIGZpbmFsIHN0YXRlIGlzIG5vdCBhdmFpbGFibGVcclxuXHQgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRva2VuIHN0cmVhbVxyXG5cdCAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCBmb3IgdGhlIGN1cnJlbnQgcHJlZGljdGlvblxyXG5cdCAqIEBwYXJhbSBzdG9wSW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRoZSBwcmVkaWN0aW9uIHdhcyBmaW5hbGx5IG1hZGVcclxuXHQgKiBAcGFyYW0gZnVsbEN0eCBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgbG9va2FoZWFkIGlzIHBhcnQgb2YgYW4gTExcclxuXHQgKiBwcmVkaWN0aW9uOyBvdGhlcndpc2UsIGBmYWxzZWAgaWYgdGhlIGN1cnJlbnQgbG9va2FoZWFkIGlzIHBhcnQgb2ZcclxuXHQgKiBhbiBTTEwgcHJlZGljdGlvblxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0ZGVjaXNpb246IG51bWJlcixcclxuXHRcdHN0YXRlOiBTaW11bGF0b3JTdGF0ZSB8IHVuZGVmaW5lZCxcclxuXHRcdHByZWRpY3RlZEFsdDogbnVtYmVyLFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IFRva2VuU3RyZWFtLFxyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyLFxyXG5cdFx0c3RvcEluZGV4OiBudW1iZXIsXHJcblx0XHRmdWxsQ3R4OiBib29sZWFuKSB7XHJcblxyXG5cdFx0c3VwZXIoZGVjaXNpb24sIHN0YXRlLCBpbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBmdWxsQ3R4KTtcclxuXHRcdHRoaXMucHJlZGljdGVkQWx0ID0gcHJlZGljdGVkQWx0O1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzUuMTkxNDMwNS0wNzowMFxyXG5cclxuaW1wb3J0IHsgRGVjaXNpb25FdmVudEluZm8gfSBmcm9tIFwiLi9EZWNpc2lvbkV2ZW50SW5mb1wiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgU2VtYW50aWNDb250ZXh0IH0gZnJvbSBcIi4vU2VtYW50aWNDb250ZXh0XCI7XHJcbmltcG9ydCB7IFNpbXVsYXRvclN0YXRlIH0gZnJvbSBcIi4vU2ltdWxhdG9yU3RhdGVcIjtcclxuaW1wb3J0IHsgVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi4vVG9rZW5TdHJlYW1cIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgcHJvZmlsaW5nIGV2ZW50IGluZm9ybWF0aW9uIGZvciBzZW1hbnRpYyBwcmVkaWNhdGVcclxuICogZXZhbHVhdGlvbnMgd2hpY2ggb2NjdXIgZHVyaW5nIHByZWRpY3Rpb24uXHJcbiAqXHJcbiAqIEBzZWUgUGFyc2VyQVROU2ltdWxhdG9yI2V2YWxTZW1hbnRpY0NvbnRleHRcclxuICpcclxuICogQHNpbmNlIDQuM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFByZWRpY2F0ZUV2YWxJbmZvIGV4dGVuZHMgRGVjaXNpb25FdmVudEluZm8ge1xyXG5cdC8qKlxyXG5cdCAqIFRoZSBzZW1hbnRpYyBjb250ZXh0IHdoaWNoIHdhcyBldmFsdWF0ZWQuXHJcblx0ICovXHJcblx0cHVibGljIHNlbWN0eDogU2VtYW50aWNDb250ZXh0O1xyXG5cdC8qKlxyXG5cdCAqIFRoZSBhbHRlcm5hdGl2ZSBudW1iZXIgZm9yIHRoZSBkZWNpc2lvbiB3aGljaCBpcyBndWFyZGVkIGJ5IHRoZSBzZW1hbnRpY1xyXG5cdCAqIGNvbnRleHQge0BsaW5rICNzZW1jdHh9LiBOb3RlIHRoYXQgb3RoZXIgQVROXHJcblx0ICogY29uZmlndXJhdGlvbnMgbWF5IHByZWRpY3QgdGhlIHNhbWUgYWx0ZXJuYXRpdmUgd2hpY2ggYXJlIGd1YXJkZWQgYnlcclxuXHQgKiBvdGhlciBzZW1hbnRpYyBjb250ZXh0cyBhbmQvb3Ige0BsaW5rIFNlbWFudGljQ29udGV4dCNOT05FfS5cclxuXHQgKi9cclxuXHRwdWJsaWMgcHJlZGljdGVkQWx0OiBudW1iZXI7XHJcblx0LyoqXHJcblx0ICogVGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIHRoZSBzZW1hbnRpYyBjb250ZXh0IHtAbGluayAjc2VtY3R4fS5cclxuXHQgKi9cclxuXHRwdWJsaWMgZXZhbFJlc3VsdDogYm9vbGVhbjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIFByZWRpY2F0ZUV2YWxJbmZvfSBjbGFzcyB3aXRoIHRoZVxyXG5cdCAqIHNwZWNpZmllZCBkZXRhaWxlZCBwcmVkaWNhdGUgZXZhbHVhdGlvbiBpbmZvcm1hdGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBzdGF0ZSBUaGUgc2ltdWxhdG9yIHN0YXRlXHJcblx0ICogQHBhcmFtIGRlY2lzaW9uIFRoZSBkZWNpc2lvbiBudW1iZXJcclxuXHQgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRva2VuIHN0cmVhbVxyXG5cdCAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCBmb3IgdGhlIGN1cnJlbnQgcHJlZGljdGlvblxyXG5cdCAqIEBwYXJhbSBzdG9wSW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRoZSBwcmVkaWNhdGUgZXZhbHVhdGlvbiB3YXNcclxuXHQgKiB0cmlnZ2VyZWQuIE5vdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIG1heSBiZSByZXNldCB0byBvdGhlciBwb3NpdGlvbnMgZm9yXHJcblx0ICogdGhlIGFjdHVhbCBldmFsdWF0aW9uIG9mIGluZGl2aWR1YWwgcHJlZGljYXRlcy5cclxuXHQgKiBAcGFyYW0gc2VtY3R4IFRoZSBzZW1hbnRpYyBjb250ZXh0IHdoaWNoIHdhcyBldmFsdWF0ZWRcclxuXHQgKiBAcGFyYW0gZXZhbFJlc3VsdCBUaGUgcmVzdWx0cyBvZiBldmFsdWF0aW5nIHRoZSBzZW1hbnRpYyBjb250ZXh0XHJcblx0ICogQHBhcmFtIHByZWRpY3RlZEFsdCBUaGUgYWx0ZXJuYXRpdmUgbnVtYmVyIGZvciB0aGUgZGVjaXNpb24gd2hpY2ggaXNcclxuXHQgKiBndWFyZGVkIGJ5IHRoZSBzZW1hbnRpYyBjb250ZXh0IGBzZW1jdHhgLiBTZWUge0BsaW5rICNwcmVkaWN0ZWRBbHR9XHJcblx0ICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcblx0ICpcclxuXHQgKiBAc2VlIFBhcnNlckFUTlNpbXVsYXRvciNldmFsU2VtYW50aWNDb250ZXh0KFNlbWFudGljQ29udGV4dCwgUGFyc2VyUnVsZUNvbnRleHQsIGludClcclxuXHQgKiBAc2VlIFNlbWFudGljQ29udGV4dCNldmFsKFJlY29nbml6ZXIsIFJ1bGVDb250ZXh0KVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0QE5vdE51bGwgc3RhdGU6IFNpbXVsYXRvclN0YXRlLFxyXG5cdFx0ZGVjaXNpb246IG51bWJlcixcclxuXHRcdEBOb3ROdWxsIGlucHV0OiBUb2tlblN0cmVhbSxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyLFxyXG5cdFx0QE5vdE51bGwgc2VtY3R4OiBTZW1hbnRpY0NvbnRleHQsXHJcblx0XHRldmFsUmVzdWx0OiBib29sZWFuLFxyXG5cdFx0cHJlZGljdGVkQWx0OiBudW1iZXIpIHtcclxuXHJcblx0XHRzdXBlcihkZWNpc2lvbiwgc3RhdGUsIGlucHV0LCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHN0YXRlLnVzZUNvbnRleHQpO1xyXG5cdFx0dGhpcy5zZW1jdHggPSBzZW1jdHg7XHJcblx0XHR0aGlzLmV2YWxSZXN1bHQgPSBldmFsUmVzdWx0O1xyXG5cdFx0dGhpcy5wcmVkaWN0ZWRBbHQgPSBwcmVkaWN0ZWRBbHQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNi40MTg4MzUyLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBbWJpZ3VpdHlJbmZvIH0gZnJvbSBcIi4vQW1iaWd1aXR5SW5mb1wiO1xyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9BVE5cIjtcclxuaW1wb3J0IHsgQVROQ29uZmlnU2V0IH0gZnJvbSBcIi4vQVROQ29uZmlnU2V0XCI7XHJcbmltcG9ydCB7IEFUTlNpbXVsYXRvciB9IGZyb20gXCIuL0FUTlNpbXVsYXRvclwiO1xyXG5pbXBvcnQgeyBCaXRTZXQgfSBmcm9tIFwiLi4vbWlzYy9CaXRTZXRcIjtcclxuaW1wb3J0IHsgQ29udGV4dFNlbnNpdGl2aXR5SW5mbyB9IGZyb20gXCIuL0NvbnRleHRTZW5zaXRpdml0eUluZm9cIjtcclxuaW1wb3J0IHsgRGVjaXNpb25JbmZvIH0gZnJvbSBcIi4vRGVjaXNpb25JbmZvXCI7XHJcbmltcG9ydCB7IERGQSB9IGZyb20gXCIuLi9kZmEvREZBXCI7XHJcbmltcG9ydCB7IERGQVN0YXRlIH0gZnJvbSBcIi4uL2RmYS9ERkFTdGF0ZVwiO1xyXG5pbXBvcnQgeyBFcnJvckluZm8gfSBmcm9tIFwiLi9FcnJvckluZm9cIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBMb29rYWhlYWRFdmVudEluZm8gfSBmcm9tIFwiLi9Mb29rYWhlYWRFdmVudEluZm9cIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4uL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJBVE5TaW11bGF0b3IgfSBmcm9tIFwiLi9QYXJzZXJBVE5TaW11bGF0b3JcIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUHJlZGljYXRlRXZhbEluZm8gfSBmcm9tIFwiLi9QcmVkaWNhdGVFdmFsSW5mb1wiO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uQ29udGV4dENhY2hlIH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRDYWNoZVwiO1xyXG5pbXBvcnQgeyBTZW1hbnRpY0NvbnRleHQgfSBmcm9tIFwiLi9TZW1hbnRpY0NvbnRleHRcIjtcclxuaW1wb3J0IHsgU2ltdWxhdG9yU3RhdGUgfSBmcm9tIFwiLi9TaW11bGF0b3JTdGF0ZVwiO1xyXG5pbXBvcnQgeyBUb2tlblN0cmVhbSB9IGZyb20gXCIuLi9Ub2tlblN0cmVhbVwiO1xyXG5cclxuLyoqXHJcbiAqIEBzaW5jZSA0LjNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcm9maWxpbmdBVE5TaW11bGF0b3IgZXh0ZW5kcyBQYXJzZXJBVE5TaW11bGF0b3Ige1xyXG5cdHByb3RlY3RlZCBkZWNpc2lvbnM6IERlY2lzaW9uSW5mb1tdO1xyXG5cdHByb3RlY3RlZCBudW1EZWNpc2lvbnM6IG51bWJlcjtcclxuXHJcblx0cHJvdGVjdGVkIF9pbnB1dDogVG9rZW5TdHJlYW0gfCB1bmRlZmluZWQ7XHJcblx0cHJvdGVjdGVkIF9zdGFydEluZGV4OiBudW1iZXIgPSAwO1xyXG5cdHByb3RlY3RlZCBfc2xsU3RvcEluZGV4OiBudW1iZXIgPSAwO1xyXG5cdHByb3RlY3RlZCBfbGxTdG9wSW5kZXg6IG51bWJlciA9IDA7XHJcblxyXG5cdHByb3RlY3RlZCBjdXJyZW50RGVjaXNpb246IG51bWJlciA9IDA7XHJcblx0cHJvdGVjdGVkIGN1cnJlbnRTdGF0ZTogU2ltdWxhdG9yU3RhdGUgfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKiBBdCB0aGUgcG9pbnQgb2YgTEwgZmFpbG92ZXIsIHdlIHJlY29yZCBob3cgU0xMIHdvdWxkIHJlc29sdmUgdGhlIGNvbmZsaWN0IHNvIHRoYXRcclxuXHQgKiAgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGRlY2lzaW9uIC8gaW5wdXQgcGFpciBpcyBjb250ZXh0LXNlbnNpdGl2ZS5cclxuXHQgKiAgSWYgTEwgZ2l2ZXMgYSBkaWZmZXJlbnQgcmVzdWx0IHRoYW4gU0xMJ3MgcHJlZGljdGVkIGFsdGVybmF0aXZlLCB3ZSBoYXZlIGFcclxuXHQgKiAgY29udGV4dCBzZW5zaXRpdml0eSBmb3Igc3VyZS4gVGhlIGNvbnZlcnNlIGlzIG5vdCBuZWNlc3NhcmlseSB0cnVlLCBob3dldmVyLlxyXG5cdCAqICBJdCdzIHBvc3NpYmxlIHRoYXQgYWZ0ZXIgY29uZmxpY3QgcmVzb2x1dGlvbiBjaG9vc2VzIG1pbmltdW0gYWx0ZXJuYXRpdmVzLFxyXG5cdCAqICBTTEwgY291bGQgZ2V0IHRoZSBzYW1lIGFuc3dlciBhcyBMTC4gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgcmVzdWx0IGluZGljYXRlc1xyXG5cdCAqICBhbiBhbWJpZ3VpdHksIGl0IGlzIG5vdCB0cmVhdGVkIGFzIGEgY29udGV4dCBzZW5zaXRpdml0eSBiZWNhdXNlIExMIHByZWRpY3Rpb25cclxuXHQgKiAgd2FzIG5vdCByZXF1aXJlZCBpbiBvcmRlciB0byBwcm9kdWNlIGEgY29ycmVjdCBwcmVkaWN0aW9uIGZvciB0aGlzIGRlY2lzaW9uIGFuZCBpbnB1dCBzZXF1ZW5jZS5cclxuXHQgKiAgSXQgbWF5IGluIGZhY3Qgc3RpbGwgYmUgYSBjb250ZXh0IHNlbnNpdGl2aXR5IGJ1dCB3ZSBkb24ndCBrbm93IGJ5IGxvb2tpbmcgYXQgdGhlXHJcblx0ICogIG1pbmltdW0gYWx0ZXJuYXRpdmVzIGZvciB0aGUgY3VycmVudCBpbnB1dC5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgY29uZmxpY3RpbmdBbHRSZXNvbHZlZEJ5U0xMOiBudW1iZXIgPSAwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihwYXJzZXI6IFBhcnNlcikge1xyXG5cdFx0c3VwZXIocGFyc2VyLmludGVycHJldGVyLmF0biwgcGFyc2VyKTtcclxuXHRcdHRoaXMub3B0aW1pemVfbGwxID0gZmFsc2U7XHJcblx0XHR0aGlzLnJlcG9ydEFtYmlndWl0aWVzID0gdHJ1ZTtcclxuXHRcdHRoaXMubnVtRGVjaXNpb25zID0gdGhpcy5hdG4uZGVjaXNpb25Ub1N0YXRlLmxlbmd0aDtcclxuXHRcdHRoaXMuZGVjaXNpb25zID0gW107XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtRGVjaXNpb25zOyBpKyspIHtcclxuXHRcdFx0dGhpcy5kZWNpc2lvbnMucHVzaChuZXcgRGVjaXNpb25JbmZvKGkpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhZGFwdGl2ZVByZWRpY3QoLypATm90TnVsbCovIGlucHV0OiBUb2tlblN0cmVhbSwgZGVjaXNpb246IG51bWJlciwgb3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCk6IG51bWJlcjtcclxuXHRwdWJsaWMgYWRhcHRpdmVQcmVkaWN0KC8qQE5vdE51bGwqLyBpbnB1dDogVG9rZW5TdHJlYW0sIGRlY2lzaW9uOiBudW1iZXIsIG91dGVyQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsIHVzZUNvbnRleHQ6IGJvb2xlYW4pOiBudW1iZXI7XHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGFkYXB0aXZlUHJlZGljdChcclxuXHRcdEBOb3ROdWxsIGlucHV0OiBUb2tlblN0cmVhbSxcclxuXHRcdGRlY2lzaW9uOiBudW1iZXIsXHJcblx0XHRvdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLFxyXG5cdFx0dXNlQ29udGV4dD86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cdFx0aWYgKHVzZUNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gc3VwZXIuYWRhcHRpdmVQcmVkaWN0KGlucHV0LCBkZWNpc2lvbiwgb3V0ZXJDb250ZXh0LCB1c2VDb250ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHR0aGlzLl9pbnB1dCA9IGlucHV0O1xyXG5cdFx0XHR0aGlzLl9zdGFydEluZGV4ID0gaW5wdXQuaW5kZXg7XHJcblx0XHRcdC8vIGl0J3MgcG9zc2libGUgZm9yIFNMTCB0byByZWFjaCBhIGNvbmZsaWN0IHN0YXRlIHdpdGhvdXQgY29uc3VtaW5nIGFueSBpbnB1dFxyXG5cdFx0XHR0aGlzLl9zbGxTdG9wSW5kZXggPSB0aGlzLl9zdGFydEluZGV4IC0gMTtcclxuXHRcdFx0dGhpcy5fbGxTdG9wSW5kZXggPSAtMTtcclxuXHRcdFx0dGhpcy5jdXJyZW50RGVjaXNpb24gPSBkZWNpc2lvbjtcclxuXHRcdFx0dGhpcy5jdXJyZW50U3RhdGUgPSB1bmRlZmluZWQ7XHJcblx0XHRcdHRoaXMuY29uZmxpY3RpbmdBbHRSZXNvbHZlZEJ5U0xMID0gQVROLklOVkFMSURfQUxUX05VTUJFUjtcclxuXHRcdFx0bGV0IHN0YXJ0OiBudW1iZXJbXSA9IHByb2Nlc3MuaHJ0aW1lKCk7XHJcblx0XHRcdGxldCBhbHQ6IG51bWJlciA9IHN1cGVyLmFkYXB0aXZlUHJlZGljdChpbnB1dCwgZGVjaXNpb24sIG91dGVyQ29udGV4dCk7XHJcblx0XHRcdGxldCBzdG9wOiBudW1iZXJbXSA9IHByb2Nlc3MuaHJ0aW1lKCk7XHJcblxyXG5cdFx0XHRsZXQgbmFub3NlY29uZHM6IG51bWJlciA9IChzdG9wWzBdIC0gc3RhcnRbMF0pICogMTAwMDAwMDAwMDtcclxuXHRcdFx0aWYgKG5hbm9zZWNvbmRzID09PSAwKSB7XHJcblx0XHRcdFx0bmFub3NlY29uZHMgPSBzdG9wWzFdIC0gc3RhcnRbMV07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gQWRkIG5hbm9zZWNvbmRzIGZyb20gc3RhcnQgdG8gZW5kIG9mIHRoYXQgc2Vjb25kLCBwbHVzIHN0YXJ0IG9mIHRoZSBlbmQgc2Vjb25kIHRvIGVuZFxyXG5cdFx0XHRcdG5hbm9zZWNvbmRzICs9ICgxMDAwMDAwMDAwIC0gc3RhcnRbMV0pICsgc3RvcFsxXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLnRpbWVJblByZWRpY3Rpb24gKz0gbmFub3NlY29uZHM7XHJcblx0XHRcdHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5pbnZvY2F0aW9ucysrO1xyXG5cclxuXHRcdFx0bGV0IFNMTF9rOiBudW1iZXIgPSB0aGlzLl9zbGxTdG9wSW5kZXggLSB0aGlzLl9zdGFydEluZGV4ICsgMTtcclxuXHRcdFx0dGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9Ub3RhbExvb2sgKz0gU0xMX2s7XHJcblx0XHRcdHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5TTExfTWluTG9vayA9IHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5TTExfTWluTG9vayA9PT0gMCA/IFNMTF9rIDogTWF0aC5taW4odGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9NaW5Mb29rLCBTTExfayk7XHJcblx0XHRcdGlmIChTTExfayA+IHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5TTExfTWF4TG9vaykge1xyXG5cdFx0XHRcdHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5TTExfTWF4TG9vayA9IFNMTF9rO1xyXG5cdFx0XHRcdHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5TTExfTWF4TG9va0V2ZW50ID1cclxuXHRcdFx0XHRcdG5ldyBMb29rYWhlYWRFdmVudEluZm8oZGVjaXNpb24sIHVuZGVmaW5lZCwgYWx0LCBpbnB1dCwgdGhpcy5fc3RhcnRJbmRleCwgdGhpcy5fc2xsU3RvcEluZGV4LCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aGlzLl9sbFN0b3BJbmRleCA+PSAwKSB7XHJcblx0XHRcdFx0bGV0IExMX2s6IG51bWJlciA9IHRoaXMuX2xsU3RvcEluZGV4IC0gdGhpcy5fc3RhcnRJbmRleCArIDE7XHJcblx0XHRcdFx0dGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLkxMX1RvdGFsTG9vayArPSBMTF9rO1xyXG5cdFx0XHRcdHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5MTF9NaW5Mb29rID0gdGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLkxMX01pbkxvb2sgPT09IDAgPyBMTF9rIDogTWF0aC5taW4odGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLkxMX01pbkxvb2ssIExMX2spO1xyXG5cdFx0XHRcdGlmIChMTF9rID4gdGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLkxMX01heExvb2spIHtcclxuXHRcdFx0XHRcdHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5MTF9NYXhMb29rID0gTExfaztcclxuXHRcdFx0XHRcdHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5MTF9NYXhMb29rRXZlbnQgPVxyXG5cdFx0XHRcdFx0XHRuZXcgTG9va2FoZWFkRXZlbnRJbmZvKGRlY2lzaW9uLCB1bmRlZmluZWQsIGFsdCwgaW5wdXQsIHRoaXMuX3N0YXJ0SW5kZXgsIHRoaXMuX2xsU3RvcEluZGV4LCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhbHQ7XHJcblx0XHR9XHJcblx0XHRmaW5hbGx5IHtcclxuXHRcdFx0dGhpcy5faW5wdXQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdHRoaXMuY3VycmVudERlY2lzaW9uID0gLTE7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgZ2V0U3RhcnRTdGF0ZShkZmE6IERGQSwgaW5wdXQ6IFRva2VuU3RyZWFtLCBvdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0LCB1c2VDb250ZXh0OiBib29sZWFuKTogU2ltdWxhdG9yU3RhdGUgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IHN0YXRlOiBTaW11bGF0b3JTdGF0ZSB8IHVuZGVmaW5lZCA9IHN1cGVyLmdldFN0YXJ0U3RhdGUoZGZhLCBpbnB1dCwgb3V0ZXJDb250ZXh0LCB1c2VDb250ZXh0KTtcclxuXHRcdHRoaXMuY3VycmVudFN0YXRlID0gc3RhdGU7XHJcblx0XHRyZXR1cm4gc3RhdGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgY29tcHV0ZVN0YXJ0U3RhdGUoZGZhOiBERkEsIGdsb2JhbENvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0LCB1c2VDb250ZXh0OiBib29sZWFuKTogU2ltdWxhdG9yU3RhdGUge1xyXG5cdFx0bGV0IHN0YXRlOiBTaW11bGF0b3JTdGF0ZSA9IHN1cGVyLmNvbXB1dGVTdGFydFN0YXRlKGRmYSwgZ2xvYmFsQ29udGV4dCwgdXNlQ29udGV4dCk7XHJcblx0XHR0aGlzLmN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xyXG5cdFx0cmV0dXJuIHN0YXRlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIGNvbXB1dGVSZWFjaFNldChkZmE6IERGQSwgcHJldmlvdXM6IFNpbXVsYXRvclN0YXRlLCB0OiBudW1iZXIsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IFNpbXVsYXRvclN0YXRlIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICh0aGlzLl9pbnB1dCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGVcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJlYWNoU3RhdGU6IFNpbXVsYXRvclN0YXRlIHwgdW5kZWZpbmVkID0gc3VwZXIuY29tcHV0ZVJlYWNoU2V0KGRmYSwgcHJldmlvdXMsIHQsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRpZiAocmVhY2hTdGF0ZSA9PSBudWxsKSB7XHJcblx0XHRcdC8vIG5vIHJlYWNoIG9uIGN1cnJlbnQgbG9va2FoZWFkIHN5bWJvbC4gRVJST1IuXHJcblx0XHRcdHRoaXMuZGVjaXNpb25zW3RoaXMuY3VycmVudERlY2lzaW9uXS5lcnJvcnMucHVzaChcclxuXHRcdFx0XHRuZXcgRXJyb3JJbmZvKHRoaXMuY3VycmVudERlY2lzaW9uLCBwcmV2aW91cywgdGhpcy5faW5wdXQsIHRoaXMuX3N0YXJ0SW5kZXgsIHRoaXMuX2lucHV0LmluZGV4KSxcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmN1cnJlbnRTdGF0ZSA9IHJlYWNoU3RhdGU7XHJcblx0XHRyZXR1cm4gcmVhY2hTdGF0ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCBnZXRFeGlzdGluZ1RhcmdldFN0YXRlKHByZXZpb3VzRDogREZBU3RhdGUsIHQ6IG51bWJlcik6IERGQVN0YXRlIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2lucHV0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCB0aW1lIHRoZSBpbnB1dCBwb3NpdGlvbiBhZHZhbmNlc1xyXG5cdFx0aWYgKHRoaXMuY3VycmVudFN0YXRlLnVzZUNvbnRleHQpIHtcclxuXHRcdFx0dGhpcy5fbGxTdG9wSW5kZXggPSB0aGlzLl9pbnB1dC5pbmRleDtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9zbGxTdG9wSW5kZXggPSB0aGlzLl9pbnB1dC5pbmRleDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZXhpc3RpbmdUYXJnZXRTdGF0ZTogREZBU3RhdGUgfCB1bmRlZmluZWQgPSBzdXBlci5nZXRFeGlzdGluZ1RhcmdldFN0YXRlKHByZXZpb3VzRCwgdCk7XHJcblx0XHRpZiAoZXhpc3RpbmdUYXJnZXRTdGF0ZSAhPSBudWxsKSB7XHJcblx0XHRcdC8vIHRoaXMgbWV0aG9kIGlzIGRpcmVjdGx5IGNhbGxlZCBieSBleGVjREZBOyBtdXN0IGNvbnN0cnVjdCBhIFNpbXVsYXRvclN0YXRlXHJcblx0XHRcdC8vIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCBzdGF0ZSBmb3IgdGhpcyBjYXNlXHJcblx0XHRcdHRoaXMuY3VycmVudFN0YXRlID0gbmV3IFNpbXVsYXRvclN0YXRlKHRoaXMuY3VycmVudFN0YXRlLm91dGVyQ29udGV4dCwgZXhpc3RpbmdUYXJnZXRTdGF0ZSwgdGhpcy5jdXJyZW50U3RhdGUudXNlQ29udGV4dCwgdGhpcy5jdXJyZW50U3RhdGUucmVtYWluaW5nT3V0ZXJDb250ZXh0KTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRTdGF0ZS51c2VDb250ZXh0KSB7XHJcblx0XHRcdFx0dGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLkxMX0RGQVRyYW5zaXRpb25zKys7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLlNMTF9ERkFUcmFuc2l0aW9ucysrOyAvLyBjb3VudCBvbmx5IGlmIHdlIHRyYW5zaXRpb24gb3ZlciBhIERGQSBzdGF0ZVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZXhpc3RpbmdUYXJnZXRTdGF0ZSA9PT0gQVROU2ltdWxhdG9yLkVSUk9SKSB7XHJcblx0XHRcdFx0bGV0IHN0YXRlOiBTaW11bGF0b3JTdGF0ZSA9IG5ldyBTaW11bGF0b3JTdGF0ZSh0aGlzLmN1cnJlbnRTdGF0ZS5vdXRlckNvbnRleHQsIHByZXZpb3VzRCwgdGhpcy5jdXJyZW50U3RhdGUudXNlQ29udGV4dCwgdGhpcy5jdXJyZW50U3RhdGUucmVtYWluaW5nT3V0ZXJDb250ZXh0KTtcclxuXHRcdFx0XHR0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uZXJyb3JzLnB1c2goXHJcblx0XHRcdFx0XHRuZXcgRXJyb3JJbmZvKHRoaXMuY3VycmVudERlY2lzaW9uLCBzdGF0ZSwgdGhpcy5faW5wdXQsIHRoaXMuX3N0YXJ0SW5kZXgsIHRoaXMuX2lucHV0LmluZGV4KSxcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV4aXN0aW5nVGFyZ2V0U3RhdGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgY29tcHV0ZVRhcmdldFN0YXRlKGRmYTogREZBLCBzOiBERkFTdGF0ZSwgcmVtYWluaW5nR2xvYmFsQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQsIHQ6IG51bWJlciwgdXNlQ29udGV4dDogYm9vbGVhbiwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogW0RGQVN0YXRlLCBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZF0ge1xyXG5cdFx0bGV0IHRhcmdldFN0YXRlOiBbREZBU3RhdGUsIFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkXSA9IHN1cGVyLmNvbXB1dGVUYXJnZXRTdGF0ZShkZmEsIHMsIHJlbWFpbmluZ0dsb2JhbENvbnRleHQsIHQsIHVzZUNvbnRleHQsIGNvbnRleHRDYWNoZSk7XHJcblxyXG5cdFx0aWYgKHVzZUNvbnRleHQpIHtcclxuXHRcdFx0dGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLkxMX0FUTlRyYW5zaXRpb25zKys7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLlNMTF9BVE5UcmFuc2l0aW9ucysrO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXRTdGF0ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCBldmFsU2VtYW50aWNDb250ZXh0SW1wbChwcmVkOiBTZW1hbnRpY0NvbnRleHQsIHBhcnNlckNhbGxTdGFjazogUGFyc2VyUnVsZUNvbnRleHQsIGFsdDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9pbnB1dCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGVcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJlc3VsdDogYm9vbGVhbiA9IHN1cGVyLmV2YWxTZW1hbnRpY0NvbnRleHRJbXBsKHByZWQsIHBhcnNlckNhbGxTdGFjaywgYWx0KTtcclxuXHRcdGlmICghKHByZWQgaW5zdGFuY2VvZiBTZW1hbnRpY0NvbnRleHQuUHJlY2VkZW5jZVByZWRpY2F0ZSkpIHtcclxuXHRcdFx0bGV0IGZ1bGxDb250ZXh0OiBib29sZWFuID0gdGhpcy5fbGxTdG9wSW5kZXggPj0gMDtcclxuXHRcdFx0bGV0IHN0b3BJbmRleDogbnVtYmVyID0gZnVsbENvbnRleHQgPyB0aGlzLl9sbFN0b3BJbmRleCA6IHRoaXMuX3NsbFN0b3BJbmRleDtcclxuXHRcdFx0dGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLnByZWRpY2F0ZUV2YWxzLnB1c2goXHJcblx0XHRcdFx0bmV3IFByZWRpY2F0ZUV2YWxJbmZvKHRoaXMuY3VycmVudFN0YXRlLCB0aGlzLmN1cnJlbnREZWNpc2lvbiwgdGhpcy5faW5wdXQsIHRoaXMuX3N0YXJ0SW5kZXgsIHN0b3BJbmRleCwgcHJlZCwgcmVzdWx0LCBhbHQpLFxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgcmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KGRmYTogREZBLCBwcmVkaWN0aW9uOiBudW1iZXIsIGFjY2VwdFN0YXRlOiBTaW11bGF0b3JTdGF0ZSwgc3RhcnRJbmRleDogbnVtYmVyLCBzdG9wSW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuX2lucHV0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJlZGljdGlvbiAhPT0gdGhpcy5jb25mbGljdGluZ0FsdFJlc29sdmVkQnlTTEwpIHtcclxuXHRcdFx0dGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLmNvbnRleHRTZW5zaXRpdml0aWVzLnB1c2goXHJcblx0XHRcdFx0bmV3IENvbnRleHRTZW5zaXRpdml0eUluZm8odGhpcy5jdXJyZW50RGVjaXNpb24sIGFjY2VwdFN0YXRlLCB0aGlzLl9pbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4KSxcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHRcdHN1cGVyLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eShkZmEsIHByZWRpY3Rpb24sIGFjY2VwdFN0YXRlLCBzdGFydEluZGV4LCBzdG9wSW5kZXgpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIHJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dChkZmE6IERGQSwgY29uZmxpY3RpbmdBbHRzOiBCaXRTZXQsIGNvbmZsaWN0U3RhdGU6IFNpbXVsYXRvclN0YXRlLCBzdGFydEluZGV4OiBudW1iZXIsIHN0b3BJbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAoY29uZmxpY3RpbmdBbHRzICE9IG51bGwpIHtcclxuXHRcdFx0dGhpcy5jb25mbGljdGluZ0FsdFJlc29sdmVkQnlTTEwgPSBjb25mbGljdGluZ0FsdHMubmV4dFNldEJpdCgwKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNvbmZsaWN0aW5nQWx0UmVzb2x2ZWRCeVNMTCA9IGNvbmZsaWN0U3RhdGUuczAuY29uZmlncy5nZXRSZXByZXNlbnRlZEFsdGVybmF0aXZlcygpLm5leHRTZXRCaXQoMCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uTExfRmFsbGJhY2srKztcclxuXHRcdHN1cGVyLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dChkZmEsIGNvbmZsaWN0aW5nQWx0cywgY29uZmxpY3RTdGF0ZSwgc3RhcnRJbmRleCwgc3RvcEluZGV4KTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCByZXBvcnRBbWJpZ3VpdHkoQE5vdE51bGwgZGZhOiBERkEsIEQ6IERGQVN0YXRlLCBzdGFydEluZGV4OiBudW1iZXIsIHN0b3BJbmRleDogbnVtYmVyLCBleGFjdDogYm9vbGVhbiwgQE5vdE51bGwgYW1iaWdBbHRzOiBCaXRTZXQsIEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuY3VycmVudFN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5faW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBwcmVkaWN0aW9uOiBudW1iZXI7XHJcblx0XHRpZiAoYW1iaWdBbHRzICE9IG51bGwpIHtcclxuXHRcdFx0cHJlZGljdGlvbiA9IGFtYmlnQWx0cy5uZXh0U2V0Qml0KDApO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHByZWRpY3Rpb24gPSBjb25maWdzLmdldFJlcHJlc2VudGVkQWx0ZXJuYXRpdmVzKCkubmV4dFNldEJpdCgwKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLmNvbmZsaWN0aW5nQWx0UmVzb2x2ZWRCeVNMTCAhPT0gQVROLklOVkFMSURfQUxUX05VTUJFUiAmJiBwcmVkaWN0aW9uICE9PSB0aGlzLmNvbmZsaWN0aW5nQWx0UmVzb2x2ZWRCeVNMTCkge1xyXG5cdFx0XHQvLyBFdmVuIHRob3VnaCB0aGlzIGlzIGFuIGFtYmlndWl0eSB3ZSBhcmUgcmVwb3J0aW5nLCB3ZSBjYW5cclxuXHRcdFx0Ly8gc3RpbGwgZGV0ZWN0IHNvbWUgY29udGV4dCBzZW5zaXRpdml0aWVzLiAgQm90aCBTTEwgYW5kIExMXHJcblx0XHRcdC8vIGFyZSBzaG93aW5nIGEgY29uZmxpY3QsIGhlbmNlIGFuIGFtYmlndWl0eSwgYnV0IGlmIHRoZXkgcmVzb2x2ZVxyXG5cdFx0XHQvLyB0byBkaWZmZXJlbnQgbWluaW11bSBhbHRlcm5hdGl2ZXMgd2UgaGF2ZSBhbHNvIGlkZW50aWZpZWQgYVxyXG5cdFx0XHQvLyBjb250ZXh0IHNlbnNpdGl2aXR5LlxyXG5cdFx0XHR0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uY29udGV4dFNlbnNpdGl2aXRpZXMucHVzaChcclxuXHRcdFx0XHRuZXcgQ29udGV4dFNlbnNpdGl2aXR5SW5mbyh0aGlzLmN1cnJlbnREZWNpc2lvbiwgdGhpcy5jdXJyZW50U3RhdGUsIHRoaXMuX2lucHV0LCBzdGFydEluZGV4LCBzdG9wSW5kZXgpLFxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLmFtYmlndWl0aWVzLnB1c2goXHJcblx0XHRcdG5ldyBBbWJpZ3VpdHlJbmZvKHRoaXMuY3VycmVudERlY2lzaW9uLCB0aGlzLmN1cnJlbnRTdGF0ZSwgYW1iaWdBbHRzLCB0aGlzLl9pbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4KSxcclxuXHRcdCk7XHJcblx0XHRzdXBlci5yZXBvcnRBbWJpZ3VpdHkoZGZhLCBELCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGV4YWN0LCBhbWJpZ0FsdHMsIGNvbmZpZ3MpO1xyXG5cdH1cclxuXHJcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cdHB1YmxpYyBnZXREZWNpc2lvbkluZm8oKTogRGVjaXNpb25JbmZvW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuZGVjaXNpb25zO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldEN1cnJlbnRTdGF0ZSgpOiBTaW11bGF0b3JTdGF0ZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50U3RhdGU7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Mi40Mzk5MTkzLTA3OjAwXHJcblxyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiLi9taXNjL1V0aWxzXCI7XHJcblxyXG5pbXBvcnQgeyBBTlRMUkVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi9BTlRMUkVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgQU5UTFJFcnJvclN0cmF0ZWd5IH0gZnJvbSBcIi4vQU5UTFJFcnJvclN0cmF0ZWd5XCI7XHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuL2F0bi9BVE5cIjtcclxuaW1wb3J0IHsgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyB9IGZyb20gXCIuL2F0bi9BVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zXCI7XHJcbmltcG9ydCB7IEFUTkRlc2VyaWFsaXplciB9IGZyb20gXCIuL2F0bi9BVE5EZXNlcmlhbGl6ZXJcIjtcclxuaW1wb3J0IHsgQVROU2ltdWxhdG9yIH0gZnJvbSBcIi4vYXRuL0FUTlNpbXVsYXRvclwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL2F0bi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBEZWZhdWx0RXJyb3JTdHJhdGVneSB9IGZyb20gXCIuL0RlZmF1bHRFcnJvclN0cmF0ZWd5XCI7XHJcbmltcG9ydCB7IERGQSB9IGZyb20gXCIuL2RmYS9ERkFcIjtcclxuaW1wb3J0IHsgRXJyb3JOb2RlIH0gZnJvbSBcIi4vdHJlZS9FcnJvck5vZGVcIjtcclxuaW1wb3J0IHsgSW50ZWdlclN0YWNrIH0gZnJvbSBcIi4vbWlzYy9JbnRlZ2VyU3RhY2tcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWxTZXQgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsU2V0XCI7XHJcbmltcG9ydCB7IEludFN0cmVhbSB9IGZyb20gXCIuL0ludFN0cmVhbVwiO1xyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuL0xleGVyXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlLCBOb3ROdWxsLCBOdWxsYWJsZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VJbmZvIH0gZnJvbSBcIi4vYXRuL1BhcnNlSW5mb1wiO1xyXG5pbXBvcnQgeyBQYXJzZXJBVE5TaW11bGF0b3IgfSBmcm9tIFwiLi9hdG4vUGFyc2VyQVROU2ltdWxhdG9yXCI7XHJcbmltcG9ydCB7IFBhcnNlckVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi9QYXJzZXJFcnJvckxpc3RlbmVyXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlTGlzdGVuZXIgfSBmcm9tIFwiLi90cmVlL1BhcnNlVHJlZUxpc3RlbmVyXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZVBhdHRlcm4gfSBmcm9tIFwiLi90cmVlL3BhdHRlcm4vUGFyc2VUcmVlUGF0dGVyblwiO1xyXG5pbXBvcnQgeyBQcm94eVBhcnNlckVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi9Qcm94eVBhcnNlckVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4vUmVjb2duaXplclwiO1xyXG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCIuL1J1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IFJ1bGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vYXRuL1J1bGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuL3RyZWUvVGVybWluYWxOb2RlXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5GYWN0b3J5IH0gZnJvbSBcIi4vVG9rZW5GYWN0b3J5XCI7XHJcbmltcG9ydCB7IFRva2VuU291cmNlIH0gZnJvbSBcIi4vVG9rZW5Tb3VyY2VcIjtcclxuaW1wb3J0IHsgVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi9Ub2tlblN0cmVhbVwiO1xyXG5cclxuY2xhc3MgVHJhY2VMaXN0ZW5lciBpbXBsZW1lbnRzIFBhcnNlVHJlZUxpc3RlbmVyIHtcclxuXHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJ1bGVOYW1lczogc3RyaW5nW10sIHByaXZhdGUgdG9rZW5TdHJlYW06IFRva2VuU3RyZWFtKSB7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZW50ZXJFdmVyeVJ1bGUoY3R4OiBQYXJzZXJSdWxlQ29udGV4dCk6IHZvaWQge1xyXG5cdFx0Y29uc29sZS5sb2coXCJlbnRlciAgIFwiICsgdGhpcy5ydWxlTmFtZXNbY3R4LnJ1bGVJbmRleF0gK1xyXG5cdFx0XHRcIiwgTFQoMSk9XCIgKyB0aGlzLnRva2VuU3RyZWFtLkxUKDEpLnRleHQpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGV4aXRFdmVyeVJ1bGUoY3R4OiBQYXJzZXJSdWxlQ29udGV4dCk6IHZvaWQge1xyXG5cdFx0Y29uc29sZS5sb2coXCJleGl0ICAgIFwiICsgdGhpcy5ydWxlTmFtZXNbY3R4LnJ1bGVJbmRleF0gK1xyXG5cdFx0XHRcIiwgTFQoMSk9XCIgKyB0aGlzLnRva2VuU3RyZWFtLkxUKDEpLnRleHQpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHZpc2l0RXJyb3JOb2RlKG5vZGU6IEVycm9yTm9kZSk6IHZvaWQge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHZpc2l0VGVybWluYWwobm9kZTogVGVybWluYWxOb2RlKTogdm9pZCB7XHJcblx0XHRsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnQhLnJ1bGVDb250ZXh0O1xyXG5cdFx0bGV0IHRva2VuOiBUb2tlbiA9IG5vZGUuc3ltYm9sO1xyXG5cdFx0Y29uc29sZS5sb2coXCJjb25zdW1lIFwiICsgdG9rZW4gKyBcIiBydWxlIFwiICsgdGhpcy5ydWxlTmFtZXNbcGFyZW50LnJ1bGVJbmRleF0pO1xyXG5cdH1cclxufVxyXG5cclxuLyoqIFRoaXMgaXMgYWxsIHRoZSBwYXJzaW5nIHN1cHBvcnQgY29kZSBlc3NlbnRpYWxseTsgbW9zdCBvZiBpdCBpcyBlcnJvciByZWNvdmVyeSBzdHVmZi4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBhcnNlciBleHRlbmRzIFJlY29nbml6ZXI8VG9rZW4sIFBhcnNlckFUTlNpbXVsYXRvcj4ge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgZmllbGQgbWFwcyBmcm9tIHRoZSBzZXJpYWxpemVkIEFUTiBzdHJpbmcgdG8gdGhlIGRlc2VyaWFsaXplZCB7QGxpbmsgQVROfSB3aXRoXHJcblx0ICogYnlwYXNzIGFsdGVybmF0aXZlcy5cclxuXHQgKlxyXG5cdCAqIEBzZWUgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5pc0dlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zXHJcblx0ICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgYnlwYXNzQWx0c0F0bkNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIEFUTj4oKTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGVycm9yIGhhbmRsaW5nIHN0cmF0ZWd5IGZvciB0aGUgcGFyc2VyLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhIG5ld1xyXG5cdCAqIGluc3RhbmNlIG9mIHtAbGluayBEZWZhdWx0RXJyb3JTdHJhdGVneX0uXHJcblx0ICpcclxuXHQgKiBAc2VlICNnZXRFcnJvckhhbmRsZXJcclxuXHQgKiBAc2VlICNzZXRFcnJvckhhbmRsZXJcclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBfZXJySGFuZGxlcjogQU5UTFJFcnJvclN0cmF0ZWd5ID0gbmV3IERlZmF1bHRFcnJvclN0cmF0ZWd5KCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBpbnB1dCBzdHJlYW0uXHJcblx0ICpcclxuXHQgKiBAc2VlICNnZXRJbnB1dFN0cmVhbVxyXG5cdCAqIEBzZWUgI3NldElucHV0U3RyZWFtXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIF9pbnB1dCE6IFRva2VuU3RyZWFtO1xyXG5cclxuXHRwcm90ZWN0ZWQgcmVhZG9ubHkgX3ByZWNlZGVuY2VTdGFjazogSW50ZWdlclN0YWNrID0gbmV3IEludGVnZXJTdGFjaygpO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0fSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHJ1bGUuXHJcblx0ICpcclxuXHQgKiBUaGlzIGlzIGFsd2F5cyBub24tdW5kZWZpbmVkIGR1cmluZyB0aGUgcGFyc2luZyBwcm9jZXNzLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBfY3R4ITogUGFyc2VyUnVsZUNvbnRleHQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGUgcGFyc2VyIHNob3VsZCBjb25zdHJ1Y3QgYSBwYXJzZSB0cmVlIGR1cmluZ1xyXG5cdCAqIHRoZSBwYXJzaW5nIHByb2Nlc3MuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cclxuXHQgKlxyXG5cdCAqIEBzZWUgYGJ1aWxkUGFyc2VUcmVlYFxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX2J1aWxkUGFyc2VUcmVlczogYm9vbGVhbiA9IHRydWU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZW4ge0BsaW5rICNzZXRUcmFjZX1gKHRydWUpYCBpcyBjYWxsZWQsIGEgcmVmZXJlbmNlIHRvIHRoZVxyXG5cdCAqIHtAbGluayBUcmFjZUxpc3RlbmVyfSBpcyBzdG9yZWQgaGVyZSBzbyBpdCBjYW4gYmUgZWFzaWx5IHJlbW92ZWQgaW4gYVxyXG5cdCAqIGxhdGVyIGNhbGwgdG8ge0BsaW5rICNzZXRUcmFjZX1gKGZhbHNlKWAuIFRoZSBsaXN0ZW5lciBpdHNlbGYgaXNcclxuXHQgKiBpbXBsZW1lbnRlZCBhcyBhIHBhcnNlciBsaXN0ZW5lciBzbyB0aGlzIGZpZWxkIGlzIG5vdCBkaXJlY3RseSB1c2VkIGJ5XHJcblx0ICogb3RoZXIgcGFyc2VyIG1ldGhvZHMuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfdHJhY2VyOiBUcmFjZUxpc3RlbmVyIHwgdW5kZWZpbmVkO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbGlzdCBvZiB7QGxpbmsgUGFyc2VUcmVlTGlzdGVuZXJ9IGxpc3RlbmVycyByZWdpc3RlcmVkIHRvIHJlY2VpdmVcclxuXHQgKiBldmVudHMgZHVyaW5nIHRoZSBwYXJzZS5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI2FkZFBhcnNlTGlzdGVuZXJcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgX3BhcnNlTGlzdGVuZXJzOiBQYXJzZVRyZWVMaXN0ZW5lcltdID0gW107XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBudW1iZXIgb2Ygc3ludGF4IGVycm9ycyByZXBvcnRlZCBkdXJpbmcgcGFyc2luZy4gVGhpcyB2YWx1ZSBpc1xyXG5cdCAqIGluY3JlbWVudGVkIGVhY2ggdGltZSB7QGxpbmsgI25vdGlmeUVycm9yTGlzdGVuZXJzfSBpcyBjYWxsZWQuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIF9zeW50YXhFcnJvcnM6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKiBJbmRpY2F0ZXMgcGFyc2VyIGhhcyBtYXRjaCgpZWQgRU9GIHRva2VuLiBTZWUge0BsaW5rICNleGl0UnVsZSgpfS4gKi9cclxuXHRwcm90ZWN0ZWQgbWF0Y2hlZEVPRjogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihpbnB1dDogVG9rZW5TdHJlYW0pIHtcclxuXHRcdHN1cGVyKCk7XHJcblx0XHR0aGlzLl9wcmVjZWRlbmNlU3RhY2sucHVzaCgwKTtcclxuXHRcdHRoaXMuaW5wdXRTdHJlYW0gPSBpbnB1dDtcclxuXHR9XHJcblxyXG5cdC8qKiByZXNldCB0aGUgcGFyc2VyJ3Mgc3RhdGUgKi9cclxuXHRwdWJsaWMgcmVzZXQoKTogdm9pZDtcclxuXHRwdWJsaWMgcmVzZXQocmVzZXRJbnB1dDogYm9vbGVhbik6IHZvaWQ7XHJcblx0cHVibGljIHJlc2V0KHJlc2V0SW5wdXQ/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHQvLyBOb3RlOiB0aGlzIG1ldGhvZCBleGVjdXRlcyB3aGVuIG5vdCBwYXJzaW5nLCBzbyBfY3R4IGNhbiBiZSB1bmRlZmluZWRcclxuXHRcdGlmIChyZXNldElucHV0ID09PSB1bmRlZmluZWQgfHwgcmVzZXRJbnB1dCkge1xyXG5cdFx0XHR0aGlzLmlucHV0U3RyZWFtLnNlZWsoMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXJySGFuZGxlci5yZXNldCh0aGlzKTtcclxuXHRcdHRoaXMuX2N0eCA9IHVuZGVmaW5lZCBhcyBhbnk7XHJcblx0XHR0aGlzLl9zeW50YXhFcnJvcnMgPSAwO1xyXG5cdFx0dGhpcy5tYXRjaGVkRU9GID0gZmFsc2U7XHJcblx0XHR0aGlzLmlzVHJhY2UgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3ByZWNlZGVuY2VTdGFjay5jbGVhcigpO1xyXG5cdFx0dGhpcy5fcHJlY2VkZW5jZVN0YWNrLnB1c2goMCk7XHJcblx0XHRsZXQgaW50ZXJwcmV0ZXI6IEFUTlNpbXVsYXRvciA9IHRoaXMuaW50ZXJwcmV0ZXI7XHJcblx0XHRpZiAoaW50ZXJwcmV0ZXIgIT0gbnVsbCkge1xyXG5cdFx0XHRpbnRlcnByZXRlci5yZXNldCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTWF0Y2ggY3VycmVudCBpbnB1dCBzeW1ib2wgYWdhaW5zdCBgdHR5cGVgLiBJZiB0aGUgc3ltYm9sIHR5cGVcclxuXHQgKiBtYXRjaGVzLCB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5I3JlcG9ydE1hdGNofSBhbmQge0BsaW5rICNjb25zdW1lfSBhcmVcclxuXHQgKiBjYWxsZWQgdG8gY29tcGxldGUgdGhlIG1hdGNoIHByb2Nlc3MuXHJcblx0ICpcclxuXHQgKiBJZiB0aGUgc3ltYm9sIHR5cGUgZG9lcyBub3QgbWF0Y2gsXHJcblx0ICoge0BsaW5rIEFOVExSRXJyb3JTdHJhdGVneSNyZWNvdmVySW5saW5lfSBpcyBjYWxsZWQgb24gdGhlIGN1cnJlbnQgZXJyb3JcclxuXHQgKiBzdHJhdGVneSB0byBhdHRlbXB0IHJlY292ZXJ5LiBJZiB7QGxpbmsgI2dldEJ1aWxkUGFyc2VUcmVlfSBpc1xyXG5cdCAqIGB0cnVlYCBhbmQgdGhlIHRva2VuIGluZGV4IG9mIHRoZSBzeW1ib2wgcmV0dXJuZWQgYnlcclxuXHQgKiB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5I3JlY292ZXJJbmxpbmV9IGlzIC0xLCB0aGUgc3ltYm9sIGlzIGFkZGVkIHRvXHJcblx0ICogdGhlIHBhcnNlIHRyZWUgYnkgY2FsbGluZyB7QGxpbmsgI2NyZWF0ZUVycm9yTm9kZShQYXJzZXJSdWxlQ29udGV4dCwgVG9rZW4pfSB0aGVuXHJcblx0ICoge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0I2FkZEVycm9yTm9kZShFcnJvck5vZGUpfS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0dHlwZSB0aGUgdG9rZW4gdHlwZSB0byBtYXRjaFxyXG5cdCAqIEByZXR1cm5zIHRoZSBtYXRjaGVkIHN5bWJvbFxyXG5cdCAqIEAgaWYgdGhlIGN1cnJlbnQgaW5wdXQgc3ltYm9sIGRpZCBub3QgbWF0Y2hcclxuXHQgKiBgdHR5cGVgIGFuZCB0aGUgZXJyb3Igc3RyYXRlZ3kgY291bGQgbm90IHJlY292ZXIgZnJvbSB0aGVcclxuXHQgKiBtaXNtYXRjaGVkIHN5bWJvbFxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIG1hdGNoKHR0eXBlOiBudW1iZXIpOiBUb2tlbiB7XHJcblx0XHRsZXQgdDogVG9rZW4gPSB0aGlzLmN1cnJlbnRUb2tlbjtcclxuXHRcdGlmICh0LnR5cGUgPT09IHR0eXBlKSB7XHJcblx0XHRcdGlmICh0dHlwZSA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdFx0dGhpcy5tYXRjaGVkRU9GID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xyXG5cdFx0XHR0aGlzLmNvbnN1bWUoKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0ID0gdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xyXG5cdFx0XHRpZiAodGhpcy5fYnVpbGRQYXJzZVRyZWVzICYmIHQudG9rZW5JbmRleCA9PT0gLTEpIHtcclxuXHRcdFx0XHQvLyB3ZSBtdXN0IGhhdmUgY29uanVyZWQgdXAgYSBuZXcgdG9rZW4gZHVyaW5nIHNpbmdsZSB0b2tlbiBpbnNlcnRpb25cclxuXHRcdFx0XHQvLyBpZiBpdCdzIG5vdCB0aGUgY3VycmVudCBzeW1ib2xcclxuXHRcdFx0XHR0aGlzLl9jdHguYWRkRXJyb3JOb2RlKHRoaXMuY3JlYXRlRXJyb3JOb2RlKHRoaXMuX2N0eCwgdCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE1hdGNoIGN1cnJlbnQgaW5wdXQgc3ltYm9sIGFzIGEgd2lsZGNhcmQuIElmIHRoZSBzeW1ib2wgdHlwZSBtYXRjaGVzXHJcblx0ICogKGkuZS4gaGFzIGEgdmFsdWUgZ3JlYXRlciB0aGFuIDApLCB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5I3JlcG9ydE1hdGNofVxyXG5cdCAqIGFuZCB7QGxpbmsgI2NvbnN1bWV9IGFyZSBjYWxsZWQgdG8gY29tcGxldGUgdGhlIG1hdGNoIHByb2Nlc3MuXHJcblx0ICpcclxuXHQgKiBJZiB0aGUgc3ltYm9sIHR5cGUgZG9lcyBub3QgbWF0Y2gsXHJcblx0ICoge0BsaW5rIEFOVExSRXJyb3JTdHJhdGVneSNyZWNvdmVySW5saW5lfSBpcyBjYWxsZWQgb24gdGhlIGN1cnJlbnQgZXJyb3JcclxuXHQgKiBzdHJhdGVneSB0byBhdHRlbXB0IHJlY292ZXJ5LiBJZiB7QGxpbmsgI2dldEJ1aWxkUGFyc2VUcmVlfSBpc1xyXG5cdCAqIGB0cnVlYCBhbmQgdGhlIHRva2VuIGluZGV4IG9mIHRoZSBzeW1ib2wgcmV0dXJuZWQgYnlcclxuXHQgKiB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5I3JlY292ZXJJbmxpbmV9IGlzIC0xLCB0aGUgc3ltYm9sIGlzIGFkZGVkIHRvXHJcblx0ICogdGhlIHBhcnNlIHRyZWUgYnkgY2FsbGluZyB7QGxpbmsgUGFyc2VyI2NyZWF0ZUVycm9yTm9kZShQYXJzZXJSdWxlQ29udGV4dCwgVG9rZW4pfSB0aGVuXHJcblx0ICoge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0I2FkZEVycm9yTm9kZShFcnJvck5vZGUpfS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHRoZSBtYXRjaGVkIHN5bWJvbFxyXG5cdCAqIEAgaWYgdGhlIGN1cnJlbnQgaW5wdXQgc3ltYm9sIGRpZCBub3QgbWF0Y2hcclxuXHQgKiBhIHdpbGRjYXJkIGFuZCB0aGUgZXJyb3Igc3RyYXRlZ3kgY291bGQgbm90IHJlY292ZXIgZnJvbSB0aGUgbWlzbWF0Y2hlZFxyXG5cdCAqIHN5bWJvbFxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIG1hdGNoV2lsZGNhcmQoKTogVG9rZW4ge1xyXG5cdFx0bGV0IHQ6IFRva2VuID0gdGhpcy5jdXJyZW50VG9rZW47XHJcblx0XHRpZiAodC50eXBlID4gMCkge1xyXG5cdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xyXG5cdFx0XHR0aGlzLmNvbnN1bWUoKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0ID0gdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xyXG5cdFx0XHRpZiAodGhpcy5fYnVpbGRQYXJzZVRyZWVzICYmIHQudG9rZW5JbmRleCA9PT0gLTEpIHtcclxuXHRcdFx0XHQvLyB3ZSBtdXN0IGhhdmUgY29uanVyZWQgdXAgYSBuZXcgdG9rZW4gZHVyaW5nIHNpbmdsZSB0b2tlbiBpbnNlcnRpb25cclxuXHRcdFx0XHQvLyBpZiBpdCdzIG5vdCB0aGUgY3VycmVudCBzeW1ib2xcclxuXHRcdFx0XHR0aGlzLl9jdHguYWRkRXJyb3JOb2RlKHRoaXMuY3JlYXRlRXJyb3JOb2RlKHRoaXMuX2N0eCwgdCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUcmFjayB0aGUge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0fSBvYmplY3RzIGR1cmluZyB0aGUgcGFyc2UgYW5kIGhvb2tcclxuXHQgKiB0aGVtIHVwIHVzaW5nIHRoZSB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHQjY2hpbGRyZW59IGxpc3Qgc28gdGhhdCBpdFxyXG5cdCAqIGZvcm1zIGEgcGFyc2UgdHJlZS4gVGhlIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dH0gcmV0dXJuZWQgZnJvbSB0aGUgc3RhcnRcclxuXHQgKiBydWxlIHJlcHJlc2VudHMgdGhlIHJvb3Qgb2YgdGhlIHBhcnNlIHRyZWUuXHJcblx0ICpcclxuXHQgKiBOb3RlIHRoYXQgaWYgd2UgYXJlIG5vdCBidWlsZGluZyBwYXJzZSB0cmVlcywgcnVsZSBjb250ZXh0cyBvbmx5IHBvaW50XHJcblx0ICogdXB3YXJkcy4gV2hlbiBhIHJ1bGUgZXhpdHMsIGl0IHJldHVybnMgdGhlIGNvbnRleHQgYnV0IHRoYXQgZ2V0cyBnYXJiYWdlXHJcblx0ICogY29sbGVjdGVkIGlmIG5vYm9keSBob2xkcyBhIHJlZmVyZW5jZS4gSXQgcG9pbnRzIHVwd2FyZHMgYnV0IG5vYm9keVxyXG5cdCAqIHBvaW50cyBhdCBpdC5cclxuXHQgKlxyXG5cdCAqIFdoZW4gd2UgYnVpbGQgcGFyc2UgdHJlZXMsIHdlIGFyZSBhZGRpbmcgYWxsIG9mIHRoZXNlIGNvbnRleHRzIHRvXHJcblx0ICoge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0I2NoaWxkcmVufSBsaXN0LiBDb250ZXh0cyBhcmUgdGhlbiBub3QgY2FuZGlkYXRlc1xyXG5cdCAqIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXHJcblx0ICovXHJcblx0c2V0IGJ1aWxkUGFyc2VUcmVlKGJ1aWxkUGFyc2VUcmVlczogYm9vbGVhbikge1xyXG5cdFx0dGhpcy5fYnVpbGRQYXJzZVRyZWVzID0gYnVpbGRQYXJzZVRyZWVzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB3aGV0aGVyIG9yIG5vdCBhIGNvbXBsZXRlIHBhcnNlIHRyZWUgd2lsbCBiZSBjb25zdHJ1Y3RlZCB3aGlsZVxyXG5cdCAqIHBhcnNpbmcuIFRoaXMgcHJvcGVydHkgaXMgYHRydWVgIGZvciBhIG5ld2x5IGNvbnN0cnVjdGVkIHBhcnNlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIGB0cnVlYCBpZiBhIGNvbXBsZXRlIHBhcnNlIHRyZWUgd2lsbCBiZSBjb25zdHJ1Y3RlZCB3aGlsZVxyXG5cdCAqIHBhcnNpbmcsIG90aGVyd2lzZSBgZmFsc2VgXHJcblx0ICovXHJcblx0Z2V0IGJ1aWxkUGFyc2VUcmVlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2J1aWxkUGFyc2VUcmVlcztcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGdldFBhcnNlTGlzdGVuZXJzKCk6IFBhcnNlVHJlZUxpc3RlbmVyW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhcnNlTGlzdGVuZXJzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXJzIGBsaXN0ZW5lcmAgdG8gcmVjZWl2ZSBldmVudHMgZHVyaW5nIHRoZSBwYXJzaW5nIHByb2Nlc3MuXHJcblx0ICpcclxuXHQgKiBUbyBzdXBwb3J0IG91dHB1dC1wcmVzZXJ2aW5nIGdyYW1tYXIgdHJhbnNmb3JtYXRpb25zIChpbmNsdWRpbmcgYnV0IG5vdFxyXG5cdCAqIGxpbWl0ZWQgdG8gbGVmdC1yZWN1cnNpb24gcmVtb3ZhbCwgYXV0b21hdGVkIGxlZnQtZmFjdG9yaW5nLCBhbmRcclxuXHQgKiBvcHRpbWl6ZWQgY29kZSBnZW5lcmF0aW9uKSwgY2FsbHMgdG8gbGlzdGVuZXIgbWV0aG9kcyBkdXJpbmcgdGhlIHBhcnNlXHJcblx0ICogbWF5IGRpZmZlciBzdWJzdGFudGlhbGx5IGZyb20gY2FsbHMgbWFkZSBieVxyXG5cdCAqIHtAbGluayBQYXJzZVRyZWVXYWxrZXIjREVGQVVMVH0gdXNlZCBhZnRlciB0aGUgcGFyc2UgaXMgY29tcGxldGUuIEluXHJcblx0ICogcGFydGljdWxhciwgcnVsZSBlbnRyeSBhbmQgZXhpdCBldmVudHMgbWF5IG9jY3VyIGluIGEgZGlmZmVyZW50IG9yZGVyXHJcblx0ICogZHVyaW5nIHRoZSBwYXJzZSB0aGFuIGFmdGVyIHRoZSBwYXJzZXIuIEluIGFkZGl0aW9uLCBjYWxscyB0byBjZXJ0YWluXHJcblx0ICogcnVsZSBlbnRyeSBtZXRob2RzIG1heSBiZSBvbWl0dGVkLlxyXG5cdCAqXHJcblx0ICogV2l0aCB0aGUgZm9sbG93aW5nIHNwZWNpZmljIGV4Y2VwdGlvbnMsIGNhbGxzIHRvIGxpc3RlbmVyIGV2ZW50cyBhcmVcclxuXHQgKiAqZGV0ZXJtaW5pc3RpYyosIGkuZS4gZm9yIGlkZW50aWNhbCBpbnB1dCB0aGUgY2FsbHMgdG8gbGlzdGVuZXJcclxuXHQgKiBtZXRob2RzIHdpbGwgYmUgdGhlIHNhbWUuXHJcblx0ICpcclxuXHQgKiAqIEFsdGVyYXRpb25zIHRvIHRoZSBncmFtbWFyIHVzZWQgdG8gZ2VuZXJhdGUgY29kZSBtYXkgY2hhbmdlIHRoZVxyXG5cdCAqICAgYmVoYXZpb3Igb2YgdGhlIGxpc3RlbmVyIGNhbGxzLlxyXG5cdCAqICogQWx0ZXJhdGlvbnMgdG8gdGhlIGNvbW1hbmQgbGluZSBvcHRpb25zIHBhc3NlZCB0byBBTlRMUiA0IHdoZW5cclxuXHQgKiAgIGdlbmVyYXRpbmcgdGhlIHBhcnNlciBtYXkgY2hhbmdlIHRoZSBiZWhhdmlvciBvZiB0aGUgbGlzdGVuZXIgY2FsbHMuXHJcblx0ICogKiBDaGFuZ2luZyB0aGUgdmVyc2lvbiBvZiB0aGUgQU5UTFIgVG9vbCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBwYXJzZXJcclxuXHQgKiAgIG1heSBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHRoZSBsaXN0ZW5lciBjYWxscy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgdG8gYWRkXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIHtAbGluayBUeXBlRXJyb3J9IGlmIGBsaXN0ZW5lcmAgaXMgYHVuZGVmaW5lZGBcclxuXHQgKi9cclxuXHRwdWJsaWMgYWRkUGFyc2VMaXN0ZW5lcihATm90TnVsbCBsaXN0ZW5lcjogUGFyc2VUcmVlTGlzdGVuZXIpOiB2b2lkIHtcclxuXHRcdGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XHJcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJsaXN0ZW5lciBjYW5ub3QgYmUgbnVsbFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wYXJzZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZSBgbGlzdGVuZXJgIGZyb20gdGhlIGxpc3Qgb2YgcGFyc2UgbGlzdGVuZXJzLlxyXG5cdCAqXHJcblx0ICogSWYgYGxpc3RlbmVyYCBpcyBgdW5kZWZpbmVkYCBvciBoYXMgbm90IGJlZW4gYWRkZWQgYXMgYSBwYXJzZVxyXG5cdCAqIGxpc3RlbmVyLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXHJcblx0ICpcclxuXHQgKiBAc2VlICNhZGRQYXJzZUxpc3RlbmVyXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyByZW1vdmVQYXJzZUxpc3RlbmVyKGxpc3RlbmVyOiBQYXJzZVRyZWVMaXN0ZW5lcik6IHZvaWQge1xyXG5cdFx0bGV0IGluZGV4ID0gdGhpcy5fcGFyc2VMaXN0ZW5lcnMuZmluZEluZGV4KChsKSA9PiBsID09PSBsaXN0ZW5lcik7XHJcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XHJcblx0XHRcdHRoaXMuX3BhcnNlTGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIGFsbCBwYXJzZSBsaXN0ZW5lcnMuXHJcblx0ICpcclxuXHQgKiBAc2VlICNhZGRQYXJzZUxpc3RlbmVyXHJcblx0ICovXHJcblx0cHVibGljIHJlbW92ZVBhcnNlTGlzdGVuZXJzKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5fcGFyc2VMaXN0ZW5lcnMubGVuZ3RoID0gMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE5vdGlmeSBhbnkgcGFyc2UgbGlzdGVuZXJzIG9mIGFuIGVudGVyIHJ1bGUgZXZlbnQuXHJcblx0ICpcclxuXHQgKiBAc2VlICNhZGRQYXJzZUxpc3RlbmVyXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHRyaWdnZXJFbnRlclJ1bGVFdmVudCgpOiB2b2lkIHtcclxuXHRcdGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3BhcnNlTGlzdGVuZXJzKSB7XHJcblx0XHRcdGlmIChsaXN0ZW5lci5lbnRlckV2ZXJ5UnVsZSkge1xyXG5cdFx0XHRcdGxpc3RlbmVyLmVudGVyRXZlcnlSdWxlKHRoaXMuX2N0eCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX2N0eC5lbnRlclJ1bGUobGlzdGVuZXIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTm90aWZ5IGFueSBwYXJzZSBsaXN0ZW5lcnMgb2YgYW4gZXhpdCBydWxlIGV2ZW50LlxyXG5cdCAqXHJcblx0ICogQHNlZSAjYWRkUGFyc2VMaXN0ZW5lclxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCB0cmlnZ2VyRXhpdFJ1bGVFdmVudCgpOiB2b2lkIHtcclxuXHRcdC8vIHJldmVyc2Ugb3JkZXIgd2FsayBvZiBsaXN0ZW5lcnNcclxuXHRcdGZvciAobGV0IGkgPSB0aGlzLl9wYXJzZUxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRsZXQgbGlzdGVuZXI6IFBhcnNlVHJlZUxpc3RlbmVyID0gdGhpcy5fcGFyc2VMaXN0ZW5lcnNbaV07XHJcblx0XHRcdHRoaXMuX2N0eC5leGl0UnVsZShsaXN0ZW5lcik7XHJcblx0XHRcdGlmIChsaXN0ZW5lci5leGl0RXZlcnlSdWxlKSB7XHJcblx0XHRcdFx0bGlzdGVuZXIuZXhpdEV2ZXJ5UnVsZSh0aGlzLl9jdHgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ludGF4IGVycm9ycyByZXBvcnRlZCBkdXJpbmcgcGFyc2luZy4gVGhpcyB2YWx1ZSBpc1xyXG5cdCAqIGluY3JlbWVudGVkIGVhY2ggdGltZSB7QGxpbmsgI25vdGlmeUVycm9yTGlzdGVuZXJzfSBpcyBjYWxsZWQuXHJcblx0ICpcclxuXHQgKiBAc2VlICNub3RpZnlFcnJvckxpc3RlbmVyc1xyXG5cdCAqL1xyXG5cdGdldCBudW1iZXJPZlN5bnRheEVycm9ycygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3N5bnRheEVycm9ycztcclxuXHR9XHJcblxyXG5cdGdldCB0b2tlbkZhY3RvcnkoKTogVG9rZW5GYWN0b3J5IHtcclxuXHRcdHJldHVybiB0aGlzLl9pbnB1dC50b2tlblNvdXJjZS50b2tlbkZhY3Rvcnk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgQVROIHdpdGggYnlwYXNzIGFsdGVybmF0aXZlcyBpcyBleHBlbnNpdmUgdG8gY3JlYXRlIHNvIHdlIGNyZWF0ZSBpdFxyXG5cdCAqIGxhemlseS5cclxuXHQgKlxyXG5cdCAqIEAgaWYgdGhlIGN1cnJlbnQgcGFyc2VyIGRvZXMgbm90XHJcblx0ICogaW1wbGVtZW50IHRoZSBgc2VyaWFsaXplZEFUTmAgcHJvcGVydHkuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0QVROV2l0aEJ5cGFzc0FsdHMoKTogQVROIHtcclxuXHRcdGxldCBzZXJpYWxpemVkQXRuOiBzdHJpbmcgPSB0aGlzLnNlcmlhbGl6ZWRBVE47XHJcblx0XHRpZiAoc2VyaWFsaXplZEF0biA9PSBudWxsKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHBhcnNlciBkb2VzIG5vdCBzdXBwb3J0IGFuIEFUTiB3aXRoIGJ5cGFzcyBhbHRlcm5hdGl2ZXMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZXN1bHQgPSBQYXJzZXIuYnlwYXNzQWx0c0F0bkNhY2hlLmdldChzZXJpYWxpemVkQXRuKTtcclxuXHRcdGlmIChyZXN1bHQgPT0gbnVsbCkge1xyXG5cdFx0XHRsZXQgZGVzZXJpYWxpemF0aW9uT3B0aW9uczogQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyA9IG5ldyBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zKCk7XHJcblx0XHRcdGRlc2VyaWFsaXphdGlvbk9wdGlvbnMuaXNHZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyA9IHRydWU7XHJcblx0XHRcdHJlc3VsdCA9IG5ldyBBVE5EZXNlcmlhbGl6ZXIoZGVzZXJpYWxpemF0aW9uT3B0aW9ucykuZGVzZXJpYWxpemUoVXRpbHMudG9DaGFyQXJyYXkoc2VyaWFsaXplZEF0bikpO1xyXG5cdFx0XHRQYXJzZXIuYnlwYXNzQWx0c0F0bkNhY2hlLnNldChzZXJpYWxpemVkQXRuLCByZXN1bHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgcHJlZmVycmVkIG1ldGhvZCBvZiBnZXR0aW5nIGEgdHJlZSBwYXR0ZXJuLiBGb3IgZXhhbXBsZSwgaGVyZSdzIGFcclxuXHQgKiBzYW1wbGUgdXNlOlxyXG5cdCAqXHJcblx0ICogYGBgXHJcblx0ICogbGV0IHQ6IFBhcnNlVHJlZSA9IHBhcnNlci5leHByKCk7XHJcblx0ICogbGV0IHA6IFBhcnNlVHJlZVBhdHRlcm4gPSBhd2FpdCBwYXJzZXIuY29tcGlsZVBhcnNlVHJlZVBhdHRlcm4oXCI8SUQ+KzBcIiwgTXlQYXJzZXIuUlVMRV9leHByKTtcclxuXHQgKiBsZXQgbTogUGFyc2VUcmVlTWF0Y2ggPSBwLm1hdGNoKHQpO1xyXG5cdCAqIGxldCBpZDogc3RyaW5nID0gbS5nZXQoXCJJRFwiKTtcclxuXHQgKiBgYGBcclxuXHQgKi9cclxuXHRwdWJsaWMgY29tcGlsZVBhcnNlVHJlZVBhdHRlcm4ocGF0dGVybjogc3RyaW5nLCBwYXR0ZXJuUnVsZUluZGV4OiBudW1iZXIpOiBQcm9taXNlPFBhcnNlVHJlZVBhdHRlcm4+O1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgc2FtZSBhcyB7QGxpbmsgI2NvbXBpbGVQYXJzZVRyZWVQYXR0ZXJuKFN0cmluZywgaW50KX0gYnV0IHNwZWNpZnkgYVxyXG5cdCAqIHtAbGluayBMZXhlcn0gcmF0aGVyIHRoYW4gdHJ5aW5nIHRvIGRlZHVjZSBpdCBmcm9tIHRoaXMgcGFyc2VyLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjb21waWxlUGFyc2VUcmVlUGF0dGVybihwYXR0ZXJuOiBzdHJpbmcsIHBhdHRlcm5SdWxlSW5kZXg6IG51bWJlciwgbGV4ZXI/OiBMZXhlcik6IFByb21pc2U8UGFyc2VUcmVlUGF0dGVybj47XHJcblxyXG5cdHB1YmxpYyBhc3luYyBjb21waWxlUGFyc2VUcmVlUGF0dGVybihwYXR0ZXJuOiBzdHJpbmcsIHBhdHRlcm5SdWxlSW5kZXg6IG51bWJlciwgbGV4ZXI/OiBMZXhlcik6IFByb21pc2U8UGFyc2VUcmVlUGF0dGVybj4ge1xyXG5cdFx0aWYgKCFsZXhlcikge1xyXG5cdFx0XHRpZiAodGhpcy5pbnB1dFN0cmVhbSkge1xyXG5cdFx0XHRcdGxldCB0b2tlblNvdXJjZSA9IHRoaXMuaW5wdXRTdHJlYW0udG9rZW5Tb3VyY2U7XHJcblx0XHRcdFx0aWYgKHRva2VuU291cmNlIGluc3RhbmNlb2YgTGV4ZXIpIHtcclxuXHRcdFx0XHRcdGxleGVyID0gdG9rZW5Tb3VyY2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIWxleGVyKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyc2VyIGNhbid0IGRpc2NvdmVyIGEgbGV4ZXIgdG8gdXNlXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGN1cnJlbnRMZXhlciA9IGxleGVyO1xyXG5cdFx0bGV0IG0gPSBhd2FpdCBpbXBvcnQoXCIuL3RyZWUvcGF0dGVybi9QYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlclwiKTtcclxuXHRcdGxldCBtYXRjaGVyID0gbmV3IG0uUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIoY3VycmVudExleGVyLCB0aGlzKTtcclxuXHRcdHJldHVybiBtYXRjaGVyLmNvbXBpbGUocGF0dGVybiwgcGF0dGVyblJ1bGVJbmRleCk7XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdGdldCBlcnJvckhhbmRsZXIoKTogQU5UTFJFcnJvclN0cmF0ZWd5IHtcclxuXHRcdHJldHVybiB0aGlzLl9lcnJIYW5kbGVyO1xyXG5cdH1cclxuXHJcblx0c2V0IGVycm9ySGFuZGxlcihATm90TnVsbCBoYW5kbGVyOiBBTlRMUkVycm9yU3RyYXRlZ3kpIHtcclxuXHRcdHRoaXMuX2VyckhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlucHV0U3RyZWFtKCk6IFRva2VuU3RyZWFtIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbnB1dDtcclxuXHR9XHJcblxyXG5cdC8qKiBTZXQgdGhlIHRva2VuIHN0cmVhbSBhbmQgcmVzZXQgdGhlIHBhcnNlci4gKi9cclxuXHRzZXQgaW5wdXRTdHJlYW0oaW5wdXQ6IFRva2VuU3RyZWFtKSB7XHJcblx0XHR0aGlzLnJlc2V0KGZhbHNlKTtcclxuXHRcdHRoaXMuX2lucHV0ID0gaW5wdXQ7XHJcblx0fVxyXG5cclxuXHQvKiogTWF0Y2ggbmVlZHMgdG8gcmV0dXJuIHRoZSBjdXJyZW50IGlucHV0IHN5bWJvbCwgd2hpY2ggZ2V0cyBwdXRcclxuXHQgKiAgaW50byB0aGUgbGFiZWwgZm9yIHRoZSBhc3NvY2lhdGVkIHRva2VuIHJlZjsgZS5nLiwgeD1JRC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBjdXJyZW50VG9rZW4oKTogVG9rZW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2lucHV0LkxUKDEpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIG5vdGlmeUVycm9yTGlzdGVuZXJzKC8qQE5vdE51bGwqLyBtc2c6IHN0cmluZyk6IHZvaWQ7XHJcblx0cHVibGljIG5vdGlmeUVycm9yTGlzdGVuZXJzKC8qQE5vdE51bGwqLyBtc2c6IHN0cmluZywgLypATm90TnVsbCovIG9mZmVuZGluZ1Rva2VuOiBUb2tlbiB8IG51bGwsIGU6IFJlY29nbml0aW9uRXhjZXB0aW9uIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcblx0cHVibGljIG5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZzogc3RyaW5nLCBvZmZlbmRpbmdUb2tlbj86IFRva2VuIHwgbnVsbCwgZT86IFJlY29nbml0aW9uRXhjZXB0aW9uIHwgdW5kZWZpbmVkKTogdm9pZCB7XHJcblx0XHRpZiAob2ZmZW5kaW5nVG9rZW4gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRvZmZlbmRpbmdUb2tlbiA9IHRoaXMuY3VycmVudFRva2VuO1xyXG5cdFx0fSBlbHNlIGlmIChvZmZlbmRpbmdUb2tlbiA9PT0gbnVsbCkge1xyXG5cdFx0XHRvZmZlbmRpbmdUb2tlbiA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zeW50YXhFcnJvcnMrKztcclxuXHRcdGxldCBsaW5lOiBudW1iZXIgPSAtMTtcclxuXHRcdGxldCBjaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlciA9IC0xO1xyXG5cdFx0aWYgKG9mZmVuZGluZ1Rva2VuICE9IG51bGwpIHtcclxuXHRcdFx0bGluZSA9IG9mZmVuZGluZ1Rva2VuLmxpbmU7XHJcblx0XHRcdGNoYXJQb3NpdGlvbkluTGluZSA9IG9mZmVuZGluZ1Rva2VuLmNoYXJQb3NpdGlvbkluTGluZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbGlzdGVuZXIgPSB0aGlzLmdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCgpO1xyXG5cdFx0aWYgKGxpc3RlbmVyLnN5bnRheEVycm9yKSB7XHJcblx0XHRcdGxpc3RlbmVyLnN5bnRheEVycm9yKHRoaXMsIG9mZmVuZGluZ1Rva2VuLCBsaW5lLCBjaGFyUG9zaXRpb25JbkxpbmUsIG1zZywgZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdW1lIGFuZCByZXR1cm4gdGhlIFtjdXJyZW50IHN5bWJvbF0oYGN1cnJlbnRUb2tlbmApLlxyXG5cdCAqXHJcblx0ICogRS5nLiwgZ2l2ZW4gdGhlIGZvbGxvd2luZyBpbnB1dCB3aXRoIGBBYCBiZWluZyB0aGUgY3VycmVudFxyXG5cdCAqIGxvb2thaGVhZCBzeW1ib2wsIHRoaXMgZnVuY3Rpb24gbW92ZXMgdGhlIGN1cnNvciB0byBgQmAgYW5kIHJldHVybnNcclxuXHQgKiBgQWAuXHJcblx0ICpcclxuXHQgKiBgYGBcclxuXHQgKiBBIEJcclxuXHQgKiBeXHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBJZiB0aGUgcGFyc2VyIGlzIG5vdCBpbiBlcnJvciByZWNvdmVyeSBtb2RlLCB0aGUgY29uc3VtZWQgc3ltYm9sIGlzIGFkZGVkXHJcblx0ICogdG8gdGhlIHBhcnNlIHRyZWUgdXNpbmcge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0I2FkZENoaWxkKFRlcm1pbmFsTm9kZSl9LCBhbmRcclxuXHQgKiB7QGxpbmsgUGFyc2VUcmVlTGlzdGVuZXIjdmlzaXRUZXJtaW5hbH0gaXMgY2FsbGVkIG9uIGFueSBwYXJzZSBsaXN0ZW5lcnMuXHJcblx0ICogSWYgdGhlIHBhcnNlciAqaXMqIGluIGVycm9yIHJlY292ZXJ5IG1vZGUsIHRoZSBjb25zdW1lZCBzeW1ib2wgaXNcclxuXHQgKiBhZGRlZCB0byB0aGUgcGFyc2UgdHJlZSB1c2luZyB7QGxpbmsgI2NyZWF0ZUVycm9yTm9kZShQYXJzZXJSdWxlQ29udGV4dCwgVG9rZW4pfSB0aGVuXHJcblx0ICoge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0I2FkZEVycm9yTm9kZShFcnJvck5vZGUpfSBhbmRcclxuXHQgKiB7QGxpbmsgUGFyc2VUcmVlTGlzdGVuZXIjdmlzaXRFcnJvck5vZGV9IGlzIGNhbGxlZCBvbiBhbnkgcGFyc2VcclxuXHQgKiBsaXN0ZW5lcnMuXHJcblx0ICovXHJcblx0cHVibGljIGNvbnN1bWUoKTogVG9rZW4ge1xyXG5cdFx0bGV0IG86IFRva2VuID0gdGhpcy5jdXJyZW50VG9rZW47XHJcblx0XHRpZiAoby50eXBlICE9PSBQYXJzZXIuRU9GKSB7XHJcblx0XHRcdHRoaXMuaW5wdXRTdHJlYW0uY29uc3VtZSgpO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGhhc0xpc3RlbmVyOiBib29sZWFuID0gdGhpcy5fcGFyc2VMaXN0ZW5lcnMubGVuZ3RoICE9PSAwO1xyXG5cdFx0aWYgKHRoaXMuX2J1aWxkUGFyc2VUcmVlcyB8fCBoYXNMaXN0ZW5lcikge1xyXG5cdFx0XHRpZiAodGhpcy5fZXJySGFuZGxlci5pbkVycm9yUmVjb3ZlcnlNb2RlKHRoaXMpKSB7XHJcblx0XHRcdFx0bGV0IG5vZGU6IEVycm9yTm9kZSA9IHRoaXMuX2N0eC5hZGRFcnJvck5vZGUodGhpcy5jcmVhdGVFcnJvck5vZGUodGhpcy5fY3R4LCBvKSk7XHJcblx0XHRcdFx0aWYgKGhhc0xpc3RlbmVyKSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9wYXJzZUxpc3RlbmVycykge1xyXG5cdFx0XHRcdFx0XHRpZiAobGlzdGVuZXIudmlzaXRFcnJvck5vZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci52aXNpdEVycm9yTm9kZShub2RlKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRsZXQgbm9kZTogVGVybWluYWxOb2RlID0gdGhpcy5jcmVhdGVUZXJtaW5hbE5vZGUodGhpcy5fY3R4LCBvKTtcclxuXHRcdFx0XHR0aGlzLl9jdHguYWRkQ2hpbGQobm9kZSk7XHJcblx0XHRcdFx0aWYgKGhhc0xpc3RlbmVyKSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9wYXJzZUxpc3RlbmVycykge1xyXG5cdFx0XHRcdFx0XHRpZiAobGlzdGVuZXIudmlzaXRUZXJtaW5hbCkge1xyXG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLnZpc2l0VGVybWluYWwobm9kZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBvO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSG93IHRvIGNyZWF0ZSBhIHRva2VuIGxlYWYgbm9kZSBhc3NvY2lhdGVkIHdpdGggYSBwYXJlbnQuXHJcblx0ICogVHlwaWNhbGx5LCB0aGUgdGVybWluYWwgbm9kZSB0byBjcmVhdGUgaXMgbm90IGEgZnVuY3Rpb24gb2YgdGhlIHBhcmVudC5cclxuXHQgKlxyXG5cdCAqIEBzaW5jZSA0LjdcclxuXHQgKi9cclxuXHRwdWJsaWMgY3JlYXRlVGVybWluYWxOb2RlKHBhcmVudDogUGFyc2VyUnVsZUNvbnRleHQsIHQ6IFRva2VuKTogVGVybWluYWxOb2RlIHtcclxuXHRcdHJldHVybiBuZXcgVGVybWluYWxOb2RlKHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSG93IHRvIGNyZWF0ZSBhbiBlcnJvciBub2RlLCBnaXZlbiBhIHRva2VuLCBhc3NvY2lhdGVkIHdpdGggYSBwYXJlbnQuXHJcblx0ICogVHlwaWNhbGx5LCB0aGUgZXJyb3Igbm9kZSB0byBjcmVhdGUgaXMgbm90IGEgZnVuY3Rpb24gb2YgdGhlIHBhcmVudC5cclxuXHQgKlxyXG5cdCAqIEBzaW5jZSA0LjdcclxuXHQgKi9cclxuXHRwdWJsaWMgY3JlYXRlRXJyb3JOb2RlKHBhcmVudDogUGFyc2VyUnVsZUNvbnRleHQsIHQ6IFRva2VuKTogRXJyb3JOb2RlIHtcclxuXHRcdHJldHVybiBuZXcgRXJyb3JOb2RlKHQpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGFkZENvbnRleHRUb1BhcnNlVHJlZSgpOiB2b2lkIHtcclxuXHRcdGxldCBwYXJlbnQgPSB0aGlzLl9jdHguX3BhcmVudCBhcyBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZDtcclxuXHRcdC8vIGFkZCBjdXJyZW50IGNvbnRleHQgdG8gcGFyZW50IGlmIHdlIGhhdmUgYSBwYXJlbnRcclxuXHRcdGlmIChwYXJlbnQgIT0gbnVsbCkge1xyXG5cdFx0XHRwYXJlbnQuYWRkQ2hpbGQodGhpcy5fY3R4KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFsd2F5cyBjYWxsZWQgYnkgZ2VuZXJhdGVkIHBhcnNlcnMgdXBvbiBlbnRyeSB0byBhIHJ1bGUuIEFjY2VzcyBmaWVsZFxyXG5cdCAqIHtAbGluayAjX2N0eH0gZ2V0IHRoZSBjdXJyZW50IGNvbnRleHQuXHJcblx0ICovXHJcblx0cHVibGljIGVudGVyUnVsZShATm90TnVsbCBsb2NhbGN0eDogUGFyc2VyUnVsZUNvbnRleHQsIHN0YXRlOiBudW1iZXIsIHJ1bGVJbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XHJcblx0XHR0aGlzLl9jdHggPSBsb2NhbGN0eDtcclxuXHRcdHRoaXMuX2N0eC5fc3RhcnQgPSB0aGlzLl9pbnB1dC5MVCgxKTtcclxuXHRcdGlmICh0aGlzLl9idWlsZFBhcnNlVHJlZXMpIHtcclxuXHRcdFx0dGhpcy5hZGRDb250ZXh0VG9QYXJzZVRyZWUoKTtcclxuXHRcdH1cclxuXHRcdHRoaXMudHJpZ2dlckVudGVyUnVsZUV2ZW50KCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZW50ZXJMZWZ0RmFjdG9yZWRSdWxlKGxvY2FsY3R4OiBQYXJzZXJSdWxlQ29udGV4dCwgc3RhdGU6IG51bWJlciwgcnVsZUluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHRcdGlmICh0aGlzLl9idWlsZFBhcnNlVHJlZXMpIHtcclxuXHRcdFx0bGV0IGZhY3RvcmVkQ29udGV4dCA9IHRoaXMuX2N0eC5nZXRDaGlsZCh0aGlzLl9jdHguY2hpbGRDb3VudCAtIDEpIGFzIFBhcnNlclJ1bGVDb250ZXh0O1xyXG5cdFx0XHR0aGlzLl9jdHgucmVtb3ZlTGFzdENoaWxkKCk7XHJcblx0XHRcdGZhY3RvcmVkQ29udGV4dC5fcGFyZW50ID0gbG9jYWxjdHg7XHJcblx0XHRcdGxvY2FsY3R4LmFkZENoaWxkKGZhY3RvcmVkQ29udGV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY3R4ID0gbG9jYWxjdHg7XHJcblx0XHR0aGlzLl9jdHguX3N0YXJ0ID0gdGhpcy5faW5wdXQuTFQoMSk7XHJcblx0XHRpZiAodGhpcy5fYnVpbGRQYXJzZVRyZWVzKSB7XHJcblx0XHRcdHRoaXMuYWRkQ29udGV4dFRvUGFyc2VUcmVlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJSdWxlRXZlbnQoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBleGl0UnVsZSgpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLm1hdGNoZWRFT0YpIHtcclxuXHRcdFx0Ly8gaWYgd2UgaGF2ZSBtYXRjaGVkIEVPRiwgaXQgY2Fubm90IGNvbnN1bWUgcGFzdCBFT0Ygc28gd2UgdXNlIExUKDEpIGhlcmVcclxuXHRcdFx0dGhpcy5fY3R4Ll9zdG9wID0gdGhpcy5faW5wdXQuTFQoMSk7IC8vIExUKDEpIHdpbGwgYmUgZW5kIG9mIGZpbGVcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9jdHguX3N0b3AgPSB0aGlzLl9pbnB1dC50cnlMVCgtMSk7IC8vIHN0b3Agbm9kZSBpcyB3aGF0IHdlIGp1c3QgbWF0Y2hlZFxyXG5cdFx0fVxyXG5cdFx0Ly8gdHJpZ2dlciBldmVudCBvbiBfY3R4LCBiZWZvcmUgaXQgcmV2ZXJ0cyB0byBwYXJlbnRcclxuXHRcdHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcclxuXHRcdHRoaXMuc3RhdGUgPSB0aGlzLl9jdHguaW52b2tpbmdTdGF0ZTtcclxuXHRcdHRoaXMuX2N0eCA9IHRoaXMuX2N0eC5fcGFyZW50IGFzIFBhcnNlclJ1bGVDb250ZXh0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIGVudGVyT3V0ZXJBbHQobG9jYWxjdHg6IFBhcnNlclJ1bGVDb250ZXh0LCBhbHROdW06IG51bWJlcik6IHZvaWQge1xyXG5cdFx0bG9jYWxjdHguYWx0TnVtYmVyID0gYWx0TnVtO1xyXG5cdFx0Ly8gaWYgd2UgaGF2ZSBuZXcgbG9jYWxjdHgsIG1ha2Ugc3VyZSB3ZSByZXBsYWNlIGV4aXN0aW5nIGN0eFxyXG5cdFx0Ly8gdGhhdCBpcyBwcmV2aW91cyBjaGlsZCBvZiBwYXJzZSB0cmVlXHJcblx0XHRpZiAodGhpcy5fYnVpbGRQYXJzZVRyZWVzICYmIHRoaXMuX2N0eCAhPT0gbG9jYWxjdHgpIHtcclxuXHRcdFx0bGV0IHBhcmVudCA9IHRoaXMuX2N0eC5fcGFyZW50IGFzIFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkO1xyXG5cdFx0XHRpZiAocGFyZW50ICE9IG51bGwpIHtcclxuXHRcdFx0XHRwYXJlbnQucmVtb3ZlTGFzdENoaWxkKCk7XHJcblx0XHRcdFx0cGFyZW50LmFkZENoaWxkKGxvY2FsY3R4KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5fY3R4ID0gbG9jYWxjdHg7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHByZWNlZGVuY2UgbGV2ZWwgZm9yIHRoZSB0b3AtbW9zdCBwcmVjZWRlbmNlIHJ1bGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgcHJlY2VkZW5jZSBsZXZlbCBmb3IgdGhlIHRvcC1tb3N0IHByZWNlZGVuY2UgcnVsZSwgb3IgLTEgaWZcclxuXHQgKiB0aGUgcGFyc2VyIGNvbnRleHQgaXMgbm90IG5lc3RlZCB3aXRoaW4gYSBwcmVjZWRlbmNlIHJ1bGUuXHJcblx0ICovXHJcblx0Z2V0IHByZWNlZGVuY2UoKTogbnVtYmVyIHtcclxuXHRcdGlmICh0aGlzLl9wcmVjZWRlbmNlU3RhY2suaXNFbXB0eSkge1xyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3ByZWNlZGVuY2VTdGFjay5wZWVrKCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4OiBQYXJzZXJSdWxlQ29udGV4dCwgc3RhdGU6IG51bWJlciwgcnVsZUluZGV4OiBudW1iZXIsIHByZWNlZGVuY2U6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cdFx0dGhpcy5fcHJlY2VkZW5jZVN0YWNrLnB1c2gocHJlY2VkZW5jZSk7XHJcblx0XHR0aGlzLl9jdHggPSBsb2NhbGN0eDtcclxuXHRcdHRoaXMuX2N0eC5fc3RhcnQgPSB0aGlzLl9pbnB1dC5MVCgxKTtcclxuXHRcdHRoaXMudHJpZ2dlckVudGVyUnVsZUV2ZW50KCk7IC8vIHNpbXVsYXRlcyBydWxlIGVudHJ5IGZvciBsZWZ0LXJlY3Vyc2l2ZSBydWxlc1xyXG5cdH1cclxuXHJcblx0LyoqIExpa2Uge0BsaW5rICNlbnRlclJ1bGV9IGJ1dCBmb3IgcmVjdXJzaXZlIHJ1bGVzLlxyXG5cdCAqICBNYWtlIHRoZSBjdXJyZW50IGNvbnRleHQgdGhlIGNoaWxkIG9mIHRoZSBpbmNvbWluZyBsb2NhbGN0eC5cclxuXHQgKi9cclxuXHRwdWJsaWMgcHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHg6IFBhcnNlclJ1bGVDb250ZXh0LCBzdGF0ZTogbnVtYmVyLCBydWxlSW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0bGV0IHByZXZpb3VzOiBQYXJzZXJSdWxlQ29udGV4dCA9IHRoaXMuX2N0eDtcclxuXHRcdHByZXZpb3VzLl9wYXJlbnQgPSBsb2NhbGN0eDtcclxuXHRcdHByZXZpb3VzLmludm9raW5nU3RhdGUgPSBzdGF0ZTtcclxuXHRcdHByZXZpb3VzLl9zdG9wID0gdGhpcy5faW5wdXQudHJ5TFQoLTEpO1xyXG5cclxuXHRcdHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xyXG5cdFx0dGhpcy5fY3R4Ll9zdGFydCA9IHByZXZpb3VzLl9zdGFydDtcclxuXHRcdGlmICh0aGlzLl9idWlsZFBhcnNlVHJlZXMpIHtcclxuXHRcdFx0dGhpcy5fY3R4LmFkZENoaWxkKHByZXZpb3VzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnRyaWdnZXJFbnRlclJ1bGVFdmVudCgpOyAvLyBzaW11bGF0ZXMgcnVsZSBlbnRyeSBmb3IgbGVmdC1yZWN1cnNpdmUgcnVsZXNcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB1bnJvbGxSZWN1cnNpb25Db250ZXh0cyhfcGFyZW50Y3R4OiBQYXJzZXJSdWxlQ29udGV4dCk6IHZvaWQge1xyXG5cdFx0dGhpcy5fcHJlY2VkZW5jZVN0YWNrLnBvcCgpO1xyXG5cdFx0dGhpcy5fY3R4Ll9zdG9wID0gdGhpcy5faW5wdXQudHJ5TFQoLTEpO1xyXG5cdFx0bGV0IHJldGN0eDogUGFyc2VyUnVsZUNvbnRleHQgPSB0aGlzLl9jdHg7IC8vIHNhdmUgY3VycmVudCBjdHggKHJldHVybiB2YWx1ZSlcclxuXHJcblx0XHQvLyB1bnJvbGwgc28gX2N0eCBpcyBhcyBpdCB3YXMgYmVmb3JlIGNhbGwgdG8gcmVjdXJzaXZlIG1ldGhvZFxyXG5cdFx0aWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0d2hpbGUgKHRoaXMuX2N0eCAhPT0gX3BhcmVudGN0eCkge1xyXG5cdFx0XHRcdHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcclxuXHRcdFx0XHR0aGlzLl9jdHggPSB0aGlzLl9jdHguX3BhcmVudCBhcyBQYXJzZXJSdWxlQ29udGV4dDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuX2N0eCA9IF9wYXJlbnRjdHg7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaG9vayBpbnRvIHRyZWVcclxuXHRcdHJldGN0eC5fcGFyZW50ID0gX3BhcmVudGN0eDtcclxuXHJcblx0XHRpZiAodGhpcy5fYnVpbGRQYXJzZVRyZWVzICYmIF9wYXJlbnRjdHggIT0gbnVsbCkge1xyXG5cdFx0XHQvLyBhZGQgcmV0dXJuIGN0eCBpbnRvIGludm9raW5nIHJ1bGUncyB0cmVlXHJcblx0XHRcdF9wYXJlbnRjdHguYWRkQ2hpbGQocmV0Y3R4KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRJbnZva2luZ0NvbnRleHQocnVsZUluZGV4OiBudW1iZXIpOiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCB7XHJcblx0XHRsZXQgcCA9IHRoaXMuX2N0eDtcclxuXHRcdHdoaWxlIChwICYmIHAucnVsZUluZGV4ICE9PSBydWxlSW5kZXgpIHtcclxuXHRcdFx0cCA9IHAuX3BhcmVudCBhcyBQYXJzZXJSdWxlQ29udGV4dDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwO1xyXG5cdH1cclxuXHJcblx0Z2V0IGNvbnRleHQoKTogUGFyc2VyUnVsZUNvbnRleHQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2N0eDtcclxuXHR9XHJcblxyXG5cdHNldCBjb250ZXh0KGN0eDogUGFyc2VyUnVsZUNvbnRleHQpIHtcclxuXHRcdHRoaXMuX2N0eCA9IGN0eDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBwcmVjcHJlZChATnVsbGFibGUgbG9jYWxjdHg6IFJ1bGVDb250ZXh0LCBwcmVjZWRlbmNlOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBwcmVjZWRlbmNlID49IHRoaXMuX3ByZWNlZGVuY2VTdGFjay5wZWVrKCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCk6IFBhcnNlckVycm9yTGlzdGVuZXIge1xyXG5cdFx0cmV0dXJuIG5ldyBQcm94eVBhcnNlckVycm9yTGlzdGVuZXIodGhpcy5nZXRFcnJvckxpc3RlbmVycygpKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBpbkNvbnRleHQoY29udGV4dDogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHQvLyBUT0RPOiB1c2VmdWwgaW4gcGFyc2VyP1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGBzeW1ib2xgIGNhbiBmb2xsb3cgdGhlIGN1cnJlbnQgc3RhdGUgaW4gdGhlXHJcblx0ICogQVROLiBUaGUgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byB0aGUgZm9sbG93aW5nLCBidXQgaXNcclxuXHQgKiBpbXBsZW1lbnRlZCBzdWNoIHRoYXQgdGhlIGNvbXBsZXRlIGNvbnRleHQtc2Vuc2l0aXZlIGZvbGxvdyBzZXQgZG9lcyBub3RcclxuXHQgKiBuZWVkIHRvIGJlIGV4cGxpY2l0bHkgY29uc3RydWN0ZWQuXHJcblx0ICpcclxuXHQgKiBgYGBcclxuXHQgKiByZXR1cm4gZ2V0RXhwZWN0ZWRUb2tlbnMoKS5jb250YWlucyhzeW1ib2wpO1xyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHN5bWJvbCB0aGUgc3ltYm9sIHR5cGUgdG8gY2hlY2tcclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYHN5bWJvbGAgY2FuIGZvbGxvdyB0aGUgY3VycmVudCBzdGF0ZSBpblxyXG5cdCAqIHRoZSBBVE4sIG90aGVyd2lzZSBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBpc0V4cGVjdGVkVG9rZW4oc3ltYm9sOiBudW1iZXIpOiBib29sZWFuIHtcclxuLy8gICBcdFx0cmV0dXJuIGludGVycHJldGVyLmF0bi5uZXh0VG9rZW5zKF9jdHgpO1xyXG5cdFx0bGV0IGF0bjogQVROID0gdGhpcy5pbnRlcnByZXRlci5hdG47XHJcblx0XHRsZXQgY3R4OiBQYXJzZXJSdWxlQ29udGV4dCA9IHRoaXMuX2N0eDtcclxuXHRcdGxldCBzOiBBVE5TdGF0ZSA9IGF0bi5zdGF0ZXNbdGhpcy5zdGF0ZV07XHJcblx0XHRsZXQgZm9sbG93aW5nOiBJbnRlcnZhbFNldCA9IGF0bi5uZXh0VG9rZW5zKHMpO1xyXG5cdFx0aWYgKGZvbGxvd2luZy5jb250YWlucyhzeW1ib2wpKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG4vLyAgICAgICAgU3lzdGVtLm91dC5wcmludGxuKFwiZm9sbG93aW5nIFwiK3MrXCI9XCIrZm9sbG93aW5nKTtcclxuXHRcdGlmICghZm9sbG93aW5nLmNvbnRhaW5zKFRva2VuLkVQU0lMT04pKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHR3aGlsZSAoY3R4ICE9IG51bGwgJiYgY3R4Lmludm9raW5nU3RhdGUgPj0gMCAmJiBmb2xsb3dpbmcuY29udGFpbnMoVG9rZW4uRVBTSUxPTikpIHtcclxuXHRcdFx0bGV0IGludm9raW5nU3RhdGU6IEFUTlN0YXRlID0gYXRuLnN0YXRlc1tjdHguaW52b2tpbmdTdGF0ZV07XHJcblx0XHRcdGxldCBydCA9IGludm9raW5nU3RhdGUudHJhbnNpdGlvbigwKSBhcyBSdWxlVHJhbnNpdGlvbjtcclxuXHRcdFx0Zm9sbG93aW5nID0gYXRuLm5leHRUb2tlbnMocnQuZm9sbG93U3RhdGUpO1xyXG5cdFx0XHRpZiAoZm9sbG93aW5nLmNvbnRhaW5zKHN5bWJvbCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3R4ID0gY3R4Ll9wYXJlbnQgYXMgUGFyc2VyUnVsZUNvbnRleHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGZvbGxvd2luZy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSAmJiBzeW1ib2wgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRnZXQgaXNNYXRjaGVkRU9GKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF0Y2hlZEVPRjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGVzIHRoZSBzZXQgb2YgaW5wdXQgc3ltYm9scyB3aGljaCBjb3VsZCBmb2xsb3cgdGhlIGN1cnJlbnQgcGFyc2VyXHJcblx0ICogc3RhdGUgYW5kIGNvbnRleHQsIGFzIGdpdmVuIGJ5IHtAbGluayAjZ2V0U3RhdGV9IGFuZCB7QGxpbmsgI2dldENvbnRleHR9LFxyXG5cdCAqIHJlc3BlY3RpdmVseS5cclxuXHQgKlxyXG5cdCAqIEBzZWUgQVROI2dldEV4cGVjdGVkVG9rZW5zKGludCwgUnVsZUNvbnRleHQpXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0RXhwZWN0ZWRUb2tlbnMoKTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0cmV0dXJuIHRoaXMuYXRuLmdldEV4cGVjdGVkVG9rZW5zKHRoaXMuc3RhdGUsIHRoaXMuY29udGV4dCk7XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRFeHBlY3RlZFRva2Vuc1dpdGhpbkN1cnJlbnRSdWxlKCk6IEludGVydmFsU2V0IHtcclxuXHRcdGxldCBhdG46IEFUTiA9IHRoaXMuaW50ZXJwcmV0ZXIuYXRuO1xyXG5cdFx0bGV0IHM6IEFUTlN0YXRlID0gYXRuLnN0YXRlc1t0aGlzLnN0YXRlXTtcclxuXHRcdHJldHVybiBhdG4ubmV4dFRva2VucyhzKTtcclxuXHR9XHJcblxyXG5cdC8qKiBHZXQgYSBydWxlJ3MgaW5kZXggKGkuZS4sIGBSVUxFX3J1bGVOYW1lYCBmaWVsZCkgb3IgLTEgaWYgbm90IGZvdW5kLiAqL1xyXG5cdHB1YmxpYyBnZXRSdWxlSW5kZXgocnVsZU5hbWU6IHN0cmluZyk6IG51bWJlciB7XHJcblx0XHRsZXQgcnVsZUluZGV4ID0gdGhpcy5nZXRSdWxlSW5kZXhNYXAoKS5nZXQocnVsZU5hbWUpO1xyXG5cdFx0aWYgKHJ1bGVJbmRleCAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBydWxlSW5kZXg7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cclxuXHRnZXQgcnVsZUNvbnRleHQoKTogUGFyc2VyUnVsZUNvbnRleHQgeyByZXR1cm4gdGhpcy5fY3R4OyB9XHJcblxyXG5cdC8qKiBSZXR1cm4gTGlzdCZsdDtTdHJpbmcmZ3Q7IG9mIHRoZSBydWxlIG5hbWVzIGluIHlvdXIgcGFyc2VyIGluc3RhbmNlXHJcblx0ICogIGxlYWRpbmcgdXAgdG8gYSBjYWxsIHRvIHRoZSBjdXJyZW50IHJ1bGUuICBZb3UgY291bGQgb3ZlcnJpZGUgaWZcclxuXHQgKiAgeW91IHdhbnQgbW9yZSBkZXRhaWxzIHN1Y2ggYXMgdGhlIGZpbGUvbGluZSBpbmZvIG9mIHdoZXJlXHJcblx0ICogIGluIHRoZSBBVE4gYSBydWxlIGlzIGludm9rZWQuXHJcblx0ICpcclxuXHQgKiAgVGhpcyBpcyB2ZXJ5IHVzZWZ1bCBmb3IgZXJyb3IgbWVzc2FnZXMuXHJcblx0ICovXHJcblxyXG5cdHB1YmxpYyBnZXRSdWxlSW52b2NhdGlvblN0YWNrKGN0eDogUnVsZUNvbnRleHQgPSB0aGlzLl9jdHgpOiBzdHJpbmdbXSB7XHJcblx0XHRsZXQgcDogUnVsZUNvbnRleHQgfCB1bmRlZmluZWQgPSBjdHg7ICBcdFx0Ly8gV29ya2Fyb3VuZCBmb3IgTWljcm9zb2Z0L1R5cGVTY3JpcHQjMTQ0ODdcclxuXHRcdGxldCBydWxlTmFtZXM6IHN0cmluZ1tdID0gdGhpcy5ydWxlTmFtZXM7XHJcblx0XHRsZXQgc3RhY2s6IHN0cmluZ1tdID0gW107XHJcblx0XHR3aGlsZSAocCAhPSBudWxsKSB7XHJcblx0XHRcdC8vIGNvbXB1dGUgd2hhdCBmb2xsb3dzIHdobyBpbnZva2VkIHVzXHJcblx0XHRcdGxldCBydWxlSW5kZXg6IG51bWJlciA9IHAucnVsZUluZGV4O1xyXG5cdFx0XHRpZiAocnVsZUluZGV4IDwgMCkge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goXCJuL2FcIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChydWxlTmFtZXNbcnVsZUluZGV4XSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cCA9IHAuX3BhcmVudCBhcyBSdWxlQ29udGV4dDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzdGFjaztcclxuXHR9XHJcblxyXG5cdC8qKiBGb3IgZGVidWdnaW5nIGFuZCBvdGhlciBwdXJwb3Nlcy4gKi9cclxuXHRwdWJsaWMgZ2V0REZBU3RyaW5ncygpOiBzdHJpbmdbXSB7XHJcblx0XHRsZXQgczogc3RyaW5nW10gPSBbXTtcclxuXHRcdGZvciAobGV0IGRmYSBvZiB0aGlzLl9pbnRlcnAuYXRuLmRlY2lzaW9uVG9ERkEpIHtcclxuXHRcdFx0cy5wdXNoKGRmYS50b1N0cmluZyh0aGlzLnZvY2FidWxhcnksIHRoaXMucnVsZU5hbWVzKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcztcclxuXHR9XHJcblxyXG5cdC8qKiBGb3IgZGVidWdnaW5nIGFuZCBvdGhlciBwdXJwb3Nlcy4gKi9cclxuXHRwdWJsaWMgZHVtcERGQSgpOiB2b2lkIHtcclxuXHRcdGxldCBzZWVuT25lOiBib29sZWFuID0gZmFsc2U7XHJcblx0XHRmb3IgKGxldCBkZmEgb2YgdGhpcy5faW50ZXJwLmF0bi5kZWNpc2lvblRvREZBKSB7XHJcblx0XHRcdGlmICghZGZhLmlzRW1wdHkpIHtcclxuXHRcdFx0XHRpZiAoc2Vlbk9uZSkge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJEZWNpc2lvbiBcIiArIGRmYS5kZWNpc2lvbiArIFwiOlwiKTtcclxuXHRcdFx0XHRwcm9jZXNzLnN0ZG91dC53cml0ZShkZmEudG9TdHJpbmcodGhpcy52b2NhYnVsYXJ5LCB0aGlzLnJ1bGVOYW1lcykpO1xyXG5cdFx0XHRcdHNlZW5PbmUgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXQgc291cmNlTmFtZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2lucHV0LnNvdXJjZU5hbWU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgcGFyc2VJbmZvKCk6IFByb21pc2U8UGFyc2VJbmZvIHwgdW5kZWZpbmVkPiB7XHJcblx0XHRyZXR1cm4gaW1wb3J0KFwiLi9hdG4vUHJvZmlsaW5nQVROU2ltdWxhdG9yXCIpLnRoZW4oKG0pID0+IHtcclxuXHRcdFx0bGV0IGludGVycDogUGFyc2VyQVROU2ltdWxhdG9yID0gdGhpcy5pbnRlcnByZXRlcjtcclxuXHRcdFx0aWYgKGludGVycCBpbnN0YW5jZW9mIG0uUHJvZmlsaW5nQVROU2ltdWxhdG9yKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBQYXJzZUluZm8oaW50ZXJwKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQHNpbmNlIDQuM1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBhc3luYyBzZXRQcm9maWxlKHByb2ZpbGU6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGxldCBtID0gYXdhaXQgaW1wb3J0KFwiLi9hdG4vUHJvZmlsaW5nQVROU2ltdWxhdG9yXCIpO1xyXG5cdFx0bGV0IGludGVycDogUGFyc2VyQVROU2ltdWxhdG9yID0gdGhpcy5pbnRlcnByZXRlcjtcclxuXHRcdGlmIChwcm9maWxlKSB7XHJcblx0XHRcdGlmICghKGludGVycCBpbnN0YW5jZW9mIG0uUHJvZmlsaW5nQVROU2ltdWxhdG9yKSkge1xyXG5cdFx0XHRcdHRoaXMuaW50ZXJwcmV0ZXIgPSBuZXcgbS5Qcm9maWxpbmdBVE5TaW11bGF0b3IodGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoaW50ZXJwIGluc3RhbmNlb2YgbS5Qcm9maWxpbmdBVE5TaW11bGF0b3IpIHtcclxuXHRcdFx0dGhpcy5pbnRlcnByZXRlciA9IG5ldyBQYXJzZXJBVE5TaW11bGF0b3IodGhpcy5hdG4sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuaW50ZXJwcmV0ZXIuc2V0UHJlZGljdGlvbk1vZGUoaW50ZXJwLmdldFByZWRpY3Rpb25Nb2RlKCkpO1xyXG5cdH1cclxuXHJcblx0LyoqIER1cmluZyBhIHBhcnNlIGlzIHNvbWV0aW1lcyB1c2VmdWwgdG8gbGlzdGVuIGluIG9uIHRoZSBydWxlIGVudHJ5IGFuZCBleGl0XHJcblx0ICogIGV2ZW50cyBhcyB3ZWxsIGFzIHRva2VuIG1hdGNoZXMuIFRoaXMgaXMgZm9yIHF1aWNrIGFuZCBkaXJ0eSBkZWJ1Z2dpbmcuXHJcblx0ICovXHJcblx0c2V0IGlzVHJhY2UodHJhY2U6IGJvb2xlYW4pIHtcclxuXHRcdGlmICghdHJhY2UpIHtcclxuXHRcdFx0aWYgKHRoaXMuX3RyYWNlcikge1xyXG5cdFx0XHRcdHRoaXMucmVtb3ZlUGFyc2VMaXN0ZW5lcih0aGlzLl90cmFjZXIpO1xyXG5cdFx0XHRcdHRoaXMuX3RyYWNlciA9IHVuZGVmaW5lZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGlmICh0aGlzLl90cmFjZXIpIHtcclxuXHRcdFx0XHR0aGlzLnJlbW92ZVBhcnNlTGlzdGVuZXIodGhpcy5fdHJhY2VyKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLl90cmFjZXIgPSBuZXcgVHJhY2VMaXN0ZW5lcih0aGlzLnJ1bGVOYW1lcywgdGhpcy5faW5wdXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmFkZFBhcnNlTGlzdGVuZXIodGhpcy5fdHJhY2VyKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgd2hldGhlciBhIHtAbGluayBUcmFjZUxpc3RlbmVyfSBpcyByZWdpc3RlcmVkIGFzIGEgcGFyc2UgbGlzdGVuZXJcclxuXHQgKiBmb3IgdGhlIHBhcnNlci5cclxuXHQgKi9cclxuXHRnZXQgaXNUcmFjZSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLl90cmFjZXIgIT0gbnVsbDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUyLjMyNTU1NDgtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuL2F0bi9BVE5Db25maWdTZXRcIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4vUmVjb2duaXplclwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4vVG9rZW5TdHJlYW1cIjtcclxuaW1wb3J0IHsgSW50U3RyZWFtIH0gZnJvbSBcIi4vSW50U3RyZWFtXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKiogSW5kaWNhdGVzIHRoYXQgdGhlIHBhcnNlciBjb3VsZCBub3QgZGVjaWRlIHdoaWNoIG9mIHR3byBvciBtb3JlIHBhdGhzXHJcbiAqICB0byB0YWtlIGJhc2VkIHVwb24gdGhlIHJlbWFpbmluZyBpbnB1dC4gSXQgdHJhY2tzIHRoZSBzdGFydGluZyB0b2tlblxyXG4gKiAgb2YgdGhlIG9mZmVuZGluZyBpbnB1dCBhbmQgYWxzbyBrbm93cyB3aGVyZSB0aGUgcGFyc2VyIHdhc1xyXG4gKiAgaW4gdGhlIHZhcmlvdXMgcGF0aHMgd2hlbiB0aGUgZXJyb3IuIFJlcG9ydGVkIGJ5IHJlcG9ydE5vVmlhYmxlQWx0ZXJuYXRpdmUoKVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE5vVmlhYmxlQWx0RXhjZXB0aW9uIGV4dGVuZHMgUmVjb2duaXRpb25FeGNlcHRpb24ge1xyXG5cdC8vcHJpdmF0ZSBzdGF0aWMgc2VyaWFsVmVyc2lvblVJRDogbnVtYmVyID0gIDUwOTYwMDAwMDg5OTI4NjcwNTJMO1xyXG5cclxuXHQvKiogV2hpY2ggY29uZmlndXJhdGlvbnMgZGlkIHdlIHRyeSBhdCBpbnB1dC5pbmRleCB0aGF0IGNvdWxkbid0IG1hdGNoIGlucHV0LkxUKDEpPyAqL1xyXG5cdHByaXZhdGUgX2RlYWRFbmRDb25maWdzPzogQVROQ29uZmlnU2V0O1xyXG5cclxuXHQvKiogVGhlIHRva2VuIG9iamVjdCBhdCB0aGUgc3RhcnQgaW5kZXg7IHRoZSBpbnB1dCBzdHJlYW0gbWlnaHRcclxuXHQgKiBcdG5vdCBiZSBidWZmZXJpbmcgdG9rZW5zIHNvIGdldCBhIHJlZmVyZW5jZSB0byBpdC4gKEF0IHRoZVxyXG5cdCAqICB0aW1lIHRoZSBlcnJvciBvY2N1cnJlZCwgb2YgY291cnNlIHRoZSBzdHJlYW0gbmVlZHMgdG8ga2VlcCBhXHJcblx0ICogIGJ1ZmZlciBhbGwgb2YgdGhlIHRva2VucyBidXQgbGF0ZXIgd2UgbWlnaHQgbm90IGhhdmUgYWNjZXNzIHRvIHRob3NlLilcclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgX3N0YXJ0VG9rZW46IFRva2VuO1xyXG5cclxuXHRjb25zdHJ1Y3RvcigvKkBOb3ROdWxsKi8gcmVjb2duaXplcjogUGFyc2VyKTtcclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0cmVjb2duaXplcjogUmVjb2duaXplcjxUb2tlbiwgYW55PixcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0aW5wdXQ6IFRva2VuU3RyZWFtLFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRzdGFydFRva2VuOiBUb2tlbixcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0b2ZmZW5kaW5nVG9rZW46IFRva2VuLFxyXG5cdFx0ZGVhZEVuZENvbmZpZ3M6IEFUTkNvbmZpZ1NldCB8IHVuZGVmaW5lZCxcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0Y3R4OiBQYXJzZXJSdWxlQ29udGV4dCk7XHJcblxyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0cmVjb2duaXplcjogUmVjb2duaXplcjxUb2tlbiwgYW55PixcclxuXHRcdGlucHV0PzogVG9rZW5TdHJlYW0sXHJcblx0XHRzdGFydFRva2VuPzogVG9rZW4sXHJcblx0XHRvZmZlbmRpbmdUb2tlbj86IFRva2VuLFxyXG5cdFx0ZGVhZEVuZENvbmZpZ3M/OiBBVE5Db25maWdTZXQsXHJcblx0XHRjdHg/OiBQYXJzZXJSdWxlQ29udGV4dCkge1xyXG5cdFx0aWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBQYXJzZXIpIHtcclxuXHRcdFx0aWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRpbnB1dCA9IHJlY29nbml6ZXIuaW5wdXRTdHJlYW07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChzdGFydFRva2VuID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRzdGFydFRva2VuID0gcmVjb2duaXplci5jdXJyZW50VG9rZW47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvZmZlbmRpbmdUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0b2ZmZW5kaW5nVG9rZW4gPSByZWNvZ25pemVyLmN1cnJlbnRUb2tlbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGN0eCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Y3R4ID0gcmVjb2duaXplci5jb250ZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0c3VwZXIocmVjb2duaXplciwgaW5wdXQsIGN0eCk7XHJcblx0XHR0aGlzLl9kZWFkRW5kQ29uZmlncyA9IGRlYWRFbmRDb25maWdzO1xyXG5cdFx0dGhpcy5fc3RhcnRUb2tlbiA9IHN0YXJ0VG9rZW4gYXMgVG9rZW47XHJcblx0XHR0aGlzLnNldE9mZmVuZGluZ1Rva2VuKHJlY29nbml6ZXIsIG9mZmVuZGluZ1Rva2VuKTtcclxuXHR9XHJcblxyXG5cdGdldCBzdGFydFRva2VuKCk6IFRva2VuIHtcclxuXHRcdHJldHVybiB0aGlzLl9zdGFydFRva2VuO1xyXG5cdH1cclxuXHJcblx0Z2V0IGRlYWRFbmRDb25maWdzKCk6IEFUTkNvbmZpZ1NldCB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZGVhZEVuZENvbmZpZ3M7XHJcblx0fVxyXG5cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTAuODI5MDUyNy0wNzowMFxyXG5cclxuaW1wb3J0IHsgQU5UTFJFcnJvclN0cmF0ZWd5IH0gZnJvbSBcIi4vQU5UTFJFcnJvclN0cmF0ZWd5XCI7XHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuL2F0bi9BVE5cIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9hdG4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vYXRuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24gfSBmcm9tIFwiLi9GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbiB9IGZyb20gXCIuL0lucHV0TWlzbWF0Y2hFeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWxTZXQgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsU2V0XCI7XHJcbmltcG9ydCB7IE5vVmlhYmxlQWx0RXhjZXB0aW9uIH0gZnJvbSBcIi4vTm9WaWFibGVBbHRFeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbkNvbnRleHQgfSBmcm9tIFwiLi9hdG4vUHJlZGljdGlvbkNvbnRleHRcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCIuL1J1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IFJ1bGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vYXRuL1J1bGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4vVG9rZW5TdHJlYW1cIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBUb2tlbkZhY3RvcnkgfSBmcm9tIFwiLi9Ub2tlbkZhY3RvcnlcIjtcclxuaW1wb3J0IHsgVG9rZW5Tb3VyY2UgfSBmcm9tIFwiLi9Ub2tlblNvdXJjZVwiO1xyXG5pbXBvcnQgeyBWb2NhYnVsYXJ5IH0gZnJvbSBcIi4vVm9jYWJ1bGFyeVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSwgTm90TnVsbCB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3l9IHVzZWQgZm9yXHJcbiAqIGVycm9yIHJlcG9ydGluZyBhbmQgcmVjb3ZlcnkgaW4gQU5UTFIgcGFyc2Vycy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0RXJyb3JTdHJhdGVneSBpbXBsZW1lbnRzIEFOVExSRXJyb3JTdHJhdGVneSB7XHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVycm9yIHN0cmF0ZWd5IGlzIGN1cnJlbnRseSBcInJlY292ZXJpbmcgZnJvbSBhblxyXG5cdCAqIGVycm9yXCIuIFRoaXMgaXMgdXNlZCB0byBzdXBwcmVzcyByZXBvcnRpbmcgbXVsdGlwbGUgZXJyb3IgbWVzc2FnZXMgd2hpbGVcclxuXHQgKiBhdHRlbXB0aW5nIHRvIHJlY292ZXIgZnJvbSBhIGRldGVjdGVkIHN5bnRheCBlcnJvci5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI2luRXJyb3JSZWNvdmVyeU1vZGVcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgZXJyb3JSZWNvdmVyeU1vZGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0LyoqIFRoZSBpbmRleCBpbnRvIHRoZSBpbnB1dCBzdHJlYW0gd2hlcmUgdGhlIGxhc3QgZXJyb3Igb2NjdXJyZWQuXHJcblx0ICogXHRUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcyB3aGVyZSBhbiBlcnJvciBpcyBmb3VuZFxyXG5cdCAqICBidXQgbm8gdG9rZW4gaXMgY29uc3VtZWQgZHVyaW5nIHJlY292ZXJ5Li4uYW5vdGhlciBlcnJvciBpcyBmb3VuZCxcclxuXHQgKiAgYWQgbmF1c2V1bS4gIFRoaXMgaXMgYSBmYWlsc2FmZSBtZWNoYW5pc20gdG8gZ3VhcmFudGVlIHRoYXQgYXQgbGVhc3RcclxuXHQgKiAgb25lIHRva2VuL3RyZWUgbm9kZSBpcyBjb25zdW1lZCBmb3IgdHdvIGVycm9ycy5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgbGFzdEVycm9ySW5kZXg6IG51bWJlciA9IC0xO1xyXG5cclxuXHRwcm90ZWN0ZWQgbGFzdEVycm9yU3RhdGVzPzogSW50ZXJ2YWxTZXQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgZmllbGQgaXMgdXNlZCB0byBwcm9wYWdhdGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxvb2thaGVhZCBmb2xsb3dpbmdcclxuXHQgKiB0aGUgcHJldmlvdXMgbWF0Y2guIFNpbmNlIHByZWRpY3Rpb24gcHJlZmVycyBjb21wbGV0aW5nIHRoZSBjdXJyZW50IHJ1bGVcclxuXHQgKiB0byBlcnJvciByZWNvdmVyeSBlZmZvcnRzLCBlcnJvciByZXBvcnRpbmcgbWF5IG9jY3VyIGxhdGVyIHRoYW4gdGhlXHJcblx0ICogb3JpZ2luYWwgcG9pbnQgd2hlcmUgaXQgd2FzIGRpc2NvdmVyYWJsZS4gVGhlIG9yaWdpbmFsIGNvbnRleHQgaXMgdXNlZCB0b1xyXG5cdCAqIGNvbXB1dGUgdGhlIHRydWUgZXhwZWN0ZWQgc2V0cyBhcyB0aG91Z2ggdGhlIHJlcG9ydGluZyBvY2N1cnJlZCBhcyBlYXJseVxyXG5cdCAqIGFzIHBvc3NpYmxlLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBuZXh0VG9rZW5zQ29udGV4dD86IFBhcnNlclJ1bGVDb250ZXh0O1xyXG5cclxuXHQvKipcclxuXHQgKiBAc2VlICNuZXh0VG9rZW5zQ29udGV4dFxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBuZXh0VG9rZW5zU3RhdGU6IG51bWJlciA9IEFUTlN0YXRlLklOVkFMSURfU1RBVEVfTlVNQkVSO1xyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW1wbHkgY2FsbHMge0BsaW5rICNlbmRFcnJvckNvbmRpdGlvbn0gdG9cclxuXHQgKiBlbnN1cmUgdGhhdCB0aGUgaGFuZGxlciBpcyBub3QgaW4gZXJyb3IgcmVjb3ZlcnkgbW9kZS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVzZXQocmVjb2duaXplcjogUGFyc2VyKTogdm9pZCB7XHJcblx0XHR0aGlzLmVuZEVycm9yQ29uZGl0aW9uKHJlY29nbml6ZXIpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHRvIGVudGVyIGVycm9yIHJlY292ZXJ5IG1vZGUgd2hlbiBhIHJlY29nbml0aW9uXHJcblx0ICogZXhjZXB0aW9uIGlzIHJlcG9ydGVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBiZWdpbkVycm9yQ29uZGl0aW9uKEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5lcnJvclJlY292ZXJ5TW9kZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcjogUGFyc2VyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5lcnJvclJlY292ZXJ5TW9kZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0byBsZWF2ZSBlcnJvciByZWNvdmVyeSBtb2RlIGFmdGVyIHJlY292ZXJpbmcgZnJvbVxyXG5cdCAqIGEgcmVjb2duaXRpb24gZXhjZXB0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXJcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgZW5kRXJyb3JDb25kaXRpb24oQE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyKTogdm9pZCB7XHJcblx0XHR0aGlzLmVycm9yUmVjb3ZlcnlNb2RlID0gZmFsc2U7XHJcblx0XHR0aGlzLmxhc3RFcnJvclN0YXRlcyA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMubGFzdEVycm9ySW5kZXggPSAtMTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNpbXBseSBjYWxscyB7QGxpbmsgI2VuZEVycm9yQ29uZGl0aW9ufS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVwb3J0TWF0Y2gocmVjb2duaXplcjogUGFyc2VyKTogdm9pZCB7XHJcblx0XHR0aGlzLmVuZEVycm9yQ29uZGl0aW9uKHJlY29nbml6ZXIpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBpbW1lZGlhdGVseSBpZiB0aGUgaGFuZGxlciBpcyBhbHJlYWR5XHJcblx0ICogaW4gZXJyb3IgcmVjb3ZlcnkgbW9kZS4gT3RoZXJ3aXNlLCBpdCBjYWxscyB7QGxpbmsgI2JlZ2luRXJyb3JDb25kaXRpb259XHJcblx0ICogYW5kIGRpc3BhdGNoZXMgdGhlIHJlcG9ydGluZyB0YXNrIGJhc2VkIG9uIHRoZSBydW50aW1lIHR5cGUgb2YgYGVgXHJcblx0ICogYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgdGFibGUuXHJcblx0ICpcclxuXHQgKiAqIHtAbGluayBOb1ZpYWJsZUFsdEV4Y2VwdGlvbn06IERpc3BhdGNoZXMgdGhlIGNhbGwgdG9cclxuXHQgKiAgIHtAbGluayAjcmVwb3J0Tm9WaWFibGVBbHRlcm5hdGl2ZX1cclxuXHQgKiAqIHtAbGluayBJbnB1dE1pc21hdGNoRXhjZXB0aW9ufTogRGlzcGF0Y2hlcyB0aGUgY2FsbCB0b1xyXG5cdCAqICAge0BsaW5rICNyZXBvcnRJbnB1dE1pc21hdGNofVxyXG5cdCAqICoge0BsaW5rIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbn06IERpc3BhdGNoZXMgdGhlIGNhbGwgdG9cclxuXHQgKiAgIHtAbGluayAjcmVwb3J0RmFpbGVkUHJlZGljYXRlfVxyXG5cdCAqICogQWxsIG90aGVyIHR5cGVzOiBjYWxscyB7QGxpbmsgUGFyc2VyI25vdGlmeUVycm9yTGlzdGVuZXJzfSB0byByZXBvcnRcclxuXHQgKiAgIHRoZSBleGNlcHRpb25cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVwb3J0RXJyb3IoXHJcblx0XHRyZWNvZ25pemVyOiBQYXJzZXIsXHJcblx0XHRlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbik6IHZvaWQge1xyXG5cdFx0Ly8gaWYgd2UndmUgYWxyZWFkeSByZXBvcnRlZCBhbiBlcnJvciBhbmQgaGF2ZSBub3QgbWF0Y2hlZCBhIHRva2VuXHJcblx0XHQvLyB5ZXQgc3VjY2Vzc2Z1bGx5LCBkb24ndCByZXBvcnQgYW55IGVycm9ycy5cclxuXHRcdGlmICh0aGlzLmluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcikpIHtcclxuLy9cdFx0XHRTeXN0ZW0uZXJyLnByaW50KFwiW1NQVVJJT1VTXSBcIik7XHJcblx0XHRcdHJldHVybjsgLy8gZG9uJ3QgcmVwb3J0IHNwdXJpb3VzIGVycm9yc1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5iZWdpbkVycm9yQ29uZGl0aW9uKHJlY29nbml6ZXIpO1xyXG5cdFx0aWYgKGUgaW5zdGFuY2VvZiBOb1ZpYWJsZUFsdEV4Y2VwdGlvbikge1xyXG5cdFx0XHR0aGlzLnJlcG9ydE5vVmlhYmxlQWx0ZXJuYXRpdmUocmVjb2duaXplciwgZSk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChlIGluc3RhbmNlb2YgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbikge1xyXG5cdFx0XHR0aGlzLnJlcG9ydElucHV0TWlzbWF0Y2gocmVjb2duaXplciwgZSk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChlIGluc3RhbmNlb2YgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKSB7XHJcblx0XHRcdHRoaXMucmVwb3J0RmFpbGVkUHJlZGljYXRlKHJlY29nbml6ZXIsIGUpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoYHVua25vd24gcmVjb2duaXRpb24gZXJyb3IgdHlwZTogJHtlfWApO1xyXG5cdFx0XHR0aGlzLm5vdGlmeUVycm9yTGlzdGVuZXJzKHJlY29nbml6ZXIsIGUudG9TdHJpbmcoKSwgZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgbm90aWZ5RXJyb3JMaXN0ZW5lcnMoQE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyLCBtZXNzYWdlOiBzdHJpbmcsIGU6IFJlY29nbml0aW9uRXhjZXB0aW9uKTogdm9pZCB7XHJcblx0XHRsZXQgb2ZmZW5kaW5nVG9rZW46IFRva2VuIHwgbnVsbCB8IHVuZGVmaW5lZCA9IGUuZ2V0T2ZmZW5kaW5nVG9rZW4ocmVjb2duaXplcik7XHJcblx0XHRpZiAob2ZmZW5kaW5nVG9rZW4gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHQvLyBQYXNzIG51bGwgdG8gbm90aWZ5RXJyb3JMaXN0ZW5lcnMgc28gaXQgaW4gdHVybiBjYWxscyB0aGUgZXJyb3IgbGlzdGVuZXJzIHdpdGggdW5kZWZpbmVkIGFzIHRoZSBvZmZlbmRpbmdcclxuXHRcdFx0Ly8gdG9rZW4uIElmIHdlIHBhc3NlZCB1bmRlZmluZWQsIGl0IHdvdWxkIGluc3RlYWQgY2FsbCB0aGUgbGlzdGVuZXJzIHdpdGggY3VycmVudFRva2VuIGZyb20gdGhlIHBhcnNlci5cclxuXHRcdFx0b2ZmZW5kaW5nVG9rZW4gPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMobWVzc2FnZSwgb2ZmZW5kaW5nVG9rZW4sIGUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmVzeW5jaHJvbml6ZXMgdGhlIHBhcnNlciBieSBjb25zdW1pbmcgdG9rZW5zXHJcblx0ICogdW50aWwgd2UgZmluZCBvbmUgaW4gdGhlIHJlc3luY2hyb25pemF0aW9uIHNldC0tbG9vc2VseSB0aGUgc2V0IG9mIHRva2Vuc1xyXG5cdCAqIHRoYXQgY2FuIGZvbGxvdyB0aGUgY3VycmVudCBydWxlLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZWNvdmVyKHJlY29nbml6ZXI6IFBhcnNlciwgZTogUmVjb2duaXRpb25FeGNlcHRpb24pOiB2b2lkIHtcclxuLy9cdFx0U3lzdGVtLm91dC5wcmludGxuKFwicmVjb3ZlciBpbiBcIityZWNvZ25pemVyLmdldFJ1bGVJbnZvY2F0aW9uU3RhY2soKStcclxuLy9cdFx0XHRcdFx0XHQgICBcIiBpbmRleD1cIityZWNvZ25pemVyLmlucHV0U3RyZWFtLmluZGV4K1xyXG4vL1x0XHRcdFx0XHRcdCAgIFwiLCBsYXN0RXJyb3JJbmRleD1cIitcclxuLy9cdFx0XHRcdFx0XHQgICBsYXN0RXJyb3JJbmRleCtcclxuLy9cdFx0XHRcdFx0XHQgICBcIiwgc3RhdGVzPVwiK2xhc3RFcnJvclN0YXRlcyk7XHJcblx0XHRpZiAodGhpcy5sYXN0RXJyb3JJbmRleCA9PT0gcmVjb2duaXplci5pbnB1dFN0cmVhbS5pbmRleCAmJlxyXG5cdFx0XHR0aGlzLmxhc3RFcnJvclN0YXRlcyAmJlxyXG5cdFx0XHR0aGlzLmxhc3RFcnJvclN0YXRlcy5jb250YWlucyhyZWNvZ25pemVyLnN0YXRlKSkge1xyXG5cdFx0XHQvLyB1aCBvaCwgYW5vdGhlciBlcnJvciBhdCBzYW1lIHRva2VuIGluZGV4IGFuZCBwcmV2aW91c2x5LXZpc2l0ZWRcclxuXHRcdFx0Ly8gc3RhdGUgaW4gQVROOyBtdXN0IGJlIGEgY2FzZSB3aGVyZSBMVCgxKSBpcyBpbiB0aGUgcmVjb3ZlcnlcclxuXHRcdFx0Ly8gdG9rZW4gc2V0IHNvIG5vdGhpbmcgZ290IGNvbnN1bWVkLiBDb25zdW1lIGEgc2luZ2xlIHRva2VuXHJcblx0XHRcdC8vIGF0IGxlYXN0IHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcDsgdGhpcyBpcyBhIGZhaWxzYWZlLlxyXG4vL1x0XHRcdFN5c3RlbS5lcnIucHJpbnRsbihcInNlZW4gZXJyb3IgY29uZGl0aW9uIGJlZm9yZSBpbmRleD1cIitcclxuLy9cdFx0XHRcdFx0XHRcdCAgIGxhc3RFcnJvckluZGV4K1wiLCBzdGF0ZXM9XCIrbGFzdEVycm9yU3RhdGVzKTtcclxuLy9cdFx0XHRTeXN0ZW0uZXJyLnByaW50bG4oXCJGQUlMU0FGRSBjb25zdW1lcyBcIityZWNvZ25pemVyLmdldFRva2VuTmFtZXMoKVtyZWNvZ25pemVyLmlucHV0U3RyZWFtLkxBKDEpXSk7XHJcblx0XHRcdHJlY29nbml6ZXIuY29uc3VtZSgpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5sYXN0RXJyb3JJbmRleCA9IHJlY29nbml6ZXIuaW5wdXRTdHJlYW0uaW5kZXg7XHJcblx0XHRpZiAoIXRoaXMubGFzdEVycm9yU3RhdGVzKSB7XHJcblx0XHRcdHRoaXMubGFzdEVycm9yU3RhdGVzID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxhc3RFcnJvclN0YXRlcy5hZGQocmVjb2duaXplci5zdGF0ZSk7XHJcblx0XHRsZXQgZm9sbG93U2V0OiBJbnRlcnZhbFNldCA9IHRoaXMuZ2V0RXJyb3JSZWNvdmVyeVNldChyZWNvZ25pemVyKTtcclxuXHRcdHRoaXMuY29uc3VtZVVudGlsKHJlY29nbml6ZXIsIGZvbGxvd1NldCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5I3N5bmN9IG1ha2VzIHN1cmVcclxuXHQgKiB0aGF0IHRoZSBjdXJyZW50IGxvb2thaGVhZCBzeW1ib2wgaXMgY29uc2lzdGVudCB3aXRoIHdoYXQgd2VyZSBleHBlY3RpbmdcclxuXHQgKiBhdCB0aGlzIHBvaW50IGluIHRoZSBBVE4uIFlvdSBjYW4gY2FsbCB0aGlzIGFueXRpbWUgYnV0IEFOVExSIG9ubHlcclxuXHQgKiBnZW5lcmF0ZXMgY29kZSB0byBjaGVjayBiZWZvcmUgc3VicnVsZXMvbG9vcHMgYW5kIGVhY2ggaXRlcmF0aW9uLlxyXG5cdCAqXHJcblx0ICogSW1wbGVtZW50cyBKaW0gSWRsZSdzIG1hZ2ljIHN5bmMgbWVjaGFuaXNtIGluIGNsb3N1cmVzIGFuZCBvcHRpb25hbFxyXG5cdCAqIHN1YnJ1bGVzLiBFLmcuLFxyXG5cdCAqXHJcblx0ICogYGBgYW50bHJcclxuXHQgKiBhIDogc3luYyAoIHN0dWZmIHN5bmMgKSogO1xyXG5cdCAqIHN5bmMgOiB7Y29uc3VtZSB0byB3aGF0IGNhbiBmb2xsb3cgc3luY30gO1xyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQXQgdGhlIHN0YXJ0IG9mIGEgc3ViIHJ1bGUgdXBvbiBlcnJvciwge0BsaW5rICNzeW5jfSBwZXJmb3JtcyBzaW5nbGVcclxuXHQgKiB0b2tlbiBkZWxldGlvbiwgaWYgcG9zc2libGUuIElmIGl0IGNhbid0IGRvIHRoYXQsIGl0IGJhaWxzIG9uIHRoZSBjdXJyZW50XHJcblx0ICogcnVsZSBhbmQgdXNlcyB0aGUgZGVmYXVsdCBlcnJvciByZWNvdmVyeSwgd2hpY2ggY29uc3VtZXMgdW50aWwgdGhlXHJcblx0ICogcmVzeW5jaHJvbml6YXRpb24gc2V0IG9mIHRoZSBjdXJyZW50IHJ1bGUuXHJcblx0ICpcclxuXHQgKiBJZiB0aGUgc3ViIHJ1bGUgaXMgb3B0aW9uYWwgKGAoLi4uKT9gLCBgKC4uLikqYCwgb3IgYmxvY2tcclxuXHQgKiB3aXRoIGFuIGVtcHR5IGFsdGVybmF0aXZlKSwgdGhlbiB0aGUgZXhwZWN0ZWQgc2V0IGluY2x1ZGVzIHdoYXQgZm9sbG93c1xyXG5cdCAqIHRoZSBzdWJydWxlLlxyXG5cdCAqXHJcblx0ICogRHVyaW5nIGxvb3AgaXRlcmF0aW9uLCBpdCBjb25zdW1lcyB1bnRpbCBpdCBzZWVzIGEgdG9rZW4gdGhhdCBjYW4gc3RhcnQgYVxyXG5cdCAqIHN1YiBydWxlIG9yIHdoYXQgZm9sbG93cyBsb29wLiBZZXMsIHRoYXQgaXMgcHJldHR5IGFnZ3Jlc3NpdmUuIFdlIG9wdCB0b1xyXG5cdCAqIHN0YXkgaW4gdGhlIGxvb3AgYXMgbG9uZyBhcyBwb3NzaWJsZS5cclxuXHQgKlxyXG5cdCAqICoqT1JJR0lOUyoqXHJcblx0ICpcclxuXHQgKiBQcmV2aW91cyB2ZXJzaW9ucyBvZiBBTlRMUiBkaWQgYSBwb29yIGpvYiBvZiB0aGVpciByZWNvdmVyeSB3aXRoaW4gbG9vcHMuXHJcblx0ICogQSBzaW5nbGUgbWlzbWF0Y2ggdG9rZW4gb3IgbWlzc2luZyB0b2tlbiB3b3VsZCBmb3JjZSB0aGUgcGFyc2VyIHRvIGJhaWxcclxuXHQgKiBvdXQgb2YgdGhlIGVudGlyZSBydWxlcyBzdXJyb3VuZGluZyB0aGUgbG9vcC4gU28sIGZvciBydWxlXHJcblx0ICpcclxuXHQgKiBgYGBhbnRsclxyXG5cdCAqIGNsYXNzRGVmIDogJ2NsYXNzJyBJRCAneycgbWVtYmVyKiAnfSdcclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIGlucHV0IHdpdGggYW4gZXh0cmEgdG9rZW4gYmV0d2VlbiBtZW1iZXJzIHdvdWxkIGZvcmNlIHRoZSBwYXJzZXIgdG9cclxuXHQgKiBjb25zdW1lIHVudGlsIGl0IGZvdW5kIHRoZSBuZXh0IGNsYXNzIGRlZmluaXRpb24gcmF0aGVyIHRoYW4gdGhlIG5leHRcclxuXHQgKiBtZW1iZXIgZGVmaW5pdGlvbiBvZiB0aGUgY3VycmVudCBjbGFzcy5cclxuXHQgKlxyXG5cdCAqIFRoaXMgZnVuY3Rpb25hbGl0eSBjb3N0IGEgbGl0dGxlIGJpdCBvZiBlZmZvcnQgYmVjYXVzZSB0aGUgcGFyc2VyIGhhcyB0b1xyXG5cdCAqIGNvbXBhcmUgdG9rZW4gc2V0IGF0IHRoZSBzdGFydCBvZiB0aGUgbG9vcCBhbmQgYXQgZWFjaCBpdGVyYXRpb24uIElmIGZvclxyXG5cdCAqIHNvbWUgcmVhc29uIHNwZWVkIGlzIHN1ZmZlcmluZyBmb3IgeW91LCB5b3UgY2FuIHR1cm4gb2ZmIHRoaXNcclxuXHQgKiBmdW5jdGlvbmFsaXR5IGJ5IHNpbXBseSBvdmVycmlkaW5nIHRoaXMgbWV0aG9kIGFzIGEgYmxhbmsgeyB9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBzeW5jKHJlY29nbml6ZXI6IFBhcnNlcik6IHZvaWQge1xyXG5cdFx0bGV0IHM6IEFUTlN0YXRlID0gcmVjb2duaXplci5pbnRlcnByZXRlci5hdG4uc3RhdGVzW3JlY29nbml6ZXIuc3RhdGVdO1xyXG4vL1x0XHRTeXN0ZW0uZXJyLnByaW50bG4oXCJzeW5jIEAgXCIrcy5zdGF0ZU51bWJlcitcIj1cIitzLmdldENsYXNzKCkuZ2V0U2ltcGxlTmFtZSgpKTtcclxuXHRcdC8vIElmIGFscmVhZHkgcmVjb3ZlcmluZywgZG9uJ3QgdHJ5IHRvIHN5bmNcclxuXHRcdGlmICh0aGlzLmluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcikpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0b2tlbnM6IFRva2VuU3RyZWFtID0gcmVjb2duaXplci5pbnB1dFN0cmVhbTtcclxuXHRcdGxldCBsYTogbnVtYmVyID0gdG9rZW5zLkxBKDEpO1xyXG5cclxuXHRcdC8vIHRyeSBjaGVhcGVyIHN1YnNldCBmaXJzdDsgbWlnaHQgZ2V0IGx1Y2t5LiBzZWVtcyB0byBzaGF2ZSBhIHdlZSBiaXQgb2ZmXHJcblx0XHRsZXQgbmV4dFRva2VuczogSW50ZXJ2YWxTZXQgPSByZWNvZ25pemVyLmF0bi5uZXh0VG9rZW5zKHMpO1xyXG5cdFx0aWYgKG5leHRUb2tlbnMuY29udGFpbnMobGEpKSB7XHJcblx0XHRcdC8vIFdlIGFyZSBzdXJlIHRoZSB0b2tlbiBtYXRjaGVzXHJcblx0XHRcdHRoaXMubmV4dFRva2Vuc0NvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdHRoaXMubmV4dFRva2Vuc1N0YXRlID0gQVROU3RhdGUuSU5WQUxJRF9TVEFURV9OVU1CRVI7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV4dFRva2Vucy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSkge1xyXG5cdFx0XHRpZiAodGhpcy5uZXh0VG9rZW5zQ29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Ly8gSXQncyBwb3NzaWJsZSB0aGUgbmV4dCB0b2tlbiB3b24ndCBtYXRjaDsgaW5mb3JtYXRpb24gdHJhY2tlZFxyXG5cdFx0XHRcdC8vIGJ5IHN5bmMgaXMgcmVzdHJpY3RlZCBmb3IgcGVyZm9ybWFuY2UuXHJcblx0XHRcdFx0dGhpcy5uZXh0VG9rZW5zQ29udGV4dCA9IHJlY29nbml6ZXIuY29udGV4dDtcclxuXHRcdFx0XHR0aGlzLm5leHRUb2tlbnNTdGF0ZSA9IHJlY29nbml6ZXIuc3RhdGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRzd2l0Y2ggKHMuc3RhdGVUeXBlKSB7XHJcblx0XHRjYXNlIEFUTlN0YXRlVHlwZS5CTE9DS19TVEFSVDpcclxuXHRcdGNhc2UgQVROU3RhdGVUeXBlLlNUQVJfQkxPQ0tfU1RBUlQ6XHJcblx0XHRjYXNlIEFUTlN0YXRlVHlwZS5QTFVTX0JMT0NLX1NUQVJUOlxyXG5cdFx0Y2FzZSBBVE5TdGF0ZVR5cGUuU1RBUl9MT09QX0VOVFJZOlxyXG5cdFx0XHQvLyByZXBvcnQgZXJyb3IgYW5kIHJlY292ZXIgaWYgcG9zc2libGVcclxuXHRcdFx0aWYgKHRoaXMuc2luZ2xlVG9rZW5EZWxldGlvbihyZWNvZ25pemVyKSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhyb3cgbmV3IElucHV0TWlzbWF0Y2hFeGNlcHRpb24ocmVjb2duaXplcik7XHJcblxyXG5cdFx0Y2FzZSBBVE5TdGF0ZVR5cGUuUExVU19MT09QX0JBQ0s6XHJcblx0XHRjYXNlIEFUTlN0YXRlVHlwZS5TVEFSX0xPT1BfQkFDSzpcclxuLy9cdFx0XHRTeXN0ZW0uZXJyLnByaW50bG4oXCJhdCBsb29wIGJhY2s6IFwiK3MuZ2V0Q2xhc3MoKS5nZXRTaW1wbGVOYW1lKCkpO1xyXG5cdFx0XHR0aGlzLnJlcG9ydFVud2FudGVkVG9rZW4ocmVjb2duaXplcik7XHJcblx0XHRcdGxldCBleHBlY3Rpbmc6IEludGVydmFsU2V0ID0gcmVjb2duaXplci5nZXRFeHBlY3RlZFRva2VucygpO1xyXG5cdFx0XHRsZXQgd2hhdEZvbGxvd3NMb29wSXRlcmF0aW9uT3JSdWxlOiBJbnRlcnZhbFNldCA9XHJcblx0XHRcdFx0ZXhwZWN0aW5nLm9yKHRoaXMuZ2V0RXJyb3JSZWNvdmVyeVNldChyZWNvZ25pemVyKSk7XHJcblx0XHRcdHRoaXMuY29uc3VtZVVudGlsKHJlY29nbml6ZXIsIHdoYXRGb2xsb3dzTG9vcEl0ZXJhdGlvbk9yUnVsZSk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdC8vIGRvIG5vdGhpbmcgaWYgd2UgY2FuJ3QgaWRlbnRpZnkgdGhlIGV4YWN0IGtpbmQgb2YgQVROIHN0YXRlXHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyBjYWxsZWQgYnkge0BsaW5rICNyZXBvcnRFcnJvcn0gd2hlbiB0aGUgZXhjZXB0aW9uIGlzIGFcclxuXHQgKiB7QGxpbmsgTm9WaWFibGVBbHRFeGNlcHRpb259LlxyXG5cdCAqXHJcblx0ICogQHNlZSAjcmVwb3J0RXJyb3JcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKiBAcGFyYW0gZSB0aGUgcmVjb2duaXRpb24gZXhjZXB0aW9uXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHJlcG9ydE5vVmlhYmxlQWx0ZXJuYXRpdmUoXHJcblx0XHRATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIsXHJcblx0XHRATm90TnVsbCBlOiBOb1ZpYWJsZUFsdEV4Y2VwdGlvbik6IHZvaWQge1xyXG5cdFx0bGV0IHRva2VuczogVG9rZW5TdHJlYW0gPSByZWNvZ25pemVyLmlucHV0U3RyZWFtO1xyXG5cdFx0bGV0IGlucHV0OiBzdHJpbmc7XHJcblx0XHRpZiAodG9rZW5zKSB7XHJcblx0XHRcdGlmIChlLnN0YXJ0VG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdFx0aW5wdXQgPSBcIjxFT0Y+XCI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aW5wdXQgPSB0b2tlbnMuZ2V0VGV4dEZyb21SYW5nZShlLnN0YXJ0VG9rZW4sIGUuZ2V0T2ZmZW5kaW5nVG9rZW4oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRpbnB1dCA9IFwiPHVua25vd24gaW5wdXQ+XCI7XHJcblx0XHR9XHJcblx0XHRsZXQgbXNnOiBzdHJpbmcgPSBcIm5vIHZpYWJsZSBhbHRlcm5hdGl2ZSBhdCBpbnB1dCBcIiArIHRoaXMuZXNjYXBlV1NBbmRRdW90ZShpbnB1dCk7XHJcblx0XHR0aGlzLm5vdGlmeUVycm9yTGlzdGVuZXJzKHJlY29nbml6ZXIsIG1zZywgZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIGNhbGxlZCBieSB7QGxpbmsgI3JlcG9ydEVycm9yfSB3aGVuIHRoZSBleGNlcHRpb24gaXMgYW5cclxuXHQgKiB7QGxpbmsgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbn0uXHJcblx0ICpcclxuXHQgKiBAc2VlICNyZXBvcnRFcnJvclxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxyXG5cdCAqIEBwYXJhbSBlIHRoZSByZWNvZ25pdGlvbiBleGNlcHRpb25cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcmVwb3J0SW5wdXRNaXNtYXRjaChcclxuXHRcdEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlcixcclxuXHRcdEBOb3ROdWxsIGU6IElucHV0TWlzbWF0Y2hFeGNlcHRpb24pOiB2b2lkIHtcclxuXHRcdGxldCBleHBlY3RlZCA9IGUuZXhwZWN0ZWRUb2tlbnM7XHJcblx0XHRsZXQgZXhwZWN0ZWRTdHJpbmcgPSBleHBlY3RlZCA/IGV4cGVjdGVkLnRvU3RyaW5nVm9jYWJ1bGFyeShyZWNvZ25pemVyLnZvY2FidWxhcnkpIDogXCJcIjtcclxuXHRcdGxldCBtc2c6IHN0cmluZyA9IFwibWlzbWF0Y2hlZCBpbnB1dCBcIiArIHRoaXMuZ2V0VG9rZW5FcnJvckRpc3BsYXkoZS5nZXRPZmZlbmRpbmdUb2tlbihyZWNvZ25pemVyKSkgK1xyXG5cdFx0XHRcIiBleHBlY3RpbmcgXCIgKyBleHBlY3RlZFN0cmluZztcclxuXHRcdHRoaXMubm90aWZ5RXJyb3JMaXN0ZW5lcnMocmVjb2duaXplciwgbXNnLCBlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgY2FsbGVkIGJ5IHtAbGluayAjcmVwb3J0RXJyb3J9IHdoZW4gdGhlIGV4Y2VwdGlvbiBpcyBhXHJcblx0ICoge0BsaW5rIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbn0uXHJcblx0ICpcclxuXHQgKiBAc2VlICNyZXBvcnRFcnJvclxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxyXG5cdCAqIEBwYXJhbSBlIHRoZSByZWNvZ25pdGlvbiBleGNlcHRpb25cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcmVwb3J0RmFpbGVkUHJlZGljYXRlKFxyXG5cdFx0QE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyLFxyXG5cdFx0QE5vdE51bGwgZTogRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKTogdm9pZCB7XHJcblx0XHRsZXQgcnVsZU5hbWU6IHN0cmluZyA9IHJlY29nbml6ZXIucnVsZU5hbWVzW3JlY29nbml6ZXIuY29udGV4dC5ydWxlSW5kZXhdO1xyXG5cdFx0bGV0IG1zZzogc3RyaW5nID0gXCJydWxlIFwiICsgcnVsZU5hbWUgKyBcIiBcIiArIGUubWVzc2FnZTtcclxuXHRcdHRoaXMubm90aWZ5RXJyb3JMaXN0ZW5lcnMocmVjb2duaXplciwgbXNnLCBlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0byByZXBvcnQgYSBzeW50YXggZXJyb3Igd2hpY2ggcmVxdWlyZXMgdGhlIHJlbW92YWxcclxuXHQgKiBvZiBhIHRva2VuIGZyb20gdGhlIGlucHV0IHN0cmVhbS4gQXQgdGhlIHRpbWUgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGVcclxuXHQgKiBlcnJvbmVvdXMgc3ltYm9sIGlzIGN1cnJlbnQgYExUKDEpYCBzeW1ib2wgYW5kIGhhcyBub3QgeWV0IGJlZW5cclxuXHQgKiByZW1vdmVkIGZyb20gdGhlIGlucHV0IHN0cmVhbS4gV2hlbiB0aGlzIG1ldGhvZCByZXR1cm5zLFxyXG5cdCAqIGByZWNvZ25pemVyYCBpcyBpbiBlcnJvciByZWNvdmVyeSBtb2RlLlxyXG5cdCAqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4ge0BsaW5rICNzaW5nbGVUb2tlbkRlbGV0aW9ufSBpZGVudGlmaWVzXHJcblx0ICogc2luZ2xlLXRva2VuIGRlbGV0aW9uIGFzIGEgdmlhYmxlIHJlY292ZXJ5IHN0cmF0ZWd5IGZvciBhIG1pc21hdGNoZWRcclxuXHQgKiBpbnB1dCBlcnJvci5cclxuXHQgKlxyXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNpbXBseSByZXR1cm5zIGlmIHRoZSBoYW5kbGVyIGlzIGFscmVhZHkgaW5cclxuXHQgKiBlcnJvciByZWNvdmVyeSBtb2RlLiBPdGhlcndpc2UsIGl0IGNhbGxzIHtAbGluayAjYmVnaW5FcnJvckNvbmRpdGlvbn0gdG9cclxuXHQgKiBlbnRlciBlcnJvciByZWNvdmVyeSBtb2RlLCBmb2xsb3dlZCBieSBjYWxsaW5nXHJcblx0ICoge0BsaW5rIFBhcnNlciNub3RpZnlFcnJvckxpc3RlbmVyc30uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHJlcG9ydFVud2FudGVkVG9rZW4oQE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5pbkVycm9yUmVjb3ZlcnlNb2RlKHJlY29nbml6ZXIpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJlZ2luRXJyb3JDb25kaXRpb24ocmVjb2duaXplcik7XHJcblxyXG5cdFx0bGV0IHQ6IFRva2VuID0gcmVjb2duaXplci5jdXJyZW50VG9rZW47XHJcblx0XHRsZXQgdG9rZW5OYW1lOiBzdHJpbmcgPSB0aGlzLmdldFRva2VuRXJyb3JEaXNwbGF5KHQpO1xyXG5cdFx0bGV0IGV4cGVjdGluZzogSW50ZXJ2YWxTZXQgPSB0aGlzLmdldEV4cGVjdGVkVG9rZW5zKHJlY29nbml6ZXIpO1xyXG5cdFx0bGV0IG1zZzogc3RyaW5nID0gXCJleHRyYW5lb3VzIGlucHV0IFwiICsgdG9rZW5OYW1lICsgXCIgZXhwZWN0aW5nIFwiICtcclxuXHRcdFx0ZXhwZWN0aW5nLnRvU3RyaW5nVm9jYWJ1bGFyeShyZWNvZ25pemVyLnZvY2FidWxhcnkpO1xyXG5cdFx0cmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtc2csIHQsIHVuZGVmaW5lZCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdG8gcmVwb3J0IGEgc3ludGF4IGVycm9yIHdoaWNoIHJlcXVpcmVzIHRoZVxyXG5cdCAqIGluc2VydGlvbiBvZiBhIG1pc3NpbmcgdG9rZW4gaW50byB0aGUgaW5wdXQgc3RyZWFtLiBBdCB0aGUgdGltZSB0aGlzXHJcblx0ICogbWV0aG9kIGlzIGNhbGxlZCwgdGhlIG1pc3NpbmcgdG9rZW4gaGFzIG5vdCB5ZXQgYmVlbiBpbnNlcnRlZC4gV2hlbiB0aGlzXHJcblx0ICogbWV0aG9kIHJldHVybnMsIGByZWNvZ25pemVyYCBpcyBpbiBlcnJvciByZWNvdmVyeSBtb2RlLlxyXG5cdCAqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4ge0BsaW5rICNzaW5nbGVUb2tlbkluc2VydGlvbn0gaWRlbnRpZmllc1xyXG5cdCAqIHNpbmdsZS10b2tlbiBpbnNlcnRpb24gYXMgYSB2aWFibGUgcmVjb3Zlcnkgc3RyYXRlZ3kgZm9yIGEgbWlzbWF0Y2hlZFxyXG5cdCAqIGlucHV0IGVycm9yLlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2ltcGx5IHJldHVybnMgaWYgdGhlIGhhbmRsZXIgaXMgYWxyZWFkeSBpblxyXG5cdCAqIGVycm9yIHJlY292ZXJ5IG1vZGUuIE90aGVyd2lzZSwgaXQgY2FsbHMge0BsaW5rICNiZWdpbkVycm9yQ29uZGl0aW9ufSB0b1xyXG5cdCAqIGVudGVyIGVycm9yIHJlY292ZXJ5IG1vZGUsIGZvbGxvd2VkIGJ5IGNhbGxpbmdcclxuXHQgKiB7QGxpbmsgUGFyc2VyI25vdGlmeUVycm9yTGlzdGVuZXJzfS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcmVwb3J0TWlzc2luZ1Rva2VuKEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlcik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuaW5FcnJvclJlY292ZXJ5TW9kZShyZWNvZ25pemVyKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5iZWdpbkVycm9yQ29uZGl0aW9uKHJlY29nbml6ZXIpO1xyXG5cclxuXHRcdGxldCB0OiBUb2tlbiA9IHJlY29nbml6ZXIuY3VycmVudFRva2VuO1xyXG5cdFx0bGV0IGV4cGVjdGluZzogSW50ZXJ2YWxTZXQgPSB0aGlzLmdldEV4cGVjdGVkVG9rZW5zKHJlY29nbml6ZXIpO1xyXG5cdFx0bGV0IG1zZzogc3RyaW5nID0gXCJtaXNzaW5nIFwiICsgZXhwZWN0aW5nLnRvU3RyaW5nVm9jYWJ1bGFyeShyZWNvZ25pemVyLnZvY2FidWxhcnkpICtcclxuXHRcdFx0XCIgYXQgXCIgKyB0aGlzLmdldFRva2VuRXJyb3JEaXNwbGF5KHQpO1xyXG5cclxuXHRcdHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMobXNnLCB0LCB1bmRlZmluZWQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYXR0ZW1wdHMgdG8gcmVjb3ZlciBmcm9tIHRoZSBtaXNtYXRjaGVkIGlucHV0XHJcblx0ICogYnkgdXNpbmcgc2luZ2xlIHRva2VuIGluc2VydGlvbiBhbmQgZGVsZXRpb24gYXMgZGVzY3JpYmVkIGJlbG93LiBJZiB0aGVcclxuXHQgKiByZWNvdmVyeSBhdHRlbXB0IGZhaWxzLCB0aGlzIG1ldGhvZFxyXG5cdCAqIHtAbGluayBJbnB1dE1pc21hdGNoRXhjZXB0aW9ufS5cclxuXHQgKlxyXG5cdCAqICoqRVhUUkEgVE9LRU4qKiAoc2luZ2xlIHRva2VuIGRlbGV0aW9uKVxyXG5cdCAqXHJcblx0ICogYExBKDEpYCBpcyBub3Qgd2hhdCB3ZSBhcmUgbG9va2luZyBmb3IuIElmIGBMQSgyKWAgaGFzIHRoZVxyXG5cdCAqIHJpZ2h0IHRva2VuLCBob3dldmVyLCB0aGVuIGFzc3VtZSBgTEEoMSlgIGlzIHNvbWUgZXh0cmEgc3B1cmlvdXNcclxuXHQgKiB0b2tlbiBhbmQgZGVsZXRlIGl0LiBUaGVuIGNvbnN1bWUgYW5kIHJldHVybiB0aGUgbmV4dCB0b2tlbiAod2hpY2ggd2FzXHJcblx0ICogdGhlIGBMQSgyKWAgdG9rZW4pIGFzIHRoZSBzdWNjZXNzZnVsIHJlc3VsdCBvZiB0aGUgbWF0Y2ggb3BlcmF0aW9uLlxyXG5cdCAqXHJcblx0ICogVGhpcyByZWNvdmVyeSBzdHJhdGVneSBpcyBpbXBsZW1lbnRlZCBieSB7QGxpbmsgI3NpbmdsZVRva2VuRGVsZXRpb259LlxyXG5cdCAqXHJcblx0ICogKipNSVNTSU5HIFRPS0VOKiogKHNpbmdsZSB0b2tlbiBpbnNlcnRpb24pXHJcblx0ICpcclxuXHQgKiBJZiBjdXJyZW50IHRva2VuIChhdCBgTEEoMSlgKSBpcyBjb25zaXN0ZW50IHdpdGggd2hhdCBjb3VsZCBjb21lXHJcblx0ICogYWZ0ZXIgdGhlIGV4cGVjdGVkIGBMQSgxKWAgdG9rZW4sIHRoZW4gYXNzdW1lIHRoZSB0b2tlbiBpcyBtaXNzaW5nXHJcblx0ICogYW5kIHVzZSB0aGUgcGFyc2VyJ3Mge0BsaW5rIFRva2VuRmFjdG9yeX0gdG8gY3JlYXRlIGl0IG9uIHRoZSBmbHkuIFRoZVxyXG5cdCAqIFwiaW5zZXJ0aW9uXCIgaXMgcGVyZm9ybWVkIGJ5IHJldHVybmluZyB0aGUgY3JlYXRlZCB0b2tlbiBhcyB0aGUgc3VjY2Vzc2Z1bFxyXG5cdCAqIHJlc3VsdCBvZiB0aGUgbWF0Y2ggb3BlcmF0aW9uLlxyXG5cdCAqXHJcblx0ICogVGhpcyByZWNvdmVyeSBzdHJhdGVneSBpcyBpbXBsZW1lbnRlZCBieSB7QGxpbmsgI3NpbmdsZVRva2VuSW5zZXJ0aW9ufS5cclxuXHQgKlxyXG5cdCAqICoqRVhBTVBMRSoqXHJcblx0ICpcclxuXHQgKiBGb3IgZXhhbXBsZSwgSW5wdXQgYGk9KDM7YCBpcyBjbGVhcmx5IG1pc3NpbmcgdGhlIGAnKSdgLiBXaGVuXHJcblx0ICogdGhlIHBhcnNlciByZXR1cm5zIGZyb20gdGhlIG5lc3RlZCBjYWxsIHRvIGBleHByYCwgaXQgd2lsbCBoYXZlXHJcblx0ICogY2FsbCBjaGFpbjpcclxuXHQgKlxyXG5cdCAqIGBgYFxyXG5cdCAqIHN0YXQgXHUyMTkyIGV4cHIgXHUyMTkyIGF0b21cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIGFuZCBpdCB3aWxsIGJlIHRyeWluZyB0byBtYXRjaCB0aGUgYCcpJ2AgYXQgdGhpcyBwb2ludCBpbiB0aGVcclxuXHQgKiBkZXJpdmF0aW9uOlxyXG5cdCAqXHJcblx0ICogYGBgXHJcblx0ICogPT4gSUQgJz0nICcoJyBJTlQgJyknICgnKycgYXRvbSkqICc7J1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICBeXHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBUaGUgYXR0ZW1wdCB0byBtYXRjaCBgJyknYCB3aWxsIGZhaWwgd2hlbiBpdCBzZWVzIGAnOydgIGFuZFxyXG5cdCAqIGNhbGwge0BsaW5rICNyZWNvdmVySW5saW5lfS4gVG8gcmVjb3ZlciwgaXQgc2VlcyB0aGF0IGBMQSgxKT09JzsnYFxyXG5cdCAqIGlzIGluIHRoZSBzZXQgb2YgdG9rZW5zIHRoYXQgY2FuIGZvbGxvdyB0aGUgYCcpJ2AgdG9rZW4gcmVmZXJlbmNlXHJcblx0ICogaW4gcnVsZSBgYXRvbWAuIEl0IGNhbiBhc3N1bWUgdGhhdCB5b3UgZm9yZ290IHRoZSBgJyknYC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVjb3ZlcklubGluZShyZWNvZ25pemVyOiBQYXJzZXIpOiBUb2tlbiB7XHJcblx0XHQvLyBTSU5HTEUgVE9LRU4gREVMRVRJT05cclxuXHRcdGxldCBtYXRjaGVkU3ltYm9sID0gdGhpcy5zaW5nbGVUb2tlbkRlbGV0aW9uKHJlY29nbml6ZXIpO1xyXG5cdFx0aWYgKG1hdGNoZWRTeW1ib2wpIHtcclxuXHRcdFx0Ly8gd2UgaGF2ZSBkZWxldGVkIHRoZSBleHRyYSB0b2tlbi5cclxuXHRcdFx0Ly8gbm93LCBtb3ZlIHBhc3QgdHR5cGUgdG9rZW4gYXMgaWYgYWxsIHdlcmUgb2tcclxuXHRcdFx0cmVjb2duaXplci5jb25zdW1lKCk7XHJcblx0XHRcdHJldHVybiBtYXRjaGVkU3ltYm9sO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNJTkdMRSBUT0tFTiBJTlNFUlRJT05cclxuXHRcdGlmICh0aGlzLnNpbmdsZVRva2VuSW5zZXJ0aW9uKHJlY29nbml6ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldE1pc3NpbmdTeW1ib2wocmVjb2duaXplcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZXZlbiB0aGF0IGRpZG4ndCB3b3JrOyBtdXN0IHRocm93IHRoZSBleGNlcHRpb25cclxuXHRcdGlmICh0aGlzLm5leHRUb2tlbnNDb250ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IElucHV0TWlzbWF0Y2hFeGNlcHRpb24ocmVjb2duaXplcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBuZXcgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbihyZWNvZ25pemVyLCB0aGlzLm5leHRUb2tlbnNTdGF0ZSwgdGhpcy5uZXh0VG9rZW5zQ29udGV4dCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBzaW5nbGUtdG9rZW4gaW5zZXJ0aW9uIGlubGluZSBlcnJvciByZWNvdmVyeVxyXG5cdCAqIHN0cmF0ZWd5LiBJdCBpcyBjYWxsZWQgYnkge0BsaW5rICNyZWNvdmVySW5saW5lfSBpZiB0aGUgc2luZ2xlLXRva2VuXHJcblx0ICogZGVsZXRpb24gc3RyYXRlZ3kgZmFpbHMgdG8gcmVjb3ZlciBmcm9tIHRoZSBtaXNtYXRjaGVkIGlucHV0LiBJZiB0aGlzXHJcblx0ICogbWV0aG9kIHJldHVybnMgYHRydWVgLCBgcmVjb2duaXplcmAgd2lsbCBiZSBpbiBlcnJvciByZWNvdmVyeVxyXG5cdCAqIG1vZGUuXHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCBkZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHNpbmdsZS10b2tlbiBpbnNlcnRpb24gaXMgdmlhYmxlIGJ5XHJcblx0ICogY2hlY2tpbmcgaWYgdGhlIGBMQSgxKWAgaW5wdXQgc3ltYm9sIGNvdWxkIGJlIHN1Y2Nlc3NmdWxseSBtYXRjaGVkXHJcblx0ICogaWYgaXQgd2VyZSBpbnN0ZWFkIHRoZSBgTEEoMilgIHN5bWJvbC4gSWYgdGhpcyBtZXRob2QgcmV0dXJuc1xyXG5cdCAqIGB0cnVlYCwgdGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIGluc2VydGluZyBhXHJcblx0ICogdG9rZW4gd2l0aCB0aGUgY29ycmVjdCB0eXBlIHRvIHByb2R1Y2UgdGhpcyBiZWhhdmlvci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgc2luZ2xlLXRva2VuIGluc2VydGlvbiBpcyBhIHZpYWJsZSByZWNvdmVyeVxyXG5cdCAqIHN0cmF0ZWd5IGZvciB0aGUgY3VycmVudCBtaXNtYXRjaGVkIGlucHV0LCBvdGhlcndpc2UgYGZhbHNlYFxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBzaW5nbGVUb2tlbkluc2VydGlvbihATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIpOiBib29sZWFuIHtcclxuXHRcdGxldCBjdXJyZW50U3ltYm9sVHlwZTogbnVtYmVyID0gcmVjb2duaXplci5pbnB1dFN0cmVhbS5MQSgxKTtcclxuXHRcdC8vIGlmIGN1cnJlbnQgdG9rZW4gaXMgY29uc2lzdGVudCB3aXRoIHdoYXQgY291bGQgY29tZSBhZnRlciBjdXJyZW50XHJcblx0XHQvLyBBVE4gc3RhdGUsIHRoZW4gd2Uga25vdyB3ZSdyZSBtaXNzaW5nIGEgdG9rZW47IGVycm9yIHJlY292ZXJ5XHJcblx0XHQvLyBpcyBmcmVlIHRvIGNvbmp1cmUgdXAgYW5kIGluc2VydCB0aGUgbWlzc2luZyB0b2tlblxyXG5cdFx0bGV0IGN1cnJlbnRTdGF0ZSA9IHJlY29nbml6ZXIuaW50ZXJwcmV0ZXIuYXRuLnN0YXRlc1tyZWNvZ25pemVyLnN0YXRlXTtcclxuXHRcdGxldCBuZXh0OiBBVE5TdGF0ZSA9IGN1cnJlbnRTdGF0ZS50cmFuc2l0aW9uKDApLnRhcmdldDtcclxuXHRcdGxldCBhdG46IEFUTiA9IHJlY29nbml6ZXIuaW50ZXJwcmV0ZXIuYXRuO1xyXG5cdFx0bGV0IGV4cGVjdGluZ0F0TEwyOiBJbnRlcnZhbFNldCA9IGF0bi5uZXh0VG9rZW5zKG5leHQsIFByZWRpY3Rpb25Db250ZXh0LmZyb21SdWxlQ29udGV4dChhdG4sIHJlY29nbml6ZXIuY29udGV4dCkpO1xyXG4vL1x0XHRjb25zb2xlLndhcm4oXCJMVCgyKSBzZXQ9XCIrZXhwZWN0aW5nQXRMTDIudG9TdHJpbmcocmVjb2duaXplci5nZXRUb2tlbk5hbWVzKCkpKTtcclxuXHRcdGlmIChleHBlY3RpbmdBdExMMi5jb250YWlucyhjdXJyZW50U3ltYm9sVHlwZSkpIHtcclxuXHRcdFx0dGhpcy5yZXBvcnRNaXNzaW5nVG9rZW4ocmVjb2duaXplcik7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgc2luZ2xlLXRva2VuIGRlbGV0aW9uIGlubGluZSBlcnJvciByZWNvdmVyeVxyXG5cdCAqIHN0cmF0ZWd5LiBJdCBpcyBjYWxsZWQgYnkge0BsaW5rICNyZWNvdmVySW5saW5lfSB0byBhdHRlbXB0IHRvIHJlY292ZXJcclxuXHQgKiBmcm9tIG1pc21hdGNoZWQgaW5wdXQuIElmIHRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZSBwYXJzZXIgYW5kIGVycm9yXHJcblx0ICogaGFuZGxlciBzdGF0ZSB3aWxsIG5vdCBoYXZlIGNoYW5nZWQuIElmIHRoaXMgbWV0aG9kIHJldHVybnMgbm9uLWB1bmRlZmluZWRgLFxyXG5cdCAqIGByZWNvZ25pemVyYCB3aWxsICpub3QqIGJlIGluIGVycm9yIHJlY292ZXJ5IG1vZGUgc2luY2UgdGhlXHJcblx0ICogcmV0dXJuZWQgdG9rZW4gd2FzIGEgc3VjY2Vzc2Z1bCBtYXRjaC5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSBzaW5nbGUtdG9rZW4gZGVsZXRpb24gaXMgc3VjY2Vzc2Z1bCwgdGhpcyBtZXRob2QgY2FsbHNcclxuXHQgKiB7QGxpbmsgI3JlcG9ydFVud2FudGVkVG9rZW59IHRvIHJlcG9ydCB0aGUgZXJyb3IsIGZvbGxvd2VkIGJ5XHJcblx0ICoge0BsaW5rIFBhcnNlciNjb25zdW1lfSB0byBhY3R1YWxseSBcImRlbGV0ZVwiIHRoZSBleHRyYW5lb3VzIHRva2VuLiBUaGVuLFxyXG5cdCAqIGJlZm9yZSByZXR1cm5pbmcge0BsaW5rICNyZXBvcnRNYXRjaH0gaXMgY2FsbGVkIHRvIHNpZ25hbCBhIHN1Y2Nlc3NmdWxcclxuXHQgKiBtYXRjaC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKiBAcmV0dXJucyB0aGUgc3VjY2Vzc2Z1bGx5IG1hdGNoZWQge0BsaW5rIFRva2VufSBpbnN0YW5jZSBpZiBzaW5nbGUtdG9rZW5cclxuXHQgKiBkZWxldGlvbiBzdWNjZXNzZnVsbHkgcmVjb3ZlcnMgZnJvbSB0aGUgbWlzbWF0Y2hlZCBpbnB1dCwgb3RoZXJ3aXNlXHJcblx0ICogYHVuZGVmaW5lZGBcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgc2luZ2xlVG9rZW5EZWxldGlvbihATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIpOiBUb2tlbiB8IHVuZGVmaW5lZCB7XHJcblx0XHRsZXQgbmV4dFRva2VuVHlwZTogbnVtYmVyID0gcmVjb2duaXplci5pbnB1dFN0cmVhbS5MQSgyKTtcclxuXHRcdGxldCBleHBlY3Rpbmc6IEludGVydmFsU2V0ID0gdGhpcy5nZXRFeHBlY3RlZFRva2VucyhyZWNvZ25pemVyKTtcclxuXHRcdGlmIChleHBlY3RpbmcuY29udGFpbnMobmV4dFRva2VuVHlwZSkpIHtcclxuXHRcdFx0dGhpcy5yZXBvcnRVbndhbnRlZFRva2VuKHJlY29nbml6ZXIpO1xyXG5cdFx0XHQvKlxyXG5cdFx0XHRTeXN0ZW0uZXJyLnByaW50bG4oXCJyZWNvdmVyRnJvbU1pc21hdGNoZWRUb2tlbiBkZWxldGluZyBcIitcclxuXHRcdFx0XHRcdFx0XHQgICAoKFRva2VuU3RyZWFtKXJlY29nbml6ZXIuaW5wdXRTdHJlYW0pLkxUKDEpK1xyXG5cdFx0XHRcdFx0XHRcdCAgIFwiIHNpbmNlIFwiKygoVG9rZW5TdHJlYW0pcmVjb2duaXplci5pbnB1dFN0cmVhbSkuTFQoMikrXHJcblx0XHRcdFx0XHRcdFx0ICAgXCIgaXMgd2hhdCB3ZSB3YW50XCIpO1xyXG5cdFx0XHQqL1xyXG5cdFx0XHRyZWNvZ25pemVyLmNvbnN1bWUoKTsgLy8gc2ltcGx5IGRlbGV0ZSBleHRyYSB0b2tlblxyXG5cdFx0XHQvLyB3ZSB3YW50IHRvIHJldHVybiB0aGUgdG9rZW4gd2UncmUgYWN0dWFsbHkgbWF0Y2hpbmdcclxuXHRcdFx0bGV0IG1hdGNoZWRTeW1ib2w6IFRva2VuID0gcmVjb2duaXplci5jdXJyZW50VG9rZW47XHJcblx0XHRcdHRoaXMucmVwb3J0TWF0Y2gocmVjb2duaXplcik7ICAvLyB3ZSBrbm93IGN1cnJlbnQgdG9rZW4gaXMgY29ycmVjdFxyXG5cdFx0XHRyZXR1cm4gbWF0Y2hlZFN5bWJvbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHQvKiogQ29uanVyZSB1cCBhIG1pc3NpbmcgdG9rZW4gZHVyaW5nIGVycm9yIHJlY292ZXJ5LlxyXG5cdCAqXHJcblx0ICogIFRoZSByZWNvZ25pemVyIGF0dGVtcHRzIHRvIHJlY292ZXIgZnJvbSBzaW5nbGUgbWlzc2luZ1xyXG5cdCAqICBzeW1ib2xzLiBCdXQsIGFjdGlvbnMgbWlnaHQgcmVmZXIgdG8gdGhhdCBtaXNzaW5nIHN5bWJvbC5cclxuXHQgKiAgRm9yIGV4YW1wbGUsIHg9SUQge2YoJHgpO30uIFRoZSBhY3Rpb24gY2xlYXJseSBhc3N1bWVzXHJcblx0ICogIHRoYXQgdGhlcmUgaGFzIGJlZW4gYW4gaWRlbnRpZmllciBtYXRjaGVkIHByZXZpb3VzbHkgYW5kIHRoYXRcclxuXHQgKiAgJHggcG9pbnRzIGF0IHRoYXQgdG9rZW4uIElmIHRoYXQgdG9rZW4gaXMgbWlzc2luZywgYnV0XHJcblx0ICogIHRoZSBuZXh0IHRva2VuIGluIHRoZSBzdHJlYW0gaXMgd2hhdCB3ZSB3YW50IHdlIGFzc3VtZSB0aGF0XHJcblx0ICogIHRoaXMgdG9rZW4gaXMgbWlzc2luZyBhbmQgd2Uga2VlcCBnb2luZy4gQmVjYXVzZSB3ZVxyXG5cdCAqICBoYXZlIHRvIHJldHVybiBzb21lIHRva2VuIHRvIHJlcGxhY2UgdGhlIG1pc3NpbmcgdG9rZW4sXHJcblx0ICogIHdlIGhhdmUgdG8gY29uanVyZSBvbmUgdXAuIFRoaXMgbWV0aG9kIGdpdmVzIHRoZSB1c2VyIGNvbnRyb2xcclxuXHQgKiAgb3ZlciB0aGUgdG9rZW5zIHJldHVybmVkIGZvciBtaXNzaW5nIHRva2Vucy4gTW9zdGx5LFxyXG5cdCAqICB5b3Ugd2lsbCB3YW50IHRvIGNyZWF0ZSBzb21ldGhpbmcgc3BlY2lhbCBmb3IgaWRlbnRpZmllclxyXG5cdCAqICB0b2tlbnMuIEZvciBsaXRlcmFscyBzdWNoIGFzICd7JyBhbmQgJywnLCB0aGUgZGVmYXVsdFxyXG5cdCAqICBhY3Rpb24gaW4gdGhlIHBhcnNlciBvciB0cmVlIHBhcnNlciB3b3Jrcy4gSXQgc2ltcGx5IGNyZWF0ZXNcclxuXHQgKiAgYSBDb21tb25Ub2tlbiBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZS4gVGhlIHRleHQgd2lsbCBiZSB0aGUgdG9rZW4uXHJcblx0ICogIElmIHlvdSBjaGFuZ2Ugd2hhdCB0b2tlbnMgbXVzdCBiZSBjcmVhdGVkIGJ5IHRoZSBsZXhlcixcclxuXHQgKiAgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB0b2tlbnMuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgZ2V0TWlzc2luZ1N5bWJvbChATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIpOiBUb2tlbiB7XHJcblx0XHRsZXQgY3VycmVudFN5bWJvbDogVG9rZW4gPSByZWNvZ25pemVyLmN1cnJlbnRUb2tlbjtcclxuXHRcdGxldCBleHBlY3Rpbmc6IEludGVydmFsU2V0ID0gdGhpcy5nZXRFeHBlY3RlZFRva2VucyhyZWNvZ25pemVyKTtcclxuXHRcdGxldCBleHBlY3RlZFRva2VuVHlwZTogbnVtYmVyID0gVG9rZW4uSU5WQUxJRF9UWVBFO1xyXG5cdFx0aWYgKCFleHBlY3RpbmcuaXNOaWwpIHtcclxuXHRcdFx0Ly8gZ2V0IGFueSBlbGVtZW50XHJcblx0XHRcdGV4cGVjdGVkVG9rZW5UeXBlID0gZXhwZWN0aW5nLm1pbkVsZW1lbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHRva2VuVGV4dDogc3RyaW5nO1xyXG5cdFx0aWYgKGV4cGVjdGVkVG9rZW5UeXBlID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0dG9rZW5UZXh0ID0gXCI8bWlzc2luZyBFT0Y+XCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0b2tlblRleHQgPSBcIjxtaXNzaW5nIFwiICsgcmVjb2duaXplci52b2NhYnVsYXJ5LmdldERpc3BsYXlOYW1lKGV4cGVjdGVkVG9rZW5UeXBlKSArIFwiPlwiO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGN1cnJlbnQ6IFRva2VuID0gY3VycmVudFN5bWJvbDtcclxuXHRcdGxldCBsb29rYmFjayA9IHJlY29nbml6ZXIuaW5wdXRTdHJlYW0udHJ5TFQoLTEpO1xyXG5cdFx0aWYgKGN1cnJlbnQudHlwZSA9PT0gVG9rZW4uRU9GICYmIGxvb2tiYWNrICE9IG51bGwpIHtcclxuXHRcdFx0Y3VycmVudCA9IGxvb2tiYWNrO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdFRva2VuKHJlY29nbml6ZXIuaW5wdXRTdHJlYW0udG9rZW5Tb3VyY2UsIGV4cGVjdGVkVG9rZW5UeXBlLCB0b2tlblRleHQsIGN1cnJlbnQpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGNvbnN0cnVjdFRva2VuKFxyXG5cdFx0dG9rZW5Tb3VyY2U6IFRva2VuU291cmNlLFxyXG5cdFx0ZXhwZWN0ZWRUb2tlblR5cGU6IG51bWJlcixcclxuXHRcdHRva2VuVGV4dDogc3RyaW5nLFxyXG5cdFx0Y3VycmVudDogVG9rZW4pOiBUb2tlbiB7XHJcblx0XHRsZXQgZmFjdG9yeTogVG9rZW5GYWN0b3J5ID0gdG9rZW5Tb3VyY2UudG9rZW5GYWN0b3J5O1xyXG5cdFx0bGV0IHggPSBjdXJyZW50LnRva2VuU291cmNlO1xyXG5cdFx0bGV0IHN0cmVhbSA9IHggPyB4LmlucHV0U3RyZWFtIDogdW5kZWZpbmVkO1xyXG5cclxuXHRcdHJldHVybiBmYWN0b3J5LmNyZWF0ZShcclxuXHRcdFx0eyBzb3VyY2U6IHRva2VuU291cmNlLCBzdHJlYW0gfSxcclxuXHRcdFx0ZXhwZWN0ZWRUb2tlblR5cGUsIHRva2VuVGV4dCxcclxuXHRcdFx0VG9rZW4uREVGQVVMVF9DSEFOTkVMLFxyXG5cdFx0XHQtMSwgLTEsXHJcblx0XHRcdGN1cnJlbnQubGluZSwgY3VycmVudC5jaGFyUG9zaXRpb25JbkxpbmUpO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgZ2V0RXhwZWN0ZWRUb2tlbnMoQE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyKTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0cmV0dXJuIHJlY29nbml6ZXIuZ2V0RXhwZWN0ZWRUb2tlbnMoKTtcclxuXHR9XHJcblxyXG5cdC8qKiBIb3cgc2hvdWxkIGEgdG9rZW4gYmUgZGlzcGxheWVkIGluIGFuIGVycm9yIG1lc3NhZ2U/IFRoZSBkZWZhdWx0XHJcblx0ICogIGlzIHRvIGRpc3BsYXkganVzdCB0aGUgdGV4dCwgYnV0IGR1cmluZyBkZXZlbG9wbWVudCB5b3UgbWlnaHRcclxuXHQgKiAgd2FudCB0byBoYXZlIGEgbG90IG9mIGluZm9ybWF0aW9uIHNwaXQgb3V0LiAgT3ZlcnJpZGUgaW4gdGhhdCBjYXNlXHJcblx0ICogIHRvIHVzZSB0LnRvU3RyaW5nKCkgKHdoaWNoLCBmb3IgQ29tbW9uVG9rZW4sIGR1bXBzIGV2ZXJ5dGhpbmcgYWJvdXRcclxuXHQgKiAgdGhlIHRva2VuKS4gVGhpcyBpcyBiZXR0ZXIgdGhhbiBmb3JjaW5nIHlvdSB0byBvdmVycmlkZSBhIG1ldGhvZCBpblxyXG5cdCAqICB5b3VyIHRva2VuIG9iamVjdHMgYmVjYXVzZSB5b3UgZG9uJ3QgaGF2ZSB0byBnbyBtb2RpZnkgeW91ciBsZXhlclxyXG5cdCAqICBzbyB0aGF0IGl0IGNyZWF0ZXMgYSBuZXcgSmF2YSB0eXBlLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBnZXRUb2tlbkVycm9yRGlzcGxheSh0OiBUb2tlbiB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XHJcblx0XHRpZiAoIXQpIHtcclxuXHRcdFx0cmV0dXJuIFwiPG5vIHRva2VuPlwiO1xyXG5cdFx0fVxyXG5cdFx0bGV0IHMgPSB0aGlzLmdldFN5bWJvbFRleHQodCk7XHJcblx0XHRpZiAoIXMpIHtcclxuXHRcdFx0aWYgKHRoaXMuZ2V0U3ltYm9sVHlwZSh0KSA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdFx0cyA9IFwiPEVPRj5cIjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzID0gYDwke3RoaXMuZ2V0U3ltYm9sVHlwZSh0KX0+YDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuZXNjYXBlV1NBbmRRdW90ZShzKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRTeW1ib2xUZXh0KEBOb3ROdWxsIHN5bWJvbDogVG9rZW4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHN5bWJvbC50ZXh0O1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldFN5bWJvbFR5cGUoQE5vdE51bGwgc3ltYm9sOiBUb2tlbik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gc3ltYm9sLnR5cGU7XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBlc2NhcGVXU0FuZFF1b3RlKEBOb3ROdWxsIHM6IHN0cmluZyk6IHN0cmluZyB7XHJcbi8vXHRcdGlmICggcz09bnVsbCApIHJldHVybiBzO1xyXG5cdFx0cyA9IHMucmVwbGFjZShcIlxcblwiLCBcIlxcXFxuXCIpO1xyXG5cdFx0cyA9IHMucmVwbGFjZShcIlxcclwiLCBcIlxcXFxyXCIpO1xyXG5cdFx0cyA9IHMucmVwbGFjZShcIlxcdFwiLCBcIlxcXFx0XCIpO1xyXG5cdFx0cmV0dXJuIFwiJ1wiICsgcyArIFwiJ1wiO1xyXG5cdH1cclxuXHJcblx0LyogIENvbXB1dGUgdGhlIGVycm9yIHJlY292ZXJ5IHNldCBmb3IgdGhlIGN1cnJlbnQgcnVsZS4gIER1cmluZ1xyXG5cdCAqICBydWxlIGludm9jYXRpb24sIHRoZSBwYXJzZXIgcHVzaGVzIHRoZSBzZXQgb2YgdG9rZW5zIHRoYXQgY2FuXHJcblx0ICogIGZvbGxvdyB0aGF0IHJ1bGUgcmVmZXJlbmNlIG9uIHRoZSBzdGFjazsgdGhpcyBhbW91bnRzIHRvXHJcblx0ICogIGNvbXB1dGluZyBGSVJTVCBvZiB3aGF0IGZvbGxvd3MgdGhlIHJ1bGUgcmVmZXJlbmNlIGluIHRoZVxyXG5cdCAqICBlbmNsb3NpbmcgcnVsZS4gU2VlIExpbmVhckFwcHJveGltYXRvci5GSVJTVCgpLlxyXG5cdCAqICBUaGlzIGxvY2FsIGZvbGxvdyBzZXQgb25seSBpbmNsdWRlcyB0b2tlbnNcclxuXHQgKiAgZnJvbSB3aXRoaW4gdGhlIHJ1bGU7IGkuZS4sIHRoZSBGSVJTVCBjb21wdXRhdGlvbiBkb25lIGJ5XHJcblx0ICogIEFOVExSIHN0b3BzIGF0IHRoZSBlbmQgb2YgYSBydWxlLlxyXG5cdCAqXHJcblx0ICogIEVYQU1QTEVcclxuXHQgKlxyXG5cdCAqICBXaGVuIHlvdSBmaW5kIGEgXCJubyB2aWFibGUgYWx0IGV4Y2VwdGlvblwiLCB0aGUgaW5wdXQgaXMgbm90XHJcblx0ICogIGNvbnNpc3RlbnQgd2l0aCBhbnkgb2YgdGhlIGFsdGVybmF0aXZlcyBmb3IgcnVsZSByLiAgVGhlIGJlc3RcclxuXHQgKiAgdGhpbmcgdG8gZG8gaXMgdG8gY29uc3VtZSB0b2tlbnMgdW50aWwgeW91IHNlZSBzb21ldGhpbmcgdGhhdFxyXG5cdCAqICBjYW4gbGVnYWxseSBmb2xsb3cgYSBjYWxsIHRvIHIgKm9yKiBhbnkgcnVsZSB0aGF0IGNhbGxlZCByLlxyXG5cdCAqICBZb3UgZG9uJ3Qgd2FudCB0aGUgZXhhY3Qgc2V0IG9mIHZpYWJsZSBuZXh0IHRva2VucyBiZWNhdXNlIHRoZVxyXG5cdCAqICBpbnB1dCBtaWdodCBqdXN0IGJlIG1pc3NpbmcgYSB0b2tlbi0teW91IG1pZ2h0IGNvbnN1bWUgdGhlXHJcblx0ICogIHJlc3Qgb2YgdGhlIGlucHV0IGxvb2tpbmcgZm9yIG9uZSBvZiB0aGUgbWlzc2luZyB0b2tlbnMuXHJcblx0ICpcclxuXHQgKiAgQ29uc2lkZXIgZ3JhbW1hcjpcclxuXHQgKlxyXG5cdCAqICBhIDogJ1snIGIgJ10nXHJcblx0ICogICAgfCAnKCcgYiAnKSdcclxuXHQgKiAgICA7XHJcblx0ICogIGIgOiBjICdeJyBJTlQgO1xyXG5cdCAqICBjIDogSURcclxuXHQgKiAgICB8IElOVFxyXG5cdCAqICAgIDtcclxuXHQgKlxyXG5cdCAqICBBdCBlYWNoIHJ1bGUgaW52b2NhdGlvbiwgdGhlIHNldCBvZiB0b2tlbnMgdGhhdCBjb3VsZCBmb2xsb3dcclxuXHQgKiAgdGhhdCBydWxlIGlzIHB1c2hlZCBvbiBhIHN0YWNrLiAgSGVyZSBhcmUgdGhlIHZhcmlvdXNcclxuXHQgKiAgY29udGV4dC1zZW5zaXRpdmUgZm9sbG93IHNldHM6XHJcblx0ICpcclxuXHQgKiAgRk9MTE9XKGIxX2luX2EpID0gRklSU1QoJ10nKSA9ICddJ1xyXG5cdCAqICBGT0xMT1coYjJfaW5fYSkgPSBGSVJTVCgnKScpID0gJyknXHJcblx0ICogIEZPTExPVyhjX2luX2IpID0gRklSU1QoJ14nKSA9ICdeJ1xyXG5cdCAqXHJcblx0ICogIFVwb24gZXJyb25lb3VzIGlucHV0IFwiW11cIiwgdGhlIGNhbGwgY2hhaW4gaXNcclxuXHQgKlxyXG5cdCAqICBhIC0+IGIgLT4gY1xyXG5cdCAqXHJcblx0ICogIGFuZCwgaGVuY2UsIHRoZSBmb2xsb3cgY29udGV4dCBzdGFjayBpczpcclxuXHQgKlxyXG5cdCAqICBkZXB0aCAgICAgZm9sbG93IHNldCAgICAgICBzdGFydCBvZiBydWxlIGV4ZWN1dGlvblxyXG5cdCAqICAgIDAgICAgICAgICA8RU9GPiAgICAgICAgICAgICAgICAgICAgYSAoZnJvbSBtYWluKCkpXHJcblx0ICogICAgMSAgICAgICAgICAnXScgICAgICAgICAgICAgICAgICAgICBiXHJcblx0ICogICAgMiAgICAgICAgICAnXicgICAgICAgICAgICAgICAgICAgICBjXHJcblx0ICpcclxuXHQgKiAgTm90aWNlIHRoYXQgJyknIGlzIG5vdCBpbmNsdWRlZCwgYmVjYXVzZSBiIHdvdWxkIGhhdmUgdG8gaGF2ZVxyXG5cdCAqICBiZWVuIGNhbGxlZCBmcm9tIGEgZGlmZmVyZW50IGNvbnRleHQgaW4gcnVsZSBhIGZvciAnKScgdG8gYmVcclxuXHQgKiAgaW5jbHVkZWQuXHJcblx0ICpcclxuXHQgKiAgRm9yIGVycm9yIHJlY292ZXJ5LCB3ZSBjYW5ub3QgY29uc2lkZXIgRk9MTE9XKGMpXHJcblx0ICogIChjb250ZXh0LXNlbnNpdGl2ZSBvciBvdGhlcndpc2UpLiAgV2UgbmVlZCB0aGUgY29tYmluZWQgc2V0IG9mXHJcblx0ICogIGFsbCBjb250ZXh0LXNlbnNpdGl2ZSBGT0xMT1cgc2V0cy0tdGhlIHNldCBvZiBhbGwgdG9rZW5zIHRoYXRcclxuXHQgKiAgY291bGQgZm9sbG93IGFueSByZWZlcmVuY2UgaW4gdGhlIGNhbGwgY2hhaW4uICBXZSBuZWVkIHRvXHJcblx0ICogIHJlc3luYyB0byBvbmUgb2YgdGhvc2UgdG9rZW5zLiAgTm90ZSB0aGF0IEZPTExPVyhjKT0nXicgYW5kIGlmXHJcblx0ICogIHdlIHJlc3luYydkIHRvIHRoYXQgdG9rZW4sIHdlJ2QgY29uc3VtZSB1bnRpbCBFT0YuICBXZSBuZWVkIHRvXHJcblx0ICogIHN5bmMgdG8gY29udGV4dC1zZW5zaXRpdmUgRk9MTE9XcyBmb3IgYSwgYiwgYW5kIGM6IHsnXScsJ14nfS5cclxuXHQgKiAgSW4gdGhpcyBjYXNlLCBmb3IgaW5wdXQgXCJbXVwiLCBMQSgxKSBpcyAnXScgYW5kIGluIHRoZSBzZXQsIHNvIHdlIHdvdWxkXHJcblx0ICogIG5vdCBjb25zdW1lIGFueXRoaW5nLiBBZnRlciBwcmludGluZyBhbiBlcnJvciwgcnVsZSBjIHdvdWxkXHJcblx0ICogIHJldHVybiBub3JtYWxseS4gIFJ1bGUgYiB3b3VsZCBub3QgZmluZCB0aGUgcmVxdWlyZWQgJ14nIHRob3VnaC5cclxuXHQgKiAgQXQgdGhpcyBwb2ludCwgaXQgZ2V0cyBhIG1pc21hdGNoZWQgdG9rZW4gZXJyb3IgYW5kXHJcblx0ICogIGV4Y2VwdGlvbiAoc2luY2UgTEEoMSkgaXMgbm90IGluIHRoZSB2aWFibGUgZm9sbG93aW5nIHRva2VuXHJcblx0ICogIHNldCkuICBUaGUgcnVsZSBleGNlcHRpb24gaGFuZGxlciB0cmllcyB0byByZWNvdmVyLCBidXQgZmluZHNcclxuXHQgKiAgdGhlIHNhbWUgcmVjb3Zlcnkgc2V0IGFuZCBkb2Vzbid0IGNvbnN1bWUgYW55dGhpbmcuICBSdWxlIGJcclxuXHQgKiAgZXhpdHMgbm9ybWFsbHkgcmV0dXJuaW5nIHRvIHJ1bGUgYS4gIE5vdyBpdCBmaW5kcyB0aGUgJ10nIChhbmRcclxuXHQgKiAgd2l0aCB0aGUgc3VjY2Vzc2Z1bCBtYXRjaCBleGl0cyBlcnJvclJlY292ZXJ5IG1vZGUpLlxyXG5cdCAqXHJcblx0ICogIFNvLCB5b3UgY2FuIHNlZSB0aGF0IHRoZSBwYXJzZXIgd2Fsa3MgdXAgdGhlIGNhbGwgY2hhaW4gbG9va2luZ1xyXG5cdCAqICBmb3IgdGhlIHRva2VuIHRoYXQgd2FzIGEgbWVtYmVyIG9mIHRoZSByZWNvdmVyeSBzZXQuXHJcblx0ICpcclxuXHQgKiAgRXJyb3JzIGFyZSBub3QgZ2VuZXJhdGVkIGluIGVycm9yUmVjb3ZlcnkgbW9kZS5cclxuXHQgKlxyXG5cdCAqICBBTlRMUidzIGVycm9yIHJlY292ZXJ5IG1lY2hhbmlzbSBpcyBiYXNlZCB1cG9uIG9yaWdpbmFsIGlkZWFzOlxyXG5cdCAqXHJcblx0ICogIFwiQWxnb3JpdGhtcyArIERhdGEgU3RydWN0dXJlcyA9IFByb2dyYW1zXCIgYnkgTmlrbGF1cyBXaXJ0aFxyXG5cdCAqXHJcblx0ICogIGFuZFxyXG5cdCAqXHJcblx0ICogIFwiQSBub3RlIG9uIGVycm9yIHJlY292ZXJ5IGluIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlcnNcIjpcclxuXHQgKiAgaHR0cDovL3BvcnRhbC5hY20ub3JnL2NpdGF0aW9uLmNmbT9pZD05NDc5MDIuOTQ3OTA1XHJcblx0ICpcclxuXHQgKiAgTGF0ZXIsIEpvc2VmIEdyb3NjaCBoYWQgc29tZSBnb29kIGlkZWFzOlxyXG5cdCAqXHJcblx0ICogIFwiRWZmaWNpZW50IGFuZCBDb21mb3J0YWJsZSBFcnJvciBSZWNvdmVyeSBpbiBSZWN1cnNpdmUgRGVzY2VudFxyXG5cdCAqICBQYXJzZXJzXCI6XHJcblx0ICogIGZ0cDovL3d3dy5jb2NvbGFiLmNvbS9wcm9kdWN0cy9jb2NrdGFpbC9kb2NhNC5wcy9lbGwucHMuemlwXHJcblx0ICpcclxuXHQgKiAgTGlrZSBHcm9zY2ggSSBpbXBsZW1lbnQgY29udGV4dC1zZW5zaXRpdmUgRk9MTE9XIHNldHMgdGhhdCBhcmUgY29tYmluZWRcclxuXHQgKiAgYXQgcnVuLXRpbWUgdXBvbiBlcnJvciB0byBhdm9pZCBvdmVyaGVhZCBkdXJpbmcgcGFyc2luZy5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBnZXRFcnJvclJlY292ZXJ5U2V0KEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlcik6IEludGVydmFsU2V0IHtcclxuXHRcdGxldCBhdG46IEFUTiA9IHJlY29nbml6ZXIuaW50ZXJwcmV0ZXIuYXRuO1xyXG5cdFx0bGV0IGN0eDogUnVsZUNvbnRleHQgfCB1bmRlZmluZWQgPSByZWNvZ25pemVyLmNvbnRleHQ7XHJcblx0XHRsZXQgcmVjb3ZlclNldDogSW50ZXJ2YWxTZXQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdHdoaWxlIChjdHggJiYgY3R4Lmludm9raW5nU3RhdGUgPj0gMCkge1xyXG5cdFx0XHQvLyBjb21wdXRlIHdoYXQgZm9sbG93cyB3aG8gaW52b2tlZCB1c1xyXG5cdFx0XHRsZXQgaW52b2tpbmdTdGF0ZTogQVROU3RhdGUgPSBhdG4uc3RhdGVzW2N0eC5pbnZva2luZ1N0YXRlXTtcclxuXHRcdFx0bGV0IHJ0ID0gaW52b2tpbmdTdGF0ZS50cmFuc2l0aW9uKDApIGFzIFJ1bGVUcmFuc2l0aW9uO1xyXG5cdFx0XHRsZXQgZm9sbG93OiBJbnRlcnZhbFNldCA9IGF0bi5uZXh0VG9rZW5zKHJ0LmZvbGxvd1N0YXRlKTtcclxuXHRcdFx0cmVjb3ZlclNldC5hZGRBbGwoZm9sbG93KTtcclxuXHRcdFx0Y3R4ID0gY3R4Ll9wYXJlbnQ7XHJcblx0XHR9XHJcblx0XHRyZWNvdmVyU2V0LnJlbW92ZShUb2tlbi5FUFNJTE9OKTtcclxuLy9cdFx0U3lzdGVtLm91dC5wcmludGxuKFwicmVjb3ZlciBzZXQgXCIrcmVjb3ZlclNldC50b1N0cmluZyhyZWNvZ25pemVyLmdldFRva2VuTmFtZXMoKSkpO1xyXG5cdFx0cmV0dXJuIHJlY292ZXJTZXQ7XHJcblx0fVxyXG5cclxuXHQvKiogQ29uc3VtZSB0b2tlbnMgdW50aWwgb25lIG1hdGNoZXMgdGhlIGdpdmVuIHRva2VuIHNldC4gKi9cclxuXHRwcm90ZWN0ZWQgY29uc3VtZVVudGlsKEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlciwgQE5vdE51bGwgc2V0OiBJbnRlcnZhbFNldCk6IHZvaWQge1xyXG4vL1x0XHRTeXN0ZW0uZXJyLnByaW50bG4oXCJjb25zdW1lVW50aWwoXCIrc2V0LnRvU3RyaW5nKHJlY29nbml6ZXIuZ2V0VG9rZW5OYW1lcygpKStcIilcIik7XHJcblx0XHRsZXQgdHR5cGU6IG51bWJlciA9IHJlY29nbml6ZXIuaW5wdXRTdHJlYW0uTEEoMSk7XHJcblx0XHR3aGlsZSAodHR5cGUgIT09IFRva2VuLkVPRiAmJiAhc2V0LmNvbnRhaW5zKHR0eXBlKSkge1xyXG5cdFx0XHQvL1N5c3RlbS5vdXQucHJpbnRsbihcImNvbnN1bWUgZHVyaW5nIHJlY292ZXIgTEEoMSk9XCIrZ2V0VG9rZW5OYW1lcygpW2lucHV0LkxBKDEpXSk7XHJcbi8vXHRcdFx0cmVjb2duaXplci5pbnB1dFN0cmVhbS5jb25zdW1lKCk7XHJcblx0XHRcdHJlY29nbml6ZXIuY29uc3VtZSgpO1xyXG5cdFx0XHR0dHlwZSA9IHJlY29nbml6ZXIuaW5wdXRTdHJlYW0uTEEoMSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0OS4yODU1MDU2LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBEZWZhdWx0RXJyb3JTdHJhdGVneSB9IGZyb20gXCIuL0RlZmF1bHRFcnJvclN0cmF0ZWd5XCI7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uIH0gZnJvbSBcIi4vSW5wdXRNaXNtYXRjaEV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9taXNjL1BhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5fSByZXNwb25kcyB0byBzeW50YXggZXJyb3JzXHJcbiAqIGJ5IGltbWVkaWF0ZWx5IGNhbmNlbGluZyB0aGUgcGFyc2Ugb3BlcmF0aW9uIHdpdGggYVxyXG4gKiB7QGxpbmsgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb259LiBUaGUgaW1wbGVtZW50YXRpb24gZW5zdXJlcyB0aGF0IHRoZVxyXG4gKiB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHQjZXhjZXB0aW9ufSBmaWVsZCBpcyBzZXQgZm9yIGFsbCBwYXJzZSB0cmVlIG5vZGVzXHJcbiAqIHRoYXQgd2VyZSBub3QgY29tcGxldGVkIHByaW9yIHRvIGVuY291bnRlcmluZyB0aGUgZXJyb3IuXHJcbiAqXHJcbiAqIFRoaXMgZXJyb3Igc3RyYXRlZ3kgaXMgdXNlZnVsIGluIHRoZSBmb2xsb3dpbmcgc2NlbmFyaW9zLlxyXG4gKlxyXG4gKiAqICoqVHdvLXN0YWdlIHBhcnNpbmc6KiogVGhpcyBlcnJvciBzdHJhdGVneSBhbGxvd3MgdGhlIGZpcnN0XHJcbiAqICAgc3RhZ2Ugb2YgdHdvLXN0YWdlIHBhcnNpbmcgdG8gaW1tZWRpYXRlbHkgdGVybWluYXRlIGlmIGFuIGVycm9yIGlzXHJcbiAqICAgZW5jb3VudGVyZWQsIGFuZCBpbW1lZGlhdGVseSBmYWxsIGJhY2sgdG8gdGhlIHNlY29uZCBzdGFnZS4gSW4gYWRkaXRpb24gdG9cclxuICogICBhdm9pZGluZyB3YXN0ZWQgd29yayBieSBhdHRlbXB0aW5nIHRvIHJlY292ZXIgZnJvbSBlcnJvcnMgaGVyZSwgdGhlIGVtcHR5XHJcbiAqICAgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIEJhaWxFcnJvclN0cmF0ZWd5I3N5bmN9IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBvZlxyXG4gKiAgIHRoZSBmaXJzdCBzdGFnZS5cclxuICogKiAqKlNpbGVudCB2YWxpZGF0aW9uOioqIFdoZW4gc3ludGF4IGVycm9ycyBhcmUgbm90IGJlaW5nXHJcbiAqICAgcmVwb3J0ZWQgb3IgbG9nZ2VkLCBhbmQgdGhlIHBhcnNlIHJlc3VsdCBpcyBzaW1wbHkgaWdub3JlZCBpZiBlcnJvcnMgb2NjdXIsXHJcbiAqICAgdGhlIHtAbGluayBCYWlsRXJyb3JTdHJhdGVneX0gYXZvaWRzIHdhc3Rpbmcgd29yayBvbiByZWNvdmVyaW5nIGZyb20gZXJyb3JzXHJcbiAqICAgd2hlbiB0aGUgcmVzdWx0IHdpbGwgYmUgaWdub3JlZCBlaXRoZXIgd2F5LlxyXG4gKlxyXG4gKiBgYGBcclxuICogbXlwYXJzZXIuZXJyb3JIYW5kbGVyID0gbmV3IEJhaWxFcnJvclN0cmF0ZWd5KCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAc2VlIFBhcnNlci5lcnJvckhhbmRsZXJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCYWlsRXJyb3JTdHJhdGVneSBleHRlbmRzIERlZmF1bHRFcnJvclN0cmF0ZWd5IHtcclxuXHQvKiogSW5zdGVhZCBvZiByZWNvdmVyaW5nIGZyb20gZXhjZXB0aW9uIGBlYCwgcmUtdGhyb3cgaXQgd3JhcHBlZFxyXG5cdCAqICBpbiBhIHtAbGluayBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbn0gc28gaXQgaXMgbm90IGNhdWdodCBieSB0aGVcclxuXHQgKiAgcnVsZSBmdW5jdGlvbiBjYXRjaGVzLiAgVXNlIHtAbGluayBFeGNlcHRpb24jZ2V0Q2F1c2UoKX0gdG8gZ2V0IHRoZVxyXG5cdCAqICBvcmlnaW5hbCB7QGxpbmsgUmVjb2duaXRpb25FeGNlcHRpb259LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZWNvdmVyKHJlY29nbml6ZXI6IFBhcnNlciwgZTogUmVjb2duaXRpb25FeGNlcHRpb24pOiB2b2lkIHtcclxuXHRcdGZvciAobGV0IGNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkID0gcmVjb2duaXplci5jb250ZXh0OyBjb250ZXh0OyBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQpIHtcclxuXHRcdFx0Y29udGV4dC5leGNlcHRpb24gPSBlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRocm93IG5ldyBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbihlKTtcclxuXHR9XHJcblxyXG5cdC8qKiBNYWtlIHN1cmUgd2UgZG9uJ3QgYXR0ZW1wdCB0byByZWNvdmVyIGlubGluZTsgaWYgdGhlIHBhcnNlclxyXG5cdCAqICBzdWNjZXNzZnVsbHkgcmVjb3ZlcnMsIGl0IHdvbid0IHRocm93IGFuIGV4Y2VwdGlvbi5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVjb3ZlcklubGluZShyZWNvZ25pemVyOiBQYXJzZXIpOiBUb2tlbiB7XHJcblx0XHRsZXQgZSA9IG5ldyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uKHJlY29nbml6ZXIpO1xyXG5cdFx0Zm9yIChsZXQgY29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQgPSByZWNvZ25pemVyLmNvbnRleHQ7IGNvbnRleHQ7IGNvbnRleHQgPSBjb250ZXh0LnBhcmVudCkge1xyXG5cdFx0XHRjb250ZXh0LmV4Y2VwdGlvbiA9IGU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhyb3cgbmV3IFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uKGUpO1xyXG5cdH1cclxuXHJcblx0LyoqIE1ha2Ugc3VyZSB3ZSBkb24ndCBhdHRlbXB0IHRvIHJlY292ZXIgZnJvbSBwcm9ibGVtcyBpbiBzdWJydWxlcy4gKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgc3luYyhyZWNvZ25pemVyOiBQYXJzZXIpOiB2b2lkIHtcclxuXHRcdC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUwLjA2NTkyOTctMDc6MDBcclxuXHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5pbXBvcnQgeyBJbnRTdHJlYW0gfSBmcm9tIFwiLi9JbnRTdHJlYW1cIjtcclxuXHJcbi8qKiBBIHNvdXJjZSBvZiBjaGFyYWN0ZXJzIGZvciBhbiBBTlRMUiBsZXhlci4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBDaGFyU3RyZWFtIGV4dGVuZHMgSW50U3RyZWFtIHtcclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0ZXh0IGZvciBhIHJhbmdlIG9mIGNoYXJhY3RlcnMgd2l0aGluIHRoaXMgaW5wdXRcclxuXHQgKiBzdHJlYW0uIFRoaXMgbWV0aG9kIGlzIGd1YXJhbnRlZWQgdG8gbm90IHRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgYGludGVydmFsYCBsaWVzIGVudGlyZWx5IHdpdGhpbiBhIG1hcmtlZCByYW5nZS4gRm9yIG1vcmVcclxuXHQgKiBpbmZvcm1hdGlvbiBhYm91dCBtYXJrZWQgcmFuZ2VzLCBzZWUge0BsaW5rIEludFN0cmVhbSNtYXJrfS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBpbnRlcnZhbCBhbiBpbnRlcnZhbCB3aXRoaW4gdGhlIHN0cmVhbVxyXG5cdCAqIEByZXR1cm5zIHRoZSB0ZXh0IG9mIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWxcclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgTnVsbFBvaW50ZXJFeGNlcHRpb24gaWYgYGludGVydmFsYCBpcyBgdW5kZWZpbmVkYFxyXG5cdCAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIGBpbnRlcnZhbC5hIDwgMGAsIG9yIGlmXHJcblx0ICogYGludGVydmFsLmIgPCBpbnRlcnZhbC5hIC0gMWAsIG9yIGlmIGBpbnRlcnZhbC5iYCBsaWVzIGF0IG9yXHJcblx0ICogcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJlYW1cclxuXHQgKiBAdGhyb3dzIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uIGlmIHRoZSBzdHJlYW0gZG9lcyBub3Qgc3VwcG9ydFxyXG5cdCAqIGdldHRpbmcgdGhlIHRleHQgb2YgdGhlIHNwZWNpZmllZCBpbnRlcnZhbFxyXG5cdCAqL1xyXG5cdC8vQE5vdE51bGxcclxuXHRnZXRUZXh0KC8qQE5vdE51bGwqLyBpbnRlcnZhbDogSW50ZXJ2YWwpOiBzdHJpbmc7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUxLjEzNDk4MjktMDc6MDBcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgZW51bSBEZXBlbmRlbnRzIHtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGVsZW1lbnQgaXMgZGVwZW5kZW50IHVwb24gdGhlIHNwZWNpZmllZCBydWxlLlxyXG5cdCAqL1xyXG5cdFNFTEYsXHJcblx0LyoqXHJcblx0ICogVGhlIGVsZW1lbnQgaXMgZGVwZW5kZW50IHVwb24gdGhlIHNldCBvZiB0aGUgc3BlY2lmaWVkIHJ1bGUncyBwYXJlbnRzXHJcblx0ICogKHJ1bGVzIHdoaWNoIGRpcmVjdGx5IHJlZmVyZW5jZSBpdCkuXHJcblx0ICovXHJcblx0UEFSRU5UUyxcclxuXHQvKipcclxuXHQgKiBUaGUgZWxlbWVudCBpcyBkZXBlbmRlbnQgdXBvbiB0aGUgc2V0IG9mIHRoZSBzcGVjaWZpZWQgcnVsZSdzIGNoaWxkcmVuXHJcblx0ICogKHJ1bGVzIHdoaWNoIGl0IGRpcmVjdGx5IHJlZmVyZW5jZXMpLlxyXG5cdCAqL1xyXG5cdENISUxEUkVOLFxyXG5cdC8qKlxyXG5cdCAqIFRoZSBlbGVtZW50IGlzIGRlcGVuZGVudCB1cG9uIHRoZSBzZXQgb2YgdGhlIHNwZWNpZmllZCBydWxlJ3MgYW5jZXN0b3JzXHJcblx0ICogKHRoZSB0cmFuc2l0aXZlIGNsb3N1cmUgb2YgYFBBUkVOVFNgIHJ1bGVzKS5cclxuXHQgKi9cclxuXHRBTkNFU1RPUlMsXHJcblx0LyoqXHJcblx0ICogVGhlIGVsZW1lbnQgaXMgZGVwZW5kZW50IHVwb24gdGhlIHNldCBvZiB0aGUgc3BlY2lmaWVkIHJ1bGUncyBkZXNjZW5kYW50c1xyXG5cdCAqICh0aGUgdHJhbnNpdGl2ZSBjbG9zdXJlIG9mIGBDSElMRFJFTmAgcnVsZXMpLlxyXG5cdCAqL1xyXG5cdERFU0NFTkRBTlRTLFxyXG5cdC8qKlxyXG5cdCAqIFRoZSBlbGVtZW50IGlzIGRlcGVuZGVudCB1cG9uIHRoZSBzZXQgb2YgdGhlIHNwZWNpZmllZCBydWxlJ3Mgc2libGluZ3NcclxuXHQgKiAodGhlIHVuaW9uIG9mIGBDSElMRFJFTmAgb2YgaXRzIGBQQVJFTlRTYCkuXHJcblx0ICovXHJcblx0U0lCTElOR1MsXHJcblx0LyoqXHJcblx0ICogVGhlIGVsZW1lbnQgaXMgZGVwZW5kZW50IHVwb24gdGhlIHNldCBvZiB0aGUgc3BlY2lmaWVkIHJ1bGUncyBwcmVjZWVkaW5nXHJcblx0ICogc2libGluZ3MgKHRoZSB1bmlvbiBvZiBgQ0hJTERSRU5gIG9mIGl0cyBgUEFSRU5UU2Agd2hpY2hcclxuXHQgKiBhcHBlYXIgYmVmb3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBydWxlKS5cclxuXHQgKi9cclxuXHRQUkVDRUVESU5HX1NJQkxJTkdTLFxyXG5cdC8qKlxyXG5cdCAqIFRoZSBlbGVtZW50IGlzIGRlcGVuZGVudCB1cG9uIHRoZSBzZXQgb2YgdGhlIHNwZWNpZmllZCBydWxlJ3MgZm9sbG93aW5nXHJcblx0ICogc2libGluZ3MgKHRoZSB1bmlvbiBvZiBgQ0hJTERSRU5gIG9mIGl0cyBgUEFSRU5UU2Agd2hpY2hcclxuXHQgKiBhcHBlYXIgYWZ0ZXIgYSByZWZlcmVuY2UgdG8gdGhlIHJ1bGUpLlxyXG5cdCAqL1xyXG5cdEZPTExPV0lOR19TSUJMSU5HUyxcclxuXHQvKipcclxuXHQgKiBUaGUgZWxlbWVudCBpcyBkZXBlbmRlbnQgdXBvbiB0aGUgc2V0IG9mIHRoZSBzcGVjaWZpZWQgcnVsZSdzIHByZWNlZWRpbmdcclxuXHQgKiBlbGVtZW50cyAocnVsZXMgd2hpY2ggbWlnaHQgZW5kIGJlZm9yZSB0aGUgc3RhcnQgb2YgdGhlIHNwZWNpZmllZCBydWxlXHJcblx0ICogd2hpbGUgcGFyc2luZykuIFRoaXMgaXMgY2FsY3VsYXRlZCBieSB0YWtpbmcgdGhlXHJcblx0ICogYFBSRUNFRURJTkdfU0lCTElOR1NgIG9mIHRoZSBydWxlIGFuZCBlYWNoIG9mIGl0c1xyXG5cdCAqIGBBTkNFU1RPUlNgLCBhbG9uZyB3aXRoIHRoZSBgREVTQ0VOREFOVFNgIG9mIHRob3NlXHJcblx0ICogZWxlbWVudHMuXHJcblx0ICovXHJcblx0UFJFQ0VFRElORyxcclxuXHQvKipcclxuXHQgKiBUaGUgZWxlbWVudCBpcyBkZXBlbmRlbnQgdXBvbiB0aGUgc2V0IG9mIHRoZSBzcGVjaWZpZWQgcnVsZSdzIGZvbGxvd2luZ1xyXG5cdCAqIGVsZW1lbnRzIChydWxlcyB3aGljaCBtaWdodCBzdGFydCBhZnRlciB0aGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgcnVsZVxyXG5cdCAqIHdoaWxlIHBhcnNpbmcpLiBUaGlzIGlzIGNhbGN1bGF0ZWQgYnkgdGFraW5nIHRoZVxyXG5cdCAqIGBGT0xMT1dJTkdfU0lCTElOR1NgIG9mIHRoZSBydWxlIGFuZCBlYWNoIG9mIGl0c1xyXG5cdCAqIGBBTkNFU1RPUlNgLCBhbG9uZyB3aXRoIHRoZSBgREVTQ0VOREFOVFNgIG9mIHRob3NlXHJcblx0ICogZWxlbWVudHMuXHJcblx0ICovXHJcblx0Rk9MTE9XSU5HLFxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1MS4yMTMzNjg1LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5Db25maWcgfSBmcm9tIFwiLi9hdG4vQVROQ29uZmlnXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuL2F0bi9BVE5Db25maWdTZXRcIjtcclxuaW1wb3J0IHsgQml0U2V0IH0gZnJvbSBcIi4vbWlzYy9CaXRTZXRcIjtcclxuaW1wb3J0IHsgREZBIH0gZnJvbSBcIi4vZGZhL0RGQVwiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi9QYXJzZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VyRXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL1BhcnNlckVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4vUmVjb2duaXplclwiO1xyXG5pbXBvcnQgeyBTaW11bGF0b3JTdGF0ZSB9IGZyb20gXCIuL2F0bi9TaW11bGF0b3JTdGF0ZVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlLCBOb3ROdWxsIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBBTlRMUkVycm9yTGlzdGVuZXJ9IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5XHJcbiAqIGNlcnRhaW4gcG90ZW50aWFsIGNvcnJlY3RuZXNzIGFuZCBwZXJmb3JtYW5jZSBwcm9ibGVtcyBpbiBncmFtbWFycy4gXCJSZXBvcnRzXCJcclxuICogYXJlIG1hZGUgYnkgY2FsbGluZyB7QGxpbmsgUGFyc2VyI25vdGlmeUVycm9yTGlzdGVuZXJzfSB3aXRoIHRoZSBhcHByb3ByaWF0ZVxyXG4gKiBtZXNzYWdlLlxyXG4gKlxyXG4gKiAqICoqQW1iaWd1aXRpZXMqKjogVGhlc2UgYXJlIGNhc2VzIHdoZXJlIG1vcmUgdGhhbiBvbmUgcGF0aCB0aHJvdWdoIHRoZVxyXG4gKiAgIGdyYW1tYXIgY2FuIG1hdGNoIHRoZSBpbnB1dC5cclxuICogKiAqKldlYWsgY29udGV4dCBzZW5zaXRpdml0eSoqOiBUaGVzZSBhcmUgY2FzZXMgd2hlcmUgZnVsbC1jb250ZXh0XHJcbiAqICAgcHJlZGljdGlvbiByZXNvbHZlZCBhbiBTTEwgY29uZmxpY3QgdG8gYSB1bmlxdWUgYWx0ZXJuYXRpdmUgd2hpY2ggZXF1YWxlZCB0aGVcclxuICogICBtaW5pbXVtIGFsdGVybmF0aXZlIG9mIHRoZSBTTEwgY29uZmxpY3QuXHJcbiAqICogKipTdHJvbmcgKGZvcmNlZCkgY29udGV4dCBzZW5zaXRpdml0eSoqOiBUaGVzZSBhcmUgY2FzZXMgd2hlcmUgdGhlXHJcbiAqICAgZnVsbC1jb250ZXh0IHByZWRpY3Rpb24gcmVzb2x2ZWQgYW4gU0xMIGNvbmZsaWN0IHRvIGEgdW5pcXVlIGFsdGVybmF0aXZlLFxyXG4gKiAgICphbmQqIHRoZSBtaW5pbXVtIGFsdGVybmF0aXZlIG9mIHRoZSBTTEwgY29uZmxpY3Qgd2FzIGZvdW5kIHRvIG5vdCBiZVxyXG4gKiAgIGEgdHJ1bHkgdmlhYmxlIGFsdGVybmF0aXZlLiBUd28tc3RhZ2UgcGFyc2luZyBjYW5ub3QgYmUgdXNlZCBmb3IgaW5wdXRzIHdoZXJlXHJcbiAqICAgdGhpcyBzaXR1YXRpb24gb2NjdXJzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIgaW1wbGVtZW50cyBQYXJzZXJFcnJvckxpc3RlbmVyIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIERpYWdub3N0aWNFcnJvckxpc3RlbmVyfSwgc3BlY2lmeWluZ1xyXG5cdCAqIHdoZXRoZXIgYWxsIGFtYmlndWl0aWVzIG9yIG9ubHkgZXhhY3QgYW1iaWd1aXRpZXMgYXJlIHJlcG9ydGVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGV4YWN0T25seSBgdHJ1ZWAgdG8gcmVwb3J0IG9ubHkgZXhhY3QgYW1iaWd1aXRpZXMsIG90aGVyd2lzZVxyXG5cdCAqIGBmYWxzZWAgdG8gcmVwb3J0IGFsbCBhbWJpZ3VpdGllcy4gIERlZmF1bHRzIHRvIHRydWUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGV4YWN0T25seTogYm9vbGVhbiA9IHRydWUpIHtcclxuXHRcdHRoaXMuZXhhY3RPbmx5ID0gZXhhY3RPbmx5O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHN5bnRheEVycm9yPFQgZXh0ZW5kcyBUb2tlbj4oXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdHJlY29nbml6ZXI6IFJlY29nbml6ZXI8VCwgYW55PixcclxuXHRcdG9mZmVuZGluZ1N5bWJvbDogVCB8IHVuZGVmaW5lZCxcclxuXHRcdGxpbmU6IG51bWJlcixcclxuXHRcdGNoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyLFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRtc2c6IHN0cmluZyxcclxuXHRcdGU6IFJlY29nbml0aW9uRXhjZXB0aW9uIHwgdW5kZWZpbmVkKTogdm9pZFxyXG5cdHtcclxuXHRcdC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZXBvcnRBbWJpZ3VpdHkoXHJcblx0XHRATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIsXHJcblx0XHRATm90TnVsbCBkZmE6IERGQSxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyLFxyXG5cdFx0ZXhhY3Q6IGJvb2xlYW4sXHJcblx0XHRhbWJpZ0FsdHM6IEJpdFNldCB8IHVuZGVmaW5lZCxcclxuXHRcdEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuZXhhY3RPbmx5ICYmICFleGFjdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGRlY2lzaW9uOiBzdHJpbmcgPSB0aGlzLmdldERlY2lzaW9uRGVzY3JpcHRpb24ocmVjb2duaXplciwgZGZhKTtcclxuXHRcdGxldCBjb25mbGljdGluZ0FsdHM6IEJpdFNldCA9IHRoaXMuZ2V0Q29uZmxpY3RpbmdBbHRzKGFtYmlnQWx0cywgY29uZmlncyk7XHJcblx0XHRsZXQgdGV4dDogc3RyaW5nID0gcmVjb2duaXplci5pbnB1dFN0cmVhbS5nZXRUZXh0KEludGVydmFsLm9mKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkpO1xyXG5cdFx0bGV0IG1lc3NhZ2U6IHN0cmluZyA9IGByZXBvcnRBbWJpZ3VpdHkgZD0ke2RlY2lzaW9ufTogYW1iaWdBbHRzPSR7Y29uZmxpY3RpbmdBbHRzfSwgaW5wdXQ9JyR7dGV4dH0nYDtcclxuXHRcdHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMobWVzc2FnZSk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KFxyXG5cdFx0QE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyLFxyXG5cdFx0QE5vdE51bGwgZGZhOiBERkEsXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcixcclxuXHRcdGNvbmZsaWN0aW5nQWx0czogQml0U2V0IHwgdW5kZWZpbmVkLFxyXG5cdFx0QE5vdE51bGwgY29uZmxpY3RTdGF0ZTogU2ltdWxhdG9yU3RhdGUpOiB2b2lkIHtcclxuXHRcdGxldCBmb3JtYXQ6IHN0cmluZyA9IFwicmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0IGQ9JXMsIGlucHV0PSclcydcIjtcclxuXHRcdGxldCBkZWNpc2lvbjogc3RyaW5nID0gdGhpcy5nZXREZWNpc2lvbkRlc2NyaXB0aW9uKHJlY29nbml6ZXIsIGRmYSk7XHJcblx0XHRsZXQgdGV4dDogc3RyaW5nID0gcmVjb2duaXplci5pbnB1dFN0cmVhbS5nZXRUZXh0KEludGVydmFsLm9mKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkpO1xyXG5cdFx0bGV0IG1lc3NhZ2U6IHN0cmluZyA9IGByZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQgZD0ke2RlY2lzaW9ufSwgaW5wdXQ9JyR7dGV4dH0nYDtcclxuXHRcdHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMobWVzc2FnZSk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KFxyXG5cdFx0QE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyLFxyXG5cdFx0QE5vdE51bGwgZGZhOiBERkEsXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcixcclxuXHRcdHByZWRpY3Rpb246IG51bWJlcixcclxuXHRcdEBOb3ROdWxsIGFjY2VwdFN0YXRlOiBTaW11bGF0b3JTdGF0ZSk6IHZvaWQge1xyXG5cdFx0bGV0IGZvcm1hdDogc3RyaW5nID0gXCJyZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkgZD0lcywgaW5wdXQ9JyVzJ1wiO1xyXG5cdFx0bGV0IGRlY2lzaW9uOiBzdHJpbmcgPSB0aGlzLmdldERlY2lzaW9uRGVzY3JpcHRpb24ocmVjb2duaXplciwgZGZhKTtcclxuXHRcdGxldCB0ZXh0OiBzdHJpbmcgPSByZWNvZ25pemVyLmlucHV0U3RyZWFtLmdldFRleHQoSW50ZXJ2YWwub2Yoc3RhcnRJbmRleCwgc3RvcEluZGV4KSk7XHJcblx0XHRsZXQgbWVzc2FnZTogc3RyaW5nID0gYHJlcG9ydENvbnRleHRTZW5zaXRpdml0eSBkPSR7ZGVjaXNpb259LCBpbnB1dD0nJHt0ZXh0fSdgO1xyXG5cdFx0cmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtZXNzYWdlKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXREZWNpc2lvbkRlc2NyaXB0aW9uKFxyXG5cdFx0QE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyLFxyXG5cdFx0QE5vdE51bGwgZGZhOiBERkEpOiBzdHJpbmcge1xyXG5cdFx0bGV0IGRlY2lzaW9uOiBudW1iZXIgPSBkZmEuZGVjaXNpb247XHJcblx0XHRsZXQgcnVsZUluZGV4OiBudW1iZXIgPSBkZmEuYXRuU3RhcnRTdGF0ZS5ydWxlSW5kZXg7XHJcblxyXG5cdFx0bGV0IHJ1bGVOYW1lczogc3RyaW5nW10gPSByZWNvZ25pemVyLnJ1bGVOYW1lcztcclxuXHRcdGlmIChydWxlSW5kZXggPCAwIHx8IHJ1bGVJbmRleCA+PSBydWxlTmFtZXMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBkZWNpc2lvbi50b1N0cmluZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBydWxlTmFtZTogc3RyaW5nID0gcnVsZU5hbWVzW3J1bGVJbmRleF07XHJcblx0XHRpZiAoIXJ1bGVOYW1lKSB7XHJcblx0XHRcdHJldHVybiBkZWNpc2lvbi50b1N0cmluZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBgJHtkZWNpc2lvbn0gKCR7cnVsZU5hbWV9KWA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wdXRlcyB0aGUgc2V0IG9mIGNvbmZsaWN0aW5nIG9yIGFtYmlndW91cyBhbHRlcm5hdGl2ZXMgZnJvbSBhXHJcblx0ICogY29uZmlndXJhdGlvbiBzZXQsIGlmIHRoYXQgaW5mb3JtYXRpb24gd2FzIG5vdCBhbHJlYWR5IHByb3ZpZGVkIGJ5IHRoZVxyXG5cdCAqIHBhcnNlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZXBvcnRlZEFsdHMgVGhlIHNldCBvZiBjb25mbGljdGluZyBvciBhbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzLCBhc1xyXG5cdCAqIHJlcG9ydGVkIGJ5IHRoZSBwYXJzZXIuXHJcblx0ICogQHBhcmFtIGNvbmZpZ3MgVGhlIGNvbmZsaWN0aW5nIG9yIGFtYmlndW91cyBjb25maWd1cmF0aW9uIHNldC5cclxuXHQgKiBAcmV0dXJucyBSZXR1cm5zIGByZXBvcnRlZEFsdHNgIGlmIGl0IGlzIG5vdCBgdW5kZWZpbmVkYCwgb3RoZXJ3aXNlXHJcblx0ICogcmV0dXJucyB0aGUgc2V0IG9mIGFsdGVybmF0aXZlcyByZXByZXNlbnRlZCBpbiBgY29uZmlnc2AuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgZ2V0Q29uZmxpY3RpbmdBbHRzKHJlcG9ydGVkQWx0czogQml0U2V0IHwgdW5kZWZpbmVkLCBATm90TnVsbCBjb25maWdzOiBBVE5Db25maWdTZXQpOiBCaXRTZXQge1xyXG5cdFx0aWYgKHJlcG9ydGVkQWx0cyAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiByZXBvcnRlZEFsdHM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJlc3VsdDogQml0U2V0ID0gbmV3IEJpdFNldCgpO1xyXG5cdFx0Zm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpIHtcclxuXHRcdFx0cmVzdWx0LnNldChjb25maWcuYWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTEuOTk1NDU2Ni0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vYXRuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5UeXBlIH0gZnJvbSBcIi4vYXRuL0FUTlR5cGVcIjtcclxuaW1wb3J0IHsgQ2hhclN0cmVhbSB9IGZyb20gXCIuL0NoYXJTdHJlYW1cIjtcclxuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMZXhlckFUTlNpbXVsYXRvciB9IGZyb20gXCIuL2F0bi9MZXhlckFUTlNpbXVsYXRvclwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVm9jYWJ1bGFyeSB9IGZyb20gXCIuL1ZvY2FidWxhcnlcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBMZXhlckludGVycHJldGVyIGV4dGVuZHMgTGV4ZXIge1xyXG5cdHByb3RlY3RlZCBfZ3JhbW1hckZpbGVOYW1lOiBzdHJpbmc7XHJcblx0cHJvdGVjdGVkIF9hdG46IEFUTjtcclxuXHJcblx0cHJvdGVjdGVkIF9ydWxlTmFtZXM6IHN0cmluZ1tdO1xyXG5cdHByb3RlY3RlZCBfY2hhbm5lbE5hbWVzOiBzdHJpbmdbXTtcclxuXHRwcm90ZWN0ZWQgX21vZGVOYW1lczogc3RyaW5nW107XHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIF92b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5O1xyXG5cclxuXHRjb25zdHJ1Y3RvcihncmFtbWFyRmlsZU5hbWU6IHN0cmluZywgQE5vdE51bGwgdm9jYWJ1bGFyeTogVm9jYWJ1bGFyeSwgcnVsZU5hbWVzOiBzdHJpbmdbXSwgY2hhbm5lbE5hbWVzOiBzdHJpbmdbXSwgbW9kZU5hbWVzOiBzdHJpbmdbXSwgYXRuOiBBVE4sIGlucHV0OiBDaGFyU3RyZWFtKSB7XHJcblx0XHRzdXBlcihpbnB1dCk7XHJcblxyXG5cdFx0aWYgKGF0bi5ncmFtbWFyVHlwZSAhPT0gQVROVHlwZS5MRVhFUikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb246IFRoZSBBVE4gbXVzdCBiZSBhIGxleGVyIEFUTi5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZ3JhbW1hckZpbGVOYW1lID0gZ3JhbW1hckZpbGVOYW1lO1xyXG5cdFx0dGhpcy5fYXRuID0gYXRuO1xyXG5cclxuXHRcdHRoaXMuX3J1bGVOYW1lcyA9IHJ1bGVOYW1lcy5zbGljZSgwKTtcclxuXHRcdHRoaXMuX2NoYW5uZWxOYW1lcyA9IGNoYW5uZWxOYW1lcy5zbGljZSgwKTtcclxuXHRcdHRoaXMuX21vZGVOYW1lcyA9IG1vZGVOYW1lcy5zbGljZSgwKTtcclxuXHRcdHRoaXMuX3ZvY2FidWxhcnkgPSB2b2NhYnVsYXJ5O1xyXG5cdFx0dGhpcy5faW50ZXJwID0gbmV3IExleGVyQVROU2ltdWxhdG9yKGF0biwgdGhpcyk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgYXRuKCk6IEFUTiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYXRuO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGdyYW1tYXJGaWxlTmFtZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2dyYW1tYXJGaWxlTmFtZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBydWxlTmFtZXMoKTogc3RyaW5nW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3J1bGVOYW1lcztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBjaGFubmVsTmFtZXMoKTogc3RyaW5nW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NoYW5uZWxOYW1lcztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBtb2RlTmFtZXMoKTogc3RyaW5nW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX21vZGVOYW1lcztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCB2b2NhYnVsYXJ5KCk6IFZvY2FidWxhcnkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3ZvY2FidWxhcnk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Mi45NDcxODYzLTA3OjAwXHJcbmltcG9ydCB7IEFOVExSRXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL0FOVExSRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBBVE5Db25maWdTZXQgfSBmcm9tIFwiLi9hdG4vQVROQ29uZmlnU2V0XCI7XHJcbmltcG9ydCB7IEJpdFNldCB9IGZyb20gXCIuL21pc2MvQml0U2V0XCI7XHJcbmltcG9ydCB7IERGQSB9IGZyb20gXCIuL2RmYS9ERkFcIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFNpbXVsYXRvclN0YXRlIH0gZnJvbSBcIi4vYXRuL1NpbXVsYXRvclN0YXRlXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0ICogYXMgU3R1YnMgZnJvbSBcIi4vbWlzYy9TdHVic1wiO1xyXG5pbXBvcnQgKiBhcyBFeGNlcHRpb24gZnJvbSBcIi4vUmVjb2duaXRpb25FeGNlcHRpb25cIjtcclxuXHJcbi8qKiBIb3cgdG8gZW1pdCByZWNvZ25pdGlvbiBlcnJvcnMgZm9yIHBhcnNlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlckVycm9yTGlzdGVuZXIgZXh0ZW5kcyBBTlRMUkVycm9yTGlzdGVuZXI8VG9rZW4+IHtcclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIHBhcnNlciB3aGVuIGEgZnVsbC1jb250ZXh0IHByZWRpY3Rpb25cclxuXHQgKiByZXN1bHRzIGluIGFuIGFtYmlndWl0eS5cclxuXHQgKlxyXG5cdCAqIEVhY2ggZnVsbC1jb250ZXh0IHByZWRpY3Rpb24gd2hpY2ggZG9lcyBub3QgcmVzdWx0IGluIGEgc3ludGF4IGVycm9yXHJcblx0ICogd2lsbCBjYWxsIGVpdGhlciB7QGxpbmsgI3JlcG9ydENvbnRleHRTZW5zaXRpdml0eX0gb3JcclxuXHQgKiB7QGxpbmsgI3JlcG9ydEFtYmlndWl0eX0uXHJcblx0ICpcclxuXHQgKiBXaGVuIGBhbWJpZ0FsdHNgIGlzIG5vdCBgdW5kZWZpbmVkYCwgaXQgY29udGFpbnMgdGhlIHNldCBvZiBwb3RlbnRpYWxseVxyXG5cdCAqIHZpYWJsZSBhbHRlcm5hdGl2ZXMgaWRlbnRpZmllZCBieSB0aGUgcHJlZGljdGlvbiBhbGdvcml0aG0uIFdoZW5cclxuXHQgKiBgYW1iaWdBbHRzYCBpcyBgdW5kZWZpbmVkYCwgdXNlXHJcblx0ICoge0BsaW5rIEFUTkNvbmZpZ1NldCNnZXRSZXByZXNlbnRlZEFsdGVybmF0aXZlc30gdG8gb2J0YWluIHRoZSByZXByZXNlbnRlZFxyXG5cdCAqIGFsdGVybmF0aXZlcyBmcm9tIHRoZSBgY29uZmlnc2AgYXJndW1lbnQuXHJcblx0ICpcclxuXHQgKiBXaGVuIGBleGFjdGAgaXMgYHRydWVgLCAqYWxsKiBvZiB0aGUgcG90ZW50aWFsbHlcclxuXHQgKiB2aWFibGUgYWx0ZXJuYXRpdmVzIGFyZSB0cnVseSB2aWFibGUsIGkuZS4gdGhpcyBpcyByZXBvcnRpbmcgYW4gZXhhY3RcclxuXHQgKiBhbWJpZ3VpdHkuIFdoZW4gYGV4YWN0YCBpcyBgZmFsc2VgLCAqYXQgbGVhc3QgdHdvKiBvZlxyXG5cdCAqIHRoZSBwb3RlbnRpYWxseSB2aWFibGUgYWx0ZXJuYXRpdmVzIGFyZSB2aWFibGUgZm9yIHRoZSBjdXJyZW50IGlucHV0LCBidXRcclxuXHQgKiB0aGUgcHJlZGljdGlvbiBhbGdvcml0aG0gdGVybWluYXRlZCBhcyBzb29uIGFzIGl0IGRldGVybWluZWQgdGhhdCBhdFxyXG5cdCAqIGxlYXN0IHRoZSAqbWluaW11bSogcG90ZW50aWFsbHkgdmlhYmxlIGFsdGVybmF0aXZlIGlzIHRydWx5XHJcblx0ICogdmlhYmxlLlxyXG5cdCAqXHJcblx0ICogV2hlbiB0aGUge0BsaW5rIFByZWRpY3Rpb25Nb2RlI0xMX0VYQUNUX0FNQklHX0RFVEVDVElPTn0gcHJlZGljdGlvblxyXG5cdCAqIG1vZGUgaXMgdXNlZCwgdGhlIHBhcnNlciBpcyByZXF1aXJlZCB0byBpZGVudGlmeSBleGFjdCBhbWJpZ3VpdGllcyBzb1xyXG5cdCAqIGBleGFjdGAgd2lsbCBhbHdheXMgYmUgYHRydWVgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxyXG5cdCAqIEBwYXJhbSBkZmEgdGhlIERGQSBmb3IgdGhlIGN1cnJlbnQgZGVjaXNpb25cclxuXHQgKiBAcGFyYW0gc3RhcnRJbmRleCB0aGUgaW5wdXQgaW5kZXggd2hlcmUgdGhlIGRlY2lzaW9uIHN0YXJ0ZWRcclxuXHQgKiBAcGFyYW0gc3RvcEluZGV4IHRoZSBpbnB1dCBpbnB1dCB3aGVyZSB0aGUgYW1iaWd1aXR5IHdhcyBpZGVudGlmaWVkXHJcblx0ICogQHBhcmFtIGV4YWN0IGB0cnVlYCBpZiB0aGUgYW1iaWd1aXR5IGlzIGV4YWN0bHkga25vd24sIG90aGVyd2lzZVxyXG5cdCAqIGBmYWxzZWAuIFRoaXMgaXMgYWx3YXlzIGB0cnVlYCB3aGVuXHJcblx0ICoge0BsaW5rIFByZWRpY3Rpb25Nb2RlI0xMX0VYQUNUX0FNQklHX0RFVEVDVElPTn0gaXMgdXNlZC5cclxuXHQgKiBAcGFyYW0gYW1iaWdBbHRzIHRoZSBwb3RlbnRpYWxseSBhbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzLCBvciBgdW5kZWZpbmVkYFxyXG5cdCAqIHRvIGluZGljYXRlIHRoYXQgdGhlIHBvdGVudGlhbGx5IGFtYmlndW91cyBhbHRlcm5hdGl2ZXMgYXJlIHRoZSBjb21wbGV0ZVxyXG5cdCAqIHNldCBvZiByZXByZXNlbnRlZCBhbHRlcm5hdGl2ZXMgaW4gYGNvbmZpZ3NgXHJcblx0ICogQHBhcmFtIGNvbmZpZ3MgdGhlIEFUTiBjb25maWd1cmF0aW9uIHNldCB3aGVyZSB0aGUgYW1iaWd1aXR5IHdhc1xyXG5cdCAqIGlkZW50aWZpZWRcclxuXHQgKi9cclxuXHRyZXBvcnRBbWJpZ3VpdHk/OiAoXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdHJlY29nbml6ZXI6IFBhcnNlcixcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0ZGZhOiBERkEsXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcixcclxuXHRcdGV4YWN0OiBib29sZWFuLFxyXG5cdFx0YW1iaWdBbHRzOiBCaXRTZXQgfCB1bmRlZmluZWQsXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCkgPT4gdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gYW4gU0xMIGNvbmZsaWN0IG9jY3VycyBhbmQgdGhlIHBhcnNlciBpcyBhYm91dFxyXG5cdCAqIHRvIHVzZSB0aGUgZnVsbCBjb250ZXh0IGluZm9ybWF0aW9uIHRvIG1ha2UgYW4gTEwgZGVjaXNpb24uXHJcblx0ICpcclxuXHQgKiBJZiBvbmUgb3IgbW9yZSBjb25maWd1cmF0aW9ucyBpbiBgY29uZmlnc2AgY29udGFpbnMgYSBzZW1hbnRpY1xyXG5cdCAqIHByZWRpY2F0ZSwgdGhlIHByZWRpY2F0ZXMgYXJlIGV2YWx1YXRlZCBiZWZvcmUgdGhpcyBtZXRob2QgaXMgY2FsbGVkLiBUaGVcclxuXHQgKiBzdWJzZXQgb2YgYWx0ZXJuYXRpdmVzIHdoaWNoIGFyZSBzdGlsbCB2aWFibGUgYWZ0ZXIgcHJlZGljYXRlcyBhcmVcclxuXHQgKiBldmFsdWF0ZWQgaXMgcmVwb3J0ZWQgaW4gYGNvbmZsaWN0aW5nQWx0c2AuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICogQHBhcmFtIGRmYSB0aGUgREZBIGZvciB0aGUgY3VycmVudCBkZWNpc2lvblxyXG5cdCAqIEBwYXJhbSBzdGFydEluZGV4IHRoZSBpbnB1dCBpbmRleCB3aGVyZSB0aGUgZGVjaXNpb24gc3RhcnRlZFxyXG5cdCAqIEBwYXJhbSBzdG9wSW5kZXggdGhlIGlucHV0IGluZGV4IHdoZXJlIHRoZSBTTEwgY29uZmxpY3Qgb2NjdXJyZWRcclxuXHQgKiBAcGFyYW0gY29uZmxpY3RpbmdBbHRzIFRoZSBzcGVjaWZpYyBjb25mbGljdGluZyBhbHRlcm5hdGl2ZXMuIElmIHRoaXMgaXNcclxuXHQgKiBgdW5kZWZpbmVkYCwgdGhlIGNvbmZsaWN0aW5nIGFsdGVybmF0aXZlcyBhcmUgYWxsIGFsdGVybmF0aXZlc1xyXG5cdCAqIHJlcHJlc2VudGVkIGluIGBjb25maWdzYC5cclxuXHQgKiBAcGFyYW0gY29uZmxpY3RTdGF0ZSB0aGUgc2ltdWxhdG9yIHN0YXRlIHdoZW4gdGhlIFNMTCBjb25mbGljdCB3YXNcclxuXHQgKiBkZXRlY3RlZFxyXG5cdCAqL1xyXG5cdHJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dD86IChcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0cmVjb2duaXplcjogUGFyc2VyLFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRkZmE6IERGQSxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyLFxyXG5cdFx0Y29uZmxpY3RpbmdBbHRzOiBCaXRTZXQgfCB1bmRlZmluZWQsXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdGNvbmZsaWN0U3RhdGU6IFNpbXVsYXRvclN0YXRlKSA9PiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIHBhcnNlciB3aGVuIGEgZnVsbC1jb250ZXh0IHByZWRpY3Rpb24gaGFzIGFcclxuXHQgKiB1bmlxdWUgcmVzdWx0LlxyXG5cdCAqXHJcblx0ICogRWFjaCBmdWxsLWNvbnRleHQgcHJlZGljdGlvbiB3aGljaCBkb2VzIG5vdCByZXN1bHQgaW4gYSBzeW50YXggZXJyb3JcclxuXHQgKiB3aWxsIGNhbGwgZWl0aGVyIHtAbGluayAjcmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5fSBvclxyXG5cdCAqIHtAbGluayAjcmVwb3J0QW1iaWd1aXR5fS5cclxuXHQgKlxyXG5cdCAqIEZvciBwcmVkaWN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IG9ubHkgZXZhbHVhdGUgZnVsbC1jb250ZXh0XHJcblx0ICogcHJlZGljdGlvbnMgd2hlbiBhbiBTTEwgY29uZmxpY3QgaXMgZm91bmQgKGluY2x1ZGluZyB0aGUgZGVmYXVsdFxyXG5cdCAqIHtAbGluayBQYXJzZXJBVE5TaW11bGF0b3J9IGltcGxlbWVudGF0aW9uKSwgdGhpcyBtZXRob2QgcmVwb3J0cyBjYXNlc1xyXG5cdCAqIHdoZXJlIFNMTCBjb25mbGljdHMgd2VyZSByZXNvbHZlZCB0byB1bmlxdWUgZnVsbC1jb250ZXh0IHByZWRpY3Rpb25zLFxyXG5cdCAqIGkuZS4gdGhlIGRlY2lzaW9uIHdhcyBjb250ZXh0LXNlbnNpdGl2ZS4gVGhpcyByZXBvcnQgZG9lcyBub3QgbmVjZXNzYXJpbHlcclxuXHQgKiBpbmRpY2F0ZSBhIHByb2JsZW0sIGFuZCBpdCBtYXkgYXBwZWFyIGV2ZW4gaW4gY29tcGxldGVseSB1bmFtYmlndW91c1xyXG5cdCAqIGdyYW1tYXJzLlxyXG5cdCAqXHJcblx0ICogYGNvbmZpZ3NgIG1heSBoYXZlIG1vcmUgdGhhbiBvbmUgcmVwcmVzZW50ZWQgYWx0ZXJuYXRpdmUgaWYgdGhlXHJcblx0ICogZnVsbC1jb250ZXh0IHByZWRpY3Rpb24gYWxnb3JpdGhtIGRvZXMgbm90IGV2YWx1YXRlIHByZWRpY2F0ZXMgYmVmb3JlXHJcblx0ICogYmVnaW5uaW5nIHRoZSBmdWxsLWNvbnRleHQgcHJlZGljdGlvbi4gSW4gYWxsIGNhc2VzLCB0aGUgZmluYWwgcHJlZGljdGlvblxyXG5cdCAqIGlzIHBhc3NlZCBhcyB0aGUgYHByZWRpY3Rpb25gIGFyZ3VtZW50LlxyXG5cdCAqXHJcblx0ICogTm90ZSB0aGF0IHRoZSBkZWZpbml0aW9uIG9mIFwiY29udGV4dCBzZW5zaXRpdml0eVwiIGluIHRoaXMgbWV0aG9kXHJcblx0ICogZGlmZmVycyBmcm9tIHRoZSBjb25jZXB0IGluIHtAbGluayBEZWNpc2lvbkluZm8jY29udGV4dFNlbnNpdGl2aXRpZXN9LlxyXG5cdCAqIFRoaXMgbWV0aG9kIHJlcG9ydHMgYWxsIGluc3RhbmNlcyB3aGVyZSBhbiBTTEwgY29uZmxpY3Qgb2NjdXJyZWQgYnV0IExMXHJcblx0ICogcGFyc2luZyBwcm9kdWNlZCBhIHVuaXF1ZSByZXN1bHQsIHdoZXRoZXIgb3Igbm90IHRoYXQgdW5pcXVlIHJlc3VsdFxyXG5cdCAqIG1hdGNoZXMgdGhlIG1pbmltdW0gYWx0ZXJuYXRpdmUgaW4gdGhlIFNMTCBjb25mbGljdGluZyBzZXQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICogQHBhcmFtIGRmYSB0aGUgREZBIGZvciB0aGUgY3VycmVudCBkZWNpc2lvblxyXG5cdCAqIEBwYXJhbSBzdGFydEluZGV4IHRoZSBpbnB1dCBpbmRleCB3aGVyZSB0aGUgZGVjaXNpb24gc3RhcnRlZFxyXG5cdCAqIEBwYXJhbSBzdG9wSW5kZXggdGhlIGlucHV0IGluZGV4IHdoZXJlIHRoZSBjb250ZXh0IHNlbnNpdGl2aXR5IHdhc1xyXG5cdCAqIGZpbmFsbHkgZGV0ZXJtaW5lZFxyXG5cdCAqIEBwYXJhbSBwcmVkaWN0aW9uIHRoZSB1bmFtYmlndW91cyByZXN1bHQgb2YgdGhlIGZ1bGwtY29udGV4dCBwcmVkaWN0aW9uXHJcblx0ICogQHBhcmFtIGFjY2VwdFN0YXRlIHRoZSBzaW11bGF0b3Igc3RhdGUgd2hlbiB0aGUgdW5hbWJpZ3VvdXMgcHJlZGljdGlvblxyXG5cdCAqIHdhcyBkZXRlcm1pbmVkXHJcblx0ICovXHJcblx0cmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5PzogKFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRyZWNvZ25pemVyOiBQYXJzZXIsXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdGRmYTogREZBLFxyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyLFxyXG5cdFx0c3RvcEluZGV4OiBudW1iZXIsXHJcblx0XHRwcmVkaWN0aW9uOiBudW1iZXIsXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdGFjY2VwdFN0YXRlOiBTaW11bGF0b3JTdGF0ZSkgPT4gdm9pZDtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTcuNDc0MTE5Ni0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vYXRuL0FUTlwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5cclxuLyoqIEEgaGFuZHkgY2xhc3MgZm9yIHVzZSB3aXRoXHJcbiAqXHJcbiAqICBvcHRpb25zIHtjb250ZXh0U3VwZXJDbGFzcz1vcmcuYW50bHIudjQucnVudGltZS5SdWxlQ29udGV4dFdpdGhBbHROdW07fVxyXG4gKlxyXG4gKiAgdGhhdCBwcm92aWRlcyBhIGJhY2tpbmcgZmllbGQgLyBpbXBsIGZvciB0aGUgb3V0ZXIgYWx0ZXJuYXRpdmUgbnVtYmVyXHJcbiAqICBtYXRjaGVkIGZvciBhbiBpbnRlcm5hbCBwYXJzZSB0cmVlIG5vZGUuXHJcbiAqXHJcbiAqICBJJ20gb25seSBwdXR0aW5nIGludG8gSmF2YSBydW50aW1lIGFzIEknbSBjZXJ0YWluIEknbSB0aGUgb25seSBvbmUgdGhhdFxyXG4gKiAgd2lsbCByZWFsbHkgZXZlcnkgdXNlIHRoaXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUNvbnRleHRXaXRoQWx0TnVtIGV4dGVuZHMgUGFyc2VyUnVsZUNvbnRleHQge1xyXG5cdHByaXZhdGUgX2FsdE51bWJlcjogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpO1xyXG5cdGNvbnN0cnVjdG9yKHBhcmVudDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsIGludm9raW5nU3RhdGVOdW1iZXI6IG51bWJlcik7XHJcblx0Y29uc3RydWN0b3IocGFyZW50PzogUGFyc2VyUnVsZUNvbnRleHQsIGludm9raW5nU3RhdGVOdW1iZXI/OiBudW1iZXIpIHtcclxuXHRcdGlmIChpbnZva2luZ1N0YXRlTnVtYmVyICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlTnVtYmVyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN1cGVyKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWx0TnVtYmVyID0gQVROLklOVkFMSURfQUxUX05VTUJFUjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBhbHROdW1iZXIoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9hbHROdW1iZXI7XHJcblx0fVxyXG5cclxuXHQvLyBAT3ZlcnJpZGVcclxuXHRzZXQgYWx0TnVtYmVyKGFsdE51bTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLl9hbHROdW1iZXIgPSBhbHROdW07XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Ny42MjcxMjIxLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBEZXBlbmRlbnRzIH0gZnJvbSBcIi4vRGVwZW5kZW50c1wiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi9QYXJzZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWNsYXJlcyBhIGRlcGVuZGVuY3kgdXBvbiBhIGdyYW1tYXIgcnVsZSwgYWxvbmcgd2l0aCBhIHNldCBvZiB6ZXJvIG9yIG1vcmUgZGVwZW5kZW50IHJ1bGVzLlxyXG4gKlxyXG4gKiBWZXJzaW9uIG51bWJlcnMgd2l0aGluIGEgZ3JhbW1hciBzaG91bGQgYmUgYXNzaWduZWQgb24gYSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgYmFzaXMgdG8gYWxsb3cgZm9yIGFjY3VyYXRlXHJcbiAqIHRyYWNraW5nIG9mIGRlcGVuZGVudCBydWxlcy5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFJ1bGVEZXBlbmRlbmN5KGRlcGVuZGVuY3k6IERlcGVuZGVuY3lTcGVjaWZpY2F0aW9uKSB7XHJcblx0cmV0dXJuICh0YXJnZXQ6IG9iamVjdCwgcHJvcGVydHlLZXk6IFByb3BlcnR5S2V5LCBwcm9wZXJ0eURlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcikgPT4ge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGVwZW5kZW5jeVNwZWNpZmljYXRpb24ge1xyXG5cdHJlYWRvbmx5IHJlY29nbml6ZXI6IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFBhcnNlcjsgfTtcclxuXHJcblx0cmVhZG9ubHkgcnVsZTogbnVtYmVyO1xyXG5cclxuXHRyZWFkb25seSB2ZXJzaW9uOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNwZWNpZmllcyB0aGUgc2V0IG9mIGdyYW1tYXIgcnVsZXMgcmVsYXRlZCB0byBgcnVsZWAgd2hpY2ggdGhlIGFubm90YXRlZCBlbGVtZW50IGRlcGVuZHMgb24uIEV2ZW4gd2hlbiBhYnNlbnRcclxuXHQgKiBmcm9tIHRoaXMgc2V0LCB0aGUgYW5ub3RhdGVkIGVsZW1lbnQgaXMgaW1wbGljaXRseSBkZXBlbmRlbnQgdXBvbiB0aGUgZXhwbGljaXRseSBzcGVjaWZpZWQgYHJ1bGVgLCB3aGljaFxyXG5cdCAqIGNvcnJlc3BvbmRzIHRvIHRoZSBgRGVwZW5kZW50cy5TRUxGYCBlbGVtZW50LlxyXG5cdCAqXHJcblx0ICogQnkgZGVmYXVsdCwgdGhlIGFubm90YXRlZCBlbGVtZW50IGlzIGRlcGVuZGVudCB1cG9uIHRoZSBzcGVjaWZpZWQgYHJ1bGVgIGFuZCBpdHMgYERlcGVuZGVudHMuUEFSRU5UU2AsIGkuZS4gdGhlXHJcblx0ICogcnVsZSB3aXRoaW4gb25lIGxldmVsIG9mIGNvbnRleHQgaW5mb3JtYXRpb24uIFRoZSBwYXJlbnRzIGFyZSBpbmNsdWRlZCBzaW5jZSB0aGUgbW9zdCBmcmVxdWVudCBhc3N1bXB0aW9uIGFib3V0IGFcclxuXHQgKiBydWxlIGlzIHdoZXJlIGl0J3MgdXNlZCBpbiB0aGUgZ3JhbW1hci5cclxuXHQgKi9cclxuXHRyZWFkb25seSBkZXBlbmRlbnRzPzogRGVwZW5kZW50c1tdO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Ny43MTcwMDI3LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi9QYXJzZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBSdWxlVmVyc2lvbih2ZXJzaW9uOiBudW1iZXIpIHtcclxuXHJcblx0cmV0dXJuIDxUIGV4dGVuZHMgUGFyc2VyUnVsZUNvbnRleHQ+KHRhcmdldDogUGFyc2VyLCBwcm9wZXJ0eUtleTogUHJvcGVydHlLZXksIHByb3BlcnR5RGVzY3JpcHRvcjogVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8KC4uLmFyZ3M6IGFueVtdKSA9PiBUPikgPT4ge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH07XHJcblxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Ny44NzgzNjQwLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBDaGFyU3RyZWFtIH0gZnJvbSBcIi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuU291cmNlIH0gZnJvbSBcIi4vVG9rZW5Tb3VyY2VcIjtcclxuXHJcbi8qKiBUaGUgZGVmYXVsdCBtZWNoYW5pc20gZm9yIGNyZWF0aW5nIHRva2Vucy4gSXQncyB1c2VkIGJ5IGRlZmF1bHQgaW4gTGV4ZXIgYW5kXHJcbiAqICB0aGUgZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ3kgKHRvIGNyZWF0ZSBtaXNzaW5nIHRva2VucykuICBOb3RpZnlpbmcgdGhlIHBhcnNlclxyXG4gKiAgb2YgYSBuZXcgZmFjdG9yeSBtZWFucyB0aGF0IGl0IG5vdGlmaWVzIGl0cyB0b2tlbiBzb3VyY2UgYW5kIGVycm9yIHN0cmF0ZWd5LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUb2tlbkZhY3Rvcnkge1xyXG5cdC8qKiBUaGlzIGlzIHRoZSBtZXRob2QgdXNlZCB0byBjcmVhdGUgdG9rZW5zIGluIHRoZSBsZXhlciBhbmQgaW4gdGhlXHJcblx0ICogIGVycm9yIGhhbmRsaW5nIHN0cmF0ZWd5LiBJZiB0ZXh0IT11bmRlZmluZWQsIHRoYW4gdGhlIHN0YXJ0IGFuZCBzdG9wIHBvc2l0aW9uc1xyXG5cdCAqICBhcmUgd2lwZWQgdG8gLTEgaW4gdGhlIHRleHQgb3ZlcnJpZGUgaXMgc2V0IGluIHRoZSBDb21tb25Ub2tlbi5cclxuXHQgKi9cclxuXHQvL0BOb3ROdWxsXHJcblx0Y3JlYXRlKFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRzb3VyY2U6IHsgc291cmNlPzogVG9rZW5Tb3VyY2UsIHN0cmVhbT86IENoYXJTdHJlYW0gfSxcclxuXHRcdHR5cGU6IG51bWJlcixcclxuXHRcdHRleHQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcclxuXHRcdGNoYW5uZWw6IG51bWJlcixcclxuXHRcdHN0YXJ0OiBudW1iZXIsXHJcblx0XHRzdG9wOiBudW1iZXIsXHJcblx0XHRsaW5lOiBudW1iZXIsXHJcblx0XHRjaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlcik6IFRva2VuO1xyXG5cclxuXHQvKiogR2VuZXJpY2FsbHkgdXNlZnVsICovXHJcblx0Ly9ATm90TnVsbFxyXG5cdGNyZWF0ZVNpbXBsZSh0eXBlOiBudW1iZXIsIHRleHQ6IHN0cmluZyk6IFRva2VuO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Ny45NjA0MjAwLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBDaGFyU3RyZWFtIH0gZnJvbSBcIi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuRmFjdG9yeSB9IGZyb20gXCIuL1Rva2VuRmFjdG9yeVwiO1xyXG5cclxuLyoqXHJcbiAqIEEgc291cmNlIG9mIHRva2VucyBtdXN0IHByb3ZpZGUgYSBzZXF1ZW5jZSBvZiB0b2tlbnMgdmlhIHtAbGluayAjbmV4dFRva2VuKCl9XHJcbiAqIGFuZCBhbHNvIG11c3QgcmV2ZWFsIGl0J3Mgc291cmNlIG9mIGNoYXJhY3RlcnM7IHtAbGluayBDb21tb25Ub2tlbn0ncyB0ZXh0IGlzXHJcbiAqIGNvbXB1dGVkIGZyb20gYSB7QGxpbmsgQ2hhclN0cmVhbX07IGl0IG9ubHkgc3RvcmUgaW5kaWNlcyBpbnRvIHRoZSBjaGFyXHJcbiAqIHN0cmVhbS5cclxuICpcclxuICogRXJyb3JzIGZyb20gdGhlIGxleGVyIGFyZSBuZXZlciBwYXNzZWQgdG8gdGhlIHBhcnNlci4gRWl0aGVyIHlvdSB3YW50IHRvIGtlZXBcclxuICogZ29pbmcgb3IgeW91IGRvIG5vdCB1cG9uIHRva2VuIHJlY29nbml0aW9uIGVycm9yLiBJZiB5b3UgZG8gbm90IHdhbnQgdG9cclxuICogY29udGludWUgbGV4aW5nIHRoZW4geW91IGRvIG5vdCB3YW50IHRvIGNvbnRpbnVlIHBhcnNpbmcuIEp1c3QgdGhyb3cgYW5cclxuICogZXhjZXB0aW9uIG5vdCB1bmRlciB7QGxpbmsgUmVjb2duaXRpb25FeGNlcHRpb259IGFuZCBKYXZhIHdpbGwgbmF0dXJhbGx5IHRvc3NcclxuICogeW91IGFsbCB0aGUgd2F5IG91dCBvZiB0aGUgcmVjb2duaXplcnMuIElmIHlvdSB3YW50IHRvIGNvbnRpbnVlIGxleGluZyB0aGVuXHJcbiAqIHlvdSBzaG91bGQgbm90IHRocm93IGFuIGV4Y2VwdGlvbiB0byB0aGUgcGFyc2VyLS1pdCBoYXMgYWxyZWFkeSByZXF1ZXN0ZWQgYVxyXG4gKiB0b2tlbi4gS2VlcCBsZXhpbmcgdW50aWwgeW91IGdldCBhIHZhbGlkIG9uZS4gSnVzdCByZXBvcnQgZXJyb3JzIGFuZCBrZWVwXHJcbiAqIGdvaW5nLCBsb29raW5nIGZvciBhIHZhbGlkIHRva2VuLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUb2tlblNvdXJjZSB7XHJcblx0LyoqXHJcblx0ICogUmV0dXJuIGEge0BsaW5rIFRva2VufSBvYmplY3QgZnJvbSB5b3VyIGlucHV0IHN0cmVhbSAodXN1YWxseSBhXHJcblx0ICoge0BsaW5rIENoYXJTdHJlYW19KS4gRG8gbm90IGZhaWwvcmV0dXJuIHVwb24gbGV4aW5nIGVycm9yOyBrZWVwIGNoZXdpbmdcclxuXHQgKiBvbiB0aGUgY2hhcmFjdGVycyB1bnRpbCB5b3UgZ2V0IGEgZ29vZCBvbmU7IGVycm9ycyBhcmUgbm90IHBhc3NlZCB0aHJvdWdoXHJcblx0ICogdG8gdGhlIHBhcnNlci5cclxuXHQgKi9cclxuXHQvL0BOb3ROdWxsXHJcblx0bmV4dFRva2VuKCk6IFRva2VuO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGxpbmUgbnVtYmVyIGZvciB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgaW5wdXQgc3RyZWFtLiBUaGVcclxuXHQgKiBmaXJzdCBsaW5lIGluIHRoZSBpbnB1dCBpcyBsaW5lIDEuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgbGluZSBudW1iZXIgZm9yIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBpbnB1dCBzdHJlYW0sIG9yXHJcblx0ICogMCBpZiB0aGUgY3VycmVudCB0b2tlbiBzb3VyY2UgZG9lcyBub3QgdHJhY2sgbGluZSBudW1iZXJzLlxyXG5cdCAqL1xyXG5cdHJlYWRvbmx5IGxpbmU6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBpbmRleCBpbnRvIHRoZSBjdXJyZW50IGxpbmUgZm9yIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBpbnB1dFxyXG5cdCAqIHN0cmVhbS4gVGhlIGZpcnN0IGNoYXJhY3RlciBvbiBhIGxpbmUgaGFzIHBvc2l0aW9uIDAuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgbGluZSBudW1iZXIgZm9yIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBpbnB1dCBzdHJlYW0sIG9yXHJcblx0ICogLTEgaWYgdGhlIGN1cnJlbnQgdG9rZW4gc291cmNlIGRvZXMgbm90IHRyYWNrIGNoYXJhY3RlciBwb3NpdGlvbnMuXHJcblx0ICovXHJcblx0cmVhZG9ubHkgY2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUge0BsaW5rIENoYXJTdHJlYW19IGZyb20gd2hpY2ggdGhpcyB0b2tlbiBzb3VyY2UgaXMgY3VycmVudGx5XHJcblx0ICogcHJvdmlkaW5nIHRva2Vucy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSB7QGxpbmsgQ2hhclN0cmVhbX0gYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluXHJcblx0ICogdGhlIGlucHV0LCBvciBgdW5kZWZpbmVkYCBpZiBubyBpbnB1dCBzdHJlYW0gaXMgYXZhaWxhYmxlIGZvciB0aGUgdG9rZW5cclxuXHQgKiBzb3VyY2UuXHJcblx0ICovXHJcblx0cmVhZG9ubHkgaW5wdXRTdHJlYW06IENoYXJTdHJlYW0gfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIHVuZGVybHlpbmcgaW5wdXQgc291cmNlLiBUaGlzIG1ldGhvZCByZXR1cm5zIGFcclxuXHQgKiBub24tdW5kZWZpbmVkLCBub24tZW1wdHkgc3RyaW5nLiBJZiBzdWNoIGEgbmFtZSBpcyBub3Qga25vd24sIHRoaXMgbWV0aG9kXHJcblx0ICogcmV0dXJucyB7QGxpbmsgSW50U3RyZWFtI1VOS05PV05fU09VUkNFX05BTUV9LlxyXG5cdCAqL1xyXG5cdC8vQE5vdE51bGxcclxuXHRyZWFkb25seSBzb3VyY2VOYW1lOiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgb3Igc2V0cyB0aGUgYFRva2VuRmFjdG9yeWAgdGhpcyB0b2tlbiBzb3VyY2UgaXMgY3VycmVudGx5IHVzaW5nIGZvclxyXG5cdCAqIGNyZWF0aW5nIGBUb2tlbmAgb2JqZWN0cyBmcm9tIHRoZSBpbnB1dC5cclxuXHQgKi9cclxuXHQvL0BOb3ROdWxsXHJcblx0dG9rZW5GYWN0b3J5OiBUb2tlbkZhY3Rvcnk7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU4LjA0MzM5OTgtMDc6MDBcclxuXHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5pbXBvcnQgeyBJbnRTdHJlYW0gfSBmcm9tIFwiLi9JbnRTdHJlYW1cIjtcclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9SdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuU291cmNlIH0gZnJvbSBcIi4vVG9rZW5Tb3VyY2VcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiB7QGxpbmsgSW50U3RyZWFtfSB3aG9zZSBzeW1ib2xzIGFyZSB7QGxpbmsgVG9rZW59IGluc3RhbmNlcy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5TdHJlYW0gZXh0ZW5kcyBJbnRTdHJlYW0ge1xyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgYFRva2VuYCBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlIHJldHVybmVkIGJ5IGBMQShrKWAuIFRoaXMgbWV0aG9kIGhhcyB0aGUgc2FtZSBwcmUtIGFuZFxyXG5cdCAqIHBvc3QtY29uZGl0aW9ucyBhcyBgSW50U3RyZWFtLkxBYC4gSW4gYWRkaXRpb24sIHdoZW4gdGhlIHByZWNvbmRpdGlvbnMgb2YgdGhpcyBtZXRob2QgYXJlIG1ldCwgdGhlIHJldHVybiB2YWx1ZVxyXG5cdCAqIGlzIG5vbi11bmRlZmluZWQgYW5kIHRoZSB2YWx1ZSBvZiBgTFQoaykudHlwZSA9PT0gTEEoaylgLlxyXG5cdCAqXHJcblx0ICogQSBgUmFuZ2VFcnJvcmAgaXMgdGhyb3duIGlmIGBrPDBgIGFuZCBmZXdlciB0aGFuIGAta2AgY2FsbHMgdG8gYGNvbnN1bWUoKWAgaGF2ZSBvY2N1cnJlZCBmcm9tIHRoZSBiZWdpbm5pbmcgb2ZcclxuXHQgKiB0aGUgc3RyZWFtIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxyXG5cdCAqXHJcblx0ICogU2VlIGBJbnRTdHJlYW0uTEFgXHJcblx0ICovXHJcblx0TFQoazogbnVtYmVyKTogVG9rZW47XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgYFRva2VuYCBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlIHJldHVybmVkIGJ5IGBMQShrKWAuIFRoaXMgbWV0aG9kIGhhcyB0aGUgc2FtZSBwcmUtIGFuZFxyXG5cdCAqIHBvc3QtY29uZGl0aW9ucyBhcyBgSW50U3RyZWFtLkxBYC4gSW4gYWRkaXRpb24sIHdoZW4gdGhlIHByZWNvbmRpdGlvbnMgb2YgdGhpcyBtZXRob2QgYXJlIG1ldCwgdGhlIHJldHVybiB2YWx1ZVxyXG5cdCAqIGlzIG5vbi11bmRlZmluZWQgYW5kIHRoZSB2YWx1ZSBvZiBgdHJ5TFQoaykudHlwZSA9PT0gTEEoaylgLlxyXG5cdCAqXHJcblx0ICogVGhlIHJldHVybiB2YWx1ZSBpcyBgdW5kZWZpbmVkYCBpZiBgazwwYCBhbmQgZmV3ZXIgdGhhbiBgLWtgIGNhbGxzIHRvIGBjb25zdW1lKClgIGhhdmUgb2NjdXJyZWQgZnJvbSB0aGVcclxuXHQgKiBiZWdpbm5pbmcgb2YgdGhlIHN0cmVhbSBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIFNlZSBgSW50U3RyZWFtLkxBYFxyXG5cdCAqL1xyXG5cdHRyeUxUKGs6IG51bWJlcik6IFRva2VuIHwgdW5kZWZpbmVkO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB7QGxpbmsgVG9rZW59IGF0IHRoZSBzcGVjaWZpZWQgYGluZGV4YCBpbiB0aGUgc3RyZWFtLiBXaGVuXHJcblx0ICogdGhlIHByZWNvbmRpdGlvbnMgb2YgdGhpcyBtZXRob2QgYXJlIG1ldCwgdGhlIHJldHVybiB2YWx1ZSBpcyBub24tdW5kZWZpbmVkLlxyXG5cdCAqXHJcblx0ICogVGhlIHByZWNvbmRpdGlvbnMgZm9yIHRoaXMgbWV0aG9kIGFyZSB0aGUgc2FtZSBhcyB0aGUgcHJlY29uZGl0aW9ucyBvZlxyXG5cdCAqIHtAbGluayBJbnRTdHJlYW0jc2Vla30uIElmIHRoZSBiZWhhdmlvciBvZiBgc2VlayhpbmRleClgIGlzXHJcblx0ICogdW5zcGVjaWZpZWQgZm9yIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBnaXZlbiBgaW5kZXhgLCB0aGVuIHRoZVxyXG5cdCAqIGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kIGlzIGFsc28gdW5zcGVjaWZpZWQuXHJcblx0ICpcclxuXHQgKiBUaGUgc3ltYm9sIHJlZmVycmVkIHRvIGJ5IGBpbmRleGAgZGlmZmVycyBmcm9tIGBzZWVrKClgIG9ubHlcclxuXHQgKiBpbiB0aGUgY2FzZSBvZiBmaWx0ZXJpbmcgc3RyZWFtcyB3aGVyZSBgaW5kZXhgIGxpZXMgYmVmb3JlIHRoZSBlbmRcclxuXHQgKiBvZiB0aGUgc3RyZWFtLiBVbmxpa2UgYHNlZWsoKWAsIHRoaXMgbWV0aG9kIGRvZXMgbm90IGFkanVzdFxyXG5cdCAqIGBpbmRleGAgdG8gcG9pbnQgdG8gYSBub24taWdub3JlZCBzeW1ib2wuXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiB7Y29kZSBpbmRleH0gaXMgbGVzcyB0aGFuIDBcclxuXHQgKiBAdGhyb3dzIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uIGlmIHRoZSBzdHJlYW0gZG9lcyBub3Qgc3VwcG9ydFxyXG5cdCAqIHJldHJpZXZpbmcgdGhlIHRva2VuIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuXHQgKi9cclxuXHQvL0BOb3ROdWxsXHJcblx0Z2V0KGk6IG51bWJlcik6IFRva2VuO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB1bmRlcmx5aW5nIHtAbGluayBUb2tlblNvdXJjZX0gd2hpY2ggcHJvdmlkZXMgdG9rZW5zIGZvciB0aGlzXHJcblx0ICogc3RyZWFtLlxyXG5cdCAqL1xyXG5cdC8vQE5vdE51bGxcclxuXHRyZWFkb25seSB0b2tlblNvdXJjZTogVG9rZW5Tb3VyY2U7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiB0aGUgdGV4dCBvZiBhbGwgdG9rZW5zIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGBpbnRlcnZhbGAuIFRoaXNcclxuXHQgKiBtZXRob2QgYmVoYXZlcyBsaWtlIHRoZSBmb2xsb3dpbmcgY29kZSAoaW5jbHVkaW5nIHBvdGVudGlhbCBleGNlcHRpb25zXHJcblx0ICogZm9yIHZpb2xhdGluZyBwcmVjb25kaXRpb25zIG9mIHtAbGluayAjZ2V0fSwgYnV0IG1heSBiZSBvcHRpbWl6ZWQgYnkgdGhlXHJcblx0ICogc3BlY2lmaWMgaW1wbGVtZW50YXRpb24uXHJcblx0ICpcclxuXHQgKiBgYGBcclxuXHQgKiBUb2tlblN0cmVhbSBzdHJlYW0gPSAuLi47XHJcblx0ICogU3RyaW5nIHRleHQgPSBcIlwiO1xyXG5cdCAqIGZvciAoaW50IGkgPSBpbnRlcnZhbC5hOyBpIDw9IGludGVydmFsLmI7IGkrKykge1xyXG5cdCAqICAgdGV4dCArPSBzdHJlYW0uZ2V0KGkpLnRleHQ7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGludGVydmFsIFRoZSBpbnRlcnZhbCBvZiB0b2tlbnMgd2l0aGluIHRoaXMgc3RyZWFtIHRvIGdldCB0ZXh0XHJcblx0ICogZm9yLlxyXG5cdCAqIEByZXR1cm5zIFRoZSB0ZXh0IG9mIGFsbCB0b2tlbnMgd2l0aGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwgaW4gdGhpc1xyXG5cdCAqIHN0cmVhbS5cclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgTnVsbFBvaW50ZXJFeGNlcHRpb24gaWYgYGludGVydmFsYCBpcyBgdW5kZWZpbmVkYFxyXG5cdCAqL1xyXG5cdC8vQE5vdE51bGxcclxuXHRnZXRUZXh0KC8qQE5vdE51bGwqLyBpbnRlcnZhbDogSW50ZXJ2YWwpOiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiB0aGUgdGV4dCBvZiBhbGwgdG9rZW5zIGluIHRoZSBzdHJlYW0uIFRoaXMgbWV0aG9kIGJlaGF2ZXMgbGlrZSB0aGVcclxuXHQgKiBmb2xsb3dpbmcgY29kZSwgaW5jbHVkaW5nIHBvdGVudGlhbCBleGNlcHRpb25zIGZyb20gdGhlIGNhbGxzIHRvXHJcblx0ICoge0BsaW5rIEludFN0cmVhbSNzaXplfSBhbmQge0BsaW5rICNnZXRUZXh0KEludGVydmFsKX0sIGJ1dCBtYXkgYmVcclxuXHQgKiBvcHRpbWl6ZWQgYnkgdGhlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uLlxyXG5cdCAqXHJcblx0ICogYGBgXHJcblx0ICogVG9rZW5TdHJlYW0gc3RyZWFtID0gLi4uO1xyXG5cdCAqIFN0cmluZyB0ZXh0ID0gc3RyZWFtLmdldFRleHQobmV3IEludGVydmFsKDAsIHN0cmVhbS5zaXplKSk7XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgdGV4dCBvZiBhbGwgdG9rZW5zIGluIHRoZSBzdHJlYW0uXHJcblx0ICovXHJcblx0Ly9ATm90TnVsbFxyXG5cdGdldFRleHQoKTogc3RyaW5nO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGhlIHRleHQgb2YgYWxsIHRva2VucyBpbiB0aGUgc291cmNlIGludGVydmFsIG9mIHRoZSBzcGVjaWZpZWRcclxuXHQgKiBjb250ZXh0LiBUaGlzIG1ldGhvZCBiZWhhdmVzIGxpa2UgdGhlIGZvbGxvd2luZyBjb2RlLCBpbmNsdWRpbmcgcG90ZW50aWFsXHJcblx0ICogZXhjZXB0aW9ucyBmcm9tIHRoZSBjYWxsIHRvIHtAbGluayAjZ2V0VGV4dChJbnRlcnZhbCl9LCBidXQgbWF5IGJlXHJcblx0ICogb3B0aW1pemVkIGJ5IHRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbi5cclxuXHQgKlxyXG5cdCAqIElmIGBjdHguc291cmNlSW50ZXJ2YWxgIGRvZXMgbm90IHJldHVybiBhIHZhbGlkIGludGVydmFsIG9mXHJcblx0ICogdG9rZW5zIHByb3ZpZGVkIGJ5IHRoaXMgc3RyZWFtLCB0aGUgYmVoYXZpb3IgaXMgdW5zcGVjaWZpZWQuXHJcblx0ICpcclxuXHQgKiBgYGBcclxuXHQgKiBUb2tlblN0cmVhbSBzdHJlYW0gPSAuLi47XHJcblx0ICogU3RyaW5nIHRleHQgPSBzdHJlYW0uZ2V0VGV4dChjdHguc291cmNlSW50ZXJ2YWwpO1xyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGN0eCBUaGUgY29udGV4dCBwcm92aWRpbmcgdGhlIHNvdXJjZSBpbnRlcnZhbCBvZiB0b2tlbnMgdG8gZ2V0XHJcblx0ICogdGV4dCBmb3IuXHJcblx0ICogQHJldHVybnMgVGhlIHRleHQgb2YgYWxsIHRva2VucyB3aXRoaW4gdGhlIHNvdXJjZSBpbnRlcnZhbCBvZiBgY3R4YC5cclxuXHQgKi9cclxuXHQvL0BOb3ROdWxsXHJcblx0Z2V0VGV4dCgvKkBOb3ROdWxsKi8gY3R4OiBSdWxlQ29udGV4dCk6IHN0cmluZztcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIHRoZSB0ZXh0IG9mIGFsbCB0b2tlbnMgaW4gdGhpcyBzdHJlYW0gYmV0d2VlbiBgc3RhcnRgIGFuZFxyXG5cdCAqIGBzdG9wYCAoaW5jbHVzaXZlKS5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSBzcGVjaWZpZWQgYHN0YXJ0YCBvciBgc3RvcGAgdG9rZW4gd2FzIG5vdCBwcm92aWRlZCBieVxyXG5cdCAqIHRoaXMgc3RyZWFtLCBvciBpZiB0aGUgYHN0b3BgIG9jY3VycmVkIGJlZm9yZSB0aGUgYHN0YXJ0YH1cclxuXHQgKiB0b2tlbiwgdGhlIGJlaGF2aW9yIGlzIHVuc3BlY2lmaWVkLlxyXG5cdCAqXHJcblx0ICogRm9yIHN0cmVhbXMgd2hpY2ggZW5zdXJlIHRoYXQgdGhlIGBUb2tlbi50b2tlbkluZGV4YCBtZXRob2QgaXNcclxuXHQgKiBhY2N1cmF0ZSBmb3IgYWxsIG9mIGl0cyBwcm92aWRlZCB0b2tlbnMsIHRoaXMgbWV0aG9kIGJlaGF2ZXMgbGlrZSB0aGVcclxuXHQgKiBmb2xsb3dpbmcgY29kZS4gT3RoZXIgc3RyZWFtcyBtYXkgaW1wbGVtZW50IHRoaXMgbWV0aG9kIGluIG90aGVyIHdheXNcclxuXHQgKiBwcm92aWRlZCB0aGUgYmVoYXZpb3IgaXMgY29uc2lzdGVudCB3aXRoIHRoaXMgYXQgYSBoaWdoIGxldmVsLlxyXG5cdCAqXHJcblx0ICogYGBgXHJcblx0ICogVG9rZW5TdHJlYW0gc3RyZWFtID0gLi4uO1xyXG5cdCAqIFN0cmluZyB0ZXh0ID0gXCJcIjtcclxuXHQgKiBmb3IgKGludCBpID0gc3RhcnQudG9rZW5JbmRleDsgaSA8PSBzdG9wLnRva2VuSW5kZXg7IGkrKykge1xyXG5cdCAqICAgdGV4dCArPSBzdHJlYW0uZ2V0KGkpLnRleHQ7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHN0YXJ0IFRoZSBmaXJzdCB0b2tlbiBpbiB0aGUgaW50ZXJ2YWwgdG8gZ2V0IHRleHQgZm9yLlxyXG5cdCAqIEBwYXJhbSBzdG9wIFRoZSBsYXN0IHRva2VuIGluIHRoZSBpbnRlcnZhbCB0byBnZXQgdGV4dCBmb3IgKGluY2x1c2l2ZSkuXHJcblx0ICogQHJldHVybnMgVGhlIHRleHQgb2YgYWxsIHRva2VucyBseWluZyBiZXR3ZWVuIHRoZSBzcGVjaWZpZWQgYHN0YXJ0YFxyXG5cdCAqIGFuZCBgc3RvcGAgdG9rZW5zLlxyXG5cdCAqXHJcblx0ICogQHRocm93cyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiBpZiB0aGlzIHN0cmVhbSBkb2VzIG5vdCBzdXBwb3J0XHJcblx0ICogdGhpcyBtZXRob2QgZm9yIHRoZSBzcGVjaWZpZWQgdG9rZW5zXHJcblx0ICovXHJcblx0Ly9ATm90TnVsbFxyXG5cdGdldFRleHRGcm9tUmFuZ2Uoc3RhcnQ6IGFueSwgc3RvcDogYW55KTogc3RyaW5nO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1OC4xNzY4ODUwLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi9Ub2tlblN0cmVhbVwiO1xyXG5cclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4vbWlzYy9VdGlsc1wiO1xyXG5cclxuLyoqXHJcbiAqIFVzZWZ1bCBmb3IgcmV3cml0aW5nIG91dCBhIGJ1ZmZlcmVkIGlucHV0IHRva2VuIHN0cmVhbSBhZnRlciBkb2luZyBzb21lXHJcbiAqIGF1Z21lbnRhdGlvbiBvciBvdGhlciBtYW5pcHVsYXRpb25zIG9uIGl0LlxyXG4gKlxyXG4gKiBZb3UgY2FuIGluc2VydCBzdHVmZiwgcmVwbGFjZSwgYW5kIGRlbGV0ZSBjaHVua3MuIE5vdGUgdGhhdCB0aGUgb3BlcmF0aW9uc1xyXG4gKiBhcmUgZG9uZSBsYXppbHktLW9ubHkgaWYgeW91IGNvbnZlcnQgdGhlIGJ1ZmZlciB0byBhIHtAbGluayBTdHJpbmd9IHdpdGhcclxuICoge0BsaW5rIFRva2VuU3RyZWFtI2dldFRleHQoKX0uIFRoaXMgaXMgdmVyeSBlZmZpY2llbnQgYmVjYXVzZSB5b3UgYXJlIG5vdFxyXG4gKiBtb3ZpbmcgZGF0YSBhcm91bmQgYWxsIHRoZSB0aW1lLiBBcyB0aGUgYnVmZmVyIG9mIHRva2VucyBpcyBjb252ZXJ0ZWQgdG9cclxuICogc3RyaW5ncywgdGhlIHtAbGluayAjZ2V0VGV4dCgpfSBtZXRob2Qocykgc2NhbiB0aGUgaW5wdXQgdG9rZW4gc3RyZWFtIGFuZFxyXG4gKiBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgYW4gb3BlcmF0aW9uIGF0IHRoZSBjdXJyZW50IGluZGV4LiBJZiBzbywgdGhlXHJcbiAqIG9wZXJhdGlvbiBpcyBkb25lIGFuZCB0aGVuIG5vcm1hbCB7QGxpbmsgU3RyaW5nfSByZW5kZXJpbmcgY29udGludWVzIG9uIHRoZVxyXG4gKiBidWZmZXIuIFRoaXMgaXMgbGlrZSBoYXZpbmcgbXVsdGlwbGUgVHVyaW5nIG1hY2hpbmUgaW5zdHJ1Y3Rpb24gc3RyZWFtc1xyXG4gKiAocHJvZ3JhbXMpIG9wZXJhdGluZyBvbiBhIHNpbmdsZSBpbnB1dCB0YXBlLiA6KVxyXG4gKlxyXG4gKiBUaGlzIHJld3JpdGVyIG1ha2VzIG5vIG1vZGlmaWNhdGlvbnMgdG8gdGhlIHRva2VuIHN0cmVhbS4gSXQgZG9lcyBub3QgYXNrIHRoZVxyXG4gKiBzdHJlYW0gdG8gZmlsbCBpdHNlbGYgdXAgbm9yIGRvZXMgaXQgYWR2YW5jZSB0aGUgaW5wdXQgY3Vyc29yLiBUaGUgdG9rZW5cclxuICogc3RyZWFtIGBUb2tlblN0cmVhbS5pbmRleGAgd2lsbCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmVmb3JlIGFuZFxyXG4gKiBhZnRlciBhbnkge0BsaW5rICNnZXRUZXh0KCl9IGNhbGwuXHJcbiAqXHJcbiAqIFRoZSByZXdyaXRlciBvbmx5IHdvcmtzIG9uIHRva2VucyB0aGF0IHlvdSBoYXZlIGluIHRoZSBidWZmZXIgYW5kIGlnbm9yZXMgdGhlXHJcbiAqIGN1cnJlbnQgaW5wdXQgY3Vyc29yLiBJZiB5b3UgYXJlIGJ1ZmZlcmluZyB0b2tlbnMgb24tZGVtYW5kLCBjYWxsaW5nXHJcbiAqIHtAbGluayAjZ2V0VGV4dCgpfSBoYWxmd2F5IHRocm91Z2ggdGhlIGlucHV0IHdpbGwgb25seSBkbyByZXdyaXRlcyBmb3IgdGhvc2VcclxuICogdG9rZW5zIGluIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSBmaWxlLlxyXG4gKlxyXG4gKiBTaW5jZSB0aGUgb3BlcmF0aW9ucyBhcmUgZG9uZSBsYXppbHkgYXQge0BsaW5rICNnZXRUZXh0fS10aW1lLCBvcGVyYXRpb25zIGRvXHJcbiAqIG5vdCBzY3JldyB1cCB0aGUgdG9rZW4gaW5kZXggdmFsdWVzLiBUaGF0IGlzLCBhbiBpbnNlcnQgb3BlcmF0aW9uIGF0IHRva2VuXHJcbiAqIGluZGV4IGBpYCBkb2VzIG5vdCBjaGFuZ2UgdGhlIGluZGV4IHZhbHVlcyBmb3IgdG9rZW5zXHJcbiAqIGBpYCsxLi5uLTEuXHJcbiAqXHJcbiAqIEJlY2F1c2Ugb3BlcmF0aW9ucyBuZXZlciBhY3R1YWxseSBhbHRlciB0aGUgYnVmZmVyLCB5b3UgbWF5IGFsd2F5cyBnZXQgdGhlXHJcbiAqIG9yaWdpbmFsIHRva2VuIHN0cmVhbSBiYWNrIHdpdGhvdXQgdW5kb2luZyBhbnl0aGluZy4gU2luY2UgdGhlIGluc3RydWN0aW9uc1xyXG4gKiBhcmUgcXVldWVkIHVwLCB5b3UgY2FuIGVhc2lseSBzaW11bGF0ZSB0cmFuc2FjdGlvbnMgYW5kIHJvbGwgYmFjayBhbnkgY2hhbmdlc1xyXG4gKiBpZiB0aGVyZSBpcyBhbiBlcnJvciBqdXN0IGJ5IHJlbW92aW5nIGluc3RydWN0aW9ucy4gRm9yIGV4YW1wbGUsXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBDaGFyU3RyZWFtIGlucHV0ID0gbmV3IEFOVExSRmlsZVN0cmVhbShcImlucHV0XCIpO1xyXG4gKiBUTGV4ZXIgbGV4ID0gbmV3IFRMZXhlcihpbnB1dCk7XHJcbiAqIENvbW1vblRva2VuU3RyZWFtIHRva2VucyA9IG5ldyBDb21tb25Ub2tlblN0cmVhbShsZXgpO1xyXG4gKiBUIHBhcnNlciA9IG5ldyBUKHRva2Vucyk7XHJcbiAqIFRva2VuU3RyZWFtUmV3cml0ZXIgcmV3cml0ZXIgPSBuZXcgVG9rZW5TdHJlYW1SZXdyaXRlcih0b2tlbnMpO1xyXG4gKiBwYXJzZXIuc3RhcnRSdWxlKCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGVuIGluIHRoZSBydWxlcywgeW91IGNhbiBleGVjdXRlIChhc3N1bWluZyByZXdyaXRlciBpcyB2aXNpYmxlKTpcclxuICpcclxuICogYGBgXHJcbiAqIFRva2VuIHQsdTtcclxuICogLi4uXHJcbiAqIHJld3JpdGVyLmluc2VydEFmdGVyKHQsIFwidGV4dCB0byBwdXQgYWZ0ZXIgdFwiKTt9XHJcbiAqIHJld3JpdGVyLmluc2VydEFmdGVyKHUsIFwidGV4dCBhZnRlciB1XCIpO31cclxuICogU3lzdGVtLm91dC5wcmludGxuKHJld3JpdGVyLmdldFRleHQoKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBZb3UgY2FuIGFsc28gaGF2ZSBtdWx0aXBsZSBcImluc3RydWN0aW9uIHN0cmVhbXNcIiBhbmQgZ2V0IG11bHRpcGxlIHJld3JpdGVzXHJcbiAqIGZyb20gYSBzaW5nbGUgcGFzcyBvdmVyIHRoZSBpbnB1dC4gSnVzdCBuYW1lIHRoZSBpbnN0cnVjdGlvbiBzdHJlYW1zIGFuZCB1c2VcclxuICogdGhhdCBuYW1lIGFnYWluIHdoZW4gcHJpbnRpbmcgdGhlIGJ1ZmZlci4gVGhpcyBjb3VsZCBiZSB1c2VmdWwgZm9yIGdlbmVyYXRpbmdcclxuICogYSBDIGZpbGUgYW5kIGFsc28gaXRzIGhlYWRlciBmaWxlLS1hbGwgZnJvbSB0aGUgc2FtZSBidWZmZXI6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiByZXdyaXRlci5pbnNlcnRBZnRlcihcInBhc3MxXCIsIHQsIFwidGV4dCB0byBwdXQgYWZ0ZXIgdFwiKTt9XHJcbiAqIHJld3JpdGVyLmluc2VydEFmdGVyKFwicGFzczJcIiwgdSwgXCJ0ZXh0IGFmdGVyIHVcIik7fVxyXG4gKiBTeXN0ZW0ub3V0LnByaW50bG4ocmV3cml0ZXIuZ2V0VGV4dChcInBhc3MxXCIpKTtcclxuICogU3lzdGVtLm91dC5wcmludGxuKHJld3JpdGVyLmdldFRleHQoXCJwYXNzMlwiKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBJZiB5b3UgZG9uJ3QgdXNlIG5hbWVkIHJld3JpdGUgc3RyZWFtcywgYSBcImRlZmF1bHRcIiBzdHJlYW0gaXMgdXNlZCBhcyB0aGVcclxuICogZmlyc3QgZXhhbXBsZSBzaG93cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUb2tlblN0cmVhbVJld3JpdGVyIHtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfUFJPR1JBTV9OQU1FOiBzdHJpbmcgPSAgXCJkZWZhdWx0XCI7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBQUk9HUkFNX0lOSVRfU0laRTogbnVtYmVyID0gIDEwMDtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE1JTl9UT0tFTl9JTkRFWDogbnVtYmVyID0gIDA7XHJcblxyXG5cdC8qKiBPdXIgc291cmNlIHN0cmVhbSAqL1xyXG5cdHByb3RlY3RlZCB0b2tlbnM6IFRva2VuU3RyZWFtO1xyXG5cclxuXHQvKiogWW91IG1heSBoYXZlIG11bHRpcGxlLCBuYW1lZCBzdHJlYW1zIG9mIHJld3JpdGUgb3BlcmF0aW9ucy5cclxuXHQgKiAgSSdtIGNhbGxpbmcgdGhlc2UgdGhpbmdzIFwicHJvZ3JhbXMuXCJcclxuXHQgKiAgTWFwcyBTdHJpbmcgKG5hbWUpICZyYXJyOyByZXdyaXRlIChMaXN0KVxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBwcm9ncmFtczogTWFwPHN0cmluZywgUmV3cml0ZU9wZXJhdGlvbltdPjtcclxuXHJcblx0LyoqIE1hcCBTdHJpbmcgKHByb2dyYW0gbmFtZSkgJnJhcnI7IEludGVnZXIgaW5kZXggKi9cclxuXHRwcm90ZWN0ZWQgbGFzdFJld3JpdGVUb2tlbkluZGV4ZXM6IE1hcDxzdHJpbmcsIG51bWJlcj47XHJcblxyXG5cdGNvbnN0cnVjdG9yKHRva2VuczogVG9rZW5TdHJlYW0pICB7XHJcblx0XHR0aGlzLnRva2VucyA9IHRva2VucztcclxuXHRcdHRoaXMucHJvZ3JhbXMgPSBuZXcgTWFwPHN0cmluZywgUmV3cml0ZU9wZXJhdGlvbltdPigpO1xyXG5cdFx0dGhpcy5wcm9ncmFtcy5zZXQoVG9rZW5TdHJlYW1SZXdyaXRlci5ERUZBVUxUX1BST0dSQU1fTkFNRSwgW10pO1xyXG5cdFx0dGhpcy5sYXN0UmV3cml0ZVRva2VuSW5kZXhlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0VG9rZW5TdHJlYW0oKTogVG9rZW5TdHJlYW0ge1xyXG5cdFx0cmV0dXJuIHRoaXMudG9rZW5zO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJvbGxiYWNrKGluc3RydWN0aW9uSW5kZXg6IG51bWJlcik6IHZvaWQ7XHJcblx0LyoqIFJvbGxiYWNrIHRoZSBpbnN0cnVjdGlvbiBzdHJlYW0gZm9yIGEgcHJvZ3JhbSBzbyB0aGF0XHJcblx0ICogIHRoZSBpbmRpY2F0ZWQgaW5zdHJ1Y3Rpb24gKHZpYSBpbnN0cnVjdGlvbkluZGV4KSBpcyBub1xyXG5cdCAqICBsb25nZXIgaW4gdGhlIHN0cmVhbS4gVU5URVNURUQhXHJcblx0ICovXHJcblx0cHVibGljIHJvbGxiYWNrKGluc3RydWN0aW9uSW5kZXg6IG51bWJlciwgcHJvZ3JhbU5hbWU6IHN0cmluZyk6IHZvaWQ7XHJcblx0cHVibGljIHJvbGxiYWNrKGluc3RydWN0aW9uSW5kZXg6IG51bWJlciwgcHJvZ3JhbU5hbWU6IHN0cmluZyA9IFRva2VuU3RyZWFtUmV3cml0ZXIuREVGQVVMVF9QUk9HUkFNX05BTUUpOiB2b2lkIHtcclxuXHRcdGxldCBpczogUmV3cml0ZU9wZXJhdGlvbltdIHwgdW5kZWZpbmVkID0gIHRoaXMucHJvZ3JhbXMuZ2V0KHByb2dyYW1OYW1lKTtcclxuXHRcdGlmICggaXMgIT0gbnVsbCApIHtcclxuXHRcdFx0dGhpcy5wcm9ncmFtcy5zZXQocHJvZ3JhbU5hbWUsIGlzLnNsaWNlKFRva2VuU3RyZWFtUmV3cml0ZXIuTUlOX1RPS0VOX0lOREVYLCBpbnN0cnVjdGlvbkluZGV4KSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZGVsZXRlUHJvZ3JhbSgpOiB2b2lkO1xyXG5cclxuXHQvKiogUmVzZXQgdGhlIHByb2dyYW0gc28gdGhhdCBubyBpbnN0cnVjdGlvbnMgZXhpc3QgKi9cclxuXHRwdWJsaWMgZGVsZXRlUHJvZ3JhbShwcm9ncmFtTmFtZTogc3RyaW5nKTogdm9pZDtcclxuXHRwdWJsaWMgZGVsZXRlUHJvZ3JhbShwcm9ncmFtTmFtZTogc3RyaW5nID0gVG9rZW5TdHJlYW1SZXdyaXRlci5ERUZBVUxUX1BST0dSQU1fTkFNRSk6IHZvaWQge1xyXG5cdFx0dGhpcy5yb2xsYmFjayhUb2tlblN0cmVhbVJld3JpdGVyLk1JTl9UT0tFTl9JTkRFWCwgcHJvZ3JhbU5hbWUpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGluc2VydEFmdGVyKHQ6IFRva2VuLCB0ZXh0OiB7fSk6IHZvaWQ7XHJcblx0cHVibGljIGluc2VydEFmdGVyKGluZGV4OiBudW1iZXIsIHRleHQ6IHt9KTogdm9pZDtcclxuXHRwdWJsaWMgaW5zZXJ0QWZ0ZXIodDogVG9rZW4sIHRleHQ6IHt9LCBwcm9ncmFtTmFtZTogc3RyaW5nKTogdm9pZDtcclxuXHRwdWJsaWMgaW5zZXJ0QWZ0ZXIoaW5kZXg6IG51bWJlciwgdGV4dDoge30sIHByb2dyYW1OYW1lOiBzdHJpbmcpOiB2b2lkO1xyXG5cdHB1YmxpYyBpbnNlcnRBZnRlcih0b2tlbk9ySW5kZXg6IFRva2VuIHwgbnVtYmVyLCB0ZXh0OiB7fSwgcHJvZ3JhbU5hbWU6IHN0cmluZyA9IFRva2VuU3RyZWFtUmV3cml0ZXIuREVGQVVMVF9QUk9HUkFNX05BTUUpOiB2b2lkIHtcclxuXHRcdGxldCBpbmRleDogbnVtYmVyO1xyXG5cdFx0aWYgKHR5cGVvZiB0b2tlbk9ySW5kZXggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0aW5kZXggPSB0b2tlbk9ySW5kZXg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbmRleCA9IHRva2VuT3JJbmRleC50b2tlbkluZGV4O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRvIGluc2VydCBhZnRlciwganVzdCBpbnNlcnQgYmVmb3JlIG5leHQgaW5kZXggKGV2ZW4gaWYgcGFzdCBlbmQpXHJcblx0XHRsZXQgcmV3cml0ZXM6IFJld3JpdGVPcGVyYXRpb25bXSA9IHRoaXMuZ2V0UHJvZ3JhbShwcm9ncmFtTmFtZSk7XHJcblx0XHRsZXQgb3AgPSBuZXcgSW5zZXJ0QWZ0ZXJPcCh0aGlzLnRva2VucywgaW5kZXgsIHJld3JpdGVzLmxlbmd0aCwgdGV4dCk7XHJcblx0XHRyZXdyaXRlcy5wdXNoKG9wKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBpbnNlcnRCZWZvcmUodDogVG9rZW4sIHRleHQ6IHt9KTogdm9pZDtcclxuXHRwdWJsaWMgaW5zZXJ0QmVmb3JlKGluZGV4OiBudW1iZXIsIHRleHQ6IHt9KTogdm9pZDtcclxuXHRwdWJsaWMgaW5zZXJ0QmVmb3JlKHQ6IFRva2VuLCB0ZXh0OiB7fSwgcHJvZ3JhbU5hbWU6IHN0cmluZyk6IHZvaWQ7XHJcblx0cHVibGljIGluc2VydEJlZm9yZShpbmRleDogbnVtYmVyLCB0ZXh0OiB7fSwgcHJvZ3JhbU5hbWU6IHN0cmluZyk6IHZvaWQ7XHJcblx0cHVibGljIGluc2VydEJlZm9yZSh0b2tlbk9ySW5kZXg6IFRva2VuIHwgbnVtYmVyLCB0ZXh0OiB7fSwgcHJvZ3JhbU5hbWU6IHN0cmluZyA9IFRva2VuU3RyZWFtUmV3cml0ZXIuREVGQVVMVF9QUk9HUkFNX05BTUUpOiB2b2lkIHtcclxuXHRcdGxldCBpbmRleDogbnVtYmVyO1xyXG5cdFx0aWYgKHR5cGVvZiB0b2tlbk9ySW5kZXggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0aW5kZXggPSB0b2tlbk9ySW5kZXg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbmRleCA9IHRva2VuT3JJbmRleC50b2tlbkluZGV4O1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZXdyaXRlczogUmV3cml0ZU9wZXJhdGlvbltdID0gdGhpcy5nZXRQcm9ncmFtKHByb2dyYW1OYW1lKTtcclxuXHRcdGxldCBvcDogUmV3cml0ZU9wZXJhdGlvbiA9IG5ldyBJbnNlcnRCZWZvcmVPcCh0aGlzLnRva2VucywgaW5kZXgsIHJld3JpdGVzLmxlbmd0aCwgdGV4dCk7XHJcblx0XHRyZXdyaXRlcy5wdXNoKG9wKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyByZXBsYWNlU2luZ2xlKGluZGV4OiBudW1iZXIsIHRleHQ6IHt9KTogdm9pZDtcclxuXHRwdWJsaWMgcmVwbGFjZVNpbmdsZShpbmRleFQ6IFRva2VuLCB0ZXh0OiB7fSk6IHZvaWQ7XHJcblx0cHVibGljIHJlcGxhY2VTaW5nbGUoaW5kZXg6IFRva2VuIHwgbnVtYmVyLCB0ZXh0OiB7fSk6IHZvaWQge1xyXG5cdFx0aWYgKHR5cGVvZiBpbmRleCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHR0aGlzLnJlcGxhY2UoaW5kZXgsIGluZGV4LCB0ZXh0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMucmVwbGFjZShpbmRleCwgaW5kZXgsIHRleHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIHJlcGxhY2UoZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCB0ZXh0OiB7fSk6IHZvaWQ7XHJcblxyXG5cdHB1YmxpYyByZXBsYWNlKGZyb206IFRva2VuLCB0bzogVG9rZW4sIHRleHQ6IHt9KTogdm9pZDtcclxuXHJcblx0cHVibGljIHJlcGxhY2UoZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCB0ZXh0OiB7fSwgcHJvZ3JhbU5hbWU6IHN0cmluZyk6IHZvaWQ7XHJcblxyXG5cdHB1YmxpYyByZXBsYWNlKGZyb206IFRva2VuLCB0bzogVG9rZW4sIHRleHQ6IHt9LCBwcm9ncmFtTmFtZTogc3RyaW5nKTogdm9pZDtcclxuXHJcblx0cHVibGljIHJlcGxhY2UoZnJvbTogVG9rZW4gfCBudW1iZXIsIHRvOiBUb2tlbiB8IG51bWJlciwgdGV4dDoge30sIHByb2dyYW1OYW1lOiBzdHJpbmcgPSBUb2tlblN0cmVhbVJld3JpdGVyLkRFRkFVTFRfUFJPR1JBTV9OQU1FKTogdm9pZCB7XHJcblx0XHRpZiAodHlwZW9mIGZyb20gIT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0ZnJvbSA9IGZyb20udG9rZW5JbmRleDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIHRvICE9PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHRvID0gdG8udG9rZW5JbmRleDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGZyb20gPiB0byB8fCBmcm9tIDwgMCB8fCB0byA8IDAgfHwgdG8gPj0gdGhpcy50b2tlbnMuc2l6ZSApIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoYHJlcGxhY2U6IHJhbmdlIGludmFsaWQ6ICR7ZnJvbX0uLiR7dG99KHNpemU9JHt0aGlzLnRva2Vucy5zaXplfSlgKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmV3cml0ZXM6IFJld3JpdGVPcGVyYXRpb25bXSA9IHRoaXMuZ2V0UHJvZ3JhbShwcm9ncmFtTmFtZSk7XHJcblx0XHRsZXQgb3A6IFJld3JpdGVPcGVyYXRpb24gPSAgbmV3IFJlcGxhY2VPcCh0aGlzLnRva2VucywgZnJvbSwgdG8sIHJld3JpdGVzLmxlbmd0aCwgdGV4dCk7XHJcblx0XHRyZXdyaXRlcy5wdXNoKG9wKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBkZWxldGUoaW5kZXg6IG51bWJlcik6IHZvaWQ7XHJcblxyXG5cdHB1YmxpYyBkZWxldGUoZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0cHVibGljIGRlbGV0ZShpbmRleFQ6IFRva2VuKTogdm9pZDtcclxuXHJcblx0cHVibGljIGRlbGV0ZShmcm9tOiBUb2tlbiwgdG86IFRva2VuKTogdm9pZDtcclxuXHJcblx0cHVibGljIGRlbGV0ZShmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIHByb2dyYW1OYW1lOiBzdHJpbmcpOiB2b2lkO1xyXG5cclxuXHRwdWJsaWMgZGVsZXRlKGZyb206IFRva2VuLCB0bzogVG9rZW4sIHByb2dyYW1OYW1lOiBzdHJpbmcpOiB2b2lkO1xyXG5cclxuXHRwdWJsaWMgZGVsZXRlKGZyb206IFRva2VuIHwgbnVtYmVyLCB0bz86IFRva2VuIHwgbnVtYmVyLCBwcm9ncmFtTmFtZTogc3RyaW5nID0gVG9rZW5TdHJlYW1SZXdyaXRlci5ERUZBVUxUX1BST0dSQU1fTkFNRSk6IHZvaWQge1xyXG5cdFx0aWYgKHRvID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dG8gPSBmcm9tO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2YgZnJvbSA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHR0aGlzLnJlcGxhY2UoZnJvbSwgdG8gYXMgbnVtYmVyLCBcIlwiLCBwcm9ncmFtTmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnJlcGxhY2UoZnJvbSwgdG8gYXMgVG9rZW4sIFwiXCIsIHByb2dyYW1OYW1lKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRMYXN0UmV3cml0ZVRva2VuSW5kZXgoKTogbnVtYmVyO1xyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0TGFzdFJld3JpdGVUb2tlbkluZGV4KHByb2dyYW1OYW1lOiBzdHJpbmcpOiBudW1iZXI7XHJcblxyXG5cdHByb3RlY3RlZCBnZXRMYXN0UmV3cml0ZVRva2VuSW5kZXgocHJvZ3JhbU5hbWU6IHN0cmluZyA9IFRva2VuU3RyZWFtUmV3cml0ZXIuREVGQVVMVF9QUk9HUkFNX05BTUUpOiBudW1iZXIge1xyXG5cdFx0bGV0IEk6IG51bWJlciB8IHVuZGVmaW5lZCA9IHRoaXMubGFzdFJld3JpdGVUb2tlbkluZGV4ZXMuZ2V0KHByb2dyYW1OYW1lKTtcclxuXHRcdGlmICggSSA9PSBudWxsICkge1xyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgc2V0TGFzdFJld3JpdGVUb2tlbkluZGV4KHByb2dyYW1OYW1lOiBzdHJpbmcsIGk6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5sYXN0UmV3cml0ZVRva2VuSW5kZXhlcy5zZXQocHJvZ3JhbU5hbWUsIGkpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldFByb2dyYW0obmFtZTogc3RyaW5nKTogUmV3cml0ZU9wZXJhdGlvbltdIHtcclxuXHRcdGxldCBpczogUmV3cml0ZU9wZXJhdGlvbltdIHwgdW5kZWZpbmVkID0gdGhpcy5wcm9ncmFtcy5nZXQobmFtZSk7XHJcblx0XHRpZiAoIGlzID09IG51bGwgKSB7XHJcblx0XHRcdGlzID0gdGhpcy5pbml0aWFsaXplUHJvZ3JhbShuYW1lKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXM7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGluaXRpYWxpemVQcm9ncmFtKG5hbWU6IHN0cmluZyk6IFJld3JpdGVPcGVyYXRpb25bXSB7XHJcblx0XHRsZXQgaXM6IFJld3JpdGVPcGVyYXRpb25bXSA9IFtdO1xyXG5cdFx0dGhpcy5wcm9ncmFtcy5zZXQobmFtZSwgaXMpO1xyXG5cdFx0cmV0dXJuIGlzO1xyXG5cdH1cclxuXHJcblx0LyoqIFJldHVybiB0aGUgdGV4dCBmcm9tIHRoZSBvcmlnaW5hbCB0b2tlbnMgYWx0ZXJlZCBwZXIgdGhlXHJcblx0ICogIGluc3RydWN0aW9ucyBnaXZlbiB0byB0aGlzIHJld3JpdGVyLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRUZXh0KCk6IHN0cmluZztcclxuXHJcblx0LyoqIFJldHVybiB0aGUgdGV4dCBmcm9tIHRoZSBvcmlnaW5hbCB0b2tlbnMgYWx0ZXJlZCBwZXIgdGhlXHJcblx0ICogIGluc3RydWN0aW9ucyBnaXZlbiB0byB0aGlzIHJld3JpdGVyIGluIHByb2dyYW1OYW1lLlxyXG5cdCAqXHJcblx0ICogQHNpbmNlIDQuNVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRUZXh0KHByb2dyYW1OYW1lOiBzdHJpbmcpOiBzdHJpbmc7XHJcblxyXG5cdC8qKiBSZXR1cm4gdGhlIHRleHQgYXNzb2NpYXRlZCB3aXRoIHRoZSB0b2tlbnMgaW4gdGhlIGludGVydmFsIGZyb20gdGhlXHJcblx0ICogIG9yaWdpbmFsIHRva2VuIHN0cmVhbSBidXQgd2l0aCB0aGUgYWx0ZXJhdGlvbnMgZ2l2ZW4gdG8gdGhpcyByZXdyaXRlci5cclxuXHQgKiAgVGhlIGludGVydmFsIHJlZmVycyB0byB0aGUgaW5kZXhlcyBpbiB0aGUgb3JpZ2luYWwgdG9rZW4gc3RyZWFtLlxyXG5cdCAqICBXZSBkbyBub3QgYWx0ZXIgdGhlIHRva2VuIHN0cmVhbSBpbiBhbnkgd2F5LCBzbyB0aGUgaW5kZXhlc1xyXG5cdCAqICBhbmQgaW50ZXJ2YWxzIGFyZSBzdGlsbCBjb25zaXN0ZW50LiBJbmNsdWRlcyBhbnkgb3BlcmF0aW9ucyBkb25lXHJcblx0ICogIHRvIHRoZSBmaXJzdCBhbmQgbGFzdCB0b2tlbiBpbiB0aGUgaW50ZXJ2YWwuIFNvLCBpZiB5b3UgZGlkIGFuXHJcblx0ICogIGluc2VydEJlZm9yZSBvbiB0aGUgZmlyc3QgdG9rZW4sIHlvdSB3b3VsZCBnZXQgdGhhdCBpbnNlcnRpb24uXHJcblx0ICogIFRoZSBzYW1lIGlzIHRydWUgaWYgeW91IGRvIGFuIGluc2VydEFmdGVyIHRoZSBzdG9wIHRva2VuLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRUZXh0KGludGVydmFsOiBJbnRlcnZhbCk6IHN0cmluZztcclxuXHJcblx0cHVibGljIGdldFRleHQoaW50ZXJ2YWw6IEludGVydmFsLCBwcm9ncmFtTmFtZTogc3RyaW5nKTogc3RyaW5nO1xyXG5cclxuXHRwdWJsaWMgZ2V0VGV4dChpbnRlcnZhbE9yUHJvZ3JhbT86IEludGVydmFsIHwgc3RyaW5nLCBwcm9ncmFtTmFtZTogc3RyaW5nID0gVG9rZW5TdHJlYW1SZXdyaXRlci5ERUZBVUxUX1BST0dSQU1fTkFNRSk6IHN0cmluZyB7XHJcblx0XHRsZXQgaW50ZXJ2YWw6IEludGVydmFsO1xyXG5cdFx0aWYgKGludGVydmFsT3JQcm9ncmFtIGluc3RhbmNlb2YgSW50ZXJ2YWwpIHtcclxuXHRcdFx0aW50ZXJ2YWwgPSBpbnRlcnZhbE9yUHJvZ3JhbTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGludGVydmFsID0gSW50ZXJ2YWwub2YoMCwgdGhpcy50b2tlbnMuc2l6ZSAtIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2YgaW50ZXJ2YWxPclByb2dyYW0gPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0cHJvZ3JhbU5hbWUgPSBpbnRlcnZhbE9yUHJvZ3JhbTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmV3cml0ZXM6IFJld3JpdGVPcGVyYXRpb25bXSB8IHVuZGVmaW5lZCA9IHRoaXMucHJvZ3JhbXMuZ2V0KHByb2dyYW1OYW1lKTtcclxuXHRcdGxldCBzdGFydDogbnVtYmVyID0gIGludGVydmFsLmE7XHJcblx0XHRsZXQgc3RvcDogbnVtYmVyID0gIGludGVydmFsLmI7XHJcblxyXG5cdFx0Ly8gZW5zdXJlIHN0YXJ0L2VuZCBhcmUgaW4gcmFuZ2VcclxuXHRcdGlmICggc3RvcCA+IHRoaXMudG9rZW5zLnNpemUgLSAxICkge1xyXG5cdFx0XHRzdG9wID0gdGhpcy50b2tlbnMuc2l6ZSAtIDE7XHJcblx0XHR9XHJcblx0XHRpZiAoIHN0YXJ0IDwgMCApIHtcclxuXHRcdFx0c3RhcnQgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmV3cml0ZXMgPT0gbnVsbCB8fCByZXdyaXRlcy5sZW5ndGggPT09IDAgKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRva2Vucy5nZXRUZXh0KGludGVydmFsKTsgLy8gbm8gaW5zdHJ1Y3Rpb25zIHRvIGV4ZWN1dGVcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYnVmOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuXHRcdC8vIEZpcnN0LCBvcHRpbWl6ZSBpbnN0cnVjdGlvbiBzdHJlYW1cclxuXHRcdGxldCBpbmRleFRvT3A6IE1hcDxudW1iZXIsIFJld3JpdGVPcGVyYXRpb24+ID0gdGhpcy5yZWR1Y2VUb1NpbmdsZU9wZXJhdGlvblBlckluZGV4KHJld3JpdGVzKTtcclxuXHJcblx0XHQvLyBXYWxrIGJ1ZmZlciwgZXhlY3V0aW5nIGluc3RydWN0aW9ucyBhbmQgZW1pdHRpbmcgdG9rZW5zXHJcblx0XHRsZXQgaTogbnVtYmVyID0gIHN0YXJ0O1xyXG5cdFx0d2hpbGUgKCBpIDw9IHN0b3AgJiYgaSA8IHRoaXMudG9rZW5zLnNpemUgKSB7XHJcblx0XHRcdGxldCBvcDogUmV3cml0ZU9wZXJhdGlvbiB8IHVuZGVmaW5lZCA9ICBpbmRleFRvT3AuZ2V0KGkpO1xyXG5cdFx0XHRpbmRleFRvT3AuZGVsZXRlKGkpOyAvLyByZW1vdmUgc28gYW55IGxlZnQgaGF2ZSBpbmRleCBzaXplLTFcclxuXHRcdFx0bGV0IHQ6IFRva2VuID0gdGhpcy50b2tlbnMuZ2V0KGkpO1xyXG5cdFx0XHRpZiAoIG9wID09IG51bGwgKSB7XHJcblx0XHRcdFx0Ly8gbm8gb3BlcmF0aW9uIGF0IHRoYXQgaW5kZXgsIGp1c3QgZHVtcCB0b2tlblxyXG5cdFx0XHRcdGlmICggdC50eXBlICE9PSBUb2tlbi5FT0YgKSB7XHJcblx0XHRcdFx0XHRidWYucHVzaChTdHJpbmcodC50ZXh0KSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkrKzsgLy8gbW92ZSB0byBuZXh0IHRva2VuXHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0aSA9IG9wLmV4ZWN1dGUoYnVmKTsgLy8gZXhlY3V0ZSBvcGVyYXRpb24gYW5kIHNraXBcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluY2x1ZGUgc3R1ZmYgYWZ0ZXIgZW5kIGlmIGl0J3MgbGFzdCBpbmRleCBpbiBidWZmZXJcclxuXHRcdC8vIFNvLCBpZiB0aGV5IGRpZCBhbiBpbnNlcnRBZnRlcihsYXN0VmFsaWRJbmRleCwgXCJmb29cIiksIGluY2x1ZGVcclxuXHRcdC8vIGZvbyBpZiBlbmQ9PWxhc3RWYWxpZEluZGV4LlxyXG5cdFx0aWYgKCBzdG9wID09PSB0aGlzLnRva2Vucy5zaXplIC0gMSApIHtcclxuXHRcdFx0Ly8gU2NhbiBhbnkgcmVtYWluaW5nIG9wZXJhdGlvbnMgYWZ0ZXIgbGFzdCB0b2tlblxyXG5cdFx0XHQvLyBzaG91bGQgYmUgaW5jbHVkZWQgKHRoZXkgd2lsbCBiZSBpbnNlcnRzKS5cclxuXHRcdFx0Zm9yIChsZXQgb3Agb2YgaW5kZXhUb09wLnZhbHVlcygpKSB7XHJcblx0XHRcdFx0aWYgKCBvcC5pbmRleCA+PSB0aGlzLnRva2Vucy5zaXplIC0gMSApIHtcclxuXHRcdFx0XHRcdGJ1Zi5wdXNoKG9wLnRleHQudG9TdHJpbmcoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJ1Zi5qb2luKFwiXCIpO1xyXG5cdH1cclxuXHJcblx0LyoqIFdlIG5lZWQgdG8gY29tYmluZSBvcGVyYXRpb25zIGFuZCByZXBvcnQgaW52YWxpZCBvcGVyYXRpb25zIChsaWtlXHJcblx0ICogIG92ZXJsYXBwaW5nIHJlcGxhY2VzIHRoYXQgYXJlIG5vdCBjb21wbGV0ZWQgbmVzdGVkKS4gSW5zZXJ0cyB0b1xyXG5cdCAqICBzYW1lIGluZGV4IG5lZWQgdG8gYmUgY29tYmluZWQgZXRjLi4uICBIZXJlIGFyZSB0aGUgY2FzZXM6XHJcblx0ICpcclxuXHQgKiAgSS5pLnUgSS5qLnZcdFx0XHRcdFx0XHRcdFx0bGVhdmUgYWxvbmUsIG5vbm92ZXJsYXBwaW5nXHJcblx0ICogIEkuaS51IEkuaS52XHRcdFx0XHRcdFx0XHRcdGNvbWJpbmU6IElpdnVcclxuXHQgKlxyXG5cdCAqICBSLmktai51IFIueC15LnZcdHwgaS1qIGluIHgteVx0XHRcdGRlbGV0ZSBmaXJzdCBSXHJcblx0ICogIFIuaS1qLnUgUi5pLWoudlx0XHRcdFx0XHRcdFx0ZGVsZXRlIGZpcnN0IFJcclxuXHQgKiAgUi5pLWoudSBSLngteS52XHR8IHgteSBpbiBpLWpcdFx0XHRFUlJPUlxyXG5cdCAqICBSLmktai51IFIueC15LnZcdHwgYm91bmRhcmllcyBvdmVybGFwXHRFUlJPUlxyXG5cdCAqXHJcblx0ICogIERlbGV0ZSBzcGVjaWFsIGNhc2Ugb2YgcmVwbGFjZSAodGV4dD09dW5kZWZpbmVkKTpcclxuXHQgKiAgRC5pLWoudSBELngteS52XHR8IGJvdW5kYXJpZXMgb3ZlcmxhcFx0Y29tYmluZSB0byBtYXgobWluKS4ubWF4KHJpZ2h0KVxyXG5cdCAqXHJcblx0ICogIEkuaS51IFIueC15LnYgfCBpIGluICh4KzEpLXlcdFx0XHRkZWxldGUgSSAoc2luY2UgaW5zZXJ0IGJlZm9yZVxyXG5cdCAqIFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3ZSdyZSBub3QgZGVsZXRpbmcgaSlcclxuXHQgKiAgSS5pLnUgUi54LXkudiB8IGkgbm90IGluICh4KzEpLXlcdFx0bGVhdmUgYWxvbmUsIG5vbm92ZXJsYXBwaW5nXHJcblx0ICogIFIueC15LnYgSS5pLnUgfCBpIGluIHgteVx0XHRcdFx0RVJST1JcclxuXHQgKiAgUi54LXkudiBJLngudSBcdFx0XHRcdFx0XHRcdFIueC15LnV2IChjb21iaW5lLCBkZWxldGUgSSlcclxuXHQgKiAgUi54LXkudiBJLmkudSB8IGkgbm90IGluIHgteVx0XHRcdGxlYXZlIGFsb25lLCBub25vdmVybGFwcGluZ1xyXG5cdCAqXHJcblx0ICogIEkuaS51ID0gaW5zZXJ0IHUgYmVmb3JlIG9wIEAgaW5kZXggaVxyXG5cdCAqICBSLngteS51ID0gcmVwbGFjZSB4LXkgaW5kZXhlZCB0b2tlbnMgd2l0aCB1XHJcblx0ICpcclxuXHQgKiAgRmlyc3Qgd2UgbmVlZCB0byBleGFtaW5lIHJlcGxhY2VzLiBGb3IgYW55IHJlcGxhY2Ugb3A6XHJcblx0ICpcclxuXHQgKiBcdFx0MS4gd2lwZSBvdXQgYW55IGluc2VydGlvbnMgYmVmb3JlIG9wIHdpdGhpbiB0aGF0IHJhbmdlLlxyXG5cdCAqIFx0XHQyLiBEcm9wIGFueSByZXBsYWNlIG9wIGJlZm9yZSB0aGF0IGlzIGNvbnRhaW5lZCBjb21wbGV0ZWx5IHdpdGhpblxyXG5cdCAqIFx0IHRoYXQgcmFuZ2UuXHJcblx0ICogXHRcdDMuIFRocm93IGV4Y2VwdGlvbiB1cG9uIGJvdW5kYXJ5IG92ZXJsYXAgd2l0aCBhbnkgcHJldmlvdXMgcmVwbGFjZS5cclxuXHQgKlxyXG5cdCAqICBUaGVuIHdlIGNhbiBkZWFsIHdpdGggaW5zZXJ0czpcclxuXHQgKlxyXG5cdCAqIFx0XHQxLiBmb3IgYW55IGluc2VydHMgdG8gc2FtZSBpbmRleCwgY29tYmluZSBldmVuIGlmIG5vdCBhZGphY2VudC5cclxuXHQgKiBcdFx0Mi4gZm9yIGFueSBwcmlvciByZXBsYWNlIHdpdGggc2FtZSBsZWZ0IGJvdW5kYXJ5LCBjb21iaW5lIHRoaXNcclxuXHQgKiBcdCBpbnNlcnQgd2l0aCByZXBsYWNlIGFuZCBkZWxldGUgdGhpcyByZXBsYWNlLlxyXG5cdCAqIFx0XHQzLiB0aHJvdyBleGNlcHRpb24gaWYgaW5kZXggaW4gc2FtZSByYW5nZSBhcyBwcmV2aW91cyByZXBsYWNlXHJcblx0ICpcclxuXHQgKiAgRG9uJ3QgYWN0dWFsbHkgZGVsZXRlOyBtYWtlIG9wIHVuZGVmaW5lZCBpbiBsaXN0LiBFYXNpZXIgdG8gd2FsayBsaXN0LlxyXG5cdCAqICBMYXRlciB3ZSBjYW4gdGhyb3cgYXMgd2UgYWRkIHRvIGluZGV4ICZyYXJyOyBvcCBtYXAuXHJcblx0ICpcclxuXHQgKiAgTm90ZSB0aGF0IEkuMiBSLjItMiB3aWxsIHdpcGUgb3V0IEkuMiBldmVuIHRob3VnaCwgdGVjaG5pY2FsbHksIHRoZVxyXG5cdCAqICBpbnNlcnRlZCBzdHVmZiB3b3VsZCBiZSBiZWZvcmUgdGhlIHJlcGxhY2UgcmFuZ2UuIEJ1dCwgaWYgeW91XHJcblx0ICogIGFkZCB0b2tlbnMgaW4gZnJvbnQgb2YgYSBtZXRob2QgYm9keSAneycgYW5kIHRoZW4gZGVsZXRlIHRoZSBtZXRob2RcclxuXHQgKiAgYm9keSwgSSB0aGluayB0aGUgc3R1ZmYgYmVmb3JlIHRoZSAneycgeW91IGFkZGVkIHNob3VsZCBkaXNhcHBlYXIgdG9vLlxyXG5cdCAqXHJcblx0ICogIFJldHVybiBhIG1hcCBmcm9tIHRva2VuIGluZGV4IHRvIG9wZXJhdGlvbi5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcmVkdWNlVG9TaW5nbGVPcGVyYXRpb25QZXJJbmRleChyZXdyaXRlczogQXJyYXk8UmV3cml0ZU9wZXJhdGlvbiB8IHVuZGVmaW5lZD4pOiBNYXA8bnVtYmVyLCBSZXdyaXRlT3BlcmF0aW9uPiB7XHJcblx0XHQvLyBjb25zb2xlLmxvZyhgcmV3cml0ZXM9WyR7VXRpbHMuam9pbihyZXdyaXRlcywgXCIsIFwiKX1dYCk7XHJcblxyXG5cdFx0Ly8gV0FMSyBSRVBMQUNFU1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZXdyaXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgb3A6IFJld3JpdGVPcGVyYXRpb24gfCB1bmRlZmluZWQgPSByZXdyaXRlc1tpXTtcclxuXHRcdFx0aWYgKCBvcCA9PSBudWxsICkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICggIShvcCBpbnN0YW5jZW9mIFJlcGxhY2VPcCkgKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IHJvcDogUmVwbGFjZU9wID0gb3A7XHJcblx0XHRcdC8vIFdpcGUgcHJpb3IgaW5zZXJ0cyB3aXRoaW4gcmFuZ2VcclxuXHRcdFx0bGV0IGluc2VydHM6IEluc2VydEJlZm9yZU9wW10gPSB0aGlzLmdldEtpbmRPZk9wcyhyZXdyaXRlcywgSW5zZXJ0QmVmb3JlT3AsIGkpO1xyXG5cdFx0XHRmb3IgKGxldCBpb3Agb2YgaW5zZXJ0cykge1xyXG5cdFx0XHRcdGlmICggaW9wLmluZGV4ID09PSByb3AuaW5kZXggKSB7XHJcblx0XHRcdFx0XHQvLyBFLmcuLCBpbnNlcnQgYmVmb3JlIDIsIGRlbGV0ZSAyLi4yOyB1cGRhdGUgcmVwbGFjZVxyXG5cdFx0XHRcdFx0Ly8gdGV4dCB0byBpbmNsdWRlIGluc2VydCBiZWZvcmUsIGtpbGwgaW5zZXJ0XHJcblx0XHRcdFx0XHRyZXdyaXRlc1tpb3AuaW5zdHJ1Y3Rpb25JbmRleF0gPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0XHRyb3AudGV4dCA9IGlvcC50ZXh0LnRvU3RyaW5nKCkgKyAocm9wLnRleHQgIT0gbnVsbCA/IHJvcC50ZXh0LnRvU3RyaW5nKCkgOiBcIlwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoIGlvcC5pbmRleCA+IHJvcC5pbmRleCAmJiBpb3AuaW5kZXggPD0gcm9wLmxhc3RJbmRleCApIHtcclxuXHRcdFx0XHRcdC8vIGRlbGV0ZSBpbnNlcnQgYXMgaXQncyBhIG5vLW9wLlxyXG5cdFx0XHRcdFx0cmV3cml0ZXNbaW9wLmluc3RydWN0aW9uSW5kZXhdID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBEcm9wIGFueSBwcmlvciByZXBsYWNlcyBjb250YWluZWQgd2l0aGluXHJcblx0XHRcdGxldCBwcmV2UmVwbGFjZXM6IFJlcGxhY2VPcFtdID0gdGhpcy5nZXRLaW5kT2ZPcHMocmV3cml0ZXMsIFJlcGxhY2VPcCwgaSk7XHJcblx0XHRcdGZvciAobGV0IHByZXZSb3Agb2YgcHJldlJlcGxhY2VzKSB7XHJcblx0XHRcdFx0aWYgKCBwcmV2Um9wLmluZGV4ID49IHJvcC5pbmRleCAmJiBwcmV2Um9wLmxhc3RJbmRleCA8PSByb3AubGFzdEluZGV4ICkge1xyXG5cdFx0XHRcdFx0Ly8gZGVsZXRlIHJlcGxhY2UgYXMgaXQncyBhIG5vLW9wLlxyXG5cdFx0XHRcdFx0cmV3cml0ZXNbcHJldlJvcC5pbnN0cnVjdGlvbkluZGV4XSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyB0aHJvdyBleGNlcHRpb24gdW5sZXNzIGRpc2pvaW50IG9yIGlkZW50aWNhbFxyXG5cdFx0XHRcdGxldCBkaXNqb2ludDogYm9vbGVhbiA9XHJcblx0XHRcdFx0XHRwcmV2Um9wLmxhc3RJbmRleCA8IHJvcC5pbmRleCB8fCBwcmV2Um9wLmluZGV4ID4gcm9wLmxhc3RJbmRleDtcclxuXHRcdFx0XHQvLyBEZWxldGUgc3BlY2lhbCBjYXNlIG9mIHJlcGxhY2UgKHRleHQ9PW51bGwpOlxyXG5cdFx0XHRcdC8vIEQuaS1qLnUgRC54LXkudlx0fCBib3VuZGFyaWVzIG92ZXJsYXBcdGNvbWJpbmUgdG8gbWF4KG1pbikuLm1heChyaWdodClcclxuXHRcdFx0XHRpZiAoIHByZXZSb3AudGV4dCA9PSBudWxsICYmIHJvcC50ZXh0ID09IG51bGwgJiYgIWRpc2pvaW50ICkge1xyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coYG92ZXJsYXBwaW5nIGRlbGV0ZXM6ICR7cHJldlJvcH0sICR7cm9wfWApO1xyXG5cdFx0XHRcdFx0cmV3cml0ZXNbcHJldlJvcC5pbnN0cnVjdGlvbkluZGV4XSA9IHVuZGVmaW5lZDsgLy8ga2lsbCBmaXJzdCBkZWxldGVcclxuXHRcdFx0XHRcdHJvcC5pbmRleCA9IE1hdGgubWluKHByZXZSb3AuaW5kZXgsIHJvcC5pbmRleCk7XHJcblx0XHRcdFx0XHRyb3AubGFzdEluZGV4ID0gTWF0aC5tYXgocHJldlJvcC5sYXN0SW5kZXgsIHJvcC5sYXN0SW5kZXgpO1xyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coYG5ldyByb3AgJHtyb3B9YCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKCAhZGlzam9pbnQgKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHJlcGxhY2Ugb3AgYm91bmRhcmllcyBvZiAke3JvcH0gb3ZlcmxhcCB3aXRoIHByZXZpb3VzICR7cHJldlJvcH1gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBXQUxLIElOU0VSVFNcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmV3cml0ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IG9wOiBSZXdyaXRlT3BlcmF0aW9uIHwgdW5kZWZpbmVkID0gcmV3cml0ZXNbaV07XHJcblx0XHRcdGlmICggb3AgPT0gbnVsbCApIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoICEob3AgaW5zdGFuY2VvZiBJbnNlcnRCZWZvcmVPcCkgKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGlvcDogSW5zZXJ0QmVmb3JlT3AgPSAgb3A7XHJcblx0XHRcdC8vIGNvbWJpbmUgY3VycmVudCBpbnNlcnQgd2l0aCBwcmlvciBpZiBhbnkgYXQgc2FtZSBpbmRleFxyXG5cdFx0XHRsZXQgcHJldkluc2VydHM6IEluc2VydEJlZm9yZU9wW10gPSB0aGlzLmdldEtpbmRPZk9wcyhyZXdyaXRlcywgSW5zZXJ0QmVmb3JlT3AsIGkpO1xyXG5cdFx0XHRmb3IgKGxldCBwcmV2SW9wIG9mIHByZXZJbnNlcnRzKSB7XHJcblx0XHRcdFx0aWYgKCBwcmV2SW9wLmluZGV4ID09PSBpb3AuaW5kZXggKSB7XHJcblx0XHRcdFx0XHRpZiAocHJldklvcCBpbnN0YW5jZW9mIEluc2VydEFmdGVyT3ApIHtcclxuXHRcdFx0XHRcdFx0aW9wLnRleHQgPSB0aGlzLmNhdE9wVGV4dChwcmV2SW9wLnRleHQsIGlvcC50ZXh0KTtcclxuXHRcdFx0XHRcdFx0cmV3cml0ZXNbcHJldklvcC5pbnN0cnVjdGlvbkluZGV4XSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgaWYgKHByZXZJb3AgaW5zdGFuY2VvZiBJbnNlcnRCZWZvcmVPcCkgeyAvLyBjb21iaW5lIG9iamVjdHNcclxuXHRcdFx0XHRcdFx0Ly8gY29udmVydCB0byBzdHJpbmdzLi4ud2UncmUgaW4gcHJvY2VzcyBvZiB0b1N0cmluZydpbmdcclxuXHRcdFx0XHRcdFx0Ly8gd2hvbGUgdG9rZW4gYnVmZmVyIHNvIG5vIGxhenkgZXZhbCBpc3N1ZSB3aXRoIGFueSB0ZW1wbGF0ZXNcclxuXHRcdFx0XHRcdFx0aW9wLnRleHQgPSB0aGlzLmNhdE9wVGV4dChpb3AudGV4dCwgcHJldklvcC50ZXh0KTtcclxuXHRcdFx0XHRcdFx0Ly8gZGVsZXRlIHJlZHVuZGFudCBwcmlvciBpbnNlcnRcclxuXHRcdFx0XHRcdFx0cmV3cml0ZXNbcHJldklvcC5pbnN0cnVjdGlvbkluZGV4XSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gbG9vayBmb3IgcmVwbGFjZXMgd2hlcmUgaW9wLmluZGV4IGlzIGluIHJhbmdlOyBlcnJvclxyXG5cdFx0XHRsZXQgcHJldlJlcGxhY2VzOiBSZXBsYWNlT3BbXSA9IHRoaXMuZ2V0S2luZE9mT3BzKHJld3JpdGVzLCBSZXBsYWNlT3AsIGkpO1xyXG5cdFx0XHRmb3IgKGxldCByb3Agb2YgcHJldlJlcGxhY2VzKSB7XHJcblx0XHRcdFx0aWYgKCBpb3AuaW5kZXggPT09IHJvcC5pbmRleCApIHtcclxuXHRcdFx0XHRcdHJvcC50ZXh0ID0gdGhpcy5jYXRPcFRleHQoaW9wLnRleHQsIHJvcC50ZXh0KTtcclxuXHRcdFx0XHRcdHJld3JpdGVzW2ldID0gdW5kZWZpbmVkO1x0Ly8gZGVsZXRlIGN1cnJlbnQgaW5zZXJ0XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCBpb3AuaW5kZXggPj0gcm9wLmluZGV4ICYmIGlvcC5pbmRleCA8PSByb3AubGFzdEluZGV4ICkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBpbnNlcnQgb3AgJHtpb3B9IHdpdGhpbiBib3VuZGFyaWVzIG9mIHByZXZpb3VzICR7cm9wfWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly8gY29uc29sZS5sb2coYHJld3JpdGVzIGFmdGVyPVske1V0aWxzLmpvaW4ocmV3cml0ZXMsIFwiLCBcIil9XWApO1xyXG5cdFx0bGV0IG06IE1hcDxudW1iZXIsIFJld3JpdGVPcGVyYXRpb24+ID0gIG5ldyBNYXA8bnVtYmVyLCBSZXdyaXRlT3BlcmF0aW9uPigpO1xyXG5cdFx0Zm9yIChsZXQgb3Agb2YgcmV3cml0ZXMpIHtcclxuXHRcdFx0aWYgKCBvcCA9PSBudWxsICkge1xyXG5cdFx0XHRcdC8vIGlnbm9yZSBkZWxldGVkIG9wc1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICggbS5nZXQob3AuaW5kZXgpICE9IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2hvdWxkIG9ubHkgYmUgb25lIG9wIHBlciBpbmRleFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRtLnNldChvcC5pbmRleCwgb3ApO1xyXG5cdFx0fVxyXG5cdFx0Ly8gY29uc29sZS5sb2coYGluZGV4IHRvIG9wOiAke219YCk7XHJcblx0XHRyZXR1cm4gbTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBjYXRPcFRleHQoYToge30sIGI6IHt9KTogc3RyaW5nIHtcclxuXHRcdGxldCB4OiBzdHJpbmcgPSAgXCJcIjtcclxuXHRcdGxldCB5OiBzdHJpbmcgPSAgXCJcIjtcclxuXHRcdGlmICggYSAhPSBudWxsICkge1xyXG5cdFx0XHR4ID0gYS50b1N0cmluZygpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCBiICE9IG51bGwgKSB7XHJcblx0XHRcdHkgPSBiLnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4geCArIHk7XHJcblx0fVxyXG5cclxuXHQvKiogR2V0IGFsbCBvcGVyYXRpb25zIGJlZm9yZSBhbiBpbmRleCBvZiBhIHBhcnRpY3VsYXIga2luZCAqL1xyXG5cdHByb3RlY3RlZCBnZXRLaW5kT2ZPcHM8VCBleHRlbmRzIFJld3JpdGVPcGVyYXRpb24+KHJld3JpdGVzOiBBcnJheTxSZXdyaXRlT3BlcmF0aW9uIHwgdW5kZWZpbmVkPiwga2luZDoge25ldyguLi5hcmdzOiBhbnlbXSk6IFR9LCBiZWZvcmU6IG51bWJlcik6IFRbXSB7XHJcblx0XHRsZXQgb3BzOiBUW10gPSBbXTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYmVmb3JlICYmIGkgPCByZXdyaXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgb3A6IFJld3JpdGVPcGVyYXRpb24gfCB1bmRlZmluZWQgPSAgcmV3cml0ZXNbaV07XHJcblx0XHRcdGlmICggb3AgPT0gbnVsbCApIHtcclxuXHRcdFx0XHQvLyBpZ25vcmUgZGVsZXRlZFxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICggb3AgaW5zdGFuY2VvZiBraW5kICkge1xyXG5cdFx0XHRcdG9wcy5wdXNoKG9wKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG9wcztcclxuXHR9XHJcbn1cclxuXHJcbi8vIERlZmluZSB0aGUgcmV3cml0ZSBvcGVyYXRpb24gaGllcmFyY2h5XHJcblxyXG5leHBvcnQgY2xhc3MgUmV3cml0ZU9wZXJhdGlvbiB7XHJcblx0cHJvdGVjdGVkIHJlYWRvbmx5IHRva2VuczogVG9rZW5TdHJlYW07XHJcblx0LyoqIFdoYXQgaW5kZXggaW50byByZXdyaXRlcyBMaXN0IGFyZSB3ZT8gKi9cclxuXHRwdWJsaWMgcmVhZG9ubHkgaW5zdHJ1Y3Rpb25JbmRleDogbnVtYmVyO1xyXG5cdC8qKiBUb2tlbiBidWZmZXIgaW5kZXguICovXHJcblx0cHVibGljIGluZGV4OiBudW1iZXI7XHJcblx0cHVibGljIHRleHQ6IHt9O1xyXG5cclxuXHRjb25zdHJ1Y3Rvcih0b2tlbnM6IFRva2VuU3RyZWFtLCBpbmRleDogbnVtYmVyLCBpbnN0cnVjdGlvbkluZGV4OiBudW1iZXIpO1xyXG5cdGNvbnN0cnVjdG9yKHRva2VuczogVG9rZW5TdHJlYW0sIGluZGV4OiBudW1iZXIsIGluc3RydWN0aW9uSW5kZXg6IG51bWJlciwgdGV4dDoge30pO1xyXG5cdGNvbnN0cnVjdG9yKHRva2VuczogVG9rZW5TdHJlYW0sIGluZGV4OiBudW1iZXIsIGluc3RydWN0aW9uSW5kZXg6IG51bWJlciwgdGV4dD86IHt9KSB7XHJcblx0XHR0aGlzLnRva2VucyA9IHRva2VucztcclxuXHRcdHRoaXMuaW5zdHJ1Y3Rpb25JbmRleCA9IGluc3RydWN0aW9uSW5kZXg7XHJcblx0XHR0aGlzLmluZGV4ID0gaW5kZXg7XHJcblx0XHR0aGlzLnRleHQgPSB0ZXh0ID09PSB1bmRlZmluZWQgPyBcIlwiIDogdGV4dDtcclxuXHR9XHJcblxyXG5cdC8qKiBFeGVjdXRlIHRoZSByZXdyaXRlIG9wZXJhdGlvbiBieSBwb3NzaWJseSBhZGRpbmcgdG8gdGhlIGJ1ZmZlci5cclxuXHQgKiAgUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbmV4dCB0b2tlbiB0byBvcGVyYXRlIG9uLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBleGVjdXRlKGJ1Zjogc3RyaW5nW10pOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW5kZXg7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGxldCBvcE5hbWU6IHN0cmluZyA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuXHRcdGxldCAkaW5kZXggPSBvcE5hbWUuaW5kZXhPZihcIiRcIik7XHJcblx0XHRvcE5hbWUgPSBvcE5hbWUuc3Vic3RyaW5nKCRpbmRleCArIDEsIG9wTmFtZS5sZW5ndGgpO1xyXG5cdFx0cmV0dXJuIFwiPFwiICsgb3BOYW1lICsgXCJAXCIgKyB0aGlzLnRva2Vucy5nZXQodGhpcy5pbmRleCkgK1xyXG5cdFx0XHRcdFwiOlxcXCJcIiArIHRoaXMudGV4dCArIFwiXFxcIj5cIjtcclxuXHR9XHJcbn1cclxuXHJcbmNsYXNzIEluc2VydEJlZm9yZU9wIGV4dGVuZHMgUmV3cml0ZU9wZXJhdGlvbiB7XHJcblx0Y29uc3RydWN0b3IodG9rZW5zOiBUb2tlblN0cmVhbSwgaW5kZXg6IG51bWJlciwgaW5zdHJ1Y3Rpb25JbmRleDogbnVtYmVyLCB0ZXh0OiB7fSkge1xyXG5cdFx0c3VwZXIodG9rZW5zLCBpbmRleCwgaW5zdHJ1Y3Rpb25JbmRleCwgdGV4dCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXhlY3V0ZShidWY6IHN0cmluZ1tdKTogbnVtYmVyIHtcclxuXHRcdGJ1Zi5wdXNoKHRoaXMudGV4dC50b1N0cmluZygpKTtcclxuXHRcdGlmICggdGhpcy50b2tlbnMuZ2V0KHRoaXMuaW5kZXgpLnR5cGUgIT09IFRva2VuLkVPRiApIHtcclxuXHRcdFx0YnVmLnB1c2goU3RyaW5nKHRoaXMudG9rZW5zLmdldCh0aGlzLmluZGV4KS50ZXh0KSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5pbmRleCArIDE7XHJcblx0fVxyXG59XHJcblxyXG4vKiogRGlzdGluZ3Vpc2ggYmV0d2VlbiBpbnNlcnQgYWZ0ZXIvYmVmb3JlIHRvIGRvIHRoZSBcImluc2VydCBhZnRlcnNcIlxyXG4gKiAgZmlyc3QgYW5kIHRoZW4gdGhlIFwiaW5zZXJ0IGJlZm9yZXNcIiBhdCBzYW1lIGluZGV4LiBJbXBsZW1lbnRhdGlvblxyXG4gKiAgb2YgXCJpbnNlcnQgYWZ0ZXJcIiBpcyBcImluc2VydCBiZWZvcmUgaW5kZXgrMVwiLlxyXG4gKi9cclxuY2xhc3MgSW5zZXJ0QWZ0ZXJPcCBleHRlbmRzIEluc2VydEJlZm9yZU9wIHtcclxuXHRjb25zdHJ1Y3Rvcih0b2tlbnM6IFRva2VuU3RyZWFtLCBpbmRleDogbnVtYmVyLCBpbnN0cnVjdGlvbkluZGV4OiBudW1iZXIsIHRleHQ6IHt9KSB7XHJcblx0XHRzdXBlcih0b2tlbnMsIGluZGV4ICsgMSwgaW5zdHJ1Y3Rpb25JbmRleCwgdGV4dCk7IC8vIGluc2VydCBhZnRlciBpcyBpbnNlcnQgYmVmb3JlIGluZGV4KzFcclxuXHR9XHJcbn1cclxuXHJcbi8qKiBJJ20gZ29pbmcgdG8gdHJ5IHJlcGxhY2luZyByYW5nZSBmcm9tIHguLnkgd2l0aCAoeS14KSsxIFJlcGxhY2VPcFxyXG4gKiAgaW5zdHJ1Y3Rpb25zLlxyXG4gKi9cclxuY2xhc3MgUmVwbGFjZU9wIGV4dGVuZHMgUmV3cml0ZU9wZXJhdGlvbiB7XHJcblx0cHVibGljIGxhc3RJbmRleDogbnVtYmVyO1xyXG5cdGNvbnN0cnVjdG9yKHRva2VuczogVG9rZW5TdHJlYW0sIGZyb206IG51bWJlciwgdG86IG51bWJlciwgaW5zdHJ1Y3Rpb25JbmRleDogbnVtYmVyLCB0ZXh0OiB7fSkge1xyXG5cdFx0c3VwZXIodG9rZW5zLCBmcm9tLCBpbnN0cnVjdGlvbkluZGV4LCB0ZXh0KTtcclxuXHRcdHRoaXMubGFzdEluZGV4ID0gdG87XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXhlY3V0ZShidWY6IHN0cmluZ1tdKTogbnVtYmVyIHtcclxuXHRcdGlmICggdGhpcy50ZXh0ICE9IG51bGwgKSB7XHJcblx0XHRcdGJ1Zi5wdXNoKHRoaXMudGV4dC50b1N0cmluZygpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxhc3RJbmRleCArIDE7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGlmICggdGhpcy50ZXh0ID09IG51bGwgKSB7XHJcblx0XHRcdHJldHVybiBcIjxEZWxldGVPcEBcIiArIHRoaXMudG9rZW5zLmdldCh0aGlzLmluZGV4KSArXHJcblx0XHRcdFx0XHRcIi4uXCIgKyB0aGlzLnRva2Vucy5nZXQodGhpcy5sYXN0SW5kZXgpICsgXCI+XCI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gXCI8UmVwbGFjZU9wQFwiICsgdGhpcy50b2tlbnMuZ2V0KHRoaXMuaW5kZXgpICtcclxuXHRcdFx0XHRcIi4uXCIgKyB0aGlzLnRva2Vucy5nZXQodGhpcy5sYXN0SW5kZXgpICsgXCI6XFxcIlwiICsgdGhpcy50ZXh0ICsgXCJcXFwiPlwiO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTkuNDk4NjYxMC0wNzowMFxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIHByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2b2NhYnVsYXJ5IHVzZWQgYnkgYVxyXG4gKiByZWNvZ25pemVyLlxyXG4gKlxyXG4gKiBAc2VlIFJlY29nbml6ZXIudm9jYWJ1bGFyeVxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFZvY2FidWxhcnkge1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBoaWdoZXN0IHRva2VuIHR5cGUgdmFsdWUuIEl0IGNhbiBiZSB1c2VkIHRvIGl0ZXJhdGUgZnJvbVxyXG5cdCAqIHplcm8gdG8gdGhhdCBudW1iZXIsIGluY2x1c2l2ZWx5LCB0aHVzIHF1ZXJ5aW5nIGFsbCBzdG9yZWQgZW50cmllcy5cclxuXHQgKiBAcmV0dXJucyB0aGUgaGlnaGVzdCB0b2tlbiB0eXBlIHZhbHVlXHJcblx0ICovXHJcblx0cmVhZG9ubHkgbWF4VG9rZW5UeXBlOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHN0cmluZyBsaXRlcmFsIGFzc29jaWF0ZWQgd2l0aCBhIHRva2VuIHR5cGUuIFRoZSBzdHJpbmcgcmV0dXJuZWRcclxuXHQgKiBieSB0aGlzIG1ldGhvZCwgd2hlbiBub3QgYHVuZGVmaW5lZGAsIGNhbiBiZSB1c2VkIHVuYWx0ZXJlZCBpbiBhIHBhcnNlclxyXG5cdCAqIGdyYW1tYXIgdG8gcmVwcmVzZW50IHRoaXMgdG9rZW4gdHlwZS5cclxuXHQgKlxyXG5cdCAqIFRoZSBmb2xsb3dpbmcgdGFibGUgc2hvd3MgZXhhbXBsZXMgb2YgbGV4ZXIgcnVsZXMgYW5kIHRoZSBsaXRlcmFsXHJcblx0ICogbmFtZXMgYXNzaWduZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgdG9rZW4gdHlwZXMuXHJcblx0ICpcclxuXHQgKiA8dGFibGU+XHJcblx0ICogIDx0cj5cclxuXHQgKiAgIDx0aD5SdWxlPC90aD5cclxuXHQgKiAgIDx0aD5MaXRlcmFsIE5hbWU8L3RoPlxyXG5cdCAqICAgPHRoPkphdmEgU3RyaW5nIExpdGVyYWw8L3RoPlxyXG5cdCAqICA8L3RyPlxyXG5cdCAqICA8dHI+XHJcblx0ICogICA8dGQ+YFRISVMgOiAndGhpcyc7YDwvdGQ+XHJcblx0ICogICA8dGQ+YCd0aGlzJ2A8L3RkPlxyXG5cdCAqICAgPHRkPmBcIid0aGlzJ1wiYDwvdGQ+XHJcblx0ICogIDwvdHI+XHJcblx0ICogIDx0cj5cclxuXHQgKiAgIDx0ZD5gU1FVT1RFIDogJ1xcJyc7YDwvdGQ+XHJcblx0ICogICA8dGQ+YCdcXCcnYDwvdGQ+XHJcblx0ICogICA8dGQ+YFwiJ1xcXFwnJ1wiYDwvdGQ+XHJcblx0ICogIDwvdHI+XHJcblx0ICogIDx0cj5cclxuXHQgKiAgIDx0ZD5gSUQgOiBbQS1aXSs7YDwvdGQ+XHJcblx0ICogICA8dGQ+bi9hPC90ZD5cclxuXHQgKiAgIDx0ZD5gdW5kZWZpbmVkYDwvdGQ+XHJcblx0ICogIDwvdHI+XHJcblx0ICogPC90YWJsZT5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0b2tlblR5cGUgVGhlIHRva2VuIHR5cGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgc3RyaW5nIGxpdGVyYWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdG9rZW4gdHlwZSwgb3JcclxuXHQgKiBgdW5kZWZpbmVkYCBpZiBubyBzdHJpbmcgbGl0ZXJhbCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0TGl0ZXJhbE5hbWUodG9rZW5UeXBlOiBudW1iZXIpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHN5bWJvbGljIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgdG9rZW4gdHlwZS4gVGhlIHN0cmluZyByZXR1cm5lZFxyXG5cdCAqIGJ5IHRoaXMgbWV0aG9kLCB3aGVuIG5vdCBgdW5kZWZpbmVkYCwgY2FuIGJlIHVzZWQgdW5hbHRlcmVkIGluIGEgcGFyc2VyXHJcblx0ICogZ3JhbW1hciB0byByZXByZXNlbnQgdGhpcyB0b2tlbiB0eXBlLlxyXG5cdCAqXHJcblx0ICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgdG9rZW4gdHlwZXMgZGVmaW5lZCBieSBhbnkgb2YgdGhlIGZvbGxvd2luZ1xyXG5cdCAqIG1ldGhvZHM6XHJcblx0ICpcclxuXHQgKiAqIFRva2VucyBjcmVhdGVkIGJ5IGxleGVyIHJ1bGVzLlxyXG5cdCAqICogVG9rZW5zIGRlZmluZWQgaW4gYSBgdG9rZW5ze31gIGJsb2NrIGluIGEgbGV4ZXIgb3IgcGFyc2VyXHJcblx0ICogICBncmFtbWFyLlxyXG5cdCAqICogVGhlIGltcGxpY2l0bHkgZGVmaW5lZCBgRU9GYCB0b2tlbiwgd2hpY2ggaGFzIHRoZSB0b2tlbiB0eXBlXHJcblx0ICogICB7QGxpbmsgVG9rZW4jRU9GfS5cclxuXHQgKlxyXG5cdCAqIFRoZSBmb2xsb3dpbmcgdGFibGUgc2hvd3MgZXhhbXBsZXMgb2YgbGV4ZXIgcnVsZXMgYW5kIHRoZSBsaXRlcmFsXHJcblx0ICogbmFtZXMgYXNzaWduZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgdG9rZW4gdHlwZXMuXHJcblx0ICpcclxuXHQgKiA8dGFibGU+XHJcblx0ICogIDx0cj5cclxuXHQgKiAgIDx0aD5SdWxlPC90aD5cclxuXHQgKiAgIDx0aD5TeW1ib2xpYyBOYW1lPC90aD5cclxuXHQgKiAgPC90cj5cclxuXHQgKiAgPHRyPlxyXG5cdCAqICAgPHRkPmBUSElTIDogJ3RoaXMnO2A8L3RkPlxyXG5cdCAqICAgPHRkPmBUSElTYDwvdGQ+XHJcblx0ICogIDwvdHI+XHJcblx0ICogIDx0cj5cclxuXHQgKiAgIDx0ZD5gU1FVT1RFIDogJ1xcJyc7YDwvdGQ+XHJcblx0ICogICA8dGQ+YFNRVU9URWA8L3RkPlxyXG5cdCAqICA8L3RyPlxyXG5cdCAqICA8dHI+XHJcblx0ICogICA8dGQ+YElEIDogW0EtWl0rO2A8L3RkPlxyXG5cdCAqICAgPHRkPmBJRGA8L3RkPlxyXG5cdCAqICA8L3RyPlxyXG5cdCAqIDwvdGFibGU+XHJcblx0ICpcclxuXHQgKiBAcGFyYW0gdG9rZW5UeXBlIFRoZSB0b2tlbiB0eXBlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIHN5bWJvbGljIG5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdG9rZW4gdHlwZSwgb3JcclxuXHQgKiBgdW5kZWZpbmVkYCBpZiBubyBzeW1ib2xpYyBuYW1lIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHlwZS5cclxuXHQgKi9cclxuXHRnZXRTeW1ib2xpY05hbWUodG9rZW5UeXBlOiBudW1iZXIpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGRpc3BsYXkgbmFtZSBvZiBhIHRva2VuIHR5cGUuXHJcblx0ICpcclxuXHQgKiBBTlRMUiBwcm92aWRlcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QsIGJ1dFxyXG5cdCAqIGFwcGxpY2F0aW9ucyBhcmUgZnJlZSB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3IgaW4gYW55IG1hbm5lciB3aGljaCBtYWtlc1xyXG5cdCAqIHNlbnNlIGZvciB0aGUgYXBwbGljYXRpb24uIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdGhlIGZpcnN0XHJcblx0ICogcmVzdWx0IGZyb20gdGhlIGZvbGxvd2luZyBsaXN0IHdoaWNoIHByb2R1Y2VzIGEgbm9uLWB1bmRlZmluZWRgXHJcblx0ICogcmVzdWx0LlxyXG5cdCAqXHJcblx0ICogMS4gVGhlIHJlc3VsdCBvZiB7QGxpbmsgI2dldExpdGVyYWxOYW1lfVxyXG5cdCAqIDEuIFRoZSByZXN1bHQgb2Yge0BsaW5rICNnZXRTeW1ib2xpY05hbWV9XHJcblx0ICogMS4gVGhlIHJlc3VsdCBvZiB7QGxpbmsgSW50ZWdlciN0b1N0cmluZ31cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0b2tlblR5cGUgVGhlIHRva2VuIHR5cGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSB0b2tlbiB0eXBlLCBmb3IgdXNlIGluIGVycm9yIHJlcG9ydGluZyBvclxyXG5cdCAqIG90aGVyIHVzZXItdmlzaWJsZSBtZXNzYWdlcyB3aGljaCByZWZlcmVuY2Ugc3BlY2lmaWMgdG9rZW4gdHlwZXMuXHJcblx0ICovXHJcblx0Ly9ATm90TnVsbFxyXG5cdGdldERpc3BsYXlOYW1lKHRva2VuVHlwZTogbnVtYmVyKTogc3RyaW5nO1xyXG5cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTkuNzAxNTc1MS0wNzowMFxyXG5cclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXcml0YWJsZVRva2VuIGV4dGVuZHMgVG9rZW4ge1xyXG5cdHRleHQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcblx0dHlwZTogbnVtYmVyO1xyXG5cclxuXHRsaW5lOiBudW1iZXI7XHJcblxyXG5cdGNoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyO1xyXG5cclxuXHRjaGFubmVsOiBudW1iZXI7XHJcblxyXG5cdHRva2VuSW5kZXg6IG51bWJlcjtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgKiBmcm9tIFwiLi9BTlRMUkVycm9yTGlzdGVuZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vQU5UTFJFcnJvclN0cmF0ZWd5XCI7XHJcbi8vIGV4cG9ydCAqIGZyb20gXCIuL0FOVExSRmlsZVN0cmVhbVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9BTlRMUklucHV0U3RyZWFtXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0JhaWxFcnJvclN0cmF0ZWd5XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0J1ZmZlcmVkVG9rZW5TdHJlYW1cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vQ2hhclN0cmVhbVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9DaGFyU3RyZWFtc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9Db2RlUG9pbnRCdWZmZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vQ29kZVBvaW50Q2hhclN0cmVhbVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9Db21tb25Ub2tlblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9Db21tb25Ub2tlbkZhY3RvcnlcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vQ29tbW9uVG9rZW5TdHJlYW1cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vQ29uc29sZUVycm9yTGlzdGVuZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vRGVmYXVsdEVycm9yU3RyYXRlZ3lcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vRGVwZW5kZW50c1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9EaWFnbm9zdGljRXJyb3JMaXN0ZW5lclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb25cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vSW5wdXRNaXNtYXRjaEV4Y2VwdGlvblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9JbnRlcnByZXRlclJ1bGVDb250ZXh0XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0ludFN0cmVhbVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9MZXhlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9MZXhlckludGVycHJldGVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0xleGVyTm9WaWFibGVBbHRFeGNlcHRpb25cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vTGlzdFRva2VuU291cmNlXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL05vVmlhYmxlQWx0RXhjZXB0aW9uXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1BhcnNlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9QYXJzZXJFcnJvckxpc3RlbmVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1BhcnNlckludGVycHJldGVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1BhcnNlclJ1bGVDb250ZXh0XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1Byb3h5RXJyb3JMaXN0ZW5lclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9Qcm94eVBhcnNlckVycm9yTGlzdGVuZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vUmVjb2duaXRpb25FeGNlcHRpb25cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vUmVjb2duaXplclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9SdWxlQ29udGV4dFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9SdWxlQ29udGV4dFdpdGhBbHROdW1cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vUnVsZURlcGVuZGVuY3lcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vUnVsZVZlcnNpb25cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vVG9rZW5cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vVG9rZW5GYWN0b3J5XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1Rva2VuU291cmNlXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1Rva2VuU3RyZWFtXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1Rva2VuU3RyZWFtUmV3cml0ZXJcIjtcclxuLy8gZXhwb3J0ICogZnJvbSBcIi4vVW5idWZmZXJlZENoYXJTdHJlYW1cIjtcclxuLy8gZXhwb3J0ICogZnJvbSBcIi4vVW5idWZmZXJlZFRva2VuU3RyZWFtXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1ZvY2FidWxhcnlcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vVm9jYWJ1bGFyeUltcGxcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vV3JpdGFibGVUb2tlblwiO1xyXG4iLCAiLy9cbi8vIGZvcm1hdCAtIHByaW50Zi1saWtlIHN0cmluZyBmb3JtYXR0aW5nIGZvciBKYXZhU2NyaXB0XG4vLyBnaXRodWIuY29tL3NhbXNvbmpzL2Zvcm1hdFxuLy8gQF9zanNcbi8vXG4vLyBDb3B5cmlnaHQgMjAxMCAtIDIwMTMgU2FtaSBTYW1odXJpIDxzYW1pQHNhbWh1cmkubmV0PlxuLy9cbi8vIE1JVCBMaWNlbnNlXG4vLyBodHRwOi8vc2pzLm1pdC1saWNlbnNlLm9yZ1xuLy9cblxuOyhmdW5jdGlvbigpIHtcblxuICAvLy8vIEV4cG9ydCB0aGUgQVBJXG4gIHZhciBuYW1lc3BhY2U7XG5cbiAgLy8gQ29tbW9uSlMgLyBOb2RlIG1vZHVsZVxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuYW1lc3BhY2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcm1hdDtcbiAgfVxuXG4gIC8vIEJyb3dzZXJzIGFuZCBvdGhlciBlbnZpcm9ubWVudHNcbiAgZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBnbG9iYWwgb2JqZWN0LiBXb3JrcyBpbiBFUzMsIEVTNSwgYW5kIEVTNSBzdHJpY3QgbW9kZS5cbiAgICBuYW1lc3BhY2UgPSAoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMgfHwgKDEsZXZhbCkoJ3RoaXMnKSB9KCkpO1xuICB9XG5cbiAgbmFtZXNwYWNlLmZvcm1hdCA9IGZvcm1hdDtcbiAgbmFtZXNwYWNlLnZzcHJpbnRmID0gdnNwcmludGY7XG5cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICBuYW1lc3BhY2UucHJpbnRmID0gcHJpbnRmO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRmKC8qIC4uLiAqLykge1xuICAgIGNvbnNvbGUubG9nKGZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZzcHJpbnRmKGZtdCwgcmVwbGFjZW1lbnRzKSB7XG4gICAgcmV0dXJuIGZvcm1hdC5hcHBseShudWxsLCBbZm10XS5jb25jYXQocmVwbGFjZW1lbnRzKSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQoZm10KSB7XG4gICAgdmFyIGFyZ0luZGV4ID0gMSAvLyBza2lwIGluaXRpYWwgZm9ybWF0IGFyZ3VtZW50XG4gICAgICAsIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICwgaSA9IDBcbiAgICAgICwgbiA9IGZtdC5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gJydcbiAgICAgICwgY1xuICAgICAgLCBlc2NhcGVkID0gZmFsc2VcbiAgICAgICwgYXJnXG4gICAgICAsIHRtcFxuICAgICAgLCBsZWFkaW5nWmVybyA9IGZhbHNlXG4gICAgICAsIHByZWNpc2lvblxuICAgICAgLCBuZXh0QXJnID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9XG4gICAgICAsIHNsdXJwTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGRpZ2l0cyA9ICcnO1xuICAgICAgICAgIHdoaWxlICgvXFxkLy50ZXN0KGZtdFtpXSkpIHtcbiAgICAgICAgICAgIGRpZ2l0cyArPSBmbXRbaSsrXTtcbiAgICAgICAgICAgIGMgPSBmbXRbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaWdpdHMubGVuZ3RoID4gMCA/IHBhcnNlSW50KGRpZ2l0cykgOiBudWxsO1xuICAgICAgICB9XG4gICAgICA7XG4gICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGMgPSBmbXRbaV07XG4gICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChjID09ICcuJykge1xuICAgICAgICAgIGxlYWRpbmdaZXJvID0gZmFsc2U7XG4gICAgICAgICAgYyA9IGZtdFsrK2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT0gJzAnICYmIGZtdFtpICsgMV0gPT0gJy4nKSB7XG4gICAgICAgICAgbGVhZGluZ1plcm8gPSB0cnVlO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICBjID0gZm10W2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxlYWRpbmdaZXJvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmVjaXNpb24gPSBzbHVycE51bWJlcigpO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnYic6IC8vIG51bWJlciBpbiBiaW5hcnlcbiAgICAgICAgICByZXN1bHQgKz0gcGFyc2VJbnQobmV4dEFyZygpLCAxMCkudG9TdHJpbmcoMik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2MnOiAvLyBjaGFyYWN0ZXJcbiAgICAgICAgICBhcmcgPSBuZXh0QXJnKCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8IGFyZyBpbnN0YW5jZW9mIFN0cmluZylcbiAgICAgICAgICAgIHJlc3VsdCArPSBhcmc7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYXJnLCAxMCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkJzogLy8gbnVtYmVyIGluIGRlY2ltYWxcbiAgICAgICAgICByZXN1bHQgKz0gcGFyc2VJbnQobmV4dEFyZygpLCAxMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2YnOiAvLyBmbG9hdGluZyBwb2ludCBudW1iZXJcbiAgICAgICAgICB0bXAgPSBTdHJpbmcocGFyc2VGbG9hdChuZXh0QXJnKCkpLnRvRml4ZWQocHJlY2lzaW9uIHx8IDYpKTtcbiAgICAgICAgICByZXN1bHQgKz0gbGVhZGluZ1plcm8gPyB0bXAgOiB0bXAucmVwbGFjZSgvXjAvLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2onOiAvLyBKU09OXG4gICAgICAgICAgcmVzdWx0ICs9IEpTT04uc3RyaW5naWZ5KG5leHRBcmcoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ28nOiAvLyBudW1iZXIgaW4gb2N0YWxcbiAgICAgICAgICByZXN1bHQgKz0gJzAnICsgcGFyc2VJbnQobmV4dEFyZygpLCAxMCkudG9TdHJpbmcoOCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3MnOiAvLyBzdHJpbmdcbiAgICAgICAgICByZXN1bHQgKz0gbmV4dEFyZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd4JzogLy8gbG93ZXJjYXNlIGhleGFkZWNpbWFsXG4gICAgICAgICAgcmVzdWx0ICs9ICcweCcgKyBwYXJzZUludChuZXh0QXJnKCksIDEwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1gnOiAvLyB1cHBlcmNhc2UgaGV4YWRlY2ltYWxcbiAgICAgICAgICByZXN1bHQgKz0gJzB4JyArIHBhcnNlSW50KG5leHRBcmcoKSwgMTApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlc3VsdCArPSBjO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGMgPT09ICclJykge1xuICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbn0oKSk7XG4iLCAiaW1wb3J0IHsgRWRpdG9yLCBNYXJrZG93blZpZXcsIFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFNpbXBsZVRleHQsIE5vZGUgYXMgU2ltcGxlVGV4dE5vZGUgfSBmcm9tICcuL1NpbXBsZVRleHQnO1xuaW1wb3J0IHsgTWFya2Rvd25BU1RCdWlsZGVyLCBNZGFzdCwgTWRhc3ROb2RlIH0gZnJvbSAnLi9NZGFzdCc7XG5pbXBvcnQgeyBQb3MgfSBmcm9tICcuL1Bvcyc7XG5pbXBvcnQgeyBBbnRsciB9IGZyb20gJy4vQW50bHInO1xuXG50eXBlIFN0cnVjdHVyYWxFZGl0U2V0dGluZ3MgPSB7XG4gICAgLyoqIElmIHNldCBzdmcgYXJlIGNvbnZlcnRlZCB0byBiaXRtYXAgKi9cbiAgICBjb252ZXJ0U3ZnVG9CaXRtYXA6IGJvb2xlYW47XG59O1xuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBTdHJ1Y3R1cmFsRWRpdFNldHRpbmdzID0ge1xuICAgIGNvbnZlcnRTdmdUb0JpdG1hcDogdHJ1ZSxcbn07XG5cbi8vIDEtYmFzZWRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RydWN0dXJhbEVkaXRQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHNldHRpbmdzOiBTdHJ1Y3R1cmFsRWRpdFNldHRpbmdzO1xuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ2dyb3ctc2VsZWN0aW9uJyxcbiAgICAgICAgICAgIG5hbWU6ICdHcm93IHNlbGVjdGlvbicsXG4gICAgICAgICAgICBlZGl0b3JDYWxsYmFjazogYXN5bmMgKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uc3QgY206IGFueSA9IHZpZXcuZWRpdG9yLmdldERvYygpLmNtO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBoZWFkLCBhbmNob3IgfSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gUG9zLm9yZGVyKFBvcy5mcm9tRWRpdG9yUG9zaXRpb24oaGVhZCksIFBvcy5mcm9tRWRpdG9yUG9zaXRpb24oYW5jaG9yKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3NlbGVjdGlvbiBzdGFydCcsIHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2VsZWN0aW9uIGVuZCcsIHJhbmdlLmVuZCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0cmVlID0gTWFya2Rvd25BU1RCdWlsZGVyLnBhcnNlKHZpZXcuZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RyZWUnLCB0cmVlLnJvb3QpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHsgbm9kZTogbm9kZVdpdGhTZWxlY3Rpb24sIGFuY2VzdG9ycyB9ID0gdHJlZS5maW5kTm9kZVdpdGhSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYW5jZXN0b3JzLm1hcCgoYSkgPT4gYS50eXBlKSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQYXJhZ3JhcGggPSBNZGFzdC5maW5kUGFyZW50UGFyYWdyYXBoKGFuY2VzdG9ycyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFBhcmFncmFwaCAmJiAhTWRhc3QuZmlsbHNOb2RlKHBhcmVudFBhcmFncmFwaCwgcmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFwcGVkU2VsZWN0aW9uID0gdGhpcy5zZWxlY3RJblBhcmFncmFwaCh2aWV3LCBwYXJlbnRQYXJhZ3JhcGgsIHJhbmdlKTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0U2VsZWN0aW9uKHJlbWFwcGVkU2VsZWN0aW9uLnN0YXJ0LCByZW1hcHBlZFNlbGVjdGlvbi5lbmQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vZGUgaXMgYW4gdW5maWxsZWQgcGFyYWdyYXBoIG9yIHBhcmFncmFwaCBjb250ZW50ICh0ZXh0LCBlbXBoYXNpcywgLi4uKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChNZGFzdC5maWxsc05vZGUobm9kZVdpdGhTZWxlY3Rpb24sIHJhbmdlKSAmJiBub2RlV2l0aFNlbGVjdGlvbi5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdub2RlIGlzIGZpbGxlZCwgc2VsZWN0aW5nIHBhcmVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVdpdGhTZWxlY3Rpb24gPSBub2RlV2l0aFNlbGVjdGlvbi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgZmlsbGluZyBub2RlIG9mIHR5cGUgJHtub2RlV2l0aFNlbGVjdGlvbi50eXBlfWApO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRTZWxlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBQb3MuZnJvbVBvaW50KG5vZGVXaXRoU2VsZWN0aW9uLnBvc2l0aW9uIS5zdGFydCkudG9FZGl0b3JQb3NpdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUG9zLmZyb21Qb2ludChub2RlV2l0aFNlbGVjdGlvbi5wb3NpdGlvbiEuZW5kKS50b0VkaXRvclBvc2l0aW9uKCksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbGV0IGNoaWxkOiBFbGVtZW50ID0gdHJlZS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgICAgIC8vIGVkaXRvci5nZXRMaW5lKGhlYWQubGluZSk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coaGVhZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhtYXJrZG93bml0KTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgcmVzdWx0ID0gbWFya2VkLmxleGVyKHZpZXcuZGF0YSwge1xuICAgICAgICAgICAgICAgIC8vIFx0Z2ZtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAvLyB9KVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNlbGVjdEluUGFyYWdyYXBoKHZpZXc6IE1hcmtkb3duVmlldywgcGFyZW50UGFyYWdyYXBoOiBNZGFzdE5vZGUsIHJhbmdlOiB7IHN0YXJ0OiBQb3M7IGVuZDogUG9zIH0pIHtcbiAgICAgICAgLy8gaW4gZG9jdW1lbnQgY29vcmRpbmF0ZXNcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoUmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogcGFyZW50UGFyYWdyYXBoLnBvc2l0aW9uIS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogcGFyZW50UGFyYWdyYXBoLnBvc2l0aW9uIS5lbmQsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT09PT09IFVzaW5nIHN1Yi1wYXJzZXIgPT09PT09PT09PT09PT09PT09PT0gJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwYXJhZ3JhcGggc3RhcnQnLCBwYXJhZ3JhcGhSYW5nZS5zdGFydCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwYXJhZ3JhcGggZW5kJywgcGFyYWdyYXBoUmFuZ2UuZW5kKTtcblxuICAgICAgICBjb25zdCB0ZXh0ID0gdmlldy5kYXRhLnN1YnN0cmluZyhwYXJhZ3JhcGhSYW5nZS5zdGFydC5vZmZzZXQhLCBwYXJhZ3JhcGhSYW5nZS5lbmQhLm9mZnNldCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRleHQpO1xuXG4gICAgICAgIGNvbnN0IHRyZWU6IFNpbXBsZVRleHROb2RlID0gU2ltcGxlVGV4dC5wYXJzZSh0ZXh0KTtcbiAgICAgICAgY29uc29sZS5sb2codHJlZSk7XG5cbiAgICAgICAgLy8gdHJhbnNsYXRlIHNlbGVjdGlvbiBpbnRvIHBhcmFncmFwaCBjb29yZGluYXRlcyAobWFrZSBzZWxlY3Rpb24gcmVsYXRpdmUgdG8gdGV4dClcbiAgICAgICAgY29uc3QgbWFwcGVkU2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHJhbmdlLnN0YXJ0Lm1pbnVzKFBvcy5mcm9tUG9pbnQocGFyYWdyYXBoUmFuZ2Uuc3RhcnQpKSxcbiAgICAgICAgICAgIGVuZDogcmFuZ2UuZW5kLm1pbnVzKFBvcy5mcm9tUG9pbnQocGFyYWdyYXBoUmFuZ2Uuc3RhcnQpKSxcbiAgICAgICAgfTtcbiAgICAgICAgbWFwcGVkU2VsZWN0aW9uLnN0YXJ0LmxpbmUrKztcbiAgICAgICAgbWFwcGVkU2VsZWN0aW9uLmVuZC5saW5lKys7XG4gICAgICAgIG1hcHBlZFNlbGVjdGlvbi5zdGFydC5jb2x1bW4rKztcbiAgICAgICAgbWFwcGVkU2VsZWN0aW9uLmVuZC5jb2x1bW4rKztcblxuICAgICAgICBjb25zb2xlLmxvZygnbWFwcGVkIHNlbGVjdGlvbjonLCBtYXBwZWRTZWxlY3Rpb24pO1xuXG4gICAgICAgIC8vIGZpbmQgbm9kZSBpbiByYW5nZVxuICAgICAgICBjb25zdCB7IG5vZGU6IG5vZGVXaXRoU2VsZWN0aW9uLCBhbmNlc3RvcnMgfSA9IEFudGxyLmZpbmROb2RlV2l0aFJhbmdlKHRyZWUsIG1hcHBlZFNlbGVjdGlvbik7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhbnRsciByZXN1bHQgbm9kZScsIG5vZGVXaXRoU2VsZWN0aW9uKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FuY2VzdG9ycycsIGFuY2VzdG9ycyk7XG5cbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgZmlsbCBpdCBncm93IHRvIGZpbGwgaXRcbiAgICAgICAgLy8gZWxzZSBzZWxlY3QgcGFyZW50XG4gICAgICAgIGxldCB0ZXh0Tm9kZTogU2ltcGxlVGV4dE5vZGUgPSBub2RlV2l0aFNlbGVjdGlvbjtcbiAgICAgICAgaWYgKEFudGxyLmZpbGxzTm9kZShub2RlV2l0aFNlbGVjdGlvbiwgcmFuZ2UpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnc2VsZWN0aW9uIGFscmVhZHkgZmlsbHMgdGhlIG5vZGUsIGdyb3dpbmcgIScpO1xuICAgICAgICAgICAgdGV4dE5vZGUgPSBhbmNlc3RvcnNbYW5jZXN0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ3NlbGVjdGluZycsIHRleHROb2RlKTtcbiAgICAgICAgY29uc29sZS5sb2coYHNlbGVjdGluZyB0ZXh0ICR7dGV4dE5vZGUudGV4dH1gKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnbmV3IHNlbGVjdGlvbiBzdGFydCcsIHRleHROb2RlLnN0YXJ0KTtcbiAgICAgICAgY29uc29sZS5sb2coJ25ldyBzZWxlY3Rpb24gZW5kJywgdGV4dE5vZGUuZW5kKTtcblxuICAgICAgICBjb25zdCByZW1hcHBlZFNlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogcGFyYWdyYXBoUmFuZ2Uuc3RhcnQubGluZSAtIDEgKyB0ZXh0Tm9kZS5zdGFydCEubGluZSAtIDEsXG4gICAgICAgICAgICAgICAgY2g6IHBhcmFncmFwaFJhbmdlLnN0YXJ0LmNvbHVtbiAtIDEgKyB0ZXh0Tm9kZS5zdGFydCEuY29sdW1uIC0gMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBwYXJhZ3JhcGhSYW5nZS5zdGFydC5saW5lIC0gMSArIHRleHROb2RlLmVuZCEubGluZSAtIDEsXG4gICAgICAgICAgICAgICAgY2g6IHBhcmFncmFwaFJhbmdlLnN0YXJ0LmNvbHVtbiAtIDEgKyB0ZXh0Tm9kZS5lbmQhLmNvbHVtbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coJ21hcHBlZCBzZWxlY3Rpb24gc3RhcnQnLCByZW1hcHBlZFNlbGVjdGlvbi5zdGFydCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdtYXBwZWQgc2VsZWN0aW9uIGVuZCcsIHJlbWFwcGVkU2VsZWN0aW9uLmVuZCk7XG4gICAgICAgIHJldHVybiByZW1hcHBlZFNlbGVjdGlvbjtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RQYXJzZVRyZWVWaXNpdG9yIH0gZnJvbSAnYW50bHI0dHMvdHJlZS9BYnN0cmFjdFBhcnNlVHJlZVZpc2l0b3InO1xuaW1wb3J0IHsgQU5UTFJJbnB1dFN0cmVhbSwgQ29tbW9uVG9rZW5TdHJlYW0sIFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSAnYW50bHI0dHMnO1xuaW1wb3J0IHsgU2ltcGxlVGV4dFZpc2l0b3IgfSBmcm9tICdncmFtbWFyL1NpbXBsZVRleHRWaXNpdG9yJztcbmltcG9ydCB7XG4gICAgRW5kUHVuY3R1YXRpb25Db250ZXh0LFxuICAgIEV4cHJlc3Npb25Db250ZXh0LFxuICAgIE1pZFB1bmN0dWF0aW9uQ29udGV4dCxcbiAgICBQYXJhZ3JhcGhDb250ZXh0LFxuICAgIFByb3Bvc2l0aW9uQ29udGV4dCxcbiAgICBTZW50ZW5jZUNvbnRleHQsXG4gICAgU2ltcGxlVGV4dFBhcnNlcixcbiAgICBXb3JkQ29udGV4dCxcbn0gZnJvbSAnZ3JhbW1hci9TaW1wbGVUZXh0UGFyc2VyJztcbmltcG9ydCB7IFNpbXBsZVRleHRMZXhlciB9IGZyb20gJ2dyYW1tYXIvU2ltcGxlVGV4dExleGVyJztcblxuZXhwb3J0IHR5cGUgUG9zaXRpb24gPSB7XG4gICAgbGluZTogbnVtYmVyO1xuICAgIGNvbHVtbjogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgTm9kZSA9IHtcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgc3RhcnQ/OiBQb3NpdGlvbjtcbiAgICBlbmQ/OiBQb3NpdGlvbjtcbiAgICB0ZXh0Pzogc3RyaW5nO1xuICAgIGNoaWxkcmVuPzogTm9kZVtdO1xufTtcblxuY2xhc3MgQnVpbGRBU1RWaXNpdG9yIGV4dGVuZHMgQWJzdHJhY3RQYXJzZVRyZWVWaXNpdG9yPE5vZGU+IGltcGxlbWVudHMgU2ltcGxlVGV4dFZpc2l0b3I8Tm9kZT4ge1xuICAgIGRlZmF1bHRSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZGVmYXVsdCcsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmlzaXRQYXJhZ3JhcGgoY3R4OiBQYXJhZ3JhcGhDb250ZXh0KTogTm9kZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NHcm91cChjdHgsICdwYXJhZ3JhcGgnKTtcbiAgICB9XG5cbiAgICB2aXNpdFNlbnRlbmNlKGN0eDogU2VudGVuY2VDb250ZXh0KTogTm9kZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NHcm91cChjdHgsICdzZW50ZW5jZScpO1xuICAgIH1cblxuICAgIHZpc2l0UHJvcG9zaXRpb24oY3R4OiBQcm9wb3NpdGlvbkNvbnRleHQpOiBOb2RlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0dyb3VwKGN0eCwgJ3Byb3Bvc2l0aW9uJyk7XG4gICAgfVxuXG4gICAgdmlzaXRFeHByZXNzaW9uKGN0eDogRXhwcmVzc2lvbkNvbnRleHQpOiBOb2RlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0dyb3VwKGN0eCwgJ2V4cHJlc3Npb24nKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzR3JvdXAoY3R4OiBQYXJzZXJSdWxlQ29udGV4dCwgdHlwZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY3R4LmNoaWxkcmVuPy5tYXAoKGNoaWxkKSA9PiB0aGlzLnZpc2l0KGNoaWxkKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU5vZGUoY3R4LCB0eXBlLCBjaGlsZHJlbiA/PyBbXSk7XG4gICAgfVxuXG4gICAgdmlzaXRXb3JkKGN0eDogV29yZENvbnRleHQpOiBOb2RlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Rlcm1pbmFsKGN0eCwgJ3dvcmQnKTtcbiAgICB9XG5cbiAgICB2aXNpdEVuZFB1bmN0dWF0aW9uKGN0eDogRW5kUHVuY3R1YXRpb25Db250ZXh0KTogTm9kZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NUZXJtaW5hbChjdHgsICdwdW5jdHVhdGlvbicpO1xuICAgIH1cblxuICAgIHZpc2l0TWlkUHVuY3R1YXRpb24oY3R4OiBNaWRQdW5jdHVhdGlvbkNvbnRleHQpOiBOb2RlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Rlcm1pbmFsKGN0eCwgJ21pZC1wdW5jdHVhdGlvbicpO1xuICAgIH1cblxuICAgIHByb2Nlc3NUZXJtaW5hbChjdHg6IFBhcnNlclJ1bGVDb250ZXh0LCB0eXBlOiBzdHJpbmcpOiBOb2RlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGN0eC5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogY3R4LnN0YXJ0LmNoYXJQb3NpdGlvbkluTGluZSArIDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgbGluZTogY3R4LnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjdHguc3RhcnQuY2hhclBvc2l0aW9uSW5MaW5lICsgY3R4LnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IGN0eC50ZXh0LFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNyZWF0ZU5vZGUoY3R4OiBQYXJzZXJSdWxlQ29udGV4dCwgdHlwZTogc3RyaW5nLCBjaGlsZHJlbjogTm9kZVtdKSB7XG4gICAgICAgIGNvbnN0IGVuZFRva2VuID0gY3R4LnN0b3AgPz8gY3R4LnN0YXJ0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHN0YXJ0OiB7IGxpbmU6IGN0eC5zdGFydC5saW5lLCBjb2x1bW46IDEgKyBjdHguc3RhcnQuY2hhclBvc2l0aW9uSW5MaW5lIH0sXG4gICAgICAgICAgICBlbmQ6IHsgbGluZTogZW5kVG9rZW4ubGluZSwgY29sdW1uOiBlbmRUb2tlbi5jaGFyUG9zaXRpb25JbkxpbmUgfSxcbiAgICAgICAgICAgIHRleHQ6IGN0eC50ZXh0LFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaXh1cEFzdChub2RlOiBOb2RlKSB7XG4gICAgLy8gRklYTUUgLSBkZXVnbGlmeVxuICAgIG5vZGUuY2hpbGRyZW4/LmZvckVhY2goKGNoaWxkKSA9PiBmaXh1cEFzdChjaGlsZCkpO1xuICAgIGNvbnN0IGxhc3RDaGlsZCA9IG5vZGUuY2hpbGRyZW4gPyBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgbm9kZS5lbmQgPSBsYXN0Q2hpbGQ/LmVuZCA/PyBub2RlLmVuZDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBTaW1wbGVUZXh0IHtcbiAgICAvKiogUGFyc2UgYSBNYXJrZG93biB0ZXh0IGFuZCByZXR1cm4gYW4gQVNUICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHRleHQ6IHN0cmluZyk6IE5vZGUge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGxleGVyIGFuZCBwYXJzZXJcbiAgICAgICAgY29uc3QgaW5wdXRTdHJlYW0gPSBuZXcgQU5UTFJJbnB1dFN0cmVhbSh0ZXh0KTtcbiAgICAgICAgY29uc3QgbGV4ZXIgPSBuZXcgU2ltcGxlVGV4dExleGVyKGlucHV0U3RyZWFtKTtcbiAgICAgICAgY29uc3QgdG9rZW5TdHJlYW0gPSBuZXcgQ29tbW9uVG9rZW5TdHJlYW0obGV4ZXIpO1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgU2ltcGxlVGV4dFBhcnNlcih0b2tlblN0cmVhbSk7XG5cbiAgICAgICAgLy8gbGV0IHRoZSBBTlRMUiBnZW5lcmF0ZWQgcGFyc2VyIHBhcnNlXG4gICAgICAgIGNvbnN0IHRyZWUgPSBwYXJzZXIucGFyYWdyYXBoKCk7XG5cbiAgICAgICAgLy8gY29uc3RydWN0IGFuIEFTVFxuICAgICAgICBjb25zdCBidWlsZGVyID0gbmV3IEJ1aWxkQVNUVmlzaXRvcigpO1xuICAgICAgICBjb25zdCBhc3QgPSBidWlsZGVyLnZpc2l0KHRyZWUpO1xuXG4gICAgICAgIGZpeHVwQXN0KGFzdCk7XG5cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG59XG4iLCAiLy8gR2VuZXJhdGVkIGZyb20gU2ltcGxlVGV4dC5nNCBieSBBTlRMUiA0LjkuMC1TTkFQU0hPVFxuXG5cbmltcG9ydCB7IEFUTiB9IGZyb20gXCJhbnRscjR0cy9hdG4vQVROXCI7XG5pbXBvcnQgeyBBVE5EZXNlcmlhbGl6ZXIgfSBmcm9tIFwiYW50bHI0dHMvYXRuL0FUTkRlc2VyaWFsaXplclwiO1xuaW1wb3J0IHsgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uIH0gZnJvbSBcImFudGxyNHRzL0ZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvblwiO1xuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCJhbnRscjR0cy9EZWNvcmF0b3JzXCI7XG5pbXBvcnQgeyBOb1ZpYWJsZUFsdEV4Y2VwdGlvbiB9IGZyb20gXCJhbnRscjR0cy9Ob1ZpYWJsZUFsdEV4Y2VwdGlvblwiO1xuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiYW50bHI0dHMvRGVjb3JhdG9yc1wiO1xuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcImFudGxyNHRzL1BhcnNlclwiO1xuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiYW50bHI0dHMvUGFyc2VyUnVsZUNvbnRleHRcIjtcbmltcG9ydCB7IFBhcnNlckFUTlNpbXVsYXRvciB9IGZyb20gXCJhbnRscjR0cy9hdG4vUGFyc2VyQVROU2ltdWxhdG9yXCI7XG5pbXBvcnQgeyBQYXJzZVRyZWVMaXN0ZW5lciB9IGZyb20gXCJhbnRscjR0cy90cmVlL1BhcnNlVHJlZUxpc3RlbmVyXCI7XG5pbXBvcnQgeyBQYXJzZVRyZWVWaXNpdG9yIH0gZnJvbSBcImFudGxyNHRzL3RyZWUvUGFyc2VUcmVlVmlzaXRvclwiO1xuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiYW50bHI0dHMvUmVjb2duaXRpb25FeGNlcHRpb25cIjtcbmltcG9ydCB7IFJ1bGVDb250ZXh0IH0gZnJvbSBcImFudGxyNHRzL1J1bGVDb250ZXh0XCI7XG4vL2ltcG9ydCB7IFJ1bGVWZXJzaW9uIH0gZnJvbSBcImFudGxyNHRzL1J1bGVWZXJzaW9uXCI7XG5pbXBvcnQgeyBUZXJtaW5hbE5vZGUgfSBmcm9tIFwiYW50bHI0dHMvdHJlZS9UZXJtaW5hbE5vZGVcIjtcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcImFudGxyNHRzL1Rva2VuXCI7XG5pbXBvcnQgeyBUb2tlblN0cmVhbSB9IGZyb20gXCJhbnRscjR0cy9Ub2tlblN0cmVhbVwiO1xuaW1wb3J0IHsgVm9jYWJ1bGFyeSB9IGZyb20gXCJhbnRscjR0cy9Wb2NhYnVsYXJ5XCI7XG5pbXBvcnQgeyBWb2NhYnVsYXJ5SW1wbCB9IGZyb20gXCJhbnRscjR0cy9Wb2NhYnVsYXJ5SW1wbFwiO1xuXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiYW50bHI0dHMvbWlzYy9VdGlsc1wiO1xuXG5pbXBvcnQgeyBTaW1wbGVUZXh0TGlzdGVuZXIgfSBmcm9tIFwiLi9TaW1wbGVUZXh0TGlzdGVuZXJcIjtcbmltcG9ydCB7IFNpbXBsZVRleHRWaXNpdG9yIH0gZnJvbSBcIi4vU2ltcGxlVGV4dFZpc2l0b3JcIjtcblxuXG5leHBvcnQgY2xhc3MgU2ltcGxlVGV4dFBhcnNlciBleHRlbmRzIFBhcnNlciB7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgV29yZCA9IDE7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU21pbGV5ID0gMjtcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBVcmwgPSAzO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERPVCA9IDQ7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUVVFU1RJT05fTUFSSyA9IDU7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRVhDTEFNQVRJT05fTUFSSyA9IDY7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTFBBUkVOID0gNztcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBSUEFSRU4gPSA4O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExBQ0NPTCA9IDk7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUkFDQ09MID0gMTA7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTEJSQUNLID0gMTE7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUkJSQUNLID0gMTI7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUVVPVEUgPSAxMztcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBEUVVPVEUgPSAxNDtcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBDT0xPTiA9IDE1O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENPTU1BID0gMTY7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU0VNSUNPTE9OID0gMTc7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU01JTEVZID0gMTg7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgV1MgPSAxOTtcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBSVUxFX3BhcmFncmFwaCA9IDA7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUlVMRV9zZW50ZW5jZSA9IDE7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUlVMRV9wcm9wb3NpdGlvbiA9IDI7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUlVMRV9taWRQdW5jdHVhdGlvbiA9IDM7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUlVMRV9lbmRQdW5jdHVhdGlvbiA9IDQ7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUlVMRV93b3JkID0gNTtcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBSVUxFX2V4cHJlc3Npb24gPSA2O1xuXHQvLyB0c2xpbnQ6ZGlzYWJsZTpuby10cmFpbGluZy13aGl0ZXNwYWNlXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgcnVsZU5hbWVzOiBzdHJpbmdbXSA9IFtcblx0XHRcInBhcmFncmFwaFwiLCBcInNlbnRlbmNlXCIsIFwicHJvcG9zaXRpb25cIiwgXCJtaWRQdW5jdHVhdGlvblwiLCBcImVuZFB1bmN0dWF0aW9uXCIsIFxuXHRcdFwid29yZFwiLCBcImV4cHJlc3Npb25cIixcblx0XTtcblxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBfTElURVJBTF9OQU1FUzogQXJyYXk8c3RyaW5nIHwgdW5kZWZpbmVkPiA9IFtcblx0XHR1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiJy4nXCIsIFwiJz8nXCIsIFwiJyEnXCIsIFwiJygnXCIsIFxuXHRcdFwiJyknXCIsIFwiJ3snXCIsIFwiJ30nXCIsIFwiJ1snXCIsIFwiJ10nXCIsIHVuZGVmaW5lZCwgXCInXFxcIidcIiwgXCInOidcIiwgXCInLCdcIiwgXCInOydcIixcblx0XTtcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgX1NZTUJPTElDX05BTUVTOiBBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0gW1xuXHRcdHVuZGVmaW5lZCwgXCJXb3JkXCIsIFwiU21pbGV5XCIsIFwiVXJsXCIsIFwiRE9UXCIsIFwiUVVFU1RJT05fTUFSS1wiLCBcIkVYQ0xBTUFUSU9OX01BUktcIiwgXG5cdFx0XCJMUEFSRU5cIiwgXCJSUEFSRU5cIiwgXCJMQUNDT0xcIiwgXCJSQUNDT0xcIiwgXCJMQlJBQ0tcIiwgXCJSQlJBQ0tcIiwgXCJRVU9URVwiLCBcIkRRVU9URVwiLCBcblx0XHRcIkNPTE9OXCIsIFwiQ09NTUFcIiwgXCJTRU1JQ09MT05cIiwgXCJTTUlMRVlcIiwgXCJXU1wiLFxuXHRdO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFZPQ0FCVUxBUlk6IFZvY2FidWxhcnkgPSBuZXcgVm9jYWJ1bGFyeUltcGwoU2ltcGxlVGV4dFBhcnNlci5fTElURVJBTF9OQU1FUywgU2ltcGxlVGV4dFBhcnNlci5fU1lNQk9MSUNfTkFNRVMsIFtdKTtcblxuXHQvLyBAT3ZlcnJpZGVcblx0Ly8gQE5vdE51bGxcblx0cHVibGljIGdldCB2b2NhYnVsYXJ5KCk6IFZvY2FidWxhcnkge1xuXHRcdHJldHVybiBTaW1wbGVUZXh0UGFyc2VyLlZPQ0FCVUxBUlk7XG5cdH1cblx0Ly8gdHNsaW50OmVuYWJsZTpuby10cmFpbGluZy13aGl0ZXNwYWNlXG5cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBnZXQgZ3JhbW1hckZpbGVOYW1lKCk6IHN0cmluZyB7IHJldHVybiBcIlNpbXBsZVRleHQuZzRcIjsgfVxuXG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZ2V0IHJ1bGVOYW1lcygpOiBzdHJpbmdbXSB7IHJldHVybiBTaW1wbGVUZXh0UGFyc2VyLnJ1bGVOYW1lczsgfVxuXG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZ2V0IHNlcmlhbGl6ZWRBVE4oKTogc3RyaW5nIHsgcmV0dXJuIFNpbXBsZVRleHRQYXJzZXIuX3NlcmlhbGl6ZWRBVE47IH1cblxuXHRwcm90ZWN0ZWQgY3JlYXRlRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHByZWRpY2F0ZT86IHN0cmluZywgbWVzc2FnZT86IHN0cmluZyk6IEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbiB7XG5cdFx0cmV0dXJuIG5ldyBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgcHJlZGljYXRlLCBtZXNzYWdlKTtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKGlucHV0OiBUb2tlblN0cmVhbSkge1xuXHRcdHN1cGVyKGlucHV0KTtcblx0XHR0aGlzLl9pbnRlcnAgPSBuZXcgUGFyc2VyQVROU2ltdWxhdG9yKFNpbXBsZVRleHRQYXJzZXIuX0FUTiwgdGhpcyk7XG5cdH1cblx0Ly8gQFJ1bGVWZXJzaW9uKDApXG5cdHB1YmxpYyBwYXJhZ3JhcGgoKTogUGFyYWdyYXBoQ29udGV4dCB7XG5cdFx0bGV0IF9sb2NhbGN0eDogUGFyYWdyYXBoQ29udGV4dCA9IG5ldyBQYXJhZ3JhcGhDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG5cdFx0dGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAwLCBTaW1wbGVUZXh0UGFyc2VyLlJVTEVfcGFyYWdyYXBoKTtcblx0XHRsZXQgX2xhOiBudW1iZXI7XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuXHRcdFx0e1xuXHRcdFx0dGhpcy5zdGF0ZSA9IDE3O1xuXHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0X2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdFx0XHR3aGlsZSAoKCgoX2xhKSAmIH4weDFGKSA9PT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLldvcmQpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5TbWlsZXkpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5VcmwpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5MUEFSRU4pIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5MQUNDT0wpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5MQlJBQ0spIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5RVU9URSkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkRRVU9URSkpKSAhPT0gMCkpIHtcblx0XHRcdFx0e1xuXHRcdFx0XHR7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSAxNDtcblx0XHRcdFx0dGhpcy5zZW50ZW5jZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDE5O1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRcdF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zdGF0ZSA9IDIwO1xuXHRcdFx0dGhpcy5tYXRjaChTaW1wbGVUZXh0UGFyc2VyLkVPRik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChyZSkge1xuXHRcdFx0aWYgKHJlIGluc3RhbmNlb2YgUmVjb2duaXRpb25FeGNlcHRpb24pIHtcblx0XHRcdFx0X2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IHJlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHRoaXMuZXhpdFJ1bGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9sb2NhbGN0eDtcblx0fVxuXHQvLyBAUnVsZVZlcnNpb24oMClcblx0cHVibGljIHNlbnRlbmNlKCk6IFNlbnRlbmNlQ29udGV4dCB7XG5cdFx0bGV0IF9sb2NhbGN0eDogU2VudGVuY2VDb250ZXh0ID0gbmV3IFNlbnRlbmNlQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHRcdHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMiwgU2ltcGxlVGV4dFBhcnNlci5SVUxFX3NlbnRlbmNlKTtcblx0XHRsZXQgX2xhOiBudW1iZXI7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBfYWx0OiBudW1iZXI7XG5cdFx0XHR0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcblx0XHRcdHtcblx0XHRcdHRoaXMuc3RhdGUgPSAyMztcblx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdF9hbHQgPSAxO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRzd2l0Y2ggKF9hbHQpIHtcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDIyO1xuXHRcdFx0XHRcdHRoaXMucHJvcG9zaXRpb24oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBOb1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnN0YXRlID0gMjU7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0X2FsdCA9IHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCAxLCB0aGlzLl9jdHgpO1xuXHRcdFx0fSB3aGlsZSAoX2FsdCAhPT0gMiAmJiBfYWx0ICE9PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSKTtcblx0XHRcdHRoaXMuc3RhdGUgPSAyODtcblx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHRcdFx0aWYgKCgoKF9sYSkgJiB+MHgxRikgPT09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5ET1QpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5RVUVTVElPTl9NQVJLKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuRVhDTEFNQVRJT05fTUFSSykpKSAhPT0gMCkpIHtcblx0XHRcdFx0e1xuXHRcdFx0XHR0aGlzLnN0YXRlID0gMjc7XG5cdFx0XHRcdHRoaXMuZW5kUHVuY3R1YXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChyZSkge1xuXHRcdFx0aWYgKHJlIGluc3RhbmNlb2YgUmVjb2duaXRpb25FeGNlcHRpb24pIHtcblx0XHRcdFx0X2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IHJlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHRoaXMuZXhpdFJ1bGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9sb2NhbGN0eDtcblx0fVxuXHQvLyBAUnVsZVZlcnNpb24oMClcblx0cHVibGljIHByb3Bvc2l0aW9uKCk6IFByb3Bvc2l0aW9uQ29udGV4dCB7XG5cdFx0bGV0IF9sb2NhbGN0eDogUHJvcG9zaXRpb25Db250ZXh0ID0gbmV3IFByb3Bvc2l0aW9uQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHRcdHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNCwgU2ltcGxlVGV4dFBhcnNlci5SVUxFX3Byb3Bvc2l0aW9uKTtcblx0XHRsZXQgX2xhOiBudW1iZXI7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBfYWx0OiBudW1iZXI7XG5cdFx0XHR0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcblx0XHRcdHtcblx0XHRcdHRoaXMuc3RhdGUgPSAzMjtcblx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdF9hbHQgPSAxO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRzd2l0Y2ggKF9hbHQpIHtcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnN0YXRlID0gMzI7XG5cdFx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0XHRcdHN3aXRjaCAodGhpcy5faW5wdXQuTEEoMSkpIHtcblx0XHRcdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuV29yZDpcblx0XHRcdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuU21pbGV5OlxuXHRcdFx0XHRcdGNhc2UgU2ltcGxlVGV4dFBhcnNlci5Vcmw6XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlID0gMzA7XG5cdFx0XHRcdFx0XHR0aGlzLndvcmQoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgU2ltcGxlVGV4dFBhcnNlci5MUEFSRU46XG5cdFx0XHRcdFx0Y2FzZSBTaW1wbGVUZXh0UGFyc2VyLkxBQ0NPTDpcblx0XHRcdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuTEJSQUNLOlxuXHRcdFx0XHRcdGNhc2UgU2ltcGxlVGV4dFBhcnNlci5RVU9URTpcblx0XHRcdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuRFFVT1RFOlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDMxO1xuXHRcdFx0XHRcdFx0dGhpcy5leHByZXNzaW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IE5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IE5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSAzNDtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0XHRfYWx0ID0gdGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDQsIHRoaXMuX2N0eCk7XG5cdFx0XHR9IHdoaWxlIChfYWx0ICE9PSAyICYmIF9hbHQgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIpO1xuXHRcdFx0dGhpcy5zdGF0ZSA9IDM3O1xuXHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0X2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdFx0XHRpZiAoKCgoX2xhKSAmIH4weDFGKSA9PT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkNPTE9OKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuQ09NTUEpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5TRU1JQ09MT04pKSkgIT09IDApKSB7XG5cdFx0XHRcdHtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDM2O1xuXHRcdFx0XHR0aGlzLm1pZFB1bmN0dWF0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAocmUpIHtcblx0XHRcdGlmIChyZSBpbnN0YW5jZW9mIFJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0XHRcdF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyByZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHR0aGlzLmV4aXRSdWxlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfbG9jYWxjdHg7XG5cdH1cblx0Ly8gQFJ1bGVWZXJzaW9uKDApXG5cdHB1YmxpYyBtaWRQdW5jdHVhdGlvbigpOiBNaWRQdW5jdHVhdGlvbkNvbnRleHQge1xuXHRcdGxldCBfbG9jYWxjdHg6IE1pZFB1bmN0dWF0aW9uQ29udGV4dCA9IG5ldyBNaWRQdW5jdHVhdGlvbkNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcblx0XHR0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDYsIFNpbXBsZVRleHRQYXJzZXIuUlVMRV9taWRQdW5jdHVhdGlvbik7XG5cdFx0bGV0IF9sYTogbnVtYmVyO1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcblx0XHRcdHtcblx0XHRcdHRoaXMuc3RhdGUgPSAzOTtcblx0XHRcdF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHRcdFx0aWYgKCEoKCgoX2xhKSAmIH4weDFGKSA9PT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkNPTE9OKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuQ09NTUEpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5TRU1JQ09MT04pKSkgIT09IDApKSkge1xuXHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBUb2tlbi5FT0YpIHtcblx0XHRcdFx0XHR0aGlzLm1hdGNoZWRFT0YgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcblx0XHRcdFx0dGhpcy5jb25zdW1lKCk7XG5cdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChyZSkge1xuXHRcdFx0aWYgKHJlIGluc3RhbmNlb2YgUmVjb2duaXRpb25FeGNlcHRpb24pIHtcblx0XHRcdFx0X2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IHJlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHRoaXMuZXhpdFJ1bGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9sb2NhbGN0eDtcblx0fVxuXHQvLyBAUnVsZVZlcnNpb24oMClcblx0cHVibGljIGVuZFB1bmN0dWF0aW9uKCk6IEVuZFB1bmN0dWF0aW9uQ29udGV4dCB7XG5cdFx0bGV0IF9sb2NhbGN0eDogRW5kUHVuY3R1YXRpb25Db250ZXh0ID0gbmV3IEVuZFB1bmN0dWF0aW9uQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHRcdHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgOCwgU2ltcGxlVGV4dFBhcnNlci5SVUxFX2VuZFB1bmN0dWF0aW9uKTtcblx0XHRsZXQgX2xhOiBudW1iZXI7XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuc3RhdGUgPSA0ODtcblx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdHN3aXRjaCAodGhpcy5faW5wdXQuTEEoMSkpIHtcblx0XHRcdGNhc2UgU2ltcGxlVGV4dFBhcnNlci5ET1Q6XG5cdFx0XHRcdHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuXHRcdFx0XHR7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA0Mjtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0XHRfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDQxO1xuXHRcdFx0XHRcdHRoaXMubWF0Y2goU2ltcGxlVGV4dFBhcnNlci5ET1QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDQ0O1xuXHRcdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0XHRfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0XHRcdFx0fSB3aGlsZSAoX2xhID09PSBTaW1wbGVUZXh0UGFyc2VyLkRPVCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuUVVFU1RJT05fTUFSSzpcblx0XHRcdFx0dGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMik7XG5cdFx0XHRcdHtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDQ2O1xuXHRcdFx0XHR0aGlzLm1hdGNoKFNpbXBsZVRleHRQYXJzZXIuUVVFU1RJT05fTUFSSyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuRVhDTEFNQVRJT05fTUFSSzpcblx0XHRcdFx0dGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMyk7XG5cdFx0XHRcdHtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDQ3O1xuXHRcdFx0XHR0aGlzLm1hdGNoKFNpbXBsZVRleHRQYXJzZXIuRVhDTEFNQVRJT05fTUFSSyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChyZSkge1xuXHRcdFx0aWYgKHJlIGluc3RhbmNlb2YgUmVjb2duaXRpb25FeGNlcHRpb24pIHtcblx0XHRcdFx0X2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IHJlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHRoaXMuZXhpdFJ1bGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9sb2NhbGN0eDtcblx0fVxuXHQvLyBAUnVsZVZlcnNpb24oMClcblx0cHVibGljIHdvcmQoKTogV29yZENvbnRleHQge1xuXHRcdGxldCBfbG9jYWxjdHg6IFdvcmRDb250ZXh0ID0gbmV3IFdvcmRDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG5cdFx0dGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxMCwgU2ltcGxlVGV4dFBhcnNlci5SVUxFX3dvcmQpO1xuXHRcdGxldCBfbGE6IG51bWJlcjtcblx0XHR0cnkge1xuXHRcdFx0dGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG5cdFx0XHR7XG5cdFx0XHR0aGlzLnN0YXRlID0gNTA7XG5cdFx0XHRfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0XHRcdGlmICghKCgoKF9sYSkgJiB+MHgxRikgPT09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5Xb3JkKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuU21pbGV5KSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuVXJsKSkpICE9PSAwKSkpIHtcblx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9pbnB1dC5MQSgxKSA9PT0gVG9rZW4uRU9GKSB7XG5cdFx0XHRcdFx0dGhpcy5tYXRjaGVkRU9GID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG5cdFx0XHRcdHRoaXMuY29uc3VtZSgpO1xuXHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAocmUpIHtcblx0XHRcdGlmIChyZSBpbnN0YW5jZW9mIFJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0XHRcdF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyByZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHR0aGlzLmV4aXRSdWxlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfbG9jYWxjdHg7XG5cdH1cblx0Ly8gQFJ1bGVWZXJzaW9uKDApXG5cdHB1YmxpYyBleHByZXNzaW9uKCk6IEV4cHJlc3Npb25Db250ZXh0IHtcblx0XHRsZXQgX2xvY2FsY3R4OiBFeHByZXNzaW9uQ29udGV4dCA9IG5ldyBFeHByZXNzaW9uQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHRcdHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTIsIFNpbXBsZVRleHRQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcblx0XHRsZXQgX2xhOiBudW1iZXI7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBfYWx0OiBudW1iZXI7XG5cdFx0XHR0aGlzLnN0YXRlID0gOTI7XG5cdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRzd2l0Y2ggKHRoaXMuX2lucHV0LkxBKDEpKSB7XG5cdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuTFBBUkVOOlxuXHRcdFx0XHR0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcblx0XHRcdFx0e1xuXHRcdFx0XHR0aGlzLnN0YXRlID0gNTI7XG5cdFx0XHRcdHRoaXMubWF0Y2goU2ltcGxlVGV4dFBhcnNlci5MUEFSRU4pO1xuXHRcdFx0XHR0aGlzLnN0YXRlID0gNTY7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0X2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdFx0XHRcdHdoaWxlICgoKChfbGEpICYgfjB4MUYpID09PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IFNpbXBsZVRleHRQYXJzZXIuV29yZCkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLlNtaWxleSkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLlVybCkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkxQQVJFTikgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkxBQ0NPTCkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkxCUkFDSykgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLlFVT1RFKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuRFFVT1RFKSkpICE9PSAwKSkge1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDUzO1xuXHRcdFx0XHRcdHRoaXMuc2VudGVuY2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuc3RhdGUgPSA1ODtcblx0XHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRcdFx0X2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDU5O1xuXHRcdFx0XHR0aGlzLm1hdGNoKFNpbXBsZVRleHRQYXJzZXIuUlBBUkVOKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgU2ltcGxlVGV4dFBhcnNlci5RVU9URTpcblx0XHRcdFx0dGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMik7XG5cdFx0XHRcdHtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDYwO1xuXHRcdFx0XHR0aGlzLm1hdGNoKFNpbXBsZVRleHRQYXJzZXIuUVVPVEUpO1xuXHRcdFx0XHR0aGlzLnN0YXRlID0gNjQ7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0X2FsdCA9IHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCA5LCB0aGlzLl9jdHgpO1xuXHRcdFx0XHR3aGlsZSAoX2FsdCAhPT0gMiAmJiBfYWx0ICE9PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG5cdFx0XHRcdFx0aWYgKF9hbHQgPT09IDEpIHtcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUgPSA2MTtcblx0XHRcdFx0XHRcdHRoaXMuc2VudGVuY2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDY2O1xuXHRcdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0XHRfYWx0ID0gdGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDksIHRoaXMuX2N0eCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDY3O1xuXHRcdFx0XHR0aGlzLm1hdGNoKFNpbXBsZVRleHRQYXJzZXIuUVVPVEUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBTaW1wbGVUZXh0UGFyc2VyLkRRVU9URTpcblx0XHRcdFx0dGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMyk7XG5cdFx0XHRcdHtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDY4O1xuXHRcdFx0XHR0aGlzLm1hdGNoKFNpbXBsZVRleHRQYXJzZXIuRFFVT1RFKTtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDcyO1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRcdF9hbHQgPSB0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgMTAsIHRoaXMuX2N0eCk7XG5cdFx0XHRcdHdoaWxlIChfYWx0ICE9PSAyICYmIF9hbHQgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcblx0XHRcdFx0XHRpZiAoX2FsdCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDY5O1xuXHRcdFx0XHRcdFx0dGhpcy5zZW50ZW5jZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnN0YXRlID0gNzQ7XG5cdFx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0XHRcdF9hbHQgPSB0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgMTAsIHRoaXMuX2N0eCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDc1O1xuXHRcdFx0XHR0aGlzLm1hdGNoKFNpbXBsZVRleHRQYXJzZXIuRFFVT1RFKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgU2ltcGxlVGV4dFBhcnNlci5MQlJBQ0s6XG5cdFx0XHRcdHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDQpO1xuXHRcdFx0XHR7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA3Njtcblx0XHRcdFx0dGhpcy5tYXRjaChTaW1wbGVUZXh0UGFyc2VyLkxCUkFDSyk7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA4MDtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0XHRfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0XHRcdFx0d2hpbGUgKCgoKF9sYSkgJiB+MHgxRikgPT09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5Xb3JkKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuU21pbGV5KSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuVXJsKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuTFBBUkVOKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuTEFDQ09MKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuTEJSQUNLKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuUVVPVEUpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5EUVVPVEUpKSkgIT09IDApKSB7XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnN0YXRlID0gNzc7XG5cdFx0XHRcdFx0dGhpcy5zZW50ZW5jZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDgyO1xuXHRcdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0XHRfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnN0YXRlID0gODM7XG5cdFx0XHRcdHRoaXMubWF0Y2goU2ltcGxlVGV4dFBhcnNlci5SQlJBQ0spO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBTaW1wbGVUZXh0UGFyc2VyLkxBQ0NPTDpcblx0XHRcdFx0dGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgNSk7XG5cdFx0XHRcdHtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDg0O1xuXHRcdFx0XHR0aGlzLm1hdGNoKFNpbXBsZVRleHRQYXJzZXIuTEFDQ09MKTtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDg4O1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRcdF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHRcdFx0XHR3aGlsZSAoKCgoX2xhKSAmIH4weDFGKSA9PT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLldvcmQpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5TbWlsZXkpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5VcmwpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5MUEFSRU4pIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5MQUNDT0wpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5MQlJBQ0spIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5RVU9URSkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkRRVU9URSkpKSAhPT0gMCkpIHtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUgPSA4NTtcblx0XHRcdFx0XHR0aGlzLnNlbnRlbmNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnN0YXRlID0gOTA7XG5cdFx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0XHRcdF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA5MTtcblx0XHRcdFx0dGhpcy5tYXRjaChTaW1wbGVUZXh0UGFyc2VyLlJBQ0NPTCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChyZSkge1xuXHRcdFx0aWYgKHJlIGluc3RhbmNlb2YgUmVjb2duaXRpb25FeGNlcHRpb24pIHtcblx0XHRcdFx0X2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IHJlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHRoaXMuZXhpdFJ1bGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9sb2NhbGN0eDtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgX3NlcmlhbGl6ZWRBVE46IHN0cmluZyA9XG5cdFx0XCJcXHgwM1xcdUM5MURcXHVDQUJBXFx1MDU4RFxcdUFGQkFcXHU0RjUzXFx1MDYwN1xcdUVBOEJcXHVDMjQxXFx4MDNcXHgxNWFcXHgwNFxceDAyXCIgK1xuXHRcdFwiXFx0XFx4MDJcXHgwNFxceDAzXFx0XFx4MDNcXHgwNFxceDA0XFx0XFx4MDRcXHgwNFxceDA1XFx0XFx4MDVcXHgwNFxceDA2XFx0XFx4MDZcXHgwNFxceDA3XCIgK1xuXHRcdFwiXFx0XFx4MDdcXHgwNFxcYlxcdFxcYlxceDAzXFx4MDJcXHgwN1xceDAyXFx4MTJcXG5cXHgwMlxcZlxceDAyXFx4MEVcXHgwMlxceDE1XFx2XFx4MDJcXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MDNcXHgwMlxceDAzXFx4MDNcXHgwNlxceDAzXFx4MUFcXG5cXHgwM1xcclxceDAzXFx4MEVcXHgwM1xceDFCXFx4MDNcXHgwM1xceDA1XFx4MDNcIiArXG5cdFx0XCJcXHgxRlxcblxceDAzXFx4MDNcXHgwNFxceDAzXFx4MDRcXHgwNlxceDA0I1xcblxceDA0XFxyXFx4MDRcXHgwRVxceDA0JFxceDAzXFx4MDRcXHgwNVxceDA0XCIgK1xuXHRcdFwiKFxcblxceDA0XFx4MDNcXHgwNVxceDAzXFx4MDVcXHgwM1xceDA2XFx4MDZcXHgwNi1cXG5cXHgwNlxcclxceDA2XFx4MEVcXHgwNi5cXHgwM1xceDA2XCIgK1xuXHRcdFwiXFx4MDNcXHgwNlxceDA1XFx4MDYzXFxuXFx4MDZcXHgwM1xceDA3XFx4MDNcXHgwN1xceDAzXFxiXFx4MDNcXGJcXHgwN1xcYjlcXG5cXGJcXGZcXGJcXHgwRVwiICtcblx0XHRcIlxcYjxcXHZcXGJcXHgwM1xcYlxceDAzXFxiXFx4MDNcXGJcXHgwN1xcYkFcXG5cXGJcXGZcXGJcXHgwRVxcYkRcXHZcXGJcXHgwM1xcYlxceDAzXFxiXFx4MDNcXGJcIiArXG5cdFx0XCJcXHgwN1xcYklcXG5cXGJcXGZcXGJcXHgwRVxcYkxcXHZcXGJcXHgwM1xcYlxceDAzXFxiXFx4MDNcXGJcXHgwN1xcYlFcXG5cXGJcXGZcXGJcXHgwRVxcYlRcXHZcXGJcIiArXG5cdFx0XCJcXHgwM1xcYlxceDAzXFxiXFx4MDNcXGJcXHgwN1xcYllcXG5cXGJcXGZcXGJcXHgwRVxcYlxcXFxcXHZcXGJcXHgwM1xcYlxceDA1XFxiX1xcblxcYlxceDAzXFxiXFx4MDJcIiArXG5cdFx0XCJcXHgwMlxceDAyXFx0XFx4MDJcXHgwMlxceDA0XFx4MDJcXHgwNlxceDAyXFxiXFx4MDJcXG5cXHgwMlxcZlxceDAyXFx4MEVcXHgwMlxceDAyXFx4MDRcXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MTFcXHgxM1xceDAzXFx4MDJcXHgwM1xceDA1XFx4MDJrXFx4MDJcXHgxM1xceDAzXFx4MDJcXHgwMlxceDAyXFx4MDRcXHgxOVxceDAzXCIgK1xuXHRcdFwiXFx4MDJcXHgwMlxceDAyXFx4MDZcXFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXGIpXFx4MDNcXHgwMlxceDAyXFx4MDJcXG4yXFx4MDNcXHgwMlxceDAyXFx4MDJcIiArXG5cdFx0XCJcXGY0XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwRV5cXHgwM1xceDAyXFx4MDJcXHgwMlxceDEwXFx4MTJcXHgwNVxceDA0XFx4MDNcXHgwMlxceDExXFx4MTBcIiArXG5cdFx0XCJcXHgwM1xceDAyXFx4MDJcXHgwMlxceDEyXFx4MTVcXHgwM1xceDAyXFx4MDJcXHgwMlxceDEzXFx4MTFcXHgwM1xceDAyXFx4MDJcXHgwMlxceDEzXFx4MTRcIiArXG5cdFx0XCJcXHgwM1xceDAyXFx4MDJcXHgwMlxceDE0XFx4MTZcXHgwM1xceDAyXFx4MDJcXHgwMlxceDE1XFx4MTNcXHgwM1xceDAyXFx4MDJcXHgwMlxceDE2XFx4MTdcIiArXG5cdFx0XCJcXHgwN1xceDAyXFx4MDJcXHgwM1xceDE3XFx4MDNcXHgwM1xceDAyXFx4MDJcXHgwMlxceDE4XFx4MUFcXHgwNVxceDA2XFx4MDRcXHgwMlxceDE5XFx4MThcIiArXG5cdFx0XCJcXHgwM1xceDAyXFx4MDJcXHgwMlxceDFBXFx4MUJcXHgwM1xceDAyXFx4MDJcXHgwMlxceDFCXFx4MTlcXHgwM1xceDAyXFx4MDJcXHgwMlxceDFCXFx4MUNcIiArXG5cdFx0XCJcXHgwM1xceDAyXFx4MDJcXHgwMlxceDFDXFx4MUVcXHgwM1xceDAyXFx4MDJcXHgwMlxceDFEXFx4MUZcXHgwNVxcblxceDA2XFx4MDJcXHgxRVxceDFEXCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxRVxceDFGXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxRlxceDA1XFx4MDNcXHgwMlxceDAyXFx4MDIgI1xceDA1XCIgK1xuXHRcdFwiXFxmXFx4MDdcXHgwMiEjXFx4MDVcXHgwRVxcYlxceDAyXFxcIiBcXHgwM1xceDAyXFx4MDJcXHgwMlxcXCIhXFx4MDNcXHgwMlxceDAyXFx4MDIjJFxceDAzXCIgK1xuXHRcdFwiXFx4MDJcXHgwMlxceDAyJFxcXCJcXHgwM1xceDAyXFx4MDJcXHgwMiQlXFx4MDNcXHgwMlxceDAyXFx4MDIlXFwnXFx4MDNcXHgwMlxceDAyXFx4MDImXCIgK1xuXHRcdFwiKFxceDA1XFxiXFx4MDVcXHgwMlxcJyZcXHgwM1xceDAyXFx4MDJcXHgwMlxcJyhcXHgwM1xceDAyXFx4MDJcXHgwMihcXHgwN1xceDAzXFx4MDJcXHgwMlwiICtcblx0XHRcIlxceDAyKSpcXHRcXHgwMlxceDAyXFx4MDIqXFx0XFx4MDNcXHgwMlxceDAyXFx4MDIrLVxceDA3XFx4MDZcXHgwMlxceDAyLCtcXHgwM1xceDAyXFx4MDJcIiArXG5cdFx0XCJcXHgwMi0uXFx4MDNcXHgwMlxceDAyXFx4MDIuLFxceDAzXFx4MDJcXHgwMlxceDAyLi9cXHgwM1xceDAyXFx4MDJcXHgwMi8zXFx4MDNcXHgwMlxceDAyXCIgK1xuXHRcdFwiXFx4MDIwM1xceDA3XFx4MDdcXHgwMlxceDAyMTNcXHgwN1xcYlxceDAyXFx4MDIyLFxceDAzXFx4MDJcXHgwMlxceDAyMjBcXHgwM1xceDAyXFx4MDJcIiArXG5cdFx0XCJcXHgwMjIxXFx4MDNcXHgwMlxceDAyXFx4MDIzXFx2XFx4MDNcXHgwMlxceDAyXFx4MDI0NVxcdFxceDAzXFx4MDJcXHgwMjVcXHJcXHgwM1xceDAyXFx4MDJcIiArXG5cdFx0XCJcXHgwMjY6XFx4MDdcXHRcXHgwMlxceDAyNzlcXHgwNVxceDA0XFx4MDNcXHgwMjg3XFx4MDNcXHgwMlxceDAyXFx4MDI5PFxceDAzXFx4MDJcXHgwMlwiICtcblx0XHRcIlxceDAyOjhcXHgwM1xceDAyXFx4MDJcXHgwMjo7XFx4MDNcXHgwMlxceDAyXFx4MDI7PVxceDAzXFx4MDJcXHgwMlxceDAyPDpcXHgwM1xceDAyXFx4MDJcIiArXG5cdFx0XCJcXHgwMj1fXFx4MDdcXG5cXHgwMlxceDAyPkJcXHgwN1xceDBGXFx4MDJcXHgwMj9BXFx4MDVcXHgwNFxceDAzXFx4MDJAP1xceDAzXFx4MDJcXHgwMlwiICtcblx0XHRcIlxceDAyQURcXHgwM1xceDAyXFx4MDJcXHgwMkJAXFx4MDNcXHgwMlxceDAyXFx4MDJCQ1xceDAzXFx4MDJcXHgwMlxceDAyQ0VcXHgwM1xceDAyXFx4MDJcIiArXG5cdFx0XCJcXHgwMkRCXFx4MDNcXHgwMlxceDAyXFx4MDJFX1xceDA3XFx4MEZcXHgwMlxceDAyRkpcXHgwN1xceDEwXFx4MDJcXHgwMkdJXFx4MDVcXHgwNFxceDAzXCIgK1xuXHRcdFwiXFx4MDJIR1xceDAzXFx4MDJcXHgwMlxceDAySUxcXHgwM1xceDAyXFx4MDJcXHgwMkpIXFx4MDNcXHgwMlxceDAyXFx4MDJKS1xceDAzXFx4MDJcXHgwMlwiICtcblx0XHRcIlxceDAyS01cXHgwM1xceDAyXFx4MDJcXHgwMkxKXFx4MDNcXHgwMlxceDAyXFx4MDJNX1xceDA3XFx4MTBcXHgwMlxceDAyTlJcXHgwN1xcclxceDAyXCIgK1xuXHRcdFwiXFx4MDJPUVxceDA1XFx4MDRcXHgwM1xceDAyUE9cXHgwM1xceDAyXFx4MDJcXHgwMlFUXFx4MDNcXHgwMlxceDAyXFx4MDJSUFxceDAzXFx4MDJcXHgwMlwiICtcblx0XHRcIlxceDAyUlNcXHgwM1xceDAyXFx4MDJcXHgwMlNVXFx4MDNcXHgwMlxceDAyXFx4MDJUUlxceDAzXFx4MDJcXHgwMlxceDAyVV9cXHgwN1xceDBFXFx4MDJcIiArXG5cdFx0XCJcXHgwMlZaXFx4MDdcXHZcXHgwMlxceDAyV1lcXHgwNVxceDA0XFx4MDNcXHgwMlhXXFx4MDNcXHgwMlxceDAyXFx4MDJZXFxcXFxceDAzXFx4MDJcXHgwMlwiICtcblx0XHRcIlxceDAyWlhcXHgwM1xceDAyXFx4MDJcXHgwMlpbXFx4MDNcXHgwMlxceDAyXFx4MDJbXVxceDAzXFx4MDJcXHgwMlxceDAyXFxcXFpcXHgwM1xceDAyXCIgK1xuXHRcdFwiXFx4MDJcXHgwMl1fXFx4MDdcXGZcXHgwMlxceDAyXjZcXHgwM1xceDAyXFx4MDJcXHgwMl4+XFx4MDNcXHgwMlxceDAyXFx4MDJeRlxceDAzXFx4MDJcIiArXG5cdFx0XCJcXHgwMlxceDAyXk5cXHgwM1xceDAyXFx4MDJcXHgwMl5WXFx4MDNcXHgwMlxceDAyXFx4MDJfXFx4MEZcXHgwM1xceDAyXFx4MDJcXHgwMlxceDEwXCIgK1xuXHRcdFwiXFx4MTNcXHgxQlxceDFFXFxcIiRcXCcuMjpCSlJaXlwiO1xuXHRwdWJsaWMgc3RhdGljIF9fQVROOiBBVE47XG5cdHB1YmxpYyBzdGF0aWMgZ2V0IF9BVE4oKTogQVROIHtcblx0XHRpZiAoIVNpbXBsZVRleHRQYXJzZXIuX19BVE4pIHtcblx0XHRcdFNpbXBsZVRleHRQYXJzZXIuX19BVE4gPSBuZXcgQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoVXRpbHMudG9DaGFyQXJyYXkoU2ltcGxlVGV4dFBhcnNlci5fc2VyaWFsaXplZEFUTikpO1xuXHRcdH1cblxuXHRcdHJldHVybiBTaW1wbGVUZXh0UGFyc2VyLl9fQVROO1xuXHR9XG5cbn1cblxuZXhwb3J0IGNsYXNzIFBhcmFncmFwaENvbnRleHQgZXh0ZW5kcyBQYXJzZXJSdWxlQ29udGV4dCB7XG5cdHB1YmxpYyBFT0YoKTogVGVybWluYWxOb2RlIHsgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5FT0YsIDApOyB9XG5cdHB1YmxpYyBzZW50ZW5jZSgpOiBTZW50ZW5jZUNvbnRleHRbXTtcblx0cHVibGljIHNlbnRlbmNlKGk6IG51bWJlcik6IFNlbnRlbmNlQ29udGV4dDtcblx0cHVibGljIHNlbnRlbmNlKGk/OiBudW1iZXIpOiBTZW50ZW5jZUNvbnRleHQgfCBTZW50ZW5jZUNvbnRleHRbXSB7XG5cdFx0aWYgKGkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKFNlbnRlbmNlQ29udGV4dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIFNlbnRlbmNlQ29udGV4dCk7XG5cdFx0fVxuXHR9XG5cdGNvbnN0cnVjdG9yKHBhcmVudDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsIGludm9raW5nU3RhdGU6IG51bWJlcikge1xuXHRcdHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBnZXQgcnVsZUluZGV4KCk6IG51bWJlciB7IHJldHVybiBTaW1wbGVUZXh0UGFyc2VyLlJVTEVfcGFyYWdyYXBoOyB9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZW50ZXJSdWxlKGxpc3RlbmVyOiBTaW1wbGVUZXh0TGlzdGVuZXIpOiB2b2lkIHtcblx0XHRpZiAobGlzdGVuZXIuZW50ZXJQYXJhZ3JhcGgpIHtcblx0XHRcdGxpc3RlbmVyLmVudGVyUGFyYWdyYXBoKHRoaXMpO1xuXHRcdH1cblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGV4aXRSdWxlKGxpc3RlbmVyOiBTaW1wbGVUZXh0TGlzdGVuZXIpOiB2b2lkIHtcblx0XHRpZiAobGlzdGVuZXIuZXhpdFBhcmFncmFwaCkge1xuXHRcdFx0bGlzdGVuZXIuZXhpdFBhcmFncmFwaCh0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBhY2NlcHQ8UmVzdWx0Pih2aXNpdG9yOiBTaW1wbGVUZXh0VmlzaXRvcjxSZXN1bHQ+KTogUmVzdWx0IHtcblx0XHRpZiAodmlzaXRvci52aXNpdFBhcmFncmFwaCkge1xuXHRcdFx0cmV0dXJuIHZpc2l0b3IudmlzaXRQYXJhZ3JhcGgodGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG5cdFx0fVxuXHR9XG59XG5cblxuZXhwb3J0IGNsYXNzIFNlbnRlbmNlQ29udGV4dCBleHRlbmRzIFBhcnNlclJ1bGVDb250ZXh0IHtcblx0cHVibGljIHByb3Bvc2l0aW9uKCk6IFByb3Bvc2l0aW9uQ29udGV4dFtdO1xuXHRwdWJsaWMgcHJvcG9zaXRpb24oaTogbnVtYmVyKTogUHJvcG9zaXRpb25Db250ZXh0O1xuXHRwdWJsaWMgcHJvcG9zaXRpb24oaT86IG51bWJlcik6IFByb3Bvc2l0aW9uQ29udGV4dCB8IFByb3Bvc2l0aW9uQ29udGV4dFtdIHtcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoUHJvcG9zaXRpb25Db250ZXh0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgUHJvcG9zaXRpb25Db250ZXh0KTtcblx0XHR9XG5cdH1cblx0cHVibGljIGVuZFB1bmN0dWF0aW9uKCk6IEVuZFB1bmN0dWF0aW9uQ29udGV4dCB8IHVuZGVmaW5lZCB7XG5cdFx0cmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgRW5kUHVuY3R1YXRpb25Db250ZXh0KTtcblx0fVxuXHRjb25zdHJ1Y3RvcihwYXJlbnQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLCBpbnZva2luZ1N0YXRlOiBudW1iZXIpIHtcblx0XHRzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZ2V0IHJ1bGVJbmRleCgpOiBudW1iZXIgeyByZXR1cm4gU2ltcGxlVGV4dFBhcnNlci5SVUxFX3NlbnRlbmNlOyB9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZW50ZXJSdWxlKGxpc3RlbmVyOiBTaW1wbGVUZXh0TGlzdGVuZXIpOiB2b2lkIHtcblx0XHRpZiAobGlzdGVuZXIuZW50ZXJTZW50ZW5jZSkge1xuXHRcdFx0bGlzdGVuZXIuZW50ZXJTZW50ZW5jZSh0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBleGl0UnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmV4aXRTZW50ZW5jZSkge1xuXHRcdFx0bGlzdGVuZXIuZXhpdFNlbnRlbmNlKHRoaXMpO1xuXHRcdH1cblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGFjY2VwdDxSZXN1bHQ+KHZpc2l0b3I6IFNpbXBsZVRleHRWaXNpdG9yPFJlc3VsdD4pOiBSZXN1bHQge1xuXHRcdGlmICh2aXNpdG9yLnZpc2l0U2VudGVuY2UpIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0U2VudGVuY2UodGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG5cdFx0fVxuXHR9XG59XG5cblxuZXhwb3J0IGNsYXNzIFByb3Bvc2l0aW9uQ29udGV4dCBleHRlbmRzIFBhcnNlclJ1bGVDb250ZXh0IHtcblx0cHVibGljIHdvcmQoKTogV29yZENvbnRleHRbXTtcblx0cHVibGljIHdvcmQoaTogbnVtYmVyKTogV29yZENvbnRleHQ7XG5cdHB1YmxpYyB3b3JkKGk/OiBudW1iZXIpOiBXb3JkQ29udGV4dCB8IFdvcmRDb250ZXh0W10ge1xuXHRcdGlmIChpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhXb3JkQ29udGV4dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIFdvcmRDb250ZXh0KTtcblx0XHR9XG5cdH1cblx0cHVibGljIGV4cHJlc3Npb24oKTogRXhwcmVzc2lvbkNvbnRleHRbXTtcblx0cHVibGljIGV4cHJlc3Npb24oaTogbnVtYmVyKTogRXhwcmVzc2lvbkNvbnRleHQ7XG5cdHB1YmxpYyBleHByZXNzaW9uKGk/OiBudW1iZXIpOiBFeHByZXNzaW9uQ29udGV4dCB8IEV4cHJlc3Npb25Db250ZXh0W10ge1xuXHRcdGlmIChpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhFeHByZXNzaW9uQ29udGV4dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIEV4cHJlc3Npb25Db250ZXh0KTtcblx0XHR9XG5cdH1cblx0cHVibGljIG1pZFB1bmN0dWF0aW9uKCk6IE1pZFB1bmN0dWF0aW9uQ29udGV4dCB8IHVuZGVmaW5lZCB7XG5cdFx0cmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgTWlkUHVuY3R1YXRpb25Db250ZXh0KTtcblx0fVxuXHRjb25zdHJ1Y3RvcihwYXJlbnQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLCBpbnZva2luZ1N0YXRlOiBudW1iZXIpIHtcblx0XHRzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZ2V0IHJ1bGVJbmRleCgpOiBudW1iZXIgeyByZXR1cm4gU2ltcGxlVGV4dFBhcnNlci5SVUxFX3Byb3Bvc2l0aW9uOyB9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZW50ZXJSdWxlKGxpc3RlbmVyOiBTaW1wbGVUZXh0TGlzdGVuZXIpOiB2b2lkIHtcblx0XHRpZiAobGlzdGVuZXIuZW50ZXJQcm9wb3NpdGlvbikge1xuXHRcdFx0bGlzdGVuZXIuZW50ZXJQcm9wb3NpdGlvbih0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBleGl0UnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmV4aXRQcm9wb3NpdGlvbikge1xuXHRcdFx0bGlzdGVuZXIuZXhpdFByb3Bvc2l0aW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGFjY2VwdDxSZXN1bHQ+KHZpc2l0b3I6IFNpbXBsZVRleHRWaXNpdG9yPFJlc3VsdD4pOiBSZXN1bHQge1xuXHRcdGlmICh2aXNpdG9yLnZpc2l0UHJvcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0UHJvcG9zaXRpb24odGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG5cdFx0fVxuXHR9XG59XG5cblxuZXhwb3J0IGNsYXNzIE1pZFB1bmN0dWF0aW9uQ29udGV4dCBleHRlbmRzIFBhcnNlclJ1bGVDb250ZXh0IHtcblx0cHVibGljIENPTU1BKCk6IFRlcm1pbmFsTm9kZSB8IHVuZGVmaW5lZCB7IHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNpbXBsZVRleHRQYXJzZXIuQ09NTUEsIDApOyB9XG5cdHB1YmxpYyBDT0xPTigpOiBUZXJtaW5hbE5vZGUgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLkNPTE9OLCAwKTsgfVxuXHRwdWJsaWMgU0VNSUNPTE9OKCk6IFRlcm1pbmFsTm9kZSB8IHVuZGVmaW5lZCB7IHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNpbXBsZVRleHRQYXJzZXIuU0VNSUNPTE9OLCAwKTsgfVxuXHRjb25zdHJ1Y3RvcihwYXJlbnQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLCBpbnZva2luZ1N0YXRlOiBudW1iZXIpIHtcblx0XHRzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZ2V0IHJ1bGVJbmRleCgpOiBudW1iZXIgeyByZXR1cm4gU2ltcGxlVGV4dFBhcnNlci5SVUxFX21pZFB1bmN0dWF0aW9uOyB9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZW50ZXJSdWxlKGxpc3RlbmVyOiBTaW1wbGVUZXh0TGlzdGVuZXIpOiB2b2lkIHtcblx0XHRpZiAobGlzdGVuZXIuZW50ZXJNaWRQdW5jdHVhdGlvbikge1xuXHRcdFx0bGlzdGVuZXIuZW50ZXJNaWRQdW5jdHVhdGlvbih0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBleGl0UnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmV4aXRNaWRQdW5jdHVhdGlvbikge1xuXHRcdFx0bGlzdGVuZXIuZXhpdE1pZFB1bmN0dWF0aW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGFjY2VwdDxSZXN1bHQ+KHZpc2l0b3I6IFNpbXBsZVRleHRWaXNpdG9yPFJlc3VsdD4pOiBSZXN1bHQge1xuXHRcdGlmICh2aXNpdG9yLnZpc2l0TWlkUHVuY3R1YXRpb24pIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0TWlkUHVuY3R1YXRpb24odGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG5cdFx0fVxuXHR9XG59XG5cblxuZXhwb3J0IGNsYXNzIEVuZFB1bmN0dWF0aW9uQ29udGV4dCBleHRlbmRzIFBhcnNlclJ1bGVDb250ZXh0IHtcblx0cHVibGljIERPVCgpOiBUZXJtaW5hbE5vZGVbXTtcblx0cHVibGljIERPVChpOiBudW1iZXIpOiBUZXJtaW5hbE5vZGU7XG5cdHB1YmxpYyBET1QoaT86IG51bWJlcik6IFRlcm1pbmFsTm9kZSB8IFRlcm1pbmFsTm9kZVtdIHtcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUb2tlbnMoU2ltcGxlVGV4dFBhcnNlci5ET1QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLkRPVCwgaSk7XG5cdFx0fVxuXHR9XG5cdHB1YmxpYyBRVUVTVElPTl9NQVJLKCk6IFRlcm1pbmFsTm9kZSB8IHVuZGVmaW5lZCB7IHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNpbXBsZVRleHRQYXJzZXIuUVVFU1RJT05fTUFSSywgMCk7IH1cblx0cHVibGljIEVYQ0xBTUFUSU9OX01BUksoKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5FWENMQU1BVElPTl9NQVJLLCAwKTsgfVxuXHRjb25zdHJ1Y3RvcihwYXJlbnQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLCBpbnZva2luZ1N0YXRlOiBudW1iZXIpIHtcblx0XHRzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZ2V0IHJ1bGVJbmRleCgpOiBudW1iZXIgeyByZXR1cm4gU2ltcGxlVGV4dFBhcnNlci5SVUxFX2VuZFB1bmN0dWF0aW9uOyB9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZW50ZXJSdWxlKGxpc3RlbmVyOiBTaW1wbGVUZXh0TGlzdGVuZXIpOiB2b2lkIHtcblx0XHRpZiAobGlzdGVuZXIuZW50ZXJFbmRQdW5jdHVhdGlvbikge1xuXHRcdFx0bGlzdGVuZXIuZW50ZXJFbmRQdW5jdHVhdGlvbih0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBleGl0UnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmV4aXRFbmRQdW5jdHVhdGlvbikge1xuXHRcdFx0bGlzdGVuZXIuZXhpdEVuZFB1bmN0dWF0aW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGFjY2VwdDxSZXN1bHQ+KHZpc2l0b3I6IFNpbXBsZVRleHRWaXNpdG9yPFJlc3VsdD4pOiBSZXN1bHQge1xuXHRcdGlmICh2aXNpdG9yLnZpc2l0RW5kUHVuY3R1YXRpb24pIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0RW5kUHVuY3R1YXRpb24odGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG5cdFx0fVxuXHR9XG59XG5cblxuZXhwb3J0IGNsYXNzIFdvcmRDb250ZXh0IGV4dGVuZHMgUGFyc2VyUnVsZUNvbnRleHQge1xuXHRwdWJsaWMgV29yZCgpOiBUZXJtaW5hbE5vZGUgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLldvcmQsIDApOyB9XG5cdHB1YmxpYyBTbWlsZXkoKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5TbWlsZXksIDApOyB9XG5cdHB1YmxpYyBVcmwoKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5VcmwsIDApOyB9XG5cdGNvbnN0cnVjdG9yKHBhcmVudDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsIGludm9raW5nU3RhdGU6IG51bWJlcikge1xuXHRcdHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBnZXQgcnVsZUluZGV4KCk6IG51bWJlciB7IHJldHVybiBTaW1wbGVUZXh0UGFyc2VyLlJVTEVfd29yZDsgfVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGVudGVyUnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmVudGVyV29yZCkge1xuXHRcdFx0bGlzdGVuZXIuZW50ZXJXb3JkKHRoaXMpO1xuXHRcdH1cblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGV4aXRSdWxlKGxpc3RlbmVyOiBTaW1wbGVUZXh0TGlzdGVuZXIpOiB2b2lkIHtcblx0XHRpZiAobGlzdGVuZXIuZXhpdFdvcmQpIHtcblx0XHRcdGxpc3RlbmVyLmV4aXRXb3JkKHRoaXMpO1xuXHRcdH1cblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGFjY2VwdDxSZXN1bHQ+KHZpc2l0b3I6IFNpbXBsZVRleHRWaXNpdG9yPFJlc3VsdD4pOiBSZXN1bHQge1xuXHRcdGlmICh2aXNpdG9yLnZpc2l0V29yZCkge1xuXHRcdFx0cmV0dXJuIHZpc2l0b3IudmlzaXRXb3JkKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuXHRcdH1cblx0fVxufVxuXG5cbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uQ29udGV4dCBleHRlbmRzIFBhcnNlclJ1bGVDb250ZXh0IHtcblx0cHVibGljIExQQVJFTigpOiBUZXJtaW5hbE5vZGUgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLkxQQVJFTiwgMCk7IH1cblx0cHVibGljIFJQQVJFTigpOiBUZXJtaW5hbE5vZGUgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLlJQQVJFTiwgMCk7IH1cblx0cHVibGljIHNlbnRlbmNlKCk6IFNlbnRlbmNlQ29udGV4dFtdO1xuXHRwdWJsaWMgc2VudGVuY2UoaTogbnVtYmVyKTogU2VudGVuY2VDb250ZXh0O1xuXHRwdWJsaWMgc2VudGVuY2UoaT86IG51bWJlcik6IFNlbnRlbmNlQ29udGV4dCB8IFNlbnRlbmNlQ29udGV4dFtdIHtcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoU2VudGVuY2VDb250ZXh0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgU2VudGVuY2VDb250ZXh0KTtcblx0XHR9XG5cdH1cblx0cHVibGljIFFVT1RFKCk6IFRlcm1pbmFsTm9kZVtdO1xuXHRwdWJsaWMgUVVPVEUoaTogbnVtYmVyKTogVGVybWluYWxOb2RlO1xuXHRwdWJsaWMgUVVPVEUoaT86IG51bWJlcik6IFRlcm1pbmFsTm9kZSB8IFRlcm1pbmFsTm9kZVtdIHtcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUb2tlbnMoU2ltcGxlVGV4dFBhcnNlci5RVU9URSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFRva2VuKFNpbXBsZVRleHRQYXJzZXIuUVVPVEUsIGkpO1xuXHRcdH1cblx0fVxuXHRwdWJsaWMgRFFVT1RFKCk6IFRlcm1pbmFsTm9kZVtdO1xuXHRwdWJsaWMgRFFVT1RFKGk6IG51bWJlcik6IFRlcm1pbmFsTm9kZTtcblx0cHVibGljIERRVU9URShpPzogbnVtYmVyKTogVGVybWluYWxOb2RlIHwgVGVybWluYWxOb2RlW10ge1xuXHRcdGlmIChpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFRva2VucyhTaW1wbGVUZXh0UGFyc2VyLkRRVU9URSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFRva2VuKFNpbXBsZVRleHRQYXJzZXIuRFFVT1RFLCBpKTtcblx0XHR9XG5cdH1cblx0cHVibGljIExCUkFDSygpOiBUZXJtaW5hbE5vZGUgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLkxCUkFDSywgMCk7IH1cblx0cHVibGljIFJCUkFDSygpOiBUZXJtaW5hbE5vZGUgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLlJCUkFDSywgMCk7IH1cblx0cHVibGljIExBQ0NPTCgpOiBUZXJtaW5hbE5vZGUgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLkxBQ0NPTCwgMCk7IH1cblx0cHVibGljIFJBQ0NPTCgpOiBUZXJtaW5hbE5vZGUgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLlJBQ0NPTCwgMCk7IH1cblx0Y29uc3RydWN0b3IocGFyZW50OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgaW52b2tpbmdTdGF0ZTogbnVtYmVyKSB7XG5cdFx0c3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBydWxlSW5kZXgoKTogbnVtYmVyIHsgcmV0dXJuIFNpbXBsZVRleHRQYXJzZXIuUlVMRV9leHByZXNzaW9uOyB9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZW50ZXJSdWxlKGxpc3RlbmVyOiBTaW1wbGVUZXh0TGlzdGVuZXIpOiB2b2lkIHtcblx0XHRpZiAobGlzdGVuZXIuZW50ZXJFeHByZXNzaW9uKSB7XG5cdFx0XHRsaXN0ZW5lci5lbnRlckV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZXhpdFJ1bGUobGlzdGVuZXI6IFNpbXBsZVRleHRMaXN0ZW5lcik6IHZvaWQge1xuXHRcdGlmIChsaXN0ZW5lci5leGl0RXhwcmVzc2lvbikge1xuXHRcdFx0bGlzdGVuZXIuZXhpdEV4cHJlc3Npb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgYWNjZXB0PFJlc3VsdD4odmlzaXRvcjogU2ltcGxlVGV4dFZpc2l0b3I8UmVzdWx0Pik6IFJlc3VsdCB7XG5cdFx0aWYgKHZpc2l0b3IudmlzaXRFeHByZXNzaW9uKSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb24odGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG5cdFx0fVxuXHR9XG59XG5cblxuIiwgIi8vIEdlbmVyYXRlZCBmcm9tIFNpbXBsZVRleHQuZzQgYnkgQU5UTFIgNC45LjAtU05BUFNIT1RcblxuXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiYW50bHI0dHMvYXRuL0FUTlwiO1xuaW1wb3J0IHsgQVRORGVzZXJpYWxpemVyIH0gZnJvbSBcImFudGxyNHRzL2F0bi9BVE5EZXNlcmlhbGl6ZXJcIjtcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiYW50bHI0dHMvQ2hhclN0cmVhbVwiO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiYW50bHI0dHMvTGV4ZXJcIjtcbmltcG9ydCB7IExleGVyQVROU2ltdWxhdG9yIH0gZnJvbSBcImFudGxyNHRzL2F0bi9MZXhlckFUTlNpbXVsYXRvclwiO1xuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCJhbnRscjR0cy9EZWNvcmF0b3JzXCI7XG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCJhbnRscjR0cy9EZWNvcmF0b3JzXCI7XG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCJhbnRscjR0cy9SdWxlQ29udGV4dFwiO1xuaW1wb3J0IHsgVm9jYWJ1bGFyeSB9IGZyb20gXCJhbnRscjR0cy9Wb2NhYnVsYXJ5XCI7XG5pbXBvcnQgeyBWb2NhYnVsYXJ5SW1wbCB9IGZyb20gXCJhbnRscjR0cy9Wb2NhYnVsYXJ5SW1wbFwiO1xuXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiYW50bHI0dHMvbWlzYy9VdGlsc1wiO1xuXG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVUZXh0TGV4ZXIgZXh0ZW5kcyBMZXhlciB7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgV29yZCA9IDE7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU21pbGV5ID0gMjtcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBVcmwgPSAzO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERPVCA9IDQ7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUVVFU1RJT05fTUFSSyA9IDU7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRVhDTEFNQVRJT05fTUFSSyA9IDY7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTFBBUkVOID0gNztcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBSUEFSRU4gPSA4O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExBQ0NPTCA9IDk7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUkFDQ09MID0gMTA7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTEJSQUNLID0gMTE7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUkJSQUNLID0gMTI7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUVVPVEUgPSAxMztcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBEUVVPVEUgPSAxNDtcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBDT0xPTiA9IDE1O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENPTU1BID0gMTY7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU0VNSUNPTE9OID0gMTc7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU01JTEVZID0gMTg7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgV1MgPSAxOTtcblxuXHQvLyB0c2xpbnQ6ZGlzYWJsZTpuby10cmFpbGluZy13aGl0ZXNwYWNlXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY2hhbm5lbE5hbWVzOiBzdHJpbmdbXSA9IFtcblx0XHRcIkRFRkFVTFRfVE9LRU5fQ0hBTk5FTFwiLCBcIkhJRERFTlwiLFxuXHRdO1xuXG5cdC8vIHRzbGludDpkaXNhYmxlOm5vLXRyYWlsaW5nLXdoaXRlc3BhY2Vcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBtb2RlTmFtZXM6IHN0cmluZ1tdID0gW1xuXHRcdFwiREVGQVVMVF9NT0RFXCIsXG5cdF07XG5cblx0cHVibGljIHN0YXRpYyByZWFkb25seSBydWxlTmFtZXM6IHN0cmluZ1tdID0gW1xuXHRcdFwiV29yZFwiLCBcIlNtaWxleVwiLCBcIlVybFwiLCBcIkRPVFwiLCBcIlFVRVNUSU9OX01BUktcIiwgXCJFWENMQU1BVElPTl9NQVJLXCIsIFwiTFBBUkVOXCIsIFxuXHRcdFwiUlBBUkVOXCIsIFwiTEFDQ09MXCIsIFwiUkFDQ09MXCIsIFwiTEJSQUNLXCIsIFwiUkJSQUNLXCIsIFwiUVVPVEVcIiwgXCJEUVVPVEVcIiwgXCJDT0xPTlwiLCBcblx0XHRcIkNPTU1BXCIsIFwiU0VNSUNPTE9OXCIsIFwiU01JTEVZXCIsIFwiU1BBQ0VcIiwgXCJXU1wiLFxuXHRdO1xuXG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IF9MSVRFUkFMX05BTUVTOiBBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0gW1xuXHRcdHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCInLidcIiwgXCInPydcIiwgXCInISdcIiwgXCInKCdcIiwgXG5cdFx0XCInKSdcIiwgXCIneydcIiwgXCInfSdcIiwgXCInWydcIiwgXCInXSdcIiwgdW5kZWZpbmVkLCBcIidcXFwiJ1wiLCBcIic6J1wiLCBcIicsJ1wiLCBcIic7J1wiLFxuXHRdO1xuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBfU1lNQk9MSUNfTkFNRVM6IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZD4gPSBbXG5cdFx0dW5kZWZpbmVkLCBcIldvcmRcIiwgXCJTbWlsZXlcIiwgXCJVcmxcIiwgXCJET1RcIiwgXCJRVUVTVElPTl9NQVJLXCIsIFwiRVhDTEFNQVRJT05fTUFSS1wiLCBcblx0XHRcIkxQQVJFTlwiLCBcIlJQQVJFTlwiLCBcIkxBQ0NPTFwiLCBcIlJBQ0NPTFwiLCBcIkxCUkFDS1wiLCBcIlJCUkFDS1wiLCBcIlFVT1RFXCIsIFwiRFFVT1RFXCIsIFxuXHRcdFwiQ09MT05cIiwgXCJDT01NQVwiLCBcIlNFTUlDT0xPTlwiLCBcIlNNSUxFWVwiLCBcIldTXCIsXG5cdF07XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVk9DQUJVTEFSWTogVm9jYWJ1bGFyeSA9IG5ldyBWb2NhYnVsYXJ5SW1wbChTaW1wbGVUZXh0TGV4ZXIuX0xJVEVSQUxfTkFNRVMsIFNpbXBsZVRleHRMZXhlci5fU1lNQk9MSUNfTkFNRVMsIFtdKTtcblxuXHQvLyBAT3ZlcnJpZGVcblx0Ly8gQE5vdE51bGxcblx0cHVibGljIGdldCB2b2NhYnVsYXJ5KCk6IFZvY2FidWxhcnkge1xuXHRcdHJldHVybiBTaW1wbGVUZXh0TGV4ZXIuVk9DQUJVTEFSWTtcblx0fVxuXHQvLyB0c2xpbnQ6ZW5hYmxlOm5vLXRyYWlsaW5nLXdoaXRlc3BhY2VcblxuXG5cdGNvbnN0cnVjdG9yKGlucHV0OiBDaGFyU3RyZWFtKSB7XG5cdFx0c3VwZXIoaW5wdXQpO1xuXHRcdHRoaXMuX2ludGVycCA9IG5ldyBMZXhlckFUTlNpbXVsYXRvcihTaW1wbGVUZXh0TGV4ZXIuX0FUTiwgdGhpcyk7XG5cdH1cblxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBncmFtbWFyRmlsZU5hbWUoKTogc3RyaW5nIHsgcmV0dXJuIFwiU2ltcGxlVGV4dC5nNFwiOyB9XG5cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBnZXQgcnVsZU5hbWVzKCk6IHN0cmluZ1tdIHsgcmV0dXJuIFNpbXBsZVRleHRMZXhlci5ydWxlTmFtZXM7IH1cblxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBzZXJpYWxpemVkQVROKCk6IHN0cmluZyB7IHJldHVybiBTaW1wbGVUZXh0TGV4ZXIuX3NlcmlhbGl6ZWRBVE47IH1cblxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBjaGFubmVsTmFtZXMoKTogc3RyaW5nW10geyByZXR1cm4gU2ltcGxlVGV4dExleGVyLmNoYW5uZWxOYW1lczsgfVxuXG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZ2V0IG1vZGVOYW1lcygpOiBzdHJpbmdbXSB7IHJldHVybiBTaW1wbGVUZXh0TGV4ZXIubW9kZU5hbWVzOyB9XG5cblx0cHVibGljIHN0YXRpYyByZWFkb25seSBfc2VyaWFsaXplZEFUTjogc3RyaW5nID1cblx0XHRcIlxceDAzXFx1QzkxRFxcdUNBQkFcXHUwNThEXFx1QUZCQVxcdTRGNTNcXHUwNjA3XFx1RUE4QlxcdUMyNDFcXHgwMlxceDE1XFx4N0ZcXGJcXHgwMVwiICtcblx0XHRcIlxceDA0XFx4MDJcXHRcXHgwMlxceDA0XFx4MDNcXHRcXHgwM1xceDA0XFx4MDRcXHRcXHgwNFxceDA0XFx4MDVcXHRcXHgwNVxceDA0XFx4MDZcXHRcXHgwNlwiICtcblx0XHRcIlxceDA0XFx4MDdcXHRcXHgwN1xceDA0XFxiXFx0XFxiXFx4MDRcXHRcXHRcXHRcXHgwNFxcblxcdFxcblxceDA0XFx2XFx0XFx2XFx4MDRcXGZcXHRcXGZcXHgwNFxcclwiICtcblx0XHRcIlxcdFxcclxceDA0XFx4MEVcXHRcXHgwRVxceDA0XFx4MEZcXHRcXHgwRlxceDA0XFx4MTBcXHRcXHgxMFxceDA0XFx4MTFcXHRcXHgxMVxceDA0XFx4MTJcXHRcIiArXG5cdFx0XCJcXHgxMlxceDA0XFx4MTNcXHRcXHgxM1xceDA0XFx4MTRcXHRcXHgxNFxceDA0XFx4MTVcXHRcXHgxNVxceDAzXFx4MDJcXHgwN1xceDAyLVxcblxceDAyXCIgK1xuXHRcdFwiXFxmXFx4MDJcXHgwRVxceDAyMFxcdlxceDAyXFx4MDNcXHgwMlxceDA2XFx4MDIzXFxuXFx4MDJcXHJcXHgwMlxceDBFXFx4MDI0XFx4MDNcXHgwM1xceDAzXCIgK1xuXHRcdFwiXFx4MDNcXHgwM1xceDA0XFx4MDNcXHgwNFxceDAzXFx4MDRcXHgwM1xceDA0XFx4MDNcXHgwNFxceDAzXFx4MDRcXHgwNVxceDA0P1xcblxceDA0XFx4MDNcIiArXG5cdFx0XCJcXHgwNFxceDAzXFx4MDRcXHgwM1xceDA0XFx4MDNcXHgwNFxceDAzXFx4MDRcXHgwM1xceDA0XFx4MDZcXHgwNEdcXG5cXHgwNFxcclxceDA0XFx4MEVcIiArXG5cdFx0XCJcXHgwNEhcXHgwM1xceDA1XFx4MDNcXHgwNVxceDAzXFx4MDZcXHgwM1xceDA2XFx4MDNcXHgwN1xceDAzXFx4MDdcXHgwM1xcYlxceDAzXFxiXFx4MDNcIiArXG5cdFx0XCJcXHRcXHgwM1xcdFxceDAzXFxuXFx4MDNcXG5cXHgwM1xcdlxceDAzXFx2XFx4MDNcXGZcXHgwM1xcZlxceDAzXFxyXFx4MDNcXHJcXHgwM1xceDBFXFx4MDNcXHgwRVwiICtcblx0XHRcIlxceDAzXFx4MEVcXHgwNVxceDBFYFxcblxceDBFXFx4MDNcXHgwRlxceDAzXFx4MEZcXHgwM1xceDEwXFx4MDNcXHgxMFxceDAzXFx4MTFcXHgwM1xceDExXCIgK1xuXHRcdFwiXFx4MDNcXHgxMlxceDAzXFx4MTJcXHgwM1xceDEzXFx4MDNcXHgxM1xceDA1XFx4MTNsXFxuXFx4MTNcXHgwM1xceDEzXFx4MDNcXHgxM1xceDAzXFx4MTNcIiArXG5cdFx0XCJcXHgwM1xceDEzXFx4MDNcXHgxM1xceDAzXFx4MTNcXHgwM1xceDEzXFx4MDVcXHgxM3VcXG5cXHgxM1xceDAzXFx4MTRcXHgwM1xceDE0XFx4MDNcXHgxNVwiICtcblx0XHRcIlxceDA2XFx4MTV6XFxuXFx4MTVcXHJcXHgxNVxceDBFXFx4MTV7XFx4MDNcXHgxNVxceDAzXFx4MTVcXHgwMlxceDAyXFx4MDJcXHgxNlxceDAzXFx4MDJcIiArXG5cdFx0XCJcXHgwM1xceDA1XFx4MDJcXHgwNFxceDA3XFx4MDJcXHgwNVxcdFxceDAyXFx4MDZcXHZcXHgwMlxceDA3XFxyXFx4MDJcXGJcXHgwRlxceDAyXFx0XFx4MTFcIiArXG5cdFx0XCJcXHgwMlxcblxceDEzXFx4MDJcXHZcXHgxNVxceDAyXFxmXFx4MTdcXHgwMlxcclxceDE5XFx4MDJcXHgwRVxceDFCXFx4MDJcXHgwRlxceDFEXFx4MDJcXHgxMFwiICtcblx0XHRcIlxceDFGXFx4MDJcXHgxMSFcXHgwMlxceDEyI1xceDAyXFx4MTMlXFx4MDJcXHgxNFxcJ1xceDAyXFx4MDIpXFx4MDJcXHgxNVxceDAzXFx4MDJcXHRcXHgwRVwiICtcblx0XHRcIlxceDAyXFx2XFxmXFx4MEVcXHgwRlxcXCIkKisuLjAwPT1BQV1dX199fVxceDdGXFx4N0ZcXHgwRVxceDAyXFx2XFxmXFx4MEVcXHgwRlxcXCIkKSsuXCIgK1xuXHRcdFwiLjAwPD1BQV1dX199fVxceDdGXFx4N0ZcXHgwNVxceDAyMjtDXFxcXGN8XFx4MDdcXHgwMiUlXFwnXFwnLV1fX2N8XFx4MDNcXHgwMjw9XFx4MDZcIiArXG5cdFx0XCJcXHgwMiorRkZycn5+XFx4MDVcXHgwMlxcdlxcZlxceDBFXFx4MEZcXFwiXFxcIlxceDAyXFx4ODVcXHgwMlxceDAzXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlwiICtcblx0XHRcIlxceDA1XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDA3XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxcdFxceDAzXFx4MDJcXHgwMlxceDAyXFx4MDJcIiArXG5cdFx0XCJcXHZcXHgwM1xceDAyXFx4MDJcXHgwMlxceDAyXFxyXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDBGXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDExXCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDEzXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDE1XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDE3XCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDE5XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDFCXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDFEXCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDFGXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMiFcXHgwM1xceDAyXFx4MDJcXHgwMlxceDAyI1xceDAzXCIgK1xuXHRcdFwiXFx4MDJcXHgwMlxceDAyXFx4MDIlXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMilcXHgwM1xceDAyXFx4MDJcXHgwMlxceDAzLlxceDAzXFx4MDJcXHgwMlwiICtcblx0XHRcIlxceDAyXFx4MDU2XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwNzhcXHgwM1xceDAyXFx4MDJcXHgwMlxcdEpcXHgwM1xceDAyXFx4MDJcXHgwMlxcdkxcXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MDJcXHgwMlxcck5cXHgwM1xceDAyXFx4MDJcXHgwMlxceDBGUFxceDAzXFx4MDJcXHgwMlxceDAyXFx4MTFSXFx4MDNcXHgwMlxceDAyXCIgK1xuXHRcdFwiXFx4MDJcXHgxM1RcXHgwM1xceDAyXFx4MDJcXHgwMlxceDE1VlxceDAzXFx4MDJcXHgwMlxceDAyXFx4MTdYXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxOVwiICtcblx0XHRcIlpcXHgwM1xceDAyXFx4MDJcXHgwMlxceDFCX1xceDAzXFx4MDJcXHgwMlxceDAyXFx4MURhXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxRmNcXHgwM1xceDAyXCIgK1xuXHRcdFwiXFx4MDJcXHgwMiFlXFx4MDNcXHgwMlxceDAyXFx4MDIjZ1xceDAzXFx4MDJcXHgwMlxceDAyJXRcXHgwM1xceDAyXFx4MDJcXHgwMlxcJ3ZcXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MDJcXHgwMil5XFx4MDNcXHgwMlxceDAyXFx4MDIrLVxcblxceDAyXFx4MDJcXHgwMiwrXFx4MDNcXHgwMlxceDAyXFx4MDItMFxceDAzXCIgK1xuXHRcdFwiXFx4MDJcXHgwMlxceDAyLixcXHgwM1xceDAyXFx4MDJcXHgwMi4vXFx4MDNcXHgwMlxceDAyXFx4MDIvMlxceDAzXFx4MDJcXHgwMlxceDAyMC5cXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MDJcXHgwMjEzXFxuXFx4MDNcXHgwMlxceDAyMjFcXHgwM1xceDAyXFx4MDJcXHgwMjM0XFx4MDNcXHgwMlxceDAyXFx4MDI0MlxceDAzXCIgK1xuXHRcdFwiXFx4MDJcXHgwMlxceDAyNDVcXHgwM1xceDAyXFx4MDJcXHgwMjVcXHgwNFxceDAzXFx4MDJcXHgwMlxceDAyNjdcXHgwNSVcXHgxM1xceDAyN1xceDA2XCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDI4OVxceDA3alxceDAyXFx4MDI5OlxceDA3dlxceDAyXFx4MDI6O1xceDA3dlxceDAyXFx4MDI7PFxceDA3clxceDAyXCIgK1xuXHRcdFwiXFx4MDI8PlxceDAzXFx4MDJcXHgwMlxceDAyPT9cXHgwN3VcXHgwMlxceDAyPj1cXHgwM1xceDAyXFx4MDJcXHgwMj4/XFx4MDNcXHgwMlxceDAyXCIgK1xuXHRcdFwiXFx4MDI/QFxceDAzXFx4MDJcXHgwMlxceDAyQEFcXHgwNzxcXHgwMlxceDAyQUJcXHgwNzFcXHgwMlxceDAyQkNcXHgwNzFcXHgwMlxceDAyQ0RcIiArXG5cdFx0XCJcXHgwM1xceDAyXFx4MDJcXHgwMkRGXFx0XFx4MDRcXHgwMlxceDAyRUdcXHRcXHgwNVxceDAyXFx4MDJGRVxceDAzXFx4MDJcXHgwMlxceDAyR0hcXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MDJcXHgwMkhGXFx4MDNcXHgwMlxceDAyXFx4MDJISVxceDAzXFx4MDJcXHgwMlxceDAySVxcYlxceDAzXFx4MDJcXHgwMlxceDAySktcIiArXG5cdFx0XCJcXHgwNzBcXHgwMlxceDAyS1xcblxceDAzXFx4MDJcXHgwMlxceDAyTE1cXHgwN0FcXHgwMlxceDAyTVxcZlxceDAzXFx4MDJcXHgwMlxceDAyTk9cXHgwN1wiICtcblx0XHRcIiNcXHgwMlxceDAyT1xceDBFXFx4MDNcXHgwMlxceDAyXFx4MDJQUVxceDA3KlxceDAyXFx4MDJRXFx4MTBcXHgwM1xceDAyXFx4MDJcXHgwMlJTXFx4MDdcIiArXG5cdFx0XCIrXFx4MDJcXHgwMlNcXHgxMlxceDAzXFx4MDJcXHgwMlxceDAyVFVcXHgwN31cXHgwMlxceDAyVVxceDE0XFx4MDNcXHgwMlxceDAyXFx4MDJWV1xceDA3XCIgK1xuXHRcdFwiXFx4N0ZcXHgwMlxceDAyV1xceDE2XFx4MDNcXHgwMlxceDAyXFx4MDJYWVxceDA3XVxceDAyXFx4MDJZXFx4MThcXHgwM1xceDAyXFx4MDJcXHgwMlwiICtcblx0XHRcIlpbXFx4MDdfXFx4MDJcXHgwMltcXHgxQVxceDAzXFx4MDJcXHgwMlxceDAyXFxcXF1cXHgwN1xcXCJcXHgwMlxceDAyXWBcXHgwNylcXHgwMlxceDAyXlwiICtcblx0XHRcImBcXHgwNylcXHgwMlxceDAyX1xcXFxcXHgwM1xceDAyXFx4MDJcXHgwMl9eXFx4MDNcXHgwMlxceDAyXFx4MDJgXFx4MUNcXHgwM1xceDAyXFx4MDJcXHgwMlwiICtcblx0XHRcImFiXFx4MDckXFx4MDJcXHgwMmJcXHgxRVxceDAzXFx4MDJcXHgwMlxceDAyY2RcXHgwNzxcXHgwMlxceDAyZCBcXHgwM1xceDAyXFx4MDJcXHgwMlwiICtcblx0XHRcImVmXFx4MDcuXFx4MDJcXHgwMmZcXFwiXFx4MDNcXHgwMlxceDAyXFx4MDJnaFxceDA3PVxceDAyXFx4MDJoJFxceDAzXFx4MDJcXHgwMlxceDAyaWtcIiArXG5cdFx0XCJcXHRcXHgwNlxceDAyXFx4MDJqbFxceDA3L1xceDAyXFx4MDJralxceDAzXFx4MDJcXHgwMlxceDAya2xcXHgwM1xceDAyXFx4MDJcXHgwMmxtXFx4MDNcIiArXG5cdFx0XCJcXHgwMlxceDAyXFx4MDJtblxcdFxceDA3XFx4MDJcXHgwMm51XFx4MDVcXCdcXHgxNFxceDAyb3BcXHgwNzpcXHgwMlxceDAycHFcXHgwNy9cXHgwMlwiICtcblx0XHRcIlxceDAycXJcXHgwNytcXHgwMlxceDAycnNcXHgwM1xceDAyXFx4MDJcXHgwMnN1XFx4MDVcXCdcXHgxNFxceDAydGlcXHgwM1xceDAyXFx4MDJcXHgwMlwiICtcblx0XHRcInRvXFx4MDNcXHgwMlxceDAyXFx4MDJ1JlxceDAzXFx4MDJcXHgwMlxceDAydndcXHRcXGJcXHgwMlxceDAydyhcXHgwM1xceDAyXFx4MDJcXHgwMnhcIiArXG5cdFx0XCJ6XFx4MDVcXCdcXHgxNFxceDAyeXhcXHgwM1xceDAyXFx4MDJcXHgwMnp7XFx4MDNcXHgwMlxceDAyXFx4MDJ7eVxceDAzXFx4MDJcXHgwMlxceDAyXCIgK1xuXHRcdFwie3xcXHgwM1xceDAyXFx4MDJcXHgwMnx9XFx4MDNcXHgwMlxceDAyXFx4MDJ9flxcYlxceDE1XFx4MDJcXHgwMn4qXFx4MDNcXHgwMlxceDAyXFx4MDJcIiArXG5cdFx0XCJcXHZcXHgwMi40Pkhfa3R7XFx4MDNcXGJcXHgwMlxceDAyXCI7XG5cdHB1YmxpYyBzdGF0aWMgX19BVE46IEFUTjtcblx0cHVibGljIHN0YXRpYyBnZXQgX0FUTigpOiBBVE4ge1xuXHRcdGlmICghU2ltcGxlVGV4dExleGVyLl9fQVROKSB7XG5cdFx0XHRTaW1wbGVUZXh0TGV4ZXIuX19BVE4gPSBuZXcgQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoVXRpbHMudG9DaGFyQXJyYXkoU2ltcGxlVGV4dExleGVyLl9zZXJpYWxpemVkQVROKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFNpbXBsZVRleHRMZXhlci5fX0FUTjtcblx0fVxuXG59XG5cbiIsICIvKipcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2luY2x1ZGVJbWFnZUFsdD10cnVlXVxuICovXG5cbi8qKlxuICogR2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSBub2RlLlxuICogUHJlZmVyIHRoZSBub2RlXHUyMDE5cyBwbGFpbi10ZXh0IGZpZWxkcywgb3RoZXJ3aXNlIHNlcmlhbGl6ZSBpdHMgY2hpbGRyZW4sXG4gKiBhbmQgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGFycmF5LCBzZXJpYWxpemUgdGhlIG5vZGVzIGluIGl0LlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gbm9kZVxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhub2RlLCBvcHRpb25zKSB7XG4gIHZhciB7aW5jbHVkZUltYWdlQWx0ID0gdHJ1ZX0gPSBvcHRpb25zIHx8IHt9XG4gIHJldHVybiBvbmUobm9kZSwgaW5jbHVkZUltYWdlQWx0KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlSW1hZ2VBbHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9uZShub2RlLCBpbmNsdWRlSW1hZ2VBbHQpIHtcbiAgcmV0dXJuIChcbiAgICAobm9kZSAmJlxuICAgICAgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmXG4gICAgICAvLyBAdHMtaWdub3JlIGxvb2tzIGxpa2UgYSBsaXRlcmFsLlxuICAgICAgKG5vZGUudmFsdWUgfHxcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBsb29rcyBsaWtlIGFuIGltYWdlLlxuICAgICAgICAoaW5jbHVkZUltYWdlQWx0ID8gbm9kZS5hbHQgOiAnJykgfHxcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBsb29rcyBsaWtlIGEgcGFyZW50LlxuICAgICAgICAoJ2NoaWxkcmVuJyBpbiBub2RlICYmIGFsbChub2RlLmNoaWxkcmVuLCBpbmNsdWRlSW1hZ2VBbHQpKSB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShub2RlKSAmJiBhbGwobm9kZSwgaW5jbHVkZUltYWdlQWx0KSkpKSB8fFxuICAgICcnXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5Ljx1bmtub3duPn0gdmFsdWVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVJbWFnZUFsdFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYWxsKHZhbHVlcywgaW5jbHVkZUltYWdlQWx0KSB7XG4gIC8qKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59ICovXG4gIHZhciByZXN1bHQgPSBbXVxuICB2YXIgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBvbmUodmFsdWVzW2luZGV4XSwgaW5jbHVkZUltYWdlQWx0KVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKVxufVxuIiwgIi8qKlxuICogTGlrZSBgQXJyYXkjc3BsaWNlYCwgYnV0IHNtYXJ0ZXIgZm9yIGdpYW50IGFycmF5cy5cbiAqXG4gKiBgQXJyYXkjc3BsaWNlYCB0YWtlcyBhbGwgaXRlbXMgdG8gYmUgaW5zZXJ0ZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudCB3aGljaFxuICogY2F1c2VzIGEgc3RhY2sgb3ZlcmZsb3cgaW4gVjggd2hlbiB0cnlpbmcgdG8gaW5zZXJ0IDEwMGsgaXRlbXMgZm9yIGluc3RhbmNlLlxuICpcbiAqIE90aGVyd2lzZSwgdGhpcyBkb2VzIG5vdCByZXR1cm4gdGhlIHJlbW92ZWQgaXRlbXMsIGFuZCB0YWtlcyBgaXRlbXNgIGFzIGFuXG4gKiBhcnJheSBpbnN0ZWFkIG9mIHJlc3QgcGFyYW1ldGVycy5cbiAqXG4gKiBAdGVtcGxhdGUge3Vua25vd259IFRcbiAqIEBwYXJhbSB7VFtdfSBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSByZW1vdmVcbiAqIEBwYXJhbSB7VFtdfSBpdGVtc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpY2UobGlzdCwgc3RhcnQsIHJlbW92ZSwgaXRlbXMpIHtcbiAgY29uc3QgZW5kID0gbGlzdC5sZW5ndGhcbiAgbGV0IGNodW5rU3RhcnQgPSAwXG4gIC8qKiBAdHlwZSB7dW5rbm93bltdfSAqL1xuXG4gIGxldCBwYXJhbWV0ZXJzIC8vIE1ha2Ugc3RhcnQgYmV0d2VlbiB6ZXJvIGFuZCBgZW5kYCAoaW5jbHVkZWQpLlxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IC1zdGFydCA+IGVuZCA/IDAgOiBlbmQgKyBzdGFydFxuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gc3RhcnQgPiBlbmQgPyBlbmQgOiBzdGFydFxuICB9XG5cbiAgcmVtb3ZlID0gcmVtb3ZlID4gMCA/IHJlbW92ZSA6IDAgLy8gTm8gbmVlZCB0byBjaHVuayB0aGUgaXRlbXMgaWYgdGhlcmVcdTIwMTlzIG9ubHkgYSBjb3VwbGUgKDEwaykgaXRlbXMuXG5cbiAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEwMDAwKSB7XG4gICAgcGFyYW1ldGVycyA9IEFycmF5LmZyb20oaXRlbXMpXG4gICAgcGFyYW1ldGVycy51bnNoaWZ0KHN0YXJ0LCByZW1vdmUpIC8vIEB0cy1leHBlY3QtZXJyb3IgSHVzaCwgaXRcdTIwMTlzIGZpbmUuXG4gICAgO1tdLnNwbGljZS5hcHBseShsaXN0LCBwYXJhbWV0ZXJzKVxuICB9IGVsc2Uge1xuICAgIC8vIERlbGV0ZSBgcmVtb3ZlYCBpdGVtcyBzdGFydGluZyBmcm9tIGBzdGFydGBcbiAgICBpZiAocmVtb3ZlKSBbXS5zcGxpY2UuYXBwbHkobGlzdCwgW3N0YXJ0LCByZW1vdmVdKSAvLyBJbnNlcnQgdGhlIGl0ZW1zIGluIGNodW5rcyB0byBub3QgY2F1c2Ugc3RhY2sgb3ZlcmZsb3dzLlxuXG4gICAgd2hpbGUgKGNodW5rU3RhcnQgPCBpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHBhcmFtZXRlcnMgPSBpdGVtcy5zbGljZShjaHVua1N0YXJ0LCBjaHVua1N0YXJ0ICsgMTAwMDApXG4gICAgICBwYXJhbWV0ZXJzLnVuc2hpZnQoc3RhcnQsIDApIC8vIEB0cy1leHBlY3QtZXJyb3IgSHVzaCwgaXRcdTIwMTlzIGZpbmUuXG4gICAgICA7W10uc3BsaWNlLmFwcGx5KGxpc3QsIHBhcmFtZXRlcnMpXG4gICAgICBjaHVua1N0YXJ0ICs9IDEwMDAwXG4gICAgICBzdGFydCArPSAxMDAwMFxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBBcHBlbmQgYGl0ZW1zYCAoYW4gYXJyYXkpIGF0IHRoZSBlbmQgb2YgYGxpc3RgIChhbm90aGVyIGFycmF5KS5cbiAqIFdoZW4gYGxpc3RgIHdhcyBlbXB0eSwgcmV0dXJucyBgaXRlbXNgIGluc3RlYWQuXG4gKlxuICogVGhpcyBwcmV2ZW50cyBhIHBvdGVudGlhbGx5IGV4cGVuc2l2ZSBvcGVyYXRpb24gd2hlbiBgbGlzdGAgaXMgZW1wdHksXG4gKiBhbmQgYWRkcyBpdGVtcyBpbiBiYXRjaGVzIHRvIHByZXZlbnQgVjggZnJvbSBoYW5naW5nLlxuICpcbiAqIEB0ZW1wbGF0ZSB7dW5rbm93bn0gVFxuICogQHBhcmFtIHtUW119IGxpc3RcbiAqIEBwYXJhbSB7VFtdfSBpdGVtc1xuICogQHJldHVybnMge1RbXX1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcHVzaChsaXN0LCBpdGVtcykge1xuICBpZiAobGlzdC5sZW5ndGggPiAwKSB7XG4gICAgc3BsaWNlKGxpc3QsIGxpc3QubGVuZ3RoLCAwLCBpdGVtcylcbiAgICByZXR1cm4gbGlzdFxuICB9XG5cbiAgcmV0dXJuIGl0ZW1zXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLk5vcm1hbGl6ZWRFeHRlbnNpb259IE5vcm1hbGl6ZWRFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXh0ZW5zaW9ufSBFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSHRtbEV4dGVuc2lvbn0gSHRtbEV4dGVuc2lvblxuICovXG5cbmltcG9ydCB7c3BsaWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaHVua2VkJ1xuXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKlxuICogQ29tYmluZSBzZXZlcmFsIHN5bnRheCBleHRlbnNpb25zIGludG8gb25lLlxuICpcbiAqIEBwYXJhbSB7RXh0ZW5zaW9uW119IGV4dGVuc2lvbnMgTGlzdCBvZiBzeW50YXggZXh0ZW5zaW9ucy5cbiAqIEByZXR1cm5zIHtOb3JtYWxpemVkRXh0ZW5zaW9ufSBBIHNpbmdsZSBjb21iaW5lZCBleHRlbnNpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lRXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gIC8qKiBAdHlwZSB7Tm9ybWFsaXplZEV4dGVuc2lvbn0gKi9cbiAgY29uc3QgYWxsID0ge31cbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgc3ludGF4RXh0ZW5zaW9uKGFsbCwgZXh0ZW5zaW9uc1tpbmRleF0pXG4gIH1cblxuICByZXR1cm4gYWxsXG59XG5cbi8qKlxuICogTWVyZ2UgYGV4dGVuc2lvbmAgaW50byBgYWxsYC5cbiAqXG4gKiBAcGFyYW0ge05vcm1hbGl6ZWRFeHRlbnNpb259IGFsbCBFeHRlbnNpb24gdG8gbWVyZ2UgaW50by5cbiAqIEBwYXJhbSB7RXh0ZW5zaW9ufSBleHRlbnNpb24gRXh0ZW5zaW9uIHRvIG1lcmdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHN5bnRheEV4dGVuc2lvbihhbGwsIGV4dGVuc2lvbikge1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgbGV0IGhvb2tcblxuICBmb3IgKGhvb2sgaW4gZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgbWF5YmUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFsbCwgaG9vaykgPyBhbGxbaG9va10gOiB1bmRlZmluZWRcbiAgICBjb25zdCBsZWZ0ID0gbWF5YmUgfHwgKGFsbFtob29rXSA9IHt9KVxuICAgIGNvbnN0IHJpZ2h0ID0gZXh0ZW5zaW9uW2hvb2tdXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbGV0IGNvZGVcblxuICAgIGZvciAoY29kZSBpbiByaWdodCkge1xuICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGxlZnQsIGNvZGUpKSBsZWZ0W2NvZGVdID0gW11cbiAgICAgIGNvbnN0IHZhbHVlID0gcmlnaHRbY29kZV1cbiAgICAgIGNvbnN0cnVjdHMoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTG9va3MgbGlrZSBhIGxpc3QuXG4gICAgICAgIGxlZnRbY29kZV0sXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiB2YWx1ZSA/IFt2YWx1ZV0gOiBbXVxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIGBsaXN0YCBpbnRvIGBleGlzdGluZ2AgKGJvdGggbGlzdHMgb2YgY29uc3RydWN0cykuXG4gKiBNdXRhdGVzIGBleGlzdGluZ2AuXG4gKlxuICogQHBhcmFtIHt1bmtub3duW119IGV4aXN0aW5nXG4gKiBAcGFyYW0ge3Vua25vd25bXX0gbGlzdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdHMoZXhpc3RpbmcsIGxpc3QpIHtcbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHt1bmtub3duW119ICovXG4gIGNvbnN0IGJlZm9yZSA9IFtdXG5cbiAgd2hpbGUgKCsraW5kZXggPCBsaXN0Lmxlbmd0aCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTG9va3MgbGlrZSBhbiBvYmplY3QuXG4gICAgOyhsaXN0W2luZGV4XS5hZGQgPT09ICdhZnRlcicgPyBleGlzdGluZyA6IGJlZm9yZSkucHVzaChsaXN0W2luZGV4XSlcbiAgfVxuXG4gIHNwbGljZShleGlzdGluZywgMCwgMCwgYmVmb3JlKVxufVxuXG4vKipcbiAqIENvbWJpbmUgc2V2ZXJhbCBIVE1MIGV4dGVuc2lvbnMgaW50byBvbmUuXG4gKlxuICogQHBhcmFtIHtIdG1sRXh0ZW5zaW9uW119IGh0bWxFeHRlbnNpb25zIExpc3Qgb2YgSFRNTCBleHRlbnNpb25zLlxuICogQHJldHVybnMge0h0bWxFeHRlbnNpb259IEEgc2luZ2xlIGNvbWJpbmVkIGV4dGVuc2lvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVIdG1sRXh0ZW5zaW9ucyhodG1sRXh0ZW5zaW9ucykge1xuICAvKiogQHR5cGUge0h0bWxFeHRlbnNpb259ICovXG4gIGNvbnN0IGhhbmRsZXJzID0ge31cbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGh0bWxFeHRlbnNpb25zLmxlbmd0aCkge1xuICAgIGh0bWxFeHRlbnNpb24oaGFuZGxlcnMsIGh0bWxFeHRlbnNpb25zW2luZGV4XSlcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVyc1xufVxuXG4vKipcbiAqIE1lcmdlIGBleHRlbnNpb25gIGludG8gYGFsbGAuXG4gKlxuICogQHBhcmFtIHtIdG1sRXh0ZW5zaW9ufSBhbGwgRXh0ZW5zaW9uIHRvIG1lcmdlIGludG8uXG4gKiBAcGFyYW0ge0h0bWxFeHRlbnNpb259IGV4dGVuc2lvbiBFeHRlbnNpb24gdG8gbWVyZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gaHRtbEV4dGVuc2lvbihhbGwsIGV4dGVuc2lvbikge1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgbGV0IGhvb2tcblxuICBmb3IgKGhvb2sgaW4gZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgbWF5YmUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFsbCwgaG9vaykgPyBhbGxbaG9va10gOiB1bmRlZmluZWRcbiAgICBjb25zdCBsZWZ0ID0gbWF5YmUgfHwgKGFsbFtob29rXSA9IHt9KVxuICAgIGNvbnN0IHJpZ2h0ID0gZXh0ZW5zaW9uW2hvb2tdXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbGV0IHR5cGVcblxuICAgIGlmIChyaWdodCkge1xuICAgICAgZm9yICh0eXBlIGluIHJpZ2h0KSB7XG4gICAgICAgIGxlZnRbdHlwZV0gPSByaWdodFt0eXBlXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgIi8vIFRoaXMgbW9kdWxlIGlzIGdlbmVyYXRlZCBieSBgc2NyaXB0L2AuXG4vL1xuLy8gQ29tbW9uTWFyayBoYW5kbGVzIGF0dGVudGlvbiAoZW1waGFzaXMsIHN0cm9uZykgbWFya2VycyBiYXNlZCBvbiB3aGF0IGNvbWVzXG4vLyBiZWZvcmUgb3IgYWZ0ZXIgdGhlbS5cbi8vIE9uZSBzdWNoIGRpZmZlcmVuY2UgaXMgaWYgdGhvc2UgY2hhcmFjdGVycyBhcmUgVW5pY29kZSBwdW5jdHVhdGlvbi5cbi8vIFRoaXMgc2NyaXB0IGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBVbmljb2RlIGRhdGEuXG5leHBvcnQgY29uc3QgdW5pY29kZVB1bmN0dWF0aW9uUmVnZXggPVxuICAvWyEtLzotQFstYHstflxcdTAwQTFcXHUwMEE3XFx1MDBBQlxcdTAwQjZcXHUwMEI3XFx1MDBCQlxcdTAwQkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MDlGRFxcdTBBNzZcXHUwQUYwXFx1MEM3N1xcdTBDODRcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkU0RlxcdTJFNTJcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XS9cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICovXG5pbXBvcnQge3VuaWNvZGVQdW5jdHVhdGlvblJlZ2V4fSBmcm9tICcuL2xpYi91bmljb2RlLXB1bmN0dWF0aW9uLXJlZ2V4LmpzJ1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBjaGFyYWN0ZXIgY29kZSByZXByZXNlbnRzIGFuIEFTQ0lJIGFscGhhIChgYWAgdGhyb3VnaCBgemAsXG4gKiBjYXNlIGluc2Vuc2l0aXZlKS5cbiAqXG4gKiBBbiAqKkFTQ0lJIGFscGhhKiogaXMgYW4gQVNDSUkgdXBwZXIgYWxwaGEgb3IgQVNDSUkgbG93ZXIgYWxwaGEuXG4gKlxuICogQW4gKipBU0NJSSB1cHBlciBhbHBoYSoqIGlzIGEgY2hhcmFjdGVyIGluIHRoZSBpbmNsdXNpdmUgcmFuZ2UgVSswMDQxIChgQWApXG4gKiB0byBVKzAwNUEgKGBaYCkuXG4gKlxuICogQW4gKipBU0NJSSBsb3dlciBhbHBoYSoqIGlzIGEgY2hhcmFjdGVyIGluIHRoZSBpbmNsdXNpdmUgcmFuZ2UgVSswMDYxIChgYWApXG4gKiB0byBVKzAwN0EgKGB6YCkuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGFzY2lpQWxwaGEgPSByZWdleENoZWNrKC9bQS1aYS16XS8pXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGNoYXJhY3RlciBjb2RlIHJlcHJlc2VudHMgYW4gQVNDSUkgZGlnaXQgKGAwYCB0aHJvdWdoIGA5YCkuXG4gKlxuICogQW4gKipBU0NJSSBkaWdpdCoqIGlzIGEgY2hhcmFjdGVyIGluIHRoZSBpbmNsdXNpdmUgcmFuZ2UgVSswMDMwIChgMGApIHRvXG4gKiBVKzAwMzkgKGA5YCkuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGFzY2lpRGlnaXQgPSByZWdleENoZWNrKC9cXGQvKVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBjaGFyYWN0ZXIgY29kZSByZXByZXNlbnRzIGFuIEFTQ0lJIGhleCBkaWdpdCAoYGFgIHRocm91Z2hcbiAqIGBmYCwgY2FzZSBpbnNlbnNpdGl2ZSwgb3IgYDBgIHRocm91Z2ggYDlgKS5cbiAqXG4gKiBBbiAqKkFTQ0lJIGhleCBkaWdpdCoqIGlzIGFuIEFTQ0lJIGRpZ2l0IChzZWUgYGFzY2lpRGlnaXRgKSwgQVNDSUkgdXBwZXIgaGV4XG4gKiBkaWdpdCwgb3IgYW4gQVNDSUkgbG93ZXIgaGV4IGRpZ2l0LlxuICpcbiAqIEFuICoqQVNDSUkgdXBwZXIgaGV4IGRpZ2l0KiogaXMgYSBjaGFyYWN0ZXIgaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBVKzAwNDFcbiAqIChgQWApIHRvIFUrMDA0NiAoYEZgKS5cbiAqXG4gKiBBbiAqKkFTQ0lJIGxvd2VyIGhleCBkaWdpdCoqIGlzIGEgY2hhcmFjdGVyIGluIHRoZSBpbmNsdXNpdmUgcmFuZ2UgVSswMDYxXG4gKiAoYGFgKSB0byBVKzAwNjYgKGBmYCkuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGFzY2lpSGV4RGlnaXQgPSByZWdleENoZWNrKC9bXFxkQS1GYS1mXS8pXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGNoYXJhY3RlciBjb2RlIHJlcHJlc2VudHMgYW4gQVNDSUkgYWxwaGFudW1lcmljIChgYWBcbiAqIHRocm91Z2ggYHpgLCBjYXNlIGluc2Vuc2l0aXZlLCBvciBgMGAgdGhyb3VnaCBgOWApLlxuICpcbiAqIEFuICoqQVNDSUkgYWxwaGFudW1lcmljKiogaXMgYW4gQVNDSUkgZGlnaXQgKHNlZSBgYXNjaWlEaWdpdGApIG9yIEFTQ0lJIGFscGhhXG4gKiAoc2VlIGBhc2NpaUFscGhhYCkuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGFzY2lpQWxwaGFudW1lcmljID0gcmVnZXhDaGVjaygvW1xcZEEtWmEtel0vKVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBjaGFyYWN0ZXIgY29kZSByZXByZXNlbnRzIEFTQ0lJIHB1bmN0dWF0aW9uLlxuICpcbiAqIEFuICoqQVNDSUkgcHVuY3R1YXRpb24qKiBpcyBhIGNoYXJhY3RlciBpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBVKzAwMjFcbiAqIEVYQ0xBTUFUSU9OIE1BUksgKGAhYCkgdG8gVSswMDJGIFNMQVNIIChgL2ApLCBVKzAwM0EgQ09MT04gKGA6YCkgdG8gVSswMDQwIEFUXG4gKiBTSUdOIChgQGApLCBVKzAwNUIgTEVGVCBTUVVBUkUgQlJBQ0tFVCAoYFtgKSB0byBVKzAwNjAgR1JBVkUgQUNDRU5UXG4gKiAoYGAgYCBgYCksIG9yIFUrMDA3QiBMRUZUIENVUkxZIEJSQUNFIChge2ApIHRvIFUrMDA3RSBUSUxERSAoYH5gKS5cbiAqL1xuXG5leHBvcnQgY29uc3QgYXNjaWlQdW5jdHVhdGlvbiA9IHJlZ2V4Q2hlY2soL1shLS86LUBbLWB7LX5dLylcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgY2hhcmFjdGVyIGNvZGUgcmVwcmVzZW50cyBhbiBBU0NJSSBhdGV4dC5cbiAqXG4gKiBhdGV4dCBpcyBhbiBBU0NJSSBhbHBoYW51bWVyaWMgKHNlZSBgYXNjaWlBbHBoYW51bWVyaWNgKSwgb3IgYSBjaGFyYWN0ZXIgaW5cbiAqIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIFUrMDAyMyBOVU1CRVIgU0lHTiAoYCNgKSB0byBVKzAwMjcgQVBPU1RST1BIRSAoYCdgKSxcbiAqIFUrMDAyQSBBU1RFUklTSyAoYCpgKSwgVSswMDJCIFBMVVMgU0lHTiAoYCtgKSwgVSswMDJEIERBU0ggKGAtYCksIFUrMDAyRlxuICogU0xBU0ggKGAvYCksIFUrMDAzRCBFUVVBTFMgVE8gKGA9YCksIFUrMDAzRiBRVUVTVElPTiBNQVJLIChgP2ApLCBVKzAwNUVcbiAqIENBUkVUIChgXmApIHRvIFUrMDA2MCBHUkFWRSBBQ0NFTlQgKGBgIGAgYGApLCBvciBVKzAwN0IgTEVGVCBDVVJMWSBCUkFDRVxuICogKGB7YCkgdG8gVSswMDdFIFRJTERFIChgfmApLlxuICpcbiAqIFNlZTpcbiAqICoqXFxbUkZDNTMyMl0qKjpcbiAqIFtJbnRlcm5ldCBNZXNzYWdlIEZvcm1hdF0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjIpLlxuICogUC4gUmVzbmljay5cbiAqIElFVEYuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGFzY2lpQXRleHQgPSByZWdleENoZWNrKC9bIy0nKitcXC0tOT0/QS1aXi1+XS8pXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBjaGFyYWN0ZXIgY29kZSBpcyBhbiBBU0NJSSBjb250cm9sIGNoYXJhY3Rlci5cbiAqXG4gKiBBbiAqKkFTQ0lJIGNvbnRyb2wqKiBpcyBhIGNoYXJhY3RlciBpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIFUrMDAwMCBOVUxMIChOVUwpXG4gKiB0byBVKzAwMUYgKFVTKSwgb3IgVSswMDdGIChERUwpLlxuICpcbiAqIEBwYXJhbSB7Q29kZX0gY29kZVxuICogQHJldHVybnMge2NvZGUgaXMgbnVtYmVyfVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhc2NpaUNvbnRyb2woY29kZSkge1xuICByZXR1cm4gKFxuICAgIC8vIFNwZWNpYWwgd2hpdGVzcGFjZSBjb2RlcyAod2hpY2ggaGF2ZSBuZWdhdGl2ZSB2YWx1ZXMpLCBDMCBhbmQgQ29udHJvbFxuICAgIC8vIGNoYXJhY3RlciBERUxcbiAgICBjb2RlICE9PSBudWxsICYmIChjb2RlIDwgMzIgfHwgY29kZSA9PT0gMTI3KVxuICApXG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBjaGFyYWN0ZXIgY29kZSBpcyBhIG1hcmtkb3duIGxpbmUgZW5kaW5nIChzZWVcbiAqIGBtYXJrZG93bkxpbmVFbmRpbmdgKSBvciBtYXJrZG93biBzcGFjZSAoc2VlIGBtYXJrZG93blNwYWNlYCkuXG4gKlxuICogQHBhcmFtIHtDb2RlfSBjb2RlXG4gKiBAcmV0dXJucyB7Y29kZSBpcyBudW1iZXJ9XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkge1xuICByZXR1cm4gY29kZSAhPT0gbnVsbCAmJiAoY29kZSA8IDAgfHwgY29kZSA9PT0gMzIpXG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBjaGFyYWN0ZXIgY29kZSBpcyBhIG1hcmtkb3duIGxpbmUgZW5kaW5nLlxuICpcbiAqIEEgKiptYXJrZG93biBsaW5lIGVuZGluZyoqIGlzIHRoZSB2aXJ0dWFsIGNoYXJhY3RlcnMgTS0wMDAzIENBUlJJQUdFIFJFVFVSTlxuICogTElORSBGRUVEIChDUkxGKSwgTS0wMDA0IExJTkUgRkVFRCAoTEYpIGFuZCBNLTAwMDUgQ0FSUklBR0UgUkVUVVJOIChDUikuXG4gKlxuICogSW4gbWljcm9tYXJrLCB0aGUgYWN0dWFsIGNoYXJhY3RlciBVKzAwMEEgTElORSBGRUVEIChMRikgYW5kIFUrMDAwRCBDQVJSSUFHRVxuICogUkVUVVJOIChDUikgYXJlIHJlcGxhY2VkIGJ5IHRoZXNlIHZpcnR1YWwgY2hhcmFjdGVycyBkZXBlbmRpbmcgb24gd2hldGhlclxuICogdGhleSBvY2N1cnJlZCB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge0NvZGV9IGNvZGVcbiAqIEByZXR1cm5zIHtjb2RlIGlzIG51bWJlcn1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgIT09IG51bGwgJiYgY29kZSA8IC0yXG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBjaGFyYWN0ZXIgY29kZSBpcyBhIG1hcmtkb3duIHNwYWNlLlxuICpcbiAqIEEgKiptYXJrZG93biBzcGFjZSoqIGlzIHRoZSBjb25jcmV0ZSBjaGFyYWN0ZXIgVSswMDIwIFNQQUNFIChTUCkgYW5kIHRoZVxuICogdmlydHVhbCBjaGFyYWN0ZXJzIE0tMDAwMSBWSVJUVUFMIFNQQUNFIChWUykgYW5kIE0tMDAwMiBIT1JJWk9OVEFMIFRBQiAoSFQpLlxuICpcbiAqIEluIG1pY3JvbWFyaywgdGhlIGFjdHVhbCBjaGFyYWN0ZXIgVSswMDA5IENIQVJBQ1RFUiBUQUJVTEFUSU9OIChIVCkgaXNcbiAqIHJlcGxhY2VkIGJ5IG9uZSBNLTAwMDIgSE9SSVpPTlRBTCBUQUIgKEhUKSBhbmQgYmV0d2VlbiAwIGFuZCAzIE0tMDAwMSBWSVJUVUFMXG4gKiBTUEFDRSAoVlMpIGNoYXJhY3RlcnMsIGRlcGVuZGluZyBvbiB0aGUgY29sdW1uIGF0IHdoaWNoIHRoZSB0YWIgb2NjdXJyZWQuXG4gKlxuICogQHBhcmFtIHtDb2RlfSBjb2RlXG4gKiBAcmV0dXJucyB7Y29kZSBpcyBudW1iZXJ9XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtkb3duU3BhY2UoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gLTIgfHwgY29kZSA9PT0gLTEgfHwgY29kZSA9PT0gMzJcbn1cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgY2hhcmFjdGVyIGNvZGUgcmVwcmVzZW50cyBVbmljb2RlIHdoaXRlc3BhY2UuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgZG9lcyBoYW5kbGUgbWljcm9tYXJrIHNwZWNpZmljIG1hcmtkb3duIHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAqIFNlZSBgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZWAgdG8gY2hlY2sgdGhhdC5cbiAqXG4gKiBBICoqVW5pY29kZSB3aGl0ZXNwYWNlKiogaXMgYSBjaGFyYWN0ZXIgaW4gdGhlIFVuaWNvZGUgYFpzYCAoU2VwYXJhdG9yLFxuICogU3BhY2UpIGNhdGVnb3J5LCBvciBVKzAwMDkgQ0hBUkFDVEVSIFRBQlVMQVRJT04gKEhUKSwgVSswMDBBIExJTkUgRkVFRCAoTEYpLFxuICogVSswMDBDIChGRiksIG9yIFUrMDAwRCBDQVJSSUFHRSBSRVRVUk4gKENSKSAoKipcXFtVTklDT0RFXSoqKS5cbiAqXG4gKiBTZWU6XG4gKiAqKlxcW1VOSUNPREVdKio6XG4gKiBbVGhlIFVuaWNvZGUgU3RhbmRhcmRdKGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3ZlcnNpb25zLykuXG4gKiBVbmljb2RlIENvbnNvcnRpdW0uXG4gKi9cblxuZXhwb3J0IGNvbnN0IHVuaWNvZGVXaGl0ZXNwYWNlID0gcmVnZXhDaGVjaygvXFxzLylcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgY2hhcmFjdGVyIGNvZGUgcmVwcmVzZW50cyBVbmljb2RlIHB1bmN0dWF0aW9uLlxuICpcbiAqIEEgKipVbmljb2RlIHB1bmN0dWF0aW9uKiogaXMgYSBjaGFyYWN0ZXIgaW4gdGhlIFVuaWNvZGUgYFBjYCAoUHVuY3R1YXRpb24sXG4gKiBDb25uZWN0b3IpLCBgUGRgIChQdW5jdHVhdGlvbiwgRGFzaCksIGBQZWAgKFB1bmN0dWF0aW9uLCBDbG9zZSksIGBQZmBcbiAqIChQdW5jdHVhdGlvbiwgRmluYWwgcXVvdGUpLCBgUGlgIChQdW5jdHVhdGlvbiwgSW5pdGlhbCBxdW90ZSksIGBQb2BcbiAqIChQdW5jdHVhdGlvbiwgT3RoZXIpLCBvciBgUHNgIChQdW5jdHVhdGlvbiwgT3BlbikgY2F0ZWdvcmllcywgb3IgYW4gQVNDSUlcbiAqIHB1bmN0dWF0aW9uIChzZWUgYGFzY2lpUHVuY3R1YXRpb25gKS5cbiAqXG4gKiBTZWU6XG4gKiAqKlxcW1VOSUNPREVdKio6XG4gKiBbVGhlIFVuaWNvZGUgU3RhbmRhcmRdKGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3ZlcnNpb25zLykuXG4gKiBVbmljb2RlIENvbnNvcnRpdW0uXG4gKi9cbi8vIFNpemUgbm90ZTogcmVtb3ZpbmcgQVNDSUkgZnJvbSB0aGUgcmVnZXggYW5kIHVzaW5nIGBhc2NpaVB1bmN0dWF0aW9uYCBoZXJlXG4vLyBJbiBmYWN0IGFkZHMgdG8gdGhlIGJ1bmRsZSBzaXplLlxuXG5leHBvcnQgY29uc3QgdW5pY29kZVB1bmN0dWF0aW9uID0gcmVnZXhDaGVjayh1bmljb2RlUHVuY3R1YXRpb25SZWdleClcbi8qKlxuICogQ3JlYXRlIGEgY29kZSBjaGVjayBmcm9tIGEgcmVnZXguXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4XG4gKiBAcmV0dXJucyB7KGNvZGU6IENvZGUpID0+IGNvZGUgaXMgbnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIHJlZ2V4Q2hlY2socmVnZXgpIHtcbiAgcmV0dXJuIGNoZWNrXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGEgY29kZSBtYXRjaGVzIHRoZSBib3VuZCByZWdleC5cbiAgICpcbiAgICogQHBhcmFtIHtDb2RlfSBjb2RlIENoYXJhY3RlciBjb2RlXG4gICAqIEByZXR1cm5zIHtjb2RlIGlzIG51bWJlcn0gV2hldGhlciB0aGUgY2hhcmFjdGVyIGNvZGUgbWF0Y2hlcyB0aGUgYm91bmQgcmVnZXhcbiAgICovXG5cbiAgZnVuY3Rpb24gY2hlY2soY29kZSkge1xuICAgIHJldHVybiBjb2RlICE9PSBudWxsICYmIHJlZ2V4LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FZmZlY3RzfSBFZmZlY3RzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge21hcmtkb3duU3BhY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3Rlcidcbi8qKlxuICogQHBhcmFtIHtFZmZlY3RzfSBlZmZlY3RzXG4gKiBAcGFyYW0ge1N0YXRlfSBva1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PUluZmluaXR5XVxuICogQHJldHVybnMge1N0YXRlfVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgb2ssIHR5cGUsIG1heCkge1xuICBjb25zdCBsaW1pdCA9IG1heCA/IG1heCAtIDEgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgbGV0IHNpemUgPSAwXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcih0eXBlKVxuICAgICAgcmV0dXJuIHByZWZpeChjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gcHJlZml4KGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSAmJiBzaXplKysgPCBsaW1pdCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gcHJlZml4XG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KHR5cGUpXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSW5pdGlhbENvbnN0cnVjdH0gSW5pdGlhbENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Jbml0aWFsaXplcn0gSW5pdGlhbGl6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0luaXRpYWxDb25zdHJ1Y3R9ICovXG5leHBvcnQgY29uc3QgY29udGVudCA9IHtcbiAgdG9rZW5pemU6IGluaXRpYWxpemVDb250ZW50XG59XG4vKiogQHR5cGUge0luaXRpYWxpemVyfSAqL1xuXG5mdW5jdGlvbiBpbml0aWFsaXplQ29udGVudChlZmZlY3RzKSB7XG4gIGNvbnN0IGNvbnRlbnRTdGFydCA9IGVmZmVjdHMuYXR0ZW1wdChcbiAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmNvbnRlbnRJbml0aWFsLFxuICAgIGFmdGVyQ29udGVudFN0YXJ0Q29uc3RydWN0LFxuICAgIHBhcmFncmFwaEluaXRpYWxcbiAgKVxuICAvKiogQHR5cGUge1Rva2VufSAqL1xuXG4gIGxldCBwcmV2aW91c1xuICByZXR1cm4gY29udGVudFN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJDb250ZW50U3RhcnRDb25zdHJ1Y3QoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG4gICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBjb250ZW50U3RhcnQsICdsaW5lUHJlZml4JylcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHBhcmFncmFwaEluaXRpYWwoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ3BhcmFncmFwaCcpXG4gICAgcmV0dXJuIGxpbmVTdGFydChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gbGluZVN0YXJ0KGNvZGUpIHtcbiAgICBjb25zdCB0b2tlbiA9IGVmZmVjdHMuZW50ZXIoJ2NodW5rVGV4dCcsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiAndGV4dCcsXG4gICAgICBwcmV2aW91c1xuICAgIH0pXG5cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIHByZXZpb3VzLm5leHQgPSB0b2tlblxuICAgIH1cblxuICAgIHByZXZpb3VzID0gdG9rZW5cbiAgICByZXR1cm4gZGF0YShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGF0YShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnY2h1bmtUZXh0JylcbiAgICAgIGVmZmVjdHMuZXhpdCgncGFyYWdyYXBoJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2NodW5rVGV4dCcpXG4gICAgICByZXR1cm4gbGluZVN0YXJ0XG4gICAgfSAvLyBEYXRhLlxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Jbml0aWFsQ29uc3RydWN0fSBJbml0aWFsQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkluaXRpYWxpemVyfSBJbml0aWFsaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZUNvbnRleHR9IFRva2VuaXplQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlBvaW50fSBQb2ludFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBTdGFja1N0YXRlXG4gKiBAdHlwZWRlZiB7W0NvbnN0cnVjdCwgU3RhY2tTdGF0ZV19IFN0YWNrSXRlbVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuaW1wb3J0IHtzcGxpY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNodW5rZWQnXG4vKiogQHR5cGUge0luaXRpYWxDb25zdHJ1Y3R9ICovXG5cbmV4cG9ydCBjb25zdCBkb2N1bWVudCA9IHtcbiAgdG9rZW5pemU6IGluaXRpYWxpemVEb2N1bWVudFxufVxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbmNvbnN0IGNvbnRhaW5lckNvbnN0cnVjdCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplQ29udGFpbmVyXG59XG4vKiogQHR5cGUge0luaXRpYWxpemVyfSAqL1xuXG5mdW5jdGlvbiBpbml0aWFsaXplRG9jdW1lbnQoZWZmZWN0cykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvKiogQHR5cGUge0FycmF5PFN0YWNrSXRlbT59ICovXG5cbiAgY29uc3Qgc3RhY2sgPSBbXVxuICBsZXQgY29udGludWVkID0gMFxuICAvKiogQHR5cGUge1Rva2VuaXplQ29udGV4dHx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGNoaWxkRmxvd1xuICAvKiogQHR5cGUge1Rva2VufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgY2hpbGRUb2tlblxuICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICBsZXQgbGluZVN0YXJ0T2Zmc2V0XG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAvLyBGaXJzdCB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIG9wZW4gYmxvY2tzLCBzdGFydGluZyB3aXRoIHRoZSByb290XG4gICAgLy8gZG9jdW1lbnQsIGFuZCBkZXNjZW5kaW5nIHRocm91Z2ggbGFzdCBjaGlsZHJlbiBkb3duIHRvIHRoZSBsYXN0IG9wZW5cbiAgICAvLyBibG9jay5cbiAgICAvLyBFYWNoIGJsb2NrIGltcG9zZXMgYSBjb25kaXRpb24gdGhhdCB0aGUgbGluZSBtdXN0IHNhdGlzZnkgaWYgdGhlIGJsb2NrIGlzXG4gICAgLy8gdG8gcmVtYWluIG9wZW4uXG4gICAgLy8gRm9yIGV4YW1wbGUsIGEgYmxvY2sgcXVvdGUgcmVxdWlyZXMgYSBgPmAgY2hhcmFjdGVyLlxuICAgIC8vIEEgcGFyYWdyYXBoIHJlcXVpcmVzIGEgbm9uLWJsYW5rIGxpbmUuXG4gICAgLy8gSW4gdGhpcyBwaGFzZSB3ZSBtYXkgbWF0Y2ggYWxsIG9yIGp1c3Qgc29tZSBvZiB0aGUgb3BlbiBibG9ja3MuXG4gICAgLy8gQnV0IHdlIGNhbm5vdCBjbG9zZSB1bm1hdGNoZWQgYmxvY2tzIHlldCwgYmVjYXVzZSB3ZSBtYXkgaGF2ZSBhIGxhenlcbiAgICAvLyBjb250aW51YXRpb24gbGluZS5cbiAgICBpZiAoY29udGludWVkIDwgc3RhY2subGVuZ3RoKSB7XG4gICAgICBjb25zdCBpdGVtID0gc3RhY2tbY29udGludWVkXVxuICAgICAgc2VsZi5jb250YWluZXJTdGF0ZSA9IGl0ZW1bMV1cbiAgICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgIGl0ZW1bMF0uY29udGludWF0aW9uLFxuICAgICAgICBkb2N1bWVudENvbnRpbnVlLFxuICAgICAgICBjaGVja05ld0NvbnRhaW5lcnNcbiAgICAgICkoY29kZSlcbiAgICB9IC8vIERvbmUuXG5cbiAgICByZXR1cm4gY2hlY2tOZXdDb250YWluZXJzKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkb2N1bWVudENvbnRpbnVlKGNvZGUpIHtcbiAgICBjb250aW51ZWQrKyAvLyBOb3RlOiB0aGlzIGZpZWxkIGlzIGNhbGxlZCBgX2Nsb3NlRmxvd2AgYnV0IGl0IGFsc28gY2xvc2VzIGNvbnRhaW5lcnMuXG4gICAgLy8gUGVyaGFwcyBhIGdvb2QgaWRlYSB0byByZW5hbWUgaXQgYnV0IGl0XHUyMDE5cyBhbHJlYWR5IHVzZWQgaW4gdGhlIHdpbGQgYnlcbiAgICAvLyBleHRlbnNpb25zLlxuXG4gICAgaWYgKHNlbGYuY29udGFpbmVyU3RhdGUuX2Nsb3NlRmxvdykge1xuICAgICAgc2VsZi5jb250YWluZXJTdGF0ZS5fY2xvc2VGbG93ID0gdW5kZWZpbmVkXG5cbiAgICAgIGlmIChjaGlsZEZsb3cpIHtcbiAgICAgICAgY2xvc2VGbG93KClcbiAgICAgIH0gLy8gTm90ZTogdGhpcyBhbGdvcml0aG0gZm9yIG1vdmluZyBldmVudHMgYXJvdW5kIGlzIHNpbWlsYXIgdG8gdGhlXG4gICAgICAvLyBhbGdvcml0aG0gd2hlbiBkZWFsaW5nIHdpdGggbGF6eSBsaW5lcyBpbiBgd3JpdGVUb0NoaWxkYC5cblxuICAgICAgY29uc3QgaW5kZXhCZWZvcmVFeGl0cyA9IHNlbGYuZXZlbnRzLmxlbmd0aFxuICAgICAgbGV0IGluZGV4QmVmb3JlRmxvdyA9IGluZGV4QmVmb3JlRXhpdHNcbiAgICAgIC8qKiBAdHlwZSB7UG9pbnR8dW5kZWZpbmVkfSAqL1xuXG4gICAgICBsZXQgcG9pbnQgLy8gRmluZCB0aGUgZmxvdyBjaHVuay5cblxuICAgICAgd2hpbGUgKGluZGV4QmVmb3JlRmxvdy0tKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzZWxmLmV2ZW50c1tpbmRleEJlZm9yZUZsb3ddWzBdID09PSAnZXhpdCcgJiZcbiAgICAgICAgICBzZWxmLmV2ZW50c1tpbmRleEJlZm9yZUZsb3ddWzFdLnR5cGUgPT09ICdjaHVua0Zsb3cnXG4gICAgICAgICkge1xuICAgICAgICAgIHBvaW50ID0gc2VsZi5ldmVudHNbaW5kZXhCZWZvcmVGbG93XVsxXS5lbmRcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4aXRDb250YWluZXJzKGNvbnRpbnVlZCkgLy8gRml4IHBvc2l0aW9ucy5cblxuICAgICAgbGV0IGluZGV4ID0gaW5kZXhCZWZvcmVFeGl0c1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBzZWxmLmV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgc2VsZi5ldmVudHNbaW5kZXhdWzFdLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIHBvaW50KVxuICAgICAgICBpbmRleCsrXG4gICAgICB9IC8vIEluamVjdCB0aGUgZXhpdHMgZWFybGllciAodGhleVx1MjAxOXJlIHN0aWxsIGFsc28gYXQgdGhlIGVuZCkuXG5cbiAgICAgIHNwbGljZShcbiAgICAgICAgc2VsZi5ldmVudHMsXG4gICAgICAgIGluZGV4QmVmb3JlRmxvdyArIDEsXG4gICAgICAgIDAsXG4gICAgICAgIHNlbGYuZXZlbnRzLnNsaWNlKGluZGV4QmVmb3JlRXhpdHMpXG4gICAgICApIC8vIERpc2NhcmQgdGhlIGR1cGxpY2F0ZSBleGl0cy5cblxuICAgICAgc2VsZi5ldmVudHMubGVuZ3RoID0gaW5kZXhcbiAgICAgIHJldHVybiBjaGVja05ld0NvbnRhaW5lcnMoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhcnQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNoZWNrTmV3Q29udGFpbmVycyhjb2RlKSB7XG4gICAgLy8gTmV4dCwgYWZ0ZXIgY29uc3VtaW5nIHRoZSBjb250aW51YXRpb24gbWFya2VycyBmb3IgZXhpc3RpbmcgYmxvY2tzLCB3ZVxuICAgIC8vIGxvb2sgZm9yIG5ldyBibG9jayBzdGFydHMgKGUuZy4gYD5gIGZvciBhIGJsb2NrIHF1b3RlKS5cbiAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYSBuZXcgYmxvY2sgc3RhcnQsIHdlIGNsb3NlIGFueSBibG9ja3MgdW5tYXRjaGVkIGluXG4gICAgLy8gc3RlcCAxIGJlZm9yZSBjcmVhdGluZyB0aGUgbmV3IGJsb2NrIGFzIGEgY2hpbGQgb2YgdGhlIGxhc3QgbWF0Y2hlZFxuICAgIC8vIGJsb2NrLlxuICAgIGlmIChjb250aW51ZWQgPT09IHN0YWNrLmxlbmd0aCkge1xuICAgICAgLy8gTm8gbmVlZCB0byBgY2hlY2tgIHdoZXRoZXIgdGhlcmVcdTIwMTlzIGEgY29udGFpbmVyLCBvZiBgZXhpdENvbnRhaW5lcnNgXG4gICAgICAvLyB3b3VsZCBiZSBtb290LlxuICAgICAgLy8gV2UgY2FuIGluc3RlYWQgaW1tZWRpYXRlbHkgYGF0dGVtcHRgIHRvIHBhcnNlIG9uZS5cbiAgICAgIGlmICghY2hpbGRGbG93KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudENvbnRpbnVlZChjb2RlKVxuICAgICAgfSAvLyBJZiB3ZSBoYXZlIGNvbmNyZXRlIGNvbnRlbnQsIHN1Y2ggYXMgYmxvY2sgSFRNTCBvciBmZW5jZWQgY29kZSxcbiAgICAgIC8vIHdlIGNhblx1MjAxOXQgaGF2ZSBjb250YWluZXJzIFx1MjAxQ3BpZXJjZVx1MjAxRCBpbnRvIHRoZW0sIHNvIHdlIGNhbiBpbW1lZGlhdGVseVxuICAgICAgLy8gc3RhcnQuXG5cbiAgICAgIGlmIChjaGlsZEZsb3cuY3VycmVudENvbnN0cnVjdCAmJiBjaGlsZEZsb3cuY3VycmVudENvbnN0cnVjdC5jb25jcmV0ZSkge1xuICAgICAgICByZXR1cm4gZmxvd1N0YXJ0KGNvZGUpXG4gICAgICB9IC8vIElmIHdlIGRvIGhhdmUgZmxvdywgaXQgY291bGQgc3RpbGwgYmUgYSBibGFuayBsaW5lLFxuICAgICAgLy8gYnV0IHdlXHUyMDE5ZCBiZSBpbnRlcnJ1cHRpbmcgaXQgdy8gYSBuZXcgY29udGFpbmVyIGlmIHRoZXJlXHUyMDE5cyBhIGN1cnJlbnRcbiAgICAgIC8vIGNvbnN0cnVjdC5cblxuICAgICAgc2VsZi5pbnRlcnJ1cHQgPSBCb29sZWFuKFxuICAgICAgICBjaGlsZEZsb3cuY3VycmVudENvbnN0cnVjdCAmJiAhY2hpbGRGbG93Ll9nZm1UYWJsZUR5bmFtaWNJbnRlcnJ1cHRIYWNrXG4gICAgICApXG4gICAgfSAvLyBDaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBjb250YWluZXIuXG5cbiAgICBzZWxmLmNvbnRhaW5lclN0YXRlID0ge31cbiAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgIGNvbnRhaW5lckNvbnN0cnVjdCxcbiAgICAgIHRoZXJlSXNBTmV3Q29udGFpbmVyLFxuICAgICAgdGhlcmVJc05vTmV3Q29udGFpbmVyXG4gICAgKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGhlcmVJc0FOZXdDb250YWluZXIoY29kZSkge1xuICAgIGlmIChjaGlsZEZsb3cpIGNsb3NlRmxvdygpXG4gICAgZXhpdENvbnRhaW5lcnMoY29udGludWVkKVxuICAgIHJldHVybiBkb2N1bWVudENvbnRpbnVlZChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGhlcmVJc05vTmV3Q29udGFpbmVyKGNvZGUpIHtcbiAgICBzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0gPSBjb250aW51ZWQgIT09IHN0YWNrLmxlbmd0aFxuICAgIGxpbmVTdGFydE9mZnNldCA9IHNlbGYubm93KCkub2Zmc2V0XG4gICAgcmV0dXJuIGZsb3dTdGFydChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZG9jdW1lbnRDb250aW51ZWQoY29kZSkge1xuICAgIC8vIFRyeSBuZXcgY29udGFpbmVycy5cbiAgICBzZWxmLmNvbnRhaW5lclN0YXRlID0ge31cbiAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgY29udGFpbmVyQ29uc3RydWN0LFxuICAgICAgY29udGFpbmVyQ29udGludWUsXG4gICAgICBmbG93U3RhcnRcbiAgICApKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250YWluZXJDb250aW51ZShjb2RlKSB7XG4gICAgY29udGludWVkKytcbiAgICBzdGFjay5wdXNoKFtzZWxmLmN1cnJlbnRDb25zdHJ1Y3QsIHNlbGYuY29udGFpbmVyU3RhdGVdKSAvLyBUcnkgYW5vdGhlci5cblxuICAgIHJldHVybiBkb2N1bWVudENvbnRpbnVlZChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZmxvd1N0YXJ0KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkRmxvdykgY2xvc2VGbG93KClcbiAgICAgIGV4aXRDb250YWluZXJzKDApXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNoaWxkRmxvdyA9IGNoaWxkRmxvdyB8fCBzZWxmLnBhcnNlci5mbG93KHNlbGYubm93KCkpXG4gICAgZWZmZWN0cy5lbnRlcignY2h1bmtGbG93Jywge1xuICAgICAgY29udGVudFR5cGU6ICdmbG93JyxcbiAgICAgIHByZXZpb3VzOiBjaGlsZFRva2VuLFxuICAgICAgX3Rva2VuaXplcjogY2hpbGRGbG93XG4gICAgfSlcbiAgICByZXR1cm4gZmxvd0NvbnRpbnVlKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBmbG93Q29udGludWUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICB3cml0ZVRvQ2hpbGQoZWZmZWN0cy5leGl0KCdjaHVua0Zsb3cnKSwgdHJ1ZSlcbiAgICAgIGV4aXRDb250YWluZXJzKDApXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgd3JpdGVUb0NoaWxkKGVmZmVjdHMuZXhpdCgnY2h1bmtGbG93JykpIC8vIEdldCByZWFkeSBmb3IgdGhlIG5leHQgbGluZS5cblxuICAgICAgY29udGludWVkID0gMFxuICAgICAgc2VsZi5pbnRlcnJ1cHQgPSB1bmRlZmluZWRcbiAgICAgIHJldHVybiBzdGFydFxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBmbG93Q29udGludWVcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZW9mXVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cbiAgZnVuY3Rpb24gd3JpdGVUb0NoaWxkKHRva2VuLCBlb2YpIHtcbiAgICBjb25zdCBzdHJlYW0gPSBzZWxmLnNsaWNlU3RyZWFtKHRva2VuKVxuICAgIGlmIChlb2YpIHN0cmVhbS5wdXNoKG51bGwpXG4gICAgdG9rZW4ucHJldmlvdXMgPSBjaGlsZFRva2VuXG4gICAgaWYgKGNoaWxkVG9rZW4pIGNoaWxkVG9rZW4ubmV4dCA9IHRva2VuXG4gICAgY2hpbGRUb2tlbiA9IHRva2VuXG4gICAgY2hpbGRGbG93LmRlZmluZVNraXAodG9rZW4uc3RhcnQpXG4gICAgY2hpbGRGbG93LndyaXRlKHN0cmVhbSkgLy8gQWxyaWdodCwgc28gd2UganVzdCBhZGRlZCBhIGxhenkgbGluZTpcbiAgICAvL1xuICAgIC8vIGBgYG1hcmtkb3duXG4gICAgLy8gPiBhXG4gICAgLy8gYi5cbiAgICAvL1xuICAgIC8vIE9yOlxuICAgIC8vXG4gICAgLy8gPiB+fn5jXG4gICAgLy8gZFxuICAgIC8vXG4gICAgLy8gT3I6XG4gICAgLy9cbiAgICAvLyA+IHwgZSB8XG4gICAgLy8gZlxuICAgIC8vIGBgYFxuICAgIC8vXG4gICAgLy8gVGhlIGNvbnN0cnVjdCBpbiB0aGUgc2Vjb25kIGV4YW1wbGUgKGZlbmNlZCBjb2RlKSBkb2VzIG5vdCBhY2NlcHQgbGF6eVxuICAgIC8vIGxpbmVzLCBzbyBpdCBtYXJrZWQgaXRzZWxmIGFzIGRvbmUgYXQgdGhlIGVuZCBvZiBpdHMgZmlyc3QgbGluZSwgYW5kXG4gICAgLy8gdGhlbiB0aGUgY29udGVudCBjb25zdHJ1Y3QgcGFyc2VzIGBkYC5cbiAgICAvLyBNb3N0IGNvbnN0cnVjdHMgaW4gbWFya2Rvd24gbWF0Y2ggb24gdGhlIGZpcnN0IGxpbmU6IGlmIHRoZSBmaXJzdCBsaW5lXG4gICAgLy8gZm9ybXMgYSBjb25zdHJ1Y3QsIGEgbm9uLWxhenkgbGluZSBjYW5cdTIwMTl0IFx1MjAxQ3VubWFrZVx1MjAxRCBpdC5cbiAgICAvL1xuICAgIC8vIFRoZSBjb25zdHJ1Y3QgaW4gdGhlIHRoaXJkIGV4YW1wbGUgaXMgcG90ZW50aWFsbHkgYSBHRk0gdGFibGUsIGFuZFxuICAgIC8vIHRob3NlIGFyZSAqd2VpcmQqLlxuICAgIC8vIEl0ICpjb3VsZCogYmUgYSB0YWJsZSwgZnJvbSB0aGUgZmlyc3QgbGluZSwgaWYgdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgLy8gbWF0Y2hlcyBhIGNvbmRpdGlvbi5cbiAgICAvLyBJbiB0aGlzIGNhc2UsIHRoYXQgc2Vjb25kIGxpbmUgaXMgbGF6eSwgd2hpY2ggXHUyMDFDdW5tYWtlc1x1MjAxRCB0aGUgZmlyc3QgbGluZVxuICAgIC8vIGFuZCB0dXJucyB0aGUgd2hvbGUgaW50byBvbmUgY29udGVudCBibG9jay5cbiAgICAvL1xuICAgIC8vIFdlXHUyMDE5dmUgbm93IHBhcnNlZCB0aGUgbm9uLWxhenkgYW5kIHRoZSBsYXp5IGxpbmUsIGFuZCBjYW4gZmlndXJlIG91dFxuICAgIC8vIHdoZXRoZXIgdGhlIGxhenkgbGluZSBzdGFydGVkIGEgbmV3IGZsb3cgYmxvY2suXG4gICAgLy8gSWYgaXQgZGlkLCB3ZSBleGl0IHRoZSBjdXJyZW50IGNvbnRhaW5lcnMgYmV0d2VlbiB0aGUgdHdvIGZsb3cgYmxvY2tzLlxuXG4gICAgaWYgKHNlbGYucGFyc2VyLmxhenlbdG9rZW4uc3RhcnQubGluZV0pIHtcbiAgICAgIGxldCBpbmRleCA9IGNoaWxkRmxvdy5ldmVudHMubGVuZ3RoXG5cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBUaGUgdG9rZW4gc3RhcnRzIGJlZm9yZSB0aGUgbGluZSBlbmRpbmdcdTIwMjZcbiAgICAgICAgICBjaGlsZEZsb3cuZXZlbnRzW2luZGV4XVsxXS5zdGFydC5vZmZzZXQgPCBsaW5lU3RhcnRPZmZzZXQgJiYgLy8gXHUyMDI2YW5kIGVpdGhlciBpcyBub3QgZW5kZWQgeWV0XHUyMDI2XG4gICAgICAgICAgKCFjaGlsZEZsb3cuZXZlbnRzW2luZGV4XVsxXS5lbmQgfHwgLy8gXHUyMDI2b3IgZW5kcyBhZnRlciBpdC5cbiAgICAgICAgICAgIGNoaWxkRmxvdy5ldmVudHNbaW5kZXhdWzFdLmVuZC5vZmZzZXQgPiBsaW5lU3RhcnRPZmZzZXQpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIEV4aXQ6IHRoZXJlXHUyMDE5cyBzdGlsbCBzb21ldGhpbmcgb3Blbiwgd2hpY2ggbWVhbnMgaXRcdTIwMTlzIGEgbGF6eSBsaW5lXG4gICAgICAgICAgLy8gcGFydCBvZiBzb21ldGhpbmcuXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH0gLy8gTm90ZTogdGhpcyBhbGdvcml0aG0gZm9yIG1vdmluZyBldmVudHMgYXJvdW5kIGlzIHNpbWlsYXIgdG8gdGhlXG4gICAgICAvLyBhbGdvcml0aG0gd2hlbiBjbG9zaW5nIGZsb3cgaW4gYGRvY3VtZW50Q29udGludWVgLlxuXG4gICAgICBjb25zdCBpbmRleEJlZm9yZUV4aXRzID0gc2VsZi5ldmVudHMubGVuZ3RoXG4gICAgICBsZXQgaW5kZXhCZWZvcmVGbG93ID0gaW5kZXhCZWZvcmVFeGl0c1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICAgICAgbGV0IHNlZW5cbiAgICAgIC8qKiBAdHlwZSB7UG9pbnR8dW5kZWZpbmVkfSAqL1xuXG4gICAgICBsZXQgcG9pbnQgLy8gRmluZCB0aGUgcHJldmlvdXMgY2h1bmsgKHRoZSBvbmUgYmVmb3JlIHRoZSBsYXp5IGxpbmUpLlxuXG4gICAgICB3aGlsZSAoaW5kZXhCZWZvcmVGbG93LS0pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHNlbGYuZXZlbnRzW2luZGV4QmVmb3JlRmxvd11bMF0gPT09ICdleGl0JyAmJlxuICAgICAgICAgIHNlbGYuZXZlbnRzW2luZGV4QmVmb3JlRmxvd11bMV0udHlwZSA9PT0gJ2NodW5rRmxvdydcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgIHBvaW50ID0gc2VsZi5ldmVudHNbaW5kZXhCZWZvcmVGbG93XVsxXS5lbmRcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VlbiA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleGl0Q29udGFpbmVycyhjb250aW51ZWQpIC8vIEZpeCBwb3NpdGlvbnMuXG5cbiAgICAgIGluZGV4ID0gaW5kZXhCZWZvcmVFeGl0c1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBzZWxmLmV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgc2VsZi5ldmVudHNbaW5kZXhdWzFdLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIHBvaW50KVxuICAgICAgICBpbmRleCsrXG4gICAgICB9IC8vIEluamVjdCB0aGUgZXhpdHMgZWFybGllciAodGhleVx1MjAxOXJlIHN0aWxsIGFsc28gYXQgdGhlIGVuZCkuXG5cbiAgICAgIHNwbGljZShcbiAgICAgICAgc2VsZi5ldmVudHMsXG4gICAgICAgIGluZGV4QmVmb3JlRmxvdyArIDEsXG4gICAgICAgIDAsXG4gICAgICAgIHNlbGYuZXZlbnRzLnNsaWNlKGluZGV4QmVmb3JlRXhpdHMpXG4gICAgICApIC8vIERpc2NhcmQgdGhlIGR1cGxpY2F0ZSBleGl0cy5cblxuICAgICAgc2VsZi5ldmVudHMubGVuZ3RoID0gaW5kZXhcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuICBmdW5jdGlvbiBleGl0Q29udGFpbmVycyhzaXplKSB7XG4gICAgbGV0IGluZGV4ID0gc3RhY2subGVuZ3RoIC8vIEV4aXQgb3BlbiBjb250YWluZXJzLlxuXG4gICAgd2hpbGUgKGluZGV4LS0gPiBzaXplKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHN0YWNrW2luZGV4XVxuICAgICAgc2VsZi5jb250YWluZXJTdGF0ZSA9IGVudHJ5WzFdXG4gICAgICBlbnRyeVswXS5leGl0LmNhbGwoc2VsZiwgZWZmZWN0cylcbiAgICB9XG5cbiAgICBzdGFjay5sZW5ndGggPSBzaXplXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUZsb3coKSB7XG4gICAgY2hpbGRGbG93LndyaXRlKFtudWxsXSlcbiAgICBjaGlsZFRva2VuID0gdW5kZWZpbmVkXG4gICAgY2hpbGRGbG93ID0gdW5kZWZpbmVkXG4gICAgc2VsZi5jb250YWluZXJTdGF0ZS5fY2xvc2VGbG93ID0gdW5kZWZpbmVkXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUNvbnRhaW5lcihlZmZlY3RzLCBvaywgbm9rKSB7XG4gIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgZWZmZWN0cyxcbiAgICBlZmZlY3RzLmF0dGVtcHQodGhpcy5wYXJzZXIuY29uc3RydWN0cy5kb2N1bWVudCwgb2ssIG5vayksXG4gICAgJ2xpbmVQcmVmaXgnLFxuICAgIHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKCdjb2RlSW5kZW50ZWQnKSA/IHVuZGVmaW5lZCA6IDRcbiAgKVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKi9cbmltcG9ydCB7XG4gIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UsXG4gIHVuaWNvZGVQdW5jdHVhdGlvbixcbiAgdW5pY29kZVdoaXRlc3BhY2Vcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKipcbiAqIENsYXNzaWZ5IHdoZXRoZXIgYSBjaGFyYWN0ZXIgY29kZSByZXByZXNlbnRzIHdoaXRlc3BhY2UsIHB1bmN0dWF0aW9uLCBvclxuICogc29tZXRoaW5nIGVsc2UuXG4gKlxuICogVXNlZCBmb3IgYXR0ZW50aW9uIChlbXBoYXNpcywgc3Ryb25nKSwgd2hvc2Ugc2VxdWVuY2VzIGNhbiBvcGVuIG9yIGNsb3NlXG4gKiBiYXNlZCBvbiB0aGUgY2xhc3Mgb2Ygc3Vycm91bmRpbmcgY2hhcmFjdGVycy5cbiAqXG4gKiBOb3RlIHRoYXQgZW9mIChgbnVsbGApIGlzIHNlZW4gYXMgd2hpdGVzcGFjZS5cbiAqXG4gKiBAcGFyYW0ge0NvZGV9IGNvZGVcbiAqIEByZXR1cm5zIHtudW1iZXJ8dW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhc3NpZnlDaGFyYWN0ZXIoY29kZSkge1xuICBpZiAoXG4gICAgY29kZSA9PT0gbnVsbCB8fFxuICAgIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkgfHxcbiAgICB1bmljb2RlV2hpdGVzcGFjZShjb2RlKVxuICApIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgaWYgKHVuaWNvZGVQdW5jdHVhdGlvbihjb2RlKSkge1xuICAgIHJldHVybiAyXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVDb250ZXh0fSBUb2tlbml6ZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlJlc29sdmVyfSBSZXNvbHZlclxuICovXG5cbi8qKlxuICogQ2FsbCBhbGwgYHJlc29sdmVBbGxgcy5cbiAqXG4gKiBAcGFyYW0ge3tyZXNvbHZlQWxsPzogUmVzb2x2ZXJ9W119IGNvbnN0cnVjdHNcbiAqIEBwYXJhbSB7RXZlbnRbXX0gZXZlbnRzXG4gKiBAcGFyYW0ge1Rva2VuaXplQ29udGV4dH0gY29udGV4dFxuICogQHJldHVybnMge0V2ZW50W119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQWxsKGNvbnN0cnVjdHMsIGV2ZW50cywgY29udGV4dCkge1xuICAvKiogQHR5cGUge1Jlc29sdmVyW119ICovXG4gIGNvbnN0IGNhbGxlZCA9IFtdXG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBjb25zdHJ1Y3RzLmxlbmd0aCkge1xuICAgIGNvbnN0IHJlc29sdmUgPSBjb25zdHJ1Y3RzW2luZGV4XS5yZXNvbHZlQWxsXG5cbiAgICBpZiAocmVzb2x2ZSAmJiAhY2FsbGVkLmluY2x1ZGVzKHJlc29sdmUpKSB7XG4gICAgICBldmVudHMgPSByZXNvbHZlKGV2ZW50cywgY29udGV4dClcbiAgICAgIGNhbGxlZC5wdXNoKHJlc29sdmUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FdmVudH0gRXZlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Qb2ludH0gUG9pbnRcbiAqL1xuaW1wb3J0IHtwdXNoLCBzcGxpY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNodW5rZWQnXG5pbXBvcnQge2NsYXNzaWZ5Q2hhcmFjdGVyfSBmcm9tICdtaWNyb21hcmstdXRpbC1jbGFzc2lmeS1jaGFyYWN0ZXInXG5pbXBvcnQge3Jlc29sdmVBbGx9IGZyb20gJ21pY3JvbWFyay11dGlsLXJlc29sdmUtYWxsJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBhdHRlbnRpb24gPSB7XG4gIG5hbWU6ICdhdHRlbnRpb24nLFxuICB0b2tlbml6ZTogdG9rZW5pemVBdHRlbnRpb24sXG4gIHJlc29sdmVBbGw6IHJlc29sdmVBbGxBdHRlbnRpb25cbn1cbi8qKlxuICogVGFrZSBhbGwgZXZlbnRzIGFuZCByZXNvbHZlIGF0dGVudGlvbiB0byBlbXBoYXNpcyBvciBzdHJvbmcuXG4gKlxuICogQHR5cGUge1Jlc29sdmVyfVxuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVBbGxBdHRlbnRpb24oZXZlbnRzLCBjb250ZXh0KSB7XG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXG4gIGxldCBvcGVuXG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG5cbiAgbGV0IGdyb3VwXG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG5cbiAgbGV0IHRleHRcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cblxuICBsZXQgb3BlbmluZ1NlcXVlbmNlXG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG5cbiAgbGV0IGNsb3NpbmdTZXF1ZW5jZVxuICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICBsZXQgdXNlXG4gIC8qKiBAdHlwZSB7RXZlbnRbXX0gKi9cblxuICBsZXQgbmV4dEV2ZW50c1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICBsZXQgb2Zmc2V0IC8vIFdhbGsgdGhyb3VnaCBhbGwgZXZlbnRzLlxuICAvL1xuICAvLyBOb3RlOiBwZXJmb3JtYW5jZSBvZiB0aGlzIGlzIGZpbmUgb24gYW4gbWIgb2Ygbm9ybWFsIG1hcmtkb3duLCBidXQgaXRcdTIwMTlzXG4gIC8vIGEgYm90dGxlbmVjayBmb3IgbWFsaWNpb3VzIHN0dWZmLlxuXG4gIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgIC8vIEZpbmQgYSB0b2tlbiB0aGF0IGNhbiBjbG9zZS5cbiAgICBpZiAoXG4gICAgICBldmVudHNbaW5kZXhdWzBdID09PSAnZW50ZXInICYmXG4gICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdhdHRlbnRpb25TZXF1ZW5jZScgJiZcbiAgICAgIGV2ZW50c1tpbmRleF1bMV0uX2Nsb3NlXG4gICAgKSB7XG4gICAgICBvcGVuID0gaW5kZXggLy8gTm93IHdhbGsgYmFjayB0byBmaW5kIGFuIG9wZW5lci5cblxuICAgICAgd2hpbGUgKG9wZW4tLSkge1xuICAgICAgICAvLyBGaW5kIGEgdG9rZW4gdGhhdCBjYW4gb3BlbiB0aGUgY2xvc2VyLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgZXZlbnRzW29wZW5dWzBdID09PSAnZXhpdCcgJiZcbiAgICAgICAgICBldmVudHNbb3Blbl1bMV0udHlwZSA9PT0gJ2F0dGVudGlvblNlcXVlbmNlJyAmJlxuICAgICAgICAgIGV2ZW50c1tvcGVuXVsxXS5fb3BlbiAmJiAvLyBJZiB0aGUgbWFya2VycyBhcmUgdGhlIHNhbWU6XG4gICAgICAgICAgY29udGV4dC5zbGljZVNlcmlhbGl6ZShldmVudHNbb3Blbl1bMV0pLmNoYXJDb2RlQXQoMCkgPT09XG4gICAgICAgICAgICBjb250ZXh0LnNsaWNlU2VyaWFsaXplKGV2ZW50c1tpbmRleF1bMV0pLmNoYXJDb2RlQXQoMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIG9wZW5pbmcgY2FuIGNsb3NlIG9yIHRoZSBjbG9zaW5nIGNhbiBvcGVuLFxuICAgICAgICAgIC8vIGFuZCB0aGUgY2xvc2Ugc2l6ZSAqaXMgbm90KiBhIG11bHRpcGxlIG9mIHRocmVlLFxuICAgICAgICAgIC8vIGJ1dCB0aGUgc3VtIG9mIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIHNpemUgKmlzKiBtdWx0aXBsZSBvZiB0aHJlZSxcbiAgICAgICAgICAvLyB0aGVuIGRvblx1MjAxOXQgbWF0Y2guXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGV2ZW50c1tvcGVuXVsxXS5fY2xvc2UgfHwgZXZlbnRzW2luZGV4XVsxXS5fb3BlbikgJiZcbiAgICAgICAgICAgIChldmVudHNbaW5kZXhdWzFdLmVuZC5vZmZzZXQgLSBldmVudHNbaW5kZXhdWzFdLnN0YXJ0Lm9mZnNldCkgJSAzICYmXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAoZXZlbnRzW29wZW5dWzFdLmVuZC5vZmZzZXQgLVxuICAgICAgICAgICAgICAgIGV2ZW50c1tvcGVuXVsxXS5zdGFydC5vZmZzZXQgK1xuICAgICAgICAgICAgICAgIGV2ZW50c1tpbmRleF1bMV0uZW5kLm9mZnNldCAtXG4gICAgICAgICAgICAgICAgZXZlbnRzW2luZGV4XVsxXS5zdGFydC5vZmZzZXQpICVcbiAgICAgICAgICAgICAgM1xuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IC8vIE51bWJlciBvZiBtYXJrZXJzIHRvIHVzZSBmcm9tIHRoZSBzZXF1ZW5jZS5cblxuICAgICAgICAgIHVzZSA9XG4gICAgICAgICAgICBldmVudHNbb3Blbl1bMV0uZW5kLm9mZnNldCAtIGV2ZW50c1tvcGVuXVsxXS5zdGFydC5vZmZzZXQgPiAxICYmXG4gICAgICAgICAgICBldmVudHNbaW5kZXhdWzFdLmVuZC5vZmZzZXQgLSBldmVudHNbaW5kZXhdWzFdLnN0YXJ0Lm9mZnNldCA+IDFcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW29wZW5dWzFdLmVuZClcbiAgICAgICAgICBjb25zdCBlbmQgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbaW5kZXhdWzFdLnN0YXJ0KVxuICAgICAgICAgIG1vdmVQb2ludChzdGFydCwgLXVzZSlcbiAgICAgICAgICBtb3ZlUG9pbnQoZW5kLCB1c2UpXG4gICAgICAgICAgb3BlbmluZ1NlcXVlbmNlID0ge1xuICAgICAgICAgICAgdHlwZTogdXNlID4gMSA/ICdzdHJvbmdTZXF1ZW5jZScgOiAnZW1waGFzaXNTZXF1ZW5jZScsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW29wZW5dWzFdLmVuZClcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xvc2luZ1NlcXVlbmNlID0ge1xuICAgICAgICAgICAgdHlwZTogdXNlID4gMSA/ICdzdHJvbmdTZXF1ZW5jZScgOiAnZW1waGFzaXNTZXF1ZW5jZScsXG4gICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2luZGV4XVsxXS5zdGFydCksXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHVzZSA+IDEgPyAnc3Ryb25nVGV4dCcgOiAnZW1waGFzaXNUZXh0JyxcbiAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbb3Blbl1bMV0uZW5kKSxcbiAgICAgICAgICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2luZGV4XVsxXS5zdGFydClcbiAgICAgICAgICB9XG4gICAgICAgICAgZ3JvdXAgPSB7XG4gICAgICAgICAgICB0eXBlOiB1c2UgPiAxID8gJ3N0cm9uZycgOiAnZW1waGFzaXMnLFxuICAgICAgICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIG9wZW5pbmdTZXF1ZW5jZS5zdGFydCksXG4gICAgICAgICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGNsb3NpbmdTZXF1ZW5jZS5lbmQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50c1tvcGVuXVsxXS5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBvcGVuaW5nU2VxdWVuY2Uuc3RhcnQpXG4gICAgICAgICAgZXZlbnRzW2luZGV4XVsxXS5zdGFydCA9IE9iamVjdC5hc3NpZ24oe30sIGNsb3NpbmdTZXF1ZW5jZS5lbmQpXG4gICAgICAgICAgbmV4dEV2ZW50cyA9IFtdIC8vIElmIHRoZXJlIGFyZSBtb3JlIG1hcmtlcnMgaW4gdGhlIG9wZW5pbmcsIGFkZCB0aGVtIGJlZm9yZS5cblxuICAgICAgICAgIGlmIChldmVudHNbb3Blbl1bMV0uZW5kLm9mZnNldCAtIGV2ZW50c1tvcGVuXVsxXS5zdGFydC5vZmZzZXQpIHtcbiAgICAgICAgICAgIG5leHRFdmVudHMgPSBwdXNoKG5leHRFdmVudHMsIFtcbiAgICAgICAgICAgICAgWydlbnRlcicsIGV2ZW50c1tvcGVuXVsxXSwgY29udGV4dF0sXG4gICAgICAgICAgICAgIFsnZXhpdCcsIGV2ZW50c1tvcGVuXVsxXSwgY29udGV4dF1cbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgfSAvLyBPcGVuaW5nLlxuXG4gICAgICAgICAgbmV4dEV2ZW50cyA9IHB1c2gobmV4dEV2ZW50cywgW1xuICAgICAgICAgICAgWydlbnRlcicsIGdyb3VwLCBjb250ZXh0XSxcbiAgICAgICAgICAgIFsnZW50ZXInLCBvcGVuaW5nU2VxdWVuY2UsIGNvbnRleHRdLFxuICAgICAgICAgICAgWydleGl0Jywgb3BlbmluZ1NlcXVlbmNlLCBjb250ZXh0XSxcbiAgICAgICAgICAgIFsnZW50ZXInLCB0ZXh0LCBjb250ZXh0XVxuICAgICAgICAgIF0pIC8vIEJldHdlZW4uXG5cbiAgICAgICAgICBuZXh0RXZlbnRzID0gcHVzaChcbiAgICAgICAgICAgIG5leHRFdmVudHMsXG4gICAgICAgICAgICByZXNvbHZlQWxsKFxuICAgICAgICAgICAgICBjb250ZXh0LnBhcnNlci5jb25zdHJ1Y3RzLmluc2lkZVNwYW4ubnVsbCxcbiAgICAgICAgICAgICAgZXZlbnRzLnNsaWNlKG9wZW4gKyAxLCBpbmRleCksXG4gICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIC8vIENsb3NpbmcuXG5cbiAgICAgICAgICBuZXh0RXZlbnRzID0gcHVzaChuZXh0RXZlbnRzLCBbXG4gICAgICAgICAgICBbJ2V4aXQnLCB0ZXh0LCBjb250ZXh0XSxcbiAgICAgICAgICAgIFsnZW50ZXInLCBjbG9zaW5nU2VxdWVuY2UsIGNvbnRleHRdLFxuICAgICAgICAgICAgWydleGl0JywgY2xvc2luZ1NlcXVlbmNlLCBjb250ZXh0XSxcbiAgICAgICAgICAgIFsnZXhpdCcsIGdyb3VwLCBjb250ZXh0XVxuICAgICAgICAgIF0pIC8vIElmIHRoZXJlIGFyZSBtb3JlIG1hcmtlcnMgaW4gdGhlIGNsb3NpbmcsIGFkZCB0aGVtIGFmdGVyLlxuXG4gICAgICAgICAgaWYgKGV2ZW50c1tpbmRleF1bMV0uZW5kLm9mZnNldCAtIGV2ZW50c1tpbmRleF1bMV0uc3RhcnQub2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAyXG4gICAgICAgICAgICBuZXh0RXZlbnRzID0gcHVzaChuZXh0RXZlbnRzLCBbXG4gICAgICAgICAgICAgIFsnZW50ZXInLCBldmVudHNbaW5kZXhdWzFdLCBjb250ZXh0XSxcbiAgICAgICAgICAgICAgWydleGl0JywgZXZlbnRzW2luZGV4XVsxXSwgY29udGV4dF1cbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzcGxpY2UoZXZlbnRzLCBvcGVuIC0gMSwgaW5kZXggLSBvcGVuICsgMywgbmV4dEV2ZW50cylcbiAgICAgICAgICBpbmRleCA9IG9wZW4gKyBuZXh0RXZlbnRzLmxlbmd0aCAtIG9mZnNldCAtIDJcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlbW92ZSByZW1haW5pbmcgc2VxdWVuY2VzLlxuXG4gIGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnYXR0ZW50aW9uU2VxdWVuY2UnKSB7XG4gICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPSAnZGF0YSdcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnRzXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVBdHRlbnRpb24oZWZmZWN0cywgb2spIHtcbiAgY29uc3QgYXR0ZW50aW9uTWFya2VycyA9IHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuYXR0ZW50aW9uTWFya2Vycy5udWxsXG4gIGNvbnN0IHByZXZpb3VzID0gdGhpcy5wcmV2aW91c1xuICBjb25zdCBiZWZvcmUgPSBjbGFzc2lmeUNoYXJhY3RlcihwcmV2aW91cylcbiAgLyoqIEB0eXBlIHtOb25OdWxsYWJsZTxDb2RlPn0gKi9cblxuICBsZXQgbWFya2VyXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdhdHRlbnRpb25TZXF1ZW5jZScpXG4gICAgbWFya2VyID0gY29kZVxuICAgIHJldHVybiBzZXF1ZW5jZShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc2VxdWVuY2UoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBtYXJrZXIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHNlcXVlbmNlXG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW4gPSBlZmZlY3RzLmV4aXQoJ2F0dGVudGlvblNlcXVlbmNlJylcbiAgICBjb25zdCBhZnRlciA9IGNsYXNzaWZ5Q2hhcmFjdGVyKGNvZGUpXG4gICAgY29uc3Qgb3BlbiA9XG4gICAgICAhYWZ0ZXIgfHwgKGFmdGVyID09PSAyICYmIGJlZm9yZSkgfHwgYXR0ZW50aW9uTWFya2Vycy5pbmNsdWRlcyhjb2RlKVxuICAgIGNvbnN0IGNsb3NlID1cbiAgICAgICFiZWZvcmUgfHwgKGJlZm9yZSA9PT0gMiAmJiBhZnRlcikgfHwgYXR0ZW50aW9uTWFya2Vycy5pbmNsdWRlcyhwcmV2aW91cylcbiAgICB0b2tlbi5fb3BlbiA9IEJvb2xlYW4obWFya2VyID09PSA0MiA/IG9wZW4gOiBvcGVuICYmIChiZWZvcmUgfHwgIWNsb3NlKSlcbiAgICB0b2tlbi5fY2xvc2UgPSBCb29sZWFuKG1hcmtlciA9PT0gNDIgPyBjbG9zZSA6IGNsb3NlICYmIChhZnRlciB8fCAhb3BlbikpXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbn1cbi8qKlxuICogTW92ZSBhIHBvaW50IGEgYml0LlxuICpcbiAqIE5vdGU6IGBtb3ZlYCBvbmx5IHdvcmtzIGluc2lkZSBsaW5lcyEgSXRcdTIwMTlzIG5vdCBwb3NzaWJsZSB0byBtb3ZlIHBhc3Qgb3RoZXJcbiAqIGNodW5rcyAocmVwbGFjZW1lbnQgY2hhcmFjdGVycywgdGFicywgb3IgbGluZSBlbmRpbmdzKS5cbiAqXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxuZnVuY3Rpb24gbW92ZVBvaW50KHBvaW50LCBvZmZzZXQpIHtcbiAgcG9pbnQuY29sdW1uICs9IG9mZnNldFxuICBwb2ludC5vZmZzZXQgKz0gb2Zmc2V0XG4gIHBvaW50Ll9idWZmZXJJbmRleCArPSBvZmZzZXRcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7XG4gIGFzY2lpQWxwaGEsXG4gIGFzY2lpQWxwaGFudW1lcmljLFxuICBhc2NpaUF0ZXh0LFxuICBhc2NpaUNvbnRyb2xcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBhdXRvbGluayA9IHtcbiAgbmFtZTogJ2F1dG9saW5rJyxcbiAgdG9rZW5pemU6IHRva2VuaXplQXV0b2xpbmtcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUF1dG9saW5rKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgbGV0IHNpemUgPSAxXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdhdXRvbGluaycpXG4gICAgZWZmZWN0cy5lbnRlcignYXV0b2xpbmtNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnYXV0b2xpbmtNYXJrZXInKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2F1dG9saW5rUHJvdG9jb2wnKVxuICAgIHJldHVybiBvcGVuXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvcGVuKGNvZGUpIHtcbiAgICBpZiAoYXNjaWlBbHBoYShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gc2NoZW1lT3JFbWFpbEF0ZXh0XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzY2lpQXRleHQoY29kZSkgPyBlbWFpbEF0ZXh0KGNvZGUpIDogbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzY2hlbWVPckVtYWlsQXRleHQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSA0MyB8fCBjb2RlID09PSA0NSB8fCBjb2RlID09PSA0NiB8fCBhc2NpaUFscGhhbnVtZXJpYyhjb2RlKVxuICAgICAgPyBzY2hlbWVJbnNpZGVPckVtYWlsQXRleHQoY29kZSlcbiAgICAgIDogZW1haWxBdGV4dChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc2NoZW1lSW5zaWRlT3JFbWFpbEF0ZXh0KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNTgpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHVybEluc2lkZVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIChjb2RlID09PSA0MyB8fCBjb2RlID09PSA0NSB8fCBjb2RlID09PSA0NiB8fCBhc2NpaUFscGhhbnVtZXJpYyhjb2RlKSkgJiZcbiAgICAgIHNpemUrKyA8IDMyXG4gICAgKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBzY2hlbWVJbnNpZGVPckVtYWlsQXRleHRcbiAgICB9XG5cbiAgICByZXR1cm4gZW1haWxBdGV4dChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdXJsSW5zaWRlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnYXV0b2xpbmtQcm90b2NvbCcpXG4gICAgICByZXR1cm4gZW5kKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gNjAgfHwgYXNjaWlDb250cm9sKGNvZGUpKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIHVybEluc2lkZVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZW1haWxBdGV4dChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDY0KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHNpemUgPSAwXG4gICAgICByZXR1cm4gZW1haWxBdFNpZ25PckRvdFxuICAgIH1cblxuICAgIGlmIChhc2NpaUF0ZXh0KGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBlbWFpbEF0ZXh0XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZW1haWxBdFNpZ25PckRvdChjb2RlKSB7XG4gICAgcmV0dXJuIGFzY2lpQWxwaGFudW1lcmljKGNvZGUpID8gZW1haWxMYWJlbChjb2RlKSA6IG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZW1haWxMYWJlbChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ2KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHNpemUgPSAwXG4gICAgICByZXR1cm4gZW1haWxBdFNpZ25PckRvdFxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgLy8gRXhpdCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUuXG4gICAgICBlZmZlY3RzLmV4aXQoJ2F1dG9saW5rUHJvdG9jb2wnKS50eXBlID0gJ2F1dG9saW5rRW1haWwnXG4gICAgICByZXR1cm4gZW5kKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVtYWlsVmFsdWUoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGVtYWlsVmFsdWUoY29kZSkge1xuICAgIGlmICgoY29kZSA9PT0gNDUgfHwgYXNjaWlBbHBoYW51bWVyaWMoY29kZSkpICYmIHNpemUrKyA8IDYzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb2RlID09PSA0NSA/IGVtYWlsVmFsdWUgOiBlbWFpbExhYmVsXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZW5kKGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdhdXRvbGlua01hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdhdXRvbGlua01hcmtlcicpXG4gICAgZWZmZWN0cy5leGl0KCdhdXRvbGluaycpXG4gICAgcmV0dXJuIG9rXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IGJsYW5rTGluZSA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplQmxhbmtMaW5lLFxuICBwYXJ0aWFsOiB0cnVlXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVCbGFua0xpbmUoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGFmdGVyV2hpdGVzcGFjZSwgJ2xpbmVQcmVmaXgnKVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyV2hpdGVzcGFjZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpID8gb2soY29kZSkgOiBub2soY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeGl0ZXJ9IEV4aXRlclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHttYXJrZG93blNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IGJsb2NrUXVvdGUgPSB7XG4gIG5hbWU6ICdibG9ja1F1b3RlJyxcbiAgdG9rZW5pemU6IHRva2VuaXplQmxvY2tRdW90ZVN0YXJ0LFxuICBjb250aW51YXRpb246IHtcbiAgICB0b2tlbml6ZTogdG9rZW5pemVCbG9ja1F1b3RlQ29udGludWF0aW9uXG4gIH0sXG4gIGV4aXRcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUJsb2NrUXVvdGVTdGFydChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gc2VsZi5jb250YWluZXJTdGF0ZVxuXG4gICAgICBpZiAoIXN0YXRlLm9wZW4pIHtcbiAgICAgICAgZWZmZWN0cy5lbnRlcignYmxvY2tRdW90ZScsIHtcbiAgICAgICAgICBfY29udGFpbmVyOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIHN0YXRlLm9wZW4gPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2Jsb2NrUXVvdGVQcmVmaXgnKVxuICAgICAgZWZmZWN0cy5lbnRlcignYmxvY2tRdW90ZU1hcmtlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnYmxvY2tRdW90ZU1hcmtlcicpXG4gICAgICByZXR1cm4gYWZ0ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlcihjb2RlKSB7XG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2Jsb2NrUXVvdGVQcmVmaXhXaGl0ZXNwYWNlJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdibG9ja1F1b3RlUHJlZml4V2hpdGVzcGFjZScpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2Jsb2NrUXVvdGVQcmVmaXgnKVxuICAgICAgcmV0dXJuIG9rXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCdibG9ja1F1b3RlUHJlZml4JylcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplQmxvY2tRdW90ZUNvbnRpbnVhdGlvbihlZmZlY3RzLCBvaywgbm9rKSB7XG4gIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgZWZmZWN0cyxcbiAgICBlZmZlY3RzLmF0dGVtcHQoYmxvY2tRdW90ZSwgb2ssIG5vayksXG4gICAgJ2xpbmVQcmVmaXgnLFxuICAgIHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKCdjb2RlSW5kZW50ZWQnKSA/IHVuZGVmaW5lZCA6IDRcbiAgKVxufVxuLyoqIEB0eXBlIHtFeGl0ZXJ9ICovXG5cbmZ1bmN0aW9uIGV4aXQoZWZmZWN0cykge1xuICBlZmZlY3RzLmV4aXQoJ2Jsb2NrUXVvdGUnKVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHthc2NpaVB1bmN0dWF0aW9ufSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IGNoYXJhY3RlckVzY2FwZSA9IHtcbiAgbmFtZTogJ2NoYXJhY3RlckVzY2FwZScsXG4gIHRva2VuaXplOiB0b2tlbml6ZUNoYXJhY3RlckVzY2FwZVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplQ2hhcmFjdGVyRXNjYXBlKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2NoYXJhY3RlckVzY2FwZScpXG4gICAgZWZmZWN0cy5lbnRlcignZXNjYXBlTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2VzY2FwZU1hcmtlcicpXG4gICAgcmV0dXJuIG9wZW5cbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIG9wZW4oY29kZSkge1xuICAgIGlmIChhc2NpaVB1bmN0dWF0aW9uKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdjaGFyYWN0ZXJFc2NhcGVWYWx1ZScpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnY2hhcmFjdGVyRXNjYXBlVmFsdWUnKVxuICAgICAgZWZmZWN0cy5leGl0KCdjaGFyYWN0ZXJFc2NhcGUnKVxuICAgICAgcmV0dXJuIG9rXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG4iLCAiLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbmNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJylcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd8ZmFsc2V9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZSh2YWx1ZSkge1xuICBjb25zdCBjaGFyYWN0ZXJSZWZlcmVuY2UgPSAnJicgKyB2YWx1ZSArICc7J1xuICBlbGVtZW50LmlubmVySFRNTCA9IGNoYXJhY3RlclJlZmVyZW5jZVxuICBjb25zdCBjaGFyID0gZWxlbWVudC50ZXh0Q29udGVudFxuXG4gIC8vIFNvbWUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMgZG8gbm90IHJlcXVpcmUgdGhlIGNsb3Npbmcgc2VtaWNvbG9uXG4gIC8vIChgJm5vdGAsIGZvciBpbnN0YW5jZSksIHdoaWNoIGxlYWRzIHRvIHNpdHVhdGlvbnMgd2hlcmUgcGFyc2luZyB0aGUgYXNzdW1lZFxuICAvLyBuYW1lZCByZWZlcmVuY2Ugb2YgYCZub3RpdDtgIHdpbGwgcmVzdWx0IGluIHRoZSBzdHJpbmcgYFx1MDBBQ2l0O2AuXG4gIC8vIFdoZW4gd2UgZW5jb3VudGVyIGEgdHJhaWxpbmcgc2VtaWNvbG9uIGFmdGVyIHBhcnNpbmcsIGFuZCB0aGUgY2hhcmFjdGVyXG4gIC8vIHJlZmVyZW5jZSB0byBkZWNvZGUgd2FzIG5vdCBhIHNlbWljb2xvbiAoYCZzZW1pO2ApLCB3ZSBjYW4gYXNzdW1lIHRoYXQgdGhlXG4gIC8vIG1hdGNoaW5nIHdhcyBub3QgY29tcGxldGUuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IFR5cGVTY3JpcHQgaXMgd3JvbmcgdGhhdCBgdGV4dENvbnRlbnRgIG9uIGVsZW1lbnRzIGNhblxuICAvLyB5aWVsZCBgbnVsbGAuXG4gIGlmIChjaGFyLmNoYXJDb2RlQXQoY2hhci5sZW5ndGggLSAxKSA9PT0gNTkgLyogYDtgICovICYmIHZhbHVlICE9PSAnc2VtaScpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIElmIHRoZSBkZWNvZGVkIHN0cmluZyBpcyBlcXVhbCB0byB0aGUgaW5wdXQsIHRoZSBjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhc1xuICAvLyBub3QgdmFsaWQuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IFR5cGVTY3JpcHQgaXMgd3JvbmcgdGhhdCBgdGV4dENvbnRlbnRgIG9uIGVsZW1lbnRzIGNhblxuICAvLyB5aWVsZCBgbnVsbGAuXG4gIHJldHVybiBjaGFyID09PSBjaGFyYWN0ZXJSZWZlcmVuY2UgPyBmYWxzZSA6IGNoYXJcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKi9cbmltcG9ydCB7ZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2V9IGZyb20gJ2RlY29kZS1uYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlJ1xuaW1wb3J0IHtcbiAgYXNjaWlBbHBoYW51bWVyaWMsXG4gIGFzY2lpRGlnaXQsXG4gIGFzY2lpSGV4RGlnaXRcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBjaGFyYWN0ZXJSZWZlcmVuY2UgPSB7XG4gIG5hbWU6ICdjaGFyYWN0ZXJSZWZlcmVuY2UnLFxuICB0b2tlbml6ZTogdG9rZW5pemVDaGFyYWN0ZXJSZWZlcmVuY2Vcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUNoYXJhY3RlclJlZmVyZW5jZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGxldCBzaXplID0gMFxuICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICBsZXQgbWF4XG4gIC8qKiBAdHlwZSB7KGNvZGU6IENvZGUpID0+IGNvZGUgaXMgbnVtYmVyfSAqL1xuXG4gIGxldCB0ZXN0XG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdjaGFyYWN0ZXJSZWZlcmVuY2UnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXInKVxuICAgIHJldHVybiBvcGVuXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvcGVuKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gMzUpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWMnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWMnKVxuICAgICAgcmV0dXJuIG51bWVyaWNcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdjaGFyYWN0ZXJSZWZlcmVuY2VWYWx1ZScpXG4gICAgbWF4ID0gMzFcbiAgICB0ZXN0ID0gYXNjaWlBbHBoYW51bWVyaWNcbiAgICByZXR1cm4gdmFsdWUoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIG51bWVyaWMoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA4OCB8fCBjb2RlID09PSAxMjApIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlckhleGFkZWNpbWFsJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbCcpXG4gICAgICBlZmZlY3RzLmVudGVyKCdjaGFyYWN0ZXJSZWZlcmVuY2VWYWx1ZScpXG4gICAgICBtYXggPSA2XG4gICAgICB0ZXN0ID0gYXNjaWlIZXhEaWdpdFxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWUnKVxuICAgIG1heCA9IDdcbiAgICB0ZXN0ID0gYXNjaWlEaWdpdFxuICAgIHJldHVybiB2YWx1ZShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdmFsdWUoY29kZSkge1xuICAgIC8qKiBAdHlwZSB7VG9rZW59ICovXG4gICAgbGV0IHRva2VuXG5cbiAgICBpZiAoY29kZSA9PT0gNTkgJiYgc2l6ZSkge1xuICAgICAgdG9rZW4gPSBlZmZlY3RzLmV4aXQoJ2NoYXJhY3RlclJlZmVyZW5jZVZhbHVlJylcblxuICAgICAgaWYgKFxuICAgICAgICB0ZXN0ID09PSBhc2NpaUFscGhhbnVtZXJpYyAmJlxuICAgICAgICAhZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2Uoc2VsZi5zbGljZVNlcmlhbGl6ZSh0b2tlbikpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgfVxuXG4gICAgICBlZmZlY3RzLmVudGVyKCdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlcicpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2NoYXJhY3RlclJlZmVyZW5jZScpXG4gICAgICByZXR1cm4gb2tcbiAgICB9XG5cbiAgICBpZiAodGVzdChjb2RlKSAmJiBzaXplKysgPCBtYXgpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7XG4gIG1hcmtkb3duTGluZUVuZGluZyxcbiAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZVxufSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IGNvZGVGZW5jZWQgPSB7XG4gIG5hbWU6ICdjb2RlRmVuY2VkJyxcbiAgdG9rZW5pemU6IHRva2VuaXplQ29kZUZlbmNlZCxcbiAgY29uY3JldGU6IHRydWVcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUNvZGVGZW5jZWQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cblxuICBjb25zdCBjbG9zaW5nRmVuY2VDb25zdHJ1Y3QgPSB7XG4gICAgdG9rZW5pemU6IHRva2VuaXplQ2xvc2luZ0ZlbmNlLFxuICAgIHBhcnRpYWw6IHRydWVcbiAgfVxuICAvKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cblxuICBjb25zdCBub25MYXp5TGluZSA9IHtcbiAgICB0b2tlbml6ZTogdG9rZW5pemVOb25MYXp5TGluZSxcbiAgICBwYXJ0aWFsOiB0cnVlXG4gIH1cbiAgY29uc3QgdGFpbCA9IHRoaXMuZXZlbnRzW3RoaXMuZXZlbnRzLmxlbmd0aCAtIDFdXG4gIGNvbnN0IGluaXRpYWxQcmVmaXggPVxuICAgIHRhaWwgJiYgdGFpbFsxXS50eXBlID09PSAnbGluZVByZWZpeCdcbiAgICAgID8gdGFpbFsyXS5zbGljZVNlcmlhbGl6ZSh0YWlsWzFdLCB0cnVlKS5sZW5ndGhcbiAgICAgIDogMFxuICBsZXQgc2l6ZU9wZW4gPSAwXG4gIC8qKiBAdHlwZSB7Tm9uTnVsbGFibGU8Q29kZT59ICovXG5cbiAgbGV0IG1hcmtlclxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignY29kZUZlbmNlZCcpXG4gICAgZWZmZWN0cy5lbnRlcignY29kZUZlbmNlZEZlbmNlJylcbiAgICBlZmZlY3RzLmVudGVyKCdjb2RlRmVuY2VkRmVuY2VTZXF1ZW5jZScpXG4gICAgbWFya2VyID0gY29kZVxuICAgIHJldHVybiBzZXF1ZW5jZU9wZW4oY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHNlcXVlbmNlT3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBzaXplT3BlbisrXG4gICAgICByZXR1cm4gc2VxdWVuY2VPcGVuXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCdjb2RlRmVuY2VkRmVuY2VTZXF1ZW5jZScpXG4gICAgcmV0dXJuIHNpemVPcGVuIDwgM1xuICAgICAgPyBub2soY29kZSlcbiAgICAgIDogZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGluZm9PcGVuLCAnd2hpdGVzcGFjZScpKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBpbmZvT3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm4gb3BlbkFmdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignY29kZUZlbmNlZEZlbmNlSW5mbycpXG4gICAgZWZmZWN0cy5lbnRlcignY2h1bmtTdHJpbmcnLCB7XG4gICAgICBjb250ZW50VHlwZTogJ3N0cmluZydcbiAgICB9KVxuICAgIHJldHVybiBpbmZvKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBpbmZvKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2NodW5rU3RyaW5nJylcbiAgICAgIGVmZmVjdHMuZXhpdCgnY29kZUZlbmNlZEZlbmNlSW5mbycpXG4gICAgICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGluZm9BZnRlciwgJ3doaXRlc3BhY2UnKShjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA5NiAmJiBjb2RlID09PSBtYXJrZXIpIHJldHVybiBub2soY29kZSlcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gaW5mb1xuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5mb0FmdGVyKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBvcGVuQWZ0ZXIoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdjb2RlRmVuY2VkRmVuY2VNZXRhJylcbiAgICBlZmZlY3RzLmVudGVyKCdjaHVua1N0cmluZycsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiAnc3RyaW5nJ1xuICAgIH0pXG4gICAgcmV0dXJuIG1ldGEoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIG1ldGEoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1N0cmluZycpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2NvZGVGZW5jZWRGZW5jZU1ldGEnKVxuICAgICAgcmV0dXJuIG9wZW5BZnRlcihjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA5NiAmJiBjb2RlID09PSBtYXJrZXIpIHJldHVybiBub2soY29kZSlcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gbWV0YVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb3BlbkFmdGVyKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ2NvZGVGZW5jZWRGZW5jZScpXG4gICAgcmV0dXJuIHNlbGYuaW50ZXJydXB0ID8gb2soY29kZSkgOiBjb250ZW50U3RhcnQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRlbnRTdGFydChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBhZnRlcihjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgIG5vbkxhenlMaW5lLFxuICAgICAgICBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgICAgY2xvc2luZ0ZlbmNlQ29uc3RydWN0LFxuICAgICAgICAgIGFmdGVyLFxuICAgICAgICAgIGluaXRpYWxQcmVmaXhcbiAgICAgICAgICAgID8gZmFjdG9yeVNwYWNlKFxuICAgICAgICAgICAgICAgIGVmZmVjdHMsXG4gICAgICAgICAgICAgICAgY29udGVudFN0YXJ0LFxuICAgICAgICAgICAgICAgICdsaW5lUHJlZml4JyxcbiAgICAgICAgICAgICAgICBpbml0aWFsUHJlZml4ICsgMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGNvbnRlbnRTdGFydFxuICAgICAgICApLFxuICAgICAgICBhZnRlclxuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2NvZGVGbG93VmFsdWUnKVxuICAgIHJldHVybiBjb250ZW50Q29udGludWUoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRlbnRDb250aW51ZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2NvZGVGbG93VmFsdWUnKVxuICAgICAgcmV0dXJuIGNvbnRlbnRTdGFydChjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBjb250ZW50Q29udGludWVcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ2NvZGVGZW5jZWQnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG4gIGZ1bmN0aW9uIHRva2VuaXplTm9uTGF6eUxpbmUoZWZmZWN0cywgb2ssIG5vaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgcmV0dXJuIHN0YXJ0XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgICAgcmV0dXJuIGxpbmVTdGFydFxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KGNvZGUpIHtcbiAgICAgIHJldHVybiBzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0gPyBub2soY29kZSkgOiBvayhjb2RlKVxuICAgIH1cbiAgfVxuICAvKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuICBmdW5jdGlvbiB0b2tlbml6ZUNsb3NpbmdGZW5jZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gICAgbGV0IHNpemUgPSAwXG4gICAgcmV0dXJuIGZhY3RvcnlTcGFjZShcbiAgICAgIGVmZmVjdHMsXG4gICAgICBjbG9zaW5nU2VxdWVuY2VTdGFydCxcbiAgICAgICdsaW5lUHJlZml4JyxcbiAgICAgIHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKCdjb2RlSW5kZW50ZWQnKVxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IDRcbiAgICApXG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIGNsb3NpbmdTZXF1ZW5jZVN0YXJ0KGNvZGUpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2NvZGVGZW5jZWRGZW5jZScpXG4gICAgICBlZmZlY3RzLmVudGVyKCdjb2RlRmVuY2VkRmVuY2VTZXF1ZW5jZScpXG4gICAgICByZXR1cm4gY2xvc2luZ1NlcXVlbmNlKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBjbG9zaW5nU2VxdWVuY2UoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgc2l6ZSsrXG4gICAgICAgIHJldHVybiBjbG9zaW5nU2VxdWVuY2VcbiAgICAgIH1cblxuICAgICAgaWYgKHNpemUgPCBzaXplT3BlbikgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdjb2RlRmVuY2VkRmVuY2VTZXF1ZW5jZScpXG4gICAgICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGNsb3NpbmdTZXF1ZW5jZUVuZCwgJ3doaXRlc3BhY2UnKShjb2RlKVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gY2xvc2luZ1NlcXVlbmNlRW5kKGNvZGUpIHtcbiAgICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgICBlZmZlY3RzLmV4aXQoJ2NvZGVGZW5jZWRGZW5jZScpXG4gICAgICAgIHJldHVybiBvayhjb2RlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlJlc29sdmVyfSBSZXNvbHZlclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IGNvZGVJbmRlbnRlZCA9IHtcbiAgbmFtZTogJ2NvZGVJbmRlbnRlZCcsXG4gIHRva2VuaXplOiB0b2tlbml6ZUNvZGVJbmRlbnRlZFxufVxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbmNvbnN0IGluZGVudGVkQ29udGVudCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplSW5kZW50ZWRDb250ZW50LFxuICBwYXJ0aWFsOiB0cnVlXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVDb2RlSW5kZW50ZWQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignY29kZUluZGVudGVkJylcbiAgICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGFmdGVyU3RhcnRQcmVmaXgsICdsaW5lUHJlZml4JywgNCArIDEpKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlclN0YXJ0UHJlZml4KGNvZGUpIHtcbiAgICBjb25zdCB0YWlsID0gc2VsZi5ldmVudHNbc2VsZi5ldmVudHMubGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gdGFpbCAmJlxuICAgICAgdGFpbFsxXS50eXBlID09PSAnbGluZVByZWZpeCcgJiZcbiAgICAgIHRhaWxbMl0uc2xpY2VTZXJpYWxpemUodGFpbFsxXSwgdHJ1ZSkubGVuZ3RoID49IDRcbiAgICAgID8gYWZ0ZXJQcmVmaXgoY29kZSlcbiAgICAgIDogbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlclByZWZpeChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBhZnRlcihjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoaW5kZW50ZWRDb250ZW50LCBhZnRlclByZWZpeCwgYWZ0ZXIpKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignY29kZUZsb3dWYWx1ZScpXG4gICAgcmV0dXJuIGNvbnRlbnQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRlbnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdjb2RlRmxvd1ZhbHVlJylcbiAgICAgIHJldHVybiBhZnRlclByZWZpeChjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBjb250ZW50XG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlcihjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCdjb2RlSW5kZW50ZWQnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVJbmRlbnRlZENvbnRlbnQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGxhenkgbGluZSwgaXQgY2FuXHUyMDE5dCBiZSBjb2RlLlxuICAgIGlmIChzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0pIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdsaW5lRW5kaW5nJylcbiAgICAgIHJldHVybiBzdGFydFxuICAgIH1cblxuICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYWZ0ZXJQcmVmaXgsICdsaW5lUHJlZml4JywgNCArIDEpKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlclByZWZpeChjb2RlKSB7XG4gICAgY29uc3QgdGFpbCA9IHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIHRhaWwgJiZcbiAgICAgIHRhaWxbMV0udHlwZSA9PT0gJ2xpbmVQcmVmaXgnICYmXG4gICAgICB0YWlsWzJdLnNsaWNlU2VyaWFsaXplKHRhaWxbMV0sIHRydWUpLmxlbmd0aCA+PSA0XG4gICAgICA/IG9rKGNvZGUpXG4gICAgICA6IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKVxuICAgICAgPyBzdGFydChjb2RlKVxuICAgICAgOiBub2soY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUHJldmlvdXN9IFByZXZpb3VzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHttYXJrZG93bkxpbmVFbmRpbmd9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5leHBvcnQgY29uc3QgY29kZVRleHQgPSB7XG4gIG5hbWU6ICdjb2RlVGV4dCcsXG4gIHRva2VuaXplOiB0b2tlbml6ZUNvZGVUZXh0LFxuICByZXNvbHZlOiByZXNvbHZlQ29kZVRleHQsXG4gIHByZXZpb3VzXG59XG4vKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQ29kZVRleHQoZXZlbnRzKSB7XG4gIGxldCB0YWlsRXhpdEluZGV4ID0gZXZlbnRzLmxlbmd0aCAtIDRcbiAgbGV0IGhlYWRFbnRlckluZGV4ID0gM1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICBsZXQgaW5kZXhcbiAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBlbnRlciAvLyBJZiB3ZSBzdGFydCBhbmQgZW5kIHdpdGggYW4gRU9MIG9yIGEgc3BhY2UuXG5cbiAgaWYgKFxuICAgIChldmVudHNbaGVhZEVudGVySW5kZXhdWzFdLnR5cGUgPT09ICdsaW5lRW5kaW5nJyB8fFxuICAgICAgZXZlbnRzW2hlYWRFbnRlckluZGV4XVsxXS50eXBlID09PSAnc3BhY2UnKSAmJlxuICAgIChldmVudHNbdGFpbEV4aXRJbmRleF1bMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmcnIHx8XG4gICAgICBldmVudHNbdGFpbEV4aXRJbmRleF1bMV0udHlwZSA9PT0gJ3NwYWNlJylcbiAgKSB7XG4gICAgaW5kZXggPSBoZWFkRW50ZXJJbmRleCAvLyBBbmQgd2UgaGF2ZSBkYXRhLlxuXG4gICAgd2hpbGUgKCsraW5kZXggPCB0YWlsRXhpdEluZGV4KSB7XG4gICAgICBpZiAoZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnY29kZVRleHREYXRhJykge1xuICAgICAgICAvLyBUaGVuIHdlIGhhdmUgcGFkZGluZy5cbiAgICAgICAgZXZlbnRzW2hlYWRFbnRlckluZGV4XVsxXS50eXBlID0gJ2NvZGVUZXh0UGFkZGluZydcbiAgICAgICAgZXZlbnRzW3RhaWxFeGl0SW5kZXhdWzFdLnR5cGUgPSAnY29kZVRleHRQYWRkaW5nJ1xuICAgICAgICBoZWFkRW50ZXJJbmRleCArPSAyXG4gICAgICAgIHRhaWxFeGl0SW5kZXggLT0gMlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBNZXJnZSBhZGphY2VudCBzcGFjZXMgYW5kIGRhdGEuXG5cbiAgaW5kZXggPSBoZWFkRW50ZXJJbmRleCAtIDFcbiAgdGFpbEV4aXRJbmRleCsrXG5cbiAgd2hpbGUgKCsraW5kZXggPD0gdGFpbEV4aXRJbmRleCkge1xuICAgIGlmIChlbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5kZXggIT09IHRhaWxFeGl0SW5kZXggJiYgZXZlbnRzW2luZGV4XVsxXS50eXBlICE9PSAnbGluZUVuZGluZycpIHtcbiAgICAgICAgZW50ZXIgPSBpbmRleFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpbmRleCA9PT0gdGFpbEV4aXRJbmRleCB8fFxuICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnbGluZUVuZGluZydcbiAgICApIHtcbiAgICAgIGV2ZW50c1tlbnRlcl1bMV0udHlwZSA9ICdjb2RlVGV4dERhdGEnXG5cbiAgICAgIGlmIChpbmRleCAhPT0gZW50ZXIgKyAyKSB7XG4gICAgICAgIGV2ZW50c1tlbnRlcl1bMV0uZW5kID0gZXZlbnRzW2luZGV4IC0gMV1bMV0uZW5kXG4gICAgICAgIGV2ZW50cy5zcGxpY2UoZW50ZXIgKyAyLCBpbmRleCAtIGVudGVyIC0gMilcbiAgICAgICAgdGFpbEV4aXRJbmRleCAtPSBpbmRleCAtIGVudGVyIC0gMlxuICAgICAgICBpbmRleCA9IGVudGVyICsgMlxuICAgICAgfVxuXG4gICAgICBlbnRlciA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudHNcbn1cbi8qKiBAdHlwZSB7UHJldmlvdXN9ICovXG5cbmZ1bmN0aW9uIHByZXZpb3VzKGNvZGUpIHtcbiAgLy8gSWYgdGhlcmUgaXMgYSBwcmV2aW91cyBjb2RlLCB0aGVyZSB3aWxsIGFsd2F5cyBiZSBhIHRhaWwuXG4gIHJldHVybiAoXG4gICAgY29kZSAhPT0gOTYgfHxcbiAgICB0aGlzLmV2ZW50c1t0aGlzLmV2ZW50cy5sZW5ndGggLSAxXVsxXS50eXBlID09PSAnY2hhcmFjdGVyRXNjYXBlJ1xuICApXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVDb2RlVGV4dChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGxldCBzaXplT3BlbiA9IDBcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgbGV0IHNpemVcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cblxuICBsZXQgdG9rZW5cbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2NvZGVUZXh0JylcbiAgICBlZmZlY3RzLmVudGVyKCdjb2RlVGV4dFNlcXVlbmNlJylcbiAgICByZXR1cm4gb3BlbmluZ1NlcXVlbmNlKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvcGVuaW5nU2VxdWVuY2UoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA5Nikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBzaXplT3BlbisrXG4gICAgICByZXR1cm4gb3BlbmluZ1NlcXVlbmNlXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCdjb2RlVGV4dFNlcXVlbmNlJylcbiAgICByZXR1cm4gZ2FwKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBnYXAoY29kZSkge1xuICAgIC8vIEVPRi5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH0gLy8gQ2xvc2luZyBmZW5jZT9cbiAgICAvLyBDb3VsZCBhbHNvIGJlIGRhdGEuXG5cbiAgICBpZiAoY29kZSA9PT0gOTYpIHtcbiAgICAgIHRva2VuID0gZWZmZWN0cy5lbnRlcignY29kZVRleHRTZXF1ZW5jZScpXG4gICAgICBzaXplID0gMFxuICAgICAgcmV0dXJuIGNsb3NpbmdTZXF1ZW5jZShjb2RlKVxuICAgIH0gLy8gVGFicyBkb25cdTIwMTl0IHdvcmssIGFuZCB2aXJ0dWFsIHNwYWNlcyBkb25cdTIwMTl0IG1ha2Ugc2Vuc2UuXG5cbiAgICBpZiAoY29kZSA9PT0gMzIpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3NwYWNlJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdzcGFjZScpXG4gICAgICByZXR1cm4gZ2FwXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignbGluZUVuZGluZycpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG4gICAgICByZXR1cm4gZ2FwXG4gICAgfSAvLyBEYXRhLlxuXG4gICAgZWZmZWN0cy5lbnRlcignY29kZVRleHREYXRhJylcbiAgICByZXR1cm4gZGF0YShjb2RlKVxuICB9IC8vIEluIGNvZGUuXG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkYXRhKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBudWxsIHx8XG4gICAgICBjb2RlID09PSAzMiB8fFxuICAgICAgY29kZSA9PT0gOTYgfHxcbiAgICAgIG1hcmtkb3duTGluZUVuZGluZyhjb2RlKVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KCdjb2RlVGV4dERhdGEnKVxuICAgICAgcmV0dXJuIGdhcChjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBkYXRhXG4gIH0gLy8gQ2xvc2luZyBmZW5jZS5cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNsb3NpbmdTZXF1ZW5jZShjb2RlKSB7XG4gICAgLy8gTW9yZS5cbiAgICBpZiAoY29kZSA9PT0gOTYpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgc2l6ZSsrXG4gICAgICByZXR1cm4gY2xvc2luZ1NlcXVlbmNlXG4gICAgfSAvLyBEb25lIVxuXG4gICAgaWYgKHNpemUgPT09IHNpemVPcGVuKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2NvZGVUZXh0U2VxdWVuY2UnKVxuICAgICAgZWZmZWN0cy5leGl0KCdjb2RlVGV4dCcpXG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9IC8vIE1vcmUgb3IgbGVzcyBhY2NlbnRzOiBtYXJrIGFzIGRhdGEuXG5cbiAgICB0b2tlbi50eXBlID0gJ2NvZGVUZXh0RGF0YSdcbiAgICByZXR1cm4gZGF0YShjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5DaHVua30gQ2h1bmtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKi9cbmltcG9ydCB7c3BsaWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaHVua2VkJ1xuXG4vKipcbiAqIFRva2VuaXplIHN1YmNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudFtdfSBldmVudHNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidG9rZW5pemUoZXZlbnRzKSB7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgY29uc3QganVtcHMgPSB7fVxuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge0V2ZW50fSAqL1xuXG4gIGxldCBldmVudFxuICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGxpbmVJbmRleFxuICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICBsZXQgb3RoZXJJbmRleFxuICAvKiogQHR5cGUge0V2ZW50fSAqL1xuXG4gIGxldCBvdGhlckV2ZW50XG4gIC8qKiBAdHlwZSB7RXZlbnRbXX0gKi9cblxuICBsZXQgcGFyYW1ldGVyc1xuICAvKiogQHR5cGUge0V2ZW50W119ICovXG5cbiAgbGV0IHN1YmV2ZW50c1xuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBtb3JlXG5cbiAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgd2hpbGUgKGluZGV4IGluIGp1bXBzKSB7XG4gICAgICBpbmRleCA9IGp1bXBzW2luZGV4XVxuICAgIH1cblxuICAgIGV2ZW50ID0gZXZlbnRzW2luZGV4XSAvLyBBZGQgYSBob29rIGZvciB0aGUgR0ZNIHRhc2tsaXN0IGV4dGVuc2lvbiwgd2hpY2ggbmVlZHMgdG8ga25vdyBpZiB0ZXh0XG4gICAgLy8gaXMgaW4gdGhlIGZpcnN0IGNvbnRlbnQgb2YgYSBsaXN0IGl0ZW0uXG5cbiAgICBpZiAoXG4gICAgICBpbmRleCAmJlxuICAgICAgZXZlbnRbMV0udHlwZSA9PT0gJ2NodW5rRmxvdycgJiZcbiAgICAgIGV2ZW50c1tpbmRleCAtIDFdWzFdLnR5cGUgPT09ICdsaXN0SXRlbVByZWZpeCdcbiAgICApIHtcbiAgICAgIHN1YmV2ZW50cyA9IGV2ZW50WzFdLl90b2tlbml6ZXIuZXZlbnRzXG4gICAgICBvdGhlckluZGV4ID0gMFxuXG4gICAgICBpZiAoXG4gICAgICAgIG90aGVySW5kZXggPCBzdWJldmVudHMubGVuZ3RoICYmXG4gICAgICAgIHN1YmV2ZW50c1tvdGhlckluZGV4XVsxXS50eXBlID09PSAnbGluZUVuZGluZ0JsYW5rJ1xuICAgICAgKSB7XG4gICAgICAgIG90aGVySW5kZXggKz0gMlxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIG90aGVySW5kZXggPCBzdWJldmVudHMubGVuZ3RoICYmXG4gICAgICAgIHN1YmV2ZW50c1tvdGhlckluZGV4XVsxXS50eXBlID09PSAnY29udGVudCdcbiAgICAgICkge1xuICAgICAgICB3aGlsZSAoKytvdGhlckluZGV4IDwgc3ViZXZlbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChzdWJldmVudHNbb3RoZXJJbmRleF1bMV0udHlwZSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdWJldmVudHNbb3RoZXJJbmRleF1bMV0udHlwZSA9PT0gJ2NodW5rVGV4dCcpIHtcbiAgICAgICAgICAgIHN1YmV2ZW50c1tvdGhlckluZGV4XVsxXS5faXNJbkZpcnN0Q29udGVudE9mTGlzdEl0ZW0gPSB0cnVlXG4gICAgICAgICAgICBvdGhlckluZGV4KytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEVudGVyLlxuXG4gICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInKSB7XG4gICAgICBpZiAoZXZlbnRbMV0uY29udGVudFR5cGUpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihqdW1wcywgc3ViY29udGVudChldmVudHMsIGluZGV4KSlcbiAgICAgICAgaW5kZXggPSBqdW1wc1tpbmRleF1cbiAgICAgICAgbW9yZSA9IHRydWVcbiAgICAgIH1cbiAgICB9IC8vIEV4aXQuXG4gICAgZWxzZSBpZiAoZXZlbnRbMV0uX2NvbnRhaW5lcikge1xuICAgICAgb3RoZXJJbmRleCA9IGluZGV4XG4gICAgICBsaW5lSW5kZXggPSB1bmRlZmluZWRcblxuICAgICAgd2hpbGUgKG90aGVySW5kZXgtLSkge1xuICAgICAgICBvdGhlckV2ZW50ID0gZXZlbnRzW290aGVySW5kZXhdXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG90aGVyRXZlbnRbMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmcnIHx8XG4gICAgICAgICAgb3RoZXJFdmVudFsxXS50eXBlID09PSAnbGluZUVuZGluZ0JsYW5rJ1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAob3RoZXJFdmVudFswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgICAgaWYgKGxpbmVJbmRleCkge1xuICAgICAgICAgICAgICBldmVudHNbbGluZUluZGV4XVsxXS50eXBlID0gJ2xpbmVFbmRpbmdCbGFuaydcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3RoZXJFdmVudFsxXS50eXBlID0gJ2xpbmVFbmRpbmcnXG4gICAgICAgICAgICBsaW5lSW5kZXggPSBvdGhlckluZGV4XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmVJbmRleCkge1xuICAgICAgICAvLyBGaXggcG9zaXRpb24uXG4gICAgICAgIGV2ZW50WzFdLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tsaW5lSW5kZXhdWzFdLnN0YXJ0KSAvLyBTd2l0Y2ggY29udGFpbmVyIGV4aXQgdy8gbGluZSBlbmRpbmdzLlxuXG4gICAgICAgIHBhcmFtZXRlcnMgPSBldmVudHMuc2xpY2UobGluZUluZGV4LCBpbmRleClcbiAgICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KGV2ZW50KVxuICAgICAgICBzcGxpY2UoZXZlbnRzLCBsaW5lSW5kZXgsIGluZGV4IC0gbGluZUluZGV4ICsgMSwgcGFyYW1ldGVycylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gIW1vcmVcbn1cbi8qKlxuICogVG9rZW5pemUgZW1iZWRkZWQgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRbXX0gZXZlbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gZXZlbnRJbmRleFxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIG51bWJlcj59XG4gKi9cblxuZnVuY3Rpb24gc3ViY29udGVudChldmVudHMsIGV2ZW50SW5kZXgpIHtcbiAgY29uc3QgdG9rZW4gPSBldmVudHNbZXZlbnRJbmRleF1bMV1cbiAgY29uc3QgY29udGV4dCA9IGV2ZW50c1tldmVudEluZGV4XVsyXVxuICBsZXQgc3RhcnRQb3NpdGlvbiA9IGV2ZW50SW5kZXggLSAxXG4gIC8qKiBAdHlwZSB7bnVtYmVyW119ICovXG5cbiAgY29uc3Qgc3RhcnRQb3NpdGlvbnMgPSBbXVxuICBjb25zdCB0b2tlbml6ZXIgPVxuICAgIHRva2VuLl90b2tlbml6ZXIgfHwgY29udGV4dC5wYXJzZXJbdG9rZW4uY29udGVudFR5cGVdKHRva2VuLnN0YXJ0KVxuICBjb25zdCBjaGlsZEV2ZW50cyA9IHRva2VuaXplci5ldmVudHNcbiAgLyoqIEB0eXBlIHtbbnVtYmVyLCBudW1iZXJdW119ICovXG5cbiAgY29uc3QganVtcHMgPSBbXVxuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIG51bWJlcj59ICovXG5cbiAgY29uc3QgZ2FwcyA9IHt9XG4gIC8qKiBAdHlwZSB7Q2h1bmtbXX0gKi9cblxuICBsZXQgc3RyZWFtXG4gIC8qKiBAdHlwZSB7VG9rZW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBwcmV2aW91c1xuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge1Rva2VufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgY3VycmVudCA9IHRva2VuXG4gIGxldCBhZGp1c3QgPSAwXG4gIGxldCBzdGFydCA9IDBcbiAgY29uc3QgYnJlYWtzID0gW3N0YXJ0XSAvLyBMb29wIGZvcndhcmQgdGhyb3VnaCB0aGUgbGlua2VkIHRva2VucyB0byBwYXNzIHRoZW0gaW4gb3JkZXIgdG8gdGhlXG4gIC8vIHN1YnRva2VuaXplci5cblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIC8vIEZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCBmb3IgdGhpcyB0b2tlbi5cbiAgICB3aGlsZSAoZXZlbnRzWysrc3RhcnRQb3NpdGlvbl1bMV0gIT09IGN1cnJlbnQpIHtcbiAgICAgIC8vIEVtcHR5LlxuICAgIH1cblxuICAgIHN0YXJ0UG9zaXRpb25zLnB1c2goc3RhcnRQb3NpdGlvbilcblxuICAgIGlmICghY3VycmVudC5fdG9rZW5pemVyKSB7XG4gICAgICBzdHJlYW0gPSBjb250ZXh0LnNsaWNlU3RyZWFtKGN1cnJlbnQpXG5cbiAgICAgIGlmICghY3VycmVudC5uZXh0KSB7XG4gICAgICAgIHN0cmVhbS5wdXNoKG51bGwpXG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICB0b2tlbml6ZXIuZGVmaW5lU2tpcChjdXJyZW50LnN0YXJ0KVxuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudC5faXNJbkZpcnN0Q29udGVudE9mTGlzdEl0ZW0pIHtcbiAgICAgICAgdG9rZW5pemVyLl9nZm1UYXNrbGlzdEZpcnN0Q29udGVudE9mTGlzdEl0ZW0gPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIHRva2VuaXplci53cml0ZShzdHJlYW0pXG5cbiAgICAgIGlmIChjdXJyZW50Ll9pc0luRmlyc3RDb250ZW50T2ZMaXN0SXRlbSkge1xuICAgICAgICB0b2tlbml6ZXIuX2dmbVRhc2tsaXN0Rmlyc3RDb250ZW50T2ZMaXN0SXRlbSA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0gLy8gVW5yYXZlbCB0aGUgbmV4dCB0b2tlbi5cblxuICAgIHByZXZpb3VzID0gY3VycmVudFxuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRcbiAgfSAvLyBOb3csIGxvb3AgYmFjayB0aHJvdWdoIGFsbCBldmVudHMgKGFuZCBsaW5rZWQgdG9rZW5zKSwgdG8gZmlndXJlIG91dCB3aGljaFxuICAvLyBwYXJ0cyBiZWxvbmcgd2hlcmUuXG5cbiAgY3VycmVudCA9IHRva2VuXG5cbiAgd2hpbGUgKCsraW5kZXggPCBjaGlsZEV2ZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoXG4gICAgICAvLyBGaW5kIGEgdm9pZCB0b2tlbiB0aGF0IGluY2x1ZGVzIGEgYnJlYWsuXG4gICAgICBjaGlsZEV2ZW50c1tpbmRleF1bMF0gPT09ICdleGl0JyAmJlxuICAgICAgY2hpbGRFdmVudHNbaW5kZXggLSAxXVswXSA9PT0gJ2VudGVyJyAmJlxuICAgICAgY2hpbGRFdmVudHNbaW5kZXhdWzFdLnR5cGUgPT09IGNoaWxkRXZlbnRzW2luZGV4IC0gMV1bMV0udHlwZSAmJlxuICAgICAgY2hpbGRFdmVudHNbaW5kZXhdWzFdLnN0YXJ0LmxpbmUgIT09IGNoaWxkRXZlbnRzW2luZGV4XVsxXS5lbmQubGluZVxuICAgICkge1xuICAgICAgc3RhcnQgPSBpbmRleCArIDFcbiAgICAgIGJyZWFrcy5wdXNoKHN0YXJ0KSAvLyBIZWxwIEdDLlxuXG4gICAgICBjdXJyZW50Ll90b2tlbml6ZXIgPSB1bmRlZmluZWRcbiAgICAgIGN1cnJlbnQucHJldmlvdXMgPSB1bmRlZmluZWRcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRcbiAgICB9XG4gIH0gLy8gSGVscCBHQy5cblxuICB0b2tlbml6ZXIuZXZlbnRzID0gW10gLy8gSWYgdGhlcmVcdTIwMTlzIG9uZSBtb3JlIHRva2VuICh3aGljaCBpcyB0aGUgY2FzZXMgZm9yIGxpbmVzIHRoYXQgZW5kIGluIGFuXG4gIC8vIEVPRiksIHRoYXRcdTIwMTlzIHBlcmZlY3Q6IHRoZSBsYXN0IHBvaW50IHdlIGZvdW5kIHN0YXJ0cyBpdC5cbiAgLy8gSWYgdGhlcmUgaXNuXHUyMDE5dCB0aGVuIG1ha2Ugc3VyZSBhbnkgcmVtYWluaW5nIGNvbnRlbnQgaXMgYWRkZWQgdG8gaXQuXG5cbiAgaWYgKGN1cnJlbnQpIHtcbiAgICAvLyBIZWxwIEdDLlxuICAgIGN1cnJlbnQuX3Rva2VuaXplciA9IHVuZGVmaW5lZFxuICAgIGN1cnJlbnQucHJldmlvdXMgPSB1bmRlZmluZWRcbiAgfSBlbHNlIHtcbiAgICBicmVha3MucG9wKClcbiAgfSAvLyBOb3cgc3BsaWNlIHRoZSBldmVudHMgZnJvbSB0aGUgc3VidG9rZW5pemVyIGludG8gdGhlIGN1cnJlbnQgZXZlbnRzLFxuICAvLyBtb3ZpbmcgYmFjayB0byBmcm9udCBzbyB0aGF0IHNwbGljZSBpbmRpY2VzIGFyZW5cdTIwMTl0IGFmZmVjdGVkLlxuXG4gIGluZGV4ID0gYnJlYWtzLmxlbmd0aFxuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBjaGlsZEV2ZW50cy5zbGljZShicmVha3NbaW5kZXhdLCBicmVha3NbaW5kZXggKyAxXSlcbiAgICBjb25zdCBzdGFydCA9IHN0YXJ0UG9zaXRpb25zLnBvcCgpXG4gICAganVtcHMudW5zaGlmdChbc3RhcnQsIHN0YXJ0ICsgc2xpY2UubGVuZ3RoIC0gMV0pXG4gICAgc3BsaWNlKGV2ZW50cywgc3RhcnQsIDIsIHNsaWNlKVxuICB9XG5cbiAgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwganVtcHMubGVuZ3RoKSB7XG4gICAgZ2Fwc1thZGp1c3QgKyBqdW1wc1tpbmRleF1bMF1dID0gYWRqdXN0ICsganVtcHNbaW5kZXhdWzFdXG4gICAgYWRqdXN0ICs9IGp1bXBzW2luZGV4XVsxXSAtIGp1bXBzW2luZGV4XVswXSAtIDFcbiAgfVxuXG4gIHJldHVybiBnYXBzXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlJlc29sdmVyfSBSZXNvbHZlclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge3N1YnRva2VuaXplfSBmcm9tICdtaWNyb21hcmstdXRpbC1zdWJ0b2tlbml6ZSdcblxuLyoqXG4gKiBObyBuYW1lIGJlY2F1c2UgaXQgbXVzdCBub3QgYmUgdHVybmVkIG9mZi5cbiAqIEB0eXBlIHtDb25zdHJ1Y3R9XG4gKi9cbmV4cG9ydCBjb25zdCBjb250ZW50ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVDb250ZW50LFxuICByZXNvbHZlOiByZXNvbHZlQ29udGVudFxufVxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbmNvbnN0IGNvbnRpbnVhdGlvbkNvbnN0cnVjdCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplQ29udGludWF0aW9uLFxuICBwYXJ0aWFsOiB0cnVlXG59XG4vKipcbiAqIENvbnRlbnQgaXMgdHJhbnNwYXJlbnQ6IGl0XHUyMDE5cyBwYXJzZWQgcmlnaHQgbm93LiBUaGF0IHdheSwgZGVmaW5pdGlvbnMgYXJlIGFsc29cbiAqIHBhcnNlZCByaWdodCBub3c6IGJlZm9yZSB0ZXh0IGluIHBhcmFncmFwaHMgKHNwZWNpZmljYWxseSwgbWVkaWEpIGFyZSBwYXJzZWQuXG4gKlxuICogQHR5cGUge1Jlc29sdmVyfVxuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVDb250ZW50KGV2ZW50cykge1xuICBzdWJ0b2tlbml6ZShldmVudHMpXG4gIHJldHVybiBldmVudHNcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUNvbnRlbnQoZWZmZWN0cywgb2spIHtcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgbGV0IHByZXZpb3VzXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdjb250ZW50JylcbiAgICBwcmV2aW91cyA9IGVmZmVjdHMuZW50ZXIoJ2NodW5rQ29udGVudCcsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiAnY29udGVudCdcbiAgICB9KVxuICAgIHJldHVybiBkYXRhKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkYXRhKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbnRlbnRFbmQoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgICAgY29udGludWF0aW9uQ29uc3RydWN0LFxuICAgICAgICBjb250ZW50Q29udGludWUsXG4gICAgICAgIGNvbnRlbnRFbmRcbiAgICAgICkoY29kZSlcbiAgICB9IC8vIERhdGEuXG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gZGF0YVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29udGVudEVuZChjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCdjaHVua0NvbnRlbnQnKVxuICAgIGVmZmVjdHMuZXhpdCgnY29udGVudCcpXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250ZW50Q29udGludWUoY29kZSkge1xuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnY2h1bmtDb250ZW50JylcbiAgICBwcmV2aW91cy5uZXh0ID0gZWZmZWN0cy5lbnRlcignY2h1bmtDb250ZW50Jywge1xuICAgICAgY29udGVudFR5cGU6ICdjb250ZW50JyxcbiAgICAgIHByZXZpb3VzXG4gICAgfSlcbiAgICBwcmV2aW91cyA9IHByZXZpb3VzLm5leHRcbiAgICByZXR1cm4gZGF0YVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVDb250aW51YXRpb24oZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gc3RhcnRMb29rYWhlYWRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydExvb2thaGVhZChjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCdjaHVua0NvbnRlbnQnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG4gICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBwcmVmaXhlZCwgJ2xpbmVQcmVmaXgnKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gcHJlZml4ZWQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGNvbnN0IHRhaWwgPSBzZWxmLmV2ZW50c1tzZWxmLmV2ZW50cy5sZW5ndGggLSAxXVxuXG4gICAgaWYgKFxuICAgICAgIXNlbGYucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKCdjb2RlSW5kZW50ZWQnKSAmJlxuICAgICAgdGFpbCAmJlxuICAgICAgdGFpbFsxXS50eXBlID09PSAnbGluZVByZWZpeCcgJiZcbiAgICAgIHRhaWxbMl0uc2xpY2VTZXJpYWxpemUodGFpbFsxXSwgdHJ1ZSkubGVuZ3RoID49IDRcbiAgICApIHtcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBlZmZlY3RzLmludGVycnVwdChzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmZsb3csIG5vaywgb2spKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRWZmZWN0c30gRWZmZWN0c1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHtcbiAgYXNjaWlDb250cm9sLFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICBtYXJrZG93bkxpbmVFbmRpbmdcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0c30gZWZmZWN0c1xuICogQHBhcmFtIHtTdGF0ZX0gb2tcbiAqIEBwYXJhbSB7U3RhdGV9IG5va1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaXRlcmFsVHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IGxpdGVyYWxNYXJrZXJUeXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3VHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1R5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PUluZmluaXR5XVxuICogQHJldHVybnMge1N0YXRlfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZXhwb3J0IGZ1bmN0aW9uIGZhY3RvcnlEZXN0aW5hdGlvbihcbiAgZWZmZWN0cyxcbiAgb2ssXG4gIG5vayxcbiAgdHlwZSxcbiAgbGl0ZXJhbFR5cGUsXG4gIGxpdGVyYWxNYXJrZXJUeXBlLFxuICByYXdUeXBlLFxuICBzdHJpbmdUeXBlLFxuICBtYXhcbikge1xuICBjb25zdCBsaW1pdCA9IG1heCB8fCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgbGV0IGJhbGFuY2UgPSAwXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjApIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIodHlwZSlcbiAgICAgIGVmZmVjdHMuZW50ZXIobGl0ZXJhbFR5cGUpXG4gICAgICBlZmZlY3RzLmVudGVyKGxpdGVyYWxNYXJrZXJUeXBlKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQobGl0ZXJhbE1hcmtlclR5cGUpXG4gICAgICByZXR1cm4gZGVzdGluYXRpb25FbmNsb3NlZEJlZm9yZVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IDQxIHx8IGFzY2lpQ29udHJvbChjb2RlKSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIodHlwZSlcbiAgICBlZmZlY3RzLmVudGVyKHJhd1R5cGUpXG4gICAgZWZmZWN0cy5lbnRlcihzdHJpbmdUeXBlKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2NodW5rU3RyaW5nJywge1xuICAgICAgY29udGVudFR5cGU6ICdzdHJpbmcnXG4gICAgfSlcbiAgICByZXR1cm4gZGVzdGluYXRpb25SYXcoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRlc3RpbmF0aW9uRW5jbG9zZWRCZWZvcmUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgZWZmZWN0cy5lbnRlcihsaXRlcmFsTWFya2VyVHlwZSlcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KGxpdGVyYWxNYXJrZXJUeXBlKVxuICAgICAgZWZmZWN0cy5leGl0KGxpdGVyYWxUeXBlKVxuICAgICAgZWZmZWN0cy5leGl0KHR5cGUpXG4gICAgICByZXR1cm4gb2tcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKHN0cmluZ1R5cGUpXG4gICAgZWZmZWN0cy5lbnRlcignY2h1bmtTdHJpbmcnLCB7XG4gICAgICBjb250ZW50VHlwZTogJ3N0cmluZydcbiAgICB9KVxuICAgIHJldHVybiBkZXN0aW5hdGlvbkVuY2xvc2VkKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkZXN0aW5hdGlvbkVuY2xvc2VkKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnY2h1bmtTdHJpbmcnKVxuICAgICAgZWZmZWN0cy5leGl0KHN0cmluZ1R5cGUpXG4gICAgICByZXR1cm4gZGVzdGluYXRpb25FbmNsb3NlZEJlZm9yZShjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IDYwIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBjb2RlID09PSA5MiA/IGRlc3RpbmF0aW9uRW5jbG9zZWRFc2NhcGUgOiBkZXN0aW5hdGlvbkVuY2xvc2VkXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkZXN0aW5hdGlvbkVuY2xvc2VkRXNjYXBlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjAgfHwgY29kZSA9PT0gNjIgfHwgY29kZSA9PT0gOTIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uRW5jbG9zZWRcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdGluYXRpb25FbmNsb3NlZChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGVzdGluYXRpb25SYXcoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0MCkge1xuICAgICAgaWYgKCsrYmFsYW5jZSA+IGxpbWl0KSByZXR1cm4gbm9rKGNvZGUpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBkZXN0aW5hdGlvblJhd1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA0MSkge1xuICAgICAgaWYgKCFiYWxhbmNlLS0pIHtcbiAgICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1N0cmluZycpXG4gICAgICAgIGVmZmVjdHMuZXhpdChzdHJpbmdUeXBlKVxuICAgICAgICBlZmZlY3RzLmV4aXQocmF3VHlwZSlcbiAgICAgICAgZWZmZWN0cy5leGl0KHR5cGUpXG4gICAgICAgIHJldHVybiBvayhjb2RlKVxuICAgICAgfVxuXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBkZXN0aW5hdGlvblJhd1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkpIHtcbiAgICAgIGlmIChiYWxhbmNlKSByZXR1cm4gbm9rKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2NodW5rU3RyaW5nJylcbiAgICAgIGVmZmVjdHMuZXhpdChzdHJpbmdUeXBlKVxuICAgICAgZWZmZWN0cy5leGl0KHJhd1R5cGUpXG4gICAgICBlZmZlY3RzLmV4aXQodHlwZSlcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChhc2NpaUNvbnRyb2woY29kZSkpIHJldHVybiBub2soY29kZSlcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29kZSA9PT0gOTIgPyBkZXN0aW5hdGlvblJhd0VzY2FwZSA6IGRlc3RpbmF0aW9uUmF3XG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkZXN0aW5hdGlvblJhd0VzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQwIHx8IGNvZGUgPT09IDQxIHx8IGNvZGUgPT09IDkyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBkZXN0aW5hdGlvblJhd1xuICAgIH1cblxuICAgIHJldHVybiBkZXN0aW5hdGlvblJhdyhjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkVmZmVjdHN9IEVmZmVjdHNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVDb250ZXh0fSBUb2tlbml6ZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nLCBtYXJrZG93blNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEBwYXJhbSB7RWZmZWN0c30gZWZmZWN0c1xuICogQHBhcmFtIHtTdGF0ZX0gb2tcbiAqIEBwYXJhbSB7U3RhdGV9IG5va1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZXJUeXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nVHlwZVxuICogQHJldHVybnMge1N0YXRlfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZXhwb3J0IGZ1bmN0aW9uIGZhY3RvcnlMYWJlbChlZmZlY3RzLCBvaywgbm9rLCB0eXBlLCBtYXJrZXJUeXBlLCBzdHJpbmdUeXBlKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGxldCBzaXplID0gMFxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cbiAgbGV0IGRhdGFcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIodHlwZSlcbiAgICBlZmZlY3RzLmVudGVyKG1hcmtlclR5cGUpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KG1hcmtlclR5cGUpXG4gICAgZWZmZWN0cy5lbnRlcihzdHJpbmdUeXBlKVxuICAgIHJldHVybiBhdEJyZWFrXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhdEJyZWFrKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBudWxsIHx8XG4gICAgICBjb2RlID09PSA5MSB8fFxuICAgICAgKGNvZGUgPT09IDkzICYmICFkYXRhKSB8fFxuICAgICAgLyogVG8gZG86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIG9uY2Ugd2VcdTIwMTl2ZSBzd2l0Y2hlZCBmcm9tXG4gICAgICAgKiBgbWljcm9tYXJrLWV4dGVuc2lvbi1mb290bm90ZWAgdG8gYG1pY3JvbWFyay1leHRlbnNpb24tZ2ZtLWZvb3Rub3RlYCxcbiAgICAgICAqIHdoaWNoIGRvZXNuXHUyMDE5dCBuZWVkIHRoaXMgKi9cblxuICAgICAgLyogSGlkZGVuIGZvb3Rub3RlcyBob29rICovXG5cbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICAgIChjb2RlID09PSA5NCAmJlxuICAgICAgICAhc2l6ZSAmJlxuICAgICAgICAnX2hpZGRlbkZvb3Rub3RlU3VwcG9ydCcgaW4gc2VsZi5wYXJzZXIuY29uc3RydWN0cykgfHxcbiAgICAgIHNpemUgPiA5OTlcbiAgICApIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gOTMpIHtcbiAgICAgIGVmZmVjdHMuZXhpdChzdHJpbmdUeXBlKVxuICAgICAgZWZmZWN0cy5lbnRlcihtYXJrZXJUeXBlKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQobWFya2VyVHlwZSlcbiAgICAgIGVmZmVjdHMuZXhpdCh0eXBlKVxuICAgICAgcmV0dXJuIG9rXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignbGluZUVuZGluZycpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG4gICAgICByZXR1cm4gYXRCcmVha1xuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2NodW5rU3RyaW5nJywge1xuICAgICAgY29udGVudFR5cGU6ICdzdHJpbmcnXG4gICAgfSlcbiAgICByZXR1cm4gbGFiZWwoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGxhYmVsKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBudWxsIHx8XG4gICAgICBjb2RlID09PSA5MSB8fFxuICAgICAgY29kZSA9PT0gOTMgfHxcbiAgICAgIG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSB8fFxuICAgICAgc2l6ZSsrID4gOTk5XG4gICAgKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2NodW5rU3RyaW5nJylcbiAgICAgIHJldHVybiBhdEJyZWFrKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZGF0YSA9IGRhdGEgfHwgIW1hcmtkb3duU3BhY2UoY29kZSlcbiAgICByZXR1cm4gY29kZSA9PT0gOTIgPyBsYWJlbEVzY2FwZSA6IGxhYmVsXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBsYWJlbEVzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDkxIHx8IGNvZGUgPT09IDkyIHx8IGNvZGUgPT09IDkzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHNpemUrK1xuICAgICAgcmV0dXJuIGxhYmVsXG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRWZmZWN0c30gRWZmZWN0c1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0c30gZWZmZWN0c1xuICogQHBhcmFtIHtTdGF0ZX0gb2tcbiAqIEBwYXJhbSB7U3RhdGV9IG5va1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZXJUeXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nVHlwZVxuICogQHJldHVybnMge1N0YXRlfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZXhwb3J0IGZ1bmN0aW9uIGZhY3RvcnlUaXRsZShlZmZlY3RzLCBvaywgbm9rLCB0eXBlLCBtYXJrZXJUeXBlLCBzdHJpbmdUeXBlKSB7XG4gIC8qKiBAdHlwZSB7Tm9uTnVsbGFibGU8Q29kZT59ICovXG4gIGxldCBtYXJrZXJcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIodHlwZSlcbiAgICBlZmZlY3RzLmVudGVyKG1hcmtlclR5cGUpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KG1hcmtlclR5cGUpXG4gICAgbWFya2VyID0gY29kZSA9PT0gNDAgPyA0MSA6IGNvZGVcbiAgICByZXR1cm4gYXRGaXJzdFRpdGxlQnJlYWtcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGF0Rmlyc3RUaXRsZUJyZWFrKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKG1hcmtlclR5cGUpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdChtYXJrZXJUeXBlKVxuICAgICAgZWZmZWN0cy5leGl0KHR5cGUpXG4gICAgICByZXR1cm4gb2tcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKHN0cmluZ1R5cGUpXG4gICAgcmV0dXJuIGF0VGl0bGVCcmVhayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYXRUaXRsZUJyZWFrKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoc3RyaW5nVHlwZSlcbiAgICAgIHJldHVybiBhdEZpcnN0VGl0bGVCcmVhayhtYXJrZXIpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9IC8vIE5vdGU6IGJsYW5rIGxpbmVzIGNhblx1MjAxOXQgZXhpc3QgaW4gY29udGVudC5cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBhdFRpdGxlQnJlYWssICdsaW5lUHJlZml4JylcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdjaHVua1N0cmluZycsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiAnc3RyaW5nJ1xuICAgIH0pXG4gICAgcmV0dXJuIHRpdGxlKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB0aXRsZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlciB8fCBjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1N0cmluZycpXG4gICAgICByZXR1cm4gYXRUaXRsZUJyZWFrKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IDkyID8gdGl0bGVFc2NhcGUgOiB0aXRsZVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGl0bGVFc2NhcGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBtYXJrZXIgfHwgY29kZSA9PT0gOTIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRpdGxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRpdGxlKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRWZmZWN0c30gRWZmZWN0c1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHttYXJrZG93bkxpbmVFbmRpbmcsIG1hcmtkb3duU3BhY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdHN9IGVmZmVjdHNcbiAqIEBwYXJhbSB7U3RhdGV9IG9rXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWN0b3J5V2hpdGVzcGFjZShlZmZlY3RzLCBvaykge1xuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIGxldCBzZWVuXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdsaW5lRW5kaW5nJylcbiAgICAgIHNlZW4gPSB0cnVlXG4gICAgICByZXR1cm4gc3RhcnRcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHNlZW4gPyAnbGluZVByZWZpeCcgOiAnbGluZVN1ZmZpeCdcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogTm9ybWFsaXplIGFuIGlkZW50aWZpZXIgKHN1Y2ggYXMgdXNlZCBpbiBkZWZpbml0aW9ucykuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSWRlbnRpZmllcih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIC8vIENvbGxhcHNlIE1hcmtkb3duIHdoaXRlc3BhY2UuXG4gICAgICAucmVwbGFjZSgvW1xcdFxcblxcciBdKy9nLCAnICcpIC8vIFRyaW0uXG4gICAgICAucmVwbGFjZSgvXiB8ICQvZywgJycpIC8vIFNvbWUgY2hhcmFjdGVycyBhcmUgY29uc2lkZXJlZCBcdTIwMUN1cHBlcmNhc2VcdTIwMUQsIGJ1dCBpZiB0aGVpciBsb3dlcmNhc2VcbiAgICAgIC8vIGNvdW50ZXJwYXJ0IGlzIHVwcGVyY2FzZWQgd2lsbCByZXN1bHQgaW4gYSBkaWZmZXJlbnQgdXBwZXJjYXNlXG4gICAgICAvLyBjaGFyYWN0ZXIuXG4gICAgICAvLyBIZW5jZSwgdG8gZ2V0IHRoYXQgZm9ybSwgd2UgcGVyZm9ybSBib3RoIGxvd2VyLSBhbmQgdXBwZXJjYXNlLlxuICAgICAgLy8gVXBwZXIgY2FzZSBtYWtlcyBzdXJlIGtleXMgd2lsbCBub3QgaW50ZXJhY3Qgd2l0aCBkZWZhdWx0IHByb3RvdHlwYWxcbiAgICAgIC8vIG1ldGhvZHM6IG5vIG1ldGhvZCBpcyB1cHBlcmNhc2UuXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgLnRvVXBwZXJDYXNlKClcbiAgKVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHtmYWN0b3J5RGVzdGluYXRpb259IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LWRlc3RpbmF0aW9uJ1xuaW1wb3J0IHtmYWN0b3J5TGFiZWx9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LWxhYmVsJ1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHtmYWN0b3J5VGl0bGV9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXRpdGxlJ1xuaW1wb3J0IHtmYWN0b3J5V2hpdGVzcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktd2hpdGVzcGFjZSdcbmltcG9ydCB7bm9ybWFsaXplSWRlbnRpZmllcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtbm9ybWFsaXplLWlkZW50aWZpZXInXG5pbXBvcnQge1xuICBtYXJrZG93bkxpbmVFbmRpbmcsXG4gIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2Vcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBkZWZpbml0aW9uID0ge1xuICBuYW1lOiAnZGVmaW5pdGlvbicsXG4gIHRva2VuaXplOiB0b2tlbml6ZURlZmluaXRpb25cbn1cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5jb25zdCB0aXRsZUNvbnN0cnVjdCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplVGl0bGUsXG4gIHBhcnRpYWw6IHRydWVcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZURlZmluaXRpb24oZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cblxuICBsZXQgaWRlbnRpZmllclxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignZGVmaW5pdGlvbicpXG4gICAgcmV0dXJuIGZhY3RvcnlMYWJlbC5jYWxsKFxuICAgICAgc2VsZixcbiAgICAgIGVmZmVjdHMsXG4gICAgICBsYWJlbEFmdGVyLFxuICAgICAgbm9rLFxuICAgICAgJ2RlZmluaXRpb25MYWJlbCcsXG4gICAgICAnZGVmaW5pdGlvbkxhYmVsTWFya2VyJyxcbiAgICAgICdkZWZpbml0aW9uTGFiZWxTdHJpbmcnXG4gICAgKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gbGFiZWxBZnRlcihjb2RlKSB7XG4gICAgaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoXG4gICAgICBzZWxmLnNsaWNlU2VyaWFsaXplKHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdWzFdKS5zbGljZSgxLCAtMSlcbiAgICApXG5cbiAgICBpZiAoY29kZSA9PT0gNTgpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2RlZmluaXRpb25NYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2RlZmluaXRpb25NYXJrZXInKSAvLyBOb3RlOiBibGFuayBsaW5lcyBjYW5cdTIwMTl0IGV4aXN0IGluIGNvbnRlbnQuXG5cbiAgICAgIHJldHVybiBmYWN0b3J5V2hpdGVzcGFjZShcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgZmFjdG9yeURlc3RpbmF0aW9uKFxuICAgICAgICAgIGVmZmVjdHMsXG4gICAgICAgICAgZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICAgICAgdGl0bGVDb25zdHJ1Y3QsXG4gICAgICAgICAgICBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYWZ0ZXIsICd3aGl0ZXNwYWNlJyksXG4gICAgICAgICAgICBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYWZ0ZXIsICd3aGl0ZXNwYWNlJylcbiAgICAgICAgICApLFxuICAgICAgICAgIG5vayxcbiAgICAgICAgICAnZGVmaW5pdGlvbkRlc3RpbmF0aW9uJyxcbiAgICAgICAgICAnZGVmaW5pdGlvbkRlc3RpbmF0aW9uTGl0ZXJhbCcsXG4gICAgICAgICAgJ2RlZmluaXRpb25EZXN0aW5hdGlvbkxpdGVyYWxNYXJrZXInLFxuICAgICAgICAgICdkZWZpbml0aW9uRGVzdGluYXRpb25SYXcnLFxuICAgICAgICAgICdkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmcnXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2RlZmluaXRpb24nKVxuXG4gICAgICBpZiAoIXNlbGYucGFyc2VyLmRlZmluZWQuaW5jbHVkZXMoaWRlbnRpZmllcikpIHtcbiAgICAgICAgc2VsZi5wYXJzZXIuZGVmaW5lZC5wdXNoKGlkZW50aWZpZXIpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplVGl0bGUoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgcmV0dXJuIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSlcbiAgICAgID8gZmFjdG9yeVdoaXRlc3BhY2UoZWZmZWN0cywgYmVmb3JlKShjb2RlKVxuICAgICAgOiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGJlZm9yZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDM0IHx8IGNvZGUgPT09IDM5IHx8IGNvZGUgPT09IDQwKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeVRpdGxlKFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYWZ0ZXIsICd3aGl0ZXNwYWNlJyksXG4gICAgICAgIG5vayxcbiAgICAgICAgJ2RlZmluaXRpb25UaXRsZScsXG4gICAgICAgICdkZWZpbml0aW9uVGl0bGVNYXJrZXInLFxuICAgICAgICAnZGVmaW5pdGlvblRpdGxlU3RyaW5nJ1xuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkgPyBvayhjb2RlKSA6IG5vayhjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBoYXJkQnJlYWtFc2NhcGUgPSB7XG4gIG5hbWU6ICdoYXJkQnJlYWtFc2NhcGUnLFxuICB0b2tlbml6ZTogdG9rZW5pemVIYXJkQnJlYWtFc2NhcGVcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUhhcmRCcmVha0VzY2FwZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdoYXJkQnJlYWtFc2NhcGUnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2VzY2FwZU1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIG9wZW5cbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIG9wZW4oY29kZSkge1xuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnZXNjYXBlTWFya2VyJylcbiAgICAgIGVmZmVjdHMuZXhpdCgnaGFyZEJyZWFrRXNjYXBlJylcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge1xuICBtYXJrZG93bkxpbmVFbmRpbmcsXG4gIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UsXG4gIG1hcmtkb3duU3BhY2Vcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuaW1wb3J0IHtzcGxpY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNodW5rZWQnXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IGhlYWRpbmdBdHggPSB7XG4gIG5hbWU6ICdoZWFkaW5nQXR4JyxcbiAgdG9rZW5pemU6IHRva2VuaXplSGVhZGluZ0F0eCxcbiAgcmVzb2x2ZTogcmVzb2x2ZUhlYWRpbmdBdHhcbn1cbi8qKiBAdHlwZSB7UmVzb2x2ZXJ9ICovXG5cbmZ1bmN0aW9uIHJlc29sdmVIZWFkaW5nQXR4KGV2ZW50cywgY29udGV4dCkge1xuICBsZXQgY29udGVudEVuZCA9IGV2ZW50cy5sZW5ndGggLSAyXG4gIGxldCBjb250ZW50U3RhcnQgPSAzXG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG5cbiAgbGV0IGNvbnRlbnRcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cblxuICBsZXQgdGV4dCAvLyBQcmVmaXggd2hpdGVzcGFjZSwgcGFydCBvZiB0aGUgb3BlbmluZy5cblxuICBpZiAoZXZlbnRzW2NvbnRlbnRTdGFydF1bMV0udHlwZSA9PT0gJ3doaXRlc3BhY2UnKSB7XG4gICAgY29udGVudFN0YXJ0ICs9IDJcbiAgfSAvLyBTdWZmaXggd2hpdGVzcGFjZSwgcGFydCBvZiB0aGUgY2xvc2luZy5cblxuICBpZiAoXG4gICAgY29udGVudEVuZCAtIDIgPiBjb250ZW50U3RhcnQgJiZcbiAgICBldmVudHNbY29udGVudEVuZF1bMV0udHlwZSA9PT0gJ3doaXRlc3BhY2UnXG4gICkge1xuICAgIGNvbnRlbnRFbmQgLT0gMlxuICB9XG5cbiAgaWYgKFxuICAgIGV2ZW50c1tjb250ZW50RW5kXVsxXS50eXBlID09PSAnYXR4SGVhZGluZ1NlcXVlbmNlJyAmJlxuICAgIChjb250ZW50U3RhcnQgPT09IGNvbnRlbnRFbmQgLSAxIHx8XG4gICAgICAoY29udGVudEVuZCAtIDQgPiBjb250ZW50U3RhcnQgJiZcbiAgICAgICAgZXZlbnRzW2NvbnRlbnRFbmQgLSAyXVsxXS50eXBlID09PSAnd2hpdGVzcGFjZScpKVxuICApIHtcbiAgICBjb250ZW50RW5kIC09IGNvbnRlbnRTdGFydCArIDEgPT09IGNvbnRlbnRFbmQgPyAyIDogNFxuICB9XG5cbiAgaWYgKGNvbnRlbnRFbmQgPiBjb250ZW50U3RhcnQpIHtcbiAgICBjb250ZW50ID0ge1xuICAgICAgdHlwZTogJ2F0eEhlYWRpbmdUZXh0JyxcbiAgICAgIHN0YXJ0OiBldmVudHNbY29udGVudFN0YXJ0XVsxXS5zdGFydCxcbiAgICAgIGVuZDogZXZlbnRzW2NvbnRlbnRFbmRdWzFdLmVuZFxuICAgIH1cbiAgICB0ZXh0ID0ge1xuICAgICAgdHlwZTogJ2NodW5rVGV4dCcsXG4gICAgICBzdGFydDogZXZlbnRzW2NvbnRlbnRTdGFydF1bMV0uc3RhcnQsXG4gICAgICBlbmQ6IGV2ZW50c1tjb250ZW50RW5kXVsxXS5lbmQsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIENvbnN0YW50cyBhcmUgZmluZSB0byBhc3NpZ24uXG4gICAgICBjb250ZW50VHlwZTogJ3RleHQnXG4gICAgfVxuICAgIHNwbGljZShldmVudHMsIGNvbnRlbnRTdGFydCwgY29udGVudEVuZCAtIGNvbnRlbnRTdGFydCArIDEsIFtcbiAgICAgIFsnZW50ZXInLCBjb250ZW50LCBjb250ZXh0XSxcbiAgICAgIFsnZW50ZXInLCB0ZXh0LCBjb250ZXh0XSxcbiAgICAgIFsnZXhpdCcsIHRleHQsIGNvbnRleHRdLFxuICAgICAgWydleGl0JywgY29udGVudCwgY29udGV4dF1cbiAgICBdKVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplSGVhZGluZ0F0eChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGxldCBzaXplID0gMFxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignYXR4SGVhZGluZycpXG4gICAgZWZmZWN0cy5lbnRlcignYXR4SGVhZGluZ1NlcXVlbmNlJylcbiAgICByZXR1cm4gZmVuY2VPcGVuSW5zaWRlKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBmZW5jZU9wZW5JbnNpZGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSAzNSAmJiBzaXplKysgPCA2KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBmZW5jZU9wZW5JbnNpZGVcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2F0eEhlYWRpbmdTZXF1ZW5jZScpXG4gICAgICByZXR1cm4gc2VsZi5pbnRlcnJ1cHQgPyBvayhjb2RlKSA6IGhlYWRpbmdCcmVhayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGhlYWRpbmdCcmVhayhjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDM1KSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdhdHhIZWFkaW5nU2VxdWVuY2UnKVxuICAgICAgcmV0dXJuIHNlcXVlbmNlKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2F0eEhlYWRpbmcnKVxuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgaGVhZGluZ0JyZWFrLCAnd2hpdGVzcGFjZScpKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignYXR4SGVhZGluZ1RleHQnKVxuICAgIHJldHVybiBkYXRhKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzZXF1ZW5jZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDM1KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBzZXF1ZW5jZVxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgnYXR4SGVhZGluZ1NlcXVlbmNlJylcbiAgICByZXR1cm4gaGVhZGluZ0JyZWFrKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkYXRhKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSAzNSB8fCBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2F0eEhlYWRpbmdUZXh0JylcbiAgICAgIHJldHVybiBoZWFkaW5nQnJlYWsoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gZGF0YVxuICB9XG59XG4iLCAiLyoqXG4gKiBMaXN0IG9mIGxvd2VyY2FzZSBIVE1MIHRhZyBuYW1lcyB3aGljaCB3aGVuIHBhcnNpbmcgSFRNTCAoZmxvdyksIHJlc3VsdFxuICogaW4gbW9yZSByZWxheGVkIHJ1bGVzIChjb25kaXRpb24gNik6IGJlY2F1c2UgdGhleSBhcmUga25vd24gYmxvY2tzLCB0aGVcbiAqIEhUTUwtbGlrZSBzeW50YXggZG9lc25cdTIwMTl0IGhhdmUgdG8gYmUgc3RyaWN0bHkgcGFyc2VkLlxuICogRm9yIHRhZyBuYW1lcyBub3QgaW4gdGhpcyBsaXN0LCBhIG1vcmUgc3RyaWN0IGFsZ29yaXRobSAoY29uZGl0aW9uIDcpIGlzIHVzZWRcbiAqIHRvIGRldGVjdCB3aGV0aGVyIHRoZSBIVE1MLWxpa2Ugc3ludGF4IGlzIHNlZW4gYXMgSFRNTCAoZmxvdykgb3Igbm90LlxuICpcbiAqIFRoaXMgaXMgY29waWVkIGZyb206XG4gKiA8aHR0cHM6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMzAvI2h0bWwtYmxvY2tzPi5cbiAqL1xuZXhwb3J0IGNvbnN0IGh0bWxCbG9ja05hbWVzID0gW1xuICAnYWRkcmVzcycsXG4gICdhcnRpY2xlJyxcbiAgJ2FzaWRlJyxcbiAgJ2Jhc2UnLFxuICAnYmFzZWZvbnQnLFxuICAnYmxvY2txdW90ZScsXG4gICdib2R5JyxcbiAgJ2NhcHRpb24nLFxuICAnY2VudGVyJyxcbiAgJ2NvbCcsXG4gICdjb2xncm91cCcsXG4gICdkZCcsXG4gICdkZXRhaWxzJyxcbiAgJ2RpYWxvZycsXG4gICdkaXInLFxuICAnZGl2JyxcbiAgJ2RsJyxcbiAgJ2R0JyxcbiAgJ2ZpZWxkc2V0JyxcbiAgJ2ZpZ2NhcHRpb24nLFxuICAnZmlndXJlJyxcbiAgJ2Zvb3RlcicsXG4gICdmb3JtJyxcbiAgJ2ZyYW1lJyxcbiAgJ2ZyYW1lc2V0JyxcbiAgJ2gxJyxcbiAgJ2gyJyxcbiAgJ2gzJyxcbiAgJ2g0JyxcbiAgJ2g1JyxcbiAgJ2g2JyxcbiAgJ2hlYWQnLFxuICAnaGVhZGVyJyxcbiAgJ2hyJyxcbiAgJ2h0bWwnLFxuICAnaWZyYW1lJyxcbiAgJ2xlZ2VuZCcsXG4gICdsaScsXG4gICdsaW5rJyxcbiAgJ21haW4nLFxuICAnbWVudScsXG4gICdtZW51aXRlbScsXG4gICduYXYnLFxuICAnbm9mcmFtZXMnLFxuICAnb2wnLFxuICAnb3B0Z3JvdXAnLFxuICAnb3B0aW9uJyxcbiAgJ3AnLFxuICAncGFyYW0nLFxuICAnc2VjdGlvbicsXG4gICdzdW1tYXJ5JyxcbiAgJ3RhYmxlJyxcbiAgJ3Rib2R5JyxcbiAgJ3RkJyxcbiAgJ3Rmb290JyxcbiAgJ3RoJyxcbiAgJ3RoZWFkJyxcbiAgJ3RpdGxlJyxcbiAgJ3RyJyxcbiAgJ3RyYWNrJyxcbiAgJ3VsJ1xuXVxuXG4vKipcbiAqIExpc3Qgb2YgbG93ZXJjYXNlIEhUTUwgdGFnIG5hbWVzIHdoaWNoIHdoZW4gcGFyc2luZyBIVE1MIChmbG93KSwgcmVzdWx0IGluXG4gKiBIVE1MIHRoYXQgY2FuIGluY2x1ZGUgbGluZXMgdy9vIGV4aXRpbmcsIHVudGlsIGEgY2xvc2luZyB0YWcgYWxzbyBpbiB0aGlzXG4gKiBsaXN0IGlzIGZvdW5kIChjb25kaXRpb24gMSkuXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgY29waWVkIGZyb206XG4gKiA8aHR0cHM6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMzAvI2h0bWwtYmxvY2tzPi5cbiAqXG4gKiBOb3RlIHRoYXQgYHRleHRhcmVhYCB3YXMgYWRkZWQgaW4gYENvbW1vbk1hcmtAMC4zMGAuXG4gKi9cbmV4cG9ydCBjb25zdCBodG1sUmF3TmFtZXMgPSBbJ3ByZScsICdzY3JpcHQnLCAnc3R5bGUnLCAndGV4dGFyZWEnXVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvZGV9IENvZGVcbiAqL1xuaW1wb3J0IHtcbiAgYXNjaWlBbHBoYSxcbiAgYXNjaWlBbHBoYW51bWVyaWMsXG4gIG1hcmtkb3duTGluZUVuZGluZyxcbiAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSxcbiAgbWFya2Rvd25TcGFjZVxufSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2h0bWxCbG9ja05hbWVzLCBodG1sUmF3TmFtZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLWh0bWwtdGFnLW5hbWUnXG5pbXBvcnQge2JsYW5rTGluZX0gZnJvbSAnLi9ibGFuay1saW5lLmpzJ1xuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbmV4cG9ydCBjb25zdCBodG1sRmxvdyA9IHtcbiAgbmFtZTogJ2h0bWxGbG93JyxcbiAgdG9rZW5pemU6IHRva2VuaXplSHRtbEZsb3csXG4gIHJlc29sdmVUbzogcmVzb2x2ZVRvSHRtbEZsb3csXG4gIGNvbmNyZXRlOiB0cnVlXG59XG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cblxuY29uc3QgbmV4dEJsYW5rQ29uc3RydWN0ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVOZXh0QmxhbmssXG4gIHBhcnRpYWw6IHRydWVcbn1cbi8qKiBAdHlwZSB7UmVzb2x2ZXJ9ICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUb0h0bWxGbG93KGV2ZW50cykge1xuICBsZXQgaW5kZXggPSBldmVudHMubGVuZ3RoXG5cbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICBpZiAoZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJyAmJiBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdodG1sRmxvdycpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGV4ID4gMSAmJiBldmVudHNbaW5kZXggLSAyXVsxXS50eXBlID09PSAnbGluZVByZWZpeCcpIHtcbiAgICAvLyBBZGQgdGhlIHByZWZpeCBzdGFydCB0byB0aGUgSFRNTCB0b2tlbi5cbiAgICBldmVudHNbaW5kZXhdWzFdLnN0YXJ0ID0gZXZlbnRzW2luZGV4IC0gMl1bMV0uc3RhcnQgLy8gQWRkIHRoZSBwcmVmaXggc3RhcnQgdG8gdGhlIEhUTUwgbGluZSB0b2tlbi5cblxuICAgIGV2ZW50c1tpbmRleCArIDFdWzFdLnN0YXJ0ID0gZXZlbnRzW2luZGV4IC0gMl1bMV0uc3RhcnQgLy8gUmVtb3ZlIHRoZSBsaW5lIHByZWZpeC5cblxuICAgIGV2ZW50cy5zcGxpY2UoaW5kZXggLSAyLCAyKVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplSHRtbEZsb3coZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICBsZXQga2luZFxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cbiAgbGV0IHN0YXJ0VGFnXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXG4gIGxldCBidWZmZXJcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgbGV0IGluZGV4XG4gIC8qKiBAdHlwZSB7Q29kZX0gKi9cblxuICBsZXQgbWFya2VyXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdodG1sRmxvdycpXG4gICAgZWZmZWN0cy5lbnRlcignaHRtbEZsb3dEYXRhJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gb3BlblxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDMzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBkZWNsYXJhdGlvblN0YXJ0XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0YWdDbG9zZVN0YXJ0XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDYzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGtpbmQgPSAzIC8vIFdoaWxlIHdlXHUyMDE5cmUgaW4gYW4gaW5zdHJ1Y3Rpb24gaW5zdGVhZCBvZiBhIGRlY2xhcmF0aW9uLCB3ZVx1MjAxOXJlIG9uIGEgYD9gXG4gICAgICAvLyByaWdodCBub3csIHNvIHdlIGRvIG5lZWQgdG8gc2VhcmNoIGZvciBgPmAsIHNpbWlsYXIgdG8gZGVjbGFyYXRpb25zLlxuXG4gICAgICByZXR1cm4gc2VsZi5pbnRlcnJ1cHQgPyBvayA6IGNvbnRpbnVhdGlvbkRlY2xhcmF0aW9uSW5zaWRlXG4gICAgfVxuXG4gICAgaWYgKGFzY2lpQWxwaGEoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgYnVmZmVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgc3RhcnRUYWcgPSB0cnVlXG4gICAgICByZXR1cm4gdGFnTmFtZVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRlY2xhcmF0aW9uU3RhcnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0NSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBraW5kID0gMlxuICAgICAgcmV0dXJuIGNvbW1lbnRPcGVuSW5zaWRlXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDkxKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGtpbmQgPSA1XG4gICAgICBidWZmZXIgPSAnQ0RBVEFbJ1xuICAgICAgaW5kZXggPSAwXG4gICAgICByZXR1cm4gY2RhdGFPcGVuSW5zaWRlXG4gICAgfVxuXG4gICAgaWYgKGFzY2lpQWxwaGEoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAga2luZCA9IDRcbiAgICAgIHJldHVybiBzZWxmLmludGVycnVwdCA/IG9rIDogY29udGludWF0aW9uRGVjbGFyYXRpb25JbnNpZGVcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21tZW50T3Blbkluc2lkZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ1KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBzZWxmLmludGVycnVwdCA/IG9rIDogY29udGludWF0aW9uRGVjbGFyYXRpb25JbnNpZGVcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjZGF0YU9wZW5JbnNpZGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBidWZmZXIuY2hhckNvZGVBdChpbmRleCsrKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5kZXggPT09IGJ1ZmZlci5sZW5ndGhcbiAgICAgICAgPyBzZWxmLmludGVycnVwdFxuICAgICAgICAgID8gb2tcbiAgICAgICAgICA6IGNvbnRpbnVhdGlvblxuICAgICAgICA6IGNkYXRhT3Blbkluc2lkZVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhZ0Nsb3NlU3RhcnQoY29kZSkge1xuICAgIGlmIChhc2NpaUFscGhhKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGJ1ZmZlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgIHJldHVybiB0YWdOYW1lXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGFnTmFtZShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgY29kZSA9PT0gNDcgfHxcbiAgICAgIGNvZGUgPT09IDYyIHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNvZGUgIT09IDQ3ICYmXG4gICAgICAgIHN0YXJ0VGFnICYmXG4gICAgICAgIGh0bWxSYXdOYW1lcy5pbmNsdWRlcyhidWZmZXIudG9Mb3dlckNhc2UoKSlcbiAgICAgICkge1xuICAgICAgICBraW5kID0gMVxuICAgICAgICByZXR1cm4gc2VsZi5pbnRlcnJ1cHQgPyBvayhjb2RlKSA6IGNvbnRpbnVhdGlvbihjb2RlKVxuICAgICAgfVxuXG4gICAgICBpZiAoaHRtbEJsb2NrTmFtZXMuaW5jbHVkZXMoYnVmZmVyLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGtpbmQgPSA2XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICAgICAgcmV0dXJuIGJhc2ljU2VsZkNsb3NpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmLmludGVycnVwdCA/IG9rKGNvZGUpIDogY29udGludWF0aW9uKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIGtpbmQgPSA3IC8vIERvIG5vdCBzdXBwb3J0IGNvbXBsZXRlIEhUTUwgd2hlbiBpbnRlcnJ1cHRpbmdcblxuICAgICAgcmV0dXJuIHNlbGYuaW50ZXJydXB0ICYmICFzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV1cbiAgICAgICAgPyBub2soY29kZSlcbiAgICAgICAgOiBzdGFydFRhZ1xuICAgICAgICA/IGNvbXBsZXRlQXR0cmlidXRlTmFtZUJlZm9yZShjb2RlKVxuICAgICAgICA6IGNvbXBsZXRlQ2xvc2luZ1RhZ0FmdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDQ1IHx8IGFzY2lpQWxwaGFudW1lcmljKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGJ1ZmZlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICByZXR1cm4gdGFnTmFtZVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGJhc2ljU2VsZkNsb3NpbmcoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gc2VsZi5pbnRlcnJ1cHQgPyBvayA6IGNvbnRpbnVhdGlvblxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlQ2xvc2luZ1RhZ0FmdGVyKGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tcGxldGVDbG9zaW5nVGFnQWZ0ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGxldGVFbmQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlQXR0cmlidXRlTmFtZUJlZm9yZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb21wbGV0ZUVuZFxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA1OCB8fCBjb2RlID09PSA5NSB8fCBhc2NpaUFscGhhKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb21wbGV0ZUF0dHJpYnV0ZU5hbWVcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tcGxldGVBdHRyaWJ1dGVOYW1lQmVmb3JlXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBsZXRlRW5kKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21wbGV0ZUF0dHJpYnV0ZU5hbWUoY29kZSkge1xuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IDQ1IHx8XG4gICAgICBjb2RlID09PSA0NiB8fFxuICAgICAgY29kZSA9PT0gNTggfHxcbiAgICAgIGNvZGUgPT09IDk1IHx8XG4gICAgICBhc2NpaUFscGhhbnVtZXJpYyhjb2RlKVxuICAgICkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tcGxldGVBdHRyaWJ1dGVOYW1lXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlTmFtZUFmdGVyKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21wbGV0ZUF0dHJpYnV0ZU5hbWVBZnRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDYxKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb21wbGV0ZUF0dHJpYnV0ZVZhbHVlQmVmb3JlXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlTmFtZUFmdGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlTmFtZUJlZm9yZShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29tcGxldGVBdHRyaWJ1dGVWYWx1ZUJlZm9yZShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgY29kZSA9PT0gNjAgfHxcbiAgICAgIGNvZGUgPT09IDYxIHx8XG4gICAgICBjb2RlID09PSA2MiB8fFxuICAgICAgY29kZSA9PT0gOTZcbiAgICApIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMzQgfHwgY29kZSA9PT0gMzkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgbWFya2VyID0gY29kZVxuICAgICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlVmFsdWVRdW90ZWRcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tcGxldGVBdHRyaWJ1dGVWYWx1ZUJlZm9yZVxuICAgIH1cblxuICAgIG1hcmtlciA9IG51bGxcbiAgICByZXR1cm4gY29tcGxldGVBdHRyaWJ1dGVWYWx1ZVVucXVvdGVkKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21wbGV0ZUF0dHJpYnV0ZVZhbHVlUXVvdGVkKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb21wbGV0ZUF0dHJpYnV0ZVZhbHVlUXVvdGVkQWZ0ZXJcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29tcGxldGVBdHRyaWJ1dGVWYWx1ZVF1b3RlZFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29tcGxldGVBdHRyaWJ1dGVWYWx1ZVVucXVvdGVkKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBudWxsIHx8XG4gICAgICBjb2RlID09PSAzNCB8fFxuICAgICAgY29kZSA9PT0gMzkgfHxcbiAgICAgIGNvZGUgPT09IDYwIHx8XG4gICAgICBjb2RlID09PSA2MSB8fFxuICAgICAgY29kZSA9PT0gNjIgfHxcbiAgICAgIGNvZGUgPT09IDk2IHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gY29tcGxldGVBdHRyaWJ1dGVOYW1lQWZ0ZXIoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29tcGxldGVBdHRyaWJ1dGVWYWx1ZVVucXVvdGVkXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21wbGV0ZUF0dHJpYnV0ZVZhbHVlUXVvdGVkQWZ0ZXIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0NyB8fCBjb2RlID09PSA2MiB8fCBtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gY29tcGxldGVBdHRyaWJ1dGVOYW1lQmVmb3JlKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29tcGxldGVFbmQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tcGxldGVBZnRlclxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlQWZ0ZXIoY29kZSkge1xuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb21wbGV0ZUFmdGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpXG4gICAgICA/IGNvbnRpbnVhdGlvbihjb2RlKVxuICAgICAgOiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRpbnVhdGlvbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ1ICYmIGtpbmQgPT09IDIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbnRpbnVhdGlvbkNvbW1lbnRJbnNpZGVcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNjAgJiYga2luZCA9PT0gMSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29udGludWF0aW9uUmF3VGFnT3BlblxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA2MiAmJiBraW5kID09PSA0KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb250aW51YXRpb25DbG9zZVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA2MyAmJiBraW5kID09PSAzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb250aW51YXRpb25EZWNsYXJhdGlvbkluc2lkZVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA5MyAmJiBraW5kID09PSA1KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb250aW51YXRpb25DaGFyYWN0ZXJEYXRhSW5zaWRlXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSAmJiAoa2luZCA9PT0gNiB8fCBraW5kID09PSA3KSkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICAgIG5leHRCbGFua0NvbnN0cnVjdCxcbiAgICAgICAgY29udGludWF0aW9uQ2xvc2UsXG4gICAgICAgIGNvbnRpbnVhdGlvbkF0TGluZUVuZGluZ1xuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIGNvbnRpbnVhdGlvbkF0TGluZUVuZGluZyhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBjb250aW51YXRpb25cbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRpbnVhdGlvbkF0TGluZUVuZGluZyhjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCdodG1sRmxvd0RhdGEnKVxuICAgIHJldHVybiBodG1sQ29udGludWVTdGFydChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaHRtbENvbnRpbnVlU3RhcnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZG9uZShjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgIHtcbiAgICAgICAgICB0b2tlbml6ZTogaHRtbExpbmVFbmQsXG4gICAgICAgICAgcGFydGlhbDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBodG1sQ29udGludWVTdGFydCxcbiAgICAgICAgZG9uZVxuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2h0bWxGbG93RGF0YScpXG4gICAgcmV0dXJuIGNvbnRpbnVhdGlvbihjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG4gIGZ1bmN0aW9uIGh0bWxMaW5lRW5kKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgICByZXR1cm4gc3RhcnRcbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignbGluZUVuZGluZycpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG4gICAgICByZXR1cm4gbGluZVN0YXJ0XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoY29kZSkge1xuICAgICAgcmV0dXJuIHNlbGYucGFyc2VyLmxhenlbc2VsZi5ub3coKS5saW5lXSA/IG5vayhjb2RlKSA6IG9rKGNvZGUpXG4gICAgfVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29udGludWF0aW9uQ29tbWVudEluc2lkZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ1KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb250aW51YXRpb25EZWNsYXJhdGlvbkluc2lkZVxuICAgIH1cblxuICAgIHJldHVybiBjb250aW51YXRpb24oY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRpbnVhdGlvblJhd1RhZ09wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBidWZmZXIgPSAnJ1xuICAgICAgcmV0dXJuIGNvbnRpbnVhdGlvblJhd0VuZFRhZ1xuICAgIH1cblxuICAgIHJldHVybiBjb250aW51YXRpb24oY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRpbnVhdGlvblJhd0VuZFRhZyhjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDYyICYmIGh0bWxSYXdOYW1lcy5pbmNsdWRlcyhidWZmZXIudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbnRpbnVhdGlvbkNsb3NlXG4gICAgfVxuXG4gICAgaWYgKGFzY2lpQWxwaGEoY29kZSkgJiYgYnVmZmVyLmxlbmd0aCA8IDgpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgYnVmZmVyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgIHJldHVybiBjb250aW51YXRpb25SYXdFbmRUYWdcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGludWF0aW9uKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250aW51YXRpb25DaGFyYWN0ZXJEYXRhSW5zaWRlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gOTMpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbnRpbnVhdGlvbkRlY2xhcmF0aW9uSW5zaWRlXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRpbnVhdGlvbihjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29udGludWF0aW9uRGVjbGFyYXRpb25JbnNpZGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29udGludWF0aW9uQ2xvc2VcbiAgICB9IC8vIE1vcmUgZGFzaGVzLlxuXG4gICAgaWYgKGNvZGUgPT09IDQ1ICYmIGtpbmQgPT09IDIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbnRpbnVhdGlvbkRlY2xhcmF0aW9uSW5zaWRlXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRpbnVhdGlvbihjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29udGludWF0aW9uQ2xvc2UoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdodG1sRmxvd0RhdGEnKVxuICAgICAgcmV0dXJuIGRvbmUoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29udGludWF0aW9uQ2xvc2VcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRvbmUoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnaHRtbEZsb3cnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVOZXh0QmxhbmsoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCdodG1sRmxvd0RhdGEnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmdCbGFuaycpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdsaW5lRW5kaW5nQmxhbmsnKVxuICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoYmxhbmtMaW5lLCBvaywgbm9rKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7XG4gIGFzY2lpQWxwaGEsXG4gIGFzY2lpQWxwaGFudW1lcmljLFxuICBtYXJrZG93bkxpbmVFbmRpbmcsXG4gIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UsXG4gIG1hcmtkb3duU3BhY2Vcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBodG1sVGV4dCA9IHtcbiAgbmFtZTogJ2h0bWxUZXh0JyxcbiAgdG9rZW5pemU6IHRva2VuaXplSHRtbFRleHRcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUh0bWxUZXh0KGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgLyoqIEB0eXBlIHtOb25OdWxsYWJsZTxDb2RlPnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IG1hcmtlclxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cblxuICBsZXQgYnVmZmVyXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXG4gIGxldCBpbmRleFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGxldCByZXR1cm5TdGF0ZVxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignaHRtbFRleHQnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2h0bWxUZXh0RGF0YScpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIG9wZW5cbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIG9wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSAzMykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZGVjbGFyYXRpb25PcGVuXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0YWdDbG9zZVN0YXJ0XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDYzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbnN0cnVjdGlvblxuICAgIH1cblxuICAgIGlmIChhc2NpaUFscGhhKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0YWdPcGVuXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGVjbGFyYXRpb25PcGVuKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDUpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbW1lbnRPcGVuXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDkxKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGJ1ZmZlciA9ICdDREFUQVsnXG4gICAgICBpbmRleCA9IDBcbiAgICAgIHJldHVybiBjZGF0YU9wZW5cbiAgICB9XG5cbiAgICBpZiAoYXNjaWlBbHBoYShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZGVjbGFyYXRpb25cbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21tZW50T3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ1KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb21tZW50U3RhcnRcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21tZW50U3RhcnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IDYyKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDQ1KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb21tZW50U3RhcnREYXNoXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbW1lbnQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbW1lbnRTdGFydERhc2goY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IDYyKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbW1lbnQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbW1lbnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDQ1KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb21tZW50Q2xvc2VcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm5TdGF0ZSA9IGNvbW1lbnRcbiAgICAgIHJldHVybiBhdExpbmVFbmRpbmcoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29tbWVudFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29tbWVudENsb3NlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDUpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGVuZFxuICAgIH1cblxuICAgIHJldHVybiBjb21tZW50KGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjZGF0YU9wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSBidWZmZXIuY2hhckNvZGVBdChpbmRleCsrKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5kZXggPT09IGJ1ZmZlci5sZW5ndGggPyBjZGF0YSA6IGNkYXRhT3BlblxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNkYXRhKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA5Mykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY2RhdGFDbG9zZVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVyblN0YXRlID0gY2RhdGFcbiAgICAgIHJldHVybiBhdExpbmVFbmRpbmcoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY2RhdGFcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNkYXRhQ2xvc2UoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA5Mykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY2RhdGFFbmRcbiAgICB9XG5cbiAgICByZXR1cm4gY2RhdGEoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNkYXRhRW5kKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgIHJldHVybiBlbmQoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gOTMpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNkYXRhRW5kXG4gICAgfVxuXG4gICAgcmV0dXJuIGNkYXRhKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkZWNsYXJhdGlvbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgY29kZSA9PT0gNjIpIHtcbiAgICAgIHJldHVybiBlbmQoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm5TdGF0ZSA9IGRlY2xhcmF0aW9uXG4gICAgICByZXR1cm4gYXRMaW5lRW5kaW5nKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBpbnN0cnVjdGlvbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNjMpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluc3RydWN0aW9uQ2xvc2VcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm5TdGF0ZSA9IGluc3RydWN0aW9uXG4gICAgICByZXR1cm4gYXRMaW5lRW5kaW5nKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGluc3RydWN0aW9uXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBpbnN0cnVjdGlvbkNsb3NlKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gNjIgPyBlbmQoY29kZSkgOiBpbnN0cnVjdGlvbihjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGFnQ2xvc2VTdGFydChjb2RlKSB7XG4gICAgaWYgKGFzY2lpQWxwaGEoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRhZ0Nsb3NlXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGFnQ2xvc2UoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0NSB8fCBhc2NpaUFscGhhbnVtZXJpYyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdGFnQ2xvc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGFnQ2xvc2VCZXR3ZWVuKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB0YWdDbG9zZUJldHdlZW4oY29kZSkge1xuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVyblN0YXRlID0gdGFnQ2xvc2VCZXR3ZWVuXG4gICAgICByZXR1cm4gYXRMaW5lRW5kaW5nKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRhZ0Nsb3NlQmV0d2VlblxuICAgIH1cblxuICAgIHJldHVybiBlbmQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhZ09wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0NSB8fCBhc2NpaUFscGhhbnVtZXJpYyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdGFnT3BlblxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA0NyB8fCBjb2RlID09PSA2MiB8fCBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gdGFnT3BlbkJldHdlZW4oY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB0YWdPcGVuQmV0d2Vlbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBlbmRcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNTggfHwgY29kZSA9PT0gOTUgfHwgYXNjaWlBbHBoYShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdGFnT3BlbkF0dHJpYnV0ZU5hbWVcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm5TdGF0ZSA9IHRhZ09wZW5CZXR3ZWVuXG4gICAgICByZXR1cm4gYXRMaW5lRW5kaW5nKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRhZ09wZW5CZXR3ZWVuXG4gICAgfVxuXG4gICAgcmV0dXJuIGVuZChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGFnT3BlbkF0dHJpYnV0ZU5hbWUoY29kZSkge1xuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IDQ1IHx8XG4gICAgICBjb2RlID09PSA0NiB8fFxuICAgICAgY29kZSA9PT0gNTggfHxcbiAgICAgIGNvZGUgPT09IDk1IHx8XG4gICAgICBhc2NpaUFscGhhbnVtZXJpYyhjb2RlKVxuICAgICkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdGFnT3BlbkF0dHJpYnV0ZU5hbWVcbiAgICB9XG5cbiAgICByZXR1cm4gdGFnT3BlbkF0dHJpYnV0ZU5hbWVBZnRlcihjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGFnT3BlbkF0dHJpYnV0ZU5hbWVBZnRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDYxKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0YWdPcGVuQXR0cmlidXRlVmFsdWVCZWZvcmVcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm5TdGF0ZSA9IHRhZ09wZW5BdHRyaWJ1dGVOYW1lQWZ0ZXJcbiAgICAgIHJldHVybiBhdExpbmVFbmRpbmcoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdGFnT3BlbkF0dHJpYnV0ZU5hbWVBZnRlclxuICAgIH1cblxuICAgIHJldHVybiB0YWdPcGVuQmV0d2Vlbihjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGFnT3BlbkF0dHJpYnV0ZVZhbHVlQmVmb3JlKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBudWxsIHx8XG4gICAgICBjb2RlID09PSA2MCB8fFxuICAgICAgY29kZSA9PT0gNjEgfHxcbiAgICAgIGNvZGUgPT09IDYyIHx8XG4gICAgICBjb2RlID09PSA5NlxuICAgICkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAzNCB8fCBjb2RlID09PSAzOSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBtYXJrZXIgPSBjb2RlXG4gICAgICByZXR1cm4gdGFnT3BlbkF0dHJpYnV0ZVZhbHVlUXVvdGVkXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuU3RhdGUgPSB0YWdPcGVuQXR0cmlidXRlVmFsdWVCZWZvcmVcbiAgICAgIHJldHVybiBhdExpbmVFbmRpbmcoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdGFnT3BlbkF0dHJpYnV0ZVZhbHVlQmVmb3JlXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgbWFya2VyID0gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRhZ09wZW5BdHRyaWJ1dGVWYWx1ZVVucXVvdGVkXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB0YWdPcGVuQXR0cmlidXRlVmFsdWVRdW90ZWQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBtYXJrZXIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRhZ09wZW5BdHRyaWJ1dGVWYWx1ZVF1b3RlZEFmdGVyXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm5TdGF0ZSA9IHRhZ09wZW5BdHRyaWJ1dGVWYWx1ZVF1b3RlZFxuICAgICAgcmV0dXJuIGF0TGluZUVuZGluZyhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiB0YWdPcGVuQXR0cmlidXRlVmFsdWVRdW90ZWRcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhZ09wZW5BdHRyaWJ1dGVWYWx1ZVF1b3RlZEFmdGVyKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjIgfHwgY29kZSA9PT0gNDcgfHwgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgcmV0dXJuIHRhZ09wZW5CZXR3ZWVuKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGFnT3BlbkF0dHJpYnV0ZVZhbHVlVW5xdW90ZWQoY29kZSkge1xuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IG51bGwgfHxcbiAgICAgIGNvZGUgPT09IDM0IHx8XG4gICAgICBjb2RlID09PSAzOSB8fFxuICAgICAgY29kZSA9PT0gNjAgfHxcbiAgICAgIGNvZGUgPT09IDYxIHx8XG4gICAgICBjb2RlID09PSA5NlxuICAgICkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA2MiB8fCBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gdGFnT3BlbkJldHdlZW4oY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gdGFnT3BlbkF0dHJpYnV0ZVZhbHVlVW5xdW90ZWRcbiAgfSAvLyBXZSBjYW5cdTIwMTl0IGhhdmUgYmxhbmsgbGluZXMgaW4gY29udGVudCwgc28gbm8gbmVlZCB0byB3b3JyeSBhYm91dCBlbXB0eVxuICAvLyB0b2tlbnMuXG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhdExpbmVFbmRpbmcoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnaHRtbFRleHREYXRhJylcbiAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICBlZmZlY3RzLFxuICAgICAgYWZ0ZXJQcmVmaXgsXG4gICAgICAnbGluZVByZWZpeCcsXG4gICAgICBzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcygnY29kZUluZGVudGVkJylcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiA0XG4gICAgKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJQcmVmaXgoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2h0bWxUZXh0RGF0YScpXG4gICAgcmV0dXJuIHJldHVyblN0YXRlKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBlbmQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2h0bWxUZXh0RGF0YScpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2h0bWxUZXh0JylcbiAgICAgIHJldHVybiBva1xuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICovXG5pbXBvcnQge2ZhY3RvcnlEZXN0aW5hdGlvbn0gZnJvbSAnbWljcm9tYXJrLWZhY3RvcnktZGVzdGluYXRpb24nXG5pbXBvcnQge2ZhY3RvcnlMYWJlbH0gZnJvbSAnbWljcm9tYXJrLWZhY3RvcnktbGFiZWwnXG5pbXBvcnQge2ZhY3RvcnlUaXRsZX0gZnJvbSAnbWljcm9tYXJrLWZhY3RvcnktdGl0bGUnXG5pbXBvcnQge2ZhY3RvcnlXaGl0ZXNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS13aGl0ZXNwYWNlJ1xuaW1wb3J0IHttYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge3B1c2gsIHNwbGljZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2h1bmtlZCdcbmltcG9ydCB7bm9ybWFsaXplSWRlbnRpZmllcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtbm9ybWFsaXplLWlkZW50aWZpZXInXG5pbXBvcnQge3Jlc29sdmVBbGx9IGZyb20gJ21pY3JvbWFyay11dGlsLXJlc29sdmUtYWxsJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBsYWJlbEVuZCA9IHtcbiAgbmFtZTogJ2xhYmVsRW5kJyxcbiAgdG9rZW5pemU6IHRva2VuaXplTGFiZWxFbmQsXG4gIHJlc29sdmVUbzogcmVzb2x2ZVRvTGFiZWxFbmQsXG4gIHJlc29sdmVBbGw6IHJlc29sdmVBbGxMYWJlbEVuZFxufVxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbmNvbnN0IHJlc291cmNlQ29uc3RydWN0ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVSZXNvdXJjZVxufVxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbmNvbnN0IGZ1bGxSZWZlcmVuY2VDb25zdHJ1Y3QgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZUZ1bGxSZWZlcmVuY2Vcbn1cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5jb25zdCBjb2xsYXBzZWRSZWZlcmVuY2VDb25zdHJ1Y3QgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZUNvbGxhcHNlZFJlZmVyZW5jZVxufVxuLyoqIEB0eXBlIHtSZXNvbHZlcn0gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUFsbExhYmVsRW5kKGV2ZW50cykge1xuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge1Rva2VufSAqL1xuXG4gIGxldCB0b2tlblxuXG4gIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgIHRva2VuID0gZXZlbnRzW2luZGV4XVsxXVxuXG4gICAgaWYgKFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2xhYmVsSW1hZ2UnIHx8XG4gICAgICB0b2tlbi50eXBlID09PSAnbGFiZWxMaW5rJyB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2xhYmVsRW5kJ1xuICAgICkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBtYXJrZXIuXG4gICAgICBldmVudHMuc3BsaWNlKGluZGV4ICsgMSwgdG9rZW4udHlwZSA9PT0gJ2xhYmVsSW1hZ2UnID8gNCA6IDIpXG4gICAgICB0b2tlbi50eXBlID0gJ2RhdGEnXG4gICAgICBpbmRleCsrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuLyoqIEB0eXBlIHtSZXNvbHZlcn0gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRvTGFiZWxFbmQoZXZlbnRzLCBjb250ZXh0KSB7XG4gIGxldCBpbmRleCA9IGV2ZW50cy5sZW5ndGhcbiAgbGV0IG9mZnNldCA9IDBcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cblxuICBsZXQgdG9rZW5cbiAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBvcGVuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cblxuICBsZXQgY2xvc2VcbiAgLyoqIEB0eXBlIHtFdmVudFtdfSAqL1xuXG4gIGxldCBtZWRpYSAvLyBGaW5kIGFuIG9wZW5pbmcuXG5cbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB0b2tlbiA9IGV2ZW50c1tpbmRleF1bMV1cblxuICAgIGlmIChvcGVuKSB7XG4gICAgICAvLyBJZiB3ZSBzZWUgYW5vdGhlciBsaW5rLCBvciBpbmFjdGl2ZSBsaW5rIGxhYmVsLCB3ZVx1MjAxOXZlIGJlZW4gaGVyZSBiZWZvcmUuXG4gICAgICBpZiAoXG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdsaW5rJyB8fFxuICAgICAgICAodG9rZW4udHlwZSA9PT0gJ2xhYmVsTGluaycgJiYgdG9rZW4uX2luYWN0aXZlKVxuICAgICAgKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IC8vIE1hcmsgb3RoZXIgbGluayBvcGVuaW5ncyBhcyBpbmFjdGl2ZSwgYXMgd2UgY2FuXHUyMDE5dCBoYXZlIGxpbmtzIGluXG4gICAgICAvLyBsaW5rcy5cblxuICAgICAgaWYgKGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcicgJiYgdG9rZW4udHlwZSA9PT0gJ2xhYmVsTGluaycpIHtcbiAgICAgICAgdG9rZW4uX2luYWN0aXZlID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2xvc2UpIHtcbiAgICAgIGlmIChcbiAgICAgICAgZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJyAmJlxuICAgICAgICAodG9rZW4udHlwZSA9PT0gJ2xhYmVsSW1hZ2UnIHx8IHRva2VuLnR5cGUgPT09ICdsYWJlbExpbmsnKSAmJlxuICAgICAgICAhdG9rZW4uX2JhbGFuY2VkXG4gICAgICApIHtcbiAgICAgICAgb3BlbiA9IGluZGV4XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdsYWJlbExpbmsnKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gMlxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdsYWJlbEVuZCcpIHtcbiAgICAgIGNsb3NlID0gaW5kZXhcbiAgICB9XG4gIH1cblxuICBjb25zdCBncm91cCA9IHtcbiAgICB0eXBlOiBldmVudHNbb3Blbl1bMV0udHlwZSA9PT0gJ2xhYmVsTGluaycgPyAnbGluaycgOiAnaW1hZ2UnLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbb3Blbl1bMV0uc3RhcnQpLFxuICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXVsxXS5lbmQpXG4gIH1cbiAgY29uc3QgbGFiZWwgPSB7XG4gICAgdHlwZTogJ2xhYmVsJyxcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW29wZW5dWzFdLnN0YXJ0KSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tjbG9zZV1bMV0uZW5kKVxuICB9XG4gIGNvbnN0IHRleHQgPSB7XG4gICAgdHlwZTogJ2xhYmVsVGV4dCcsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tvcGVuICsgb2Zmc2V0ICsgMl1bMV0uZW5kKSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tjbG9zZSAtIDJdWzFdLnN0YXJ0KVxuICB9XG4gIG1lZGlhID0gW1xuICAgIFsnZW50ZXInLCBncm91cCwgY29udGV4dF0sXG4gICAgWydlbnRlcicsIGxhYmVsLCBjb250ZXh0XVxuICBdIC8vIE9wZW5pbmcgbWFya2VyLlxuXG4gIG1lZGlhID0gcHVzaChtZWRpYSwgZXZlbnRzLnNsaWNlKG9wZW4gKyAxLCBvcGVuICsgb2Zmc2V0ICsgMykpIC8vIFRleHQgb3Blbi5cblxuICBtZWRpYSA9IHB1c2gobWVkaWEsIFtbJ2VudGVyJywgdGV4dCwgY29udGV4dF1dKSAvLyBCZXR3ZWVuLlxuXG4gIG1lZGlhID0gcHVzaChcbiAgICBtZWRpYSxcbiAgICByZXNvbHZlQWxsKFxuICAgICAgY29udGV4dC5wYXJzZXIuY29uc3RydWN0cy5pbnNpZGVTcGFuLm51bGwsXG4gICAgICBldmVudHMuc2xpY2Uob3BlbiArIG9mZnNldCArIDQsIGNsb3NlIC0gMyksXG4gICAgICBjb250ZXh0XG4gICAgKVxuICApIC8vIFRleHQgY2xvc2UsIG1hcmtlciBjbG9zZSwgbGFiZWwgY2xvc2UuXG5cbiAgbWVkaWEgPSBwdXNoKG1lZGlhLCBbXG4gICAgWydleGl0JywgdGV4dCwgY29udGV4dF0sXG4gICAgZXZlbnRzW2Nsb3NlIC0gMl0sXG4gICAgZXZlbnRzW2Nsb3NlIC0gMV0sXG4gICAgWydleGl0JywgbGFiZWwsIGNvbnRleHRdXG4gIF0pIC8vIFJlZmVyZW5jZSwgcmVzb3VyY2UsIG9yIHNvLlxuXG4gIG1lZGlhID0gcHVzaChtZWRpYSwgZXZlbnRzLnNsaWNlKGNsb3NlICsgMSkpIC8vIE1lZGlhIGNsb3NlLlxuXG4gIG1lZGlhID0gcHVzaChtZWRpYSwgW1snZXhpdCcsIGdyb3VwLCBjb250ZXh0XV0pXG4gIHNwbGljZShldmVudHMsIG9wZW4sIGV2ZW50cy5sZW5ndGgsIG1lZGlhKVxuICByZXR1cm4gZXZlbnRzXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVMYWJlbEVuZChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGxldCBpbmRleCA9IHNlbGYuZXZlbnRzLmxlbmd0aFxuICAvKiogQHR5cGUge1Rva2VufSAqL1xuXG4gIGxldCBsYWJlbFN0YXJ0XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblxuICBsZXQgZGVmaW5lZCAvLyBGaW5kIGFuIG9wZW5pbmcuXG5cbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICBpZiAoXG4gICAgICAoc2VsZi5ldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdsYWJlbEltYWdlJyB8fFxuICAgICAgICBzZWxmLmV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ2xhYmVsTGluaycpICYmXG4gICAgICAhc2VsZi5ldmVudHNbaW5kZXhdWzFdLl9iYWxhbmNlZFxuICAgICkge1xuICAgICAgbGFiZWxTdGFydCA9IHNlbGYuZXZlbnRzW2luZGV4XVsxXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKCFsYWJlbFN0YXJ0KSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfSAvLyBJdFx1MjAxOXMgYSBiYWxhbmNlZCBicmFja2V0LCBidXQgY29udGFpbnMgYSBsaW5rLlxuXG4gICAgaWYgKGxhYmVsU3RhcnQuX2luYWN0aXZlKSByZXR1cm4gYmFsYW5jZWQoY29kZSlcbiAgICBkZWZpbmVkID0gc2VsZi5wYXJzZXIuZGVmaW5lZC5pbmNsdWRlcyhcbiAgICAgIG5vcm1hbGl6ZUlkZW50aWZpZXIoXG4gICAgICAgIHNlbGYuc2xpY2VTZXJpYWxpemUoe1xuICAgICAgICAgIHN0YXJ0OiBsYWJlbFN0YXJ0LmVuZCxcbiAgICAgICAgICBlbmQ6IHNlbGYubm93KClcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApXG4gICAgZWZmZWN0cy5lbnRlcignbGFiZWxFbmQnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2xhYmVsTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xhYmVsTWFya2VyJylcbiAgICBlZmZlY3RzLmV4aXQoJ2xhYmVsRW5kJylcbiAgICByZXR1cm4gYWZ0ZXJMYWJlbEVuZFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJMYWJlbEVuZChjb2RlKSB7XG4gICAgLy8gUmVzb3VyY2U6IGBbYXNkXShmZ2gpYC5cbiAgICBpZiAoY29kZSA9PT0gNDApIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgIHJlc291cmNlQ29uc3RydWN0LFxuICAgICAgICBvayxcbiAgICAgICAgZGVmaW5lZCA/IG9rIDogYmFsYW5jZWRcbiAgICAgICkoY29kZSlcbiAgICB9IC8vIENvbGxhcHNlZCAoYFthc2RdW11gKSBvciBmdWxsIChgW2FzZF1bZmdoXWApIHJlZmVyZW5jZT9cblxuICAgIGlmIChjb2RlID09PSA5MSkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuYXR0ZW1wdChcbiAgICAgICAgZnVsbFJlZmVyZW5jZUNvbnN0cnVjdCxcbiAgICAgICAgb2ssXG4gICAgICAgIGRlZmluZWRcbiAgICAgICAgICA/IGVmZmVjdHMuYXR0ZW1wdChjb2xsYXBzZWRSZWZlcmVuY2VDb25zdHJ1Y3QsIG9rLCBiYWxhbmNlZClcbiAgICAgICAgICA6IGJhbGFuY2VkXG4gICAgICApKGNvZGUpXG4gICAgfSAvLyBTaG9ydGN1dCByZWZlcmVuY2U6IGBbYXNkXWA/XG5cbiAgICByZXR1cm4gZGVmaW5lZCA/IG9rKGNvZGUpIDogYmFsYW5jZWQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGJhbGFuY2VkKGNvZGUpIHtcbiAgICBsYWJlbFN0YXJ0Ll9iYWxhbmNlZCA9IHRydWVcbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZVJlc291cmNlKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ3Jlc291cmNlJylcbiAgICBlZmZlY3RzLmVudGVyKCdyZXNvdXJjZU1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdyZXNvdXJjZU1hcmtlcicpXG4gICAgcmV0dXJuIGZhY3RvcnlXaGl0ZXNwYWNlKGVmZmVjdHMsIG9wZW4pXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvcGVuKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDEpIHtcbiAgICAgIHJldHVybiBlbmQoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gZmFjdG9yeURlc3RpbmF0aW9uKFxuICAgICAgZWZmZWN0cyxcbiAgICAgIGRlc3RpbmF0aW9uQWZ0ZXIsXG4gICAgICBub2ssXG4gICAgICAncmVzb3VyY2VEZXN0aW5hdGlvbicsXG4gICAgICAncmVzb3VyY2VEZXN0aW5hdGlvbkxpdGVyYWwnLFxuICAgICAgJ3Jlc291cmNlRGVzdGluYXRpb25MaXRlcmFsTWFya2VyJyxcbiAgICAgICdyZXNvdXJjZURlc3RpbmF0aW9uUmF3JyxcbiAgICAgICdyZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nJyxcbiAgICAgIDMyXG4gICAgKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGVzdGluYXRpb25BZnRlcihjb2RlKSB7XG4gICAgcmV0dXJuIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSlcbiAgICAgID8gZmFjdG9yeVdoaXRlc3BhY2UoZWZmZWN0cywgYmV0d2VlbikoY29kZSlcbiAgICAgIDogZW5kKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBiZXR3ZWVuKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gMzQgfHwgY29kZSA9PT0gMzkgfHwgY29kZSA9PT0gNDApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5VGl0bGUoXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGZhY3RvcnlXaGl0ZXNwYWNlKGVmZmVjdHMsIGVuZCksXG4gICAgICAgIG5vayxcbiAgICAgICAgJ3Jlc291cmNlVGl0bGUnLFxuICAgICAgICAncmVzb3VyY2VUaXRsZU1hcmtlcicsXG4gICAgICAgICdyZXNvdXJjZVRpdGxlU3RyaW5nJ1xuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBlbmQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGVuZChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQxKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdyZXNvdXJjZU1hcmtlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgncmVzb3VyY2VNYXJrZXInKVxuICAgICAgZWZmZWN0cy5leGl0KCdyZXNvdXJjZScpXG4gICAgICByZXR1cm4gb2tcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUZ1bGxSZWZlcmVuY2UoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgcmV0dXJuIGZhY3RvcnlMYWJlbC5jYWxsKFxuICAgICAgc2VsZixcbiAgICAgIGVmZmVjdHMsXG4gICAgICBhZnRlckxhYmVsLFxuICAgICAgbm9rLFxuICAgICAgJ3JlZmVyZW5jZScsXG4gICAgICAncmVmZXJlbmNlTWFya2VyJyxcbiAgICAgICdyZWZlcmVuY2VTdHJpbmcnXG4gICAgKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJMYWJlbChjb2RlKSB7XG4gICAgcmV0dXJuIHNlbGYucGFyc2VyLmRlZmluZWQuaW5jbHVkZXMoXG4gICAgICBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgICBzZWxmLnNsaWNlU2VyaWFsaXplKHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdWzFdKS5zbGljZSgxLCAtMSlcbiAgICAgIClcbiAgICApXG4gICAgICA/IG9rKGNvZGUpXG4gICAgICA6IG5vayhjb2RlKVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVDb2xsYXBzZWRSZWZlcmVuY2UoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcigncmVmZXJlbmNlJylcbiAgICBlZmZlY3RzLmVudGVyKCdyZWZlcmVuY2VNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgncmVmZXJlbmNlTWFya2VyJylcbiAgICByZXR1cm4gb3BlblxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDkzKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdyZWZlcmVuY2VNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3JlZmVyZW5jZU1hcmtlcicpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3JlZmVyZW5jZScpXG4gICAgICByZXR1cm4gb2tcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7bGFiZWxFbmR9IGZyb20gJy4vbGFiZWwtZW5kLmpzJ1xuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbmV4cG9ydCBjb25zdCBsYWJlbFN0YXJ0SW1hZ2UgPSB7XG4gIG5hbWU6ICdsYWJlbFN0YXJ0SW1hZ2UnLFxuICB0b2tlbml6ZTogdG9rZW5pemVMYWJlbFN0YXJ0SW1hZ2UsXG4gIHJlc29sdmVBbGw6IGxhYmVsRW5kLnJlc29sdmVBbGxcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUxhYmVsU3RhcnRJbWFnZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdsYWJlbEltYWdlJylcbiAgICBlZmZlY3RzLmVudGVyKCdsYWJlbEltYWdlTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xhYmVsSW1hZ2VNYXJrZXInKVxuICAgIHJldHVybiBvcGVuXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvcGVuKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gOTEpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2xhYmVsTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdsYWJlbE1hcmtlcicpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xhYmVsSW1hZ2UnKVxuICAgICAgcmV0dXJuIGFmdGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgIC8qIFRvIGRvOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSBvbmNlIHdlXHUyMDE5dmUgc3dpdGNoZWQgZnJvbVxuICAgICAqIGBtaWNyb21hcmstZXh0ZW5zaW9uLWZvb3Rub3RlYCB0byBgbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tZm9vdG5vdGVgLFxuICAgICAqIHdoaWNoIGRvZXNuXHUyMDE5dCBuZWVkIHRoaXMgKi9cblxuICAgIC8qIEhpZGRlbiBmb290bm90ZXMgaG9vayAqL1xuXG4gICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgIHJldHVybiBjb2RlID09PSA5NCAmJiAnX2hpZGRlbkZvb3Rub3RlU3VwcG9ydCcgaW4gc2VsZi5wYXJzZXIuY29uc3RydWN0c1xuICAgICAgPyBub2soY29kZSlcbiAgICAgIDogb2soY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHtsYWJlbEVuZH0gZnJvbSAnLi9sYWJlbC1lbmQuanMnXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cblxuZXhwb3J0IGNvbnN0IGxhYmVsU3RhcnRMaW5rID0ge1xuICBuYW1lOiAnbGFiZWxTdGFydExpbmsnLFxuICB0b2tlbml6ZTogdG9rZW5pemVMYWJlbFN0YXJ0TGluayxcbiAgcmVzb2x2ZUFsbDogbGFiZWxFbmQucmVzb2x2ZUFsbFxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplTGFiZWxTdGFydExpbmsoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignbGFiZWxMaW5rJylcbiAgICBlZmZlY3RzLmVudGVyKCdsYWJlbE1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdsYWJlbE1hcmtlcicpXG4gICAgZWZmZWN0cy5leGl0KCdsYWJlbExpbmsnKVxuICAgIHJldHVybiBhZnRlclxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgIC8qIFRvIGRvOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSBvbmNlIHdlXHUyMDE5dmUgc3dpdGNoZWQgZnJvbVxuICAgICAqIGBtaWNyb21hcmstZXh0ZW5zaW9uLWZvb3Rub3RlYCB0byBgbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tZm9vdG5vdGVgLFxuICAgICAqIHdoaWNoIGRvZXNuXHUyMDE5dCBuZWVkIHRoaXMgKi9cblxuICAgIC8qIEhpZGRlbiBmb290bm90ZXMgaG9vay4gKi9cblxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICByZXR1cm4gY29kZSA9PT0gOTQgJiYgJ19oaWRkZW5Gb290bm90ZVN1cHBvcnQnIGluIHNlbGYucGFyc2VyLmNvbnN0cnVjdHNcbiAgICAgID8gbm9rKGNvZGUpXG4gICAgICA6IG9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IGxpbmVFbmRpbmcgPSB7XG4gIG5hbWU6ICdsaW5lRW5kaW5nJyxcbiAgdG9rZW5pemU6IHRva2VuaXplTGluZUVuZGluZ1xufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplTGluZUVuZGluZyhlZmZlY3RzLCBvaykge1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignbGluZUVuZGluZycpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdsaW5lRW5kaW5nJylcbiAgICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIG9rLCAnbGluZVByZWZpeCcpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvZGV9IENvZGVcbiAqL1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHttYXJrZG93bkxpbmVFbmRpbmcsIG1hcmtkb3duU3BhY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5leHBvcnQgY29uc3QgdGhlbWF0aWNCcmVhayA9IHtcbiAgbmFtZTogJ3RoZW1hdGljQnJlYWsnLFxuICB0b2tlbml6ZTogdG9rZW5pemVUaGVtYXRpY0JyZWFrXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVUaGVtYXRpY0JyZWFrKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgbGV0IHNpemUgPSAwXG4gIC8qKiBAdHlwZSB7Tm9uTnVsbGFibGU8Q29kZT59ICovXG5cbiAgbGV0IG1hcmtlclxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcigndGhlbWF0aWNCcmVhaycpXG4gICAgbWFya2VyID0gY29kZVxuICAgIHJldHVybiBhdEJyZWFrKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhdEJyZWFrKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0aGVtYXRpY0JyZWFrU2VxdWVuY2UnKVxuICAgICAgcmV0dXJuIHNlcXVlbmNlKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYXRCcmVhaywgJ3doaXRlc3BhY2UnKShjb2RlKVxuICAgIH1cblxuICAgIGlmIChzaXplIDwgMyB8fCAoY29kZSAhPT0gbnVsbCAmJiAhbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgndGhlbWF0aWNCcmVhaycpXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzZXF1ZW5jZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBzaXplKytcbiAgICAgIHJldHVybiBzZXF1ZW5jZVxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgndGhlbWF0aWNCcmVha1NlcXVlbmNlJylcbiAgICByZXR1cm4gYXRCcmVhayhjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplQ29udGV4dH0gVG9rZW5pemVDb250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4aXRlcn0gRXhpdGVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgdW5rbm93bj4gJiB7bWFya2VyOiBDb2RlLCB0eXBlOiBzdHJpbmcsIHNpemU6IG51bWJlcn19IExpc3RDb250YWluZXJTdGF0ZVxuICogQHR5cGVkZWYge1Rva2VuaXplQ29udGV4dCAmIHtjb250YWluZXJTdGF0ZTogTGlzdENvbnRhaW5lclN0YXRlfX0gVG9rZW5pemVDb250ZXh0V2l0aFN0YXRlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7YXNjaWlEaWdpdCwgbWFya2Rvd25TcGFjZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuaW1wb3J0IHtibGFua0xpbmV9IGZyb20gJy4vYmxhbmstbGluZS5qcydcbmltcG9ydCB7dGhlbWF0aWNCcmVha30gZnJvbSAnLi90aGVtYXRpYy1icmVhay5qcydcbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5leHBvcnQgY29uc3QgbGlzdCA9IHtcbiAgbmFtZTogJ2xpc3QnLFxuICB0b2tlbml6ZTogdG9rZW5pemVMaXN0U3RhcnQsXG4gIGNvbnRpbnVhdGlvbjoge1xuICAgIHRva2VuaXplOiB0b2tlbml6ZUxpc3RDb250aW51YXRpb25cbiAgfSxcbiAgZXhpdDogdG9rZW5pemVMaXN0RW5kXG59XG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cblxuY29uc3QgbGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlQ29uc3RydWN0ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVMaXN0SXRlbVByZWZpeFdoaXRlc3BhY2UsXG4gIHBhcnRpYWw6IHRydWVcbn1cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5jb25zdCBpbmRlbnRDb25zdHJ1Y3QgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZUluZGVudCxcbiAgcGFydGlhbDogdHJ1ZVxufVxuLyoqXG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dFdpdGhTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUxpc3RTdGFydChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGNvbnN0IHRhaWwgPSBzZWxmLmV2ZW50c1tzZWxmLmV2ZW50cy5sZW5ndGggLSAxXVxuICBsZXQgaW5pdGlhbFNpemUgPVxuICAgIHRhaWwgJiYgdGFpbFsxXS50eXBlID09PSAnbGluZVByZWZpeCdcbiAgICAgID8gdGFpbFsyXS5zbGljZVNlcmlhbGl6ZSh0YWlsWzFdLCB0cnVlKS5sZW5ndGhcbiAgICAgIDogMFxuICBsZXQgc2l6ZSA9IDBcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGNvbnN0IGtpbmQgPVxuICAgICAgc2VsZi5jb250YWluZXJTdGF0ZS50eXBlIHx8XG4gICAgICAoY29kZSA9PT0gNDIgfHwgY29kZSA9PT0gNDMgfHwgY29kZSA9PT0gNDVcbiAgICAgICAgPyAnbGlzdFVub3JkZXJlZCdcbiAgICAgICAgOiAnbGlzdE9yZGVyZWQnKVxuXG4gICAgaWYgKFxuICAgICAga2luZCA9PT0gJ2xpc3RVbm9yZGVyZWQnXG4gICAgICAgID8gIXNlbGYuY29udGFpbmVyU3RhdGUubWFya2VyIHx8IGNvZGUgPT09IHNlbGYuY29udGFpbmVyU3RhdGUubWFya2VyXG4gICAgICAgIDogYXNjaWlEaWdpdChjb2RlKVxuICAgICkge1xuICAgICAgaWYgKCFzZWxmLmNvbnRhaW5lclN0YXRlLnR5cGUpIHtcbiAgICAgICAgc2VsZi5jb250YWluZXJTdGF0ZS50eXBlID0ga2luZFxuICAgICAgICBlZmZlY3RzLmVudGVyKGtpbmQsIHtcbiAgICAgICAgICBfY29udGFpbmVyOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmIChraW5kID09PSAnbGlzdFVub3JkZXJlZCcpIHtcbiAgICAgICAgZWZmZWN0cy5lbnRlcignbGlzdEl0ZW1QcmVmaXgnKVxuICAgICAgICByZXR1cm4gY29kZSA9PT0gNDIgfHwgY29kZSA9PT0gNDVcbiAgICAgICAgICA/IGVmZmVjdHMuY2hlY2sodGhlbWF0aWNCcmVhaywgbm9rLCBhdE1hcmtlcikoY29kZSlcbiAgICAgICAgICA6IGF0TWFya2VyKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5pbnRlcnJ1cHQgfHwgY29kZSA9PT0gNDkpIHtcbiAgICAgICAgZWZmZWN0cy5lbnRlcignbGlzdEl0ZW1QcmVmaXgnKVxuICAgICAgICBlZmZlY3RzLmVudGVyKCdsaXN0SXRlbVZhbHVlJylcbiAgICAgICAgcmV0dXJuIGluc2lkZShjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGluc2lkZShjb2RlKSB7XG4gICAgaWYgKGFzY2lpRGlnaXQoY29kZSkgJiYgKytzaXplIDwgMTApIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluc2lkZVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgICghc2VsZi5pbnRlcnJ1cHQgfHwgc2l6ZSA8IDIpICYmXG4gICAgICAoc2VsZi5jb250YWluZXJTdGF0ZS5tYXJrZXJcbiAgICAgICAgPyBjb2RlID09PSBzZWxmLmNvbnRhaW5lclN0YXRlLm1hcmtlclxuICAgICAgICA6IGNvZGUgPT09IDQxIHx8IGNvZGUgPT09IDQ2KVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KCdsaXN0SXRlbVZhbHVlJylcbiAgICAgIHJldHVybiBhdE1hcmtlcihjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKipcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKiovXG5cbiAgZnVuY3Rpb24gYXRNYXJrZXIoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2xpc3RJdGVtTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xpc3RJdGVtTWFya2VyJylcbiAgICBzZWxmLmNvbnRhaW5lclN0YXRlLm1hcmtlciA9IHNlbGYuY29udGFpbmVyU3RhdGUubWFya2VyIHx8IGNvZGVcbiAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgIGJsYW5rTGluZSwgLy8gQ2FuXHUyMDE5dCBiZSBlbXB0eSB3aGVuIGludGVycnVwdGluZy5cbiAgICAgIHNlbGYuaW50ZXJydXB0ID8gbm9rIDogb25CbGFuayxcbiAgICAgIGVmZmVjdHMuYXR0ZW1wdChcbiAgICAgICAgbGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlQ29uc3RydWN0LFxuICAgICAgICBlbmRPZlByZWZpeCxcbiAgICAgICAgb3RoZXJQcmVmaXhcbiAgICAgIClcbiAgICApXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvbkJsYW5rKGNvZGUpIHtcbiAgICBzZWxmLmNvbnRhaW5lclN0YXRlLmluaXRpYWxCbGFua0xpbmUgPSB0cnVlXG4gICAgaW5pdGlhbFNpemUrK1xuICAgIHJldHVybiBlbmRPZlByZWZpeChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb3RoZXJQcmVmaXgoY29kZSkge1xuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdsaXN0SXRlbVByZWZpeFdoaXRlc3BhY2UnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpc3RJdGVtUHJlZml4V2hpdGVzcGFjZScpXG4gICAgICByZXR1cm4gZW5kT2ZQcmVmaXhcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBlbmRPZlByZWZpeChjb2RlKSB7XG4gICAgc2VsZi5jb250YWluZXJTdGF0ZS5zaXplID1cbiAgICAgIGluaXRpYWxTaXplICtcbiAgICAgIHNlbGYuc2xpY2VTZXJpYWxpemUoZWZmZWN0cy5leGl0KCdsaXN0SXRlbVByZWZpeCcpLCB0cnVlKS5sZW5ndGhcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxufVxuLyoqXG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dFdpdGhTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUxpc3RDb250aW51YXRpb24oZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBzZWxmLmNvbnRhaW5lclN0YXRlLl9jbG9zZUZsb3cgPSB1bmRlZmluZWRcbiAgcmV0dXJuIGVmZmVjdHMuY2hlY2soYmxhbmtMaW5lLCBvbkJsYW5rLCBub3RCbGFuaylcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvbkJsYW5rKGNvZGUpIHtcbiAgICBzZWxmLmNvbnRhaW5lclN0YXRlLmZ1cnRoZXJCbGFua0xpbmVzID1cbiAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUuZnVydGhlckJsYW5rTGluZXMgfHxcbiAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUuaW5pdGlhbEJsYW5rTGluZSAvLyBXZSBoYXZlIGEgYmxhbmsgbGluZS5cbiAgICAvLyBTdGlsbCwgdHJ5IHRvIGNvbnN1bWUgYXQgbW9zdCB0aGUgaXRlbXMgc2l6ZS5cblxuICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICBlZmZlY3RzLFxuICAgICAgb2ssXG4gICAgICAnbGlzdEl0ZW1JbmRlbnQnLFxuICAgICAgc2VsZi5jb250YWluZXJTdGF0ZS5zaXplICsgMVxuICAgICkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIG5vdEJsYW5rKGNvZGUpIHtcbiAgICBpZiAoc2VsZi5jb250YWluZXJTdGF0ZS5mdXJ0aGVyQmxhbmtMaW5lcyB8fCAhbWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgc2VsZi5jb250YWluZXJTdGF0ZS5mdXJ0aGVyQmxhbmtMaW5lcyA9IHVuZGVmaW5lZFxuICAgICAgc2VsZi5jb250YWluZXJTdGF0ZS5pbml0aWFsQmxhbmtMaW5lID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm4gbm90SW5DdXJyZW50SXRlbShjb2RlKVxuICAgIH1cblxuICAgIHNlbGYuY29udGFpbmVyU3RhdGUuZnVydGhlckJsYW5rTGluZXMgPSB1bmRlZmluZWRcbiAgICBzZWxmLmNvbnRhaW5lclN0YXRlLmluaXRpYWxCbGFua0xpbmUgPSB1bmRlZmluZWRcbiAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KGluZGVudENvbnN0cnVjdCwgb2ssIG5vdEluQ3VycmVudEl0ZW0pKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBub3RJbkN1cnJlbnRJdGVtKGNvZGUpIHtcbiAgICAvLyBXaGlsZSB3ZSBkbyBjb250aW51ZSwgd2Ugc2lnbmFsIHRoYXQgdGhlIGZsb3cgc2hvdWxkIGJlIGNsb3NlZC5cbiAgICBzZWxmLmNvbnRhaW5lclN0YXRlLl9jbG9zZUZsb3cgPSB0cnVlIC8vIEFzIHdlXHUyMDE5cmUgY2xvc2luZyBmbG93LCB3ZVx1MjAxOXJlIG5vIGxvbmdlciBpbnRlcnJ1cHRpbmcuXG5cbiAgICBzZWxmLmludGVycnVwdCA9IHVuZGVmaW5lZFxuICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICBlZmZlY3RzLFxuICAgICAgZWZmZWN0cy5hdHRlbXB0KGxpc3QsIG9rLCBub2spLFxuICAgICAgJ2xpbmVQcmVmaXgnLFxuICAgICAgc2VsZi5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoJ2NvZGVJbmRlbnRlZCcpXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogNFxuICAgICkoY29kZSlcbiAgfVxufVxuLyoqXG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dFdpdGhTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUluZGVudChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgZWZmZWN0cyxcbiAgICBhZnRlclByZWZpeCxcbiAgICAnbGlzdEl0ZW1JbmRlbnQnLFxuICAgIHNlbGYuY29udGFpbmVyU3RhdGUuc2l6ZSArIDFcbiAgKVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyUHJlZml4KGNvZGUpIHtcbiAgICBjb25zdCB0YWlsID0gc2VsZi5ldmVudHNbc2VsZi5ldmVudHMubGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gdGFpbCAmJlxuICAgICAgdGFpbFsxXS50eXBlID09PSAnbGlzdEl0ZW1JbmRlbnQnICYmXG4gICAgICB0YWlsWzJdLnNsaWNlU2VyaWFsaXplKHRhaWxbMV0sIHRydWUpLmxlbmd0aCA9PT0gc2VsZi5jb250YWluZXJTdGF0ZS5zaXplXG4gICAgICA/IG9rKGNvZGUpXG4gICAgICA6IG5vayhjb2RlKVxuICB9XG59XG4vKipcbiAqIEB0eXBlIHtFeGl0ZXJ9XG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0V2l0aFN0YXRlfVxuICovXG5cbmZ1bmN0aW9uIHRva2VuaXplTGlzdEVuZChlZmZlY3RzKSB7XG4gIGVmZmVjdHMuZXhpdCh0aGlzLmNvbnRhaW5lclN0YXRlLnR5cGUpXG59XG4vKipcbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0V2l0aFN0YXRlfVxuICovXG5cbmZ1bmN0aW9uIHRva2VuaXplTGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIGZhY3RvcnlTcGFjZShcbiAgICBlZmZlY3RzLFxuICAgIGFmdGVyUHJlZml4LFxuICAgICdsaXN0SXRlbVByZWZpeFdoaXRlc3BhY2UnLFxuICAgIHNlbGYucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKCdjb2RlSW5kZW50ZWQnKVxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogNCArIDFcbiAgKVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyUHJlZml4KGNvZGUpIHtcbiAgICBjb25zdCB0YWlsID0gc2VsZi5ldmVudHNbc2VsZi5ldmVudHMubGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gIW1hcmtkb3duU3BhY2UoY29kZSkgJiZcbiAgICAgIHRhaWwgJiZcbiAgICAgIHRhaWxbMV0udHlwZSA9PT0gJ2xpc3RJdGVtUHJlZml4V2hpdGVzcGFjZSdcbiAgICAgID8gb2soY29kZSlcbiAgICAgIDogbm9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUmVzb2x2ZXJ9IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IHNldGV4dFVuZGVybGluZSA9IHtcbiAgbmFtZTogJ3NldGV4dFVuZGVybGluZScsXG4gIHRva2VuaXplOiB0b2tlbml6ZVNldGV4dFVuZGVybGluZSxcbiAgcmVzb2x2ZVRvOiByZXNvbHZlVG9TZXRleHRVbmRlcmxpbmVcbn1cbi8qKiBAdHlwZSB7UmVzb2x2ZXJ9ICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUb1NldGV4dFVuZGVybGluZShldmVudHMsIGNvbnRleHQpIHtcbiAgbGV0IGluZGV4ID0gZXZlbnRzLmxlbmd0aFxuICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGNvbnRlbnRcbiAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuXG4gIGxldCB0ZXh0XG4gIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cblxuICBsZXQgZGVmaW5pdGlvbiAvLyBGaW5kIHRoZSBvcGVuaW5nIG9mIHRoZSBjb250ZW50LlxuICAvLyBJdFx1MjAxOWxsIGFsd2F5cyBleGlzdDogd2UgZG9uXHUyMDE5dCB0b2tlbml6ZSBpZiBpdCBpc25cdTIwMTl0IHRoZXJlLlxuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgaWYgKGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcicpIHtcbiAgICAgIGlmIChldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdjb250ZW50Jykge1xuICAgICAgICBjb250ZW50ID0gaW5kZXhcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgdGV4dCA9IGluZGV4XG4gICAgICB9XG4gICAgfSAvLyBFeGl0XG4gICAgZWxzZSB7XG4gICAgICBpZiAoZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnY29udGVudCcpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjb250ZW50IGVuZCAoaWYgbmVlZGVkIHdlXHUyMDE5bGwgYWRkIGl0IGxhdGVyKVxuICAgICAgICBldmVudHMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRlZmluaXRpb24gJiYgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnZGVmaW5pdGlvbicpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGluZGV4XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgaGVhZGluZyA9IHtcbiAgICB0eXBlOiAnc2V0ZXh0SGVhZGluZycsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1t0ZXh0XVsxXS5zdGFydCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdWzFdLmVuZClcbiAgfSAvLyBDaGFuZ2UgdGhlIHBhcmFncmFwaCB0byBzZXRleHQgaGVhZGluZyB0ZXh0LlxuXG4gIGV2ZW50c1t0ZXh0XVsxXS50eXBlID0gJ3NldGV4dEhlYWRpbmdUZXh0JyAvLyBJZiB3ZSBoYXZlIGRlZmluaXRpb25zIGluIHRoZSBjb250ZW50LCB3ZVx1MjAxOWxsIGtlZXAgb24gaGF2aW5nIGNvbnRlbnQsXG4gIC8vIGJ1dCB3ZSBuZWVkIG1vdmUgaXQuXG5cbiAgaWYgKGRlZmluaXRpb24pIHtcbiAgICBldmVudHMuc3BsaWNlKHRleHQsIDAsIFsnZW50ZXInLCBoZWFkaW5nLCBjb250ZXh0XSlcbiAgICBldmVudHMuc3BsaWNlKGRlZmluaXRpb24gKyAxLCAwLCBbJ2V4aXQnLCBldmVudHNbY29udGVudF1bMV0sIGNvbnRleHRdKVxuICAgIGV2ZW50c1tjb250ZW50XVsxXS5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbZGVmaW5pdGlvbl1bMV0uZW5kKVxuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tjb250ZW50XVsxXSA9IGhlYWRpbmdcbiAgfSAvLyBBZGQgdGhlIGhlYWRpbmcgZXhpdCBhdCB0aGUgZW5kLlxuXG4gIGV2ZW50cy5wdXNoKFsnZXhpdCcsIGhlYWRpbmcsIGNvbnRleHRdKVxuICByZXR1cm4gZXZlbnRzXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVTZXRleHRVbmRlcmxpbmUoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgaW5kZXggPSBzZWxmLmV2ZW50cy5sZW5ndGhcbiAgLyoqIEB0eXBlIHtOb25OdWxsYWJsZTxDb2RlPn0gKi9cblxuICBsZXQgbWFya2VyXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblxuICBsZXQgcGFyYWdyYXBoIC8vIEZpbmQgYW4gb3BlbmluZy5cblxuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIC8vIFNraXAgZW50ZXIvZXhpdCBvZiBsaW5lIGVuZGluZywgbGluZSBwcmVmaXgsIGFuZCBjb250ZW50LlxuICAgIC8vIFdlIGNhbiBub3cgZWl0aGVyIGhhdmUgYSBkZWZpbml0aW9uIG9yIGEgcGFyYWdyYXBoLlxuICAgIGlmIChcbiAgICAgIHNlbGYuZXZlbnRzW2luZGV4XVsxXS50eXBlICE9PSAnbGluZUVuZGluZycgJiZcbiAgICAgIHNlbGYuZXZlbnRzW2luZGV4XVsxXS50eXBlICE9PSAnbGluZVByZWZpeCcgJiZcbiAgICAgIHNlbGYuZXZlbnRzW2luZGV4XVsxXS50eXBlICE9PSAnY29udGVudCdcbiAgICApIHtcbiAgICAgIHBhcmFncmFwaCA9IHNlbGYuZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAncGFyYWdyYXBoJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKCFzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0gJiYgKHNlbGYuaW50ZXJydXB0IHx8IHBhcmFncmFwaCkpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3NldGV4dEhlYWRpbmdMaW5lJylcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3NldGV4dEhlYWRpbmdMaW5lU2VxdWVuY2UnKVxuICAgICAgbWFya2VyID0gY29kZVxuICAgICAgcmV0dXJuIGNsb3NpbmdTZXF1ZW5jZShjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNsb3NpbmdTZXF1ZW5jZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY2xvc2luZ1NlcXVlbmNlXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCdzZXRleHRIZWFkaW5nTGluZVNlcXVlbmNlJylcbiAgICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGNsb3NpbmdTZXF1ZW5jZUVuZCwgJ2xpbmVTdWZmaXgnKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY2xvc2luZ1NlcXVlbmNlRW5kKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnc2V0ZXh0SGVhZGluZ0xpbmUnKVxuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkluaXRpYWxDb25zdHJ1Y3R9IEluaXRpYWxDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSW5pdGlhbGl6ZXJ9IEluaXRpYWxpemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge2JsYW5rTGluZSwgY29udGVudH0gZnJvbSAnbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyaydcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKiBAdHlwZSB7SW5pdGlhbENvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBmbG93ID0ge1xuICB0b2tlbml6ZTogaW5pdGlhbGl6ZUZsb3dcbn1cbi8qKiBAdHlwZSB7SW5pdGlhbGl6ZXJ9ICovXG5cbmZ1bmN0aW9uIGluaXRpYWxpemVGbG93KGVmZmVjdHMpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgaW5pdGlhbCA9IGVmZmVjdHMuYXR0ZW1wdChcbiAgICAvLyBUcnkgdG8gcGFyc2UgYSBibGFuayBsaW5lLlxuICAgIGJsYW5rTGluZSxcbiAgICBhdEJsYW5rRW5kaW5nLCAvLyBUcnkgdG8gcGFyc2UgaW5pdGlhbCBmbG93IChlc3NlbnRpYWxseSwgb25seSBjb2RlKS5cbiAgICBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmZsb3dJbml0aWFsLFxuICAgICAgYWZ0ZXJDb25zdHJ1Y3QsXG4gICAgICBmYWN0b3J5U3BhY2UoXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGVmZmVjdHMuYXR0ZW1wdChcbiAgICAgICAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmZsb3csXG4gICAgICAgICAgYWZ0ZXJDb25zdHJ1Y3QsXG4gICAgICAgICAgZWZmZWN0cy5hdHRlbXB0KGNvbnRlbnQsIGFmdGVyQ29uc3RydWN0KVxuICAgICAgICApLFxuICAgICAgICAnbGluZVByZWZpeCdcbiAgICAgIClcbiAgICApXG4gIClcbiAgcmV0dXJuIGluaXRpYWxcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhdEJsYW5rRW5kaW5nKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nQmxhbmsnKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZ0JsYW5rJylcbiAgICBzZWxmLmN1cnJlbnRDb25zdHJ1Y3QgPSB1bmRlZmluZWRcbiAgICByZXR1cm4gaW5pdGlhbFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJDb25zdHJ1Y3QoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG4gICAgc2VsZi5jdXJyZW50Q29uc3RydWN0ID0gdW5kZWZpbmVkXG4gICAgcmV0dXJuIGluaXRpYWxcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSW5pdGlhbGl6ZXJ9IEluaXRpYWxpemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkluaXRpYWxDb25zdHJ1Y3R9IEluaXRpYWxDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvZGV9IENvZGVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVyID0ge1xuICByZXNvbHZlQWxsOiBjcmVhdGVSZXNvbHZlcigpXG59XG5leHBvcnQgY29uc3Qgc3RyaW5nID0gaW5pdGlhbGl6ZUZhY3RvcnkoJ3N0cmluZycpXG5leHBvcnQgY29uc3QgdGV4dCA9IGluaXRpYWxpemVGYWN0b3J5KCd0ZXh0Jylcbi8qKlxuICogQHBhcmFtIHsnc3RyaW5nJ3wndGV4dCd9IGZpZWxkXG4gKiBAcmV0dXJucyB7SW5pdGlhbENvbnN0cnVjdH1cbiAqL1xuXG5mdW5jdGlvbiBpbml0aWFsaXplRmFjdG9yeShmaWVsZCkge1xuICByZXR1cm4ge1xuICAgIHRva2VuaXplOiBpbml0aWFsaXplVGV4dCxcbiAgICByZXNvbHZlQWxsOiBjcmVhdGVSZXNvbHZlcihcbiAgICAgIGZpZWxkID09PSAndGV4dCcgPyByZXNvbHZlQWxsTGluZVN1ZmZpeGVzIDogdW5kZWZpbmVkXG4gICAgKVxuICB9XG4gIC8qKiBAdHlwZSB7SW5pdGlhbGl6ZXJ9ICovXG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZVRleHQoZWZmZWN0cykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgY29uc3QgY29uc3RydWN0cyA9IHRoaXMucGFyc2VyLmNvbnN0cnVjdHNbZmllbGRdXG4gICAgY29uc3QgdGV4dCA9IGVmZmVjdHMuYXR0ZW1wdChjb25zdHJ1Y3RzLCBzdGFydCwgbm90VGV4dClcbiAgICByZXR1cm4gc3RhcnRcbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgcmV0dXJuIGF0QnJlYWsoY29kZSkgPyB0ZXh0KGNvZGUpIDogbm90VGV4dChjb2RlKVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gbm90VGV4dChjb2RlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2RhdGEnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gZGF0YShjb2RlKSB7XG4gICAgICBpZiAoYXRCcmVhayhjb2RlKSkge1xuICAgICAgICBlZmZlY3RzLmV4aXQoJ2RhdGEnKVxuICAgICAgICByZXR1cm4gdGV4dChjb2RlKVxuICAgICAgfSAvLyBEYXRhLlxuXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29kZX0gY29kZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gYXRCcmVhayhjb2RlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBsaXN0ID0gY29uc3RydWN0c1tjb2RlXVxuICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBsaXN0W2luZGV4XVxuXG4gICAgICAgICAgaWYgKCFpdGVtLnByZXZpb3VzIHx8IGl0ZW0ucHJldmlvdXMuY2FsbChzZWxmLCBzZWxmLnByZXZpb3VzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7UmVzb2x2ZXJ9IFtleHRyYVJlc29sdmVyXVxuICogQHJldHVybnMge1Jlc29sdmVyfVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKGV4dHJhUmVzb2x2ZXIpIHtcbiAgcmV0dXJuIHJlc29sdmVBbGxUZXh0XG4gIC8qKiBAdHlwZSB7UmVzb2x2ZXJ9ICovXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFsbFRleHQoZXZlbnRzLCBjb250ZXh0KSB7XG4gICAgbGV0IGluZGV4ID0gLTFcbiAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG5cbiAgICBsZXQgZW50ZXIgLy8gQSByYXRoZXIgYm9yaW5nIGNvbXB1dGF0aW9uICh0byBtZXJnZSBhZGphY2VudCBgZGF0YWAgZXZlbnRzKSB3aGljaFxuICAgIC8vIGltcHJvdmVzIG1tIHBlcmZvcm1hbmNlIGJ5IDI5JS5cblxuICAgIHdoaWxlICgrK2luZGV4IDw9IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmIChlbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChldmVudHNbaW5kZXhdICYmIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgZW50ZXIgPSBpbmRleFxuICAgICAgICAgIGluZGV4KytcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghZXZlbnRzW2luZGV4XSB8fCBldmVudHNbaW5kZXhdWzFdLnR5cGUgIT09ICdkYXRhJykge1xuICAgICAgICAvLyBEb25cdTIwMTl0IGRvIGFueXRoaW5nIGlmIHRoZXJlIGlzIG9uZSBkYXRhIHRva2VuLlxuICAgICAgICBpZiAoaW5kZXggIT09IGVudGVyICsgMikge1xuICAgICAgICAgIGV2ZW50c1tlbnRlcl1bMV0uZW5kID0gZXZlbnRzW2luZGV4IC0gMV1bMV0uZW5kXG4gICAgICAgICAgZXZlbnRzLnNwbGljZShlbnRlciArIDIsIGluZGV4IC0gZW50ZXIgLSAyKVxuICAgICAgICAgIGluZGV4ID0gZW50ZXIgKyAyXG4gICAgICAgIH1cblxuICAgICAgICBlbnRlciA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHRyYVJlc29sdmVyID8gZXh0cmFSZXNvbHZlcihldmVudHMsIGNvbnRleHQpIDogZXZlbnRzXG4gIH1cbn1cbi8qKlxuICogQSByYXRoZXIgdWdseSBzZXQgb2YgaW5zdHJ1Y3Rpb25zIHdoaWNoIGFnYWluIGxvb2tzIGF0IGNodW5rcyBpbiB0aGUgaW5wdXRcbiAqIHN0cmVhbS5cbiAqIFRoZSByZWFzb24gdG8gZG8gdGhpcyBoZXJlIGlzIHRoYXQgaXQgaXMgKm11Y2gqIGZhc3RlciB0byBwYXJzZSBpbiByZXZlcnNlLlxuICogQW5kIHRoYXQgd2UgY2FuXHUyMDE5dCBob29rIGludG8gYG51bGxgIHRvIHNwbGl0IHRoZSBsaW5lIHN1ZmZpeCBiZWZvcmUgYW4gRU9GLlxuICogVG8gZG86IGZpZ3VyZSBvdXQgaWYgd2UgY2FuIG1ha2UgdGhpcyBpbnRvIGEgY2xlYW4gdXRpbGl0eSwgb3IgZXZlbiBpbiBjb3JlLlxuICogQXMgaXQgd2lsbCBiZSB1c2VmdWwgZm9yIEdGTXMgbGl0ZXJhbCBhdXRvbGluayBleHRlbnNpb24gKGFuZCBtYXliZSBldmVuXG4gKiB0YWJsZXM/KVxuICpcbiAqIEB0eXBlIHtSZXNvbHZlcn1cbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQWxsTGluZVN1ZmZpeGVzKGV2ZW50cywgY29udGV4dCkge1xuICBsZXQgZXZlbnRJbmRleCA9IDAgLy8gU2tpcCBmaXJzdC5cblxuICB3aGlsZSAoKytldmVudEluZGV4IDw9IGV2ZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoXG4gICAgICAoZXZlbnRJbmRleCA9PT0gZXZlbnRzLmxlbmd0aCB8fFxuICAgICAgICBldmVudHNbZXZlbnRJbmRleF1bMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmcnKSAmJlxuICAgICAgZXZlbnRzW2V2ZW50SW5kZXggLSAxXVsxXS50eXBlID09PSAnZGF0YSdcbiAgICApIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBldmVudHNbZXZlbnRJbmRleCAtIDFdWzFdXG4gICAgICBjb25zdCBjaHVua3MgPSBjb250ZXh0LnNsaWNlU3RyZWFtKGRhdGEpXG4gICAgICBsZXQgaW5kZXggPSBjaHVua3MubGVuZ3RoXG4gICAgICBsZXQgYnVmZmVySW5kZXggPSAtMVxuICAgICAgbGV0IHNpemUgPSAwXG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gICAgICBsZXQgdGFic1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpbmRleF1cblxuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGJ1ZmZlckluZGV4ID0gY2h1bmsubGVuZ3RoXG5cbiAgICAgICAgICB3aGlsZSAoY2h1bmsuY2hhckNvZGVBdChidWZmZXJJbmRleCAtIDEpID09PSAzMikge1xuICAgICAgICAgICAgc2l6ZSsrXG4gICAgICAgICAgICBidWZmZXJJbmRleC0tXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJ1ZmZlckluZGV4KSBicmVha1xuICAgICAgICAgIGJ1ZmZlckluZGV4ID0gLTFcbiAgICAgICAgfSAvLyBOdW1iZXJcbiAgICAgICAgZWxzZSBpZiAoY2h1bmsgPT09IC0yKSB7XG4gICAgICAgICAgdGFicyA9IHRydWVcbiAgICAgICAgICBzaXplKytcbiAgICAgICAgfSBlbHNlIGlmIChjaHVuayA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBFbXB0eVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlcGxhY2VtZW50IGNoYXJhY3RlciwgZXhpdC5cbiAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgICB0eXBlOlxuICAgICAgICAgICAgZXZlbnRJbmRleCA9PT0gZXZlbnRzLmxlbmd0aCB8fCB0YWJzIHx8IHNpemUgPCAyXG4gICAgICAgICAgICAgID8gJ2xpbmVTdWZmaXgnXG4gICAgICAgICAgICAgIDogJ2hhcmRCcmVha1RyYWlsaW5nJyxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgbGluZTogZGF0YS5lbmQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZGF0YS5lbmQuY29sdW1uIC0gc2l6ZSxcbiAgICAgICAgICAgIG9mZnNldDogZGF0YS5lbmQub2Zmc2V0IC0gc2l6ZSxcbiAgICAgICAgICAgIF9pbmRleDogZGF0YS5zdGFydC5faW5kZXggKyBpbmRleCxcbiAgICAgICAgICAgIF9idWZmZXJJbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgPyBidWZmZXJJbmRleFxuICAgICAgICAgICAgICA6IGRhdGEuc3RhcnQuX2J1ZmZlckluZGV4ICsgYnVmZmVySW5kZXhcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgZGF0YS5lbmQpXG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCB0b2tlbi5zdGFydClcblxuICAgICAgICBpZiAoZGF0YS5zdGFydC5vZmZzZXQgPT09IGRhdGEuZW5kLm9mZnNldCkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgdG9rZW4pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnRzLnNwbGljZShcbiAgICAgICAgICAgIGV2ZW50SW5kZXgsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgWydlbnRlcicsIHRva2VuLCBjb250ZXh0XSxcbiAgICAgICAgICAgIFsnZXhpdCcsIHRva2VuLCBjb250ZXh0XVxuICAgICAgICAgIClcbiAgICAgICAgICBldmVudEluZGV4ICs9IDJcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldmVudEluZGV4KytcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnRzXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvZGV9IENvZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ2h1bmt9IENodW5rXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlBvaW50fSBQb2ludFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRWZmZWN0c30gRWZmZWN0c1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSW5pdGlhbENvbnN0cnVjdH0gSW5pdGlhbENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3RSZWNvcmR9IENvbnN0cnVjdFJlY29yZFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZUNvbnRleHR9IFRva2VuaXplQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5QYXJzZUNvbnRleHR9IFBhcnNlQ29udGV4dFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgSW5mb1xuICogQHByb3BlcnR5IHsoKSA9PiB2b2lkfSByZXN0b3JlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZnJvbVxuICpcbiAqIEBjYWxsYmFjayBSZXR1cm5IYW5kbGVcbiAqICAgSGFuZGxlIGEgc3VjY2Vzc2Z1bCBydW4uXG4gKiBAcGFyYW0ge0NvbnN0cnVjdH0gY29uc3RydWN0XG4gKiBAcGFyYW0ge0luZm99IGluZm9cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuaW1wb3J0IHtwdXNoLCBzcGxpY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNodW5rZWQnXG5pbXBvcnQge3Jlc29sdmVBbGx9IGZyb20gJ21pY3JvbWFyay11dGlsLXJlc29sdmUtYWxsJ1xuXG4vKipcbiAqIENyZWF0ZSBhIHRva2VuaXplci5cbiAqIFRva2VuaXplcnMgZGVhbCB3aXRoIG9uZSB0eXBlIG9mIGRhdGEgKGUuZy4sIGNvbnRhaW5lcnMsIGZsb3csIHRleHQpLlxuICogVGhlIHBhcnNlciBpcyB0aGUgb2JqZWN0IGRlYWxpbmcgd2l0aCBpdCBhbGwuXG4gKiBgaW5pdGlhbGl6ZWAgd29ya3MgbGlrZSBvdGhlciBjb25zdHJ1Y3RzLCBleGNlcHQgdGhhdCBvbmx5IGl0cyBgdG9rZW5pemVgXG4gKiBmdW5jdGlvbiBpcyB1c2VkLCBpbiB3aGljaCBjYXNlIGl0IGRvZXNuXHUyMDE5dCByZWNlaXZlIGFuIGBva2Agb3IgYG5va2AuXG4gKiBgZnJvbWAgY2FuIGJlIGdpdmVuIHRvIHNldCB0aGUgcG9pbnQgYmVmb3JlIHRoZSBmaXJzdCBjaGFyYWN0ZXIsIGFsdGhvdWdoXG4gKiB3aGVuIGZ1cnRoZXIgbGluZXMgYXJlIGluZGVudGVkLCB0aGV5IG11c3QgYmUgc2V0IHdpdGggYGRlZmluZVNraXBgLlxuICpcbiAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBwYXJzZXJcbiAqIEBwYXJhbSB7SW5pdGlhbENvbnN0cnVjdH0gaW5pdGlhbGl6ZVxuICogQHBhcmFtIHtPbWl0PFBvaW50LCAnX2luZGV4J3wnX2J1ZmZlckluZGV4Jz59IFtmcm9tXVxuICogQHJldHVybnMge1Rva2VuaXplQ29udGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRva2VuaXplcihwYXJzZXIsIGluaXRpYWxpemUsIGZyb20pIHtcbiAgLyoqIEB0eXBlIHtQb2ludH0gKi9cbiAgbGV0IHBvaW50ID0gT2JqZWN0LmFzc2lnbihcbiAgICBmcm9tXG4gICAgICA/IE9iamVjdC5hc3NpZ24oe30sIGZyb20pXG4gICAgICA6IHtcbiAgICAgICAgICBsaW5lOiAxLFxuICAgICAgICAgIGNvbHVtbjogMSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICB7XG4gICAgICBfaW5kZXg6IDAsXG4gICAgICBfYnVmZmVySW5kZXg6IC0xXG4gICAgfVxuICApXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn0gKi9cblxuICBjb25zdCBjb2x1bW5TdGFydCA9IHt9XG4gIC8qKiBAdHlwZSB7QXJyYXk8Q29uc3RydWN0Pn0gKi9cblxuICBjb25zdCByZXNvbHZlQWxsQ29uc3RydWN0cyA9IFtdXG4gIC8qKiBAdHlwZSB7QXJyYXk8Q2h1bms+fSAqL1xuXG4gIGxldCBjaHVua3MgPSBbXVxuICAvKiogQHR5cGUge0FycmF5PFRva2VuPn0gKi9cblxuICBsZXQgc3RhY2sgPSBbXVxuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBjb25zdW1lZCA9IHRydWVcbiAgLyoqXG4gICAqIFRvb2xzIHVzZWQgZm9yIHRva2VuaXppbmcuXG4gICAqXG4gICAqIEB0eXBlIHtFZmZlY3RzfVxuICAgKi9cblxuICBjb25zdCBlZmZlY3RzID0ge1xuICAgIGNvbnN1bWUsXG4gICAgZW50ZXIsXG4gICAgZXhpdCxcbiAgICBhdHRlbXB0OiBjb25zdHJ1Y3RGYWN0b3J5KG9uc3VjY2Vzc2Z1bGNvbnN0cnVjdCksXG4gICAgY2hlY2s6IGNvbnN0cnVjdEZhY3Rvcnkob25zdWNjZXNzZnVsY2hlY2spLFxuICAgIGludGVycnVwdDogY29uc3RydWN0RmFjdG9yeShvbnN1Y2Nlc3NmdWxjaGVjaywge1xuICAgICAgaW50ZXJydXB0OiB0cnVlXG4gICAgfSlcbiAgfVxuICAvKipcbiAgICogU3RhdGUgYW5kIHRvb2xzIGZvciByZXNvbHZpbmcgYW5kIHNlcmlhbGl6aW5nLlxuICAgKlxuICAgKiBAdHlwZSB7VG9rZW5pemVDb250ZXh0fVxuICAgKi9cblxuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIHByZXZpb3VzOiBudWxsLFxuICAgIGNvZGU6IG51bGwsXG4gICAgY29udGFpbmVyU3RhdGU6IHt9LFxuICAgIGV2ZW50czogW10sXG4gICAgcGFyc2VyLFxuICAgIHNsaWNlU3RyZWFtLFxuICAgIHNsaWNlU2VyaWFsaXplLFxuICAgIG5vdyxcbiAgICBkZWZpbmVTa2lwLFxuICAgIHdyaXRlXG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdGF0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHR5cGUge1N0YXRlfHZvaWR9XG4gICAqL1xuXG4gIGxldCBzdGF0ZSA9IGluaXRpYWxpemUudG9rZW5pemUuY2FsbChjb250ZXh0LCBlZmZlY3RzKVxuICAvKipcbiAgICogVHJhY2sgd2hpY2ggY2hhcmFjdGVyIHdlIGV4cGVjdCB0byBiZSBjb25zdW1lZCwgdG8gY2F0Y2ggYnVncy5cbiAgICpcbiAgICogQHR5cGUge0NvZGV9XG4gICAqL1xuXG4gIGxldCBleHBlY3RlZENvZGVcblxuICBpZiAoaW5pdGlhbGl6ZS5yZXNvbHZlQWxsKSB7XG4gICAgcmVzb2x2ZUFsbENvbnN0cnVjdHMucHVzaChpbml0aWFsaXplKVxuICB9XG5cbiAgcmV0dXJuIGNvbnRleHRcbiAgLyoqIEB0eXBlIHtUb2tlbml6ZUNvbnRleHRbJ3dyaXRlJ119ICovXG5cbiAgZnVuY3Rpb24gd3JpdGUoc2xpY2UpIHtcbiAgICBjaHVua3MgPSBwdXNoKGNodW5rcywgc2xpY2UpXG4gICAgbWFpbigpIC8vIEV4aXQgaWYgd2VcdTIwMTlyZSBub3QgZG9uZSwgcmVzb2x2ZSBtaWdodCBjaGFuZ2Ugc3R1ZmYuXG5cbiAgICBpZiAoY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgYWRkUmVzdWx0KGluaXRpYWxpemUsIDApIC8vIE90aGVyd2lzZSwgcmVzb2x2ZSwgYW5kIGV4aXQuXG5cbiAgICBjb250ZXh0LmV2ZW50cyA9IHJlc29sdmVBbGwocmVzb2x2ZUFsbENvbnN0cnVjdHMsIGNvbnRleHQuZXZlbnRzLCBjb250ZXh0KVxuICAgIHJldHVybiBjb250ZXh0LmV2ZW50c1xuICB9IC8vXG4gIC8vIFRvb2xzLlxuICAvL1xuXG4gIC8qKiBAdHlwZSB7VG9rZW5pemVDb250ZXh0WydzbGljZVNlcmlhbGl6ZSddfSAqL1xuXG4gIGZ1bmN0aW9uIHNsaWNlU2VyaWFsaXplKHRva2VuLCBleHBhbmRUYWJzKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZUNodW5rcyhzbGljZVN0cmVhbSh0b2tlbiksIGV4cGFuZFRhYnMpXG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbml6ZUNvbnRleHRbJ3NsaWNlU3RyZWFtJ119ICovXG5cbiAgZnVuY3Rpb24gc2xpY2VTdHJlYW0odG9rZW4pIHtcbiAgICByZXR1cm4gc2xpY2VDaHVua3MoY2h1bmtzLCB0b2tlbilcbiAgfVxuICAvKiogQHR5cGUge1Rva2VuaXplQ29udGV4dFsnbm93J119ICovXG5cbiAgZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwb2ludClcbiAgfVxuICAvKiogQHR5cGUge1Rva2VuaXplQ29udGV4dFsnZGVmaW5lU2tpcCddfSAqL1xuXG4gIGZ1bmN0aW9uIGRlZmluZVNraXAodmFsdWUpIHtcbiAgICBjb2x1bW5TdGFydFt2YWx1ZS5saW5lXSA9IHZhbHVlLmNvbHVtblxuICAgIGFjY291bnRGb3JQb3RlbnRpYWxTa2lwKClcbiAgfSAvL1xuICAvLyBTdGF0ZSBtYW5hZ2VtZW50LlxuICAvL1xuXG4gIC8qKlxuICAgKiBNYWluIGxvb3AgKG5vdGUgdGhhdCBgX2luZGV4YCBhbmQgYF9idWZmZXJJbmRleGAgaW4gYHBvaW50YCBhcmUgbW9kaWZpZWQgYnlcbiAgICogYGNvbnN1bWVgKS5cbiAgICogSGVyZSBpcyB3aGVyZSB3ZSB3YWxrIHRocm91Z2ggdGhlIGNodW5rcywgd2hpY2ggZWl0aGVyIGluY2x1ZGUgc3RyaW5ncyBvZlxuICAgKiBzZXZlcmFsIGNoYXJhY3RlcnMsIG9yIG51bWVyaWNhbCBjaGFyYWN0ZXIgY29kZXMuXG4gICAqIFRoZSByZWFzb24gdG8gZG8gdGhpcyBpbiBhIGxvb3AgaW5zdGVhZCBvZiBhIGNhbGwgaXMgc28gdGhlIHN0YWNrIGNhblxuICAgKiBkcmFpbi5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1haW4oKSB7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgbGV0IGNodW5rSW5kZXhcblxuICAgIHdoaWxlIChwb2ludC5faW5kZXggPCBjaHVua3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaHVuayA9IGNodW5rc1twb2ludC5faW5kZXhdIC8vIElmIHdlXHUyMDE5cmUgaW4gYSBidWZmZXIgY2h1bmssIGxvb3AgdGhyb3VnaCBpdC5cblxuICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2h1bmtJbmRleCA9IHBvaW50Ll9pbmRleFxuXG4gICAgICAgIGlmIChwb2ludC5fYnVmZmVySW5kZXggPCAwKSB7XG4gICAgICAgICAgcG9pbnQuX2J1ZmZlckluZGV4ID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgIHBvaW50Ll9pbmRleCA9PT0gY2h1bmtJbmRleCAmJlxuICAgICAgICAgIHBvaW50Ll9idWZmZXJJbmRleCA8IGNodW5rLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICBnbyhjaHVuay5jaGFyQ29kZUF0KHBvaW50Ll9idWZmZXJJbmRleCkpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdvKGNodW5rKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVhbCB3aXRoIG9uZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvZGV9IGNvZGVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdvKGNvZGUpIHtcbiAgICBjb25zdW1lZCA9IHVuZGVmaW5lZFxuICAgIGV4cGVjdGVkQ29kZSA9IGNvZGVcbiAgICBzdGF0ZSA9IHN0YXRlKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtFZmZlY3RzWydjb25zdW1lJ119ICovXG5cbiAgZnVuY3Rpb24gY29uc3VtZShjb2RlKSB7XG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcG9pbnQubGluZSsrXG4gICAgICBwb2ludC5jb2x1bW4gPSAxXG4gICAgICBwb2ludC5vZmZzZXQgKz0gY29kZSA9PT0gLTMgPyAyIDogMVxuICAgICAgYWNjb3VudEZvclBvdGVudGlhbFNraXAoKVxuICAgIH0gZWxzZSBpZiAoY29kZSAhPT0gLTEpIHtcbiAgICAgIHBvaW50LmNvbHVtbisrXG4gICAgICBwb2ludC5vZmZzZXQrK1xuICAgIH0gLy8gTm90IGluIGEgc3RyaW5nIGNodW5rLlxuXG4gICAgaWYgKHBvaW50Ll9idWZmZXJJbmRleCA8IDApIHtcbiAgICAgIHBvaW50Ll9pbmRleCsrXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50Ll9idWZmZXJJbmRleCsrIC8vIEF0IGVuZCBvZiBzdHJpbmcgY2h1bmsuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBvaW50cyB3LyBub24tbmVnYXRpdmUgYF9idWZmZXJJbmRleGAgcmVmZXJlbmNlXG4gICAgICAvLyBzdHJpbmdzLlxuXG4gICAgICBpZiAocG9pbnQuX2J1ZmZlckluZGV4ID09PSBjaHVua3NbcG9pbnQuX2luZGV4XS5sZW5ndGgpIHtcbiAgICAgICAgcG9pbnQuX2J1ZmZlckluZGV4ID0gLTFcbiAgICAgICAgcG9pbnQuX2luZGV4KytcbiAgICAgIH1cbiAgICB9IC8vIEV4cG9zZSB0aGUgcHJldmlvdXMgY2hhcmFjdGVyLlxuXG4gICAgY29udGV4dC5wcmV2aW91cyA9IGNvZGUgLy8gTWFyayBhcyBjb25zdW1lZC5cblxuICAgIGNvbnN1bWVkID0gdHJ1ZVxuICB9XG4gIC8qKiBAdHlwZSB7RWZmZWN0c1snZW50ZXInXX0gKi9cblxuICBmdW5jdGlvbiBlbnRlcih0eXBlLCBmaWVsZHMpIHtcbiAgICAvKiogQHR5cGUge1Rva2VufSAqL1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgUGF0Y2ggaW5zdGVhZCBvZiBhc3NpZ24gcmVxdWlyZWQgZmllbGRzIHRvIGhlbHAgR0MuXG4gICAgY29uc3QgdG9rZW4gPSBmaWVsZHMgfHwge31cbiAgICB0b2tlbi50eXBlID0gdHlwZVxuICAgIHRva2VuLnN0YXJ0ID0gbm93KClcbiAgICBjb250ZXh0LmV2ZW50cy5wdXNoKFsnZW50ZXInLCB0b2tlbiwgY29udGV4dF0pXG4gICAgc3RhY2sucHVzaCh0b2tlbilcbiAgICByZXR1cm4gdG9rZW5cbiAgfVxuICAvKiogQHR5cGUge0VmZmVjdHNbJ2V4aXQnXX0gKi9cblxuICBmdW5jdGlvbiBleGl0KHR5cGUpIHtcbiAgICBjb25zdCB0b2tlbiA9IHN0YWNrLnBvcCgpXG4gICAgdG9rZW4uZW5kID0gbm93KClcbiAgICBjb250ZXh0LmV2ZW50cy5wdXNoKFsnZXhpdCcsIHRva2VuLCBjb250ZXh0XSlcbiAgICByZXR1cm4gdG9rZW5cbiAgfVxuICAvKipcbiAgICogVXNlIHJlc3VsdHMuXG4gICAqXG4gICAqIEB0eXBlIHtSZXR1cm5IYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uc3VjY2Vzc2Z1bGNvbnN0cnVjdChjb25zdHJ1Y3QsIGluZm8pIHtcbiAgICBhZGRSZXN1bHQoY29uc3RydWN0LCBpbmZvLmZyb20pXG4gIH1cbiAgLyoqXG4gICAqIERpc2NhcmQgcmVzdWx0cy5cbiAgICpcbiAgICogQHR5cGUge1JldHVybkhhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25zdWNjZXNzZnVsY2hlY2soXywgaW5mbykge1xuICAgIGluZm8ucmVzdG9yZSgpXG4gIH1cbiAgLyoqXG4gICAqIEZhY3RvcnkgdG8gYXR0ZW1wdC9jaGVjay9pbnRlcnJ1cHQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmV0dXJuSGFuZGxlfSBvbnJldHVyblxuICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBbZmllbGRzXVxuICAgKi9cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RGYWN0b3J5KG9ucmV0dXJuLCBmaWVsZHMpIHtcbiAgICByZXR1cm4gaG9va1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBlaXRoZXIgYW4gb2JqZWN0IG1hcHBpbmcgY29kZXMgdG8gY29uc3RydWN0cywgYSBsaXN0IG9mXG4gICAgICogY29uc3RydWN0cywgb3IgYSBzaW5nbGUgY29uc3RydWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb25zdHJ1Y3R8QXJyYXk8Q29uc3RydWN0PnxDb25zdHJ1Y3RSZWNvcmR9IGNvbnN0cnVjdHNcbiAgICAgKiBAcGFyYW0ge1N0YXRlfSByZXR1cm5TdGF0ZVxuICAgICAqIEBwYXJhbSB7U3RhdGV9IFtib2d1c1N0YXRlXVxuICAgICAqIEByZXR1cm5zIHtTdGF0ZX1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGhvb2soY29uc3RydWN0cywgcmV0dXJuU3RhdGUsIGJvZ3VzU3RhdGUpIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8Q29uc3RydWN0Pn0gKi9cbiAgICAgIGxldCBsaXN0T2ZDb25zdHJ1Y3RzXG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICAgICAgbGV0IGNvbnN0cnVjdEluZGV4XG4gICAgICAvKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cblxuICAgICAgbGV0IGN1cnJlbnRDb25zdHJ1Y3RcbiAgICAgIC8qKiBAdHlwZSB7SW5mb30gKi9cblxuICAgICAgbGV0IGluZm9cbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNvbnN0cnVjdHMpXG4gICAgICAgID8gLyogYzggaWdub3JlIG5leHQgMSAqL1xuICAgICAgICAgIGhhbmRsZUxpc3RPZkNvbnN0cnVjdHMoY29uc3RydWN0cylcbiAgICAgICAgOiAndG9rZW5pemUnIGluIGNvbnN0cnVjdHMgLy8gQHRzLWV4cGVjdC1lcnJvciBMb29rcyBsaWtlIGEgY29uc3RydWN0LlxuICAgICAgICA/IGhhbmRsZUxpc3RPZkNvbnN0cnVjdHMoW2NvbnN0cnVjdHNdKVxuICAgICAgICA6IGhhbmRsZU1hcE9mQ29uc3RydWN0cyhjb25zdHJ1Y3RzKVxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgYSBsaXN0IG9mIGNvbnN0cnVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0NvbnN0cnVjdFJlY29yZH0gbWFwXG4gICAgICAgKiBAcmV0dXJucyB7U3RhdGV9XG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlTWFwT2ZDb25zdHJ1Y3RzKG1hcCkge1xuICAgICAgICByZXR1cm4gc3RhcnRcbiAgICAgICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgICAgICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgICAgICAgY29uc3QgZGVmID0gY29kZSAhPT0gbnVsbCAmJiBtYXBbY29kZV1cbiAgICAgICAgICBjb25zdCBhbGwgPSBjb2RlICE9PSBudWxsICYmIG1hcC5udWxsXG4gICAgICAgICAgY29uc3QgbGlzdCA9IFtcbiAgICAgICAgICAgIC8vIFRvIGRvOiBhZGQgbW9yZSBleHRlbnNpb24gdGVzdHMuXG5cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KGRlZikgPyBkZWYgOiBkZWYgPyBbZGVmXSA6IFtdKSxcbiAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KGFsbCkgPyBhbGwgOiBhbGwgPyBbYWxsXSA6IFtdKVxuICAgICAgICAgIF1cbiAgICAgICAgICByZXR1cm4gaGFuZGxlTGlzdE9mQ29uc3RydWN0cyhsaXN0KShjb2RlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBhIGxpc3Qgb2YgY29uc3RydWN0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7QXJyYXk8Q29uc3RydWN0Pn0gbGlzdFxuICAgICAgICogQHJldHVybnMge1N0YXRlfVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUxpc3RPZkNvbnN0cnVjdHMobGlzdCkge1xuICAgICAgICBsaXN0T2ZDb25zdHJ1Y3RzID0gbGlzdFxuICAgICAgICBjb25zdHJ1Y3RJbmRleCA9IDBcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gYm9ndXNTdGF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUNvbnN0cnVjdChsaXN0W2NvbnN0cnVjdEluZGV4XSlcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIGEgc2luZ2xlIGNvbnN0cnVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0NvbnN0cnVjdH0gY29uc3RydWN0XG4gICAgICAgKiBAcmV0dXJucyB7U3RhdGV9XG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlQ29uc3RydWN0KGNvbnN0cnVjdCkge1xuICAgICAgICByZXR1cm4gc3RhcnRcbiAgICAgICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgICAgICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgICAgICAgLy8gVG8gZG86IG5vdCBuZWVkZWQgdG8gc3RvcmUgaWYgdGhlcmUgaXMgbm8gYm9ndXMgc3RhdGUsIHByb2JhYmx5P1xuICAgICAgICAgIC8vIEN1cnJlbnRseSBkb2Vzblx1MjAxOXQgd29yayBiZWNhdXNlIGBpbnNwZWN0YCBpbiBkb2N1bWVudCBkb2VzIGEgY2hlY2tcbiAgICAgICAgICAvLyB3L28gYSBib2d1cywgd2hpY2ggZG9lc25cdTIwMTl0IG1ha2Ugc2Vuc2UuIEJ1dCBpdCBkb2VzIHNlZW0gdG8gaGVscCBwZXJmXG4gICAgICAgICAgLy8gYnkgbm90IHN0b3JpbmcuXG4gICAgICAgICAgaW5mbyA9IHN0b3JlKClcbiAgICAgICAgICBjdXJyZW50Q29uc3RydWN0ID0gY29uc3RydWN0XG5cbiAgICAgICAgICBpZiAoIWNvbnN0cnVjdC5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRDb25zdHJ1Y3QgPSBjb25zdHJ1Y3RcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25zdHJ1Y3QubmFtZSAmJlxuICAgICAgICAgICAgY29udGV4dC5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoY29uc3RydWN0Lm5hbWUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdC50b2tlbml6ZS5jYWxsKFxuICAgICAgICAgICAgLy8gSWYgd2UgZG8gaGF2ZSBmaWVsZHMsIGNyZWF0ZSBhbiBvYmplY3Qgdy8gYGNvbnRleHRgIGFzIGl0c1xuICAgICAgICAgICAgLy8gcHJvdG90eXBlLlxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgYSBcdTIwMUNsaXZlIGJpbmRpbmdcdTIwMUQsIHdoaWNoIGlzIG5lZWRlZCBmb3IgYGludGVycnVwdGAuXG4gICAgICAgICAgICBmaWVsZHMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoY29udGV4dCksIGZpZWxkcykgOiBjb250ZXh0LFxuICAgICAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgICAgIG9rLFxuICAgICAgICAgICAgbm9rXG4gICAgICAgICAgKShjb2RlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgICBmdW5jdGlvbiBvayhjb2RlKSB7XG4gICAgICAgIGNvbnN1bWVkID0gdHJ1ZVxuICAgICAgICBvbnJldHVybihjdXJyZW50Q29uc3RydWN0LCBpbmZvKVxuICAgICAgICByZXR1cm4gcmV0dXJuU3RhdGVcbiAgICAgIH1cbiAgICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICAgIGZ1bmN0aW9uIG5vayhjb2RlKSB7XG4gICAgICAgIGNvbnN1bWVkID0gdHJ1ZVxuICAgICAgICBpbmZvLnJlc3RvcmUoKVxuXG4gICAgICAgIGlmICgrK2NvbnN0cnVjdEluZGV4IDwgbGlzdE9mQ29uc3RydWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlQ29uc3RydWN0KGxpc3RPZkNvbnN0cnVjdHNbY29uc3RydWN0SW5kZXhdKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvZ3VzU3RhdGVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29uc3RydWN0fSBjb25zdHJ1Y3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFkZFJlc3VsdChjb25zdHJ1Y3QsIGZyb20pIHtcbiAgICBpZiAoY29uc3RydWN0LnJlc29sdmVBbGwgJiYgIXJlc29sdmVBbGxDb25zdHJ1Y3RzLmluY2x1ZGVzKGNvbnN0cnVjdCkpIHtcbiAgICAgIHJlc29sdmVBbGxDb25zdHJ1Y3RzLnB1c2goY29uc3RydWN0KVxuICAgIH1cblxuICAgIGlmIChjb25zdHJ1Y3QucmVzb2x2ZSkge1xuICAgICAgc3BsaWNlKFxuICAgICAgICBjb250ZXh0LmV2ZW50cyxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgY29udGV4dC5ldmVudHMubGVuZ3RoIC0gZnJvbSxcbiAgICAgICAgY29uc3RydWN0LnJlc29sdmUoY29udGV4dC5ldmVudHMuc2xpY2UoZnJvbSksIGNvbnRleHQpXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKGNvbnN0cnVjdC5yZXNvbHZlVG8pIHtcbiAgICAgIGNvbnRleHQuZXZlbnRzID0gY29uc3RydWN0LnJlc29sdmVUbyhjb250ZXh0LmV2ZW50cywgY29udGV4dClcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlIHN0YXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7SW5mb31cbiAgICovXG5cbiAgZnVuY3Rpb24gc3RvcmUoKSB7XG4gICAgY29uc3Qgc3RhcnRQb2ludCA9IG5vdygpXG4gICAgY29uc3Qgc3RhcnRQcmV2aW91cyA9IGNvbnRleHQucHJldmlvdXNcbiAgICBjb25zdCBzdGFydEN1cnJlbnRDb25zdHJ1Y3QgPSBjb250ZXh0LmN1cnJlbnRDb25zdHJ1Y3RcbiAgICBjb25zdCBzdGFydEV2ZW50c0luZGV4ID0gY29udGV4dC5ldmVudHMubGVuZ3RoXG4gICAgY29uc3Qgc3RhcnRTdGFjayA9IEFycmF5LmZyb20oc3RhY2spXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RvcmUsXG4gICAgICBmcm9tOiBzdGFydEV2ZW50c0luZGV4XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHJlc3RvcmUoKSB7XG4gICAgICBwb2ludCA9IHN0YXJ0UG9pbnRcbiAgICAgIGNvbnRleHQucHJldmlvdXMgPSBzdGFydFByZXZpb3VzXG4gICAgICBjb250ZXh0LmN1cnJlbnRDb25zdHJ1Y3QgPSBzdGFydEN1cnJlbnRDb25zdHJ1Y3RcbiAgICAgIGNvbnRleHQuZXZlbnRzLmxlbmd0aCA9IHN0YXJ0RXZlbnRzSW5kZXhcbiAgICAgIHN0YWNrID0gc3RhcnRTdGFja1xuICAgICAgYWNjb3VudEZvclBvdGVudGlhbFNraXAoKVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW92ZSB0aGUgY3VycmVudCBwb2ludCBhIGJpdCBmb3J3YXJkIGluIHRoZSBsaW5lIHdoZW4gaXRcdTIwMTlzIG9uIGEgY29sdW1uXG4gICAqIHNraXAuXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuICBmdW5jdGlvbiBhY2NvdW50Rm9yUG90ZW50aWFsU2tpcCgpIHtcbiAgICBpZiAocG9pbnQubGluZSBpbiBjb2x1bW5TdGFydCAmJiBwb2ludC5jb2x1bW4gPCAyKSB7XG4gICAgICBwb2ludC5jb2x1bW4gPSBjb2x1bW5TdGFydFtwb2ludC5saW5lXVxuICAgICAgcG9pbnQub2Zmc2V0ICs9IGNvbHVtblN0YXJ0W3BvaW50LmxpbmVdIC0gMVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHZXQgdGhlIGNodW5rcyBmcm9tIGEgc2xpY2Ugb2YgY2h1bmtzIGluIHRoZSByYW5nZSBvZiBhIHRva2VuLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Q2h1bms+fSBjaHVua3NcbiAqIEBwYXJhbSB7UGljazxUb2tlbiwgJ3N0YXJ0J3wnZW5kJz59IHRva2VuXG4gKiBAcmV0dXJucyB7QXJyYXk8Q2h1bms+fVxuICovXG5cbmZ1bmN0aW9uIHNsaWNlQ2h1bmtzKGNodW5rcywgdG9rZW4pIHtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IHRva2VuLnN0YXJ0Ll9pbmRleFxuICBjb25zdCBzdGFydEJ1ZmZlckluZGV4ID0gdG9rZW4uc3RhcnQuX2J1ZmZlckluZGV4XG4gIGNvbnN0IGVuZEluZGV4ID0gdG9rZW4uZW5kLl9pbmRleFxuICBjb25zdCBlbmRCdWZmZXJJbmRleCA9IHRva2VuLmVuZC5fYnVmZmVySW5kZXhcbiAgLyoqIEB0eXBlIHtBcnJheTxDaHVuaz59ICovXG5cbiAgbGV0IHZpZXdcblxuICBpZiAoc3RhcnRJbmRleCA9PT0gZW5kSW5kZXgpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBfYnVmZmVySW5kZXhgIGlzIHVzZWQgb24gc3RyaW5nIGNodW5rcy5cbiAgICB2aWV3ID0gW2NodW5rc1tzdGFydEluZGV4XS5zbGljZShzdGFydEJ1ZmZlckluZGV4LCBlbmRCdWZmZXJJbmRleCldXG4gIH0gZWxzZSB7XG4gICAgdmlldyA9IGNodW5rcy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleClcblxuICAgIGlmIChzdGFydEJ1ZmZlckluZGV4ID4gLTEpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYF9idWZmZXJJbmRleGAgaXMgdXNlZCBvbiBzdHJpbmcgY2h1bmtzLlxuICAgICAgdmlld1swXSA9IHZpZXdbMF0uc2xpY2Uoc3RhcnRCdWZmZXJJbmRleClcbiAgICB9XG5cbiAgICBpZiAoZW5kQnVmZmVySW5kZXggPiAwKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBfYnVmZmVySW5kZXhgIGlzIHVzZWQgb24gc3RyaW5nIGNodW5rcy5cbiAgICAgIHZpZXcucHVzaChjaHVua3NbZW5kSW5kZXhdLnNsaWNlKDAsIGVuZEJ1ZmZlckluZGV4KSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmlld1xufVxuLyoqXG4gKiBHZXQgdGhlIHN0cmluZyB2YWx1ZSBvZiBhIHNsaWNlIG9mIGNodW5rcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PENodW5rPn0gY2h1bmtzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBhbmRUYWJzPWZhbHNlXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemVDaHVua3MoY2h1bmtzLCBleHBhbmRUYWJzKSB7XG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cblxuICBjb25zdCByZXN1bHQgPSBbXVxuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBhdFRhYlxuXG4gIHdoaWxlICgrK2luZGV4IDwgY2h1bmtzLmxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2luZGV4XVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXG4gICAgbGV0IHZhbHVlXG5cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBjaHVua1xuICAgIH0gZWxzZVxuICAgICAgc3dpdGNoIChjaHVuaykge1xuICAgICAgICBjYXNlIC01OiB7XG4gICAgICAgICAgdmFsdWUgPSAnXFxyJ1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIC00OiB7XG4gICAgICAgICAgdmFsdWUgPSAnXFxuJ1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIC0zOiB7XG4gICAgICAgICAgdmFsdWUgPSAnXFxyJyArICdcXG4nXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgLTI6IHtcbiAgICAgICAgICB2YWx1ZSA9IGV4cGFuZFRhYnMgPyAnICcgOiAnXFx0J1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIC0xOiB7XG4gICAgICAgICAgaWYgKCFleHBhbmRUYWJzICYmIGF0VGFiKSBjb250aW51ZVxuICAgICAgICAgIHZhbHVlID0gJyAnXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAvLyBDdXJyZW50bHkgb25seSByZXBsYWNlbWVudCBjaGFyYWN0ZXIuXG4gICAgICAgICAgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNodW5rKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBhdFRhYiA9IGNodW5rID09PSAtMlxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeHRlbnNpb259IEV4dGVuc2lvblxuICovXG5pbXBvcnQge1xuICBhdHRlbnRpb24sXG4gIGF1dG9saW5rLFxuICBibG9ja1F1b3RlLFxuICBjaGFyYWN0ZXJFc2NhcGUsXG4gIGNoYXJhY3RlclJlZmVyZW5jZSxcbiAgY29kZUZlbmNlZCxcbiAgY29kZUluZGVudGVkLFxuICBjb2RlVGV4dCxcbiAgZGVmaW5pdGlvbixcbiAgaGFyZEJyZWFrRXNjYXBlLFxuICBoZWFkaW5nQXR4LFxuICBodG1sRmxvdyxcbiAgaHRtbFRleHQsXG4gIGxhYmVsRW5kLFxuICBsYWJlbFN0YXJ0SW1hZ2UsXG4gIGxhYmVsU3RhcnRMaW5rLFxuICBsaW5lRW5kaW5nLFxuICBsaXN0LFxuICBzZXRleHRVbmRlcmxpbmUsXG4gIHRoZW1hdGljQnJlYWtcbn0gZnJvbSAnbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyaydcbmltcG9ydCB7cmVzb2x2ZXIgYXMgcmVzb2x2ZVRleHR9IGZyb20gJy4vaW5pdGlhbGl6ZS90ZXh0LmpzJ1xuLyoqIEB0eXBlIHtFeHRlbnNpb25bJ2RvY3VtZW50J119ICovXG5cbmV4cG9ydCBjb25zdCBkb2N1bWVudCA9IHtcbiAgWzQyXTogbGlzdCxcbiAgWzQzXTogbGlzdCxcbiAgWzQ1XTogbGlzdCxcbiAgWzQ4XTogbGlzdCxcbiAgWzQ5XTogbGlzdCxcbiAgWzUwXTogbGlzdCxcbiAgWzUxXTogbGlzdCxcbiAgWzUyXTogbGlzdCxcbiAgWzUzXTogbGlzdCxcbiAgWzU0XTogbGlzdCxcbiAgWzU1XTogbGlzdCxcbiAgWzU2XTogbGlzdCxcbiAgWzU3XTogbGlzdCxcbiAgWzYyXTogYmxvY2tRdW90ZVxufVxuLyoqIEB0eXBlIHtFeHRlbnNpb25bJ2NvbnRlbnRJbml0aWFsJ119ICovXG5cbmV4cG9ydCBjb25zdCBjb250ZW50SW5pdGlhbCA9IHtcbiAgWzkxXTogZGVmaW5pdGlvblxufVxuLyoqIEB0eXBlIHtFeHRlbnNpb25bJ2Zsb3dJbml0aWFsJ119ICovXG5cbmV4cG9ydCBjb25zdCBmbG93SW5pdGlhbCA9IHtcbiAgWy0yXTogY29kZUluZGVudGVkLFxuICBbLTFdOiBjb2RlSW5kZW50ZWQsXG4gIFszMl06IGNvZGVJbmRlbnRlZFxufVxuLyoqIEB0eXBlIHtFeHRlbnNpb25bJ2Zsb3cnXX0gKi9cblxuZXhwb3J0IGNvbnN0IGZsb3cgPSB7XG4gIFszNV06IGhlYWRpbmdBdHgsXG4gIFs0Ml06IHRoZW1hdGljQnJlYWssXG4gIFs0NV06IFtzZXRleHRVbmRlcmxpbmUsIHRoZW1hdGljQnJlYWtdLFxuICBbNjBdOiBodG1sRmxvdyxcbiAgWzYxXTogc2V0ZXh0VW5kZXJsaW5lLFxuICBbOTVdOiB0aGVtYXRpY0JyZWFrLFxuICBbOTZdOiBjb2RlRmVuY2VkLFxuICBbMTI2XTogY29kZUZlbmNlZFxufVxuLyoqIEB0eXBlIHtFeHRlbnNpb25bJ3N0cmluZyddfSAqL1xuXG5leHBvcnQgY29uc3Qgc3RyaW5nID0ge1xuICBbMzhdOiBjaGFyYWN0ZXJSZWZlcmVuY2UsXG4gIFs5Ml06IGNoYXJhY3RlckVzY2FwZVxufVxuLyoqIEB0eXBlIHtFeHRlbnNpb25bJ3RleHQnXX0gKi9cblxuZXhwb3J0IGNvbnN0IHRleHQgPSB7XG4gIFstNV06IGxpbmVFbmRpbmcsXG4gIFstNF06IGxpbmVFbmRpbmcsXG4gIFstM106IGxpbmVFbmRpbmcsXG4gIFszM106IGxhYmVsU3RhcnRJbWFnZSxcbiAgWzM4XTogY2hhcmFjdGVyUmVmZXJlbmNlLFxuICBbNDJdOiBhdHRlbnRpb24sXG4gIFs2MF06IFthdXRvbGluaywgaHRtbFRleHRdLFxuICBbOTFdOiBsYWJlbFN0YXJ0TGluayxcbiAgWzkyXTogW2hhcmRCcmVha0VzY2FwZSwgY2hhcmFjdGVyRXNjYXBlXSxcbiAgWzkzXTogbGFiZWxFbmQsXG4gIFs5NV06IGF0dGVudGlvbixcbiAgWzk2XTogY29kZVRleHRcbn1cbi8qKiBAdHlwZSB7RXh0ZW5zaW9uWydpbnNpZGVTcGFuJ119ICovXG5cbmV4cG9ydCBjb25zdCBpbnNpZGVTcGFuID0ge1xuICBudWxsOiBbYXR0ZW50aW9uLCByZXNvbHZlVGV4dF1cbn1cbi8qKiBAdHlwZSB7RXh0ZW5zaW9uWydhdHRlbnRpb25NYXJrZXJzJ119ICovXG5cbmV4cG9ydCBjb25zdCBhdHRlbnRpb25NYXJrZXJzID0ge1xuICBudWxsOiBbNDIsIDk1XVxufVxuLyoqIEB0eXBlIHtFeHRlbnNpb25bJ2Rpc2FibGUnXX0gKi9cblxuZXhwb3J0IGNvbnN0IGRpc2FibGUgPSB7XG4gIG51bGw6IFtdXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkluaXRpYWxDb25zdHJ1Y3R9IEluaXRpYWxDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRnVsbE5vcm1hbGl6ZWRFeHRlbnNpb259IEZ1bGxOb3JtYWxpemVkRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlBhcnNlT3B0aW9uc30gUGFyc2VPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlBhcnNlQ29udGV4dH0gUGFyc2VDb250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNyZWF0ZX0gQ3JlYXRlXG4gKi9cbmltcG9ydCB7Y29tYmluZUV4dGVuc2lvbnN9IGZyb20gJ21pY3JvbWFyay11dGlsLWNvbWJpbmUtZXh0ZW5zaW9ucydcbmltcG9ydCB7Y29udGVudH0gZnJvbSAnLi9pbml0aWFsaXplL2NvbnRlbnQuanMnXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tICcuL2luaXRpYWxpemUvZG9jdW1lbnQuanMnXG5pbXBvcnQge2Zsb3d9IGZyb20gJy4vaW5pdGlhbGl6ZS9mbG93LmpzJ1xuaW1wb3J0IHt0ZXh0LCBzdHJpbmd9IGZyb20gJy4vaW5pdGlhbGl6ZS90ZXh0LmpzJ1xuaW1wb3J0IHtjcmVhdGVUb2tlbml6ZXJ9IGZyb20gJy4vY3JlYXRlLXRva2VuaXplci5qcydcbmltcG9ydCAqIGFzIGRlZmF1bHRDb25zdHJ1Y3RzIGZyb20gJy4vY29uc3RydWN0cy5qcydcbi8qKlxuICogQHBhcmFtIHtQYXJzZU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1BhcnNlQ29udGV4dH1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uob3B0aW9ucyA9IHt9KSB7XG4gIC8qKiBAdHlwZSB7RnVsbE5vcm1hbGl6ZWRFeHRlbnNpb259ICovXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgYGRlZmF1bHRDb25zdHJ1Y3RzYCBpcyBmdWxsLCBzbyB0aGUgcmVzdWx0IHdpbGwgYmUgdG9vLlxuICBjb25zdCBjb25zdHJ1Y3RzID0gY29tYmluZUV4dGVuc2lvbnMoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBTYW1lIGFzIGFib3ZlLlxuICAgIFtkZWZhdWx0Q29uc3RydWN0c10uY29uY2F0KG9wdGlvbnMuZXh0ZW5zaW9ucyB8fCBbXSlcbiAgKVxuICAvKiogQHR5cGUge1BhcnNlQ29udGV4dH0gKi9cblxuICBjb25zdCBwYXJzZXIgPSB7XG4gICAgZGVmaW5lZDogW10sXG4gICAgbGF6eToge30sXG4gICAgY29uc3RydWN0cyxcbiAgICBjb250ZW50OiBjcmVhdGUoY29udGVudCksXG4gICAgZG9jdW1lbnQ6IGNyZWF0ZShkb2N1bWVudCksXG4gICAgZmxvdzogY3JlYXRlKGZsb3cpLFxuICAgIHN0cmluZzogY3JlYXRlKHN0cmluZyksXG4gICAgdGV4dDogY3JlYXRlKHRleHQpXG4gIH1cbiAgcmV0dXJuIHBhcnNlclxuICAvKipcbiAgICogQHBhcmFtIHtJbml0aWFsQ29uc3RydWN0fSBpbml0aWFsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZShpbml0aWFsKSB7XG4gICAgcmV0dXJuIGNyZWF0b3JcbiAgICAvKiogQHR5cGUge0NyZWF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIGNyZWF0b3IoZnJvbSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuaXplcihwYXJzZXIsIGluaXRpYWwsIGZyb20pXG4gICAgfVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkVuY29kaW5nfSBFbmNvZGluZ1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5WYWx1ZX0gVmFsdWVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ2h1bmt9IENodW5rXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvZGV9IENvZGVcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBQcmVwcm9jZXNzb3JcbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlXG4gKiBAcGFyYW0ge0VuY29kaW5nfSBbZW5jb2RpbmddXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmQ9ZmFsc2VdXG4gKiBAcmV0dXJucyB7QXJyYXk8Q2h1bms+fVxuICovXG5jb25zdCBzZWFyY2ggPSAvW1xcMFxcdFxcblxccl0vZ1xuLyoqXG4gKiBAcmV0dXJucyB7UHJlcHJvY2Vzc29yfVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzKCkge1xuICBsZXQgY29sdW1uID0gMVxuICBsZXQgYnVmZmVyID0gJydcbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgc3RhcnQgPSB0cnVlXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGF0Q2FycmlhZ2VSZXR1cm5cbiAgcmV0dXJuIHByZXByb2Nlc3NvclxuICAvKiogQHR5cGUge1ByZXByb2Nlc3Nvcn0gKi9cblxuICBmdW5jdGlvbiBwcmVwcm9jZXNzb3IodmFsdWUsIGVuY29kaW5nLCBlbmQpIHtcbiAgICAvKiogQHR5cGUge0FycmF5PENodW5rPn0gKi9cbiAgICBjb25zdCBjaHVua3MgPSBbXVxuICAgIC8qKiBAdHlwZSB7UmVnRXhwTWF0Y2hBcnJheXxudWxsfSAqL1xuXG4gICAgbGV0IG1hdGNoXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgICBsZXQgbmV4dFxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXG4gICAgbGV0IHN0YXJ0UG9zaXRpb25cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICAgIGxldCBlbmRQb3NpdGlvblxuICAgIC8qKiBAdHlwZSB7Q29kZX0gKi9cblxuICAgIGxldCBjb2RlIC8vIEB0cy1leHBlY3QtZXJyb3IgYEJ1ZmZlcmAgZG9lcyBhbGxvdyBhbiBlbmNvZGluZy5cblxuICAgIHZhbHVlID0gYnVmZmVyICsgdmFsdWUudG9TdHJpbmcoZW5jb2RpbmcpXG4gICAgc3RhcnRQb3NpdGlvbiA9IDBcbiAgICBidWZmZXIgPSAnJ1xuXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBpZiAodmFsdWUuY2hhckNvZGVBdCgwKSA9PT0gNjUyNzkpIHtcbiAgICAgICAgc3RhcnRQb3NpdGlvbisrXG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgd2hpbGUgKHN0YXJ0UG9zaXRpb24gPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIHNlYXJjaC5sYXN0SW5kZXggPSBzdGFydFBvc2l0aW9uXG4gICAgICBtYXRjaCA9IHNlYXJjaC5leGVjKHZhbHVlKVxuICAgICAgZW5kUG9zaXRpb24gPVxuICAgICAgICBtYXRjaCAmJiBtYXRjaC5pbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0Y2guaW5kZXggOiB2YWx1ZS5sZW5ndGhcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGVuZFBvc2l0aW9uKVxuXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGJ1ZmZlciA9IHZhbHVlLnNsaWNlKHN0YXJ0UG9zaXRpb24pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlID09PSAxMCAmJiBzdGFydFBvc2l0aW9uID09PSBlbmRQb3NpdGlvbiAmJiBhdENhcnJpYWdlUmV0dXJuKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKC0zKVxuICAgICAgICBhdENhcnJpYWdlUmV0dXJuID0gdW5kZWZpbmVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYXRDYXJyaWFnZVJldHVybikge1xuICAgICAgICAgIGNodW5rcy5wdXNoKC01KVxuICAgICAgICAgIGF0Q2FycmlhZ2VSZXR1cm4gPSB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydFBvc2l0aW9uIDwgZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICBjaHVua3MucHVzaCh2YWx1ZS5zbGljZShzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikpXG4gICAgICAgICAgY29sdW1uICs9IGVuZFBvc2l0aW9uIC0gc3RhcnRQb3NpdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgICBjaHVua3MucHVzaCg2NTUzMylcbiAgICAgICAgICAgIGNvbHVtbisrXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgOToge1xuICAgICAgICAgICAgbmV4dCA9IE1hdGguY2VpbChjb2x1bW4gLyA0KSAqIDRcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKC0yKVxuXG4gICAgICAgICAgICB3aGlsZSAoY29sdW1uKysgPCBuZXh0KSBjaHVua3MucHVzaCgtMSlcblxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICBjaHVua3MucHVzaCgtNClcbiAgICAgICAgICAgIGNvbHVtbiA9IDFcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgYXRDYXJyaWFnZVJldHVybiA9IHRydWVcbiAgICAgICAgICAgIGNvbHVtbiA9IDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhcnRQb3NpdGlvbiA9IGVuZFBvc2l0aW9uICsgMVxuICAgIH1cblxuICAgIGlmIChlbmQpIHtcbiAgICAgIGlmIChhdENhcnJpYWdlUmV0dXJuKSBjaHVua3MucHVzaCgtNSlcbiAgICAgIGlmIChidWZmZXIpIGNodW5rcy5wdXNoKGJ1ZmZlcilcbiAgICAgIGNodW5rcy5wdXNoKG51bGwpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNodW5rc1xuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICovXG5pbXBvcnQge3N1YnRva2VuaXplfSBmcm9tICdtaWNyb21hcmstdXRpbC1zdWJ0b2tlbml6ZSdcbi8qKlxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICogQHJldHVybnMge0FycmF5PEV2ZW50Pn1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcG9zdHByb2Nlc3MoZXZlbnRzKSB7XG4gIHdoaWxlICghc3VidG9rZW5pemUoZXZlbnRzKSkge1xuICAgIC8vIEVtcHR5XG4gIH1cblxuICByZXR1cm4gZXZlbnRzXG59XG4iLCAiLyoqXG4gKiBUdXJuIHRoZSBudW1iZXIgKGluIHN0cmluZyBmb3JtIGFzIGVpdGhlciBoZXhhLSBvciBwbGFpbiBkZWNpbWFsKSBjb21pbmcgZnJvbVxuICogYSBudW1lcmljIGNoYXJhY3RlciByZWZlcmVuY2UgaW50byBhIGNoYXJhY3Rlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgVmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcbiAqICAgTnVtZXJpYyBiYXNlLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UodmFsdWUsIGJhc2UpIHtcbiAgY29uc3QgY29kZSA9IE51bWJlci5wYXJzZUludCh2YWx1ZSwgYmFzZSlcblxuICBpZiAoXG4gICAgLy8gQzAgZXhjZXB0IGZvciBIVCwgTEYsIEZGLCBDUiwgc3BhY2VcbiAgICBjb2RlIDwgOSB8fFxuICAgIGNvZGUgPT09IDExIHx8XG4gICAgKGNvZGUgPiAxMyAmJiBjb2RlIDwgMzIpIHx8IC8vIENvbnRyb2wgY2hhcmFjdGVyIChERUwpIG9mIHRoZSBiYXNpYyBibG9jayBhbmQgQzEgY29udHJvbHMuXG4gICAgKGNvZGUgPiAxMjYgJiYgY29kZSA8IDE2MCkgfHwgLy8gTG9uZSBoaWdoIHN1cnJvZ2F0ZXMgYW5kIGxvdyBzdXJyb2dhdGVzLlxuICAgIChjb2RlID4gNTUyOTUgJiYgY29kZSA8IDU3MzQ0KSB8fCAvLyBOb25jaGFyYWN0ZXJzLlxuICAgIChjb2RlID4gNjQ5NzUgJiYgY29kZSA8IDY1MDA4KSB8fFxuICAgIChjb2RlICYgNjU1MzUpID09PSA2NTUzNSB8fFxuICAgIChjb2RlICYgNjU1MzUpID09PSA2NTUzNCB8fCAvLyBPdXQgb2YgcmFuZ2VcbiAgICBjb2RlID4gMTExNDExMVxuICApIHtcbiAgICByZXR1cm4gJ1xcdUZGRkQnXG4gIH1cblxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKVxufVxuIiwgImltcG9ydCB7ZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2V9IGZyb20gJ2RlY29kZS1uYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlJ1xuaW1wb3J0IHtkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1kZWNvZGUtbnVtZXJpYy1jaGFyYWN0ZXItcmVmZXJlbmNlJ1xuY29uc3QgY2hhcmFjdGVyRXNjYXBlT3JSZWZlcmVuY2UgPVxuICAvXFxcXChbIS0vOi1AWy1gey1+XSl8JigjKD86XFxkezEsN318eFtcXGRhLWZdezEsNn0pfFtcXGRhLXpdezEsMzF9KTsvZ2lcbi8qKlxuICogVXRpbGl0eSB0byBkZWNvZGUgbWFya2Rvd24gc3RyaW5ncyAod2hpY2ggb2NjdXIgaW4gcGxhY2VzIHN1Y2ggYXMgZmVuY2VkXG4gKiBjb2RlIGluZm8gc3RyaW5ncywgZGVzdGluYXRpb25zLCBsYWJlbHMsIGFuZCB0aXRsZXMpLlxuICogVGhlIFx1MjAxQ3N0cmluZ1x1MjAxRCBjb250ZW50IHR5cGUgYWxsb3dzIGNoYXJhY3RlciBlc2NhcGVzIGFuZCAtcmVmZXJlbmNlcy5cbiAqIFRoaXMgZGVjb2RlcyB0aG9zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShjaGFyYWN0ZXJFc2NhcGVPclJlZmVyZW5jZSwgZGVjb2RlKVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gJDBcbiAqIEBwYXJhbSB7c3RyaW5nfSAkMVxuICogQHBhcmFtIHtzdHJpbmd9ICQyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZSgkMCwgJDEsICQyKSB7XG4gIGlmICgkMSkge1xuICAgIC8vIEVzY2FwZS5cbiAgICByZXR1cm4gJDFcbiAgfSAvLyBSZWZlcmVuY2UuXG5cbiAgY29uc3QgaGVhZCA9ICQyLmNoYXJDb2RlQXQoMClcblxuICBpZiAoaGVhZCA9PT0gMzUpIHtcbiAgICBjb25zdCBoZWFkID0gJDIuY2hhckNvZGVBdCgxKVxuICAgIGNvbnN0IGhleCA9IGhlYWQgPT09IDEyMCB8fCBoZWFkID09PSA4OFxuICAgIHJldHVybiBkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlKCQyLnNsaWNlKGhleCA/IDIgOiAxKSwgaGV4ID8gMTYgOiAxMClcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZSgkMikgfHwgJDBcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUG9pbnR9IFBvaW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLk5vZGV9IE5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUG9zaXRpb259IFBvc2l0aW9uXG4gKiBAdHlwZWRlZiB7b2JqZWN0ICYge3R5cGU6IHN0cmluZywgcG9zaXRpb24/OiBQb3NpdGlvbnx1bmRlZmluZWR9fSBOb2RlTGlrZVxuICovXG5cbi8qKlxuICogU3RyaW5naWZ5IG9uZSBwb2ludCwgYSBwb3NpdGlvbiAoc3RhcnQgYW5kIGVuZCBwb2ludHMpLCBvciBhIG5vZGVcdTIwMTlzXG4gKiBwb3NpdGlvbmFsIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7Tm9kZXxOb2RlTGlrZXxQb3NpdGlvbnxQb2ludHxudWxsfSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5UG9zaXRpb24odmFsdWUpIHtcbiAgLy8gTm90aGluZy5cbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBOb2RlLlxuICBpZiAoJ3Bvc2l0aW9uJyBpbiB2YWx1ZSB8fCAndHlwZScgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gcG9zaXRpb24odmFsdWUucG9zaXRpb24pXG4gIH1cblxuICAvLyBQb3NpdGlvbi5cbiAgaWYgKCdzdGFydCcgaW4gdmFsdWUgfHwgJ2VuZCcgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gcG9zaXRpb24odmFsdWUpXG4gIH1cblxuICAvLyBQb2ludC5cbiAgaWYgKCdsaW5lJyBpbiB2YWx1ZSB8fCAnY29sdW1uJyBpbiB2YWx1ZSkge1xuICAgIHJldHVybiBwb2ludCh2YWx1ZSlcbiAgfVxuXG4gIC8vID9cbiAgcmV0dXJuICcnXG59XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludHx1bmRlZmluZWR9IHBvaW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBwb2ludChwb2ludCkge1xuICByZXR1cm4gaW5kZXgocG9pbnQgJiYgcG9pbnQubGluZSkgKyAnOicgKyBpbmRleChwb2ludCAmJiBwb2ludC5jb2x1bW4pXG59XG5cbi8qKlxuICogQHBhcmFtIHtQb3NpdGlvbnx1bmRlZmluZWR9IHBvc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcG9zaXRpb24ocG9zKSB7XG4gIHJldHVybiBwb2ludChwb3MgJiYgcG9zLnN0YXJ0KSArICctJyArIHBvaW50KHBvcyAmJiBwb3MuZW5kKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGluZGV4KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiAxXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkVuY29kaW5nfSBFbmNvZGluZ1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FdmVudH0gRXZlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUGFyc2VPcHRpb25zfSBQYXJzZU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplQ29udGV4dH0gVG9rZW5pemVDb250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlZhbHVlfSBWYWx1ZVxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5QYXJlbnR9IFVuaXN0UGFyZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBvaW50fSBQb2ludFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QaHJhc2luZ0NvbnRlbnR9IFBocmFzaW5nQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Db250ZW50fSBDb250ZW50XG4gKiBAdHlwZWRlZiB7Um9vdHxDb250ZW50fSBOb2RlXG4gKiBAdHlwZWRlZiB7RXh0cmFjdDxOb2RlLCBVbmlzdFBhcmVudD59IFBhcmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5CcmVha30gQnJlYWtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQmxvY2txdW90ZX0gQmxvY2txdW90ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Db2RlfSBDb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkRlZmluaXRpb259IERlZmluaXRpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuRW1waGFzaXN9IEVtcGhhc2lzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkhlYWRpbmd9IEhlYWRpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSFRNTH0gSFRNTFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5JbWFnZX0gSW1hZ2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSW1hZ2VSZWZlcmVuY2V9IEltYWdlUmVmZXJlbmNlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLklubGluZUNvZGV9IElubGluZUNvZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGlua30gTGlua1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaW5rUmVmZXJlbmNlfSBMaW5rUmVmZXJlbmNlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpc3R9IExpc3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGlzdEl0ZW19IExpc3RJdGVtXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlBhcmFncmFwaH0gUGFyYWdyYXBoXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuU3Ryb25nfSBTdHJvbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGV4dH0gVGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UaGVtYXRpY0JyZWFrfSBUaGVtYXRpY0JyZWFrXG4gKlxuICogQHR5cGVkZWYge1VuaXN0UGFyZW50ICYge3R5cGU6ICdmcmFnbWVudCcsIGNoaWxkcmVuOiBBcnJheTxQaHJhc2luZ0NvbnRlbnQ+fX0gRnJhZ21lbnRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIF9Db21waWxlRGF0YUZpZWxkc1xuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBmbG93Q29kZUluc2lkZVxuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gc2V0ZXh0SGVhZGluZ1NsdXJwTGluZUVuZGluZ1xuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gYXRIYXJkQnJlYWtcbiAqIEBwcm9wZXJ0eSB7J2NvbGxhcHNlZCd8J2Z1bGwnfSByZWZlcmVuY2VUeXBlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBpblJlZmVyZW5jZVxuICogQHByb3BlcnR5IHsnY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWwnfCdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljJ30gY2hhcmFjdGVyUmVmZXJlbmNlVHlwZVxuICpcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiAmIFBhcnRpYWw8X0NvbXBpbGVEYXRhRmllbGRzPn0gQ29tcGlsZURhdGFcbiAqXG4gKiBAdHlwZWRlZiB7KHRyZWU6IFJvb3QpID0+IFJvb3R8dm9pZH0gVHJhbnNmb3JtXG4gKiBAdHlwZWRlZiB7KHRoaXM6IENvbXBpbGVDb250ZXh0LCB0b2tlbjogVG9rZW4pID0+IHZvaWR9IEhhbmRsZVxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIEhhbmRsZT59IEhhbmRsZXNcbiAqICAgVG9rZW4gdHlwZXMgbWFwcGluZyB0byBoYW5kbGVzXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgdW5rbm93bj58QXJyYXk8dW5rbm93bj4+ICYge2NhbkNvbnRhaW5Fb2xzOiBBcnJheTxzdHJpbmc+LCB0cmFuc2Zvcm1zOiBBcnJheTxUcmFuc2Zvcm0+LCBlbnRlcjogSGFuZGxlcywgZXhpdDogSGFuZGxlc319IE5vcm1hbGl6ZWRFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtQYXJ0aWFsPE5vcm1hbGl6ZWRFeHRlbnNpb24+fSBFeHRlbnNpb25cbiAqICAgQW4gbWRhc3QgZXh0ZW5zaW9uIGNoYW5nZXMgaG93IG1hcmtkb3duIHRva2VucyBhcmUgdHVybmVkIGludG8gbWRhc3QuXG4gKlxuICogQHR5cGVkZWYgeyh0aGlzOiBPbWl0PENvbXBpbGVDb250ZXh0LCAnc2xpY2VTZXJpYWxpemUnPiwgbGVmdDogVG9rZW58dW5kZWZpbmVkLCByaWdodDogVG9rZW4pID0+IHZvaWR9IE9uRW50ZXJFcnJvclxuICogQHR5cGVkZWYgeyh0aGlzOiBPbWl0PENvbXBpbGVDb250ZXh0LCAnc2xpY2VTZXJpYWxpemUnPiwgbGVmdDogVG9rZW4sIHJpZ2h0OiBUb2tlbikgPT4gdm9pZH0gT25FeGl0RXJyb3JcbiAqXG4gKiBAdHlwZWRlZiBDb21waWxlQ29udGV4dFxuICogICBtZGFzdCBjb21waWxlciBjb250ZXh0XG4gKiBAcHJvcGVydHkge0FycmF5PE5vZGUgfCBGcmFnbWVudD59IHN0YWNrXG4gKiBAcHJvcGVydHkge0FycmF5PFtUb2tlbiwgT25FbnRlckVycm9yfHVuZGVmaW5lZF0+fSB0b2tlblN0YWNrXG4gKiBAcHJvcGVydHkgeyhrZXk6IHN0cmluZywgdmFsdWU/OiB1bmtub3duKSA9PiB2b2lkfSBzZXREYXRhXG4gKiAgIFNldCBkYXRhIGludG8gdGhlIGtleS12YWx1ZSBzdG9yZS5cbiAqIEBwcm9wZXJ0eSB7PEsgZXh0ZW5kcyBzdHJpbmc+KGtleTogSykgPT4gQ29tcGlsZURhdGFbS119IGdldERhdGFcbiAqICAgR2V0IGRhdGEgZnJvbSB0aGUga2V5LXZhbHVlIHN0b3JlLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQpID0+IHZvaWR9IGJ1ZmZlclxuICogICBDYXB0dXJlIHNvbWUgb2YgdGhlIG91dHB1dCBkYXRhLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQpID0+IHN0cmluZ30gcmVzdW1lXG4gKiAgIFN0b3AgY2FwdHVyaW5nIGFuZCBhY2Nlc3MgdGhlIG91dHB1dCBkYXRhLlxuICogQHByb3BlcnR5IHs8TiBleHRlbmRzIE5vZGU+KHRoaXM6IENvbXBpbGVDb250ZXh0LCBub2RlOiBOLCB0b2tlbjogVG9rZW4sIG9uRXJyb3I/OiBPbkVudGVyRXJyb3IpID0+IE59IGVudGVyXG4gKiAgIEVudGVyIGEgdG9rZW4uXG4gKiBAcHJvcGVydHkgeyh0aGlzOiBDb21waWxlQ29udGV4dCwgdG9rZW46IFRva2VuLCBvbkVycm9yPzogT25FeGl0RXJyb3IpID0+IE5vZGV9IGV4aXRcbiAqICAgRXhpdCBhIHRva2VuLlxuICogQHByb3BlcnR5IHtUb2tlbml6ZUNvbnRleHRbJ3NsaWNlU2VyaWFsaXplJ119IHNsaWNlU2VyaWFsaXplXG4gKiAgIEdldCB0aGUgc3RyaW5nIHZhbHVlIG9mIGEgdG9rZW4uXG4gKiBAcHJvcGVydHkge05vcm1hbGl6ZWRFeHRlbnNpb259IGNvbmZpZ1xuICogICBDb25maWd1cmF0aW9uLlxuICpcbiAqIEB0eXBlZGVmIHt7bWRhc3RFeHRlbnNpb25zPzogQXJyYXk8RXh0ZW5zaW9ufEFycmF5PEV4dGVuc2lvbj4+fX0gRnJvbU1hcmtkb3duT3B0aW9uc1xuICogQHR5cGVkZWYge1BhcnNlT3B0aW9ucyAmIEZyb21NYXJrZG93bk9wdGlvbnN9IE9wdGlvbnNcbiAqL1xuaW1wb3J0IHt0b1N0cmluZ30gZnJvbSAnbWRhc3QtdXRpbC10by1zdHJpbmcnXG5pbXBvcnQge3BhcnNlfSBmcm9tICdtaWNyb21hcmsvbGliL3BhcnNlLmpzJ1xuaW1wb3J0IHtwcmVwcm9jZXNzfSBmcm9tICdtaWNyb21hcmsvbGliL3ByZXByb2Nlc3MuanMnXG5pbXBvcnQge3Bvc3Rwcm9jZXNzfSBmcm9tICdtaWNyb21hcmsvbGliL3Bvc3Rwcm9jZXNzLmpzJ1xuaW1wb3J0IHtkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1kZWNvZGUtbnVtZXJpYy1jaGFyYWN0ZXItcmVmZXJlbmNlJ1xuaW1wb3J0IHtkZWNvZGVTdHJpbmd9IGZyb20gJ21pY3JvbWFyay11dGlsLWRlY29kZS1zdHJpbmcnXG5pbXBvcnQge25vcm1hbGl6ZUlkZW50aWZpZXJ9IGZyb20gJ21pY3JvbWFyay11dGlsLW5vcm1hbGl6ZS1pZGVudGlmaWVyJ1xuaW1wb3J0IHtkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZX0gZnJvbSAnZGVjb2RlLW5hbWVkLWNoYXJhY3Rlci1yZWZlcmVuY2UnXG5pbXBvcnQge3N0cmluZ2lmeVBvc2l0aW9ufSBmcm9tICd1bmlzdC11dGlsLXN0cmluZ2lmeS1wb3NpdGlvbidcbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG4vKipcbiAqIEBwYXJhbSB2YWx1ZSBNYXJrZG93biB0byBwYXJzZSAoYHN0cmluZ2Agb3IgYEJ1ZmZlcmApLlxuICogQHBhcmFtIFtlbmNvZGluZ10gQ2hhcmFjdGVyIGVuY29kaW5nIHRvIHVuZGVyc3RhbmQgYHZhbHVlYCBhcyB3aGVuIGl0XHUyMDE5cyBhIGBCdWZmZXJgIChgc3RyaW5nYCwgZGVmYXVsdDogYCd1dGY4J2ApLlxuICogQHBhcmFtIFtvcHRpb25zXSBDb25maWd1cmF0aW9uXG4gKi9cblxuZXhwb3J0IGNvbnN0IGZyb21NYXJrZG93biA9XG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICgodmFsdWU6IFZhbHVlLCBlbmNvZGluZzogRW5jb2RpbmcsIG9wdGlvbnM/OiBPcHRpb25zKSA9PiBSb290KSAmXG4gICAqICAgKCh2YWx1ZTogVmFsdWUsIG9wdGlvbnM/OiBPcHRpb25zKSA9PiBSb290KVxuICAgKiApfVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtWYWx1ZX0gdmFsdWVcbiAgICogQHBhcmFtIHtFbmNvZGluZ30gW2VuY29kaW5nXVxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7Um9vdH1cbiAgICovXG4gIGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IGVuY29kaW5nXG4gICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHJldHVybiBjb21waWxlcihvcHRpb25zKShcbiAgICAgIHBvc3Rwcm9jZXNzKFxuICAgICAgICBwYXJzZShvcHRpb25zKS5kb2N1bWVudCgpLndyaXRlKHByZXByb2Nlc3MoKSh2YWx1ZSwgZW5jb2RpbmcsIHRydWUpKVxuICAgICAgKVxuICAgIClcbiAgfVxuLyoqXG4gKiBOb3RlIHRoaXMgY29tcGlsZXIgb25seSB1bmRlcnN0YW5kIGNvbXBsZXRlIGJ1ZmZlcmluZywgbm90IHN0cmVhbWluZy5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVyKG9wdGlvbnMgPSB7fSkge1xuICAvKiogQHR5cGUge05vcm1hbGl6ZWRFeHRlbnNpb259ICovXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IG91ciBiYXNlIGhhcyBhbGwgcmVxdWlyZWQgZmllbGRzLCBzbyB0aGUgcmVzdWx0IHdpbGwgdG9vLlxuICBjb25zdCBjb25maWcgPSBjb25maWd1cmUoXG4gICAge1xuICAgICAgdHJhbnNmb3JtczogW10sXG4gICAgICBjYW5Db250YWluRW9sczogW1xuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAnZnJhZ21lbnQnLFxuICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICdwYXJhZ3JhcGgnLFxuICAgICAgICAnc3Ryb25nJ1xuICAgICAgXSxcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGF1dG9saW5rOiBvcGVuZXIobGluayksXG4gICAgICAgIGF1dG9saW5rUHJvdG9jb2w6IG9uZW50ZXJkYXRhLFxuICAgICAgICBhdXRvbGlua0VtYWlsOiBvbmVudGVyZGF0YSxcbiAgICAgICAgYXR4SGVhZGluZzogb3BlbmVyKGhlYWRpbmcpLFxuICAgICAgICBibG9ja1F1b3RlOiBvcGVuZXIoYmxvY2tRdW90ZSksXG4gICAgICAgIGNoYXJhY3RlckVzY2FwZTogb25lbnRlcmRhdGEsXG4gICAgICAgIGNoYXJhY3RlclJlZmVyZW5jZTogb25lbnRlcmRhdGEsXG4gICAgICAgIGNvZGVGZW5jZWQ6IG9wZW5lcihjb2RlRmxvdyksXG4gICAgICAgIGNvZGVGZW5jZWRGZW5jZUluZm86IGJ1ZmZlcixcbiAgICAgICAgY29kZUZlbmNlZEZlbmNlTWV0YTogYnVmZmVyLFxuICAgICAgICBjb2RlSW5kZW50ZWQ6IG9wZW5lcihjb2RlRmxvdywgYnVmZmVyKSxcbiAgICAgICAgY29kZVRleHQ6IG9wZW5lcihjb2RlVGV4dCwgYnVmZmVyKSxcbiAgICAgICAgY29kZVRleHREYXRhOiBvbmVudGVyZGF0YSxcbiAgICAgICAgZGF0YTogb25lbnRlcmRhdGEsXG4gICAgICAgIGNvZGVGbG93VmFsdWU6IG9uZW50ZXJkYXRhLFxuICAgICAgICBkZWZpbml0aW9uOiBvcGVuZXIoZGVmaW5pdGlvbiksXG4gICAgICAgIGRlZmluaXRpb25EZXN0aW5hdGlvblN0cmluZzogYnVmZmVyLFxuICAgICAgICBkZWZpbml0aW9uTGFiZWxTdHJpbmc6IGJ1ZmZlcixcbiAgICAgICAgZGVmaW5pdGlvblRpdGxlU3RyaW5nOiBidWZmZXIsXG4gICAgICAgIGVtcGhhc2lzOiBvcGVuZXIoZW1waGFzaXMpLFxuICAgICAgICBoYXJkQnJlYWtFc2NhcGU6IG9wZW5lcihoYXJkQnJlYWspLFxuICAgICAgICBoYXJkQnJlYWtUcmFpbGluZzogb3BlbmVyKGhhcmRCcmVhayksXG4gICAgICAgIGh0bWxGbG93OiBvcGVuZXIoaHRtbCwgYnVmZmVyKSxcbiAgICAgICAgaHRtbEZsb3dEYXRhOiBvbmVudGVyZGF0YSxcbiAgICAgICAgaHRtbFRleHQ6IG9wZW5lcihodG1sLCBidWZmZXIpLFxuICAgICAgICBodG1sVGV4dERhdGE6IG9uZW50ZXJkYXRhLFxuICAgICAgICBpbWFnZTogb3BlbmVyKGltYWdlKSxcbiAgICAgICAgbGFiZWw6IGJ1ZmZlcixcbiAgICAgICAgbGluazogb3BlbmVyKGxpbmspLFxuICAgICAgICBsaXN0SXRlbTogb3BlbmVyKGxpc3RJdGVtKSxcbiAgICAgICAgbGlzdEl0ZW1WYWx1ZTogb25lbnRlcmxpc3RpdGVtdmFsdWUsXG4gICAgICAgIGxpc3RPcmRlcmVkOiBvcGVuZXIobGlzdCwgb25lbnRlcmxpc3RvcmRlcmVkKSxcbiAgICAgICAgbGlzdFVub3JkZXJlZDogb3BlbmVyKGxpc3QpLFxuICAgICAgICBwYXJhZ3JhcGg6IG9wZW5lcihwYXJhZ3JhcGgpLFxuICAgICAgICByZWZlcmVuY2U6IG9uZW50ZXJyZWZlcmVuY2UsXG4gICAgICAgIHJlZmVyZW5jZVN0cmluZzogYnVmZmVyLFxuICAgICAgICByZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nOiBidWZmZXIsXG4gICAgICAgIHJlc291cmNlVGl0bGVTdHJpbmc6IGJ1ZmZlcixcbiAgICAgICAgc2V0ZXh0SGVhZGluZzogb3BlbmVyKGhlYWRpbmcpLFxuICAgICAgICBzdHJvbmc6IG9wZW5lcihzdHJvbmcpLFxuICAgICAgICB0aGVtYXRpY0JyZWFrOiBvcGVuZXIodGhlbWF0aWNCcmVhaylcbiAgICAgIH0sXG4gICAgICBleGl0OiB7XG4gICAgICAgIGF0eEhlYWRpbmc6IGNsb3NlcigpLFxuICAgICAgICBhdHhIZWFkaW5nU2VxdWVuY2U6IG9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSxcbiAgICAgICAgYXV0b2xpbms6IGNsb3NlcigpLFxuICAgICAgICBhdXRvbGlua0VtYWlsOiBvbmV4aXRhdXRvbGlua2VtYWlsLFxuICAgICAgICBhdXRvbGlua1Byb3RvY29sOiBvbmV4aXRhdXRvbGlua3Byb3RvY29sLFxuICAgICAgICBibG9ja1F1b3RlOiBjbG9zZXIoKSxcbiAgICAgICAgY2hhcmFjdGVyRXNjYXBlVmFsdWU6IG9uZXhpdGRhdGEsXG4gICAgICAgIGNoYXJhY3RlclJlZmVyZW5jZU1hcmtlckhleGFkZWNpbWFsOiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIsXG4gICAgICAgIGNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWM6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlcixcbiAgICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWU6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZXZhbHVlLFxuICAgICAgICBjb2RlRmVuY2VkOiBjbG9zZXIob25leGl0Y29kZWZlbmNlZCksXG4gICAgICAgIGNvZGVGZW5jZWRGZW5jZTogb25leGl0Y29kZWZlbmNlZGZlbmNlLFxuICAgICAgICBjb2RlRmVuY2VkRmVuY2VJbmZvOiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VpbmZvLFxuICAgICAgICBjb2RlRmVuY2VkRmVuY2VNZXRhOiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VtZXRhLFxuICAgICAgICBjb2RlRmxvd1ZhbHVlOiBvbmV4aXRkYXRhLFxuICAgICAgICBjb2RlSW5kZW50ZWQ6IGNsb3NlcihvbmV4aXRjb2RlaW5kZW50ZWQpLFxuICAgICAgICBjb2RlVGV4dDogY2xvc2VyKG9uZXhpdGNvZGV0ZXh0KSxcbiAgICAgICAgY29kZVRleHREYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgICBkYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgICBkZWZpbml0aW9uOiBjbG9zZXIoKSxcbiAgICAgICAgZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nOiBvbmV4aXRkZWZpbml0aW9uZGVzdGluYXRpb25zdHJpbmcsXG4gICAgICAgIGRlZmluaXRpb25MYWJlbFN0cmluZzogb25leGl0ZGVmaW5pdGlvbmxhYmVsc3RyaW5nLFxuICAgICAgICBkZWZpbml0aW9uVGl0bGVTdHJpbmc6IG9uZXhpdGRlZmluaXRpb250aXRsZXN0cmluZyxcbiAgICAgICAgZW1waGFzaXM6IGNsb3NlcigpLFxuICAgICAgICBoYXJkQnJlYWtFc2NhcGU6IGNsb3NlcihvbmV4aXRoYXJkYnJlYWspLFxuICAgICAgICBoYXJkQnJlYWtUcmFpbGluZzogY2xvc2VyKG9uZXhpdGhhcmRicmVhayksXG4gICAgICAgIGh0bWxGbG93OiBjbG9zZXIob25leGl0aHRtbGZsb3cpLFxuICAgICAgICBodG1sRmxvd0RhdGE6IG9uZXhpdGRhdGEsXG4gICAgICAgIGh0bWxUZXh0OiBjbG9zZXIob25leGl0aHRtbHRleHQpLFxuICAgICAgICBodG1sVGV4dERhdGE6IG9uZXhpdGRhdGEsXG4gICAgICAgIGltYWdlOiBjbG9zZXIob25leGl0aW1hZ2UpLFxuICAgICAgICBsYWJlbDogb25leGl0bGFiZWwsXG4gICAgICAgIGxhYmVsVGV4dDogb25leGl0bGFiZWx0ZXh0LFxuICAgICAgICBsaW5lRW5kaW5nOiBvbmV4aXRsaW5lZW5kaW5nLFxuICAgICAgICBsaW5rOiBjbG9zZXIob25leGl0bGluayksXG4gICAgICAgIGxpc3RJdGVtOiBjbG9zZXIoKSxcbiAgICAgICAgbGlzdE9yZGVyZWQ6IGNsb3NlcigpLFxuICAgICAgICBsaXN0VW5vcmRlcmVkOiBjbG9zZXIoKSxcbiAgICAgICAgcGFyYWdyYXBoOiBjbG9zZXIoKSxcbiAgICAgICAgcmVmZXJlbmNlU3RyaW5nOiBvbmV4aXRyZWZlcmVuY2VzdHJpbmcsXG4gICAgICAgIHJlc291cmNlRGVzdGluYXRpb25TdHJpbmc6IG9uZXhpdHJlc291cmNlZGVzdGluYXRpb25zdHJpbmcsXG4gICAgICAgIHJlc291cmNlVGl0bGVTdHJpbmc6IG9uZXhpdHJlc291cmNldGl0bGVzdHJpbmcsXG4gICAgICAgIHJlc291cmNlOiBvbmV4aXRyZXNvdXJjZSxcbiAgICAgICAgc2V0ZXh0SGVhZGluZzogY2xvc2VyKG9uZXhpdHNldGV4dGhlYWRpbmcpLFxuICAgICAgICBzZXRleHRIZWFkaW5nTGluZVNlcXVlbmNlOiBvbmV4aXRzZXRleHRoZWFkaW5nbGluZXNlcXVlbmNlLFxuICAgICAgICBzZXRleHRIZWFkaW5nVGV4dDogb25leGl0c2V0ZXh0aGVhZGluZ3RleHQsXG4gICAgICAgIHN0cm9uZzogY2xvc2VyKCksXG4gICAgICAgIHRoZW1hdGljQnJlYWs6IGNsb3NlcigpXG4gICAgICB9XG4gICAgfSxcbiAgICBvcHRpb25zLm1kYXN0RXh0ZW5zaW9ucyB8fCBbXVxuICApXG4gIC8qKiBAdHlwZSB7Q29tcGlsZURhdGF9ICovXG5cbiAgY29uc3QgZGF0YSA9IHt9XG4gIHJldHVybiBjb21waWxlXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4gICAqIEByZXR1cm5zIHtSb290fVxuICAgKi9cblxuICBmdW5jdGlvbiBjb21waWxlKGV2ZW50cykge1xuICAgIC8qKiBAdHlwZSB7Um9vdH0gKi9cbiAgICBsZXQgdHJlZSA9IHtcbiAgICAgIHR5cGU6ICdyb290JyxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgICAvKiogQHR5cGUge0NvbXBpbGVDb250ZXh0WydzdGFjayddfSAqL1xuXG4gICAgY29uc3Qgc3RhY2sgPSBbdHJlZV1cbiAgICAvKiogQHR5cGUge0NvbXBpbGVDb250ZXh0Wyd0b2tlblN0YWNrJ119ICovXG5cbiAgICBjb25zdCB0b2tlblN0YWNrID0gW11cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG5cbiAgICBjb25zdCBsaXN0U3RhY2sgPSBbXVxuICAgIC8qKiBAdHlwZSB7T21pdDxDb21waWxlQ29udGV4dCwgJ3NsaWNlU2VyaWFsaXplJz59ICovXG5cbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgc3RhY2ssXG4gICAgICB0b2tlblN0YWNrLFxuICAgICAgY29uZmlnLFxuICAgICAgZW50ZXIsXG4gICAgICBleGl0LFxuICAgICAgYnVmZmVyLFxuICAgICAgcmVzdW1lLFxuICAgICAgc2V0RGF0YSxcbiAgICAgIGdldERhdGFcbiAgICB9XG4gICAgbGV0IGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgICAgLy8gV2UgcHJlcHJvY2VzcyBsaXN0cyB0byBhZGQgYGxpc3RJdGVtYCB0b2tlbnMsIGFuZCB0byBpbmZlciB3aGV0aGVyXG4gICAgICAvLyBpdGVtcyB0aGUgbGlzdCBpdHNlbGYgYXJlIHNwcmVhZCBvdXQuXG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ2xpc3RPcmRlcmVkJyB8fFxuICAgICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdsaXN0VW5vcmRlcmVkJ1xuICAgICAgKSB7XG4gICAgICAgIGlmIChldmVudHNbaW5kZXhdWzBdID09PSAnZW50ZXInKSB7XG4gICAgICAgICAgbGlzdFN0YWNrLnB1c2goaW5kZXgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGFpbCA9IGxpc3RTdGFjay5wb3AoKVxuICAgICAgICAgIGluZGV4ID0gcHJlcGFyZUxpc3QoZXZlbnRzLCB0YWlsLCBpbmRleClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGNvbmZpZ1tldmVudHNbaW5kZXhdWzBdXVxuXG4gICAgICBpZiAob3duLmNhbGwoaGFuZGxlciwgZXZlbnRzW2luZGV4XVsxXS50eXBlKSkge1xuICAgICAgICBoYW5kbGVyW2V2ZW50c1tpbmRleF1bMV0udHlwZV0uY2FsbChcbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzbGljZVNlcmlhbGl6ZTogZXZlbnRzW2luZGV4XVsyXS5zbGljZVNlcmlhbGl6ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICApLFxuICAgICAgICAgIGV2ZW50c1tpbmRleF1bMV1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlblN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRhaWwgPSB0b2tlblN0YWNrW3Rva2VuU3RhY2subGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0YWlsWzFdIHx8IGRlZmF1bHRPbkVycm9yXG4gICAgICBoYW5kbGVyLmNhbGwoY29udGV4dCwgdW5kZWZpbmVkLCB0YWlsWzBdKVxuICAgIH0gLy8gRmlndXJlIG91dCBgcm9vdGAgcG9zaXRpb24uXG5cbiAgICB0cmVlLnBvc2l0aW9uID0ge1xuICAgICAgc3RhcnQ6IHBvaW50KFxuICAgICAgICBldmVudHMubGVuZ3RoID4gMFxuICAgICAgICAgID8gZXZlbnRzWzBdWzFdLnN0YXJ0XG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIGxpbmU6IDEsXG4gICAgICAgICAgICAgIGNvbHVtbjogMSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICB9XG4gICAgICApLFxuICAgICAgZW5kOiBwb2ludChcbiAgICAgICAgZXZlbnRzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMl1bMV0uZW5kXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIGxpbmU6IDEsXG4gICAgICAgICAgICAgIGNvbHVtbjogMSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICB9XG4gICAgICApXG4gICAgfVxuICAgIGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgY29uZmlnLnRyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgICB0cmVlID0gY29uZmlnLnRyYW5zZm9ybXNbaW5kZXhdKHRyZWUpIHx8IHRyZWVcbiAgICB9XG5cbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHByZXBhcmVMaXN0KGV2ZW50cywgc3RhcnQsIGxlbmd0aCkge1xuICAgIGxldCBpbmRleCA9IHN0YXJ0IC0gMVxuICAgIGxldCBjb250YWluZXJCYWxhbmNlID0gLTFcbiAgICBsZXQgbGlzdFNwcmVhZCA9IGZhbHNlXG4gICAgLyoqIEB0eXBlIHtUb2tlbnx1bmRlZmluZWR9ICovXG5cbiAgICBsZXQgbGlzdEl0ZW1cbiAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG5cbiAgICBsZXQgbGluZUluZGV4XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuXG4gICAgbGV0IGZpcnN0QmxhbmtMaW5lSW5kZXhcbiAgICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gICAgbGV0IGF0TWFya2VyXG5cbiAgICB3aGlsZSAoKytpbmRleCA8PSBsZW5ndGgpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2luZGV4XVxuXG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50WzFdLnR5cGUgPT09ICdsaXN0VW5vcmRlcmVkJyB8fFxuICAgICAgICBldmVudFsxXS50eXBlID09PSAnbGlzdE9yZGVyZWQnIHx8XG4gICAgICAgIGV2ZW50WzFdLnR5cGUgPT09ICdibG9ja1F1b3RlJ1xuICAgICAgKSB7XG4gICAgICAgIGlmIChldmVudFswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgIGNvbnRhaW5lckJhbGFuY2UrK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lckJhbGFuY2UtLVxuICAgICAgICB9XG5cbiAgICAgICAgYXRNYXJrZXIgPSB1bmRlZmluZWRcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRbMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmdCbGFuaycpIHtcbiAgICAgICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGlzdEl0ZW0gJiZcbiAgICAgICAgICAgICFhdE1hcmtlciAmJlxuICAgICAgICAgICAgIWNvbnRhaW5lckJhbGFuY2UgJiZcbiAgICAgICAgICAgICFmaXJzdEJsYW5rTGluZUluZGV4XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBmaXJzdEJsYW5rTGluZUluZGV4ID0gaW5kZXhcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdE1hcmtlciA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBldmVudFsxXS50eXBlID09PSAnbGluZVByZWZpeCcgfHxcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gJ2xpc3RJdGVtVmFsdWUnIHx8XG4gICAgICAgIGV2ZW50WzFdLnR5cGUgPT09ICdsaXN0SXRlbU1hcmtlcicgfHxcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gJ2xpc3RJdGVtUHJlZml4JyB8fFxuICAgICAgICBldmVudFsxXS50eXBlID09PSAnbGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlJ1xuICAgICAgKSB7XG4gICAgICAgIC8vIEVtcHR5LlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXRNYXJrZXIgPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAoIWNvbnRhaW5lckJhbGFuY2UgJiZcbiAgICAgICAgICBldmVudFswXSA9PT0gJ2VudGVyJyAmJlxuICAgICAgICAgIGV2ZW50WzFdLnR5cGUgPT09ICdsaXN0SXRlbVByZWZpeCcpIHx8XG4gICAgICAgIChjb250YWluZXJCYWxhbmNlID09PSAtMSAmJlxuICAgICAgICAgIGV2ZW50WzBdID09PSAnZXhpdCcgJiZcbiAgICAgICAgICAoZXZlbnRbMV0udHlwZSA9PT0gJ2xpc3RVbm9yZGVyZWQnIHx8XG4gICAgICAgICAgICBldmVudFsxXS50eXBlID09PSAnbGlzdE9yZGVyZWQnKSlcbiAgICAgICkge1xuICAgICAgICBpZiAobGlzdEl0ZW0pIHtcbiAgICAgICAgICBsZXQgdGFpbEluZGV4ID0gaW5kZXhcbiAgICAgICAgICBsaW5lSW5kZXggPSB1bmRlZmluZWRcblxuICAgICAgICAgIHdoaWxlICh0YWlsSW5kZXgtLSkge1xuICAgICAgICAgICAgY29uc3QgdGFpbEV2ZW50ID0gZXZlbnRzW3RhaWxJbmRleF1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmcnIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSAnbGluZUVuZGluZ0JsYW5rJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICh0YWlsRXZlbnRbMF0gPT09ICdleGl0JykgY29udGludWVcblxuICAgICAgICAgICAgICBpZiAobGluZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzW2xpbmVJbmRleF1bMV0udHlwZSA9ICdsaW5lRW5kaW5nQmxhbmsnXG4gICAgICAgICAgICAgICAgbGlzdFNwcmVhZCA9IHRydWVcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID0gJ2xpbmVFbmRpbmcnXG4gICAgICAgICAgICAgIGxpbmVJbmRleCA9IHRhaWxJbmRleFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09ICdsaW5lUHJlZml4JyB8fFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gJ2Jsb2NrUXVvdGVQcmVmaXgnIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSAnYmxvY2tRdW90ZVByZWZpeFdoaXRlc3BhY2UnIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSAnYmxvY2tRdW90ZU1hcmtlcicgfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09ICdsaXN0SXRlbUluZGVudCdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBFbXB0eVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmaXJzdEJsYW5rTGluZUluZGV4ICYmXG4gICAgICAgICAgICAoIWxpbmVJbmRleCB8fCBmaXJzdEJsYW5rTGluZUluZGV4IDwgbGluZUluZGV4KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQYXRjaGVkLlxuICAgICAgICAgICAgbGlzdEl0ZW0uX3NwcmVhZCA9IHRydWVcbiAgICAgICAgICB9IC8vIEZpeCBwb3NpdGlvbi5cblxuICAgICAgICAgIGxpc3RJdGVtLmVuZCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGxpbmVJbmRleCA/IGV2ZW50c1tsaW5lSW5kZXhdWzFdLnN0YXJ0IDogZXZlbnRbMV0uZW5kXG4gICAgICAgICAgKVxuICAgICAgICAgIGV2ZW50cy5zcGxpY2UobGluZUluZGV4IHx8IGluZGV4LCAwLCBbJ2V4aXQnLCBsaXN0SXRlbSwgZXZlbnRbMl1dKVxuICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICBsZW5ndGgrK1xuICAgICAgICB9IC8vIENyZWF0ZSBhIG5ldyBsaXN0IGl0ZW0uXG5cbiAgICAgICAgaWYgKGV2ZW50WzFdLnR5cGUgPT09ICdsaXN0SXRlbVByZWZpeCcpIHtcbiAgICAgICAgICBsaXN0SXRlbSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0SXRlbScsXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhdGNoZWRcbiAgICAgICAgICAgIF9zcHJlYWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50WzFdLnN0YXJ0KVxuICAgICAgICAgIH0gLy8gQHRzLWV4cGVjdC1lcnJvcjogYGxpc3RJdGVtYCBpcyBtb3N0IGRlZmluaXRlbHkgZGVmaW5lZCwgVFMuLi5cblxuICAgICAgICAgIGV2ZW50cy5zcGxpY2UoaW5kZXgsIDAsIFsnZW50ZXInLCBsaXN0SXRlbSwgZXZlbnRbMl1dKVxuICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICBsZW5ndGgrK1xuICAgICAgICAgIGZpcnN0QmxhbmtMaW5lSW5kZXggPSB1bmRlZmluZWRcbiAgICAgICAgICBhdE1hcmtlciA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQHRzLWV4cGVjdC1lcnJvciBQYXRjaGVkLlxuXG4gICAgZXZlbnRzW3N0YXJ0XVsxXS5fc3ByZWFkID0gbGlzdFNwcmVhZFxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0NvbXBpbGVDb250ZXh0WydzZXREYXRhJ119XG4gICAqIEBwYXJhbSBbdmFsdWVdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNldERhdGEoa2V5LCB2YWx1ZSkge1xuICAgIGRhdGFba2V5XSA9IHZhbHVlXG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtDb21waWxlQ29udGV4dFsnZ2V0RGF0YSddfVxuICAgKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICAgKiBAcGFyYW0ge0t9IGtleVxuICAgKiBAcmV0dXJucyB7Q29tcGlsZURhdGFbS119XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldERhdGEoa2V5KSB7XG4gICAgcmV0dXJuIGRhdGFba2V5XVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50fSBkXG4gICAqIEByZXR1cm5zIHtQb2ludH1cbiAgICovXG5cbiAgZnVuY3Rpb24gcG9pbnQoZCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBkLmxpbmUsXG4gICAgICBjb2x1bW46IGQuY29sdW1uLFxuICAgICAgb2Zmc2V0OiBkLm9mZnNldFxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsodG9rZW46IFRva2VuKSA9PiBOb2RlfSBjcmVhdGVcbiAgICogQHBhcmFtIHtIYW5kbGV9IFthbmRdXG4gICAqIEByZXR1cm5zIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9wZW5lcihjcmVhdGUsIGFuZCkge1xuICAgIHJldHVybiBvcGVuXG4gICAgLyoqXG4gICAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBvcGVuKHRva2VuKSB7XG4gICAgICBlbnRlci5jYWxsKHRoaXMsIGNyZWF0ZSh0b2tlbiksIHRva2VuKVxuICAgICAgaWYgKGFuZCkgYW5kLmNhbGwodGhpcywgdG9rZW4pXG4gICAgfVxuICB9XG4gIC8qKiBAdHlwZSB7Q29tcGlsZUNvbnRleHRbJ2J1ZmZlciddfSAqL1xuXG4gIGZ1bmN0aW9uIGJ1ZmZlcigpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgdHlwZTogJ2ZyYWdtZW50JyxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0pXG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtDb21waWxlQ29udGV4dFsnZW50ZXInXX1cbiAgICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHBhcmFtIHtOfSBub2RlXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqIEBwYXJhbSB7T25FbnRlckVycm9yfSBbZXJyb3JIYW5kbGVyXVxuICAgKiBAcmV0dXJucyB7Tn1cbiAgICovXG5cbiAgZnVuY3Rpb24gZW50ZXIobm9kZSwgdG9rZW4sIGVycm9ySGFuZGxlcikge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEFzc3VtZSBgTm9kZWAgY2FuIGV4aXN0IGFzIGEgY2hpbGQgb2YgYHBhcmVudGAuXG4gICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSlcbiAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSlcbiAgICB0aGlzLnRva2VuU3RhY2sucHVzaChbdG9rZW4sIGVycm9ySGFuZGxlcl0pIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBlbmRgIHdpbGwgYmUgcGF0Y2hlZCBsYXRlci5cblxuICAgIG5vZGUucG9zaXRpb24gPSB7XG4gICAgICBzdGFydDogcG9pbnQodG9rZW4uc3RhcnQpXG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7SGFuZGxlfSBbYW5kXVxuICAgKiBAcmV0dXJucyB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBjbG9zZXIoYW5kKSB7XG4gICAgcmV0dXJuIGNsb3NlXG4gICAgLyoqXG4gICAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjbG9zZSh0b2tlbikge1xuICAgICAgaWYgKGFuZCkgYW5kLmNhbGwodGhpcywgdG9rZW4pXG4gICAgICBleGl0LmNhbGwodGhpcywgdG9rZW4pXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7Q29tcGlsZUNvbnRleHRbJ2V4aXQnXX1cbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiBAcGFyYW0ge09uRXhpdEVycm9yfSBbb25FeGl0RXJyb3JdXG4gICAqIEByZXR1cm5zIHtOb2RlfVxuICAgKi9cblxuICBmdW5jdGlvbiBleGl0KHRva2VuLCBvbkV4aXRFcnJvcikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpXG4gICAgY29uc3Qgb3BlbiA9IHRoaXMudG9rZW5TdGFjay5wb3AoKVxuXG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgY2xvc2UgYCcgK1xuICAgICAgICAgIHRva2VuLnR5cGUgK1xuICAgICAgICAgICdgICgnICtcbiAgICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7XG4gICAgICAgICAgICBzdGFydDogdG9rZW4uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHRva2VuLmVuZFxuICAgICAgICAgIH0pICtcbiAgICAgICAgICAnKTogaXRcdTIwMTlzIG5vdCBvcGVuJ1xuICAgICAgKVxuICAgIH0gZWxzZSBpZiAob3BlblswXS50eXBlICE9PSB0b2tlbi50eXBlKSB7XG4gICAgICBpZiAob25FeGl0RXJyb3IpIHtcbiAgICAgICAgb25FeGl0RXJyb3IuY2FsbCh0aGlzLCB0b2tlbiwgb3BlblswXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBvcGVuWzFdIHx8IGRlZmF1bHRPbkVycm9yXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCB0b2tlbiwgb3BlblswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlLnBvc2l0aW9uLmVuZCA9IHBvaW50KHRva2VuLmVuZClcbiAgICByZXR1cm4gbm9kZVxuICB9XG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcodGhpcy5zdGFjay5wb3AoKSlcbiAgfSAvL1xuICAvLyBIYW5kbGVycy5cbiAgLy9cblxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmVudGVybGlzdG9yZGVyZWQoKSB7XG4gICAgc2V0RGF0YSgnZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlJywgdHJ1ZSlcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmVudGVybGlzdGl0ZW12YWx1ZSh0b2tlbikge1xuICAgIGlmIChnZXREYXRhKCdleHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWUnKSkge1xuICAgICAgY29uc3QgYW5jZXN0b3IgPVxuICAgICAgICAvKiogQHR5cGUge0xpc3R9ICovXG4gICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXVxuICAgICAgYW5jZXN0b3Iuc3RhcnQgPSBOdW1iZXIucGFyc2VJbnQodGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbiksIDEwKVxuICAgICAgc2V0RGF0YSgnZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlJylcbiAgICB9XG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlaW5mbygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHtDb2RlfSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgbm9kZS5sYW5nID0gZGF0YVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGVmZW5jZWRmZW5jZW1ldGEoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7Q29kZX0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUubWV0YSA9IGRhdGFcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkZmVuY2UoKSB7XG4gICAgLy8gRXhpdCBpZiB0aGlzIGlzIHRoZSBjbG9zaW5nIGZlbmNlLlxuICAgIGlmIChnZXREYXRhKCdmbG93Q29kZUluc2lkZScpKSByZXR1cm5cbiAgICB0aGlzLmJ1ZmZlcigpXG4gICAgc2V0RGF0YSgnZmxvd0NvZGVJbnNpZGUnLCB0cnVlKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGVmZW5jZWQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7Q29kZX0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUudmFsdWUgPSBkYXRhLnJlcGxhY2UoL14oXFxyP1xcbnxcXHIpfChcXHI/XFxufFxccikkL2csICcnKVxuICAgIHNldERhdGEoJ2Zsb3dDb2RlSW5zaWRlJylcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRjb2RlaW5kZW50ZWQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7Q29kZX0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUudmFsdWUgPSBkYXRhLnJlcGxhY2UoLyhcXHI/XFxufFxccikkL2csICcnKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb25sYWJlbHN0cmluZyh0b2tlbikge1xuICAgIC8vIERpc2NhcmQgbGFiZWwsIHVzZSB0aGUgc291cmNlIGNvbnRlbnQgaW5zdGVhZC5cbiAgICBjb25zdCBsYWJlbCA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7RGVmaW5pdGlvbn0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUubGFiZWwgPSBsYWJlbFxuICAgIG5vZGUuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoXG4gICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgICkudG9Mb3dlckNhc2UoKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb250aXRsZXN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHtEZWZpbml0aW9ufSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgbm9kZS50aXRsZSA9IGRhdGFcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRkZWZpbml0aW9uZGVzdGluYXRpb25zdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7RGVmaW5pdGlvbn0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUudXJsID0gZGF0YVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSh0b2tlbikge1xuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHtIZWFkaW5nfSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG5cbiAgICBpZiAoIW5vZGUuZGVwdGgpIHtcbiAgICAgIGNvbnN0IGRlcHRoID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbikubGVuZ3RoXG4gICAgICBub2RlLmRlcHRoID0gZGVwdGhcbiAgICB9XG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0c2V0ZXh0aGVhZGluZ3RleHQoKSB7XG4gICAgc2V0RGF0YSgnc2V0ZXh0SGVhZGluZ1NsdXJwTGluZUVuZGluZycsIHRydWUpXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0c2V0ZXh0aGVhZGluZ2xpbmVzZXF1ZW5jZSh0b2tlbikge1xuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHtIZWFkaW5nfSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgbm9kZS5kZXB0aCA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLmNoYXJDb2RlQXQoMCkgPT09IDYxID8gMSA6IDJcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRzZXRleHRoZWFkaW5nKCkge1xuICAgIHNldERhdGEoJ3NldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcnKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZW50ZXJkYXRhKHRva2VuKSB7XG4gICAgY29uc3QgcGFyZW50ID1cbiAgICAgIC8qKiBAdHlwZSB7UGFyZW50fSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuXG4gICAgbGV0IHRhaWwgPSBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdXG5cbiAgICBpZiAoIXRhaWwgfHwgdGFpbC50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgIC8vIEFkZCBhIG5ldyB0ZXh0IG5vZGUuXG4gICAgICB0YWlsID0gdGV4dCgpIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlXHUyMDE5bGwgYWRkIGBlbmRgIGxhdGVyLlxuXG4gICAgICB0YWlsLnBvc2l0aW9uID0ge1xuICAgICAgICBzdGFydDogcG9pbnQodG9rZW4uc3RhcnQpXG4gICAgICB9IC8vIEB0cy1leHBlY3QtZXJyb3I6IEFzc3VtZSBgcGFyZW50YCBhY2NlcHRzIGB0ZXh0YC5cblxuICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2godGFpbClcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2godGFpbClcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRkYXRhKHRva2VuKSB7XG4gICAgY29uc3QgdGFpbCA9IHRoaXMuc3RhY2sucG9wKClcbiAgICB0YWlsLnZhbHVlICs9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGluZWVuZGluZyh0b2tlbikge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cblxuICAgIC8vIElmIHdlXHUyMDE5cmUgYXQgYSBoYXJkIGJyZWFrLCBpbmNsdWRlIHRoZSBsaW5lIGVuZGluZyBpbiB0aGVyZS5cbiAgICBpZiAoZ2V0RGF0YSgnYXRIYXJkQnJlYWsnKSkge1xuICAgICAgY29uc3QgdGFpbCA9IGNvbnRleHQuY2hpbGRyZW5bY29udGV4dC5jaGlsZHJlbi5sZW5ndGggLSAxXVxuICAgICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gICAgICBzZXREYXRhKCdhdEhhcmRCcmVhaycpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhZ2V0RGF0YSgnc2V0ZXh0SGVhZGluZ1NsdXJwTGluZUVuZGluZycpICYmXG4gICAgICBjb25maWcuY2FuQ29udGFpbkVvbHMuaW5jbHVkZXMoY29udGV4dC50eXBlKVxuICAgICkge1xuICAgICAgb25lbnRlcmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICAgIG9uZXhpdGRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB9XG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0aGFyZGJyZWFrKCkge1xuICAgIHNldERhdGEoJ2F0SGFyZEJyZWFrJywgdHJ1ZSlcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRodG1sZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHtIVE1MfSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRodG1sdGV4dCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHtIVE1MfSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRjb2RldGV4dCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHtJbmxpbmVDb2RlfSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRsaW5rKCkge1xuICAgIGNvbnN0IGNvbnRleHQgPVxuICAgICAgLyoqIEB0eXBlIHtMaW5rICYge2lkZW50aWZpZXI6IHN0cmluZywgbGFiZWw6IHN0cmluZ319ICovXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gLy8gVG8gZG86IGNsZWFuLlxuXG4gICAgaWYgKGdldERhdGEoJ2luUmVmZXJlbmNlJykpIHtcbiAgICAgIGNvbnRleHQudHlwZSArPSAnUmVmZXJlbmNlJyAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG5cbiAgICAgIGNvbnRleHQucmVmZXJlbmNlVHlwZSA9IGdldERhdGEoJ3JlZmVyZW5jZVR5cGUnKSB8fCAnc2hvcnRjdXQnIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cblxuICAgICAgZGVsZXRlIGNvbnRleHQudXJsXG4gICAgICBkZWxldGUgY29udGV4dC50aXRsZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgY29udGV4dC5pZGVudGlmaWVyIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cblxuICAgICAgZGVsZXRlIGNvbnRleHQubGFiZWxcbiAgICB9XG5cbiAgICBzZXREYXRhKCdyZWZlcmVuY2VUeXBlJylcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRpbWFnZSgpIHtcbiAgICBjb25zdCBjb250ZXh0ID1cbiAgICAgIC8qKiBAdHlwZSB7SW1hZ2UgJiB7aWRlbnRpZmllcjogc3RyaW5nLCBsYWJlbDogc3RyaW5nfX0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSAvLyBUbyBkbzogY2xlYW4uXG5cbiAgICBpZiAoZ2V0RGF0YSgnaW5SZWZlcmVuY2UnKSkge1xuICAgICAgY29udGV4dC50eXBlICs9ICdSZWZlcmVuY2UnIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cblxuICAgICAgY29udGV4dC5yZWZlcmVuY2VUeXBlID0gZ2V0RGF0YSgncmVmZXJlbmNlVHlwZScpIHx8ICdzaG9ydGN1dCcgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuXG4gICAgICBkZWxldGUgY29udGV4dC51cmxcbiAgICAgIGRlbGV0ZSBjb250ZXh0LnRpdGxlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIGRlbGV0ZSBjb250ZXh0LmlkZW50aWZpZXIgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuXG4gICAgICBkZWxldGUgY29udGV4dC5sYWJlbFxuICAgIH1cblxuICAgIHNldERhdGEoJ3JlZmVyZW5jZVR5cGUnKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGxhYmVsdGV4dCh0b2tlbikge1xuICAgIGNvbnN0IGFuY2VzdG9yID1cbiAgICAgIC8qKiBAdHlwZSB7KExpbmt8SW1hZ2UpICYge2lkZW50aWZpZXI6IHN0cmluZywgbGFiZWw6IHN0cmluZ319ICovXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl1cbiAgICBjb25zdCBzdHJpbmcgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIGFuY2VzdG9yLmxhYmVsID0gZGVjb2RlU3RyaW5nKHN0cmluZylcbiAgICBhbmNlc3Rvci5pZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcihzdHJpbmcpLnRvTG93ZXJDYXNlKClcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRsYWJlbCgpIHtcbiAgICBjb25zdCBmcmFnbWVudCA9XG4gICAgICAvKiogQHR5cGUge0ZyYWdtZW50fSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9XG4gICAgICAvKiogQHR5cGUgeyhMaW5rfEltYWdlKSAmIHtpZGVudGlmaWVyOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmd9fSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdIC8vIEFzc3VtZSBhIHJlZmVyZW5jZS5cblxuICAgIHNldERhdGEoJ2luUmVmZXJlbmNlJywgdHJ1ZSlcblxuICAgIGlmIChub2RlLnR5cGUgPT09ICdsaW5rJykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogQXNzdW1lIHN0YXRpYyBwaHJhc2luZyBjb250ZW50LlxuICAgICAgbm9kZS5jaGlsZHJlbiA9IGZyYWdtZW50LmNoaWxkcmVuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYWx0ID0gdmFsdWVcbiAgICB9XG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVzb3VyY2VkZXN0aW5hdGlvbnN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHtMaW5rfEltYWdlfSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgbm9kZS51cmwgPSBkYXRhXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVzb3VyY2V0aXRsZXN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHtMaW5rfEltYWdlfSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgbm9kZS50aXRsZSA9IGRhdGFcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRyZXNvdXJjZSgpIHtcbiAgICBzZXREYXRhKCdpblJlZmVyZW5jZScpXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25lbnRlcnJlZmVyZW5jZSgpIHtcbiAgICBzZXREYXRhKCdyZWZlcmVuY2VUeXBlJywgJ2NvbGxhcHNlZCcpXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVmZXJlbmNlc3RyaW5nKHRva2VuKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9XG4gICAgICAvKiogQHR5cGUge0xpbmtSZWZlcmVuY2V8SW1hZ2VSZWZlcmVuY2V9ICovXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBub2RlLmxhYmVsID0gbGFiZWxcbiAgICBub2RlLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICApLnRvTG93ZXJDYXNlKClcbiAgICBzZXREYXRhKCdyZWZlcmVuY2VUeXBlJywgJ2Z1bGwnKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlcih0b2tlbikge1xuICAgIHNldERhdGEoJ2NoYXJhY3RlclJlZmVyZW5jZVR5cGUnLCB0b2tlbi50eXBlKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZXZhbHVlKHRva2VuKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgY29uc3QgdHlwZSA9IGdldERhdGEoJ2NoYXJhY3RlclJlZmVyZW5jZVR5cGUnKVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXG4gICAgbGV0IHZhbHVlXG5cbiAgICBpZiAodHlwZSkge1xuICAgICAgdmFsdWUgPSBkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlKFxuICAgICAgICBkYXRhLFxuICAgICAgICB0eXBlID09PSAnY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpYycgPyAxMCA6IDE2XG4gICAgICApXG4gICAgICBzZXREYXRhKCdjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlJylcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2VgIGNhbiByZXR1cm4gZmFsc2UgZm9yXG4gICAgICAvLyBpbnZhbGlkIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLCBidXQgZXZlcnl0aGluZyB3ZVx1MjAxOXZlIHRva2VuaXplZCBpc1xuICAgICAgLy8gdmFsaWQuXG4gICAgICB2YWx1ZSA9IGRlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlKGRhdGEpXG4gICAgfVxuXG4gICAgY29uc3QgdGFpbCA9IHRoaXMuc3RhY2sucG9wKClcbiAgICB0YWlsLnZhbHVlICs9IHZhbHVlXG4gICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0YXV0b2xpbmtwcm90b2NvbCh0b2tlbikge1xuICAgIG9uZXhpdGRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7TGlua30gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUudXJsID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRhdXRvbGlua2VtYWlsKHRva2VuKSB7XG4gICAgb25leGl0ZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHtMaW5rfSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgbm9kZS51cmwgPSAnbWFpbHRvOicgKyB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9IC8vXG4gIC8vIENyZWF0ZXJzLlxuICAvL1xuXG4gIC8qKiBAcmV0dXJucyB7QmxvY2txdW90ZX0gKi9cblxuICBmdW5jdGlvbiBibG9ja1F1b3RlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYmxvY2txdW90ZScsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9XG4gIH1cbiAgLyoqIEByZXR1cm5zIHtDb2RlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvZGVGbG93KCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnY29kZScsXG4gICAgICBsYW5nOiBudWxsLFxuICAgICAgbWV0YTogbnVsbCxcbiAgICAgIHZhbHVlOiAnJ1xuICAgIH1cbiAgfVxuICAvKiogQHJldHVybnMge0lubGluZUNvZGV9ICovXG5cbiAgZnVuY3Rpb24gY29kZVRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdpbmxpbmVDb2RlJyxcbiAgICAgIHZhbHVlOiAnJ1xuICAgIH1cbiAgfVxuICAvKiogQHJldHVybnMge0RlZmluaXRpb259ICovXG5cbiAgZnVuY3Rpb24gZGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2RlZmluaXRpb24nLFxuICAgICAgaWRlbnRpZmllcjogJycsXG4gICAgICBsYWJlbDogbnVsbCxcbiAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgdXJsOiAnJ1xuICAgIH1cbiAgfVxuICAvKiogQHJldHVybnMge0VtcGhhc2lzfSAqL1xuXG4gIGZ1bmN0aW9uIGVtcGhhc2lzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZW1waGFzaXMnLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG4gIC8qKiBAcmV0dXJucyB7SGVhZGluZ30gKi9cblxuICBmdW5jdGlvbiBoZWFkaW5nKCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGRlcHRoYCB3aWxsIGJlIHNldCBsYXRlci5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgZGVwdGg6IHVuZGVmaW5lZCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuICAvKiogQHJldHVybnMge0JyZWFrfSAqL1xuXG4gIGZ1bmN0aW9uIGhhcmRCcmVhaygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2JyZWFrJ1xuICAgIH1cbiAgfVxuICAvKiogQHJldHVybnMge0hUTUx9ICovXG5cbiAgZnVuY3Rpb24gaHRtbCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgdmFsdWU6ICcnXG4gICAgfVxuICB9XG4gIC8qKiBAcmV0dXJucyB7SW1hZ2V9ICovXG5cbiAgZnVuY3Rpb24gaW1hZ2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICB0aXRsZTogbnVsbCxcbiAgICAgIHVybDogJycsXG4gICAgICBhbHQ6IG51bGxcbiAgICB9XG4gIH1cbiAgLyoqIEByZXR1cm5zIHtMaW5rfSAqL1xuXG4gIGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgdXJsOiAnJyxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICogQHJldHVybnMge0xpc3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGxpc3QodG9rZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgb3JkZXJlZDogdG9rZW4udHlwZSA9PT0gJ2xpc3RPcmRlcmVkJyxcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQYXRjaGVkLlxuICAgICAgc3ByZWFkOiB0b2tlbi5fc3ByZWFkLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiBAcmV0dXJucyB7TGlzdEl0ZW19XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGxpc3RJdGVtKHRva2VuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaXN0SXRlbScsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhdGNoZWQuXG4gICAgICBzcHJlYWQ6IHRva2VuLl9zcHJlYWQsXG4gICAgICBjaGVja2VkOiBudWxsLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG4gIC8qKiBAcmV0dXJucyB7UGFyYWdyYXBofSAqL1xuXG4gIGZ1bmN0aW9uIHBhcmFncmFwaCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9XG4gIH1cbiAgLyoqIEByZXR1cm5zIHtTdHJvbmd9ICovXG5cbiAgZnVuY3Rpb24gc3Ryb25nKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnc3Ryb25nJyxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuICAvKiogQHJldHVybnMge1RleHR9ICovXG5cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgdmFsdWU6ICcnXG4gICAgfVxuICB9XG4gIC8qKiBAcmV0dXJucyB7VGhlbWF0aWNCcmVha30gKi9cblxuICBmdW5jdGlvbiB0aGVtYXRpY0JyZWFrKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAndGhlbWF0aWNCcmVhaydcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtFeHRlbnNpb259IGNvbWJpbmVkXG4gKiBAcGFyYW0ge0FycmF5PEV4dGVuc2lvbnxBcnJheTxFeHRlbnNpb24+Pn0gZXh0ZW5zaW9uc1xuICogQHJldHVybnMge0V4dGVuc2lvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb25maWd1cmUoY29tYmluZWQsIGV4dGVuc2lvbnMpIHtcbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb25zW2luZGV4XVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjb25maWd1cmUoY29tYmluZWQsIHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbnNpb24oY29tYmluZWQsIHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb21iaW5lZFxufVxuLyoqXG4gKiBAcGFyYW0ge0V4dGVuc2lvbn0gY29tYmluZWRcbiAqIEBwYXJhbSB7RXh0ZW5zaW9ufSBleHRlbnNpb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cbmZ1bmN0aW9uIGV4dGVuc2lvbihjb21iaW5lZCwgZXh0ZW5zaW9uKSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQga2V5XG5cbiAgZm9yIChrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgaWYgKG93bi5jYWxsKGV4dGVuc2lvbiwga2V5KSkge1xuICAgICAgY29uc3QgbGlzdCA9IGtleSA9PT0gJ2NhbkNvbnRhaW5Fb2xzJyB8fCBrZXkgPT09ICd0cmFuc2Zvcm1zJ1xuICAgICAgY29uc3QgbWF5YmUgPSBvd24uY2FsbChjb21iaW5lZCwga2V5KSA/IGNvbWJpbmVkW2tleV0gOiB1bmRlZmluZWRcbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG5cbiAgICAgIGNvbnN0IGxlZnQgPSBtYXliZSB8fCAoY29tYmluZWRba2V5XSA9IGxpc3QgPyBbXSA6IHt9KVxuICAgICAgY29uc3QgcmlnaHQgPSBleHRlbnNpb25ba2V5XVxuXG4gICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgbGVmdGAgaXMgYW4gYXJyYXkuXG4gICAgICAgICAgY29tYmluZWRba2V5XSA9IFsuLi5sZWZ0LCAuLi5yaWdodF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGxlZnQsIHJpZ2h0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKiogQHR5cGUge09uRW50ZXJFcnJvcn0gKi9cblxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IobGVmdCwgcmlnaHQpIHtcbiAgaWYgKGxlZnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2Fubm90IGNsb3NlIGAnICtcbiAgICAgICAgbGVmdC50eXBlICtcbiAgICAgICAgJ2AgKCcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7XG4gICAgICAgICAgc3RhcnQ6IGxlZnQuc3RhcnQsXG4gICAgICAgICAgZW5kOiBsZWZ0LmVuZFxuICAgICAgICB9KSArXG4gICAgICAgICcpOiBhIGRpZmZlcmVudCB0b2tlbiAoYCcgK1xuICAgICAgICByaWdodC50eXBlICtcbiAgICAgICAgJ2AsICcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7XG4gICAgICAgICAgc3RhcnQ6IHJpZ2h0LnN0YXJ0LFxuICAgICAgICAgIGVuZDogcmlnaHQuZW5kXG4gICAgICAgIH0pICtcbiAgICAgICAgJykgaXMgb3BlbidcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBjbG9zZSBkb2N1bWVudCwgYSB0b2tlbiAoYCcgK1xuICAgICAgICByaWdodC50eXBlICtcbiAgICAgICAgJ2AsICcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7XG4gICAgICAgICAgc3RhcnQ6IHJpZ2h0LnN0YXJ0LFxuICAgICAgICAgIGVuZDogcmlnaHQuZW5kXG4gICAgICAgIH0pICtcbiAgICAgICAgJykgaXMgc3RpbGwgb3BlbidcbiAgICApXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IG1hdGhGbG93ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVNYXRoRmVuY2VkLFxuICBjb25jcmV0ZTogdHJ1ZVxufVxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbmNvbnN0IG5vbkxhenlMaW5lID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVOb25MYXp5TGluZSxcbiAgcGFydGlhbDogdHJ1ZVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplTWF0aEZlbmNlZChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGNvbnN0IHRhaWwgPSBzZWxmLmV2ZW50c1tzZWxmLmV2ZW50cy5sZW5ndGggLSAxXVxuICBjb25zdCBpbml0aWFsU2l6ZSA9XG4gICAgdGFpbCAmJiB0YWlsWzFdLnR5cGUgPT09ICdsaW5lUHJlZml4J1xuICAgICAgPyB0YWlsWzJdLnNsaWNlU2VyaWFsaXplKHRhaWxbMV0sIHRydWUpLmxlbmd0aFxuICAgICAgOiAwXG4gIGxldCBzaXplT3BlbiA9IDBcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ21hdGhGbG93JylcbiAgICBlZmZlY3RzLmVudGVyKCdtYXRoRmxvd0ZlbmNlJylcbiAgICBlZmZlY3RzLmVudGVyKCdtYXRoRmxvd0ZlbmNlU2VxdWVuY2UnKVxuICAgIHJldHVybiBzZXF1ZW5jZU9wZW4oY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHNlcXVlbmNlT3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDM2KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHNpemVPcGVuKytcbiAgICAgIHJldHVybiBzZXF1ZW5jZU9wZW5cbiAgICB9XG5cbiAgICBlZmZlY3RzLmV4aXQoJ21hdGhGbG93RmVuY2VTZXF1ZW5jZScpXG4gICAgcmV0dXJuIHNpemVPcGVuIDwgMlxuICAgICAgPyBub2soY29kZSlcbiAgICAgIDogZmFjdG9yeVNwYWNlKGVmZmVjdHMsIG1ldGFPcGVuLCAnd2hpdGVzcGFjZScpKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBtZXRhT3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm4gb3BlbkFmdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignbWF0aEZsb3dGZW5jZU1ldGEnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2NodW5rU3RyaW5nJywge1xuICAgICAgY29udGVudFR5cGU6ICdzdHJpbmcnXG4gICAgfSlcbiAgICByZXR1cm4gbWV0YShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gbWV0YShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2NodW5rU3RyaW5nJylcbiAgICAgIGVmZmVjdHMuZXhpdCgnbWF0aEZsb3dGZW5jZU1ldGEnKVxuICAgICAgcmV0dXJuIG9wZW5BZnRlcihjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAzNikgcmV0dXJuIG5vayhjb2RlKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBtZXRhXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvcGVuQWZ0ZXIoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnbWF0aEZsb3dGZW5jZScpXG4gICAgcmV0dXJuIHNlbGYuaW50ZXJydXB0ID8gb2soY29kZSkgOiBjb250ZW50U3RhcnQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRlbnRTdGFydChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBhZnRlcihjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgIG5vbkxhenlMaW5lLFxuICAgICAgICBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdG9rZW5pemU6IHRva2VuaXplQ2xvc2luZ0ZlbmNlLFxuICAgICAgICAgICAgcGFydGlhbDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWZ0ZXIsXG4gICAgICAgICAgaW5pdGlhbFNpemVcbiAgICAgICAgICAgID8gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGNvbnRlbnRTdGFydCwgJ2xpbmVQcmVmaXgnLCBpbml0aWFsU2l6ZSArIDEpXG4gICAgICAgICAgICA6IGNvbnRlbnRTdGFydFxuICAgICAgICApLFxuICAgICAgICBhZnRlclxuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ21hdGhGbG93VmFsdWUnKVxuICAgIHJldHVybiBjb250ZW50Q29udGludWUoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRlbnRDb250aW51ZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ21hdGhGbG93VmFsdWUnKVxuICAgICAgcmV0dXJuIGNvbnRlbnRTdGFydChjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBjb250ZW50Q29udGludWVcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ21hdGhGbG93JylcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuICBmdW5jdGlvbiB0b2tlbml6ZUNsb3NpbmdGZW5jZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gICAgbGV0IHNpemUgPSAwXG4gICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBjbG9zaW5nUHJlZml4QWZ0ZXIsICdsaW5lUHJlZml4JywgNClcbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gY2xvc2luZ1ByZWZpeEFmdGVyKGNvZGUpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ21hdGhGbG93RmVuY2UnKVxuICAgICAgZWZmZWN0cy5lbnRlcignbWF0aEZsb3dGZW5jZVNlcXVlbmNlJylcbiAgICAgIHJldHVybiBjbG9zaW5nU2VxdWVuY2UoY29kZSlcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIGNsb3NpbmdTZXF1ZW5jZShjb2RlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gMzYpIHtcbiAgICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICAgIHNpemUrK1xuICAgICAgICByZXR1cm4gY2xvc2luZ1NlcXVlbmNlXG4gICAgICB9XG5cbiAgICAgIGlmIChzaXplIDwgc2l6ZU9wZW4pIHJldHVybiBub2soY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnbWF0aEZsb3dGZW5jZVNlcXVlbmNlJylcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgY2xvc2luZ1NlcXVlbmNlRW5kLCAnd2hpdGVzcGFjZScpKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBjbG9zaW5nU2VxdWVuY2VFbmQoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICAgIGVmZmVjdHMuZXhpdCgnbWF0aEZsb3dGZW5jZScpXG4gICAgICAgIHJldHVybiBvayhjb2RlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVOb25MYXp5TGluZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgIHJldHVybiBsaW5lU3RhcnRcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGxpbmVTdGFydChjb2RlKSB7XG4gICAgcmV0dXJuIHNlbGYucGFyc2VyLmxhenlbc2VsZi5ub3coKS5saW5lXSA/IG5vayhjb2RlKSA6IG9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUmVzb2x2ZXJ9IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlByZXZpb3VzfSBQcmV2aW91c1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbc2luZ2xlRG9sbGFyVGV4dE1hdGg9dHJ1ZV1cbiAqICAgV2hldGhlciB0byBzdXBwb3J0IG1hdGggKHRleHQpIHdpdGggYSBzaW5nbGUgZG9sbGFyIChgYm9vbGVhbmAsIGRlZmF1bHQ6XG4gKiAgIGB0cnVlYCkuXG4gKiAgIFNpbmdsZSBkb2xsYXJzIHdvcmsgaW4gUGFuZG9jIGFuZCBtYW55IG90aGVyIHBsYWNlcywgYnV0IG9mdGVuIGludGVyZmVyZVxuICogICB3aXRoIFx1MjAxQ25vcm1hbFx1MjAxRCBkb2xsYXJzIGluIHRleHQuXG4gKi9cbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKlxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRoVGV4dChvcHRpb25zID0ge30pIHtcbiAgbGV0IHNpbmdsZSA9IG9wdGlvbnMuc2luZ2xlRG9sbGFyVGV4dE1hdGhcblxuICBpZiAoc2luZ2xlID09PSBudWxsIHx8IHNpbmdsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2luZ2xlID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b2tlbml6ZTogdG9rZW5pemVNYXRoVGV4dCxcbiAgICByZXNvbHZlOiByZXNvbHZlTWF0aFRleHQsXG4gICAgcHJldmlvdXNcbiAgfVxuICAvKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuICBmdW5jdGlvbiB0b2tlbml6ZU1hdGhUZXh0KGVmZmVjdHMsIG9rLCBub2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGxldCBzaXplT3BlbiA9IDBcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICAgIGxldCBzaXplXG4gICAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cblxuICAgIGxldCB0b2tlblxuICAgIHJldHVybiBzdGFydFxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdtYXRoVGV4dCcpXG4gICAgICBlZmZlY3RzLmVudGVyKCdtYXRoVGV4dFNlcXVlbmNlJylcbiAgICAgIHJldHVybiBvcGVuaW5nU2VxdWVuY2UoY29kZSlcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIG9wZW5pbmdTZXF1ZW5jZShjb2RlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gMzYpIHtcbiAgICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICAgIHNpemVPcGVuKytcbiAgICAgICAgcmV0dXJuIG9wZW5pbmdTZXF1ZW5jZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZU9wZW4gPCAyICYmICFzaW5nbGUpIHJldHVybiBub2soY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnbWF0aFRleHRTZXF1ZW5jZScpXG4gICAgICByZXR1cm4gZ2FwKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBnYXAoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgfSAvLyBDbG9zaW5nIGZlbmNlP1xuICAgICAgLy8gQ291bGQgYWxzbyBiZSBkYXRhLlxuXG4gICAgICBpZiAoY29kZSA9PT0gMzYpIHtcbiAgICAgICAgdG9rZW4gPSBlZmZlY3RzLmVudGVyKCdtYXRoVGV4dFNlcXVlbmNlJylcbiAgICAgICAgc2l6ZSA9IDBcbiAgICAgICAgcmV0dXJuIGNsb3NpbmdTZXF1ZW5jZShjb2RlKVxuICAgICAgfSAvLyBUYWJzIGRvblx1MjAxOXQgd29yaywgYW5kIHZpcnR1YWwgc3BhY2VzIGRvblx1MjAxOXQgbWFrZSBzZW5zZS5cblxuICAgICAgaWYgKGNvZGUgPT09IDMyKSB7XG4gICAgICAgIGVmZmVjdHMuZW50ZXIoJ3NwYWNlJylcbiAgICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICAgIGVmZmVjdHMuZXhpdCgnc3BhY2UnKVxuICAgICAgICByZXR1cm4gZ2FwXG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgICAgZWZmZWN0cy5lbnRlcignbGluZUVuZGluZycpXG4gICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgICAgICByZXR1cm4gZ2FwXG4gICAgICB9IC8vIERhdGEuXG5cbiAgICAgIGVmZmVjdHMuZW50ZXIoJ21hdGhUZXh0RGF0YScpXG4gICAgICByZXR1cm4gZGF0YShjb2RlKVxuICAgIH0gLy8gSW4gbWF0aC5cblxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBkYXRhKGNvZGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgICBjb2RlID09PSAzMiB8fFxuICAgICAgICBjb2RlID09PSAzNiB8fFxuICAgICAgICBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSlcbiAgICAgICkge1xuICAgICAgICBlZmZlY3RzLmV4aXQoJ21hdGhUZXh0RGF0YScpXG4gICAgICAgIHJldHVybiBnYXAoY29kZSlcbiAgICAgIH1cblxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gLy8gQ2xvc2luZyBmZW5jZS5cblxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBjbG9zaW5nU2VxdWVuY2UoY29kZSkge1xuICAgICAgLy8gTW9yZS5cbiAgICAgIGlmIChjb2RlID09PSAzNikge1xuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgc2l6ZSsrXG4gICAgICAgIHJldHVybiBjbG9zaW5nU2VxdWVuY2VcbiAgICAgIH0gLy8gRG9uZSFcblxuICAgICAgaWYgKHNpemUgPT09IHNpemVPcGVuKSB7XG4gICAgICAgIGVmZmVjdHMuZXhpdCgnbWF0aFRleHRTZXF1ZW5jZScpXG4gICAgICAgIGVmZmVjdHMuZXhpdCgnbWF0aFRleHQnKVxuICAgICAgICByZXR1cm4gb2soY29kZSlcbiAgICAgIH0gLy8gTW9yZSBvciBsZXNzIGFjY2VudHM6IG1hcmsgYXMgZGF0YS5cblxuICAgICAgdG9rZW4udHlwZSA9ICdtYXRoVGV4dERhdGEnXG4gICAgICByZXR1cm4gZGF0YShjb2RlKVxuICAgIH1cbiAgfVxufVxuLyoqIEB0eXBlIHtSZXNvbHZlcn0gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZU1hdGhUZXh0KGV2ZW50cykge1xuICBsZXQgdGFpbEV4aXRJbmRleCA9IGV2ZW50cy5sZW5ndGggLSA0XG4gIGxldCBoZWFkRW50ZXJJbmRleCA9IDNcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgbGV0IGluZGV4XG4gIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cblxuICBsZXQgZW50ZXIgLy8gSWYgd2Ugc3RhcnQgYW5kIGVuZCB3aXRoIGFuIEVPTCBvciBhIHNwYWNlLlxuXG4gIGlmIChcbiAgICAoZXZlbnRzW2hlYWRFbnRlckluZGV4XVsxXS50eXBlID09PSAnbGluZUVuZGluZycgfHxcbiAgICAgIGV2ZW50c1toZWFkRW50ZXJJbmRleF1bMV0udHlwZSA9PT0gJ3NwYWNlJykgJiZcbiAgICAoZXZlbnRzW3RhaWxFeGl0SW5kZXhdWzFdLnR5cGUgPT09ICdsaW5lRW5kaW5nJyB8fFxuICAgICAgZXZlbnRzW3RhaWxFeGl0SW5kZXhdWzFdLnR5cGUgPT09ICdzcGFjZScpXG4gICkge1xuICAgIGluZGV4ID0gaGVhZEVudGVySW5kZXggLy8gQW5kIHdlIGhhdmUgZGF0YS5cblxuICAgIHdoaWxlICgrK2luZGV4IDwgdGFpbEV4aXRJbmRleCkge1xuICAgICAgaWYgKGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ21hdGhUZXh0RGF0YScpIHtcbiAgICAgICAgLy8gVGhlbiB3ZSBoYXZlIHBhZGRpbmcuXG4gICAgICAgIGV2ZW50c1t0YWlsRXhpdEluZGV4XVsxXS50eXBlID0gJ21hdGhUZXh0UGFkZGluZydcbiAgICAgICAgZXZlbnRzW2hlYWRFbnRlckluZGV4XVsxXS50eXBlID0gJ21hdGhUZXh0UGFkZGluZydcbiAgICAgICAgaGVhZEVudGVySW5kZXggKz0gMlxuICAgICAgICB0YWlsRXhpdEluZGV4IC09IDJcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gTWVyZ2UgYWRqYWNlbnQgc3BhY2VzIGFuZCBkYXRhLlxuXG4gIGluZGV4ID0gaGVhZEVudGVySW5kZXggLSAxXG4gIHRhaWxFeGl0SW5kZXgrK1xuXG4gIHdoaWxlICgrK2luZGV4IDw9IHRhaWxFeGl0SW5kZXgpIHtcbiAgICBpZiAoZW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZGV4ICE9PSB0YWlsRXhpdEluZGV4ICYmIGV2ZW50c1tpbmRleF1bMV0udHlwZSAhPT0gJ2xpbmVFbmRpbmcnKSB7XG4gICAgICAgIGVudGVyID0gaW5kZXhcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaW5kZXggPT09IHRhaWxFeGl0SW5kZXggfHxcbiAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmcnXG4gICAgKSB7XG4gICAgICBldmVudHNbZW50ZXJdWzFdLnR5cGUgPSAnbWF0aFRleHREYXRhJ1xuXG4gICAgICBpZiAoaW5kZXggIT09IGVudGVyICsgMikge1xuICAgICAgICBldmVudHNbZW50ZXJdWzFdLmVuZCA9IGV2ZW50c1tpbmRleCAtIDFdWzFdLmVuZFxuICAgICAgICBldmVudHMuc3BsaWNlKGVudGVyICsgMiwgaW5kZXggLSBlbnRlciAtIDIpXG4gICAgICAgIHRhaWxFeGl0SW5kZXggLT0gaW5kZXggLSBlbnRlciAtIDJcbiAgICAgICAgaW5kZXggPSBlbnRlciArIDJcbiAgICAgIH1cblxuICAgICAgZW50ZXIgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnRzXG59XG4vKiogQHR5cGUge1ByZXZpb3VzfSAqL1xuXG5mdW5jdGlvbiBwcmV2aW91cyhjb2RlKSB7XG4gIC8vIElmIHRoZXJlIGlzIGEgcHJldmlvdXMgY29kZSwgdGhlcmUgd2lsbCBhbHdheXMgYmUgYSB0YWlsLlxuICByZXR1cm4gKFxuICAgIGNvZGUgIT09IDM2IHx8XG4gICAgdGhpcy5ldmVudHNbdGhpcy5ldmVudHMubGVuZ3RoIC0gMV1bMV0udHlwZSA9PT0gJ2NoYXJhY3RlckVzY2FwZSdcbiAgKVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeHRlbnNpb259IEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9tYXRoLXRleHQnKS5PcHRpb25zfSBPcHRpb25zXG4gKi9cbmltcG9ydCB7bWF0aEZsb3d9IGZyb20gJy4vbWF0aC1mbG93LmpzJ1xuaW1wb3J0IHttYXRoVGV4dH0gZnJvbSAnLi9tYXRoLXRleHQuanMnXG4vKipcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7RXh0ZW5zaW9ufVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBmbG93OiB7XG4gICAgICBbMzZdOiBtYXRoRmxvd1xuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgWzM2XTogbWF0aFRleHQob3B0aW9ucylcbiAgICB9XG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUG9pbnR9IFBvaW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLlRyYWNrRmllbGRzfSBUcmFja0ZpZWxkc1xuICovXG5cbi8qKlxuICogRnVuY3Rpb25zIHRvIHRyYWNrIG91dHB1dCBwb3NpdGlvbnMuXG4gKiBUaGlzIGluZm8gaXNuXHUyMDE5dCB1c2VkIHlldCBidXQgc3VjaHMgZnVuY3Rpb25hbGl0eSBhbGxvd3MgbGluZSB3cmFwcGluZyxcbiAqIGFuZCB0aGVvcmV0aWNhbGx5IHNvdXJjZSBtYXBzICh0aG91Z2gsIGlzIHRoZXJlIHByYWN0aWNhbCB1c2UgaW4gdGhhdD8pLlxuICpcbiAqIEBwYXJhbSB7VHJhY2tGaWVsZHN9IG9wdGlvbnNfXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFjayhvcHRpb25zXykge1xuICAvLyBEZWZhdWx0cyBhcmUgdXNlZCB0byBwcmV2ZW50IGNyYXNoZXMgd2hlbiBvbGRlciB1dGlsaXRpZXMgc29tZWhvdyBhY3RpdmF0ZVxuICAvLyB0aGlzIGNvZGUuXG4gIC8qIGM4IGlnbm9yZSBuZXh0IDUgKi9cbiAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNfIHx8IHt9XG4gIGNvbnN0IG5vdyA9IG9wdGlvbnMubm93IHx8IHt9XG4gIGxldCBsaW5lU2hpZnQgPSBvcHRpb25zLmxpbmVTaGlmdCB8fCAwXG4gIGxldCBsaW5lID0gbm93LmxpbmUgfHwgMVxuICBsZXQgY29sdW1uID0gbm93LmNvbHVtbiB8fCAxXG5cbiAgcmV0dXJuIHttb3ZlLCBjdXJyZW50LCBzaGlmdH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHRyYWNrZWQgaW5mby5cbiAgICpcbiAgICogQHJldHVybnMge3tub3c6IFBvaW50LCBsaW5lU2hpZnQ6IG51bWJlcn19XG4gICAqL1xuICBmdW5jdGlvbiBjdXJyZW50KCkge1xuICAgIHJldHVybiB7bm93OiB7bGluZSwgY29sdW1ufSwgbGluZVNoaWZ0fVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhbiBpbmNyZWFzZWQgbGluZSBzaGlmdCAodGhlIHR5cGljYWwgaW5kZW50IGZvciBsaW5lcykuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2hpZnQodmFsdWUpIHtcbiAgICBsaW5lU2hpZnQgKz0gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHBhc3QgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gbW92ZSh2YWx1ZSA9ICcnKSB7XG4gICAgY29uc3QgY2h1bmtzID0gdmFsdWUuc3BsaXQoL1xccj9cXG58XFxyL2cpXG4gICAgY29uc3QgdGFpbCA9IGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV1cbiAgICBsaW5lICs9IGNodW5rcy5sZW5ndGggLSAxXG4gICAgY29sdW1uID1cbiAgICAgIGNodW5rcy5sZW5ndGggPT09IDEgPyBjb2x1bW4gKyB0YWlsLmxlbmd0aCA6IDEgKyB0YWlsLmxlbmd0aCArIGxpbmVTaGlmdFxuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5FeHRlbnNpb259IEZyb21NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuSGFuZGxlfSBGcm9tTWFya2Rvd25IYW5kbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5PcHRpb25zfSBUb01hcmtkb3duRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuSGFuZGxlfSBUb01hcmtkb3duSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvbXBsZXgtdHlwZXMnKS5NYXRofSBNYXRoXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvbXBsZXgtdHlwZXMnKS5JbmxpbmVNYXRofSBJbmxpbmVNYXRoXG4gKlxuICogQHR5cGVkZWYgVG9PcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaW5nbGVEb2xsYXJUZXh0TWF0aD10cnVlXVxuICogICBXaGV0aGVyIHRvIHN1cHBvcnQgbWF0aCAodGV4dCkgd2l0aCBhIHNpbmdsZSBkb2xsYXIgKGBib29sZWFuYCwgZGVmYXVsdDpcbiAqICAgYHRydWVgKS5cbiAqICAgU2luZ2xlIGRvbGxhcnMgd29yayBpbiBQYW5kb2MgYW5kIG1hbnkgb3RoZXIgcGxhY2VzLCBidXQgb2Z0ZW4gaW50ZXJmZXJlXG4gKiAgIHdpdGggXHUyMDFDbm9ybWFsXHUyMDFEIGRvbGxhcnMgaW4gdGV4dC5cbiAqL1xuXG5pbXBvcnQge2xvbmdlc3RTdHJlYWt9IGZyb20gJ2xvbmdlc3Qtc3RyZWFrJ1xuaW1wb3J0IHtzYWZlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL3NhZmUuanMnXG5pbXBvcnQge3RyYWNrfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL3RyYWNrLmpzJ1xuXG4vKipcbiAqIEByZXR1cm5zIHtGcm9tTWFya2Rvd25FeHRlbnNpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRoRnJvbU1hcmtkb3duKCkge1xuICByZXR1cm4ge1xuICAgIGVudGVyOiB7XG4gICAgICBtYXRoRmxvdzogZW50ZXJNYXRoRmxvdyxcbiAgICAgIG1hdGhGbG93RmVuY2VNZXRhOiBlbnRlck1hdGhGbG93TWV0YSxcbiAgICAgIG1hdGhUZXh0OiBlbnRlck1hdGhUZXh0XG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBtYXRoRmxvdzogZXhpdE1hdGhGbG93LFxuICAgICAgbWF0aEZsb3dGZW5jZTogZXhpdE1hdGhGbG93RmVuY2UsXG4gICAgICBtYXRoRmxvd0ZlbmNlTWV0YTogZXhpdE1hdGhGbG93TWV0YSxcbiAgICAgIG1hdGhGbG93VmFsdWU6IGV4aXRNYXRoRGF0YSxcbiAgICAgIG1hdGhUZXh0OiBleGl0TWF0aFRleHQsXG4gICAgICBtYXRoVGV4dERhdGE6IGV4aXRNYXRoRGF0YVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBlbnRlck1hdGhGbG93KHRva2VuKSB7XG4gICAgdGhpcy5lbnRlcihcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ21hdGgnLFxuICAgICAgICBtZXRhOiBudWxsLFxuICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBoTmFtZTogJ2RpdicsXG4gICAgICAgICAgaFByb3BlcnRpZXM6IHtjbGFzc05hbWU6IFsnbWF0aCcsICdtYXRoLWRpc3BsYXknXX0sXG4gICAgICAgICAgaENoaWxkcmVuOiBbe3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcnfV1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VuXG4gICAgKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGVudGVyTWF0aEZsb3dNZXRhKCkge1xuICAgIHRoaXMuYnVmZmVyKClcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBleGl0TWF0aEZsb3dNZXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IC8qKiBAdHlwZSB7TWF0aH0gKi8gKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSlcbiAgICBub2RlLm1ldGEgPSBkYXRhXG4gIH1cblxuICAvKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbiAgZnVuY3Rpb24gZXhpdE1hdGhGbG93RmVuY2UoKSB7XG4gICAgLy8gRXhpdCBpZiB0aGlzIGlzIHRoZSBjbG9zaW5nIGZlbmNlLlxuICAgIGlmICh0aGlzLmdldERhdGEoJ21hdGhGbG93SW5zaWRlJykpIHJldHVyblxuICAgIHRoaXMuYnVmZmVyKClcbiAgICB0aGlzLnNldERhdGEoJ21hdGhGbG93SW5zaWRlJywgdHJ1ZSlcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBleGl0TWF0aEZsb3codG9rZW4pIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKS5yZXBsYWNlKC9eKFxccj9cXG58XFxyKXwoXFxyP1xcbnxcXHIpJC9nLCAnJylcbiAgICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtNYXRofSAqLyAodGhpcy5leGl0KHRva2VuKSlcbiAgICBub2RlLnZhbHVlID0gZGF0YVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlIGRlZmluZWQgaXQuXG4gICAgbm9kZS5kYXRhLmhDaGlsZHJlblswXS52YWx1ZSA9IGRhdGFcbiAgICB0aGlzLnNldERhdGEoJ21hdGhGbG93SW5zaWRlJylcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBlbnRlck1hdGhUZXh0KHRva2VuKSB7XG4gICAgdGhpcy5lbnRlcihcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ2lubGluZU1hdGgnLFxuICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBoTmFtZTogJ3NwYW4nLFxuICAgICAgICAgIGhQcm9wZXJ0aWVzOiB7Y2xhc3NOYW1lOiBbJ21hdGgnLCAnbWF0aC1pbmxpbmUnXX0sXG4gICAgICAgICAgaENoaWxkcmVuOiBbe3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcnfV1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VuXG4gICAgKVxuICAgIHRoaXMuYnVmZmVyKClcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBleGl0TWF0aFRleHQodG9rZW4pIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSAvKiogQHR5cGUge01hdGh9ICovICh0aGlzLmV4aXQodG9rZW4pKVxuICAgIG5vZGUudmFsdWUgPSBkYXRhXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogd2UgZGVmaW5lZCBpdC5cbiAgICBub2RlLmRhdGEuaENoaWxkcmVuWzBdLnZhbHVlID0gZGF0YVxuICB9XG5cbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGV4aXRNYXRoRGF0YSh0b2tlbikge1xuICAgIHRoaXMuY29uZmlnLmVudGVyLmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB0aGlzLmNvbmZpZy5leGl0LmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VG9PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtUb01hcmtkb3duRXh0ZW5zaW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0aFRvTWFya2Rvd24ob3B0aW9ucyA9IHt9KSB7XG4gIGxldCBzaW5nbGUgPSBvcHRpb25zLnNpbmdsZURvbGxhclRleHRNYXRoXG5cbiAgaWYgKHNpbmdsZSA9PT0gbnVsbCB8fCBzaW5nbGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNpbmdsZSA9IHRydWVcbiAgfVxuXG4gIGlubGluZU1hdGgucGVlayA9IGlubGluZU1hdGhQZWVrXG5cbiAgcmV0dXJuIHtcbiAgICB1bnNhZmU6IFtcbiAgICAgIHtjaGFyYWN0ZXI6ICdcXHInLCBpbkNvbnN0cnVjdDogWydtYXRoRmxvd01ldGEnXX0sXG4gICAgICB7Y2hhcmFjdGVyOiAnXFxyJywgaW5Db25zdHJ1Y3Q6IFsnbWF0aEZsb3dNZXRhJ119LFxuICAgICAgc2luZ2xlXG4gICAgICAgID8ge2NoYXJhY3RlcjogJyQnLCBpbkNvbnN0cnVjdDogWydtYXRoRmxvd01ldGEnLCAncGhyYXNpbmcnXX1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBjaGFyYWN0ZXI6ICckJyxcbiAgICAgICAgICAgIGFmdGVyOiAnXFxcXCQnLFxuICAgICAgICAgICAgaW5Db25zdHJ1Y3Q6IFsnbWF0aEZsb3dNZXRhJywgJ3BocmFzaW5nJ11cbiAgICAgICAgICB9LFxuICAgICAge2F0QnJlYWs6IHRydWUsIGNoYXJhY3RlcjogJyQnLCBhZnRlcjogJ1xcXFwkJ31cbiAgICBdLFxuICAgIGhhbmRsZXJzOiB7bWF0aCwgaW5saW5lTWF0aH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtNYXRofSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBtYXRoKG5vZGUsIF8sIGNvbnRleHQsIHNhZmVPcHRpb25zKSB7XG4gICAgY29uc3QgcmF3ID0gbm9kZS52YWx1ZSB8fCAnJ1xuICAgIGNvbnN0IHNlcXVlbmNlID0gJyQnLnJlcGVhdChNYXRoLm1heChsb25nZXN0U3RyZWFrKHJhdywgJyQnKSArIDEsIDIpKVxuICAgIGNvbnN0IGV4aXQgPSBjb250ZXh0LmVudGVyKCdtYXRoRmxvdycpXG4gICAgY29uc3QgdHJhY2tlciA9IHRyYWNrKHNhZmVPcHRpb25zKVxuICAgIGxldCB2YWx1ZSA9IHRyYWNrZXIubW92ZShzZXF1ZW5jZSlcblxuICAgIGlmIChub2RlLm1ldGEpIHtcbiAgICAgIGNvbnN0IHN1YmV4aXQgPSBjb250ZXh0LmVudGVyKCdtYXRoRmxvd01ldGEnKVxuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgICBzYWZlKGNvbnRleHQsIG5vZGUubWV0YSwge1xuICAgICAgICAgIC4uLnRyYWNrZXIuY3VycmVudCgpLFxuICAgICAgICAgIGJlZm9yZTogdmFsdWUsXG4gICAgICAgICAgYWZ0ZXI6ICcgJyxcbiAgICAgICAgICBlbmNvZGU6IFsnJCddXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICBzdWJleGl0KClcbiAgICB9XG5cbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJ1xcbicpXG5cbiAgICBpZiAocmF3KSB7XG4gICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUocmF3ICsgJ1xcbicpXG4gICAgfVxuXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKHNlcXVlbmNlKVxuICAgIGV4aXQoKVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfVxuICAgKiBAcGFyYW0ge0lubGluZU1hdGh9IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIGlubGluZU1hdGgobm9kZSkge1xuICAgIGNvbnN0IHZhbHVlID0gbm9kZS52YWx1ZSB8fCAnJ1xuICAgIGxldCBzaXplID0gMVxuICAgIGxldCBwYWQgPSAnJ1xuXG4gICAgaWYgKCFzaW5nbGUpIHNpemUrK1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBzaW5nbGUgZG9sbGFyIHNpZ24gb24gaXRzIG93biBpbiB0aGUgbWF0aCwgdXNlIGEgZmVuY2Ugb2ZcbiAgICAvLyB0d28uXG4gICAgLy8gSWYgdGhlcmUgYXJlIHR3byBpbiBhIHJvdywgdXNlIG9uZS5cbiAgICB3aGlsZSAoXG4gICAgICBuZXcgUmVnRXhwKCcoXnxbXiRdKScgKyAnXFxcXCQnLnJlcGVhdChzaXplKSArICcoW14kXXwkKScpLnRlc3QodmFsdWUpXG4gICAgKSB7XG4gICAgICBzaXplKytcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIGlzIG5vdCBqdXN0IHNwYWNlcyBvciBlb2xzICh0YWJzIGRvblx1MjAxOXQgY291bnQpLCBhbmQgZWl0aGVyIHRoZSBmaXJzdFxuICAgIC8vIG9yIGxhc3QgY2hhcmFjdGVyIGFyZSBhIHNwYWNlLCBlb2wsIG9yIGRvbGxhciBzaWduLCB0aGVuIHBhZCB3aXRoIHNwYWNlcy5cbiAgICBpZiAoXG4gICAgICAvW14gXFxyXFxuXS8udGVzdCh2YWx1ZSkgJiZcbiAgICAgICgvWyBcXHJcXG4kXS8udGVzdCh2YWx1ZS5jaGFyQXQoMCkpIHx8XG4gICAgICAgIC9bIFxcclxcbiRdLy50ZXN0KHZhbHVlLmNoYXJBdCh2YWx1ZS5sZW5ndGggLSAxKSkpXG4gICAgKSB7XG4gICAgICBwYWQgPSAnICdcbiAgICB9XG5cbiAgICBjb25zdCBzZXF1ZW5jZSA9ICckJy5yZXBlYXQoc2l6ZSlcbiAgICByZXR1cm4gc2VxdWVuY2UgKyBwYWQgKyB2YWx1ZSArIHBhZCArIHNlcXVlbmNlXG4gIH1cblxuICAvKiogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGlubGluZU1hdGhQZWVrKCkge1xuICAgIHJldHVybiAnJCdcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeHRlbnNpb259IEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3RSZWNvcmR9IENvbnN0cnVjdFJlY29yZFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5QcmV2aW91c30gUHJldmlvdXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7XG4gIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UsXG4gIG1hcmtkb3duTGluZUVuZGluZ1xufSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5jb25zdCB0YXNrbGlzdENoZWNrID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVUYXNrbGlzdENoZWNrXG59XG5leHBvcnQgY29uc3QgZ2ZtVGFza0xpc3RJdGVtID0ge1xuICB0ZXh0OiB7XG4gICAgWzkxXTogdGFza2xpc3RDaGVja1xuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVUYXNrbGlzdENoZWNrKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIG9wZW5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvcGVuKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICAvLyBFeGl0IGlmIHRoZXJlXHUyMDE5cyBzdHVmZiBiZWZvcmUuXG4gICAgICBzZWxmLnByZXZpb3VzICE9PSBudWxsIHx8IC8vIEV4aXQgaWYgbm90IGluIHRoZSBmaXJzdCBjb250ZW50IHRoYXQgaXMgdGhlIGZpcnN0IGNoaWxkIG9mIGEgbGlzdFxuICAgICAgLy8gaXRlbS5cbiAgICAgICFzZWxmLl9nZm1UYXNrbGlzdEZpcnN0Q29udGVudE9mTGlzdEl0ZW1cbiAgICApIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCd0YXNrTGlzdENoZWNrJylcbiAgICBlZmZlY3RzLmVudGVyKCd0YXNrTGlzdENoZWNrTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ3Rhc2tMaXN0Q2hlY2tNYXJrZXInKVxuICAgIHJldHVybiBpbnNpZGVcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGluc2lkZShjb2RlKSB7XG4gICAgLy8gVG8gbWF0Y2ggaG93IEdIIHdvcmtzIGluIGNvbW1lbnRzLCB1c2UgYG1hcmtkb3duU3BhY2VgIChgWyBcXHRdYCkgaW5zdGVhZFxuICAgIC8vIG9mIGBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlYCAoYFsgXFx0XFxyXFxuXWApLlxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YXNrTGlzdENoZWNrVmFsdWVVbmNoZWNrZWQnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3Rhc2tMaXN0Q2hlY2tWYWx1ZVVuY2hlY2tlZCcpXG4gICAgICByZXR1cm4gY2xvc2VcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gODggfHwgY29kZSA9PT0gMTIwKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YXNrTGlzdENoZWNrVmFsdWVDaGVja2VkJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YXNrTGlzdENoZWNrVmFsdWVDaGVja2VkJylcbiAgICAgIHJldHVybiBjbG9zZVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNsb3NlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gOTMpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3Rhc2tMaXN0Q2hlY2tNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3Rhc2tMaXN0Q2hlY2tNYXJrZXInKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YXNrTGlzdENoZWNrJylcbiAgICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKFxuICAgICAgICB7XG4gICAgICAgICAgdG9rZW5pemU6IHNwYWNlVGhlbk5vblNwYWNlXG4gICAgICAgIH0sXG4gICAgICAgIG9rLFxuICAgICAgICBub2tcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiBzcGFjZVRoZW5Ob25TcGFjZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYWZ0ZXIsICd3aGl0ZXNwYWNlJylcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlcihjb2RlKSB7XG4gICAgY29uc3QgdGFpbCA9IHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIFdlIGVpdGhlciBmb3VuZCBzcGFjZXNcdTIwMjZcbiAgICAgICgodGFpbCAmJiB0YWlsWzFdLnR5cGUgPT09ICd3aGl0ZXNwYWNlJykgfHwgLy8gXHUyMDI2b3IgaXQgd2FzIGZvbGxvd2VkIGJ5IGEgbGluZSBlbmRpbmcsIGluIHdoaWNoIGNhc2UsIHRoZXJlIGhhcyB0byBiZVxuICAgICAgICAvLyBub24td2hpdGVzcGFjZSBhZnRlciB0aGF0IGxpbmUgZW5kaW5nLCBiZWNhdXNlIG90aGVyd2lzZSB3ZVx1MjAxOWQgZ2V0IGFuXG4gICAgICAgIC8vIEVPRiBhcyB0aGUgY29udGVudCBpcyBjbG9zZWQgd2l0aCBibGFuayBsaW5lcy5cbiAgICAgICAgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSAmJlxuICAgICAgICBjb2RlICE9PSBudWxsXG4gICAgICAgID8gb2soY29kZSlcbiAgICAgICAgOiBub2soY29kZSlcbiAgICApXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtFeHRyYWN0PGltcG9ydCgnbWRhc3QnKS5Sb290fGltcG9ydCgnbWRhc3QnKS5Db250ZW50LCBpbXBvcnQoJ3VuaXN0JykuUGFyZW50Pn0gUGFyZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpc3RJdGVtfSBMaXN0SXRlbVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QYXJhZ3JhcGh9IFBhcmFncmFwaFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5CbG9ja0NvbnRlbnR9IEJsb2NrQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuRXh0ZW5zaW9ufSBGcm9tTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkhhbmRsZX0gRnJvbU1hcmtkb3duSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuT3B0aW9uc30gVG9NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkhhbmRsZX0gVG9NYXJrZG93bkhhbmRsZVxuICovXG5cbmltcG9ydCB7bGlzdEl0ZW19IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL2hhbmRsZS9saXN0LWl0ZW0uanMnXG5pbXBvcnQge3RyYWNrfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL3RyYWNrLmpzJ1xuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93bkV4dGVuc2lvbn0gKi9cbmV4cG9ydCBjb25zdCBnZm1UYXNrTGlzdEl0ZW1Gcm9tTWFya2Rvd24gPSB7XG4gIGV4aXQ6IHtcbiAgICB0YXNrTGlzdENoZWNrVmFsdWVDaGVja2VkOiBleGl0Q2hlY2ssXG4gICAgdGFza0xpc3RDaGVja1ZhbHVlVW5jaGVja2VkOiBleGl0Q2hlY2ssXG4gICAgcGFyYWdyYXBoOiBleGl0UGFyYWdyYXBoV2l0aFRhc2tMaXN0SXRlbVxuICB9XG59XG5cbi8qKiBAdHlwZSB7VG9NYXJrZG93bkV4dGVuc2lvbn0gKi9cbmV4cG9ydCBjb25zdCBnZm1UYXNrTGlzdEl0ZW1Ub01hcmtkb3duID0ge1xuICB1bnNhZmU6IFt7YXRCcmVhazogdHJ1ZSwgY2hhcmFjdGVyOiAnLScsIGFmdGVyOiAnWzp8LV0nfV0sXG4gIGhhbmRsZXJzOiB7bGlzdEl0ZW06IGxpc3RJdGVtV2l0aFRhc2tMaXN0SXRlbX1cbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBleGl0Q2hlY2sodG9rZW4pIHtcbiAgY29uc3Qgbm9kZSA9IC8qKiBAdHlwZSB7TGlzdEl0ZW19ICovICh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl0pXG4gIC8vIFdlXHUyMDE5cmUgYWx3YXlzIGluIGEgcGFyYWdyYXBoLCBpbiBhIGxpc3QgaXRlbS5cbiAgbm9kZS5jaGVja2VkID0gdG9rZW4udHlwZSA9PT0gJ3Rhc2tMaXN0Q2hlY2tWYWx1ZUNoZWNrZWQnXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZXhpdFBhcmFncmFwaFdpdGhUYXNrTGlzdEl0ZW0odG9rZW4pIHtcbiAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtQYXJlbnR9ICovICh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl0pXG4gIGNvbnN0IG5vZGUgPSAvKiogQHR5cGUge1BhcmFncmFwaH0gKi8gKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSlcbiAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW5cbiAgY29uc3QgaGVhZCA9IG5vZGUuY2hpbGRyZW5bMF1cbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtQYXJhZ3JhcGh8dW5kZWZpbmVkfSAqL1xuICBsZXQgZmlyc3RQYXJhZ2hyYXBoXG5cbiAgaWYgKFxuICAgIHBhcmVudCAmJlxuICAgIHBhcmVudC50eXBlID09PSAnbGlzdEl0ZW0nICYmXG4gICAgdHlwZW9mIHBhcmVudC5jaGVja2VkID09PSAnYm9vbGVhbicgJiZcbiAgICBoZWFkICYmXG4gICAgaGVhZC50eXBlID09PSAndGV4dCdcbiAgKSB7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzaWJsaW5ncy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpbmRleF1cbiAgICAgIGlmIChzaWJsaW5nLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgIGZpcnN0UGFyYWdocmFwaCA9IHNpYmxpbmdcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmlyc3RQYXJhZ2hyYXBoID09PSBub2RlKSB7XG4gICAgICAvLyBNdXN0IHN0YXJ0IHdpdGggYSBzcGFjZSBvciBhIHRhYi5cbiAgICAgIGhlYWQudmFsdWUgPSBoZWFkLnZhbHVlLnNsaWNlKDEpXG5cbiAgICAgIGlmIChoZWFkLnZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBub2RlLmNoaWxkcmVuLnNoaWZ0KClcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIG5vZGUucG9zaXRpb24gJiZcbiAgICAgICAgaGVhZC5wb3NpdGlvbiAmJlxuICAgICAgICB0eXBlb2YgaGVhZC5wb3NpdGlvbi5zdGFydC5vZmZzZXQgPT09ICdudW1iZXInXG4gICAgICApIHtcbiAgICAgICAgaGVhZC5wb3NpdGlvbi5zdGFydC5jb2x1bW4rK1xuICAgICAgICBoZWFkLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCsrXG4gICAgICAgIG5vZGUucG9zaXRpb24uc3RhcnQgPSBPYmplY3QuYXNzaWduKHt9LCBoZWFkLnBvc2l0aW9uLnN0YXJ0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXhpdCh0b2tlbilcbn1cblxuLyoqXG4gKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAqIEBwYXJhbSB7TGlzdEl0ZW19IG5vZGVcbiAqL1xuZnVuY3Rpb24gbGlzdEl0ZW1XaXRoVGFza0xpc3RJdGVtKG5vZGUsIHBhcmVudCwgY29udGV4dCwgc2FmZU9wdGlvbnMpIHtcbiAgY29uc3QgaGVhZCA9IG5vZGUuY2hpbGRyZW5bMF1cbiAgY29uc3QgY2hlY2thYmxlID1cbiAgICB0eXBlb2Ygbm9kZS5jaGVja2VkID09PSAnYm9vbGVhbicgJiYgaGVhZCAmJiBoZWFkLnR5cGUgPT09ICdwYXJhZ3JhcGgnXG4gIGNvbnN0IGNoZWNrYm94ID0gJ1snICsgKG5vZGUuY2hlY2tlZCA/ICd4JyA6ICcgJykgKyAnXSAnXG4gIGNvbnN0IHRyYWNrZXIgPSB0cmFjayhzYWZlT3B0aW9ucylcblxuICBpZiAoY2hlY2thYmxlKSB7XG4gICAgdHJhY2tlci5tb3ZlKGNoZWNrYm94KVxuICB9XG5cbiAgbGV0IHZhbHVlID0gbGlzdEl0ZW0obm9kZSwgcGFyZW50LCBjb250ZXh0LCB7XG4gICAgLi4uc2FmZU9wdGlvbnMsXG4gICAgLi4udHJhY2tlci5jdXJyZW50KClcbiAgfSlcblxuICBpZiAoY2hlY2thYmxlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKD86WyorLV18XFxkK1xcLikoW1xcclxcbl18IHsxLDN9KS8sIGNoZWNrKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAkMFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2soJDApIHtcbiAgICByZXR1cm4gJDAgKyBjaGVja2JveFxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4dGVuc2lvbn0gRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlJlc29sdmVyfSBSZXNvbHZlclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2xlZnQnfCdjZW50ZXInfCdyaWdodCd8J25vbmUnfSBBbGlnblxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge1xuICBtYXJrZG93bkxpbmVFbmRpbmcsXG4gIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UsXG4gIG1hcmtkb3duU3BhY2Vcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0V4dGVuc2lvbn0gKi9cbmV4cG9ydCBjb25zdCBnZm1UYWJsZSA9IHtcbiAgZmxvdzoge1xuICAgIG51bGw6IHtcbiAgICAgIHRva2VuaXplOiB0b2tlbml6ZVRhYmxlLFxuICAgICAgcmVzb2x2ZTogcmVzb2x2ZVRhYmxlXG4gICAgfVxuICB9XG59XG5jb25zdCBuZXh0UHJlZml4ZWRPckJsYW5rID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVOZXh0UHJlZml4ZWRPckJsYW5rLFxuICBwYXJ0aWFsOiB0cnVlXG59XG4vKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVGFibGUoZXZlbnRzLCBjb250ZXh0KSB7XG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGluSGVhZFxuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBpbkRlbGltaXRlclJvd1xuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBpblJvd1xuICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGNvbnRlbnRTdGFydFxuICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGNvbnRlbnRFbmRcbiAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBjZWxsU3RhcnRcbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgc2VlbkNlbGxJblJvd1xuXG4gIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IHRva2VuID0gZXZlbnRzW2luZGV4XVsxXVxuXG4gICAgaWYgKGluUm93KSB7XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RlbXBvcmFyeVRhYmxlQ2VsbENvbnRlbnQnKSB7XG4gICAgICAgIGNvbnRlbnRTdGFydCA9IGNvbnRlbnRTdGFydCB8fCBpbmRleFxuICAgICAgICBjb250ZW50RW5kID0gaW5kZXhcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAvLyBDb21iaW5lIHNlcGFyYXRlIGNvbnRlbnQgcGFydHMgaW50byBvbmUuXG4gICAgICAgICh0b2tlbi50eXBlID09PSAndGFibGVDZWxsRGl2aWRlcicgfHwgdG9rZW4udHlwZSA9PT0gJ3RhYmxlUm93JykgJiZcbiAgICAgICAgY29udGVudEVuZFxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhYmxlQ29udGVudCcsXG4gICAgICAgICAgc3RhcnQ6IGV2ZW50c1tjb250ZW50U3RhcnRdWzFdLnN0YXJ0LFxuICAgICAgICAgIGVuZDogZXZlbnRzW2NvbnRlbnRFbmRdWzFdLmVuZFxuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7VG9rZW59ICovXG5cbiAgICAgICAgY29uc3QgdGV4dCA9IHtcbiAgICAgICAgICB0eXBlOiAnY2h1bmtUZXh0JyxcbiAgICAgICAgICBzdGFydDogY29udGVudC5zdGFydCxcbiAgICAgICAgICBlbmQ6IGNvbnRlbnQuZW5kLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSXRcdTIwMTlzIGZpbmUuXG4gICAgICAgICAgY29udGVudFR5cGU6ICd0ZXh0J1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50cy5zcGxpY2UoXG4gICAgICAgICAgY29udGVudFN0YXJ0LFxuICAgICAgICAgIGNvbnRlbnRFbmQgLSBjb250ZW50U3RhcnQgKyAxLFxuICAgICAgICAgIFsnZW50ZXInLCBjb250ZW50LCBjb250ZXh0XSxcbiAgICAgICAgICBbJ2VudGVyJywgdGV4dCwgY29udGV4dF0sXG4gICAgICAgICAgWydleGl0JywgdGV4dCwgY29udGV4dF0sXG4gICAgICAgICAgWydleGl0JywgY29udGVudCwgY29udGV4dF1cbiAgICAgICAgKVxuICAgICAgICBpbmRleCAtPSBjb250ZW50RW5kIC0gY29udGVudFN0YXJ0IC0gM1xuICAgICAgICBjb250ZW50U3RhcnQgPSB1bmRlZmluZWRcbiAgICAgICAgY29udGVudEVuZCA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGV2ZW50c1tpbmRleF1bMF0gPT09ICdleGl0JyAmJlxuICAgICAgY2VsbFN0YXJ0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGNlbGxTdGFydCArIChzZWVuQ2VsbEluUm93ID8gMCA6IDEpIDwgaW5kZXggJiZcbiAgICAgICh0b2tlbi50eXBlID09PSAndGFibGVDZWxsRGl2aWRlcicgfHxcbiAgICAgICAgKHRva2VuLnR5cGUgPT09ICd0YWJsZVJvdycgJiZcbiAgICAgICAgICAoY2VsbFN0YXJ0ICsgMyA8IGluZGV4IHx8XG4gICAgICAgICAgICBldmVudHNbY2VsbFN0YXJ0XVsxXS50eXBlICE9PSAnd2hpdGVzcGFjZScpKSlcbiAgICApIHtcbiAgICAgIGNvbnN0IGNlbGwgPSB7XG4gICAgICAgIHR5cGU6IGluRGVsaW1pdGVyUm93XG4gICAgICAgICAgPyAndGFibGVEZWxpbWl0ZXInXG4gICAgICAgICAgOiBpbkhlYWRcbiAgICAgICAgICA/ICd0YWJsZUhlYWRlcidcbiAgICAgICAgICA6ICd0YWJsZURhdGEnLFxuICAgICAgICBzdGFydDogZXZlbnRzW2NlbGxTdGFydF1bMV0uc3RhcnQsXG4gICAgICAgIGVuZDogZXZlbnRzW2luZGV4XVsxXS5lbmRcbiAgICAgIH1cbiAgICAgIGV2ZW50cy5zcGxpY2UoaW5kZXggKyAodG9rZW4udHlwZSA9PT0gJ3RhYmxlQ2VsbERpdmlkZXInID8gMSA6IDApLCAwLCBbXG4gICAgICAgICdleGl0JyxcbiAgICAgICAgY2VsbCxcbiAgICAgICAgY29udGV4dFxuICAgICAgXSlcbiAgICAgIGV2ZW50cy5zcGxpY2UoY2VsbFN0YXJ0LCAwLCBbJ2VudGVyJywgY2VsbCwgY29udGV4dF0pXG4gICAgICBpbmRleCArPSAyXG4gICAgICBjZWxsU3RhcnQgPSBpbmRleCArIDFcbiAgICAgIHNlZW5DZWxsSW5Sb3cgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0YWJsZVJvdycpIHtcbiAgICAgIGluUm93ID0gZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJ1xuXG4gICAgICBpZiAoaW5Sb3cpIHtcbiAgICAgICAgY2VsbFN0YXJ0ID0gaW5kZXggKyAxXG4gICAgICAgIHNlZW5DZWxsSW5Sb3cgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGFibGVEZWxpbWl0ZXJSb3cnKSB7XG4gICAgICBpbkRlbGltaXRlclJvdyA9IGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcidcblxuICAgICAgaWYgKGluRGVsaW1pdGVyUm93KSB7XG4gICAgICAgIGNlbGxTdGFydCA9IGluZGV4ICsgMVxuICAgICAgICBzZWVuQ2VsbEluUm93ID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RhYmxlSGVhZCcpIHtcbiAgICAgIGluSGVhZCA9IGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcidcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnRzXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVUYWJsZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8qKiBAdHlwZSB7QXJyYXk8QWxpZ24+fSAqL1xuXG4gIGNvbnN0IGFsaWduID0gW11cbiAgbGV0IHRhYmxlSGVhZGVyQ291bnQgPSAwXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IHNlZW5EZWxpbWl0ZXJcbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgaGFzRGFzaFxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBDdXN0b20uXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGUnKS5fYWxpZ24gPSBhbGlnblxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlSGVhZCcpXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVSb3cnKSAvLyBJZiB3ZSBzdGFydCB3aXRoIGEgcGlwZSwgd2Ugb3BlbiBhIGNlbGwgbWFya2VyLlxuXG4gICAgaWYgKGNvZGUgPT09IDEyNCkge1xuICAgICAgcmV0dXJuIGNlbGxEaXZpZGVySGVhZChjb2RlKVxuICAgIH1cblxuICAgIHRhYmxlSGVhZGVyQ291bnQrK1xuICAgIGVmZmVjdHMuZW50ZXIoJ3RlbXBvcmFyeVRhYmxlQ2VsbENvbnRlbnQnKSAvLyBDYW5cdTIwMTl0IGJlIHNwYWNlIG9yIGVvbHMgYXQgdGhlIHN0YXJ0IG9mIGEgY29uc3RydWN0LCBzbyB3ZVx1MjAxOXJlIGluIGEgY2VsbC5cblxuICAgIHJldHVybiBpbkNlbGxDb250ZW50SGVhZChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY2VsbERpdmlkZXJIZWFkKGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgIHNlZW5EZWxpbWl0ZXIgPSB0cnVlXG4gICAgcmV0dXJuIGNlbGxCcmVha0hlYWRcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNlbGxCcmVha0hlYWQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIGF0Um93RW5kSGVhZChjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd3aGl0ZXNwYWNlJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluV2hpdGVzcGFjZUhlYWRcbiAgICB9XG5cbiAgICBpZiAoc2VlbkRlbGltaXRlcikge1xuICAgICAgc2VlbkRlbGltaXRlciA9IHVuZGVmaW5lZFxuICAgICAgdGFibGVIZWFkZXJDb3VudCsrXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDEyNCkge1xuICAgICAgcmV0dXJuIGNlbGxEaXZpZGVySGVhZChjb2RlKVxuICAgIH0gLy8gQW55dGhpbmcgZWxzZSBpcyBjZWxsIGNvbnRlbnQuXG5cbiAgICBlZmZlY3RzLmVudGVyKCd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50JylcbiAgICByZXR1cm4gaW5DZWxsQ29udGVudEhlYWQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGluV2hpdGVzcGFjZUhlYWQoY29kZSkge1xuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbldoaXRlc3BhY2VIZWFkXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCd3aGl0ZXNwYWNlJylcbiAgICByZXR1cm4gY2VsbEJyZWFrSGVhZChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5DZWxsQ29udGVudEhlYWQoY29kZSkge1xuICAgIC8vIEVPRiwgd2hpdGVzcGFjZSwgcGlwZVxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IDEyNCB8fCBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ3RlbXBvcmFyeVRhYmxlQ2VsbENvbnRlbnQnKVxuICAgICAgcmV0dXJuIGNlbGxCcmVha0hlYWQoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29kZSA9PT0gOTIgPyBpbkNlbGxDb250ZW50RXNjYXBlSGVhZCA6IGluQ2VsbENvbnRlbnRIZWFkXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBpbkNlbGxDb250ZW50RXNjYXBlSGVhZChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDkyIHx8IGNvZGUgPT09IDEyNCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5DZWxsQ29udGVudEhlYWRcbiAgICB9IC8vIEFueXRoaW5nIGVsc2UuXG5cbiAgICByZXR1cm4gaW5DZWxsQ29udGVudEhlYWQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGF0Um93RW5kSGVhZChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlUm93JylcbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlSGVhZCcpXG4gICAgY29uc3Qgb3JpZ2luYWxJbnRlcnJ1cHQgPSBzZWxmLmludGVycnVwdFxuICAgIHNlbGYuaW50ZXJydXB0ID0gdHJ1ZVxuICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICB7XG4gICAgICAgIHRva2VuaXplOiB0b2tlbml6ZVJvd0VuZCxcbiAgICAgICAgcGFydGlhbDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHNlbGYuaW50ZXJydXB0ID0gb3JpZ2luYWxJbnRlcnJ1cHRcbiAgICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJSb3cnKVxuICAgICAgICByZXR1cm4gYXREZWxpbWl0ZXJSb3dCcmVhayhjb2RlKVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHNlbGYuaW50ZXJydXB0ID0gb3JpZ2luYWxJbnRlcnJ1cHRcbiAgICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgfVxuICAgICkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGF0RGVsaW1pdGVyUm93QnJlYWsoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIHJvd0VuZERlbGltaXRlcihjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd3aGl0ZXNwYWNlJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluV2hpdGVzcGFjZURlbGltaXRlclxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA0NSkge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJGaWxsZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBoYXNEYXNoID0gdHJ1ZVxuICAgICAgYWxpZ24ucHVzaCgnbm9uZScpXG4gICAgICByZXR1cm4gaW5GaWxsZXJEZWxpbWl0ZXJcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNTgpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyQWxpZ25tZW50JylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZURlbGltaXRlckFsaWdubWVudCcpXG4gICAgICBhbGlnbi5wdXNoKCdsZWZ0JylcbiAgICAgIHJldHVybiBhZnRlckxlZnRBbGlnbm1lbnRcbiAgICB9IC8vIElmIHdlIHN0YXJ0IHdpdGggYSBwaXBlLCB3ZSBvcGVuIGEgY2VsbCBtYXJrZXIuXG5cbiAgICBpZiAoY29kZSA9PT0gMTI0KSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIHJldHVybiBhdERlbGltaXRlclJvd0JyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5XaGl0ZXNwYWNlRGVsaW1pdGVyKGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5XaGl0ZXNwYWNlRGVsaW1pdGVyXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCd3aGl0ZXNwYWNlJylcbiAgICByZXR1cm4gYXREZWxpbWl0ZXJSb3dCcmVhayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5GaWxsZXJEZWxpbWl0ZXIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0NSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5GaWxsZXJEZWxpbWl0ZXJcbiAgICB9XG5cbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcblxuICAgIGlmIChjb2RlID09PSA1OCkge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJBbGlnbm1lbnQnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyQWxpZ25tZW50JylcbiAgICAgIGFsaWduW2FsaWduLmxlbmd0aCAtIDFdID1cbiAgICAgICAgYWxpZ25bYWxpZ24ubGVuZ3RoIC0gMV0gPT09ICdsZWZ0JyA/ICdjZW50ZXInIDogJ3JpZ2h0J1xuICAgICAgcmV0dXJuIGFmdGVyUmlnaHRBbGlnbm1lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gYXREZWxpbWl0ZXJSb3dCcmVhayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJMZWZ0QWxpZ25tZW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDUpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgaGFzRGFzaCA9IHRydWVcbiAgICAgIHJldHVybiBpbkZpbGxlckRlbGltaXRlclxuICAgIH0gLy8gQW55dGhpbmcgZWxzZSBpcyBub3Qgb2suXG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlclJpZ2h0QWxpZ25tZW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiByb3dFbmREZWxpbWl0ZXIoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignd2hpdGVzcGFjZScpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbldoaXRlc3BhY2VEZWxpbWl0ZXJcbiAgICB9IC8vIGB8YFxuXG4gICAgaWYgKGNvZGUgPT09IDEyNCkge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICByZXR1cm4gYXREZWxpbWl0ZXJSb3dCcmVha1xuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHJvd0VuZERlbGltaXRlcihjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZURlbGltaXRlclJvdycpIC8vIEV4aXQgaWYgdGhlcmUgd2FzIG5vIGRhc2ggYXQgYWxsLCBvciBpZiB0aGUgaGVhZGVyIGNlbGwgY291bnQgaXMgbm90IHRoZVxuICAgIC8vIGRlbGltaXRlciBjZWxsIGNvdW50LlxuXG4gICAgaWYgKCFoYXNEYXNoIHx8IHRhYmxlSGVhZGVyQ291bnQgIT09IGFsaWduLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGFibGVDbG9zZShjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKFxuICAgICAgbmV4dFByZWZpeGVkT3JCbGFuayxcbiAgICAgIHRhYmxlQ2xvc2UsXG4gICAgICBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgIHtcbiAgICAgICAgICB0b2tlbml6ZTogdG9rZW5pemVSb3dFbmQsXG4gICAgICAgICAgcGFydGlhbDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYm9keVN0YXJ0LCAnbGluZVByZWZpeCcsIDQpLFxuICAgICAgICB0YWJsZUNsb3NlXG4gICAgICApXG4gICAgKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGFibGVDbG9zZShjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZScpXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBib2R5U3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlQm9keScpXG4gICAgcmV0dXJuIHJvd1N0YXJ0Qm9keShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gcm93U3RhcnRCb2R5KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCd0YWJsZVJvdycpIC8vIElmIHdlIHN0YXJ0IHdpdGggYSBwaXBlLCB3ZSBvcGVuIGEgY2VsbCBtYXJrZXIuXG5cbiAgICBpZiAoY29kZSA9PT0gMTI0KSB7XG4gICAgICByZXR1cm4gY2VsbERpdmlkZXJCb2R5KGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcigndGVtcG9yYXJ5VGFibGVDZWxsQ29udGVudCcpIC8vIENhblx1MjAxOXQgYmUgc3BhY2Ugb3IgZW9scyBhdCB0aGUgc3RhcnQgb2YgYSBjb25zdHJ1Y3QsIHNvIHdlXHUyMDE5cmUgaW4gYSBjZWxsLlxuXG4gICAgcmV0dXJuIGluQ2VsbENvbnRlbnRCb2R5KGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjZWxsRGl2aWRlckJvZHkoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgcmV0dXJuIGNlbGxCcmVha0JvZHlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNlbGxCcmVha0JvZHkoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIGF0Um93RW5kQm9keShjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd3aGl0ZXNwYWNlJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluV2hpdGVzcGFjZUJvZHlcbiAgICB9IC8vIGB8YFxuXG4gICAgaWYgKGNvZGUgPT09IDEyNCkge1xuICAgICAgcmV0dXJuIGNlbGxEaXZpZGVyQm9keShjb2RlKVxuICAgIH0gLy8gQW55dGhpbmcgZWxzZSBpcyBjZWxsIGNvbnRlbnQuXG5cbiAgICBlZmZlY3RzLmVudGVyKCd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50JylcbiAgICByZXR1cm4gaW5DZWxsQ29udGVudEJvZHkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGluV2hpdGVzcGFjZUJvZHkoY29kZSkge1xuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbldoaXRlc3BhY2VCb2R5XG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCd3aGl0ZXNwYWNlJylcbiAgICByZXR1cm4gY2VsbEJyZWFrQm9keShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5DZWxsQ29udGVudEJvZHkoY29kZSkge1xuICAgIC8vIEVPRiwgd2hpdGVzcGFjZSwgcGlwZVxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IDEyNCB8fCBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ3RlbXBvcmFyeVRhYmxlQ2VsbENvbnRlbnQnKVxuICAgICAgcmV0dXJuIGNlbGxCcmVha0JvZHkoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29kZSA9PT0gOTIgPyBpbkNlbGxDb250ZW50RXNjYXBlQm9keSA6IGluQ2VsbENvbnRlbnRCb2R5XG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBpbkNlbGxDb250ZW50RXNjYXBlQm9keShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDkyIHx8IGNvZGUgPT09IDEyNCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5DZWxsQ29udGVudEJvZHlcbiAgICB9IC8vIEFueXRoaW5nIGVsc2UuXG5cbiAgICByZXR1cm4gaW5DZWxsQ29udGVudEJvZHkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGF0Um93RW5kQm9keShjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZVJvdycpXG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRhYmxlQm9keUNsb3NlKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICBuZXh0UHJlZml4ZWRPckJsYW5rLFxuICAgICAgdGFibGVCb2R5Q2xvc2UsXG4gICAgICBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgIHtcbiAgICAgICAgICB0b2tlbml6ZTogdG9rZW5pemVSb3dFbmQsXG4gICAgICAgICAgcGFydGlhbDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBmYWN0b3J5U3BhY2UoZWZmZWN0cywgcm93U3RhcnRCb2R5LCAnbGluZVByZWZpeCcsIDQpLFxuICAgICAgICB0YWJsZUJvZHlDbG9zZVxuICAgICAgKVxuICAgICkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhYmxlQm9keUNsb3NlKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlQm9keScpXG4gICAgcmV0dXJuIHRhYmxlQ2xvc2UoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuICBmdW5jdGlvbiB0b2tlbml6ZVJvd0VuZChlZmZlY3RzLCBvaywgbm9rKSB7XG4gICAgcmV0dXJuIHN0YXJ0XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBwcmVmaXhlZCwgJ2xpbmVQcmVmaXgnKVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gcHJlZml4ZWQoY29kZSkge1xuICAgICAgLy8gQmxhbmsgb3IgaW50ZXJydXB0aW5nIGxpbmUuXG4gICAgICBpZiAoXG4gICAgICAgIHNlbGYucGFyc2VyLmxhenlbc2VsZi5ub3coKS5saW5lXSB8fFxuICAgICAgICBjb2RlID09PSBudWxsIHx8XG4gICAgICAgIG1hcmtkb3duTGluZUVuZGluZyhjb2RlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFpbCA9IHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdIC8vIEluZGVudGVkIGNvZGUgY2FuIGludGVycnVwdCBkZWxpbWl0ZXIgYW5kIGJvZHkgcm93cy5cblxuICAgICAgaWYgKFxuICAgICAgICAhc2VsZi5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoJ2NvZGVJbmRlbnRlZCcpICYmXG4gICAgICAgIHRhaWwgJiZcbiAgICAgICAgdGFpbFsxXS50eXBlID09PSAnbGluZVByZWZpeCcgJiZcbiAgICAgICAgdGFpbFsyXS5zbGljZVNlcmlhbGl6ZSh0YWlsWzFdLCB0cnVlKS5sZW5ndGggPj0gNFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cblxuICAgICAgc2VsZi5fZ2ZtVGFibGVEeW5hbWljSW50ZXJydXB0SGFjayA9IHRydWVcbiAgICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKFxuICAgICAgICBzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmZsb3csXG4gICAgICAgIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgc2VsZi5fZ2ZtVGFibGVEeW5hbWljSW50ZXJydXB0SGFjayA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIHNlbGYuX2dmbVRhYmxlRHluYW1pY0ludGVycnVwdEhhY2sgPSBmYWxzZVxuICAgICAgICAgIHJldHVybiBvayhjb2RlKVxuICAgICAgICB9XG4gICAgICApKGNvZGUpXG4gICAgfVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVOZXh0UHJlZml4ZWRPckJsYW5rKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgbGV0IHNpemUgPSAwXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAvLyBUaGlzIGlzIGEgY2hlY2ssIHNvIHdlIGRvblx1MjAxOXQgY2FyZSBhYm91dCB0b2tlbnMsIGJ1dCB3ZSBvcGVuIGEgYm9ndXMgb25lXG4gICAgLy8gc28gd2VcdTIwMTlyZSB2YWxpZC5cbiAgICBlZmZlY3RzLmVudGVyKCdjaGVjaycpIC8vIEVPTC5cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiB3aGl0ZXNwYWNlXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB3aGl0ZXNwYWNlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gLTEgfHwgY29kZSA9PT0gMzIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgc2l6ZSsrXG4gICAgICByZXR1cm4gc2l6ZSA9PT0gNCA/IG9rIDogd2hpdGVzcGFjZVxuICAgIH0gLy8gRU9GIG9yIHdoaXRlc3BhY2VcblxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH0gLy8gQW55dGhpbmcgZWxzZS5cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5Ob2RlfSBOb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLlBhcmVudH0gUGFyZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLlNhZmVPcHRpb25zfSBTYWZlT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5Db250ZXh0fSBDb250ZXh0XG4gKi9cblxuaW1wb3J0IHt0cmFja30gZnJvbSAnLi90cmFjay5qcydcblxuLyoqXG4gKiBAcGFyYW0ge1BhcmVudH0gcGFyZW50XG4gKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHRcbiAqIEBwYXJhbSB7U2FmZU9wdGlvbnN9IHNhZmVPcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbmVyUGhyYXNpbmcocGFyZW50LCBjb250ZXh0LCBzYWZlT3B0aW9ucykge1xuICBjb25zdCBpbmRleFN0YWNrID0gY29udGV4dC5pbmRleFN0YWNrXG4gIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuIHx8IFtdXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgcmVzdWx0cyA9IFtdXG4gIGxldCBpbmRleCA9IC0xXG4gIGxldCBiZWZvcmUgPSBzYWZlT3B0aW9ucy5iZWZvcmVcblxuICBpbmRleFN0YWNrLnB1c2goLTEpXG4gIGxldCB0cmFja2VyID0gdHJhY2soc2FmZU9wdGlvbnMpXG5cbiAgd2hpbGUgKCsraW5kZXggPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2luZGV4XVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGxldCBhZnRlclxuXG4gICAgaW5kZXhTdGFja1tpbmRleFN0YWNrLmxlbmd0aCAtIDFdID0gaW5kZXhcblxuICAgIGlmIChpbmRleCArIDEgPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGh1c2gsIGl0XHUyMDE5cyBhY3R1YWxseSBhIGB6d2l0Y2hgLlxuICAgICAgbGV0IGhhbmRsZSA9IGNvbnRleHQuaGFuZGxlLmhhbmRsZXJzW2NoaWxkcmVuW2luZGV4ICsgMV0udHlwZV1cbiAgICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlLnBlZWspIGhhbmRsZSA9IGhhbmRsZS5wZWVrXG4gICAgICBhZnRlciA9IGhhbmRsZVxuICAgICAgICA/IGhhbmRsZShjaGlsZHJlbltpbmRleCArIDFdLCBwYXJlbnQsIGNvbnRleHQsIHtcbiAgICAgICAgICAgIGJlZm9yZTogJycsXG4gICAgICAgICAgICBhZnRlcjogJycsXG4gICAgICAgICAgICAuLi50cmFja2VyLmN1cnJlbnQoKVxuICAgICAgICAgIH0pLmNoYXJBdCgwKVxuICAgICAgICA6ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyID0gc2FmZU9wdGlvbnMuYWZ0ZXJcbiAgICB9XG5cbiAgICAvLyBJbiBzb21lIGNhc2VzLCBodG1sICh0ZXh0KSBjYW4gYmUgZm91bmQgaW4gcGhyYXNpbmcgcmlnaHQgYWZ0ZXIgYW4gZW9sLlxuICAgIC8vIFdoZW4gd2VcdTIwMTlkIHNlcmlhbGl6ZSB0aGF0LCBpbiBtb3N0IGNhc2VzIHRoYXQgd291bGQgYmUgc2VlbiBhcyBodG1sXG4gICAgLy8gKGZsb3cpLlxuICAgIC8vIEFzIHdlIGNhblx1MjAxOXQgZXNjYXBlIG9yIHNvIHRvIHByZXZlbnQgaXQgZnJvbSBoYXBwZW5pbmcsIHdlIHRha2UgYSBzb21ld2hhdFxuICAgIC8vIHJlYXNvbmFibGUgYXBwcm9hY2g6IHJlcGxhY2UgdGhhdCBlb2wgd2l0aCBhIHNwYWNlLlxuICAgIC8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2lzc3Vlcy8xNT5cbiAgICBpZiAoXG4gICAgICByZXN1bHRzLmxlbmd0aCA+IDAgJiZcbiAgICAgIChiZWZvcmUgPT09ICdcXHInIHx8IGJlZm9yZSA9PT0gJ1xcbicpICYmXG4gICAgICBjaGlsZC50eXBlID09PSAnaHRtbCdcbiAgICApIHtcbiAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXSA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXS5yZXBsYWNlKFxuICAgICAgICAvKFxccj9cXG58XFxyKSQvLFxuICAgICAgICAnICdcbiAgICAgIClcbiAgICAgIGJlZm9yZSA9ICcgJ1xuXG4gICAgICAvLyBUbyBkbzogZG9lcyB0aGlzIHdvcmsgdG8gcmVzZXQgdHJhY2tlcj9cbiAgICAgIHRyYWNrZXIgPSB0cmFjayhzYWZlT3B0aW9ucylcbiAgICAgIHRyYWNrZXIubW92ZShyZXN1bHRzLmpvaW4oJycpKVxuICAgIH1cblxuICAgIHJlc3VsdHMucHVzaChcbiAgICAgIHRyYWNrZXIubW92ZShcbiAgICAgICAgY29udGV4dC5oYW5kbGUoY2hpbGQsIHBhcmVudCwgY29udGV4dCwge1xuICAgICAgICAgIC4uLnRyYWNrZXIuY3VycmVudCgpLFxuICAgICAgICAgIGJlZm9yZSxcbiAgICAgICAgICBhZnRlclxuICAgICAgICB9KVxuICAgICAgKVxuICAgIClcblxuICAgIGJlZm9yZSA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXS5zbGljZSgtMSlcbiAgfVxuXG4gIGluZGV4U3RhY2sucG9wKClcblxuICByZXR1cm4gcmVzdWx0cy5qb2luKCcnKVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5BbGlnblR5cGV9IEFsaWduVHlwZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UYWJsZX0gVGFibGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGFibGVSb3d9IFRhYmxlUm93XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlRhYmxlQ2VsbH0gVGFibGVDZWxsXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLklubGluZUNvZGV9IElubGluZUNvZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21hcmtkb3duLXRhYmxlJykuTWFya2Rvd25UYWJsZU9wdGlvbnN9IE1hcmtkb3duVGFibGVPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5FeHRlbnNpb259IEZyb21NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuSGFuZGxlfSBGcm9tTWFya2Rvd25IYW5kbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5PcHRpb25zfSBUb01hcmtkb3duRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuSGFuZGxlfSBUb01hcmtkb3duSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuQ29udGV4dH0gVG9NYXJrZG93bkNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5TYWZlT3B0aW9uc30gU2FmZU9wdGlvbnNcbiAqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt0YWJsZUNlbGxQYWRkaW5nPXRydWVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt0YWJsZVBpcGVBbGlnbj10cnVlXVxuICogQHByb3BlcnR5IHtNYXJrZG93blRhYmxlT3B0aW9uc1snc3RyaW5nTGVuZ3RoJ119IFtzdHJpbmdMZW5ndGhdXG4gKi9cblxuaW1wb3J0IHtjb250YWluZXJQaHJhc2luZ30gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9jb250YWluZXItcGhyYXNpbmcuanMnXG5pbXBvcnQge2lubGluZUNvZGV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL2hhbmRsZS9pbmxpbmUtY29kZS5qcydcbmltcG9ydCB7bWFya2Rvd25UYWJsZX0gZnJvbSAnbWFya2Rvd24tdGFibGUnXG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duRXh0ZW5zaW9ufSAqL1xuZXhwb3J0IGNvbnN0IGdmbVRhYmxlRnJvbU1hcmtkb3duID0ge1xuICBlbnRlcjoge1xuICAgIHRhYmxlOiBlbnRlclRhYmxlLFxuICAgIHRhYmxlRGF0YTogZW50ZXJDZWxsLFxuICAgIHRhYmxlSGVhZGVyOiBlbnRlckNlbGwsXG4gICAgdGFibGVSb3c6IGVudGVyUm93XG4gIH0sXG4gIGV4aXQ6IHtcbiAgICBjb2RlVGV4dDogZXhpdENvZGVUZXh0LFxuICAgIHRhYmxlOiBleGl0VGFibGUsXG4gICAgdGFibGVEYXRhOiBleGl0LFxuICAgIHRhYmxlSGVhZGVyOiBleGl0LFxuICAgIHRhYmxlUm93OiBleGl0XG4gIH1cbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBlbnRlclRhYmxlKHRva2VuKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8J2xlZnQnfCdyaWdodCd8J2NlbnRlcid8J25vbmUnPn0gKi9cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGFsaWduYCBpcyBjdXN0b20uXG4gIGNvbnN0IGFsaWduID0gdG9rZW4uX2FsaWduXG4gIHRoaXMuZW50ZXIoXG4gICAge1xuICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgIGFsaWduOiBhbGlnbi5tYXAoKGQpID0+IChkID09PSAnbm9uZScgPyBudWxsIDogZCkpLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSxcbiAgICB0b2tlblxuICApXG4gIHRoaXMuc2V0RGF0YSgnaW5UYWJsZScsIHRydWUpXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZXhpdFRhYmxlKHRva2VuKSB7XG4gIHRoaXMuZXhpdCh0b2tlbilcbiAgdGhpcy5zZXREYXRhKCdpblRhYmxlJylcbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBlbnRlclJvdyh0b2tlbikge1xuICB0aGlzLmVudGVyKHt0eXBlOiAndGFibGVSb3cnLCBjaGlsZHJlbjogW119LCB0b2tlbilcbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBleGl0KHRva2VuKSB7XG4gIHRoaXMuZXhpdCh0b2tlbilcbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBlbnRlckNlbGwodG9rZW4pIHtcbiAgdGhpcy5lbnRlcih7dHlwZTogJ3RhYmxlQ2VsbCcsIGNoaWxkcmVuOiBbXX0sIHRva2VuKVxufVxuXG4vLyBPdmVyd3JpdGUgdGhlIGRlZmF1bHQgY29kZSB0ZXh0IGRhdGEgaGFuZGxlciB0byB1bmVzY2FwZSBlc2NhcGVkIHBpcGVzIHdoZW5cbi8vIHRoZXkgYXJlIGluIHRhYmxlcy5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZXhpdENvZGVUZXh0KHRva2VuKSB7XG4gIGxldCB2YWx1ZSA9IHRoaXMucmVzdW1lKClcblxuICBpZiAodGhpcy5nZXREYXRhKCdpblRhYmxlJykpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwoW1xcXFx8XSkvZywgcmVwbGFjZSlcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSAvKiogQHR5cGUge0lubGluZUNvZGV9ICovICh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0pXG4gIG5vZGUudmFsdWUgPSB2YWx1ZVxuICB0aGlzLmV4aXQodG9rZW4pXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9ICQwXG4gKiBAcGFyYW0ge3N0cmluZ30gJDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2UoJDAsICQxKSB7XG4gIC8vIFBpcGVzIHdvcmssIGJhY2tzbGFzaGVzIGRvblx1MjAxOXQgKGJ1dCBjYW5cdTIwMTl0IGVzY2FwZSBwaXBlcykuXG4gIHJldHVybiAkMSA9PT0gJ3wnID8gJDEgOiAkMFxufVxuXG4vKipcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7VG9NYXJrZG93bkV4dGVuc2lvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVRhYmxlVG9NYXJrZG93bihvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBwYWRkaW5nID0gc2V0dGluZ3MudGFibGVDZWxsUGFkZGluZ1xuICBjb25zdCBhbGlnbkRlbGltaXRlcnMgPSBzZXR0aW5ncy50YWJsZVBpcGVBbGlnblxuICBjb25zdCBzdHJpbmdMZW5ndGggPSBzZXR0aW5ncy5zdHJpbmdMZW5ndGhcbiAgY29uc3QgYXJvdW5kID0gcGFkZGluZyA/ICcgJyA6ICd8J1xuXG4gIHJldHVybiB7XG4gICAgdW5zYWZlOiBbXG4gICAgICB7Y2hhcmFjdGVyOiAnXFxyJywgaW5Db25zdHJ1Y3Q6ICd0YWJsZUNlbGwnfSxcbiAgICAgIHtjaGFyYWN0ZXI6ICdcXG4nLCBpbkNvbnN0cnVjdDogJ3RhYmxlQ2VsbCd9LFxuICAgICAgLy8gQSBwaXBlLCB3aGVuIGZvbGxvd2VkIGJ5IGEgdGFiIG9yIHNwYWNlIChwYWRkaW5nKSwgb3IgYSBkYXNoIG9yIGNvbG9uXG4gICAgICAvLyAodW5wYWRkZWQgZGVsaW1pdGVyIHJvdyksIGNvdWxkIHJlc3VsdCBpbiBhIHRhYmxlLlxuICAgICAge2F0QnJlYWs6IHRydWUsIGNoYXJhY3RlcjogJ3wnLCBhZnRlcjogJ1tcXHQgOi1dJ30sXG4gICAgICAvLyBBIHBpcGUgaW4gYSBjZWxsIG11c3QgYmUgZW5jb2RlZC5cbiAgICAgIHtjaGFyYWN0ZXI6ICd8JywgaW5Db25zdHJ1Y3Q6ICd0YWJsZUNlbGwnfSxcbiAgICAgIC8vIEEgY29sb24gbXVzdCBiZSBmb2xsb3dlZCBieSBhIGRhc2gsIGluIHdoaWNoIGNhc2UgaXQgY291bGQgc3RhcnQgYVxuICAgICAgLy8gZGVsaW1pdGVyIHJvdy5cbiAgICAgIHthdEJyZWFrOiB0cnVlLCBjaGFyYWN0ZXI6ICc6JywgYWZ0ZXI6ICctJ30sXG4gICAgICAvLyBBIGRlbGltaXRlciByb3cgY2FuIGFsc28gc3RhcnQgd2l0aCBhIGRhc2gsIHdoZW4gZm9sbG93ZWQgYnkgbW9yZVxuICAgICAgLy8gZGFzaGVzLCBhIGNvbG9uLCBvciBhIHBpcGUuXG4gICAgICAvLyBUaGlzIGlzIGEgc3RyaWN0ZXIgdmVyc2lvbiB0aGFuIHRoZSBidWlsdCBpbiBjaGVjayBmb3IgbGlzdHMsIHRoZW1hdGljXG4gICAgICAvLyBicmVha3MsIGFuZCBzZXRleCBoZWFkaW5nIHVuZGVybGluZXMgdGhvdWdoOlxuICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2Jsb2IvNTFhMjAzOC9saWIvdW5zYWZlLmpzI0w1Nz5cbiAgICAgIHthdEJyZWFrOiB0cnVlLCBjaGFyYWN0ZXI6ICctJywgYWZ0ZXI6ICdbOnwtXSd9XG4gICAgXSxcbiAgICBoYW5kbGVyczoge1xuICAgICAgdGFibGU6IGhhbmRsZVRhYmxlLFxuICAgICAgdGFibGVSb3c6IGhhbmRsZVRhYmxlUm93LFxuICAgICAgdGFibGVDZWxsOiBoYW5kbGVUYWJsZUNlbGwsXG4gICAgICBpbmxpbmVDb2RlOiBpbmxpbmVDb2RlV2l0aFRhYmxlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfVxuICAgKiBAcGFyYW0ge1RhYmxlfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVUYWJsZShub2RlLCBfLCBjb250ZXh0LCBzYWZlT3B0aW9ucykge1xuICAgIHJldHVybiBzZXJpYWxpemVEYXRhKFxuICAgICAgaGFuZGxlVGFibGVBc0RhdGEobm9kZSwgY29udGV4dCwgc2FmZU9wdGlvbnMpLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogZml4ZWQgaW4gYG1hcmtkb3duLXRhYmxlQDMuMC4xYC5cbiAgICAgIG5vZGUuYWxpZ25cbiAgICApXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpc25cdTIwMTl0IHJlYWxseSB1c2VkIG5vcm1hbGx5LCBiZWNhdXNlIHdlIGhhbmRsZSByb3dzIGF0IHRoZVxuICAgKiB0YWJsZSBsZXZlbC5cbiAgICogQnV0LCBpZiBzb21lb25lIHBhc3NlcyBpbiBhIHRhYmxlIHJvdywgdGhpcyBlbnN1cmVzIHdlIG1ha2Ugc29tZXdoYXQgc2Vuc2UuXG4gICAqXG4gICAqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfVxuICAgKiBAcGFyYW0ge1RhYmxlUm93fSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVUYWJsZVJvdyhub2RlLCBfLCBjb250ZXh0LCBzYWZlT3B0aW9ucykge1xuICAgIGNvbnN0IHJvdyA9IGhhbmRsZVRhYmxlUm93QXNEYXRhKG5vZGUsIGNvbnRleHQsIHNhZmVPcHRpb25zKVxuICAgIC8vIGBtYXJrZG93bi10YWJsZWAgd2lsbCBhbHdheXMgYWRkIGFuIGFsaWduIHJvd1xuICAgIGNvbnN0IHZhbHVlID0gc2VyaWFsaXplRGF0YShbcm93XSlcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCwgdmFsdWUuaW5kZXhPZignXFxuJykpXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gICAqIEBwYXJhbSB7VGFibGVDZWxsfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVUYWJsZUNlbGwobm9kZSwgXywgY29udGV4dCwgc2FmZU9wdGlvbnMpIHtcbiAgICBjb25zdCBleGl0ID0gY29udGV4dC5lbnRlcigndGFibGVDZWxsJylcbiAgICBjb25zdCBzdWJleGl0ID0gY29udGV4dC5lbnRlcigncGhyYXNpbmcnKVxuICAgIGNvbnN0IHZhbHVlID0gY29udGFpbmVyUGhyYXNpbmcobm9kZSwgY29udGV4dCwge1xuICAgICAgLi4uc2FmZU9wdGlvbnMsXG4gICAgICBiZWZvcmU6IGFyb3VuZCxcbiAgICAgIGFmdGVyOiBhcm91bmRcbiAgICB9KVxuICAgIHN1YmV4aXQoKVxuICAgIGV4aXQoKVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8c3RyaW5nPj59IG1hdHJpeFxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFthbGlnbl1cbiAgICovXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZURhdGEobWF0cml4LCBhbGlnbikge1xuICAgIHJldHVybiBtYXJrZG93blRhYmxlKG1hdHJpeCwge1xuICAgICAgYWxpZ24sXG4gICAgICBhbGlnbkRlbGltaXRlcnMsXG4gICAgICBwYWRkaW5nLFxuICAgICAgc3RyaW5nTGVuZ3RoXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RhYmxlfSBub2RlXG4gICAqIEBwYXJhbSB7VG9NYXJrZG93bkNvbnRleHR9IGNvbnRleHRcbiAgICogQHBhcmFtIHtTYWZlT3B0aW9uc30gc2FmZU9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZVRhYmxlQXNEYXRhKG5vZGUsIGNvbnRleHQsIHNhZmVPcHRpb25zKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuXG4gICAgbGV0IGluZGV4ID0gLTFcbiAgICAvKiogQHR5cGUge0FycmF5PEFycmF5PHN0cmluZz4+fSAqL1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdXG4gICAgY29uc3Qgc3ViZXhpdCA9IGNvbnRleHQuZW50ZXIoJ3RhYmxlJylcblxuICAgIHdoaWxlICgrK2luZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaGFuZGxlVGFibGVSb3dBc0RhdGEoXG4gICAgICAgIGNoaWxkcmVuW2luZGV4XSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgc2FmZU9wdGlvbnNcbiAgICAgIClcbiAgICB9XG5cbiAgICBzdWJleGl0KClcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RhYmxlUm93fSBub2RlXG4gICAqIEBwYXJhbSB7VG9NYXJrZG93bkNvbnRleHR9IGNvbnRleHRcbiAgICogQHBhcmFtIHtTYWZlT3B0aW9uc30gc2FmZU9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZVRhYmxlUm93QXNEYXRhKG5vZGUsIGNvbnRleHQsIHNhZmVPcHRpb25zKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuXG4gICAgbGV0IGluZGV4ID0gLTFcbiAgICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gICAgY29uc3QgcmVzdWx0ID0gW11cbiAgICBjb25zdCBzdWJleGl0ID0gY29udGV4dC5lbnRlcigndGFibGVSb3cnKVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIE5vdGU6IHRoZSBwb3NpdGlvbmFsIGluZm8gYXMgdXNlZCBoZXJlIGlzIGluY29ycmVjdC5cbiAgICAgIC8vIE1ha2luZyBpdCBjb3JyZWN0IHdvdWxkIGJlIGltcG9zc2libGUgZHVlIHRvIGFsaWduaW5nIGNlbGxzP1xuICAgICAgLy8gQW5kIGl0IHdvdWxkIG5lZWQgY29weS9wYXN0aW5nIGBtYXJrZG93bi10YWJsZWAgaW50byB0aGlzIHByb2plY3QuXG4gICAgICByZXN1bHRbaW5kZXhdID0gaGFuZGxlVGFibGVDZWxsKFxuICAgICAgICBjaGlsZHJlbltpbmRleF0sXG4gICAgICAgIG5vZGUsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHNhZmVPcHRpb25zXG4gICAgICApXG4gICAgfVxuXG4gICAgc3ViZXhpdCgpXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gICAqIEBwYXJhbSB7SW5saW5lQ29kZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gaW5saW5lQ29kZVdpdGhUYWJsZShub2RlLCBwYXJlbnQsIGNvbnRleHQpIHtcbiAgICBsZXQgdmFsdWUgPSBpbmxpbmVDb2RlKG5vZGUsIHBhcmVudCwgY29udGV4dClcblxuICAgIGlmIChjb250ZXh0LnN0YWNrLmluY2x1ZGVzKCd0YWJsZUNlbGwnKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHwvZywgJ1xcXFwkJicpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXh0ZW5zaW9ufSBFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUmVzb2x2ZXJ9IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NpbmdsZVRpbGRlPXRydWVdXG4gKiAgIFdoZXRoZXIgdG8gc3VwcG9ydCBzdHJpa2V0aHJvdWdoIHdpdGggYSBzaW5nbGUgdGlsZGUgKGBib29sZWFuYCwgZGVmYXVsdDpcbiAqICAgYHRydWVgKS5cbiAqICAgU2luZ2xlIHRpbGRlcyB3b3JrIG9uIGdpdGh1Yi5jb20sIGJ1dCBhcmUgdGVjaG5pY2FsbHkgcHJvaGliaXRlZCBieSB0aGVcbiAqICAgR0ZNIHNwZWMuXG4gKi9cbmltcG9ydCB7c3BsaWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaHVua2VkJ1xuaW1wb3J0IHtjbGFzc2lmeUNoYXJhY3Rlcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2xhc3NpZnktY2hhcmFjdGVyJ1xuaW1wb3J0IHtyZXNvbHZlQWxsfSBmcm9tICdtaWNyb21hcmstdXRpbC1yZXNvbHZlLWFsbCdcblxuLyoqXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge0V4dGVuc2lvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVN0cmlrZXRocm91Z2gob3B0aW9ucyA9IHt9KSB7XG4gIGxldCBzaW5nbGUgPSBvcHRpb25zLnNpbmdsZVRpbGRlXG4gIGNvbnN0IHRva2VuaXplciA9IHtcbiAgICB0b2tlbml6ZTogdG9rZW5pemVTdHJpa2V0aHJvdWdoLFxuICAgIHJlc29sdmVBbGw6IHJlc29sdmVBbGxTdHJpa2V0aHJvdWdoXG4gIH1cblxuICBpZiAoc2luZ2xlID09PSBudWxsIHx8IHNpbmdsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2luZ2xlID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0ZXh0OiB7XG4gICAgICBbMTI2XTogdG9rZW5pemVyXG4gICAgfSxcbiAgICBpbnNpZGVTcGFuOiB7XG4gICAgICBudWxsOiBbdG9rZW5pemVyXVxuICAgIH0sXG4gICAgYXR0ZW50aW9uTWFya2Vyczoge1xuICAgICAgbnVsbDogWzEyNl1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRha2UgZXZlbnRzIGFuZCByZXNvbHZlIHN0cmlrZXRocm91Z2guXG4gICAqXG4gICAqIEB0eXBlIHtSZXNvbHZlcn1cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFsbFN0cmlrZXRocm91Z2goZXZlbnRzLCBjb250ZXh0KSB7XG4gICAgbGV0IGluZGV4ID0gLTEgLy8gV2FsayB0aHJvdWdoIGFsbCBldmVudHMuXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEZpbmQgYSB0b2tlbiB0aGF0IGNhbiBjbG9zZS5cbiAgICAgIGlmIChcbiAgICAgICAgZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJyAmJlxuICAgICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdzdHJpa2V0aHJvdWdoU2VxdWVuY2VUZW1wb3JhcnknICYmXG4gICAgICAgIGV2ZW50c1tpbmRleF1bMV0uX2Nsb3NlXG4gICAgICApIHtcbiAgICAgICAgbGV0IG9wZW4gPSBpbmRleCAvLyBOb3cgd2FsayBiYWNrIHRvIGZpbmQgYW4gb3BlbmVyLlxuXG4gICAgICAgIHdoaWxlIChvcGVuLS0pIHtcbiAgICAgICAgICAvLyBGaW5kIGEgdG9rZW4gdGhhdCBjYW4gb3BlbiB0aGUgY2xvc2VyLlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGV2ZW50c1tvcGVuXVswXSA9PT0gJ2V4aXQnICYmXG4gICAgICAgICAgICBldmVudHNbb3Blbl1bMV0udHlwZSA9PT0gJ3N0cmlrZXRocm91Z2hTZXF1ZW5jZVRlbXBvcmFyeScgJiZcbiAgICAgICAgICAgIGV2ZW50c1tvcGVuXVsxXS5fb3BlbiAmJiAvLyBJZiB0aGUgc2l6ZXMgYXJlIHRoZSBzYW1lOlxuICAgICAgICAgICAgZXZlbnRzW2luZGV4XVsxXS5lbmQub2Zmc2V0IC0gZXZlbnRzW2luZGV4XVsxXS5zdGFydC5vZmZzZXQgPT09XG4gICAgICAgICAgICAgIGV2ZW50c1tvcGVuXVsxXS5lbmQub2Zmc2V0IC0gZXZlbnRzW29wZW5dWzFdLnN0YXJ0Lm9mZnNldFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID0gJ3N0cmlrZXRocm91Z2hTZXF1ZW5jZSdcbiAgICAgICAgICAgIGV2ZW50c1tvcGVuXVsxXS50eXBlID0gJ3N0cmlrZXRocm91Z2hTZXF1ZW5jZSdcbiAgICAgICAgICAgIGNvbnN0IHN0cmlrZXRocm91Z2ggPSB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpa2V0aHJvdWdoJyxcbiAgICAgICAgICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tvcGVuXVsxXS5zdGFydCksXG4gICAgICAgICAgICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2luZGV4XVsxXS5lbmQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0ge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaWtldGhyb3VnaFRleHQnLFxuICAgICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW29wZW5dWzFdLmVuZCksXG4gICAgICAgICAgICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2luZGV4XVsxXS5zdGFydClcbiAgICAgICAgICAgIH0gLy8gT3BlbmluZy5cblxuICAgICAgICAgICAgY29uc3QgbmV4dEV2ZW50cyA9IFtcbiAgICAgICAgICAgICAgWydlbnRlcicsIHN0cmlrZXRocm91Z2gsIGNvbnRleHRdLFxuICAgICAgICAgICAgICBbJ2VudGVyJywgZXZlbnRzW29wZW5dWzFdLCBjb250ZXh0XSxcbiAgICAgICAgICAgICAgWydleGl0JywgZXZlbnRzW29wZW5dWzFdLCBjb250ZXh0XSxcbiAgICAgICAgICAgICAgWydlbnRlcicsIHRleHQsIGNvbnRleHRdXG4gICAgICAgICAgICBdIC8vIEJldHdlZW4uXG5cbiAgICAgICAgICAgIHNwbGljZShcbiAgICAgICAgICAgICAgbmV4dEV2ZW50cyxcbiAgICAgICAgICAgICAgbmV4dEV2ZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIHJlc29sdmVBbGwoXG4gICAgICAgICAgICAgICAgY29udGV4dC5wYXJzZXIuY29uc3RydWN0cy5pbnNpZGVTcGFuLm51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRzLnNsaWNlKG9wZW4gKyAxLCBpbmRleCksXG4gICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIC8vIENsb3NpbmcuXG5cbiAgICAgICAgICAgIHNwbGljZShuZXh0RXZlbnRzLCBuZXh0RXZlbnRzLmxlbmd0aCwgMCwgW1xuICAgICAgICAgICAgICBbJ2V4aXQnLCB0ZXh0LCBjb250ZXh0XSxcbiAgICAgICAgICAgICAgWydlbnRlcicsIGV2ZW50c1tpbmRleF1bMV0sIGNvbnRleHRdLFxuICAgICAgICAgICAgICBbJ2V4aXQnLCBldmVudHNbaW5kZXhdWzFdLCBjb250ZXh0XSxcbiAgICAgICAgICAgICAgWydleGl0Jywgc3RyaWtldGhyb3VnaCwgY29udGV4dF1cbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBzcGxpY2UoZXZlbnRzLCBvcGVuIC0gMSwgaW5kZXggLSBvcGVuICsgMywgbmV4dEV2ZW50cylcbiAgICAgICAgICAgIGluZGV4ID0gb3BlbiArIG5leHRFdmVudHMubGVuZ3RoIC0gMlxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmIChldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdzdHJpa2V0aHJvdWdoU2VxdWVuY2VUZW1wb3JhcnknKSB7XG4gICAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9ICdkYXRhJ1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmVudHNcbiAgfVxuICAvKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuICBmdW5jdGlvbiB0b2tlbml6ZVN0cmlrZXRocm91Z2goZWZmZWN0cywgb2ssIG5vaykge1xuICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5wcmV2aW91c1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuZXZlbnRzXG4gICAgbGV0IHNpemUgPSAwXG4gICAgcmV0dXJuIHN0YXJ0XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcHJldmlvdXMgPT09IDEyNiAmJlxuICAgICAgICBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdWzFdLnR5cGUgIT09ICdjaGFyYWN0ZXJFc2NhcGUnXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgfVxuXG4gICAgICBlZmZlY3RzLmVudGVyKCdzdHJpa2V0aHJvdWdoU2VxdWVuY2VUZW1wb3JhcnknKVxuICAgICAgcmV0dXJuIG1vcmUoY29kZSlcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIG1vcmUoY29kZSkge1xuICAgICAgY29uc3QgYmVmb3JlID0gY2xhc3NpZnlDaGFyYWN0ZXIocHJldmlvdXMpXG5cbiAgICAgIGlmIChjb2RlID09PSAxMjYpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgdGhpcmQgbWFya2VyLCBleGl0LlxuICAgICAgICBpZiAoc2l6ZSA+IDEpIHJldHVybiBub2soY29kZSlcbiAgICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICAgIHNpemUrK1xuICAgICAgICByZXR1cm4gbW9yZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSA8IDIgJiYgIXNpbmdsZSkgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgY29uc3QgdG9rZW4gPSBlZmZlY3RzLmV4aXQoJ3N0cmlrZXRocm91Z2hTZXF1ZW5jZVRlbXBvcmFyeScpXG4gICAgICBjb25zdCBhZnRlciA9IGNsYXNzaWZ5Q2hhcmFjdGVyKGNvZGUpXG4gICAgICB0b2tlbi5fb3BlbiA9ICFhZnRlciB8fCAoYWZ0ZXIgPT09IDIgJiYgQm9vbGVhbihiZWZvcmUpKVxuICAgICAgdG9rZW4uX2Nsb3NlID0gIWJlZm9yZSB8fCAoYmVmb3JlID09PSAyICYmIEJvb2xlYW4oYWZ0ZXIpKVxuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkRlbGV0ZX0gRGVsZXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5FeHRlbnNpb259IEZyb21NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuSGFuZGxlfSBGcm9tTWFya2Rvd25IYW5kbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5PcHRpb25zfSBUb01hcmtkb3duRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuSGFuZGxlfSBUb01hcmtkb3duSGFuZGxlXG4gKi9cblxuaW1wb3J0IHtjb250YWluZXJQaHJhc2luZ30gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9jb250YWluZXItcGhyYXNpbmcuanMnXG5pbXBvcnQge3RyYWNrfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL3RyYWNrLmpzJ1xuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93bkV4dGVuc2lvbn0gKi9cbmV4cG9ydCBjb25zdCBnZm1TdHJpa2V0aHJvdWdoRnJvbU1hcmtkb3duID0ge1xuICBjYW5Db250YWluRW9sczogWydkZWxldGUnXSxcbiAgZW50ZXI6IHtzdHJpa2V0aHJvdWdoOiBlbnRlclN0cmlrZXRocm91Z2h9LFxuICBleGl0OiB7c3RyaWtldGhyb3VnaDogZXhpdFN0cmlrZXRocm91Z2h9XG59XG5cbi8qKlxuICogTGlzdCBvZiBjb25zdHJ1Y3RzIHRoYXQgb2NjdXIgaW4gcGhyYXNpbmcgKHBhcmFncmFwaHMsIGhlYWRpbmdzKSwgYnV0IGNhbm5vdFxuICogY29udGFpbiBzdHJpa2V0aHJvdWdocy4gU28gdGhleSBzb3J0IG9mIGNhbmNlbCBlYWNoIG90aGVyIG91dC5cbiAqXG4gKiBOb3RlOiBrZWVwIGluIHN5bmMgd2l0aDogPGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2Jsb2IvYzQ3NzQzYi9saWIvdW5zYWZlLmpzI0wxMT5cbiAqL1xuY29uc3QgY29uc3RydWN0c1dpdGhvdXRTdHJpa2V0aHJvdWdoID0gW1xuICAnYXV0b2xpbmsnLFxuICAnZGVzdGluYXRpb25MaXRlcmFsJyxcbiAgJ2Rlc3RpbmF0aW9uUmF3JyxcbiAgJ3JlZmVyZW5jZScsXG4gICd0aXRsZVF1b3RlJyxcbiAgJ3RpdGxlQXBvc3Ryb3BoZSdcbl1cblxuLyoqIEB0eXBlIHtUb01hcmtkb3duRXh0ZW5zaW9ufSAqL1xuZXhwb3J0IGNvbnN0IGdmbVN0cmlrZXRocm91Z2hUb01hcmtkb3duID0ge1xuICB1bnNhZmU6IFtcbiAgICB7XG4gICAgICBjaGFyYWN0ZXI6ICd+JyxcbiAgICAgIGluQ29uc3RydWN0OiAncGhyYXNpbmcnLFxuICAgICAgbm90SW5Db25zdHJ1Y3Q6IGNvbnN0cnVjdHNXaXRob3V0U3RyaWtldGhyb3VnaFxuICAgIH1cbiAgXSxcbiAgaGFuZGxlcnM6IHtkZWxldGU6IGhhbmRsZURlbGV0ZX1cbn1cblxuaGFuZGxlRGVsZXRlLnBlZWsgPSBwZWVrRGVsZXRlXG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZW50ZXJTdHJpa2V0aHJvdWdoKHRva2VuKSB7XG4gIHRoaXMuZW50ZXIoe3R5cGU6ICdkZWxldGUnLCBjaGlsZHJlbjogW119LCB0b2tlbilcbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBleGl0U3RyaWtldGhyb3VnaCh0b2tlbikge1xuICB0aGlzLmV4aXQodG9rZW4pXG59XG5cbi8qKlxuICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gKiBAcGFyYW0ge0RlbGV0ZX0gbm9kZVxuICovXG5mdW5jdGlvbiBoYW5kbGVEZWxldGUobm9kZSwgXywgY29udGV4dCwgc2FmZU9wdGlvbnMpIHtcbiAgY29uc3QgdHJhY2tlciA9IHRyYWNrKHNhZmVPcHRpb25zKVxuICBjb25zdCBleGl0ID0gY29udGV4dC5lbnRlcignZW1waGFzaXMnKVxuICBsZXQgdmFsdWUgPSB0cmFja2VyLm1vdmUoJ35+JylcbiAgdmFsdWUgKz0gY29udGFpbmVyUGhyYXNpbmcobm9kZSwgY29udGV4dCwge1xuICAgIC4uLnRyYWNrZXIuY3VycmVudCgpLFxuICAgIGJlZm9yZTogdmFsdWUsXG4gICAgYWZ0ZXI6ICd+J1xuICB9KVxuICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJ35+JylcbiAgZXhpdCgpXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKiogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBwZWVrRGVsZXRlKCkge1xuICByZXR1cm4gJ34nXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4dGVuc2lvbn0gRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlJlc29sdmVyfSBSZXNvbHZlclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXhpdGVyfSBFeGl0ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICovXG5pbXBvcnQge2JsYW5rTGluZX0gZnJvbSAnbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyaydcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7XG4gIG1hcmtkb3duTGluZUVuZGluZyxcbiAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZVxufSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge25vcm1hbGl6ZUlkZW50aWZpZXJ9IGZyb20gJ21pY3JvbWFyay11dGlsLW5vcm1hbGl6ZS1pZGVudGlmaWVyJ1xuY29uc3QgaW5kZW50ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVJbmRlbnQsXG4gIHBhcnRpYWw6IHRydWVcbn1cbi8qKlxuICogQHJldHVybnMge0V4dGVuc2lvbn1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2ZtRm9vdG5vdGUoKSB7XG4gIC8qKiBAdHlwZSB7RXh0ZW5zaW9ufSAqL1xuICByZXR1cm4ge1xuICAgIGRvY3VtZW50OiB7XG4gICAgICBbOTFdOiB7XG4gICAgICAgIHRva2VuaXplOiB0b2tlbml6ZURlZmluaXRpb25TdGFydCxcbiAgICAgICAgY29udGludWF0aW9uOiB7XG4gICAgICAgICAgdG9rZW5pemU6IHRva2VuaXplRGVmaW5pdGlvbkNvbnRpbnVhdGlvblxuICAgICAgICB9LFxuICAgICAgICBleGl0OiBnZm1Gb290bm90ZURlZmluaXRpb25FbmRcbiAgICAgIH1cbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIFs5MV06IHtcbiAgICAgICAgdG9rZW5pemU6IHRva2VuaXplR2ZtRm9vdG5vdGVDYWxsXG4gICAgICB9LFxuICAgICAgWzkzXToge1xuICAgICAgICBhZGQ6ICdhZnRlcicsXG4gICAgICAgIHRva2VuaXplOiB0b2tlbml6ZVBvdGVudGlhbEdmbUZvb3Rub3RlQ2FsbCxcbiAgICAgICAgcmVzb2x2ZVRvOiByZXNvbHZlVG9Qb3RlbnRpYWxHZm1Gb290bm90ZUNhbGxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZVBvdGVudGlhbEdmbUZvb3Rub3RlQ2FsbChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGxldCBpbmRleCA9IHNlbGYuZXZlbnRzLmxlbmd0aFxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgSXRcdTIwMTlzIGZpbmUhXG5cbiAgY29uc3QgZGVmaW5lZCA9IHNlbGYucGFyc2VyLmdmbUZvb3Rub3RlcyB8fCAoc2VsZi5wYXJzZXIuZ2ZtRm9vdG5vdGVzID0gW10pXG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG5cbiAgbGV0IGxhYmVsU3RhcnQgLy8gRmluZCBhbiBvcGVuaW5nLlxuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgY29uc3QgdG9rZW4gPSBzZWxmLmV2ZW50c1tpbmRleF1bMV1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGFiZWxJbWFnZScpIHtcbiAgICAgIGxhYmVsU3RhcnQgPSB0b2tlblxuICAgICAgYnJlYWtcbiAgICB9IC8vIEV4aXQgaWYgd2VcdTIwMTl2ZSB3YWxrZWQgZmFyIGVub3VnaC5cblxuICAgIGlmIChcbiAgICAgIHRva2VuLnR5cGUgPT09ICdnZm1Gb290bm90ZUNhbGwnIHx8XG4gICAgICB0b2tlbi50eXBlID09PSAnbGFiZWxMaW5rJyB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2xhYmVsJyB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2ltYWdlJyB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2xpbmsnXG4gICAgKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBpZiAoIWxhYmVsU3RhcnQgfHwgIWxhYmVsU3RhcnQuX2JhbGFuY2VkKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgc2VsZi5zbGljZVNlcmlhbGl6ZSh7XG4gICAgICAgIHN0YXJ0OiBsYWJlbFN0YXJ0LmVuZCxcbiAgICAgICAgZW5kOiBzZWxmLm5vdygpXG4gICAgICB9KVxuICAgIClcblxuICAgIGlmIChpZC5jaGFyQ29kZUF0KDApICE9PSA5NCB8fCAhZGVmaW5lZC5pbmNsdWRlcyhpZC5zbGljZSgxKSkpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZUNhbGxMYWJlbE1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZUNhbGxMYWJlbE1hcmtlcicpXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7UmVzb2x2ZXJ9ICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUb1BvdGVudGlhbEdmbUZvb3Rub3RlQ2FsbChldmVudHMsIGNvbnRleHQpIHtcbiAgbGV0IGluZGV4ID0gZXZlbnRzLmxlbmd0aFxuICAvKiogQHR5cGUge1Rva2VufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgbGFiZWxTdGFydCAvLyBGaW5kIGFuIG9wZW5pbmcuXG5cbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICBpZiAoXG4gICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdsYWJlbEltYWdlJyAmJlxuICAgICAgZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJ1xuICAgICkge1xuICAgICAgbGFiZWxTdGFydCA9IGV2ZW50c1tpbmRleF1bMV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hhbmdlIHRoZSBgbGFiZWxJbWFnZU1hcmtlcmAgdG8gYSBgZGF0YWAuXG4gIGV2ZW50c1tpbmRleCArIDFdWzFdLnR5cGUgPSAnZGF0YSdcbiAgZXZlbnRzW2luZGV4ICsgM11bMV0udHlwZSA9ICdnZm1Gb290bm90ZUNhbGxMYWJlbE1hcmtlcicgLy8gVGhlIHdob2xlICh3aXRob3V0IGAhYCk6XG5cbiAgY29uc3QgY2FsbCA9IHtcbiAgICB0eXBlOiAnZ2ZtRm9vdG5vdGVDYWxsJyxcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2luZGV4ICsgM11bMV0uc3RhcnQpLFxuICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXVsxXS5lbmQpXG4gIH0gLy8gVGhlIGBeYCBtYXJrZXJcblxuICBjb25zdCBtYXJrZXIgPSB7XG4gICAgdHlwZTogJ2dmbUZvb3Rub3RlQ2FsbE1hcmtlcicsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tpbmRleCArIDNdWzFdLmVuZCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbaW5kZXggKyAzXVsxXS5lbmQpXG4gIH0gLy8gSW5jcmVtZW50IHRoZSBlbmQgMSBjaGFyYWN0ZXIuXG5cbiAgbWFya2VyLmVuZC5jb2x1bW4rK1xuICBtYXJrZXIuZW5kLm9mZnNldCsrXG4gIG1hcmtlci5lbmQuX2J1ZmZlckluZGV4KytcbiAgY29uc3Qgc3RyaW5nID0ge1xuICAgIHR5cGU6ICdnZm1Gb290bm90ZUNhbGxTdHJpbmcnLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBtYXJrZXIuZW5kKSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV1bMV0uc3RhcnQpXG4gIH1cbiAgY29uc3QgY2h1bmsgPSB7XG4gICAgdHlwZTogJ2NodW5rU3RyaW5nJyxcbiAgICBjb250ZW50VHlwZTogJ3N0cmluZycsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIHN0cmluZy5zdGFydCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBzdHJpbmcuZW5kKVxuICB9XG4gIC8qKiBAdHlwZSB7QXJyYXk8RXZlbnQ+fSAqL1xuXG4gIGNvbnN0IHJlcGxhY2VtZW50ID0gW1xuICAgIC8vIFRha2UgdGhlIGBsYWJlbEltYWdlTWFya2VyYCAobm93IGBkYXRhYCwgdGhlIGAhYClcbiAgICBldmVudHNbaW5kZXggKyAxXSxcbiAgICBldmVudHNbaW5kZXggKyAyXSxcbiAgICBbJ2VudGVyJywgY2FsbCwgY29udGV4dF0sIC8vIFRoZSBgW2BcbiAgICBldmVudHNbaW5kZXggKyAzXSxcbiAgICBldmVudHNbaW5kZXggKyA0XSwgLy8gVGhlIGBeYC5cbiAgICBbJ2VudGVyJywgbWFya2VyLCBjb250ZXh0XSxcbiAgICBbJ2V4aXQnLCBtYXJrZXIsIGNvbnRleHRdLCAvLyBFdmVyeXRoaW5nIGluIGJldHdlZW4uXG4gICAgWydlbnRlcicsIHN0cmluZywgY29udGV4dF0sXG4gICAgWydlbnRlcicsIGNodW5rLCBjb250ZXh0XSxcbiAgICBbJ2V4aXQnLCBjaHVuaywgY29udGV4dF0sXG4gICAgWydleGl0Jywgc3RyaW5nLCBjb250ZXh0XSwgLy8gVGhlIGVuZGluZyAoYF1gLCBwcm9wZXJseSBwYXJzZWQgYW5kIGxhYmVsbGVkKS5cbiAgICBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDJdLFxuICAgIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV0sXG4gICAgWydleGl0JywgY2FsbCwgY29udGV4dF1cbiAgXVxuICBldmVudHMuc3BsaWNlKGluZGV4LCBldmVudHMubGVuZ3RoIC0gaW5kZXggKyAxLCAuLi5yZXBsYWNlbWVudClcbiAgcmV0dXJuIGV2ZW50c1xufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplR2ZtRm9vdG5vdGVDYWxsKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIEl0XHUyMDE5cyBmaW5lIVxuXG4gIGNvbnN0IGRlZmluZWQgPSBzZWxmLnBhcnNlci5nZm1Gb290bm90ZXMgfHwgKHNlbGYucGFyc2VyLmdmbUZvb3Rub3RlcyA9IFtdKVxuICBsZXQgc2l6ZSA9IDBcbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuXG4gIGxldCBkYXRhXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZUNhbGwnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbExhYmVsTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlQ2FsbExhYmVsTWFya2VyJylcbiAgICByZXR1cm4gY2FsbFN0YXJ0XG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjYWxsU3RhcnQoY29kZSkge1xuICAgIGlmIChjb2RlICE9PSA5NCkgcmV0dXJuIG5vayhjb2RlKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbE1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZUNhbGxNYXJrZXInKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbFN0cmluZycpXG4gICAgZWZmZWN0cy5lbnRlcignY2h1bmtTdHJpbmcnKS5jb250ZW50VHlwZSA9ICdzdHJpbmcnXG4gICAgcmV0dXJuIGNhbGxEYXRhXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjYWxsRGF0YShjb2RlKSB7XG4gICAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgICBsZXQgdG9rZW5cblxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IDkxIHx8IHNpemUrKyA+IDk5OSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA5Mykge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cblxuICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1N0cmluZycpXG4gICAgICB0b2tlbiA9IGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVDYWxsU3RyaW5nJylcbiAgICAgIHJldHVybiBkZWZpbmVkLmluY2x1ZGVzKG5vcm1hbGl6ZUlkZW50aWZpZXIoc2VsZi5zbGljZVNlcmlhbGl6ZSh0b2tlbikpKVxuICAgICAgICA/IGVuZChjb2RlKVxuICAgICAgICA6IG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuXG4gICAgaWYgKCFtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICBkYXRhID0gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBjb2RlID09PSA5MiA/IGNhbGxFc2NhcGUgOiBjYWxsRGF0YVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY2FsbEVzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDkxIHx8IGNvZGUgPT09IDkyIHx8IGNvZGUgPT09IDkzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHNpemUrK1xuICAgICAgcmV0dXJuIGNhbGxEYXRhXG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxEYXRhKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBlbmQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbExhYmVsTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlQ2FsbExhYmVsTWFya2VyJylcbiAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlQ2FsbCcpXG4gICAgcmV0dXJuIG9rXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZURlZmluaXRpb25TdGFydChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBJdFx1MjAxOXMgZmluZSFcblxuICBjb25zdCBkZWZpbmVkID0gc2VsZi5wYXJzZXIuZ2ZtRm9vdG5vdGVzIHx8IChzZWxmLnBhcnNlci5nZm1Gb290bm90ZXMgPSBbXSlcbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cbiAgbGV0IGlkZW50aWZpZXJcbiAgbGV0IHNpemUgPSAwXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGRhdGFcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbicpLl9jb250YWluZXIgPSB0cnVlXG4gICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWwnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsTWFya2VyJylcbiAgICByZXR1cm4gbGFiZWxTdGFydFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gbGFiZWxTdGFydChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDk0KSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZURlZmluaXRpb25NYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbk1hcmtlcicpXG4gICAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbFN0cmluZycpXG4gICAgICByZXR1cm4gYXRCcmVha1xuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGF0QnJlYWsoY29kZSkge1xuICAgIC8qKiBAdHlwZSB7VG9rZW59ICovXG4gICAgbGV0IHRva2VuXG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSA5MSB8fCBzaXplID4gOTk5KSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDkzKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgfVxuXG4gICAgICB0b2tlbiA9IGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxTdHJpbmcnKVxuICAgICAgaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoc2VsZi5zbGljZVNlcmlhbGl6ZSh0b2tlbikpXG4gICAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbE1hcmtlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxNYXJrZXInKVxuICAgICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbCcpXG4gICAgICByZXR1cm4gbGFiZWxBZnRlclxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgICAgc2l6ZSsrXG4gICAgICByZXR1cm4gYXRCcmVha1xuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2NodW5rU3RyaW5nJykuY29udGVudFR5cGUgPSAnc3RyaW5nJ1xuICAgIHJldHVybiBsYWJlbChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gbGFiZWwoY29kZSkge1xuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IG51bGwgfHxcbiAgICAgIG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSB8fFxuICAgICAgY29kZSA9PT0gOTEgfHxcbiAgICAgIGNvZGUgPT09IDkzIHx8XG4gICAgICBzaXplID4gOTk5XG4gICAgKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2NodW5rU3RyaW5nJylcbiAgICAgIHJldHVybiBhdEJyZWFrKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKCFtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICBkYXRhID0gdHJ1ZVxuICAgIH1cblxuICAgIHNpemUrK1xuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBjb2RlID09PSA5MiA/IGxhYmVsRXNjYXBlIDogbGFiZWxcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGxhYmVsRXNjYXBlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gOTEgfHwgY29kZSA9PT0gOTIgfHwgY29kZSA9PT0gOTMpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgc2l6ZSsrXG4gICAgICByZXR1cm4gbGFiZWxcbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWwoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGxhYmVsQWZ0ZXIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA1OCkge1xuICAgICAgZWZmZWN0cy5lbnRlcignZGVmaW5pdGlvbk1hcmtlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnZGVmaW5pdGlvbk1hcmtlcicpIC8vIEFueSB3aGl0ZXNwYWNlIGFmdGVyIHRoZSBtYXJrZXIgaXMgZWF0ZW4sIGZvcm1pbmcgaW5kZW50ZWQgY29kZVxuICAgICAgLy8gaXMgbm90IHBvc3NpYmxlLlxuICAgICAgLy8gTm8gc3BhY2UgaXMgYWxzbyBmaW5lLCBqdXN0IGxpa2UgYSBibG9jayBxdW90ZSBtYXJrZXIuXG5cbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgZG9uZSwgJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbldoaXRlc3BhY2UnKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRvbmUoY29kZSkge1xuICAgIGlmICghZGVmaW5lZC5pbmNsdWRlcyhpZGVudGlmaWVyKSkge1xuICAgICAgZGVmaW5lZC5wdXNoKGlkZW50aWZpZXIpXG4gICAgfVxuXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZURlZmluaXRpb25Db250aW51YXRpb24oZWZmZWN0cywgb2ssIG5vaykge1xuICAvLyBFaXRoZXIgYSBibGFuayBsaW5lLCB3aGljaCBpcyBva2F5LCBvciBhbiBpbmRlbnRlZCB0aGluZy5cbiAgcmV0dXJuIGVmZmVjdHMuY2hlY2soYmxhbmtMaW5lLCBvaywgZWZmZWN0cy5hdHRlbXB0KGluZGVudCwgb2ssIG5vaykpXG59XG4vKiogQHR5cGUge0V4aXRlcn0gKi9cblxuZnVuY3Rpb24gZ2ZtRm9vdG5vdGVEZWZpbml0aW9uRW5kKGVmZmVjdHMpIHtcbiAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZURlZmluaXRpb24nKVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplSW5kZW50KGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIGZhY3RvcnlTcGFjZShcbiAgICBlZmZlY3RzLFxuICAgIGFmdGVyUHJlZml4LFxuICAgICdnZm1Gb290bm90ZURlZmluaXRpb25JbmRlbnQnLFxuICAgIDQgKyAxXG4gIClcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlclByZWZpeChjb2RlKSB7XG4gICAgY29uc3QgdGFpbCA9IHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIHRhaWwgJiZcbiAgICAgIHRhaWxbMV0udHlwZSA9PT0gJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkluZGVudCcgJiZcbiAgICAgIHRhaWxbMl0uc2xpY2VTZXJpYWxpemUodGFpbFsxXSwgdHJ1ZSkubGVuZ3RoID09PSA0XG4gICAgICA/IG9rKGNvZGUpXG4gICAgICA6IG5vayhjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkZvb3Rub3RlUmVmZXJlbmNlfSBGb290bm90ZVJlZmVyZW5jZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Gb290bm90ZURlZmluaXRpb259IEZvb3Rub3RlRGVmaW5pdGlvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuRXh0ZW5zaW9ufSBGcm9tTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkhhbmRsZX0gRnJvbU1hcmtkb3duSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuT3B0aW9uc30gVG9NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkhhbmRsZX0gVG9NYXJrZG93bkhhbmRsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLk1hcH0gTWFwXG4gKi9cblxuaW1wb3J0IHtub3JtYWxpemVJZGVudGlmaWVyfSBmcm9tICdtaWNyb21hcmstdXRpbC1ub3JtYWxpemUtaWRlbnRpZmllcidcbmltcG9ydCB7YXNzb2NpYXRpb259IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvYXNzb2NpYXRpb24uanMnXG5pbXBvcnQge2NvbnRhaW5lckZsb3d9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvY29udGFpbmVyLWZsb3cuanMnXG5pbXBvcnQge2luZGVudExpbmVzfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2luZGVudC1saW5lcy5qcydcbmltcG9ydCB7c2FmZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9zYWZlLmpzJ1xuaW1wb3J0IHt0cmFja30gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC90cmFjay5qcydcblxuLyoqXG4gKiBAcmV0dXJucyB7RnJvbU1hcmtkb3duRXh0ZW5zaW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtRm9vdG5vdGVGcm9tTWFya2Rvd24oKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXI6IHtcbiAgICAgIGdmbUZvb3Rub3RlRGVmaW5pdGlvbjogZW50ZXJGb290bm90ZURlZmluaXRpb24sXG4gICAgICBnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbFN0cmluZzogZW50ZXJGb290bm90ZURlZmluaXRpb25MYWJlbFN0cmluZyxcbiAgICAgIGdmbUZvb3Rub3RlQ2FsbDogZW50ZXJGb290bm90ZUNhbGwsXG4gICAgICBnZm1Gb290bm90ZUNhbGxTdHJpbmc6IGVudGVyRm9vdG5vdGVDYWxsU3RyaW5nXG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBnZm1Gb290bm90ZURlZmluaXRpb246IGV4aXRGb290bm90ZURlZmluaXRpb24sXG4gICAgICBnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbFN0cmluZzogZXhpdEZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsU3RyaW5nLFxuICAgICAgZ2ZtRm9vdG5vdGVDYWxsOiBleGl0Rm9vdG5vdGVDYWxsLFxuICAgICAgZ2ZtRm9vdG5vdGVDYWxsU3RyaW5nOiBleGl0Rm9vdG5vdGVDYWxsU3RyaW5nXG4gICAgfVxuICB9XG5cbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGVudGVyRm9vdG5vdGVEZWZpbml0aW9uKHRva2VuKSB7XG4gICAgdGhpcy5lbnRlcihcbiAgICAgIHt0eXBlOiAnZm9vdG5vdGVEZWZpbml0aW9uJywgaWRlbnRpZmllcjogJycsIGxhYmVsOiAnJywgY2hpbGRyZW46IFtdfSxcbiAgICAgIHRva2VuXG4gICAgKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGVudGVyRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxTdHJpbmcoKSB7XG4gICAgdGhpcy5idWZmZXIoKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGV4aXRGb290bm90ZURlZmluaXRpb25MYWJlbFN0cmluZyh0b2tlbikge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSAvKiogQHR5cGUge0Zvb3Rub3RlRGVmaW5pdGlvbn0gKi8gKFxuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgKVxuICAgIG5vZGUubGFiZWwgPSBsYWJlbFxuICAgIG5vZGUuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoXG4gICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgICkudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGV4aXRGb290bm90ZURlZmluaXRpb24odG9rZW4pIHtcbiAgICB0aGlzLmV4aXQodG9rZW4pXG4gIH1cblxuICAvKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbiAgZnVuY3Rpb24gZW50ZXJGb290bm90ZUNhbGwodG9rZW4pIHtcbiAgICB0aGlzLmVudGVyKHt0eXBlOiAnZm9vdG5vdGVSZWZlcmVuY2UnLCBpZGVudGlmaWVyOiAnJywgbGFiZWw6ICcnfSwgdG9rZW4pXG4gIH1cblxuICAvKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbiAgZnVuY3Rpb24gZW50ZXJGb290bm90ZUNhbGxTdHJpbmcoKSB7XG4gICAgdGhpcy5idWZmZXIoKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGV4aXRGb290bm90ZUNhbGxTdHJpbmcodG9rZW4pIHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtGb290bm90ZURlZmluaXRpb259ICovIChcbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIClcbiAgICBub2RlLmxhYmVsID0gbGFiZWxcbiAgICBub2RlLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICApLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBleGl0Rm9vdG5vdGVDYWxsKHRva2VuKSB7XG4gICAgdGhpcy5leGl0KHRva2VuKVxuICB9XG59XG5cbi8qKlxuICogQHJldHVybnMge1RvTWFya2Rvd25FeHRlbnNpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1Gb290bm90ZVRvTWFya2Rvd24oKSB7XG4gIGZvb3Rub3RlUmVmZXJlbmNlLnBlZWsgPSBmb290bm90ZVJlZmVyZW5jZVBlZWtcblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgaXMgb24gYnkgZGVmYXVsdCBhbHJlYWR5LlxuICAgIHVuc2FmZTogW3tjaGFyYWN0ZXI6ICdbJywgaW5Db25zdHJ1Y3Q6IFsncGhyYXNpbmcnLCAnbGFiZWwnLCAncmVmZXJlbmNlJ119XSxcbiAgICBoYW5kbGVyczoge2Zvb3Rub3RlRGVmaW5pdGlvbiwgZm9vdG5vdGVSZWZlcmVuY2V9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gICAqIEBwYXJhbSB7Rm9vdG5vdGVSZWZlcmVuY2V9IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIGZvb3Rub3RlUmVmZXJlbmNlKG5vZGUsIF8sIGNvbnRleHQsIHNhZmVPcHRpb25zKSB7XG4gICAgY29uc3QgdHJhY2tlciA9IHRyYWNrKHNhZmVPcHRpb25zKVxuICAgIGxldCB2YWx1ZSA9IHRyYWNrZXIubW92ZSgnW14nKVxuICAgIGNvbnN0IGV4aXQgPSBjb250ZXh0LmVudGVyKCdmb290bm90ZVJlZmVyZW5jZScpXG4gICAgY29uc3Qgc3ViZXhpdCA9IGNvbnRleHQuZW50ZXIoJ3JlZmVyZW5jZScpXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgc2FmZShjb250ZXh0LCBhc3NvY2lhdGlvbihub2RlKSwge1xuICAgICAgICAuLi50cmFja2VyLmN1cnJlbnQoKSxcbiAgICAgICAgYmVmb3JlOiB2YWx1ZSxcbiAgICAgICAgYWZ0ZXI6ICddJ1xuICAgICAgfSlcbiAgICApXG4gICAgc3ViZXhpdCgpXG4gICAgZXhpdCgpXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCddJylcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX0gKi9cbiAgZnVuY3Rpb24gZm9vdG5vdGVSZWZlcmVuY2VQZWVrKCkge1xuICAgIHJldHVybiAnWydcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtGb290bm90ZURlZmluaXRpb259IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIGZvb3Rub3RlRGVmaW5pdGlvbihub2RlLCBfLCBjb250ZXh0LCBzYWZlT3B0aW9ucykge1xuICAgIGNvbnN0IHRyYWNrZXIgPSB0cmFjayhzYWZlT3B0aW9ucylcbiAgICBsZXQgdmFsdWUgPSB0cmFja2VyLm1vdmUoJ1teJylcbiAgICBjb25zdCBleGl0ID0gY29udGV4dC5lbnRlcignZm9vdG5vdGVEZWZpbml0aW9uJylcbiAgICBjb25zdCBzdWJleGl0ID0gY29udGV4dC5lbnRlcignbGFiZWwnKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgIHNhZmUoY29udGV4dCwgYXNzb2NpYXRpb24obm9kZSksIHtcbiAgICAgICAgLi4udHJhY2tlci5jdXJyZW50KCksXG4gICAgICAgIGJlZm9yZTogdmFsdWUsXG4gICAgICAgIGFmdGVyOiAnXSdcbiAgICAgIH0pXG4gICAgKVxuICAgIHN1YmV4aXQoKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgICddOicgKyAobm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDAgPyAnICcgOiAnJylcbiAgICApXG4gICAgdHJhY2tlci5zaGlmdCg0KVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgIGluZGVudExpbmVzKGNvbnRhaW5lckZsb3cobm9kZSwgY29udGV4dCwgdHJhY2tlci5jdXJyZW50KCkpLCBtYXApXG4gICAgKVxuICAgIGV4aXQoKVxuXG4gICAgcmV0dXJuIHZhbHVlXG5cbiAgICAvKiogQHR5cGUge01hcH0gKi9cbiAgICBmdW5jdGlvbiBtYXAobGluZSwgaW5kZXgsIGJsYW5rKSB7XG4gICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIChibGFuayA/ICcnIDogJyAgICAnKSArIGxpbmVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpbmVcbiAgICB9XG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXh0ZW5zaW9ufSBFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0UmVjb3JkfSBDb25zdHJ1Y3RSZWNvcmRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUHJldmlvdXN9IFByZXZpb3VzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FdmVudH0gRXZlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICovXG5pbXBvcnQge1xuICBhc2NpaUFscGhhLFxuICBhc2NpaUFscGhhbnVtZXJpYyxcbiAgYXNjaWlDb250cm9sLFxuICBhc2NpaURpZ2l0LFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICBtYXJrZG93bkxpbmVFbmRpbmcsXG4gIHVuaWNvZGVQdW5jdHVhdGlvbixcbiAgdW5pY29kZVdoaXRlc3BhY2Vcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuY29uc3Qgd3d3ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVXd3csXG4gIHBhcnRpYWw6IHRydWVcbn1cbmNvbnN0IGRvbWFpbiA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplRG9tYWluLFxuICBwYXJ0aWFsOiB0cnVlXG59XG5jb25zdCBwYXRoID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVQYXRoLFxuICBwYXJ0aWFsOiB0cnVlXG59XG5jb25zdCBwdW5jdHVhdGlvbiA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplUHVuY3R1YXRpb24sXG4gIHBhcnRpYWw6IHRydWVcbn1cbmNvbnN0IG5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVOYW1lZENoYXJhY3RlclJlZmVyZW5jZSxcbiAgcGFydGlhbDogdHJ1ZVxufVxuY29uc3Qgd3d3QXV0b2xpbmsgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZVd3d0F1dG9saW5rLFxuICBwcmV2aW91czogcHJldmlvdXNXd3dcbn1cbmNvbnN0IGh0dHBBdXRvbGluayA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplSHR0cEF1dG9saW5rLFxuICBwcmV2aW91czogcHJldmlvdXNIdHRwXG59XG5jb25zdCBlbWFpbEF1dG9saW5rID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVFbWFpbEF1dG9saW5rLFxuICBwcmV2aW91czogcHJldmlvdXNFbWFpbFxufVxuLyoqIEB0eXBlIHtDb25zdHJ1Y3RSZWNvcmR9ICovXG5cbmNvbnN0IHRleHQgPSB7fVxuLyoqIEB0eXBlIHtFeHRlbnNpb259ICovXG5cbmV4cG9ydCBjb25zdCBnZm1BdXRvbGlua0xpdGVyYWwgPSB7XG4gIHRleHRcbn1cbmxldCBjb2RlID0gNDggLy8gQWRkIGFscGhhbnVtZXJpY3MuXG5cbndoaWxlIChjb2RlIDwgMTIzKSB7XG4gIHRleHRbY29kZV0gPSBlbWFpbEF1dG9saW5rXG4gIGNvZGUrK1xuICBpZiAoY29kZSA9PT0gNTgpIGNvZGUgPSA2NVxuICBlbHNlIGlmIChjb2RlID09PSA5MSkgY29kZSA9IDk3XG59XG5cbnRleHRbNDNdID0gZW1haWxBdXRvbGlua1xudGV4dFs0NV0gPSBlbWFpbEF1dG9saW5rXG50ZXh0WzQ2XSA9IGVtYWlsQXV0b2xpbmtcbnRleHRbOTVdID0gZW1haWxBdXRvbGlua1xudGV4dFs3Ml0gPSBbZW1haWxBdXRvbGluaywgaHR0cEF1dG9saW5rXVxudGV4dFsxMDRdID0gW2VtYWlsQXV0b2xpbmssIGh0dHBBdXRvbGlua11cbnRleHRbODddID0gW2VtYWlsQXV0b2xpbmssIHd3d0F1dG9saW5rXVxudGV4dFsxMTldID0gW2VtYWlsQXV0b2xpbmssIHd3d0F1dG9saW5rXVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplRW1haWxBdXRvbGluayhlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblxuICBsZXQgaGFzRG90XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGhhc0RpZ2l0SW5MYXN0U2VnbWVudFxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgIWdmbUF0ZXh0KGNvZGUpIHx8XG4gICAgICAhcHJldmlvdXNFbWFpbChzZWxmLnByZXZpb3VzKSB8fFxuICAgICAgcHJldmlvdXNVbmJhbGFuY2VkKHNlbGYuZXZlbnRzKVxuICAgICkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpdGVyYWxBdXRvbGluaycpXG4gICAgZWZmZWN0cy5lbnRlcignbGl0ZXJhbEF1dG9saW5rRW1haWwnKVxuICAgIHJldHVybiBhdGV4dChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYXRleHQoY29kZSkge1xuICAgIGlmIChnZm1BdGV4dChjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gYXRleHRcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNjQpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGxhYmVsXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gbGFiZWwoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0Nikge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2socHVuY3R1YXRpb24sIGRvbmUsIGRvdENvbnRpbnVhdGlvbikoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNDUgfHwgY29kZSA9PT0gOTUpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKHB1bmN0dWF0aW9uLCBub2ssIGRhc2hPclVuZGVyc2NvcmVDb250aW51YXRpb24pKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGFzY2lpQWxwaGFudW1lcmljKGNvZGUpKSB7XG4gICAgICBpZiAoIWhhc0RpZ2l0SW5MYXN0U2VnbWVudCAmJiBhc2NpaURpZ2l0KGNvZGUpKSB7XG4gICAgICAgIGhhc0RpZ2l0SW5MYXN0U2VnbWVudCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gbGFiZWxcbiAgICB9XG5cbiAgICByZXR1cm4gZG9uZShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZG90Q29udGludWF0aW9uKGNvZGUpIHtcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBoYXNEb3QgPSB0cnVlXG4gICAgaGFzRGlnaXRJbkxhc3RTZWdtZW50ID0gdW5kZWZpbmVkXG4gICAgcmV0dXJuIGxhYmVsXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkYXNoT3JVbmRlcnNjb3JlQ29udGludWF0aW9uKGNvZGUpIHtcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gYWZ0ZXJEYXNoT3JVbmRlcnNjb3JlXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlckRhc2hPclVuZGVyc2NvcmUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0Nikge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2socHVuY3R1YXRpb24sIG5vaywgZG90Q29udGludWF0aW9uKShjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZG9uZShjb2RlKSB7XG4gICAgaWYgKGhhc0RvdCAmJiAhaGFzRGlnaXRJbkxhc3RTZWdtZW50KSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpdGVyYWxBdXRvbGlua0VtYWlsJylcbiAgICAgIGVmZmVjdHMuZXhpdCgnbGl0ZXJhbEF1dG9saW5rJylcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplV3d3QXV0b2xpbmsoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgKGNvZGUgIT09IDg3ICYmIGNvZGUgIT09IDExOSkgfHxcbiAgICAgICFwcmV2aW91c1d3dyhzZWxmLnByZXZpb3VzKSB8fFxuICAgICAgcHJldmlvdXNVbmJhbGFuY2VkKHNlbGYuZXZlbnRzKVxuICAgICkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpdGVyYWxBdXRvbGluaycpXG4gICAgZWZmZWN0cy5lbnRlcignbGl0ZXJhbEF1dG9saW5rV3d3JykgLy8gRm9yIGB3d3cuYCB3ZSBjaGVjayBpbnN0ZWFkIG9mIGF0dGVtcHQsIGJlY2F1c2Ugd2hlbiBpdCBtYXRjaGVzLCBHSFxuICAgIC8vIHRyZWF0cyBpdCBhcyBwYXJ0IG9mIGEgZG9tYWluICh5ZXMsIGl0IHNheXMgYSB2YWxpZCBkb21haW4gbXVzdCBjb21lXG4gICAgLy8gYWZ0ZXIgYHd3dy5gLCBidXQgdGhhdFx1MjAxOXMgbm90IGhvdyBpdFx1MjAxOXMgaW1wbGVtZW50ZWQgYnkgdGhlbSkuXG5cbiAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgIHd3dyxcbiAgICAgIGVmZmVjdHMuYXR0ZW1wdChkb21haW4sIGVmZmVjdHMuYXR0ZW1wdChwYXRoLCBkb25lKSwgbm9rKSxcbiAgICAgIG5va1xuICAgICkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRvbmUoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnbGl0ZXJhbEF1dG9saW5rV3d3JylcbiAgICBlZmZlY3RzLmV4aXQoJ2xpdGVyYWxBdXRvbGluaycpXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUh0dHBBdXRvbGluayhlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICAoY29kZSAhPT0gNzIgJiYgY29kZSAhPT0gMTA0KSB8fFxuICAgICAgIXByZXZpb3VzSHR0cChzZWxmLnByZXZpb3VzKSB8fFxuICAgICAgcHJldmlvdXNVbmJhbGFuY2VkKHNlbGYuZXZlbnRzKVxuICAgICkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpdGVyYWxBdXRvbGluaycpXG4gICAgZWZmZWN0cy5lbnRlcignbGl0ZXJhbEF1dG9saW5rSHR0cCcpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIHQxXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB0MShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDg0IHx8IGNvZGUgPT09IDExNikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdDJcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB0Mihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDg0IHx8IGNvZGUgPT09IDExNikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gcFxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHAoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA4MCB8fCBjb2RlID09PSAxMTIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHNcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gODMgfHwgY29kZSA9PT0gMTE1KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb2xvblxuICAgIH1cblxuICAgIHJldHVybiBjb2xvbihjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29sb24oY29kZSkge1xuICAgIGlmIChjb2RlID09PSA1OCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gc2xhc2gxXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc2xhc2gxKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHNsYXNoMlxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHNsYXNoMihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBhZnRlclxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gbnVsbCB8fFxuICAgICAgYXNjaWlDb250cm9sKGNvZGUpIHx8XG4gICAgICB1bmljb2RlV2hpdGVzcGFjZShjb2RlKSB8fFxuICAgICAgdW5pY29kZVB1bmN0dWF0aW9uKGNvZGUpXG4gICAgICA/IG5vayhjb2RlKVxuICAgICAgOiBlZmZlY3RzLmF0dGVtcHQoZG9tYWluLCBlZmZlY3RzLmF0dGVtcHQocGF0aCwgZG9uZSksIG5vaykoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRvbmUoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnbGl0ZXJhbEF1dG9saW5rSHR0cCcpXG4gICAgZWZmZWN0cy5leGl0KCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVXd3coZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIHcyXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB3Mihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDg3IHx8IGNvZGUgPT09IDExOSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdzNcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB3Myhjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDg3IHx8IGNvZGUgPT09IDExOSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZG90XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZG90KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDYpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGFmdGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSA/IG5vayhjb2RlKSA6IG9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZURvbWFpbihlZmZlY3RzLCBvaywgbm9rKSB7XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG4gIGxldCBoYXNVbmRlcnNjb3JlSW5MYXN0U2VnbWVudFxuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBoYXNVbmRlcnNjb3JlSW5MYXN0TGFzdFNlZ21lbnRcbiAgcmV0dXJuIGRvbWFpblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRvbWFpbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDM4KSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgICAgbmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UsXG4gICAgICAgIGRvbmUsXG4gICAgICAgIHB1bmN0dWF0aW9uQ29udGludWF0aW9uXG4gICAgICApKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDQ2IHx8IGNvZGUgPT09IDk1KSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhwdW5jdHVhdGlvbiwgZG9uZSwgcHVuY3R1YXRpb25Db250aW51YXRpb24pKGNvZGUpXG4gICAgfSAvLyBHSCBkb2N1bWVudHMgdGhhdCBvbmx5IGFscGhhbnVtZXJpY3MgKG90aGVyIHRoYW4gYC1gLCBgLmAsIGFuZCBgX2ApIGNhblxuICAgIC8vIG9jY3VyLCB3aGljaCBzb3VuZHMgbGlrZSBBU0NJSSBvbmx5LCBidXQgdGhleSBhbHNvIHN1cHBvcnQgYHd3dy5cdTlFREVcdTc3MEIuY29tYCxcbiAgICAvLyBzbyB0aGF0XHUyMDE5cyBVbmljb2RlLlxuICAgIC8vIEluc3RlYWQgb2Ygc29tZSBuZXcgcHJvZHVjdGlvbiBmb3IgVW5pY29kZSBhbHBoYW51bWVyaWNzLCBtYXJrZG93blxuICAgIC8vIGFscmVhZHkgaGFzIHRoYXQgZm9yIFVuaWNvZGUgcHVuY3R1YXRpb24gYW5kIHdoaXRlc3BhY2UsIHNvIHVzZSB0aG9zZS5cblxuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IG51bGwgfHxcbiAgICAgIGFzY2lpQ29udHJvbChjb2RlKSB8fFxuICAgICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSkgfHxcbiAgICAgIChjb2RlICE9PSA0NSAmJiB1bmljb2RlUHVuY3R1YXRpb24oY29kZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZG9uZShjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBkb21haW5cbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHB1bmN0dWF0aW9uQ29udGludWF0aW9uKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDYpIHtcbiAgICAgIGhhc1VuZGVyc2NvcmVJbkxhc3RMYXN0U2VnbWVudCA9IGhhc1VuZGVyc2NvcmVJbkxhc3RTZWdtZW50XG4gICAgICBoYXNVbmRlcnNjb3JlSW5MYXN0U2VnbWVudCA9IHVuZGVmaW5lZFxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZG9tYWluXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDk1KSBoYXNVbmRlcnNjb3JlSW5MYXN0U2VnbWVudCA9IHRydWVcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gZG9tYWluXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkb25lKGNvZGUpIHtcbiAgICBpZiAoIWhhc1VuZGVyc2NvcmVJbkxhc3RMYXN0U2VnbWVudCAmJiAhaGFzVW5kZXJzY29yZUluTGFzdFNlZ21lbnQpIHtcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplUGF0aChlZmZlY3RzLCBvaykge1xuICBsZXQgYmFsYW5jZSA9IDBcbiAgcmV0dXJuIGluUGF0aFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGluUGF0aChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDM4KSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgICAgbmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UsXG4gICAgICAgIG9rLFxuICAgICAgICBjb250aW51ZWRQdW5jdHVhdGlvblxuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA0MCkge1xuICAgICAgYmFsYW5jZSsrXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDQxKSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgICAgcHVuY3R1YXRpb24sXG4gICAgICAgIHBhcmVuQXRQYXRoRW5kLFxuICAgICAgICBjb250aW51ZWRQdW5jdHVhdGlvblxuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIGlmIChwYXRoRW5kKGNvZGUpKSB7XG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAodHJhaWxpbmdQdW5jdHVhdGlvbihjb2RlKSkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2socHVuY3R1YXRpb24sIG9rLCBjb250aW51ZWRQdW5jdHVhdGlvbikoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gaW5QYXRoXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250aW51ZWRQdW5jdHVhdGlvbihjb2RlKSB7XG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGluUGF0aFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gcGFyZW5BdFBhdGhFbmQoY29kZSkge1xuICAgIGJhbGFuY2UtLVxuICAgIHJldHVybiBiYWxhbmNlIDwgMCA/IG9rKGNvZGUpIDogY29udGludWVkUHVuY3R1YXRpb24oY29kZSlcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGluc2lkZVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5zaWRlKGNvZGUpIHtcbiAgICBpZiAoYXNjaWlBbHBoYShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5zaWRlXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDU5KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBhZnRlclxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICAvLyBJZiB0aGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSBpcyBmb2xsb3dlZCBieSB0aGUgZW5kIG9mIHRoZSBwYXRoLCBpdFx1MjAxOXNcbiAgICAvLyBub3QgY29udGludWVkIHB1bmN0dWF0aW9uLlxuICAgIHJldHVybiBwYXRoRW5kKGNvZGUpID8gb2soY29kZSkgOiBub2soY29kZSlcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplUHVuY3R1YXRpb24oZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGFmdGVyXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlcihjb2RlKSB7XG4gICAgLy8gQ2hlY2sgdGhlIG5leHQuXG4gICAgaWYgKHRyYWlsaW5nUHVuY3R1YXRpb24oY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGFmdGVyXG4gICAgfSAvLyBJZiB0aGUgcHVuY3R1YXRpb24gbWFya2VyIGlzIGZvbGxvd2VkIGJ5IHRoZSBlbmQgb2YgdGhlIHBhdGgsIGl0XHUyMDE5cyBub3RcbiAgICAvLyBjb250aW51ZWQgcHVuY3R1YXRpb24uXG5cbiAgICByZXR1cm4gcGF0aEVuZChjb2RlKSA/IG9rKGNvZGUpIDogbm9rKGNvZGUpXG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtDb2RlfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiB0cmFpbGluZ1B1bmN0dWF0aW9uKGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICBjb2RlID09PSAzMyB8fFxuICAgIGNvZGUgPT09IDM0IHx8XG4gICAgY29kZSA9PT0gMzkgfHxcbiAgICBjb2RlID09PSA0MSB8fFxuICAgIGNvZGUgPT09IDQyIHx8XG4gICAgY29kZSA9PT0gNDQgfHxcbiAgICBjb2RlID09PSA0NiB8fFxuICAgIGNvZGUgPT09IDU4IHx8XG4gICAgY29kZSA9PT0gNTkgfHxcbiAgICBjb2RlID09PSA2MCB8fFxuICAgIGNvZGUgPT09IDYzIHx8XG4gICAgY29kZSA9PT0gOTUgfHxcbiAgICBjb2RlID09PSAxMjZcbiAgKVxufVxuLyoqXG4gKiBAcGFyYW0ge0NvZGV9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIHBhdGhFbmQoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSA2MCB8fCBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG59XG4vKipcbiAqIEBwYXJhbSB7Q29kZX0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gZ2ZtQXRleHQoY29kZSkge1xuICByZXR1cm4gKFxuICAgIGNvZGUgPT09IDQzIHx8XG4gICAgY29kZSA9PT0gNDUgfHxcbiAgICBjb2RlID09PSA0NiB8fFxuICAgIGNvZGUgPT09IDk1IHx8XG4gICAgYXNjaWlBbHBoYW51bWVyaWMoY29kZSlcbiAgKVxufVxuLyoqIEB0eXBlIHtQcmV2aW91c30gKi9cblxuZnVuY3Rpb24gcHJldmlvdXNXd3coY29kZSkge1xuICByZXR1cm4gKFxuICAgIGNvZGUgPT09IG51bGwgfHxcbiAgICBjb2RlID09PSA0MCB8fFxuICAgIGNvZGUgPT09IDQyIHx8XG4gICAgY29kZSA9PT0gOTUgfHxcbiAgICBjb2RlID09PSAxMjYgfHxcbiAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gIClcbn1cbi8qKiBAdHlwZSB7UHJldmlvdXN9ICovXG5cbmZ1bmN0aW9uIHByZXZpb3VzSHR0cChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSBudWxsIHx8ICFhc2NpaUFscGhhKGNvZGUpXG59XG4vKiogQHR5cGUge1ByZXZpb3VzfSAqL1xuXG5mdW5jdGlvbiBwcmV2aW91c0VtYWlsKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgIT09IDQ3ICYmIHByZXZpb3VzSHR0cChjb2RlKVxufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBwcmV2aW91c1VuYmFsYW5jZWQoZXZlbnRzKSB7XG4gIGxldCBpbmRleCA9IGV2ZW50cy5sZW5ndGhcbiAgbGV0IHJlc3VsdCA9IGZhbHNlXG5cbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICBjb25zdCB0b2tlbiA9IGV2ZW50c1tpbmRleF1bMV1cblxuICAgIGlmIChcbiAgICAgICh0b2tlbi50eXBlID09PSAnbGFiZWxMaW5rJyB8fCB0b2tlbi50eXBlID09PSAnbGFiZWxJbWFnZScpICYmXG4gICAgICAhdG9rZW4uX2JhbGFuY2VkXG4gICAgKSB7XG4gICAgICByZXN1bHQgPSB0cnVlXG4gICAgICBicmVha1xuICAgIH0gLy8gQHRzLWV4cGVjdC1lcnJvciBJZiB3ZVx1MjAxOXZlIHNlZW4gdGhpcyB0b2tlbiwgYW5kIGl0IHdhcyBtYXJrZWQgYXMgbm90XG4gICAgLy8gaGF2aW5nIGFueSB1bmJhbGFuY2VkIGJyYWNrZXQgYmVmb3JlIGl0LCB3ZSBjYW4gZXhpdC5cblxuICAgIGlmICh0b2tlbi5fZ2ZtQXV0b2xpbmtMaXRlcmFsV2Fsa2VkSW50bykge1xuICAgICAgcmVzdWx0ID0gZmFsc2VcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKGV2ZW50cy5sZW5ndGggPiAwICYmICFyZXN1bHQpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE1hcmsgdGhlIGxhc3QgdG9rZW4gYXMgXHUyMDFDd2Fsa2VkIGludG9cdTIwMUQgdy9vIGZpbmRpbmdcbiAgICAvLyBhbnl0aGluZy5cbiAgICBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdWzFdLl9nZm1BdXRvbGlua0xpdGVyYWxXYWxrZWRJbnRvID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwgIi8qKlxuICogQ291bnQgaG93IG9mdGVuIGEgY2hhcmFjdGVyIChvciBzdWJzdHJpbmcpIGlzIHVzZWQgaW4gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgIFZhbHVlIHRvIHNlYXJjaCBpbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJcbiAqICAgQ2hhcmFjdGVyIChvciBzdWJzdHJpbmcpIHRvIGxvb2sgZm9yLlxuICogQHJldHVybiB7bnVtYmVyfVxuICogICBOdW1iZXIgb2YgdGltZXMgYGNoYXJhY3RlcmAgb2NjdXJyZWQgaW4gYHZhbHVlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNjb3VudCh2YWx1ZSwgY2hhcmFjdGVyKSB7XG4gIGNvbnN0IHNvdXJjZSA9IFN0cmluZyh2YWx1ZSlcblxuICBpZiAodHlwZW9mIGNoYXJhY3RlciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBjaGFyYWN0ZXInKVxuICB9XG5cbiAgbGV0IGNvdW50ID0gMFxuICBsZXQgaW5kZXggPSBzb3VyY2UuaW5kZXhPZihjaGFyYWN0ZXIpXG5cbiAgd2hpbGUgKGluZGV4ICE9PSAtMSkge1xuICAgIGNvdW50KytcbiAgICBpbmRleCA9IHNvdXJjZS5pbmRleE9mKGNoYXJhY3RlciwgaW5kZXggKyBjaGFyYWN0ZXIubGVuZ3RoKVxuICB9XG5cbiAgcmV0dXJuIGNvdW50XG59XG4iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXNjYXBlU3RyaW5nUmVnZXhwKHN0cmluZykge1xuXHRpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuXHR9XG5cblx0Ly8gRXNjYXBlIGNoYXJhY3RlcnMgd2l0aCBzcGVjaWFsIG1lYW5pbmcgZWl0aGVyIGluc2lkZSBvciBvdXRzaWRlIGNoYXJhY3RlciBzZXRzLlxuXHQvLyBVc2UgYSBzaW1wbGUgYmFja3NsYXNoIGVzY2FwZSB3aGVuIGl0XHUyMDE5cyBhbHdheXMgdmFsaWQsIGFuZCBhIGBcXHhubmAgZXNjYXBlIHdoZW4gdGhlIHNpbXBsZXIgZm9ybSB3b3VsZCBiZSBkaXNhbGxvd2VkIGJ5IFVuaWNvZGUgcGF0dGVybnNcdTIwMTkgc3RyaWN0ZXIgZ3JhbW1hci5cblx0cmV0dXJuIHN0cmluZ1xuXHRcdC5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZywgJ1xcXFwkJicpXG5cdFx0LnJlcGxhY2UoLy0vZywgJ1xcXFx4MmQnKTtcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuTm9kZX0gTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5QYXJlbnR9IFBhcmVudFxuICpcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFR5cGVcbiAqIEB0eXBlZGVmIHtPYmplY3Q8c3RyaW5nLCB1bmtub3duPn0gUHJvcHNcbiAqXG4gKiBAdHlwZWRlZiB7bnVsbHx1bmRlZmluZWR8VHlwZXxQcm9wc3xUZXN0RnVuY3Rpb25Bbnl0aGluZ3xBcnJheS48VHlwZXxQcm9wc3xUZXN0RnVuY3Rpb25Bbnl0aGluZz59IFRlc3RcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBwYXNzZXMgYSB0ZXN0XG4gKlxuICogQGNhbGxiYWNrIFRlc3RGdW5jdGlvbkFueXRoaW5nXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfG51bGx8dW5kZWZpbmVkfSBbaW5kZXhdXG4gKiBAcGFyYW0ge1BhcmVudHxudWxsfHVuZGVmaW5lZH0gW3BhcmVudF1cbiAqIEByZXR1cm5zIHtib29sZWFufHZvaWR9XG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgcGFzc2VzIGEgY2VydGFpbiBub2RlIHRlc3RcbiAqXG4gKiBAdGVtcGxhdGUge05vZGV9IFhcbiAqIEBjYWxsYmFjayBUZXN0RnVuY3Rpb25QcmVkaWNhdGVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ8bnVsbHx1bmRlZmluZWR9IFtpbmRleF1cbiAqIEBwYXJhbSB7UGFyZW50fG51bGx8dW5kZWZpbmVkfSBbcGFyZW50XVxuICogQHJldHVybnMge25vZGUgaXMgWH1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBBc3NlcnRBbnl0aGluZ1xuICogQHBhcmFtIHt1bmtub3dufSBbbm9kZV1cbiAqIEBwYXJhbSB7bnVtYmVyfG51bGx8dW5kZWZpbmVkfSBbaW5kZXhdXG4gKiBAcGFyYW0ge1BhcmVudHxudWxsfHVuZGVmaW5lZH0gW3BhcmVudF1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIHBhc3NlcyBhIGNlcnRhaW4gbm9kZSB0ZXN0XG4gKlxuICogQHRlbXBsYXRlIHtOb2RlfSBZXG4gKiBAY2FsbGJhY2sgQXNzZXJ0UHJlZGljYXRlXG4gKiBAcGFyYW0ge3Vua25vd259IFtub2RlXVxuICogQHBhcmFtIHtudW1iZXJ8bnVsbHx1bmRlZmluZWR9IFtpbmRleF1cbiAqIEBwYXJhbSB7UGFyZW50fG51bGx8dW5kZWZpbmVkfSBbcGFyZW50XVxuICogQHJldHVybnMge25vZGUgaXMgWX1cbiAqL1xuXG5leHBvcnQgY29uc3QgaXMgPVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBub2RlIHBhc3NlcyBhIHRlc3QuXG4gICAqIFdoZW4gYSBgcGFyZW50YCBub2RlIGlzIGtub3duIHRoZSBgaW5kZXhgIG9mIG5vZGUgc2hvdWxkIGFsc28gYmUgZ2l2ZW4uXG4gICAqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKDxUIGV4dGVuZHMgTm9kZT4obm9kZTogdW5rbm93biwgdGVzdDogVFsndHlwZSddfFBhcnRpYWw8VD58VGVzdEZ1bmN0aW9uUHJlZGljYXRlPFQ+fEFycmF5LjxUWyd0eXBlJ118UGFydGlhbDxUPnxUZXN0RnVuY3Rpb25QcmVkaWNhdGU8VD4+LCBpbmRleD86IG51bWJlcnxudWxsfHVuZGVmaW5lZCwgcGFyZW50PzogUGFyZW50fG51bGx8dW5kZWZpbmVkLCBjb250ZXh0PzogdW5rbm93bikgPT4gbm9kZSBpcyBUKSAmXG4gICAqICAgKChub2RlPzogdW5rbm93biwgdGVzdD86IFRlc3QsIGluZGV4PzogbnVtYmVyfG51bGx8dW5kZWZpbmVkLCBwYXJlbnQ/OiBQYXJlbnR8bnVsbHx1bmRlZmluZWQsIGNvbnRleHQ/OiB1bmtub3duKSA9PiBib29sZWFuKVxuICAgKiApfVxuICAgKi9cbiAgKFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgbm9kZSBwYXNzZXMgYSB0ZXN0LlxuICAgICAqIFdoZW4gYSBgcGFyZW50YCBub2RlIGlzIGtub3duIHRoZSBgaW5kZXhgIG9mIG5vZGUgc2hvdWxkIGFsc28gYmUgZ2l2ZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Vua25vd259IFtub2RlXSBOb2RlIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtUZXN0fSBbdGVzdF1cbiAgICAgKiBXaGVuIG51bGxpc2gsIGNoZWNrcyBpZiBgbm9kZWAgaXMgYSBgTm9kZWAuXG4gICAgICogV2hlbiBgc3RyaW5nYCwgd29ya3MgbGlrZSBwYXNzaW5nIGBmdW5jdGlvbiAobm9kZSkge3JldHVybiBub2RlLnR5cGUgPT09IHRlc3R9YC5cbiAgICAgKiBXaGVuIGBmdW5jdGlvbmAgY2hlY2tzIGlmIGZ1bmN0aW9uIHBhc3NlZCB0aGUgbm9kZSBpcyB0cnVlLlxuICAgICAqIFdoZW4gYG9iamVjdGAsIGNoZWNrcyB0aGF0IGFsbCBrZXlzIGluIHRlc3QgYXJlIGluIG5vZGUsIGFuZCB0aGF0IHRoZXkgaGF2ZSAoc3RyaWN0bHkpIGVxdWFsIHZhbHVlcy5cbiAgICAgKiBXaGVuIGBhcnJheWAsIGNoZWNrcyBhbnkgb25lIG9mIHRoZSBzdWJ0ZXN0cyBwYXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bGx8dW5kZWZpbmVkfSBbaW5kZXhdIFBvc2l0aW9uIG9mIGBub2RlYCBpbiBgcGFyZW50YFxuICAgICAqIEBwYXJhbSB7UGFyZW50fG51bGx8dW5kZWZpbmVkfSBbcGFyZW50XSBQYXJlbnQgb2YgYG5vZGVgXG4gICAgICogQHBhcmFtIHt1bmtub3dufSBbY29udGV4dF0gQ29udGV4dCBvYmplY3QgdG8gaW52b2tlIGB0ZXN0YCB3aXRoXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGVzdCBwYXNzZWQgYW5kIGBub2RlYCBpcyBhIGBOb2RlYCAob2JqZWN0IHdpdGggYHR5cGVgIHNldCB0byBub24tZW1wdHkgYHN0cmluZ2ApLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG4gICAgZnVuY3Rpb24gaXMobm9kZSwgdGVzdCwgaW5kZXgsIHBhcmVudCwgY29udGV4dCkge1xuICAgICAgY29uc3QgY2hlY2sgPSBjb252ZXJ0KHRlc3QpXG5cbiAgICAgIGlmIChcbiAgICAgICAgaW5kZXggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBpbmRleCAhPT0gbnVsbCAmJlxuICAgICAgICAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgIGluZGV4IDwgMCB8fFxuICAgICAgICAgIGluZGV4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3NpdGl2ZSBmaW5pdGUgaW5kZXgnKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHBhcmVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHBhcmVudCAhPT0gbnVsbCAmJlxuICAgICAgICAoIWlzKHBhcmVudCkgfHwgIXBhcmVudC5jaGlsZHJlbilcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBhcmVudCBub2RlJylcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAocGFyZW50ID09PSB1bmRlZmluZWQgfHwgcGFyZW50ID09PSBudWxsKSAhPT1cbiAgICAgICAgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPT09IG51bGwpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBib3RoIHBhcmVudCBhbmQgaW5kZXgnKVxuICAgICAgfVxuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIExvb2tzIGxpa2UgYSBub2RlLlxuICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS50eXBlICYmIHR5cGVvZiBub2RlLnR5cGUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gQm9vbGVhbihjaGVjay5jYWxsKGNvbnRleHQsIG5vZGUsIGluZGV4LCBwYXJlbnQpKVxuICAgICAgICA6IGZhbHNlXG4gICAgfVxuICApXG5cbmV4cG9ydCBjb25zdCBjb252ZXJ0ID1cbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKDxUIGV4dGVuZHMgTm9kZT4odGVzdDogVFsndHlwZSddfFBhcnRpYWw8VD58VGVzdEZ1bmN0aW9uUHJlZGljYXRlPFQ+KSA9PiBBc3NlcnRQcmVkaWNhdGU8VD4pICZcbiAgICogICAoKHRlc3Q/OiBUZXN0KSA9PiBBc3NlcnRBbnl0aGluZylcbiAgICogKX1cbiAgICovXG4gIChcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBhc3NlcnRpb24gZnJvbSBhIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7VGVzdH0gW3Rlc3RdXG4gICAgICogV2hlbiBudWxsaXNoLCBjaGVja3MgaWYgYG5vZGVgIGlzIGEgYE5vZGVgLlxuICAgICAqIFdoZW4gYHN0cmluZ2AsIHdvcmtzIGxpa2UgcGFzc2luZyBgZnVuY3Rpb24gKG5vZGUpIHtyZXR1cm4gbm9kZS50eXBlID09PSB0ZXN0fWAuXG4gICAgICogV2hlbiBgZnVuY3Rpb25gIGNoZWNrcyBpZiBmdW5jdGlvbiBwYXNzZWQgdGhlIG5vZGUgaXMgdHJ1ZS5cbiAgICAgKiBXaGVuIGBvYmplY3RgLCBjaGVja3MgdGhhdCBhbGwga2V5cyBpbiB0ZXN0IGFyZSBpbiBub2RlLCBhbmQgdGhhdCB0aGV5IGhhdmUgKHN0cmljdGx5KSBlcXVhbCB2YWx1ZXMuXG4gICAgICogV2hlbiBgYXJyYXlgLCBjaGVja3MgYW55IG9uZSBvZiB0aGUgc3VidGVzdHMgcGFzcy5cbiAgICAgKiBAcmV0dXJucyB7QXNzZXJ0QW55dGhpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICAgIGlmICh0ZXN0ID09PSB1bmRlZmluZWQgfHwgdGVzdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb2tcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdHlwZUZhY3RvcnkodGVzdClcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0ZXN0KSA/IGFueUZhY3RvcnkodGVzdCkgOiBwcm9wc0ZhY3RvcnkodGVzdClcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjYXN0RmFjdG9yeSh0ZXN0KVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGZ1bmN0aW9uLCBzdHJpbmcsIG9yIG9iamVjdCBhcyB0ZXN0JylcbiAgICB9XG4gIClcbi8qKlxuICogQHBhcmFtIHtBcnJheS48VHlwZXxQcm9wc3xUZXN0RnVuY3Rpb25Bbnl0aGluZz59IHRlc3RzXG4gKiBAcmV0dXJucyB7QXNzZXJ0QW55dGhpbmd9XG4gKi9cbmZ1bmN0aW9uIGFueUZhY3RvcnkodGVzdHMpIHtcbiAgLyoqIEB0eXBlIHtBcnJheS48QXNzZXJ0QW55dGhpbmc+fSAqL1xuICBjb25zdCBjaGVja3MgPSBbXVxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgdGVzdHMubGVuZ3RoKSB7XG4gICAgY2hlY2tzW2luZGV4XSA9IGNvbnZlcnQodGVzdHNbaW5kZXhdKVxuICB9XG5cbiAgcmV0dXJuIGNhc3RGYWN0b3J5KGFueSlcblxuICAvKipcbiAgICogQHRoaXMge3Vua25vd259XG4gICAqIEBwYXJhbSB7dW5rbm93bltdfSBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gYW55KC4uLnBhcmFtZXRlcnMpIHtcbiAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBjaGVja3MubGVuZ3RoKSB7XG4gICAgICBpZiAoY2hlY2tzW2luZGV4XS5jYWxsKHRoaXMsIC4uLnBhcmFtZXRlcnMpKSByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogVXRpbGl0eSB0byBhc3NlcnQgZWFjaCBwcm9wZXJ0eSBpbiBgdGVzdGAgaXMgcmVwcmVzZW50ZWQgaW4gYG5vZGVgLCBhbmQgZWFjaFxuICogdmFsdWVzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge1Byb3BzfSBjaGVja1xuICogQHJldHVybnMge0Fzc2VydEFueXRoaW5nfVxuICovXG5mdW5jdGlvbiBwcm9wc0ZhY3RvcnkoY2hlY2spIHtcbiAgcmV0dXJuIGNhc3RGYWN0b3J5KGFsbClcblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gYWxsKG5vZGUpIHtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQga2V5XG5cbiAgICBmb3IgKGtleSBpbiBjaGVjaykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaHVzaCwgaXQgc3VyZSB3b3JrcyBhcyBhbiBpbmRleC5cbiAgICAgIGlmIChub2RlW2tleV0gIT09IGNoZWNrW2tleV0pIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuLyoqXG4gKiBVdGlsaXR5IHRvIGNvbnZlcnQgYSBzdHJpbmcgaW50byBhIGZ1bmN0aW9uIHdoaWNoIGNoZWNrcyBhIGdpdmVuIG5vZGVcdTIwMTlzIHR5cGVcbiAqIGZvciBzYWlkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1R5cGV9IGNoZWNrXG4gKiBAcmV0dXJucyB7QXNzZXJ0QW55dGhpbmd9XG4gKi9cbmZ1bmN0aW9uIHR5cGVGYWN0b3J5KGNoZWNrKSB7XG4gIHJldHVybiBjYXN0RmFjdG9yeSh0eXBlKVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIHR5cGUobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGUudHlwZSA9PT0gY2hlY2tcbiAgfVxufVxuXG4vKipcbiAqIFV0aWxpdHkgdG8gY29udmVydCBhIHN0cmluZyBpbnRvIGEgZnVuY3Rpb24gd2hpY2ggY2hlY2tzIGEgZ2l2ZW4gbm9kZVx1MjAxOXMgdHlwZVxuICogZm9yIHNhaWQgc3RyaW5nLlxuICogQHBhcmFtIHtUZXN0RnVuY3Rpb25Bbnl0aGluZ30gY2hlY2tcbiAqIEByZXR1cm5zIHtBc3NlcnRBbnl0aGluZ31cbiAqL1xuZnVuY3Rpb24gY2FzdEZhY3RvcnkoY2hlY2spIHtcbiAgcmV0dXJuIGFzc2VydGlvblxuXG4gIC8qKlxuICAgKiBAdGhpcyB7dW5rbm93bn1cbiAgICogQHBhcmFtIHtBcnJheS48dW5rbm93bj59IHBhcmFtZXRlcnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBhc3NlcnRpb24oLi4ucGFyYW1ldGVycykge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHNwcmVhZGluZyBpcyBmaW5lLlxuICAgIHJldHVybiBCb29sZWFuKGNoZWNrLmNhbGwodGhpcywgLi4ucGFyYW1ldGVycykpXG4gIH1cbn1cblxuLy8gVXRpbGl0eSB0byByZXR1cm4gdHJ1ZS5cbmZ1bmN0aW9uIG9rKCkge1xuICByZXR1cm4gdHJ1ZVxufVxuIiwgIi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2xvcihkKSB7XG4gIHJldHVybiBkXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLk5vZGV9IE5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUGFyZW50fSBQYXJlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0LXV0aWwtaXMnKS5UZXN0fSBUZXN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvbXBsZXgtdHlwZXMuanMnKS5BY3Rpb259IEFjdGlvblxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9jb21wbGV4LXR5cGVzLmpzJykuSW5kZXh9IEluZGV4XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvbXBsZXgtdHlwZXMuanMnKS5BY3Rpb25UdXBsZX0gQWN0aW9uVHVwbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29tcGxleC10eXBlcy5qcycpLlZpc2l0b3JSZXN1bHR9IFZpc2l0b3JSZXN1bHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29tcGxleC10eXBlcy5qcycpLlZpc2l0b3J9IFZpc2l0b3JcbiAqL1xuXG5pbXBvcnQge2NvbnZlcnR9IGZyb20gJ3VuaXN0LXV0aWwtaXMnXG5pbXBvcnQge2NvbG9yfSBmcm9tICcuL2NvbG9yLmpzJ1xuXG4vKipcbiAqIENvbnRpbnVlIHRyYXZlcnNpbmcgYXMgbm9ybWFsXG4gKi9cbmV4cG9ydCBjb25zdCBDT05USU5VRSA9IHRydWVcbi8qKlxuICogRG8gbm90IHRyYXZlcnNlIHRoaXMgbm9kZVx1MjAxOXMgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGNvbnN0IFNLSVAgPSAnc2tpcCdcbi8qKlxuICogU3RvcCB0cmF2ZXJzaW5nIGltbWVkaWF0ZWx5XG4gKi9cbmV4cG9ydCBjb25zdCBFWElUID0gZmFsc2VcblxuLyoqXG4gKiBWaXNpdCBjaGlsZHJlbiBvZiB0cmVlIHdoaWNoIHBhc3MgdGVzdC5cbiAqXG4gKiBAcGFyYW0gdHJlZVxuICogICBUcmVlIHRvIHdhbGtcbiAqIEBwYXJhbSBbdGVzdF1cbiAqICAgYHVuaXN0LXV0aWwtaXNgLWNvbXBhdGlibGUgdGVzdFxuICogQHBhcmFtIHZpc2l0b3JcbiAqICAgRnVuY3Rpb24gY2FsbGVkIGZvciBub2RlcyB0aGF0IHBhc3MgYHRlc3RgLlxuICogQHBhcmFtIFtyZXZlcnNlPWZhbHNlXVxuICogICBUcmF2ZXJzZSBpbiByZXZlcnNlIHByZW9yZGVyIChOUkwpIGluc3RlYWQgb2YgcHJlb3JkZXIgKE5MUikgKGRlZmF1bHQpLlxuICovXG5leHBvcnQgY29uc3QgdmlzaXRQYXJlbnRzID1cbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKDxUcmVlIGV4dGVuZHMgTm9kZSwgQ2hlY2sgZXh0ZW5kcyBUZXN0Pih0cmVlOiBUcmVlLCB0ZXN0OiBDaGVjaywgdmlzaXRvcjogaW1wb3J0KCcuL2NvbXBsZXgtdHlwZXMuanMnKS5CdWlsZFZpc2l0b3I8VHJlZSwgQ2hlY2s+LCByZXZlcnNlPzogYm9vbGVhbikgPT4gdm9pZCkgJlxuICAgKiAgICg8VHJlZSBleHRlbmRzIE5vZGU+KHRyZWU6IFRyZWUsIHZpc2l0b3I6IGltcG9ydCgnLi9jb21wbGV4LXR5cGVzLmpzJykuQnVpbGRWaXNpdG9yPFRyZWU+LCByZXZlcnNlPzogYm9vbGVhbikgPT4gdm9pZClcbiAgICogKX1cbiAgICovXG4gIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IHRyZWVcbiAgICAgKiBAcGFyYW0ge1Rlc3R9IHRlc3RcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9jb21wbGV4LXR5cGVzLmpzJykuVmlzaXRvcjxOb2RlPn0gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2U9ZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRyZWUsIHRlc3QsIHZpc2l0b3IsIHJldmVyc2UpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmlzaXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXZlcnNlID0gdmlzaXRvclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG5vIHZpc2l0b3IgZ2l2ZW4sIHNvIGB2aXNpdG9yYCBpcyB0ZXN0LlxuICAgICAgICB2aXNpdG9yID0gdGVzdFxuICAgICAgICB0ZXN0ID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCBpcyA9IGNvbnZlcnQodGVzdClcbiAgICAgIGNvbnN0IHN0ZXAgPSByZXZlcnNlID8gLTEgOiAxXG5cbiAgICAgIGZhY3RvcnkodHJlZSwgbnVsbCwgW10pKClcblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyP30gaW5kZXhcbiAgICAgICAqIEBwYXJhbSB7QXJyYXk8UGFyZW50Pn0gcGFyZW50c1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBmYWN0b3J5KG5vZGUsIGluZGV4LCBwYXJlbnRzKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59ICovXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGh1c2hcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZSAhPT0gbnVsbCA/IG5vZGUgOiB7fVxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAgIGxldCBuYW1lXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG5hbWUgPVxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRhZ05hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgID8gdmFsdWUudGFnTmFtZVxuICAgICAgICAgICAgICA6IHR5cGVvZiB2YWx1ZS5uYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICA/IHZhbHVlLm5hbWVcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2aXNpdCwgJ25hbWUnLCB7XG4gICAgICAgICAgICB2YWx1ZTpcbiAgICAgICAgICAgICAgJ25vZGUgKCcgK1xuICAgICAgICAgICAgICBjb2xvcih2YWx1ZS50eXBlICsgKG5hbWUgPyAnPCcgKyBuYW1lICsgJz4nIDogJycpKSArXG4gICAgICAgICAgICAgICcpJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmlzaXRcblxuICAgICAgICBmdW5jdGlvbiB2aXNpdCgpIHtcbiAgICAgICAgICAvKiogQHR5cGUge0FjdGlvblR1cGxlfSAqL1xuICAgICAgICAgIGxldCByZXN1bHQgPSBbXVxuICAgICAgICAgIC8qKiBAdHlwZSB7QWN0aW9uVHVwbGV9ICovXG4gICAgICAgICAgbGV0IHN1YnJlc3VsdFxuICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgIGxldCBvZmZzZXRcbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5PFBhcmVudD59ICovXG4gICAgICAgICAgbGV0IGdyYW5kcGFyZW50c1xuXG4gICAgICAgICAgaWYgKCF0ZXN0IHx8IGlzKG5vZGUsIGluZGV4LCBwYXJlbnRzW3BhcmVudHMubGVuZ3RoIC0gMV0gfHwgbnVsbCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRvUmVzdWx0KHZpc2l0b3Iobm9kZSwgcGFyZW50cykpXG5cbiAgICAgICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3MgbGlrZSBhIHBhcmVudC5cbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbiAmJiByZXN1bHRbMF0gIT09IFNLSVApIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3MgbGlrZSBhIHBhcmVudC5cbiAgICAgICAgICAgIG9mZnNldCA9IChyZXZlcnNlID8gbm9kZS5jaGlsZHJlbi5sZW5ndGggOiAtMSkgKyBzdGVwXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2tzIGxpa2UgYSBwYXJlbnQuXG4gICAgICAgICAgICBncmFuZHBhcmVudHMgPSBwYXJlbnRzLmNvbmNhdChub2RlKVxuXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2tzIGxpa2UgYSBwYXJlbnQuXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0ID4gLTEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29rcyBsaWtlIGEgcGFyZW50LlxuICAgICAgICAgICAgICBzdWJyZXN1bHQgPSBmYWN0b3J5KG5vZGUuY2hpbGRyZW5bb2Zmc2V0XSwgb2Zmc2V0LCBncmFuZHBhcmVudHMpKClcblxuICAgICAgICAgICAgICBpZiAoc3VicmVzdWx0WzBdID09PSBFWElUKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnJlc3VsdFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2Zmc2V0ID1cbiAgICAgICAgICAgICAgICB0eXBlb2Ygc3VicmVzdWx0WzFdID09PSAnbnVtYmVyJyA/IHN1YnJlc3VsdFsxXSA6IG9mZnNldCArIHN0ZXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIClcblxuLyoqXG4gKiBAcGFyYW0ge1Zpc2l0b3JSZXN1bHR9IHZhbHVlXG4gKiBAcmV0dXJucyB7QWN0aW9uVHVwbGV9XG4gKi9cbmZ1bmN0aW9uIHRvUmVzdWx0KHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gW0NPTlRJTlVFLCB2YWx1ZV1cbiAgfVxuXG4gIHJldHVybiBbdmFsdWVdXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEBwcm9wZXJ0eSB7VGVzdH0gW2lnbm9yZV1cbiAqICAgYHVuaXN0LXV0aWwtaXNgIHRlc3QgdXNlZCB0byBhc3NlcnQgcGFyZW50c1xuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUm9vdH0gUm9vdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Db250ZW50fSBDb250ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlBocmFzaW5nQ29udGVudH0gUGhyYXNpbmdDb250ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlRleHR9IFRleHRcbiAqIEB0eXBlZGVmIHtDb250ZW50fFJvb3R9IE5vZGVcbiAqIEB0eXBlZGVmIHtFeGNsdWRlPEV4dHJhY3Q8Tm9kZSwgaW1wb3J0KCdtZGFzdCcpLlBhcmVudD4sIFJvb3Q+fSBQYXJlbnRcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnKS5UZXN0fSBUZXN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnKS5WaXNpdG9yUmVzdWx0fSBWaXNpdG9yUmVzdWx0XG4gKlxuICogQHR5cGVkZWYgUmVnRXhwTWF0Y2hPYmplY3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlucHV0XG4gKiBAcHJvcGVydHkge1tSb290LCAuLi5BcnJheTxQYXJlbnQ+LCBUZXh0XX0gc3RhY2tcbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfFJlZ0V4cH0gRmluZFxuICogQHR5cGVkZWYge3N0cmluZ3xSZXBsYWNlRnVuY3Rpb259IFJlcGxhY2VcbiAqXG4gKiBAdHlwZWRlZiB7W0ZpbmQsIFJlcGxhY2VdfSBGaW5kQW5kUmVwbGFjZVR1cGxlXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgUmVwbGFjZT59IEZpbmRBbmRSZXBsYWNlU2NoZW1hXG4gKiBAdHlwZWRlZiB7QXJyYXk8RmluZEFuZFJlcGxhY2VUdXBsZT59IEZpbmRBbmRSZXBsYWNlTGlzdFxuICpcbiAqIEB0eXBlZGVmIHtbUmVnRXhwLCBSZXBsYWNlRnVuY3Rpb25dfSBQYWlyXG4gKiBAdHlwZWRlZiB7QXJyYXk8UGFpcj59IFBhaXJzXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgUmVwbGFjZUZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLmFueX0gcGFyYW1ldGVyc1xuICogQHJldHVybnMge0FycmF5PFBocmFzaW5nQ29udGVudD58UGhyYXNpbmdDb250ZW50fHN0cmluZ3xmYWxzZXx1bmRlZmluZWR8bnVsbH1cbiAqL1xuXG5pbXBvcnQgZXNjYXBlIGZyb20gJ2VzY2FwZS1zdHJpbmctcmVnZXhwJ1xuaW1wb3J0IHt2aXNpdFBhcmVudHN9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cydcbmltcG9ydCB7Y29udmVydH0gZnJvbSAndW5pc3QtdXRpbC1pcydcblxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLyoqXG4gKiBAcGFyYW0gdHJlZSBtZGFzdCB0cmVlXG4gKiBAcGFyYW0gZmluZCBWYWx1ZSB0byBmaW5kIGFuZCByZW1vdmUuIFdoZW4gYHN0cmluZ2AsIGVzY2FwZWQgYW5kIG1hZGUgaW50byBhIGdsb2JhbCBgUmVnRXhwYFxuICogQHBhcmFtIFtyZXBsYWNlXSBWYWx1ZSB0byBpbnNlcnQuXG4gKiAgICogV2hlbiBgc3RyaW5nYCwgdHVybmVkIGludG8gYSBUZXh0IG5vZGUuXG4gKiAgICogV2hlbiBgRnVuY3Rpb25gLCBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIGBSZWdFeHAuZXhlY2AgYXNcbiAqICAgICBhcmd1bWVudHMsIGluIHdoaWNoIGNhc2UgaXQgY2FuIHJldHVybiBhIHNpbmdsZSBvciBhIGxpc3Qgb2YgYE5vZGVgLFxuICogICAgIGEgYHN0cmluZ2AgKHdoaWNoIGlzIHdyYXBwZWQgaW4gYSBgVGV4dGAgbm9kZSksIG9yIGBmYWxzZWAgdG8gbm90IHJlcGxhY2VcbiAqIEBwYXJhbSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRBbmRSZXBsYWNlID1cbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKCh0cmVlOiBOb2RlLCBmaW5kOiBGaW5kLCByZXBsYWNlPzogUmVwbGFjZSwgb3B0aW9ucz86IE9wdGlvbnMpID0+IE5vZGUpICZcbiAgICogICAoKHRyZWU6IE5vZGUsIHNjaGVtYTogRmluZEFuZFJlcGxhY2VTY2hlbWF8RmluZEFuZFJlcGxhY2VMaXN0LCBvcHRpb25zPzogT3B0aW9ucykgPT4gTm9kZSlcbiAgICogKX1cbiAgICoqL1xuICAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSB0cmVlXG4gICAgICogQHBhcmFtIHtGaW5kfEZpbmRBbmRSZXBsYWNlU2NoZW1hfEZpbmRBbmRSZXBsYWNlTGlzdH0gZmluZFxuICAgICAqIEBwYXJhbSB7UmVwbGFjZXxPcHRpb25zfSBbcmVwbGFjZV1cbiAgICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0cmVlLCBmaW5kLCByZXBsYWNlLCBvcHRpb25zKSB7XG4gICAgICAvKiogQHR5cGUge09wdGlvbnN8dW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IHNldHRpbmdzXG4gICAgICAvKiogQHR5cGUge0ZpbmRBbmRSZXBsYWNlU2NoZW1hfEZpbmRBbmRSZXBsYWNlTGlzdH0gKi9cbiAgICAgIGxldCBzY2hlbWFcblxuICAgICAgaWYgKHR5cGVvZiBmaW5kID09PSAnc3RyaW5nJyB8fCBmaW5kIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZG9uXHUyMDE5dCBleHBlY3Qgb3B0aW9ucyB0d2ljZS5cbiAgICAgICAgc2NoZW1hID0gW1tmaW5kLCByZXBsYWNlXV1cbiAgICAgICAgc2V0dGluZ3MgPSBvcHRpb25zXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWEgPSBmaW5kXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZG9uXHUyMDE5dCBleHBlY3QgcmVwbGFjZSB0d2ljZS5cbiAgICAgICAgc2V0dGluZ3MgPSByZXBsYWNlXG4gICAgICB9XG5cbiAgICAgIGlmICghc2V0dGluZ3MpIHtcbiAgICAgICAgc2V0dGluZ3MgPSB7fVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpZ25vcmVkID0gY29udmVydChzZXR0aW5ncy5pZ25vcmUgfHwgW10pXG4gICAgICBjb25zdCBwYWlycyA9IHRvUGFpcnMoc2NoZW1hKVxuICAgICAgbGV0IHBhaXJJbmRleCA9IC0xXG5cbiAgICAgIHdoaWxlICgrK3BhaXJJbmRleCA8IHBhaXJzLmxlbmd0aCkge1xuICAgICAgICB2aXNpdFBhcmVudHModHJlZSwgJ3RleHQnLCB2aXNpdG9yKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJlZVxuXG4gICAgICAvKiogQHR5cGUge2ltcG9ydCgndW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzL2NvbXBsZXgtdHlwZXMnKS5CdWlsZFZpc2l0b3I8Um9vdCwgJ3RleHQnPn0gKi9cbiAgICAgIGZ1bmN0aW9uIHZpc2l0b3Iobm9kZSwgcGFyZW50cykge1xuICAgICAgICBsZXQgaW5kZXggPSAtMVxuICAgICAgICAvKiogQHR5cGUge1BhcmVudHx1bmRlZmluZWR9ICovXG4gICAgICAgIGxldCBncmFuZHBhcmVudFxuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgcGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge1BhcmVudH0gKi8gKHBhcmVudHNbaW5kZXhdKVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaWdub3JlZChcbiAgICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG1kYXN0IHZzLiB1bmlzdCBwYXJlbnQuXG4gICAgICAgICAgICAgIGdyYW5kcGFyZW50ID8gZ3JhbmRwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihwYXJlbnQpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBncmFuZHBhcmVudFxuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ3JhbmRwYXJlbnQgPSBwYXJlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmFuZHBhcmVudCkge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHN0YWNrIGlzIGZpbmUuXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXIobm9kZSwgcGFyZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7VGV4dH0gbm9kZVxuICAgICAgICogQHBhcmFtIHtbUm9vdCwgLi4uQXJyYXk8UGFyZW50Pl19IHBhcmVudHNcbiAgICAgICAqIEByZXR1cm5zIHtWaXNpdG9yUmVzdWx0fVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKG5vZGUsIHBhcmVudHMpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gcGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdXG4gICAgICAgIGNvbnN0IGZpbmQgPSBwYWlyc1twYWlySW5kZXhdWzBdXG4gICAgICAgIGNvbnN0IHJlcGxhY2UgPSBwYWlyc1twYWlySW5kZXhdWzFdXG4gICAgICAgIGxldCBzdGFydCA9IDBcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogVFMgaXMgd3JvbmcsIHNvbWUgb2YgdGhlc2UgY2hpbGRyZW4gY2FuIGJlIHRleHQuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2Yobm9kZSlcbiAgICAgICAgbGV0IGNoYW5nZSA9IGZhbHNlXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8UGhyYXNpbmdDb250ZW50Pn0gKi9cbiAgICAgICAgbGV0IG5vZGVzID0gW11cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICBsZXQgcG9zaXRpb25cblxuICAgICAgICBmaW5kLmxhc3RJbmRleCA9IDBcblxuICAgICAgICBsZXQgbWF0Y2ggPSBmaW5kLmV4ZWMobm9kZS52YWx1ZSlcblxuICAgICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9IG1hdGNoLmluZGV4XG4gICAgICAgICAgLyoqIEB0eXBlIHtSZWdFeHBNYXRjaE9iamVjdH0gKi9cbiAgICAgICAgICBjb25zdCBtYXRjaE9iamVjdCA9IHtcbiAgICAgICAgICAgIGluZGV4OiBtYXRjaC5pbmRleCxcbiAgICAgICAgICAgIGlucHV0OiBtYXRjaC5pbnB1dCxcbiAgICAgICAgICAgIHN0YWNrOiBbLi4ucGFyZW50cywgbm9kZV1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHZhbHVlID0gcmVwbGFjZSguLi5tYXRjaCwgbWF0Y2hPYmplY3QpXG5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5sZW5ndGggPiAwID8ge3R5cGU6ICd0ZXh0JywgdmFsdWV9IDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ICE9PSBwb3NpdGlvbikge1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vZGUudmFsdWUuc2xpY2Uoc3RhcnQsIHBvc2l0aW9uKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgbm9kZXMucHVzaCguLi52YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgbm9kZXMucHVzaCh2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhcnQgPSBwb3NpdGlvbiArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZmluZC5nbG9iYWwpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWF0Y2ggPSBmaW5kLmV4ZWMobm9kZS52YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgICBpZiAoc3RhcnQgPCBub2RlLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZXMucHVzaCh7dHlwZTogJ3RleHQnLCB2YWx1ZTogbm9kZS52YWx1ZS5zbGljZShzdGFydCl9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEsIC4uLm5vZGVzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVzID0gW25vZGVdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXggKyBub2Rlcy5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gIClcblxuLyoqXG4gKiBAcGFyYW0ge0ZpbmRBbmRSZXBsYWNlU2NoZW1hfEZpbmRBbmRSZXBsYWNlTGlzdH0gc2NoZW1hXG4gKiBAcmV0dXJucyB7UGFpcnN9XG4gKi9cbmZ1bmN0aW9uIHRvUGFpcnMoc2NoZW1hKSB7XG4gIC8qKiBAdHlwZSB7UGFpcnN9ICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdXG5cbiAgaWYgKHR5cGVvZiBzY2hlbWEgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYXJyYXkgb3Igb2JqZWN0IGFzIHNjaGVtYScpXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgbGV0IGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgc2NoZW1hLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goW1xuICAgICAgICB0b0V4cHJlc3Npb24oc2NoZW1hW2luZGV4XVswXSksXG4gICAgICAgIHRvRnVuY3Rpb24oc2NoZW1hW2luZGV4XVsxXSlcbiAgICAgIF0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGxldCBrZXlcblxuICAgIGZvciAoa2V5IGluIHNjaGVtYSkge1xuICAgICAgaWYgKG93bi5jYWxsKHNjaGVtYSwga2V5KSkge1xuICAgICAgICByZXN1bHQucHVzaChbdG9FeHByZXNzaW9uKGtleSksIHRvRnVuY3Rpb24oc2NoZW1hW2tleV0pXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQHBhcmFtIHtGaW5kfSBmaW5kXG4gKiBAcmV0dXJucyB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b0V4cHJlc3Npb24oZmluZCkge1xuICByZXR1cm4gdHlwZW9mIGZpbmQgPT09ICdzdHJpbmcnID8gbmV3IFJlZ0V4cChlc2NhcGUoZmluZCksICdnJykgOiBmaW5kXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZXBsYWNlfSByZXBsYWNlXG4gKiBAcmV0dXJucyB7UmVwbGFjZUZ1bmN0aW9ufVxuICovXG5mdW5jdGlvbiB0b0Z1bmN0aW9uKHJlcGxhY2UpIHtcbiAgcmV0dXJuIHR5cGVvZiByZXBsYWNlID09PSAnZnVuY3Rpb24nID8gcmVwbGFjZSA6ICgpID0+IHJlcGxhY2Vcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGlua30gTGlua1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuRXh0ZW5zaW9ufSBGcm9tTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLlRyYW5zZm9ybX0gRnJvbU1hcmtkb3duVHJhbnNmb3JtXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5IYW5kbGV9IEZyb21NYXJrZG93bkhhbmRsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdHlwZXMuanMnKS5PcHRpb25zfSBUb01hcmtkb3duRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZpbmQtYW5kLXJlcGxhY2UnKS5SZXBsYWNlRnVuY3Rpb259IFJlcGxhY2VGdW5jdGlvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlJykuUmVnRXhwTWF0Y2hPYmplY3R9IFJlZ0V4cE1hdGNoT2JqZWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZpbmQtYW5kLXJlcGxhY2UnKS5QaHJhc2luZ0NvbnRlbnR9IFBocmFzaW5nQ29udGVudFxuICovXG5cbmltcG9ydCB7Y2NvdW50fSBmcm9tICdjY291bnQnXG5pbXBvcnQge2ZpbmRBbmRSZXBsYWNlfSBmcm9tICdtZGFzdC11dGlsLWZpbmQtYW5kLXJlcGxhY2UnXG5pbXBvcnQge3VuaWNvZGVQdW5jdHVhdGlvbiwgdW5pY29kZVdoaXRlc3BhY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuY29uc3QgaW5Db25zdHJ1Y3QgPSAncGhyYXNpbmcnXG5jb25zdCBub3RJbkNvbnN0cnVjdCA9IFsnYXV0b2xpbmsnLCAnbGluaycsICdpbWFnZScsICdsYWJlbCddXG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duRXh0ZW5zaW9ufSAqL1xuZXhwb3J0IGNvbnN0IGdmbUF1dG9saW5rTGl0ZXJhbEZyb21NYXJrZG93biA9IHtcbiAgdHJhbnNmb3JtczogW3RyYW5zZm9ybUdmbUF1dG9saW5rTGl0ZXJhbHNdLFxuICBlbnRlcjoge1xuICAgIGxpdGVyYWxBdXRvbGluazogZW50ZXJMaXRlcmFsQXV0b2xpbmssXG4gICAgbGl0ZXJhbEF1dG9saW5rRW1haWw6IGVudGVyTGl0ZXJhbEF1dG9saW5rVmFsdWUsXG4gICAgbGl0ZXJhbEF1dG9saW5rSHR0cDogZW50ZXJMaXRlcmFsQXV0b2xpbmtWYWx1ZSxcbiAgICBsaXRlcmFsQXV0b2xpbmtXd3c6IGVudGVyTGl0ZXJhbEF1dG9saW5rVmFsdWVcbiAgfSxcbiAgZXhpdDoge1xuICAgIGxpdGVyYWxBdXRvbGluazogZXhpdExpdGVyYWxBdXRvbGluayxcbiAgICBsaXRlcmFsQXV0b2xpbmtFbWFpbDogZXhpdExpdGVyYWxBdXRvbGlua0VtYWlsLFxuICAgIGxpdGVyYWxBdXRvbGlua0h0dHA6IGV4aXRMaXRlcmFsQXV0b2xpbmtIdHRwLFxuICAgIGxpdGVyYWxBdXRvbGlua1d3dzogZXhpdExpdGVyYWxBdXRvbGlua1d3d1xuICB9XG59XG5cbi8qKiBAdHlwZSB7VG9NYXJrZG93bkV4dGVuc2lvbn0gKi9cbmV4cG9ydCBjb25zdCBnZm1BdXRvbGlua0xpdGVyYWxUb01hcmtkb3duID0ge1xuICB1bnNhZmU6IFtcbiAgICB7XG4gICAgICBjaGFyYWN0ZXI6ICdAJyxcbiAgICAgIGJlZm9yZTogJ1srXFxcXC0uXFxcXHddJyxcbiAgICAgIGFmdGVyOiAnW1xcXFwtLlxcXFx3XScsXG4gICAgICBpbkNvbnN0cnVjdCxcbiAgICAgIG5vdEluQ29uc3RydWN0XG4gICAgfSxcbiAgICB7XG4gICAgICBjaGFyYWN0ZXI6ICcuJyxcbiAgICAgIGJlZm9yZTogJ1tXd10nLFxuICAgICAgYWZ0ZXI6ICdbXFxcXC0uXFxcXHddJyxcbiAgICAgIGluQ29uc3RydWN0LFxuICAgICAgbm90SW5Db25zdHJ1Y3RcbiAgICB9LFxuICAgIHtjaGFyYWN0ZXI6ICc6JywgYmVmb3JlOiAnW3BzXScsIGFmdGVyOiAnXFxcXC8nLCBpbkNvbnN0cnVjdCwgbm90SW5Db25zdHJ1Y3R9XG4gIF1cbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBlbnRlckxpdGVyYWxBdXRvbGluayh0b2tlbikge1xuICB0aGlzLmVudGVyKHt0eXBlOiAnbGluaycsIHRpdGxlOiBudWxsLCB1cmw6ICcnLCBjaGlsZHJlbjogW119LCB0b2tlbilcbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBlbnRlckxpdGVyYWxBdXRvbGlua1ZhbHVlKHRva2VuKSB7XG4gIHRoaXMuY29uZmlnLmVudGVyLmF1dG9saW5rUHJvdG9jb2wuY2FsbCh0aGlzLCB0b2tlbilcbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBleGl0TGl0ZXJhbEF1dG9saW5rSHR0cCh0b2tlbikge1xuICB0aGlzLmNvbmZpZy5leGl0LmF1dG9saW5rUHJvdG9jb2wuY2FsbCh0aGlzLCB0b2tlbilcbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBleGl0TGl0ZXJhbEF1dG9saW5rV3d3KHRva2VuKSB7XG4gIHRoaXMuY29uZmlnLmV4aXQuZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtMaW5rfSAqLyAodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdKVxuICBub2RlLnVybCA9ICdodHRwOi8vJyArIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZXhpdExpdGVyYWxBdXRvbGlua0VtYWlsKHRva2VuKSB7XG4gIHRoaXMuY29uZmlnLmV4aXQuYXV0b2xpbmtFbWFpbC5jYWxsKHRoaXMsIHRva2VuKVxufVxuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbmZ1bmN0aW9uIGV4aXRMaXRlcmFsQXV0b2xpbmsodG9rZW4pIHtcbiAgdGhpcy5leGl0KHRva2VuKVxufVxuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93blRyYW5zZm9ybX0gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUdmbUF1dG9saW5rTGl0ZXJhbHModHJlZSkge1xuICBmaW5kQW5kUmVwbGFjZShcbiAgICB0cmVlLFxuICAgIFtcbiAgICAgIFsvKGh0dHBzPzpcXC9cXC98d3d3KD89XFwuKSkoWy0uXFx3XSspKFteIFxcdFxcclxcbl0qKS9naSwgZmluZFVybF0sXG4gICAgICBbLyhbLS5cXHcrXSspQChbLVxcd10rKD86XFwuWy1cXHddKykrKS9nLCBmaW5kRW1haWxdXG4gICAgXSxcbiAgICB7aWdub3JlOiBbJ2xpbmsnLCAnbGlua1JlZmVyZW5jZSddfVxuICApXG59XG5cbi8qKlxuICogQHR5cGUge1JlcGxhY2VGdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfSBfXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge1JlZ0V4cE1hdGNoT2JqZWN0fSBtYXRjaFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZnVuY3Rpb24gZmluZFVybChfLCBwcm90b2NvbCwgZG9tYWluLCBwYXRoLCBtYXRjaCkge1xuICBsZXQgcHJlZml4ID0gJydcblxuICAvLyBOb3QgYW4gZXhwZWN0ZWQgcHJldmlvdXMgY2hhcmFjdGVyLlxuICBpZiAoIXByZXZpb3VzKG1hdGNoKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gVHJlYXQgYHd3d2AgYXMgcGFydCBvZiB0aGUgZG9tYWluLlxuICBpZiAoL153L2kudGVzdChwcm90b2NvbCkpIHtcbiAgICBkb21haW4gPSBwcm90b2NvbCArIGRvbWFpblxuICAgIHByb3RvY29sID0gJydcbiAgICBwcmVmaXggPSAnaHR0cDovLydcbiAgfVxuXG4gIGlmICghaXNDb3JyZWN0RG9tYWluKGRvbWFpbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHBhcnRzID0gc3BsaXRVcmwoZG9tYWluICsgcGF0aClcblxuICBpZiAoIXBhcnRzWzBdKSByZXR1cm4gZmFsc2VcblxuICAvKiogQHR5cGUge1BocmFzaW5nQ29udGVudH0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHR5cGU6ICdsaW5rJyxcbiAgICB0aXRsZTogbnVsbCxcbiAgICB1cmw6IHByZWZpeCArIHByb3RvY29sICsgcGFydHNbMF0sXG4gICAgY2hpbGRyZW46IFt7dHlwZTogJ3RleHQnLCB2YWx1ZTogcHJvdG9jb2wgKyBwYXJ0c1swXX1dXG4gIH1cblxuICBpZiAocGFydHNbMV0pIHtcbiAgICByZXR1cm4gW3Jlc3VsdCwge3R5cGU6ICd0ZXh0JywgdmFsdWU6IHBhcnRzWzFdfV1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAdHlwZSB7UmVwbGFjZUZ1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd9IF9cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gKiBAcGFyYW0ge1JlZ0V4cE1hdGNoT2JqZWN0fSBtYXRjaFxuICovXG5mdW5jdGlvbiBmaW5kRW1haWwoXywgYXRleHQsIGxhYmVsLCBtYXRjaCkge1xuICBpZiAoXG4gICAgLy8gTm90IGFuIGV4cGVjdGVkIHByZXZpb3VzIGNoYXJhY3Rlci5cbiAgICAhcHJldmlvdXMobWF0Y2gsIHRydWUpIHx8XG4gICAgLy8gTGFiZWwgZW5kcyBpbiBub3QgYWxsb3dlZCBjaGFyYWN0ZXIuXG4gICAgL1tfLVxcZF0kLy50ZXN0KGxhYmVsKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ2xpbmsnLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHVybDogJ21haWx0bzonICsgYXRleHQgKyAnQCcgKyBsYWJlbCxcbiAgICBjaGlsZHJlbjogW3t0eXBlOiAndGV4dCcsIHZhbHVlOiBhdGV4dCArICdAJyArIGxhYmVsfV1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0NvcnJlY3REb21haW4oZG9tYWluKSB7XG4gIGNvbnN0IHBhcnRzID0gZG9tYWluLnNwbGl0KCcuJylcblxuICBpZiAoXG4gICAgcGFydHMubGVuZ3RoIDwgMiB8fFxuICAgIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSAmJlxuICAgICAgKC9fLy50ZXN0KHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdKSB8fFxuICAgICAgICAhL1thLXpBLVpcXGRdLy50ZXN0KHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdKSkpIHx8XG4gICAgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDJdICYmXG4gICAgICAoL18vLnRlc3QocGFydHNbcGFydHMubGVuZ3RoIC0gMl0pIHx8XG4gICAgICAgICEvW2EtekEtWlxcZF0vLnRlc3QocGFydHNbcGFydHMubGVuZ3RoIC0gMl0pKSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmd8dW5kZWZpbmVkXX1cbiAqL1xuZnVuY3Rpb24gc3BsaXRVcmwodXJsKSB7XG4gIGNvbnN0IHRyYWlsRXhlYyA9IC9bIVwiJicpLC46Ozw+P1xcXX1dKyQvLmV4ZWModXJsKVxuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgbGV0IGNsb3NpbmdQYXJlbkluZGV4XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICBsZXQgb3BlbmluZ1BhcmVuc1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgbGV0IGNsb3NpbmdQYXJlbnNcbiAgLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICBsZXQgdHJhaWxcblxuICBpZiAodHJhaWxFeGVjKSB7XG4gICAgdXJsID0gdXJsLnNsaWNlKDAsIHRyYWlsRXhlYy5pbmRleClcbiAgICB0cmFpbCA9IHRyYWlsRXhlY1swXVxuICAgIGNsb3NpbmdQYXJlbkluZGV4ID0gdHJhaWwuaW5kZXhPZignKScpXG4gICAgb3BlbmluZ1BhcmVucyA9IGNjb3VudCh1cmwsICcoJylcbiAgICBjbG9zaW5nUGFyZW5zID0gY2NvdW50KHVybCwgJyknKVxuXG4gICAgd2hpbGUgKGNsb3NpbmdQYXJlbkluZGV4ICE9PSAtMSAmJiBvcGVuaW5nUGFyZW5zID4gY2xvc2luZ1BhcmVucykge1xuICAgICAgdXJsICs9IHRyYWlsLnNsaWNlKDAsIGNsb3NpbmdQYXJlbkluZGV4ICsgMSlcbiAgICAgIHRyYWlsID0gdHJhaWwuc2xpY2UoY2xvc2luZ1BhcmVuSW5kZXggKyAxKVxuICAgICAgY2xvc2luZ1BhcmVuSW5kZXggPSB0cmFpbC5pbmRleE9mKCcpJylcbiAgICAgIGNsb3NpbmdQYXJlbnMrK1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbdXJsLCB0cmFpbF1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cE1hdGNoT2JqZWN0fSBtYXRjaFxuICogQHBhcmFtIHtib29sZWFufSBbZW1haWw9ZmFsc2VdXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcHJldmlvdXMobWF0Y2gsIGVtYWlsKSB7XG4gIGNvbnN0IGNvZGUgPSBtYXRjaC5pbnB1dC5jaGFyQ29kZUF0KG1hdGNoLmluZGV4IC0gMSlcblxuICByZXR1cm4gKFxuICAgIChtYXRjaC5pbmRleCA9PT0gMCB8fFxuICAgICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSkgfHxcbiAgICAgIHVuaWNvZGVQdW5jdHVhdGlvbihjb2RlKSkgJiZcbiAgICAoIWVtYWlsIHx8IGNvZGUgIT09IDQ3KVxuICApXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4dGVuc2lvbn0gRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkh0bWxFeHRlbnNpb259IEh0bWxFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXN0cmlrZXRocm91Z2gnKS5PcHRpb25zfSBPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1mb290bm90ZScpLkh0bWxPcHRpb25zfSBIdG1sT3B0aW9uc1xuICovXG5cbmltcG9ydCB7XG4gIGNvbWJpbmVFeHRlbnNpb25zLFxuICBjb21iaW5lSHRtbEV4dGVuc2lvbnNcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY29tYmluZS1leHRlbnNpb25zJ1xuaW1wb3J0IHtcbiAgZ2ZtQXV0b2xpbmtMaXRlcmFsLFxuICBnZm1BdXRvbGlua0xpdGVyYWxIdG1sXG59IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLWF1dG9saW5rLWxpdGVyYWwnXG5pbXBvcnQge2dmbUZvb3Rub3RlLCBnZm1Gb290bm90ZUh0bWx9IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLWZvb3Rub3RlJ1xuaW1wb3J0IHtcbiAgZ2ZtU3RyaWtldGhyb3VnaCxcbiAgZ2ZtU3RyaWtldGhyb3VnaEh0bWxcbn0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tc3RyaWtldGhyb3VnaCdcbmltcG9ydCB7Z2ZtVGFibGUsIGdmbVRhYmxlSHRtbH0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUnXG5pbXBvcnQge2dmbVRhZ2ZpbHRlckh0bWx9IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXRhZ2ZpbHRlcidcbmltcG9ydCB7XG4gIGdmbVRhc2tMaXN0SXRlbSxcbiAgZ2ZtVGFza0xpc3RJdGVtSHRtbFxufSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YXNrLWxpc3QtaXRlbSdcblxuLyoqXG4gKiBTdXBwb3J0IEdGTSBvciBtYXJrZG93biBvbiBnaXRodWIuY29tLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7RXh0ZW5zaW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNvbWJpbmVFeHRlbnNpb25zKFtcbiAgICBnZm1BdXRvbGlua0xpdGVyYWwsXG4gICAgZ2ZtRm9vdG5vdGUoKSxcbiAgICBnZm1TdHJpa2V0aHJvdWdoKG9wdGlvbnMpLFxuICAgIGdmbVRhYmxlLFxuICAgIGdmbVRhc2tMaXN0SXRlbVxuICBdKVxufVxuXG4vKipcbiAqIFN1cHBvcnQgdG8gY29tcGlsZSBHRk0gdG8gSFRNTC5cbiAqXG4gKiBAcGFyYW0ge0h0bWxPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtIdG1sRXh0ZW5zaW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtSHRtbChvcHRpb25zKSB7XG4gIHJldHVybiBjb21iaW5lSHRtbEV4dGVuc2lvbnMoW1xuICAgIGdmbUF1dG9saW5rTGl0ZXJhbEh0bWwsXG4gICAgZ2ZtRm9vdG5vdGVIdG1sKG9wdGlvbnMpLFxuICAgIGdmbVN0cmlrZXRocm91Z2hIdG1sLFxuICAgIGdmbVRhYmxlSHRtbCxcbiAgICBnZm1UYWdmaWx0ZXJIdG1sLFxuICAgIGdmbVRhc2tMaXN0SXRlbUh0bWxcbiAgXSlcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkV4dGVuc2lvbn0gRnJvbU1hcmtkb3duRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuT3B0aW9uc30gVG9NYXJrZG93bkV4dGVuc2lvblxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZ2ZtLXRhYmxlJykuT3B0aW9uc30gT3B0aW9uc1xuICovXG5cbmltcG9ydCB7XG4gIGdmbUF1dG9saW5rTGl0ZXJhbEZyb21NYXJrZG93bixcbiAgZ2ZtQXV0b2xpbmtMaXRlcmFsVG9NYXJrZG93blxufSBmcm9tICdtZGFzdC11dGlsLWdmbS1hdXRvbGluay1saXRlcmFsJ1xuaW1wb3J0IHtcbiAgZ2ZtRm9vdG5vdGVGcm9tTWFya2Rvd24sXG4gIGdmbUZvb3Rub3RlVG9NYXJrZG93blxufSBmcm9tICdtZGFzdC11dGlsLWdmbS1mb290bm90ZSdcbmltcG9ydCB7XG4gIGdmbVN0cmlrZXRocm91Z2hGcm9tTWFya2Rvd24sXG4gIGdmbVN0cmlrZXRocm91Z2hUb01hcmtkb3duXG59IGZyb20gJ21kYXN0LXV0aWwtZ2ZtLXN0cmlrZXRocm91Z2gnXG5pbXBvcnQge2dmbVRhYmxlRnJvbU1hcmtkb3duLCBnZm1UYWJsZVRvTWFya2Rvd259IGZyb20gJ21kYXN0LXV0aWwtZ2ZtLXRhYmxlJ1xuaW1wb3J0IHtcbiAgZ2ZtVGFza0xpc3RJdGVtRnJvbU1hcmtkb3duLFxuICBnZm1UYXNrTGlzdEl0ZW1Ub01hcmtkb3duXG59IGZyb20gJ21kYXN0LXV0aWwtZ2ZtLXRhc2stbGlzdC1pdGVtJ1xuXG4vKipcbiAqIEByZXR1cm5zIHtBcnJheTxGcm9tTWFya2Rvd25FeHRlbnNpb24+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtRnJvbU1hcmtkb3duKCkge1xuICByZXR1cm4gW1xuICAgIGdmbUF1dG9saW5rTGl0ZXJhbEZyb21NYXJrZG93bixcbiAgICBnZm1Gb290bm90ZUZyb21NYXJrZG93bigpLFxuICAgIGdmbVN0cmlrZXRocm91Z2hGcm9tTWFya2Rvd24sXG4gICAgZ2ZtVGFibGVGcm9tTWFya2Rvd24sXG4gICAgZ2ZtVGFza0xpc3RJdGVtRnJvbU1hcmtkb3duXG4gIF1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1RvTWFya2Rvd25FeHRlbnNpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1Ub01hcmtkb3duKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBleHRlbnNpb25zOiBbXG4gICAgICBnZm1BdXRvbGlua0xpdGVyYWxUb01hcmtkb3duLFxuICAgICAgZ2ZtRm9vdG5vdGVUb01hcmtkb3duKCksXG4gICAgICBnZm1TdHJpa2V0aHJvdWdoVG9NYXJrZG93bixcbiAgICAgIGdmbVRhYmxlVG9NYXJrZG93bihvcHRpb25zKSxcbiAgICAgIGdmbVRhc2tMaXN0SXRlbVRvTWFya2Rvd25cbiAgICBdXG4gIH1cbn1cbiIsICIvLyBAdHMtZXhwZWN0LWVycm9yXG5pbXBvcnQgZm9ybWF0dGVyIGZyb20gJ2Zvcm1hdCdcblxuZXhwb3J0IGNvbnN0IGZhdWx0ID0gT2JqZWN0LmFzc2lnbihjcmVhdGUoRXJyb3IpLCB7XG4gIGV2YWw6IGNyZWF0ZShFdmFsRXJyb3IpLFxuICByYW5nZTogY3JlYXRlKFJhbmdlRXJyb3IpLFxuICByZWZlcmVuY2U6IGNyZWF0ZShSZWZlcmVuY2VFcnJvciksXG4gIHN5bnRheDogY3JlYXRlKFN5bnRheEVycm9yKSxcbiAgdHlwZTogY3JlYXRlKFR5cGVFcnJvciksXG4gIHVyaTogY3JlYXRlKFVSSUVycm9yKVxufSlcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYEVDb25zdHJ1Y3RvcmAsIHdpdGggdGhlIGZvcm1hdHRlZCBgZm9ybWF0YCBhcyBhIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEB0ZW1wbGF0ZSB7RXJyb3J9IEZhdWx0XG4gKiBAdGVtcGxhdGUge25ldyAocmVhc29uOiBzdHJpbmcpID0+IEZhdWx0fSBDbGFzc1xuICogQHBhcmFtIHtDbGFzc30gQ29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShDb25zdHJ1Y3Rvcikge1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBGb3JtYXR0ZWRFcnJvci5kaXNwbGF5TmFtZSA9IENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IENvbnN0cnVjdG9yLm5hbWVcblxuICByZXR1cm4gRm9ybWF0dGVkRXJyb3JcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGVycm9yIHdpdGggYSBwcmludGYtbGlrZSBmb3JtYXR0ZWQgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gW2Zvcm1hdF1cbiAgICogICBUZW1wbGF0ZSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Li4udW5rbm93bn0gdmFsdWVzXG4gICAqICAgVmFsdWVzIHRvIHJlbmRlciBpbiBgZm9ybWF0YC5cbiAgICogQHJldHVybnMge0ZhdWx0fVxuICAgKi9cbiAgZnVuY3Rpb24gRm9ybWF0dGVkRXJyb3IoZm9ybWF0LCAuLi52YWx1ZXMpIHtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBjb25zdCByZWFzb24gPSBmb3JtYXQgPyBmb3JtYXR0ZXIoZm9ybWF0LCAuLi52YWx1ZXMpIDogZm9ybWF0XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihyZWFzb24pXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHsneWFtbCd8J3RvbWwnfSBQcmVzZXRcbiAqICAgRWl0aGVyIGAneWFtbCdgIG9yIGAndG9tbCdgXG4gKlxuICogQHR5cGVkZWYgSW5mb1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG9wZW5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjbG9zZVxuICpcbiAqIEB0eXBlZGVmIE1hdHRlclByb3BzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICogICBUeXBlIHRvIHRva2VuaXplIGFzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthbnl3aGVyZT1mYWxzZV1cbiAqICAgSWYgYHRydWVgLCBtYXR0ZXIgY2FuIGJlIGZvdW5kIGFueXdoZXJlIGluIHRoZSBkb2N1bWVudC5cbiAqICAgSWYgYGZhbHNlYCAoZGVmYXVsdCksIG9ubHkgbWF0dGVyIGF0IHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgaXNcbiAqICAgcmVjb2duaXplZC5cbiAqXG4gKiBAdHlwZWRlZiBNYXJrZXJQcm9wc1xuICogQHByb3BlcnR5IHtzdHJpbmd8SW5mb30gbWFya2VyXG4gKiAgIENoYXJhY3RlciB1c2VkIHRvIGNvbnN0cnVjdCBmZW5jZXMuXG4gKiAgIEJ5IHByb3ZpZGluZyBhbiBvYmplY3Qgd2l0aCBgb3BlbmAgYW5kIGBjbG9zZWAgZGlmZmVyZW50IGNoYXJhY3RlcnMgY2FuIGJlXG4gKiAgIHVzZWQgZm9yIG9wZW5pbmcgYW5kIGNsb3NpbmcgZmVuY2VzLlxuICogICBGb3IgZXhhbXBsZSB0aGUgY2hhcmFjdGVyIGAnLSdgIHdpbGwgcmVzdWx0IGluIGAnLS0tJ2AgYmVpbmcgdXNlZCBhcyB0aGVcbiAqICAgZmVuY2VcbiAqIEBwcm9wZXJ0eSB7bmV2ZXJ9IFtmZW5jZV1cbiAqXG4gKiBAdHlwZWRlZiBGZW5jZVByb3BzXG4gKiBAcHJvcGVydHkge3N0cmluZ3xJbmZvfSBmZW5jZVxuICogICBTdHJpbmcgdXNlZCBhcyB0aGUgY29tcGxldGUgZmVuY2UuXG4gKiAgIEJ5IHByb3ZpZGluZyBhbiBvYmplY3Qgd2l0aCBgb3BlbmAgYW5kIGBjbG9zZWAgZGlmZmVyZW50IHZhbHVlcyBjYW4gYmUgdXNlZFxuICogICBmb3Igb3BlbmluZyBhbmQgY2xvc2luZyBmZW5jZXMuXG4gKiAgIFRoaXMgY2FuIGJlIHVzZWQgdG9vIGlmIGZlbmNlcyBjb250YWluIGRpZmZlcmVudCBjaGFyYWN0ZXJzIG9yIGxlbmd0aHNcbiAqICAgb3RoZXIgdGhhbiAzLlxuICogQHByb3BlcnR5IHtuZXZlcn0gW21hcmtlcl1cbiAqXG4gKiBAdHlwZWRlZiB7KE1hdHRlclByb3BzICYgRmVuY2VQcm9wcyl8KE1hdHRlclByb3BzICYgTWFya2VyUHJvcHMpfSBNYXR0ZXJcbiAqXG4gKiBAdHlwZWRlZiB7UHJlc2V0fE1hdHRlcnxBcnJheS48UHJlc2V0fE1hdHRlcj59IE9wdGlvbnNcbiAqL1xuaW1wb3J0IHtmYXVsdH0gZnJvbSAnZmF1bHQnXG5jb25zdCBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuY29uc3QgbWFya2VycyA9IHtcbiAgeWFtbDogJy0nLFxuICB0b21sOiAnKydcbn1cbi8qKlxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9ucz0neWFtbCddXG4gKiBAcmV0dXJucyB7QXJyYXk8TWF0dGVyPn1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF0dGVycyhvcHRpb25zID0gJ3lhbWwnKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8TWF0dGVyPn0gKi9cbiAgY29uc3QgcmVzdWx0cyA9IFtdXG4gIGxldCBpbmRleCA9IC0xIC8vIE9uZSBwcmVzZXQgb3IgbWF0dGVyLlxuXG4gIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSBbb3B0aW9uc11cbiAgfVxuXG4gIHdoaWxlICgrK2luZGV4IDwgb3B0aW9ucy5sZW5ndGgpIHtcbiAgICByZXN1bHRzW2luZGV4XSA9IG1hdHRlcihvcHRpb25zW2luZGV4XSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzXG59XG4vKipcbiAqIEBwYXJhbSB7UHJlc2V0fE1hdHRlcn0gb3B0aW9uXG4gKiBAcmV0dXJucyB7TWF0dGVyfVxuICovXG5cbmZ1bmN0aW9uIG1hdHRlcihvcHRpb24pIHtcbiAgbGV0IHJlc3VsdCA9IG9wdGlvblxuXG4gIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgIGlmICghb3duLmNhbGwobWFya2VycywgcmVzdWx0KSkge1xuICAgICAgdGhyb3cgZmF1bHQoJ01pc3NpbmcgbWF0dGVyIGRlZmluaXRpb24gZm9yIGAlc2AnLCByZXN1bHQpXG4gICAgfVxuXG4gICAgcmVzdWx0ID0ge1xuICAgICAgdHlwZTogcmVzdWx0LFxuICAgICAgbWFya2VyOiBtYXJrZXJzW3Jlc3VsdF1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBmYXVsdCgnRXhwZWN0ZWQgbWF0dGVyIHRvIGJlIGFuIG9iamVjdCwgbm90IGAlamAnLCByZXN1bHQpXG4gIH1cblxuICBpZiAoIW93bi5jYWxsKHJlc3VsdCwgJ3R5cGUnKSkge1xuICAgIHRocm93IGZhdWx0KCdNaXNzaW5nIGB0eXBlYCBpbiBtYXR0ZXIgYCVqYCcsIHJlc3VsdClcbiAgfVxuXG4gIGlmICghb3duLmNhbGwocmVzdWx0LCAnZmVuY2UnKSAmJiAhb3duLmNhbGwocmVzdWx0LCAnbWFya2VyJykpIHtcbiAgICB0aHJvdyBmYXVsdCgnTWlzc2luZyBgbWFya2VyYCBvciBgZmVuY2VgIGluIG1hdHRlciBgJWpgJywgcmVzdWx0KVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeHRlbnNpb259IEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3RSZWNvcmR9IENvbnN0cnVjdFJlY29yZFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL21hdHRlcnMuanMnKS5PcHRpb25zfSBPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tYXR0ZXJzLmpzJykuTWF0dGVyfSBNYXR0ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL21hdHRlcnMuanMnKS5JbmZvfSBJbmZvXG4gKi9cbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nLCBtYXJrZG93blNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge21hdHRlcnN9IGZyb20gJy4uL21hdHRlcnMuanMnXG4vKipcbiAqIENyZWF0ZSBhbiBleHRlbnNpb24gdG8gc3VwcG9ydCBmcm9udG1hdHRlciAoWUFNTCwgVE9NTCwgYW5kIG1vcmUpLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnM9J3lhbWwnXSBPbmUgcHJlc2V0IG9yIG1hdHRlciwgb3IgYW4gYXJyYXkgb2YgdGhlbS5cbiAqIEByZXR1cm5zIHtFeHRlbnNpb259XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb250bWF0dGVyKG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBtYXR0ZXJzKG9wdGlvbnMpXG4gIC8qKiBAdHlwZSB7Q29uc3RydWN0UmVjb3JkfSAqL1xuXG4gIGNvbnN0IGZsb3cgPSB7fVxuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge01hdHRlcn0gKi9cblxuICBsZXQgbWF0dGVyXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXG4gIGxldCBjb2RlXG5cbiAgd2hpbGUgKCsraW5kZXggPCBzZXR0aW5ncy5sZW5ndGgpIHtcbiAgICBtYXR0ZXIgPSBzZXR0aW5nc1tpbmRleF1cbiAgICBjb2RlID0gZmVuY2UobWF0dGVyLCAnb3BlbicpLmNoYXJDb2RlQXQoMClcblxuICAgIGlmIChjb2RlIGluIGZsb3cpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaXQgY2xlYXJseSBkb2VzIGV4aXN0LlxuICAgICAgZmxvd1tjb2RlXS5wdXNoKHBhcnNlKG1hdHRlcikpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dbY29kZV0gPSBbcGFyc2UobWF0dGVyKV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZsb3dcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge01hdHRlcn0gbWF0dGVyXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKG1hdHRlcikge1xuICBjb25zdCBuYW1lID0gbWF0dGVyLnR5cGVcbiAgY29uc3QgYW55d2hlcmUgPSBtYXR0ZXIuYW55d2hlcmVcbiAgY29uc3QgdmFsdWVUeXBlID0gbmFtZSArICdWYWx1ZSdcbiAgY29uc3QgZmVuY2VUeXBlID0gbmFtZSArICdGZW5jZSdcbiAgY29uc3Qgc2VxdWVuY2VUeXBlID0gZmVuY2VUeXBlICsgJ1NlcXVlbmNlJ1xuICBjb25zdCBmZW5jZUNvbnN0cnVjdCA9IHtcbiAgICB0b2tlbml6ZTogdG9rZW5pemVGZW5jZSxcbiAgICBwYXJ0aWFsOiB0cnVlXG4gIH1cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cbiAgbGV0IGJ1ZmZlclxuICByZXR1cm4ge1xuICAgIHRva2VuaXplOiB0b2tlbml6ZUZyb250bWF0dGVyLFxuICAgIGNvbmNyZXRlOiB0cnVlXG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVGcm9udG1hdHRlcihlZmZlY3RzLCBvaywgbm9rKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICByZXR1cm4gc3RhcnRcbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBzZWxmLm5vdygpXG5cbiAgICAgIGlmIChwb3NpdGlvbi5jb2x1bW4gIT09IDEgfHwgKCFhbnl3aGVyZSAmJiBwb3NpdGlvbi5saW5lICE9PSAxKSkge1xuICAgICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIGVmZmVjdHMuZW50ZXIobmFtZSlcbiAgICAgIGJ1ZmZlciA9IGZlbmNlKG1hdHRlciwgJ29wZW4nKVxuICAgICAgcmV0dXJuIGVmZmVjdHMuYXR0ZW1wdChmZW5jZUNvbnN0cnVjdCwgYWZ0ZXJPcGVuaW5nRmVuY2UsIG5vaykoY29kZSlcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIGFmdGVyT3BlbmluZ0ZlbmNlKGNvZGUpIHtcbiAgICAgIGJ1ZmZlciA9IGZlbmNlKG1hdHRlciwgJ2Nsb3NlJylcbiAgICAgIHJldHVybiBsaW5lRW5kKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICAgIHJldHVybiBsaW5lRW5kKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIGVmZmVjdHMuZW50ZXIodmFsdWVUeXBlKVxuICAgICAgcmV0dXJuIGxpbmVEYXRhKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBsaW5lRGF0YShjb2RlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgICAgZWZmZWN0cy5leGl0KHZhbHVlVHlwZSlcbiAgICAgICAgcmV0dXJuIGxpbmVFbmQoY29kZSlcbiAgICAgIH1cblxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gbGluZURhdGFcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoY29kZSkge1xuICAgICAgLy8gUmVxdWlyZSBhIGNsb3NpbmcgZmVuY2UuXG4gICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgICB9IC8vIENhbiBvbmx5IGJlIGFuIGVvbC5cblxuICAgICAgZWZmZWN0cy5lbnRlcignbGluZUVuZGluZycpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG4gICAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KGZlbmNlQ29uc3RydWN0LCBhZnRlciwgbGluZVN0YXJ0KVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgICAgZWZmZWN0cy5leGl0KG5hbWUpXG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVGZW5jZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gICAgbGV0IGJ1ZmZlckluZGV4ID0gMFxuICAgIHJldHVybiBzdGFydFxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gYnVmZmVyLmNoYXJDb2RlQXQoYnVmZmVySW5kZXgpKSB7XG4gICAgICAgIGVmZmVjdHMuZW50ZXIoZmVuY2VUeXBlKVxuICAgICAgICBlZmZlY3RzLmVudGVyKHNlcXVlbmNlVHlwZSlcbiAgICAgICAgcmV0dXJuIGluc2lkZVNlcXVlbmNlKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIGluc2lkZVNlcXVlbmNlKGNvZGUpIHtcbiAgICAgIGlmIChidWZmZXJJbmRleCA9PT0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBlZmZlY3RzLmV4aXQoc2VxdWVuY2VUeXBlKVxuXG4gICAgICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICAgICAgZWZmZWN0cy5lbnRlcignd2hpdGVzcGFjZScpXG4gICAgICAgICAgcmV0dXJuIGluc2lkZVdoaXRlc3BhY2UoY29kZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmZW5jZUVuZChjb2RlKVxuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA9PT0gYnVmZmVyLmNoYXJDb2RlQXQoYnVmZmVySW5kZXgrKykpIHtcbiAgICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICAgIHJldHVybiBpbnNpZGVTZXF1ZW5jZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBpbnNpZGVXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgICByZXR1cm4gaW5zaWRlV2hpdGVzcGFjZVxuICAgICAgfVxuXG4gICAgICBlZmZlY3RzLmV4aXQoJ3doaXRlc3BhY2UnKVxuICAgICAgcmV0dXJuIGZlbmNlRW5kKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBmZW5jZUVuZChjb2RlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgICAgZWZmZWN0cy5leGl0KGZlbmNlVHlwZSlcbiAgICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtNYXR0ZXJ9IG1hdHRlclxuICogQHBhcmFtIHsnb3Blbid8J2Nsb3NlJ30gcHJvcFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmZW5jZShtYXR0ZXIsIHByb3ApIHtcbiAgcmV0dXJuIG1hdHRlci5tYXJrZXJcbiAgICA/IHBpY2sobWF0dGVyLm1hcmtlciwgcHJvcCkucmVwZWF0KDMpIC8vIEB0cy1leHBlY3QtZXJyb3I6IFRoZXlcdTIwMTlyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAgOiBwaWNrKG1hdHRlci5mZW5jZSwgcHJvcClcbn1cbi8qKlxuICogQHBhcmFtIHtJbmZvfHN0cmluZ30gc2NoZW1hXG4gKiBAcGFyYW0geydvcGVuJ3wnY2xvc2UnfSBwcm9wXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHBpY2soc2NoZW1hLCBwcm9wKSB7XG4gIHJldHVybiB0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJyA/IHNjaGVtYSA6IHNjaGVtYVtwcm9wXVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaXRlcmFsfSBMaXRlcmFsXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5FeHRlbnNpb259IEZyb21NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuSGFuZGxlfSBGcm9tTWFya2Rvd25IYW5kbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3R5cGVzLmpzJykuT3B0aW9uc30gVG9NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdHlwZXMuanMnKS5IYW5kbGV9IFRvTWFya2Rvd25IYW5kbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvaW5kZW50LWxpbmVzLmpzJykuTWFwfSBNYXBcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstZXh0ZW5zaW9uLWZyb250bWF0dGVyL21hdHRlcnMuanMnKS5PcHRpb25zfSBPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstZXh0ZW5zaW9uLWZyb250bWF0dGVyL21hdHRlcnMuanMnKS5NYXR0ZXJ9IE1hdHRlclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLWV4dGVuc2lvbi1mcm9udG1hdHRlci9tYXR0ZXJzLmpzJykuSW5mb30gSW5mb1xuICovXG5cbmltcG9ydCB7bWF0dGVyc30gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1mcm9udG1hdHRlci9tYXR0ZXJzLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7RnJvbU1hcmtkb3duRXh0ZW5zaW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbnRtYXR0ZXJGcm9tTWFya2Rvd24ob3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG1hdHRlcnMob3B0aW9ucylcbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25FeHRlbnNpb25bJ2VudGVyJ119ICovXG4gIGNvbnN0IGVudGVyID0ge31cbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25FeHRlbnNpb25bJ2V4aXQnXX0gKi9cbiAgY29uc3QgZXhpdCA9IHt9XG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBzZXR0aW5ncy5sZW5ndGgpIHtcbiAgICBjb25zdCBtYXR0ZXIgPSBzZXR0aW5nc1tpbmRleF1cbiAgICBlbnRlclttYXR0ZXIudHlwZV0gPSBvcGVuZXIobWF0dGVyKVxuICAgIGV4aXRbbWF0dGVyLnR5cGVdID0gY2xvc2VcbiAgICBleGl0W21hdHRlci50eXBlICsgJ1ZhbHVlJ10gPSB2YWx1ZVxuICB9XG5cbiAgcmV0dXJuIHtlbnRlciwgZXhpdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge01hdHRlcn0gbWF0dGVyXG4gKiBAcmV0dXJucyB7RnJvbU1hcmtkb3duSGFuZGxlfSBlbnRlclxuICovXG5mdW5jdGlvbiBvcGVuZXIobWF0dGVyKSB7XG4gIHJldHVybiBvcGVuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBvcGVuKHRva2VuKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogY3VzdG9tLlxuICAgIHRoaXMuZW50ZXIoe3R5cGU6IG1hdHRlci50eXBlLCB2YWx1ZTogJyd9LCB0b2tlbilcbiAgICB0aGlzLmJ1ZmZlcigpXG4gIH1cbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBjbG9zZSh0b2tlbikge1xuICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAvLyBSZW1vdmUgdGhlIGluaXRpYWwgYW5kIGZpbmFsIGVvbC5cbiAgdGhpcy5leGl0KHRva2VuKS52YWx1ZSA9IGRhdGEucmVwbGFjZSgvXihcXHI/XFxufFxccil8KFxccj9cXG58XFxyKSQvZywgJycpXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gdmFsdWUodG9rZW4pIHtcbiAgdGhpcy5jb25maWcuZW50ZXIuZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICB0aGlzLmNvbmZpZy5leGl0LmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1RvTWFya2Rvd25FeHRlbnNpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9udG1hdHRlclRvTWFya2Rvd24ob3B0aW9ucykge1xuICAvKiogQHR5cGUge1RvTWFya2Rvd25FeHRlbnNpb25bJ3Vuc2FmZSddfSAqL1xuICBjb25zdCB1bnNhZmUgPSBbXVxuICAvKiogQHR5cGUge1RvTWFya2Rvd25FeHRlbnNpb25bJ2hhbmRsZXJzJ119ICovXG4gIGNvbnN0IGhhbmRsZXJzID0ge31cbiAgY29uc3Qgc2V0dGluZ3MgPSBtYXR0ZXJzKG9wdGlvbnMpXG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBzZXR0aW5ncy5sZW5ndGgpIHtcbiAgICBjb25zdCBtYXR0ZXIgPSBzZXR0aW5nc1tpbmRleF1cbiAgICBoYW5kbGVyc1ttYXR0ZXIudHlwZV0gPSBoYW5kbGVyKG1hdHRlcilcbiAgICB1bnNhZmUucHVzaCh7YXRCcmVhazogdHJ1ZSwgY2hhcmFjdGVyOiBmZW5jZShtYXR0ZXIsICdvcGVuJykuY2hhckF0KDApfSlcbiAgfVxuXG4gIHJldHVybiB7dW5zYWZlLCBoYW5kbGVyc31cbn1cblxuLyoqXG4gKiBAcGFyYW0ge01hdHRlcn0gbWF0dGVyXG4gKiBAcmV0dXJucyB7KG5vZGU6IExpdGVyYWwpID0+IHN0cmluZ30gZW50ZXJcbiAqL1xuZnVuY3Rpb24gaGFuZGxlcihtYXR0ZXIpIHtcbiAgY29uc3Qgb3BlbiA9IGZlbmNlKG1hdHRlciwgJ29wZW4nKVxuICBjb25zdCBjbG9zZSA9IGZlbmNlKG1hdHRlciwgJ2Nsb3NlJylcblxuICByZXR1cm4gaGFuZGxlXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfVxuICAgKiBAcGFyYW0ge0xpdGVyYWx9IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZShub2RlKSB7XG4gICAgcmV0dXJuIG9wZW4gKyAobm9kZS52YWx1ZSA/ICdcXG4nICsgbm9kZS52YWx1ZSA6ICcnKSArICdcXG4nICsgY2xvc2VcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWF0dGVyfSBtYXR0ZXJcbiAqIEBwYXJhbSB7J29wZW4nfCdjbG9zZSd9IHByb3BcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZlbmNlKG1hdHRlciwgcHJvcCkge1xuICByZXR1cm4gbWF0dGVyLm1hcmtlclxuICAgID8gcGljayhtYXR0ZXIubWFya2VyLCBwcm9wKS5yZXBlYXQoMylcbiAgICA6IC8vIEB0cy1leHBlY3QtZXJyb3I6IFRoZXlcdTIwMTlyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAgICBwaWNrKG1hdHRlci5mZW5jZSwgcHJvcClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0luZm98c3RyaW5nfSBzY2hlbWFcbiAqIEBwYXJhbSB7J29wZW4nfCdjbG9zZSd9IHByb3BcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHBpY2soc2NoZW1hLCBwcm9wKSB7XG4gIHJldHVybiB0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJyA/IHNjaGVtYSA6IHNjaGVtYVtwcm9wXVxufVxuIiwgInR5cGUgUG9pbnQgPSB7XG4gICAgbGluZTogbnVtYmVyO1xuICAgIGNvbHVtbjogbnVtYmVyO1xuICAgIG9mZnNldD86IG51bWJlciB8IHVuZGVmaW5lZDtcbn07XG5cbnR5cGUgRWRpdG9yUG9zaXRpb24gPSB7XG4gICAgbGluZTogbnVtYmVyO1xuICAgIGNoOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBSYW5nZSA9IHtcbiAgICBzdGFydDogUG9zO1xuICAgIGVuZDogUG9zO1xufTtcblxuZXhwb3J0IGNsYXNzIFBvcyB7XG4gICAgbGluZTogbnVtYmVyO1xuICAgIGNvbHVtbjogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IobGluZTogbnVtYmVyLCBjb2x1bW46IG51bWJlcikge1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUVkaXRvclBvc2l0aW9uKHBvczogRWRpdG9yUG9zaXRpb24pOiBQb3Mge1xuICAgICAgICByZXR1cm4gbmV3IFBvcyhwb3MubGluZSArIDEsIHBvcy5jaCArIDEpO1xuICAgIH1cblxuICAgIHRvRWRpdG9yUG9zaXRpb24oKTogRWRpdG9yUG9zaXRpb24ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZTogdGhpcy5saW5lIC0gMSxcbiAgICAgICAgICAgIGNoOiB0aGlzLmNvbHVtbiAtIDEsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21Qb2ludChwb3M6IFBvaW50KTogUG9zIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3MocG9zLmxpbmUsIHBvcy5jb2x1bW4pO1xuICAgIH1cblxuICAgIGNvbXBhcmVUbyhvdGhlcjogUG9zKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMubGluZSA8IG90aGVyLmxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lID4gb3RoZXIubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uIDwgb3RoZXIuY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uID4gb3RoZXIuY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBlcXVhbHMob3RoZXI6IFBvcyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID09PSAwO1xuICAgIH1cblxuICAgIGluUmFuZ2Uoc3RhcnQ6IFBvcywgZW5kOiBQb3MpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKHN0YXJ0KSA+PSAwICYmIHRoaXMuY29tcGFyZVRvKGVuZCkgPD0gMDtcbiAgICB9XG5cbiAgICBzdGF0aWMgb3JkZXIoYTogUG9zLCBiOiBQb3MpOiBSYW5nZSB7XG4gICAgICAgIGlmIChhLmNvbXBhcmVUbyhiKSA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBhLFxuICAgICAgICAgICAgICAgIGVuZDogYixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBiLFxuICAgICAgICAgICAgICAgIGVuZDogYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtaW51cyhvdGhlcjogUG9zKTogUG9zIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3ModGhpcy5saW5lIC0gb3RoZXIubGluZSwgdGhpcy5jb2x1bW4gLSBvdGhlci5jb2x1bW4pO1xuICAgIH1cblxuICAgIHBsdXMob3RoZXI6IFBvcyk6IFBvcyB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zKHRoaXMubGluZSArIG90aGVyLmxpbmUsIHRoaXMuY29sdW1uIC0gb3RoZXIuY29sdW1uKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQ29udGVudCwgSGVhZGluZywgUG9pbnQsIFJvb3QgfSBmcm9tICdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24vbGliJztcbmltcG9ydCB7IGZyb21NYXJrZG93biB9IGZyb20gJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bic7XG5pbXBvcnQgeyBtYXRoIH0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1tYXRoJztcbmltcG9ydCB7IG1hdGhGcm9tTWFya2Rvd24gfSBmcm9tICdtZGFzdC11dGlsLW1hdGgnO1xuaW1wb3J0IHsgZ2ZtVGFza0xpc3RJdGVtIH0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFzay1saXN0LWl0ZW0nO1xuaW1wb3J0IHsgZ2ZtVGFza0xpc3RJdGVtRnJvbU1hcmtkb3duIH0gZnJvbSAnbWRhc3QtdXRpbC1nZm0tdGFzay1saXN0LWl0ZW0nO1xuaW1wb3J0IHsgZ2ZtVGFibGUgfSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZSc7XG5pbXBvcnQgeyBnZm1UYWJsZUZyb21NYXJrZG93biB9IGZyb20gJ21kYXN0LXV0aWwtZ2ZtLXRhYmxlJztcbmltcG9ydCB7IGdmbVN0cmlrZXRocm91Z2ggfSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1zdHJpa2V0aHJvdWdoJztcbmltcG9ydCB7IGdmbVN0cmlrZXRocm91Z2hGcm9tTWFya2Rvd24gfSBmcm9tICdtZGFzdC11dGlsLWdmbS1zdHJpa2V0aHJvdWdoJztcbmltcG9ydCB7IGdmbUZvb3Rub3RlIH0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tZm9vdG5vdGUnO1xuaW1wb3J0IHsgZ2ZtRm9vdG5vdGVGcm9tTWFya2Rvd24gfSBmcm9tICdtZGFzdC11dGlsLWdmbS1mb290bm90ZSc7XG5pbXBvcnQgeyBnZm1BdXRvbGlua0xpdGVyYWwgfSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsJztcbmltcG9ydCB7IGdmbUF1dG9saW5rTGl0ZXJhbEZyb21NYXJrZG93biB9IGZyb20gJ21kYXN0LXV0aWwtZ2ZtLWF1dG9saW5rLWxpdGVyYWwnO1xuaW1wb3J0IHsgZ2ZtIH0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0nO1xuaW1wb3J0IHsgZ2ZtRnJvbU1hcmtkb3duIH0gZnJvbSAnbWRhc3QtdXRpbC1nZm0nO1xuaW1wb3J0IHsgZnJvbnRtYXR0ZXIgfSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWZyb250bWF0dGVyJztcbmltcG9ydCB7IGZyb250bWF0dGVyRnJvbU1hcmtkb3duIH0gZnJvbSAnbWRhc3QtdXRpbC1mcm9udG1hdHRlcic7XG5cbmltcG9ydCB7IFBvcywgUmFuZ2UgfSBmcm9tICcuL1Bvcyc7XG5cbmV4cG9ydCB0eXBlIE1kYXN0Tm9kZSA9IHtcbiAgICBwb3NpdGlvbjoge1xuICAgICAgICBzdGFydDogUG9pbnQ7XG4gICAgICAgIGVuZDogUG9pbnQ7XG4gICAgfTtcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgY2hpbGRyZW4/OiBNZGFzdE5vZGVbXTtcbiAgICBwYXJlbnQ/OiBNZGFzdE5vZGU7XG59O1xuXG5leHBvcnQgY2xhc3MgTWRhc3Qge1xuICAgIHN0YXRpYyBpbk5vZGUobm9kZTogTWRhc3ROb2RlLCBwb3M6IFBvcykge1xuICAgICAgICBpZiAoIW5vZGUucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3MuaW5SYW5nZShQb3MuZnJvbVBvaW50KG5vZGUucG9zaXRpb24uc3RhcnQpLCBQb3MuZnJvbVBvaW50KG5vZGUucG9zaXRpb24uZW5kKSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGZpbGxzTm9kZShub2RlOiBNZGFzdE5vZGUsIHsgc3RhcnQsIGVuZCB9OiBSYW5nZSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIW5vZGUucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBQb3MuZnJvbVBvaW50KG5vZGUucG9zaXRpb24uc3RhcnQpLmNvbXBhcmVUbyhzdGFydCkgPT09IDAgJiZcbiAgICAgICAgICAgIFBvcy5mcm9tUG9pbnQobm9kZS5wb3NpdGlvbi5lbmQpLmNvbXBhcmVUbyhlbmQpID09PSAwXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIGxvZ1Bvcyhwb3M6IHsgc3RhcnQ6IFBvaW50OyBlbmQ6IFBvaW50IH0gfCB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBwb3Muc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwb3MuZW5kO1xuICAgICAgICAgICAgcmV0dXJuIGBbJHtzdGFydC5saW5lfToke3N0YXJ0LmNvbHVtbn0tJHtlbmQubGluZX06JHtlbmQuY29sdW1ufV1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdbXSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbG9nTm9kZShub2RlOiBNZGFzdE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubG9nUG9zKG5vZGUucG9zaXRpb24pICtcbiAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgKG5vZGUuY2hpbGRyZW4gPyBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHRoaXMubG9nUG9zKGNoaWxkLnBvc2l0aW9uKSkgOiBbXSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBhZGp1c3Qgbm9kZSBib3VuZGFyaWVzIHNvIHRoZXkgYXJlIGNvbnRpbnVvdXMgYW5kIGZpbGwgdGhlIHBhcmVudFxuICAgIHN0YXRpYyBhZGp1c3RCb3VuZGFyaWVzKHBhcmVudDogTWRhc3ROb2RlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gcGFyZW50LnBvc2l0aW9uLnN0YXJ0O1xuICAgICAgICBpZiAoIXBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ2JlZm9yZScsIHRoaXMubG9nTm9kZShwYXJlbnQpKTtcblxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbi5maWx0ZXIoKGNoaWxkKSA9PiAhIWNoaWxkLnBvc2l0aW9uKTtcblxuICAgICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hpbGRyZW5bMF0ucG9zaXRpb24uc3RhcnQgPSBwYXJlbnQucG9zaXRpb24uc3RhcnQ7XG4gICAgICAgIC8vIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnBvc2l0aW9uLmVuZCA9IHBhcmVudC5wb3NpdGlvbi5lbmQ7XG5cbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgLy8gICAgIGNoaWxkcmVuW2ldLnBvc2l0aW9uLmVuZCA9IGNoaWxkcmVuW2kgKyAxXS5wb3NpdGlvbi5zdGFydDtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdhZnRlcicsIHRoaXMubG9nTm9kZShwYXJlbnQpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZmluZE5vZGVXaXRoUmFuZ2Uocm9vdDogTWRhc3ROb2RlLCB7IHN0YXJ0LCBlbmQgfTogUmFuZ2UpOiB7IG5vZGU6IE1kYXN0Tm9kZTsgYW5jZXN0b3JzOiBNZGFzdE5vZGVbXSB9IHtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXJlbnQ6IE1kYXN0Tm9kZSA9IHJvb3Q7XG5cbiAgICAgICAgY29uc3Qgbm9kZVN0YWNrOiBNZGFzdE5vZGVbXSA9IFtdO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgdHJ5aW5nIG5vZGVgLCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgICAgIG5vZGVTdGFjay5wdXNoKGN1cnJlbnRQYXJlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLmFkanVzdEJvdW5kYXJpZXMoY3VycmVudFBhcmVudCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbG9va2luZyAgICBpbicsIHRoaXMubG9nTm9kZShjdXJyZW50UGFyZW50KSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkOiBNZGFzdE5vZGUgfCB1bmRlZmluZWQgPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuPy5maW5kKFxuICAgICAgICAgICAgICAgIChub2RlKSA9PiB0aGlzLmluTm9kZShub2RlLCBzdGFydCkgJiYgdGhpcy5pbk5vZGUobm9kZSwgZW5kKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgbm8gbWF0Y2hpbmcgY2hpbGRgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCdjaGlsZHJlbicgaW4gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgY2hpbGQgd2l0aCBjaGlsZHJlbmApO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBjaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYGNoaWxkIHdpdGggbm8gY2hpbGRyZW5gKTtcbiAgICAgICAgICAgICAgICBub2RlU3RhY2sucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHVwIHRvIHRoZSBoaWdoZXN0IG5vZGUgdGhhdCBoYXMgdGhlIHNhbWUgcmFuZ2UgYXMgdGhlIGxhc3Qgbm9kZVxuICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGVTdGFja1tub2RlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBzYW1lTm9kZUluZGV4O1xuICAgICAgICBmb3IgKHNhbWVOb2RlSW5kZXggPSBub2RlU3RhY2subGVuZ3RoIC0gMjsgc2FtZU5vZGVJbmRleCA+PSAwOyAtLXNhbWVOb2RlSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlU3RhY2tbc2FtZU5vZGVJbmRleF07XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgUG9zLmZyb21Qb2ludChwYXJlbnROb2RlLnBvc2l0aW9uIS5zdGFydCkuZXF1YWxzKFBvcy5mcm9tUG9pbnQobGFzdE5vZGUucG9zaXRpb24hLnN0YXJ0KSkgJiZcbiAgICAgICAgICAgICAgICBQb3MuZnJvbVBvaW50KHBhcmVudE5vZGUucG9zaXRpb24hLmVuZCkuZXF1YWxzKFBvcy5mcm9tUG9pbnQobGFzdE5vZGUucG9zaXRpb24hLmVuZCkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlOiB7IC4uLm5vZGVTdGFja1tzYW1lTm9kZUluZGV4ICsgMV0sIHBhcmVudDogbm9kZVN0YWNrW01hdGgubWF4KDAsIHNhbWVOb2RlSW5kZXgpXSB9LFxuICAgICAgICAgICAgYW5jZXN0b3JzOiBub2RlU3RhY2suc2xpY2UoMCwgTWF0aC5tYXgoMCwgc2FtZU5vZGVJbmRleCArIDEpKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNJblBhcmFncmFwaChhbmNlc3RvcnM6IE1kYXN0Tm9kZVtdKTogYm9vbGVhbiB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhbmNlc3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnNbaV0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnNbaV0udHlwZSA9PT0gJ3NlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvcnRjdXQgLSB3ZSBkb24ndCAgbmVlZCB0byBsb29rIGFueSBmYXJ0aGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBmaW5kUGFyZW50UGFyYWdyYXBoKGFuY2VzdG9yczogTWRhc3ROb2RlW10pOiBNZGFzdE5vZGUgfCB1bmRlZmluZWQge1xuICAgICAgICBmb3IgKGxldCBpID0gYW5jZXN0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBpZiAoYW5jZXN0b3JzW2ldLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuY2VzdG9yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnNbaV0udHlwZSA9PT0gJ3NlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvcnRjdXQgLSB3ZSBkb24ndCAgbmVlZCB0byBsb29rIGFueSBmYXJ0aGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG4vLyBAdHMtaWdub3JlXG5pbnRlcmZhY2UgU2VjdGlvbiBleHRlbmRzIFBhcmVudCB7XG4gICAgdHlwZTogJ3NlY3Rpb24nO1xuICAgIGNoaWxkcmVuOiBbSGVhZGluZywgU2VjdGlvbkNvbnRlbnQsIFN1YlNlY3Rpb25zXTtcbiAgICBwb3NpdGlvbjogUmFuZ2U7XG59XG5cbi8vIEB0cy1pZ25vcmVcbmludGVyZmFjZSBTZWN0aW9uQ29udGVudCBleHRlbmRzIFBhcmVudCB7XG4gICAgdHlwZTogJ3NlY3Rpb24tY29udGVudCc7XG4gICAgY2hpbGRyZW46IENvbnRlbnRbXTtcbiAgICBwb3NpdGlvbjogUmFuZ2U7XG59XG5cbi8vIEB0cy1pZ25vcmVcbmludGVyZmFjZSBTdWJTZWN0aW9ucyBleHRlbmRzIFBhcmVudCB7XG4gICAgdHlwZTogJ3N1Yi1zZWN0aW9ucyc7XG4gICAgY2hpbGRyZW46IENvbnRlbnRbXTtcbiAgICBwb3NpdGlvbjogUmFuZ2U7XG59XG5cbmNsYXNzIE1hcmtkb3duQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgcm9vdDogUm9vdCkge31cblxuICAgIGZpbmROb2RlV2l0aFJhbmdlKHJhbmdlOiBSYW5nZSk6IHsgbm9kZTogTWRhc3ROb2RlOyBhbmNlc3RvcnM6IE1kYXN0Tm9kZVtdIH0ge1xuICAgICAgICByZXR1cm4gTWRhc3QuZmluZE5vZGVXaXRoUmFuZ2UodGhpcy5yb290IGFzIE1kYXN0Tm9kZSwgcmFuZ2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1hcmtkb3duQVNUQnVpbGRlciB7XG4gICAgc3RhdGljIHBhcnNlKG1hcmtkb3duOiBzdHJpbmcpOiBNYXJrZG93bkFTVCB7XG4gICAgICAgIGNvbnN0IHRyZWUgPSBmcm9tTWFya2Rvd24obWFya2Rvd24sIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IFtcbiAgICAgICAgICAgICAgICBtYXRoKCksXG4gICAgICAgICAgICAgICAgZ2ZtVGFza0xpc3RJdGVtLFxuICAgICAgICAgICAgICAgIGdmbVRhYmxlLFxuICAgICAgICAgICAgICAgIGdmbVN0cmlrZXRocm91Z2goKSxcbiAgICAgICAgICAgICAgICBnZm1Gb290bm90ZSgpLFxuICAgICAgICAgICAgICAgIGdmbUF1dG9saW5rTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICBnZm0oKSxcbiAgICAgICAgICAgICAgICBmcm9udG1hdHRlcihbJ3lhbWwnXSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbWRhc3RFeHRlbnNpb25zOiBbXG4gICAgICAgICAgICAgICAgbWF0aEZyb21NYXJrZG93bigpLFxuICAgICAgICAgICAgICAgIGdmbVRhc2tMaXN0SXRlbUZyb21NYXJrZG93bixcbiAgICAgICAgICAgICAgICBnZm1UYWJsZUZyb21NYXJrZG93bixcbiAgICAgICAgICAgICAgICBnZm1TdHJpa2V0aHJvdWdoRnJvbU1hcmtkb3duLFxuICAgICAgICAgICAgICAgIGdmbUZvb3Rub3RlRnJvbU1hcmtkb3duKCksXG4gICAgICAgICAgICAgICAgZ2ZtQXV0b2xpbmtMaXRlcmFsRnJvbU1hcmtkb3duLFxuICAgICAgICAgICAgICAgIGdmbUZyb21NYXJrZG93bigpLFxuICAgICAgICAgICAgICAgIGZyb250bWF0dGVyRnJvbU1hcmtkb3duKFsneWFtbCddKSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRyZWUpO1xuICAgICAgICB0aGlzLm5lc3RTZWN0aW9ucyh0cmVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IE1hcmtkb3duQVNUKHRyZWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgbmVzdFNlY3Rpb25zKHRyZWU6IFJvb3QpOiB2b2lkIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSA2OyBkZXB0aCA+PSAxOyAtLWRlcHRoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFNlY3Rpb246IFNlY3Rpb24gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmNoaWxkcmVuW2ldLnR5cGUgPT09ICdoZWFkaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nID0gdHJlZS5jaGlsZHJlbltpXSBhcyBIZWFkaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGluZy5kZXB0aCA9PT0gZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25Db250ZW50OiBTZWN0aW9uQ29udGVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2VjdGlvbi1jb250ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFBvcy5mcm9tUG9pbnQoaGVhZGluZy5wb3NpdGlvbiEuZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBQb3MuZnJvbVBvaW50KGhlYWRpbmcucG9zaXRpb24hLmVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YlNlY3Rpb25zOiBTdWJTZWN0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3ViLXNlY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFBvcy5mcm9tUG9pbnQoaGVhZGluZy5wb3NpdGlvbiEuZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBQb3MuZnJvbVBvaW50KGhlYWRpbmcucG9zaXRpb24hLmVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtoZWFkaW5nLCBzZWN0aW9uQ29udGVudCwgc3ViU2VjdGlvbnNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBQb3MuZnJvbVBvaW50KGhlYWRpbmcucG9zaXRpb24hLnN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBQb3MuZnJvbVBvaW50KGhlYWRpbmcucG9zaXRpb24hLmVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUuY2hpbGRyZW5baV0gPSBjdXJyZW50U2VjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkaW5nLmRlcHRoIDwgZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJlZS5jaGlsZHJlbltpXS50eXBlID09PSAnc2VjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VjdGlvbi5jaGlsZHJlblsyXS5jaGlsZHJlbi5wdXNoKHRyZWUuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VjdGlvbi5jaGlsZHJlblsxXS5jaGlsZHJlbi5wdXNoKHRyZWUuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBQb3MuZnJvbVBvaW50KHRyZWUuY2hpbGRyZW5baV0ucG9zaXRpb24hLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VjdGlvbi5wb3NpdGlvbi5lbmQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VjdGlvbi5jaGlsZHJlblsxXS5wb3NpdGlvbi5lbmQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlLmNoaWxkcmVuW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmVlLmNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbi5maWx0ZXIoKG5vZGU6IGFueSkgPT4gISFub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBQb2ludCB9IGZyb20gJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bi9saWInO1xuaW1wb3J0IHsgUG9zLCBSYW5nZSB9IGZyb20gJy4vUG9zJztcbmltcG9ydCB7IE5vZGUgYXMgU2ltcGxlVGV4dE5vZGUgfSBmcm9tICcuL1NpbXBsZVRleHQnO1xuXG5leHBvcnQgY2xhc3MgQW50bHIge1xuICAgIHN0YXRpYyBpbk5vZGUobm9kZTogU2ltcGxlVGV4dE5vZGUsIHBvczogUG9zKSB7XG4gICAgICAgIGlmIChub2RlLnN0YXJ0Py5saW5lID09PSB1bmRlZmluZWQgfHwgbm9kZS5lbmQ/LmxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRklYTUUgLSBnZXQgcmlkIG9mIG1kYXN0IHBvaW50cyBoZXJlXG4gICAgICAgIHJldHVybiBwb3MuaW5SYW5nZShQb3MuZnJvbVBvaW50KG5vZGUuc3RhcnQgYXMgUG9pbnQpLCBQb3MuZnJvbVBvaW50KG5vZGUuZW5kIGFzIFBvaW50KSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGZpbGxzTm9kZShub2RlOiBTaW1wbGVUZXh0Tm9kZSwgeyBzdGFydCwgZW5kIH06IFJhbmdlKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChub2RlLnN0YXJ0Py5saW5lID09PSB1bmRlZmluZWQgfHwgbm9kZS5lbmQ/LmxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFBvcy5mcm9tUG9pbnQobm9kZS5zdGFydCBhcyBQb2ludCkuY29tcGFyZVRvKHN0YXJ0KSA9PT0gMCAmJlxuICAgICAgICAgICAgUG9zLmZyb21Qb2ludChub2RlLmVuZCBhcyBQb2ludCkuY29tcGFyZVRvKGVuZCkgPT09IDBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZmluZE5vZGVXaXRoUmFuZ2UoXG4gICAgICAgIHJvb3Q6IFNpbXBsZVRleHROb2RlLFxuICAgICAgICB7IHN0YXJ0LCBlbmQgfTogUmFuZ2UsXG4gICAgKTogeyBub2RlOiBTaW1wbGVUZXh0Tm9kZTsgYW5jZXN0b3JzOiBTaW1wbGVUZXh0Tm9kZVtdIH0ge1xuICAgICAgICBsZXQgY3VycmVudFBhcmVudDogU2ltcGxlVGV4dE5vZGUgPSByb290O1xuXG4gICAgICAgIGNvbnN0IG5vZGVTdGFjazogU2ltcGxlVGV4dE5vZGVbXSA9IFtdO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0cnlpbmcgbm9kZScsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICAgICAgbm9kZVN0YWNrLnB1c2goY3VycmVudFBhcmVudCk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FOiB3ZSBhbHNvIG5lZWQgdG8gY2hlY2sgd2hldGhlciB3ZSBhcmUgaW4gYSBcImdhcFwiLCBpZS4gYmV0d2VlbiB0d28gIG5vZGVzLiBJbiB0aGF0IGNhc2UgY29uc2lkZXJcbiAgICAgICAgICAgIC8vICAgICAgICB3ZSBhcmUgaW4gdGhlIGZpcnN0IG5vZGUuIERvIHRoZSBzYW1lIGZvciB0aGUgbWFya2Rvd24gdmVyc2lvbi4gVGhpcyBhdm9pZHMgc2VsZWN0aW5nIFwidXBcIiB0b28gZmFzdFxuICAgICAgICAgICAgY29uc3QgY2hpbGQ6IFNpbXBsZVRleHROb2RlIHwgdW5kZWZpbmVkID0gY3VycmVudFBhcmVudC5jaGlsZHJlbj8uZmluZChcbiAgICAgICAgICAgICAgICAobm9kZSkgPT4gdGhpcy5pbk5vZGUobm9kZSwgc3RhcnQpICYmIHRoaXMuaW5Ob2RlKG5vZGUsIGVuZCksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ25vIG1hdGNoaW5nIGNoaWxkJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgnY2hpbGRyZW4nIGluIGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NoaWxkIHdpdGggY2hpbGRyZW4nKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gY2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjaGlsZCB3aXRoIG5vIGNoaWxkcmVuJyk7XG4gICAgICAgICAgICAgICAgbm9kZVN0YWNrLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW92ZSB1cCB0byB0aGUgaGlnaGVzdCBub2RlIHRoYXQgaGFzIHRoZSBzYW1lIHJhbmdlIGFzIHRoZSBsYXN0IG5vZGVcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSBub2RlU3RhY2tbbm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBsZXQgc2FtZU5vZGVJbmRleDtcbiAgICAgICAgZm9yIChzYW1lTm9kZUluZGV4ID0gbm9kZVN0YWNrLmxlbmd0aCAtIDI7IHNhbWVOb2RlSW5kZXggPj0gMDsgLS1zYW1lTm9kZUluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZVN0YWNrW3NhbWVOb2RlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFBvcy5mcm9tUG9pbnQocGFyZW50Tm9kZS5zdGFydCBhcyBQb2ludCkuZXF1YWxzKFBvcy5mcm9tUG9pbnQobGFzdE5vZGUuc3RhcnQgYXMgUG9pbnQpKSAmJlxuICAgICAgICAgICAgICAgIFBvcy5mcm9tUG9pbnQocGFyZW50Tm9kZS5lbmQgYXMgUG9pbnQpLmVxdWFscyhQb3MuZnJvbVBvaW50KGxhc3ROb2RlLmVuZCBhcyBQb2ludCkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlOiBub2RlU3RhY2tbc2FtZU5vZGVJbmRleCArIDFdLFxuICAgICAgICAgICAgYW5jZXN0b3JzOiBub2RlU3RhY2suc2xpY2UoMCwgTWF0aC5tYXgoMCwgc2FtZU5vZGVJbmRleCArIDEpKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBS0EscUJBQ0MsUUFDQSxhQUNBLG9CQUFnRDtJQUVqRDtBQUxBLFlBQUEsVUFBQTtBQU9BLHNCQUNDLFFBQ0EsYUFDQSxvQkFBZ0Q7SUFFakQ7QUFMQSxZQUFBLFdBQUE7QUFPQSxzQkFDQyxRQUNBLGFBQ0Esb0JBQXVDO0lBRXhDO0FBTEEsWUFBQSxXQUFBO0FBT0EsOEJBQWlDLFNBQWU7QUFDL0MsYUFBTyxDQUFDLFFBQWEsYUFBMEIsZUFBbUM7TUFFbEY7SUFDRDtBQUpBLFlBQUEsbUJBQUE7Ozs7Ozs7O0FDMUJBOzs7Ozs7Ozs7Ozs7Ozs7OztBQVFBLFFBQUEsZUFBQTtBQU1BLFFBQXNCLDRCQUF0QixNQUE4QztNQVF0QyxNQUFlLE1BQWU7QUFDcEMsZUFBTyxLQUFLLE9BQU8sSUFBSTtNQUN4QjtNQWtCTyxjQUF1QixNQUFjO0FBQzNDLFlBQUksU0FBaUIsS0FBSyxjQUFhO0FBQ3ZDLFlBQUksSUFBWSxLQUFLO0FBQ3JCLGlCQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSztBQUMzQixjQUFJLENBQUMsS0FBSyxxQkFBcUIsTUFBTSxNQUFNLEdBQUc7QUFDN0M7O0FBR0QsY0FBSSxJQUFlLEtBQUssU0FBUyxDQUFDO0FBQ2xDLGNBQUksY0FBc0IsRUFBRSxPQUFPLElBQUk7QUFDdkMsbUJBQVMsS0FBSyxnQkFBZ0IsUUFBUSxXQUFXOztBQUdsRCxlQUFPO01B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
