/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/format/format.js
var require_format = __commonJS({
  "node_modules/format/format.js"(exports, module2) {
    (function() {
      var namespace;
      if (typeof module2 !== "undefined") {
        namespace = module2.exports = format;
      } else {
        namespace = function() {
          return this || (1, eval)("this");
        }();
      }
      namespace.format = format;
      namespace.vsprintf = vsprintf;
      if (typeof console !== "undefined" && typeof console.log === "function") {
        namespace.printf = printf;
      }
      function printf() {
        console.log(format.apply(null, arguments));
      }
      function vsprintf(fmt, replacements) {
        return format.apply(null, [fmt].concat(replacements));
      }
      function format(fmt) {
        var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
          return args[argIndex++];
        }, slurpNumber = function() {
          var digits = "";
          while (/\d/.test(fmt[i])) {
            digits += fmt[i++];
            c = fmt[i];
          }
          return digits.length > 0 ? parseInt(digits) : null;
        };
        for (; i < n; ++i) {
          c = fmt[i];
          if (escaped) {
            escaped = false;
            if (c == ".") {
              leadingZero = false;
              c = fmt[++i];
            } else if (c == "0" && fmt[i + 1] == ".") {
              leadingZero = true;
              i += 2;
              c = fmt[i];
            } else {
              leadingZero = true;
            }
            precision = slurpNumber();
            switch (c) {
              case "b":
                result += parseInt(nextArg(), 10).toString(2);
                break;
              case "c":
                arg = nextArg();
                if (typeof arg === "string" || arg instanceof String)
                  result += arg;
                else
                  result += String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
                result += parseInt(nextArg(), 10);
                break;
              case "f":
                tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                result += leadingZero ? tmp : tmp.replace(/^0/, "");
                break;
              case "j":
                result += JSON.stringify(nextArg());
                break;
              case "o":
                result += "0" + parseInt(nextArg(), 10).toString(8);
                break;
              case "s":
                result += nextArg();
                break;
              case "x":
                result += "0x" + parseInt(nextArg(), 10).toString(16);
                break;
              case "X":
                result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                break;
              default:
                result += c;
                break;
            }
          } else if (c === "%") {
            escaped = true;
          } else {
            result += c;
          }
        }
        return result;
      }
    })();
  }
});

// node_modules/antlr4ts/ANTLRErrorListener.js
var require_ANTLRErrorListener = __commonJS({
  "node_modules/antlr4ts/ANTLRErrorListener.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/ANTLRErrorStrategy.js
var require_ANTLRErrorStrategy = __commonJS({
  "node_modules/antlr4ts/ANTLRErrorStrategy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/Decorators.js
var require_Decorators = __commonJS({
  "node_modules/antlr4ts/Decorators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SuppressWarnings = exports.Override = exports.Nullable = exports.NotNull = void 0;
    function NotNull(target, propertyKey, propertyDescriptor) {
    }
    exports.NotNull = NotNull;
    function Nullable(target, propertyKey, propertyDescriptor) {
    }
    exports.Nullable = Nullable;
    function Override(target, propertyKey, propertyDescriptor) {
    }
    exports.Override = Override;
    function SuppressWarnings(options) {
      return (target, propertyKey, descriptor) => {
      };
    }
    exports.SuppressWarnings = SuppressWarnings;
  }
});

// node_modules/antlr4ts/IntStream.js
var require_IntStream = __commonJS({
  "node_modules/antlr4ts/IntStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntStream = void 0;
    var IntStream;
    (function(IntStream2) {
      IntStream2.EOF = -1;
      IntStream2.UNKNOWN_SOURCE_NAME = "<unknown>";
    })(IntStream = exports.IntStream || (exports.IntStream = {}));
  }
});

// node_modules/antlr4ts/ANTLRInputStream.js
var require_ANTLRInputStream = __commonJS({
  "node_modules/antlr4ts/ANTLRInputStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ANTLRInputStream = void 0;
    var assert = require("assert");
    var Decorators_1 = require_Decorators();
    var IntStream_1 = require_IntStream();
    var ANTLRInputStream2 = class {
      constructor(input) {
        this.p = 0;
        this.data = input;
        this.n = input.length;
      }
      reset() {
        this.p = 0;
      }
      consume() {
        if (this.p >= this.n) {
          assert(this.LA(1) === IntStream_1.IntStream.EOF);
          throw new Error("cannot consume EOF");
        }
        if (this.p < this.n) {
          this.p++;
        }
      }
      LA(i) {
        if (i === 0) {
          return 0;
        }
        if (i < 0) {
          i++;
          if (this.p + i - 1 < 0) {
            return IntStream_1.IntStream.EOF;
          }
        }
        if (this.p + i - 1 >= this.n) {
          return IntStream_1.IntStream.EOF;
        }
        return this.data.charCodeAt(this.p + i - 1);
      }
      LT(i) {
        return this.LA(i);
      }
      get index() {
        return this.p;
      }
      get size() {
        return this.n;
      }
      mark() {
        return -1;
      }
      release(marker) {
      }
      seek(index2) {
        if (index2 <= this.p) {
          this.p = index2;
          return;
        }
        index2 = Math.min(index2, this.n);
        while (this.p < index2) {
          this.consume();
        }
      }
      getText(interval) {
        let start = interval.a;
        let stop = interval.b;
        if (stop >= this.n) {
          stop = this.n - 1;
        }
        let count = stop - start + 1;
        if (start >= this.n) {
          return "";
        }
        return this.data.substr(start, count);
      }
      get sourceName() {
        if (!this.name) {
          return IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        return this.name;
      }
      toString() {
        return this.data;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "LA", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "getText", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream2.prototype, "toString", null);
    exports.ANTLRInputStream = ANTLRInputStream2;
  }
});

// node_modules/antlr4ts/atn/ATNState.js
var require_ATNState = __commonJS({
  "node_modules/antlr4ts/atn/ATNState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNState = void 0;
    var Decorators_1 = require_Decorators();
    var ATNState = class {
      constructor() {
        this.stateNumber = ATNState.INVALID_STATE_NUMBER;
        this.ruleIndex = 0;
        this.epsilonOnlyTransitions = false;
        this.transitions = [];
        this.optimizedTransitions = this.transitions;
      }
      getStateNumber() {
        return this.stateNumber;
      }
      get nonStopStateNumber() {
        return this.getStateNumber();
      }
      hashCode() {
        return this.stateNumber;
      }
      equals(o) {
        if (o instanceof ATNState) {
          return this.stateNumber === o.stateNumber;
        }
        return false;
      }
      get isNonGreedyExitState() {
        return false;
      }
      toString() {
        return String(this.stateNumber);
      }
      getTransitions() {
        return this.transitions.slice(0);
      }
      get numberOfTransitions() {
        return this.transitions.length;
      }
      addTransition(e, index2) {
        if (this.transitions.length === 0) {
          this.epsilonOnlyTransitions = e.isEpsilon;
        } else if (this.epsilonOnlyTransitions !== e.isEpsilon) {
          this.epsilonOnlyTransitions = false;
          throw new Error("ATN state " + this.stateNumber + " has both epsilon and non-epsilon transitions.");
        }
        this.transitions.splice(index2 !== void 0 ? index2 : this.transitions.length, 0, e);
      }
      transition(i) {
        return this.transitions[i];
      }
      setTransition(i, e) {
        this.transitions[i] = e;
      }
      removeTransition(index2) {
        return this.transitions.splice(index2, 1)[0];
      }
      get onlyHasEpsilonTransitions() {
        return this.epsilonOnlyTransitions;
      }
      setRuleIndex(ruleIndex) {
        this.ruleIndex = ruleIndex;
      }
      get isOptimized() {
        return this.optimizedTransitions !== this.transitions;
      }
      get numberOfOptimizedTransitions() {
        return this.optimizedTransitions.length;
      }
      getOptimizedTransition(i) {
        return this.optimizedTransitions[i];
      }
      addOptimizedTransition(e) {
        if (!this.isOptimized) {
          this.optimizedTransitions = new Array();
        }
        this.optimizedTransitions.push(e);
      }
      setOptimizedTransition(i, e) {
        if (!this.isOptimized) {
          throw new Error("This ATNState is not optimized.");
        }
        this.optimizedTransitions[i] = e;
      }
      removeOptimizedTransition(i) {
        if (!this.isOptimized) {
          throw new Error("This ATNState is not optimized.");
        }
        this.optimizedTransitions.splice(i, 1);
      }
    };
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "toString", null);
    exports.ATNState = ATNState;
    (function(ATNState2) {
      ATNState2.INVALID_STATE_NUMBER = -1;
    })(ATNState = exports.ATNState || (exports.ATNState = {}));
  }
});

// node_modules/antlr4ts/atn/ATNStateType.js
var require_ATNStateType = __commonJS({
  "node_modules/antlr4ts/atn/ATNStateType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNStateType = void 0;
    var ATNStateType;
    (function(ATNStateType2) {
      ATNStateType2[ATNStateType2["INVALID_TYPE"] = 0] = "INVALID_TYPE";
      ATNStateType2[ATNStateType2["BASIC"] = 1] = "BASIC";
      ATNStateType2[ATNStateType2["RULE_START"] = 2] = "RULE_START";
      ATNStateType2[ATNStateType2["BLOCK_START"] = 3] = "BLOCK_START";
      ATNStateType2[ATNStateType2["PLUS_BLOCK_START"] = 4] = "PLUS_BLOCK_START";
      ATNStateType2[ATNStateType2["STAR_BLOCK_START"] = 5] = "STAR_BLOCK_START";
      ATNStateType2[ATNStateType2["TOKEN_START"] = 6] = "TOKEN_START";
      ATNStateType2[ATNStateType2["RULE_STOP"] = 7] = "RULE_STOP";
      ATNStateType2[ATNStateType2["BLOCK_END"] = 8] = "BLOCK_END";
      ATNStateType2[ATNStateType2["STAR_LOOP_BACK"] = 9] = "STAR_LOOP_BACK";
      ATNStateType2[ATNStateType2["STAR_LOOP_ENTRY"] = 10] = "STAR_LOOP_ENTRY";
      ATNStateType2[ATNStateType2["PLUS_LOOP_BACK"] = 11] = "PLUS_LOOP_BACK";
      ATNStateType2[ATNStateType2["LOOP_END"] = 12] = "LOOP_END";
    })(ATNStateType = exports.ATNStateType || (exports.ATNStateType = {}));
  }
});

// node_modules/antlr4ts/RecognitionException.js
var require_RecognitionException = __commonJS({
  "node_modules/antlr4ts/RecognitionException.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecognitionException = void 0;
    var RecognitionException2 = class extends Error {
      constructor(recognizer, input, ctx, message) {
        super(message);
        this._offendingState = -1;
        this._recognizer = recognizer;
        this.input = input;
        this.ctx = ctx;
        if (recognizer) {
          this._offendingState = recognizer.state;
        }
      }
      get offendingState() {
        return this._offendingState;
      }
      setOffendingState(offendingState) {
        this._offendingState = offendingState;
      }
      get expectedTokens() {
        if (this._recognizer) {
          return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);
        }
        return void 0;
      }
      get context() {
        return this.ctx;
      }
      get inputStream() {
        return this.input;
      }
      getOffendingToken(recognizer) {
        if (recognizer && recognizer !== this._recognizer) {
          return void 0;
        }
        return this.offendingToken;
      }
      setOffendingToken(recognizer, offendingToken) {
        if (recognizer === this._recognizer) {
          this.offendingToken = offendingToken;
        }
      }
      get recognizer() {
        return this._recognizer;
      }
    };
    exports.RecognitionException = RecognitionException2;
  }
});

// node_modules/antlr4ts/atn/Transition.js
var require_Transition = __commonJS({
  "node_modules/antlr4ts/atn/Transition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition = class Transition {
      constructor(target) {
        if (target == null) {
          throw new Error("target cannot be null.");
        }
        this.target = target;
      }
      get isEpsilon() {
        return false;
      }
      get label() {
        return void 0;
      }
    };
    Transition.serializationNames = [
      "INVALID",
      "EPSILON",
      "RANGE",
      "RULE",
      "PREDICATE",
      "ATOM",
      "ACTION",
      "SET",
      "NOT_SET",
      "WILDCARD",
      "PRECEDENCE"
    ];
    __decorate([
      Decorators_1.NotNull
    ], Transition.prototype, "target", void 0);
    Transition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], Transition);
    exports.Transition = Transition;
  }
});

// node_modules/antlr4ts/atn/AbstractPredicateTransition.js
var require_AbstractPredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/AbstractPredicateTransition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractPredicateTransition = void 0;
    var Transition_1 = require_Transition();
    var AbstractPredicateTransition = class extends Transition_1.Transition {
      constructor(target) {
        super(target);
      }
    };
    exports.AbstractPredicateTransition = AbstractPredicateTransition;
  }
});

// node_modules/antlr4ts/misc/MurmurHash.js
var require_MurmurHash = __commonJS({
  "node_modules/antlr4ts/misc/MurmurHash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MurmurHash = void 0;
    var MurmurHash;
    (function(MurmurHash2) {
      const DEFAULT_SEED = 0;
      function initialize(seed = DEFAULT_SEED) {
        return seed;
      }
      MurmurHash2.initialize = initialize;
      function update(hash, value2) {
        const c1 = 3432918353;
        const c2 = 461845907;
        const r1 = 15;
        const r2 = 13;
        const m = 5;
        const n = 3864292196;
        if (value2 == null) {
          value2 = 0;
        } else if (typeof value2 === "string") {
          value2 = hashString(value2);
        } else if (typeof value2 === "object") {
          value2 = value2.hashCode();
        }
        let k = value2;
        k = Math.imul(k, c1);
        k = k << r1 | k >>> 32 - r1;
        k = Math.imul(k, c2);
        hash = hash ^ k;
        hash = hash << r2 | hash >>> 32 - r2;
        hash = Math.imul(hash, m) + n;
        return hash & 4294967295;
      }
      MurmurHash2.update = update;
      function finish(hash, numberOfWords) {
        hash = hash ^ numberOfWords * 4;
        hash = hash ^ hash >>> 16;
        hash = Math.imul(hash, 2246822507);
        hash = hash ^ hash >>> 13;
        hash = Math.imul(hash, 3266489909);
        hash = hash ^ hash >>> 16;
        return hash;
      }
      MurmurHash2.finish = finish;
      function hashCode(data, seed = DEFAULT_SEED) {
        let hash = initialize(seed);
        let length = 0;
        for (let value2 of data) {
          hash = update(hash, value2);
          length++;
        }
        hash = finish(hash, length);
        return hash;
      }
      MurmurHash2.hashCode = hashCode;
      function hashString(str) {
        let len = str.length;
        if (len === 0) {
          return 0;
        }
        let hash = 0;
        for (let i = 0; i < len; i++) {
          let c = str.charCodeAt(i);
          hash = (hash << 5 >>> 0) - hash + c;
          hash |= 0;
        }
        return hash;
      }
    })(MurmurHash = exports.MurmurHash || (exports.MurmurHash = {}));
  }
});

// node_modules/antlr4ts/misc/ObjectEqualityComparator.js
var require_ObjectEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/ObjectEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator = class {
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return obj.hashCode();
      }
      equals(a, b) {
        if (a == null) {
          return b == null;
        }
        return a.equals(b);
      }
    };
    ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], ObjectEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ObjectEqualityComparator.prototype, "equals", null);
    exports.ObjectEqualityComparator = ObjectEqualityComparator;
  }
});

// node_modules/antlr4ts/misc/DefaultEqualityComparator.js
var require_DefaultEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/DefaultEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var DefaultEqualityComparator = class {
      hashCode(obj) {
        if (obj == null) {
          return 0;
        } else if (typeof obj === "string" || typeof obj === "number") {
          return MurmurHash_1.MurmurHash.hashCode([obj]);
        } else {
          return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.hashCode(obj);
        }
      }
      equals(a, b) {
        if (a == null) {
          return b == null;
        } else if (typeof a === "string" || typeof a === "number") {
          return a === b;
        } else {
          return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a, b);
        }
      }
    };
    DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], DefaultEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], DefaultEqualityComparator.prototype, "equals", null);
    exports.DefaultEqualityComparator = DefaultEqualityComparator;
  }
});

// node_modules/antlr4ts/misc/Array2DHashSet.js
var require_Array2DHashSet = __commonJS({
  "node_modules/antlr4ts/misc/Array2DHashSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Array2DHashSet = void 0;
    var assert = require("assert");
    var DefaultEqualityComparator_1 = require_DefaultEqualityComparator();
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var INITAL_CAPACITY = 16;
    var LOAD_FACTOR = 0.75;
    var Array2DHashSet = class {
      constructor(comparatorOrSet, initialCapacity = INITAL_CAPACITY) {
        this.n = 0;
        this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
        if (comparatorOrSet instanceof Array2DHashSet) {
          this.comparator = comparatorOrSet.comparator;
          this.buckets = comparatorOrSet.buckets.slice(0);
          for (let i = 0; i < this.buckets.length; i++) {
            let bucket = this.buckets[i];
            if (bucket) {
              this.buckets[i] = bucket.slice(0);
            }
          }
          this.n = comparatorOrSet.n;
          this.threshold = comparatorOrSet.threshold;
        } else {
          this.comparator = comparatorOrSet || DefaultEqualityComparator_1.DefaultEqualityComparator.INSTANCE;
          this.buckets = this.createBuckets(initialCapacity);
        }
      }
      getOrAdd(o) {
        if (this.n > this.threshold) {
          this.expand();
        }
        return this.getOrAddImpl(o);
      }
      getOrAddImpl(o) {
        let b = this.getBucket(o);
        let bucket = this.buckets[b];
        if (!bucket) {
          bucket = [o];
          this.buckets[b] = bucket;
          this.n++;
          return o;
        }
        for (let existing of bucket) {
          if (this.comparator.equals(existing, o)) {
            return existing;
          }
        }
        bucket.push(o);
        this.n++;
        return o;
      }
      get(o) {
        if (o == null) {
          return o;
        }
        let b = this.getBucket(o);
        let bucket = this.buckets[b];
        if (!bucket) {
          return void 0;
        }
        for (let e of bucket) {
          if (this.comparator.equals(e, o)) {
            return e;
          }
        }
        return void 0;
      }
      getBucket(o) {
        let hash = this.comparator.hashCode(o);
        let b = hash & this.buckets.length - 1;
        return b;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            hash = MurmurHash_1.MurmurHash.update(hash, this.comparator.hashCode(o));
          }
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, this.size);
        return hash;
      }
      equals(o) {
        if (o === this) {
          return true;
        }
        if (!(o instanceof Array2DHashSet)) {
          return false;
        }
        if (o.size !== this.size) {
          return false;
        }
        let same = this.containsAll(o);
        return same;
      }
      expand() {
        let old = this.buckets;
        let newCapacity = this.buckets.length * 2;
        let newTable = this.createBuckets(newCapacity);
        this.buckets = newTable;
        this.threshold = Math.floor(newCapacity * LOAD_FACTOR);
        let oldSize = this.size;
        for (let bucket of old) {
          if (!bucket) {
            continue;
          }
          for (let o of bucket) {
            let b = this.getBucket(o);
            let newBucket = this.buckets[b];
            if (!newBucket) {
              newBucket = [];
              this.buckets[b] = newBucket;
            }
            newBucket.push(o);
          }
        }
        assert(this.n === oldSize);
      }
      add(t) {
        let existing = this.getOrAdd(t);
        return existing === t;
      }
      get size() {
        return this.n;
      }
      get isEmpty() {
        return this.n === 0;
      }
      contains(o) {
        return this.containsFast(this.asElementType(o));
      }
      containsFast(obj) {
        if (obj == null) {
          return false;
        }
        return this.get(obj) != null;
      }
      *[Symbol.iterator]() {
        yield* this.toArray();
      }
      toArray() {
        const a = new Array(this.size);
        let i = 0;
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            a[i++] = o;
          }
        }
        return a;
      }
      containsAll(collection) {
        if (collection instanceof Array2DHashSet) {
          let s = collection;
          for (let bucket of s.buckets) {
            if (bucket == null) {
              continue;
            }
            for (let o of bucket) {
              if (o == null) {
                break;
              }
              if (!this.containsFast(this.asElementType(o))) {
                return false;
              }
            }
          }
        } else {
          for (let o of collection) {
            if (!this.containsFast(this.asElementType(o))) {
              return false;
            }
          }
        }
        return true;
      }
      addAll(c) {
        let changed = false;
        for (let o of c) {
          let existing = this.getOrAdd(o);
          if (existing !== o) {
            changed = true;
          }
        }
        return changed;
      }
      clear() {
        this.buckets = this.createBuckets(INITAL_CAPACITY);
        this.n = 0;
        this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
      }
      toString() {
        if (this.size === 0) {
          return "{}";
        }
        let buf = "{";
        let first = true;
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            buf += o.toString();
          }
        }
        buf += "}";
        return buf;
      }
      toTableString() {
        let buf = "";
        for (let bucket of this.buckets) {
          if (bucket == null) {
            buf += "null\n";
            continue;
          }
          buf += "[";
          let first = true;
          for (let o of bucket) {
            if (first) {
              first = false;
            } else {
              buf += " ";
            }
            if (o == null) {
              buf += "_";
            } else {
              buf += o.toString();
            }
          }
          buf += "]\n";
        }
        return buf;
      }
      asElementType(o) {
        return o;
      }
      createBuckets(capacity) {
        return new Array(capacity);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], Array2DHashSet.prototype, "comparator", void 0);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "add", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "contains", null);
    __decorate([
      __param(0, Decorators_1.Nullable)
    ], Array2DHashSet.prototype, "containsFast", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, Symbol.iterator, null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "toArray", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "containsAll", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "addAll", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "clear", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "toString", null);
    __decorate([
      Decorators_1.SuppressWarnings("unchecked")
    ], Array2DHashSet.prototype, "asElementType", null);
    __decorate([
      Decorators_1.SuppressWarnings("unchecked")
    ], Array2DHashSet.prototype, "createBuckets", null);
    exports.Array2DHashSet = Array2DHashSet;
  }
});

// node_modules/antlr4ts/misc/ArrayEqualityComparator.js
var require_ArrayEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/ArrayEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var ArrayEqualityComparator = class {
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return MurmurHash_1.MurmurHash.hashCode(obj, 0);
      }
      equals(a, b) {
        if (a == null) {
          return b == null;
        } else if (b == null) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; i++) {
          if (!ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
    };
    ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], ArrayEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ArrayEqualityComparator.prototype, "equals", null);
    exports.ArrayEqualityComparator = ArrayEqualityComparator;
  }
});

// node_modules/antlr4ts/misc/Utils.js
var require_Utils = __commonJS({
  "node_modules/antlr4ts/misc/Utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toCharArray = exports.toMap = exports.equals = exports.join = exports.escapeWhitespace = void 0;
    function escapeWhitespace(s, escapeSpaces) {
      return escapeSpaces ? s.replace(/ /, "\xB7") : s.replace(/\t/, "\\t").replace(/\n/, "\\n").replace(/\r/, "\\r");
    }
    exports.escapeWhitespace = escapeWhitespace;
    function join(collection, separator) {
      let buf = "";
      let first = true;
      for (let current of collection) {
        if (first) {
          first = false;
        } else {
          buf += separator;
        }
        buf += current;
      }
      return buf;
    }
    exports.join = join;
    function equals(x, y) {
      if (x === y) {
        return true;
      }
      if (x === void 0 || y === void 0) {
        return false;
      }
      return x.equals(y);
    }
    exports.equals = equals;
    function toMap(keys) {
      let m = /* @__PURE__ */ new Map();
      for (let i = 0; i < keys.length; i++) {
        m.set(keys[i], i);
      }
      return m;
    }
    exports.toMap = toMap;
    function toCharArray3(str) {
      if (typeof str === "string") {
        let result = new Uint16Array(str.length);
        for (let i = 0; i < str.length; i++) {
          result[i] = str.charCodeAt(i);
        }
        return result;
      } else {
        return str.toCharArray();
      }
    }
    exports.toCharArray = toCharArray3;
  }
});

// node_modules/antlr4ts/atn/SemanticContext.js
var require_SemanticContext = __commonJS({
  "node_modules/antlr4ts/atn/SemanticContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticContext = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var Utils3 = require_Utils();
    function max(items) {
      let result;
      for (let current of items) {
        if (result === void 0) {
          result = current;
          continue;
        }
        let comparison = result.compareTo(current);
        if (comparison < 0) {
          result = current;
        }
      }
      return result;
    }
    function min(items) {
      let result;
      for (let current of items) {
        if (result === void 0) {
          result = current;
          continue;
        }
        let comparison = result.compareTo(current);
        if (comparison > 0) {
          result = current;
        }
      }
      return result;
    }
    var SemanticContext = class {
      static get NONE() {
        if (SemanticContext._NONE === void 0) {
          SemanticContext._NONE = new SemanticContext.Predicate();
        }
        return SemanticContext._NONE;
      }
      evalPrecedence(parser, parserCallStack) {
        return this;
      }
      static and(a, b) {
        if (!a || a === SemanticContext.NONE) {
          return b;
        }
        if (b === SemanticContext.NONE) {
          return a;
        }
        let result = new SemanticContext.AND(a, b);
        if (result.opnds.length === 1) {
          return result.opnds[0];
        }
        return result;
      }
      static or(a, b) {
        if (!a) {
          return b;
        }
        if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
          return SemanticContext.NONE;
        }
        let result = new SemanticContext.OR(a, b);
        if (result.opnds.length === 1) {
          return result.opnds[0];
        }
        return result;
      }
    };
    exports.SemanticContext = SemanticContext;
    (function(SemanticContext2) {
      const AND_HASHCODE = 40363613;
      const OR_HASHCODE = 486279973;
      function filterPrecedencePredicates(collection) {
        let result = [];
        for (let i = 0; i < collection.length; i++) {
          let context = collection[i];
          if (context instanceof SemanticContext2.PrecedencePredicate) {
            result.push(context);
            collection.splice(i, 1);
            i--;
          }
        }
        return result;
      }
      class Predicate extends SemanticContext2 {
        constructor(ruleIndex = -1, predIndex = -1, isCtxDependent = false) {
          super();
          this.ruleIndex = ruleIndex;
          this.predIndex = predIndex;
          this.isCtxDependent = isCtxDependent;
        }
        eval(parser, parserCallStack) {
          let localctx = this.isCtxDependent ? parserCallStack : void 0;
          return parser.sempred(localctx, this.ruleIndex, this.predIndex);
        }
        hashCode() {
          let hashCode = MurmurHash_1.MurmurHash.initialize();
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);
          return hashCode;
        }
        equals(obj) {
          if (!(obj instanceof Predicate)) {
            return false;
          }
          if (this === obj) {
            return true;
          }
          return this.ruleIndex === obj.ruleIndex && this.predIndex === obj.predIndex && this.isCtxDependent === obj.isCtxDependent;
        }
        toString() {
          return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
        }
      }
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "toString", null);
      SemanticContext2.Predicate = Predicate;
      class PrecedencePredicate extends SemanticContext2 {
        constructor(precedence) {
          super();
          this.precedence = precedence;
        }
        eval(parser, parserCallStack) {
          return parser.precpred(parserCallStack, this.precedence);
        }
        evalPrecedence(parser, parserCallStack) {
          if (parser.precpred(parserCallStack, this.precedence)) {
            return SemanticContext2.NONE;
          } else {
            return void 0;
          }
        }
        compareTo(o) {
          return this.precedence - o.precedence;
        }
        hashCode() {
          let hashCode = 1;
          hashCode = 31 * hashCode + this.precedence;
          return hashCode;
        }
        equals(obj) {
          if (!(obj instanceof PrecedencePredicate)) {
            return false;
          }
          if (this === obj) {
            return true;
          }
          return this.precedence === obj.precedence;
        }
        toString() {
          return "{" + this.precedence + ">=prec}?";
        }
      }
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "compareTo", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "toString", null);
      SemanticContext2.PrecedencePredicate = PrecedencePredicate;
      class Operator extends SemanticContext2 {
      }
      SemanticContext2.Operator = Operator;
      let AND = class AND2 extends Operator {
        constructor(a, b) {
          super();
          let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          if (a instanceof AND2) {
            operands.addAll(a.opnds);
          } else {
            operands.add(a);
          }
          if (b instanceof AND2) {
            operands.addAll(b.opnds);
          } else {
            operands.add(b);
          }
          this.opnds = operands.toArray();
          let precedencePredicates = filterPrecedencePredicates(this.opnds);
          let reduced = min(precedencePredicates);
          if (reduced) {
            this.opnds.push(reduced);
          }
        }
        get operands() {
          return this.opnds;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof AND2)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);
        }
        eval(parser, parserCallStack) {
          for (let opnd of this.opnds) {
            if (!opnd.eval(parser, parserCallStack)) {
              return false;
            }
          }
          return true;
        }
        evalPrecedence(parser, parserCallStack) {
          let differs = false;
          let operands = [];
          for (let context of this.opnds) {
            let evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated == null) {
              return void 0;
            } else if (evaluated !== SemanticContext2.NONE) {
              operands.push(evaluated);
            }
          }
          if (!differs) {
            return this;
          }
          if (operands.length === 0) {
            return SemanticContext2.NONE;
          }
          let result = operands[0];
          for (let i = 1; i < operands.length; i++) {
            result = SemanticContext2.and(result, operands[i]);
          }
          return result;
        }
        toString() {
          return Utils3.join(this.opnds, "&&");
        }
      };
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "operands", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "toString", null);
      AND = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], AND);
      SemanticContext2.AND = AND;
      let OR = class OR2 extends Operator {
        constructor(a, b) {
          super();
          let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          if (a instanceof OR2) {
            operands.addAll(a.opnds);
          } else {
            operands.add(a);
          }
          if (b instanceof OR2) {
            operands.addAll(b.opnds);
          } else {
            operands.add(b);
          }
          this.opnds = operands.toArray();
          let precedencePredicates = filterPrecedencePredicates(this.opnds);
          let reduced = max(precedencePredicates);
          if (reduced) {
            this.opnds.push(reduced);
          }
        }
        get operands() {
          return this.opnds;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof OR2)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);
        }
        eval(parser, parserCallStack) {
          for (let opnd of this.opnds) {
            if (opnd.eval(parser, parserCallStack)) {
              return true;
            }
          }
          return false;
        }
        evalPrecedence(parser, parserCallStack) {
          let differs = false;
          let operands = [];
          for (let context of this.opnds) {
            let evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated === SemanticContext2.NONE) {
              return SemanticContext2.NONE;
            } else if (evaluated) {
              operands.push(evaluated);
            }
          }
          if (!differs) {
            return this;
          }
          if (operands.length === 0) {
            return void 0;
          }
          let result = operands[0];
          for (let i = 1; i < operands.length; i++) {
            result = SemanticContext2.or(result, operands[i]);
          }
          return result;
        }
        toString() {
          return Utils3.join(this.opnds, "||");
        }
      };
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "operands", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "toString", null);
      OR = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], OR);
      SemanticContext2.OR = OR;
    })(SemanticContext = exports.SemanticContext || (exports.SemanticContext = {}));
  }
});

// node_modules/antlr4ts/atn/PredicateTransition.js
var require_PredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/PredicateTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredicateTransition = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Decorators_1 = require_Decorators();
    var SemanticContext_1 = require_SemanticContext();
    var PredicateTransition = class PredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
      constructor(target, ruleIndex, predIndex, isCtxDependent) {
        super(target);
        this.ruleIndex = ruleIndex;
        this.predIndex = predIndex;
        this.isCtxDependent = isCtxDependent;
      }
      get serializationType() {
        return 4;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      get predicate() {
        return new SemanticContext_1.SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
      }
      toString() {
        return "pred_" + this.ruleIndex + ":" + this.predIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], PredicateTransition.prototype, "toString", null);
    PredicateTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], PredicateTransition);
    exports.PredicateTransition = PredicateTransition;
  }
});

// node_modules/antlr4ts/FailedPredicateException.js
var require_FailedPredicateException = __commonJS({
  "node_modules/antlr4ts/FailedPredicateException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FailedPredicateException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var PredicateTransition_1 = require_PredicateTransition();
    var FailedPredicateException2 = class FailedPredicateException3 extends RecognitionException_1.RecognitionException {
      constructor(recognizer, predicate, message) {
        super(recognizer, recognizer.inputStream, recognizer.context, FailedPredicateException3.formatMessage(predicate, message));
        let s = recognizer.interpreter.atn.states[recognizer.state];
        let trans = s.transition(0);
        if (trans instanceof PredicateTransition_1.PredicateTransition) {
          this._ruleIndex = trans.ruleIndex;
          this._predicateIndex = trans.predIndex;
        } else {
          this._ruleIndex = 0;
          this._predicateIndex = 0;
        }
        this._predicate = predicate;
        super.setOffendingToken(recognizer, recognizer.currentToken);
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
      get predicateIndex() {
        return this._predicateIndex;
      }
      get predicate() {
        return this._predicate;
      }
      static formatMessage(predicate, message) {
        if (message) {
          return message;
        }
        return `failed predicate: {${predicate}}?`;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], FailedPredicateException2, "formatMessage", null);
    FailedPredicateException2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], FailedPredicateException2);
    exports.FailedPredicateException = FailedPredicateException2;
  }
});

// node_modules/antlr4ts/InputMismatchException.js
var require_InputMismatchException = __commonJS({
  "node_modules/antlr4ts/InputMismatchException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputMismatchException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var InputMismatchException = class InputMismatchException extends RecognitionException_1.RecognitionException {
      constructor(recognizer, state, context) {
        if (context === void 0) {
          context = recognizer.context;
        }
        super(recognizer, recognizer.inputStream, context);
        if (state !== void 0) {
          this.setOffendingState(state);
        }
        this.setOffendingToken(recognizer, recognizer.currentToken);
      }
    };
    InputMismatchException = __decorate([
      __param(0, Decorators_1.NotNull)
    ], InputMismatchException);
    exports.InputMismatchException = InputMismatchException;
  }
});

// node_modules/antlr4ts/misc/Arrays.js
var require_Arrays = __commonJS({
  "node_modules/antlr4ts/misc/Arrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Arrays = void 0;
    var Arrays;
    (function(Arrays2) {
      function binarySearch(array, key, fromIndex, toIndex) {
        return binarySearch0(array, fromIndex !== void 0 ? fromIndex : 0, toIndex !== void 0 ? toIndex : array.length, key);
      }
      Arrays2.binarySearch = binarySearch;
      function binarySearch0(array, fromIndex, toIndex, key) {
        let low = fromIndex;
        let high = toIndex - 1;
        while (low <= high) {
          let mid = low + high >>> 1;
          let midVal = array[mid];
          if (midVal < key) {
            low = mid + 1;
          } else if (midVal > key) {
            high = mid - 1;
          } else {
            return mid;
          }
        }
        return -(low + 1);
      }
      function toString2(array) {
        let result = "[";
        let first = true;
        for (let element2 of array) {
          if (first) {
            first = false;
          } else {
            result += ", ";
          }
          if (element2 === null) {
            result += "null";
          } else if (element2 === void 0) {
            result += "undefined";
          } else {
            result += element2;
          }
        }
        result += "]";
        return result;
      }
      Arrays2.toString = toString2;
    })(Arrays = exports.Arrays || (exports.Arrays = {}));
  }
});

// node_modules/antlr4ts/misc/IntegerList.js
var require_IntegerList = __commonJS({
  "node_modules/antlr4ts/misc/IntegerList.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntegerList = void 0;
    var Arrays_1 = require_Arrays();
    var Decorators_1 = require_Decorators();
    var EMPTY_DATA = new Int32Array(0);
    var INITIAL_SIZE = 4;
    var MAX_ARRAY_SIZE = (1 << 31 >>> 0) - 1 - 8;
    var IntegerList = class {
      constructor(arg) {
        if (!arg) {
          this._data = EMPTY_DATA;
          this._size = 0;
        } else if (arg instanceof IntegerList) {
          this._data = arg._data.slice(0);
          this._size = arg._size;
        } else if (typeof arg === "number") {
          if (arg === 0) {
            this._data = EMPTY_DATA;
            this._size = 0;
          } else {
            this._data = new Int32Array(arg);
            this._size = 0;
          }
        } else {
          this._data = EMPTY_DATA;
          this._size = 0;
          for (let value2 of arg) {
            this.add(value2);
          }
        }
      }
      add(value2) {
        if (this._data.length === this._size) {
          this.ensureCapacity(this._size + 1);
        }
        this._data[this._size] = value2;
        this._size++;
      }
      addAll(list2) {
        if (Array.isArray(list2)) {
          this.ensureCapacity(this._size + list2.length);
          this._data.subarray(this._size, this._size + list2.length).set(list2);
          this._size += list2.length;
        } else if (list2 instanceof IntegerList) {
          this.ensureCapacity(this._size + list2._size);
          this._data.subarray(this._size, this._size + list2.size).set(list2._data);
          this._size += list2._size;
        } else {
          this.ensureCapacity(this._size + list2.size);
          let current = 0;
          for (let xi of list2) {
            this._data[this._size + current] = xi;
            current++;
          }
          this._size += list2.size;
        }
      }
      get(index2) {
        if (index2 < 0 || index2 >= this._size) {
          throw RangeError();
        }
        return this._data[index2];
      }
      contains(value2) {
        for (let i = 0; i < this._size; i++) {
          if (this._data[i] === value2) {
            return true;
          }
        }
        return false;
      }
      set(index2, value2) {
        if (index2 < 0 || index2 >= this._size) {
          throw RangeError();
        }
        let previous4 = this._data[index2];
        this._data[index2] = value2;
        return previous4;
      }
      removeAt(index2) {
        let value2 = this.get(index2);
        this._data.copyWithin(index2, index2 + 1, this._size);
        this._data[this._size - 1] = 0;
        this._size--;
        return value2;
      }
      removeRange(fromIndex, toIndex) {
        if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
          throw RangeError();
        }
        if (fromIndex > toIndex) {
          throw RangeError();
        }
        this._data.copyWithin(toIndex, fromIndex, this._size);
        this._data.fill(0, this._size - (toIndex - fromIndex), this._size);
        this._size -= toIndex - fromIndex;
      }
      get isEmpty() {
        return this._size === 0;
      }
      get size() {
        return this._size;
      }
      trimToSize() {
        if (this._data.length === this._size) {
          return;
        }
        this._data = this._data.slice(0, this._size);
      }
      clear() {
        this._data.fill(0, 0, this._size);
        this._size = 0;
      }
      toArray() {
        if (this._size === 0) {
          return [];
        }
        return Array.from(this._data.subarray(0, this._size));
      }
      sort() {
        this._data.subarray(0, this._size).sort();
      }
      equals(o) {
        if (o === this) {
          return true;
        }
        if (!(o instanceof IntegerList)) {
          return false;
        }
        if (this._size !== o._size) {
          return false;
        }
        for (let i = 0; i < this._size; i++) {
          if (this._data[i] !== o._data[i]) {
            return false;
          }
        }
        return true;
      }
      hashCode() {
        let hashCode = 1;
        for (let i = 0; i < this._size; i++) {
          hashCode = 31 * hashCode + this._data[i];
        }
        return hashCode;
      }
      toString() {
        return this._data.toString();
      }
      binarySearch(key, fromIndex, toIndex) {
        if (fromIndex === void 0) {
          fromIndex = 0;
        }
        if (toIndex === void 0) {
          toIndex = this._size;
        }
        if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
          throw new RangeError();
        }
        if (fromIndex > toIndex) {
          throw new RangeError();
        }
        return Arrays_1.Arrays.binarySearch(this._data, key, fromIndex, toIndex);
      }
      ensureCapacity(capacity) {
        if (capacity < 0 || capacity > MAX_ARRAY_SIZE) {
          throw new RangeError();
        }
        let newLength;
        if (this._data.length === 0) {
          newLength = INITIAL_SIZE;
        } else {
          newLength = this._data.length;
        }
        while (newLength < capacity) {
          newLength = newLength * 2;
          if (newLength < 0 || newLength > MAX_ARRAY_SIZE) {
            newLength = MAX_ARRAY_SIZE;
          }
        }
        let tmp = new Int32Array(newLength);
        tmp.set(this._data);
        this._data = tmp;
      }
      toCharArray() {
        let resultArray = new Uint16Array(this._size);
        let resultIdx = 0;
        let calculatedPreciseResultSize = false;
        for (let i = 0; i < this._size; i++) {
          let codePoint = this._data[i];
          if (codePoint >= 0 && codePoint < 65536) {
            resultArray[resultIdx] = codePoint;
            resultIdx++;
            continue;
          }
          if (!calculatedPreciseResultSize) {
            let newResultArray = new Uint16Array(this.charArraySize());
            newResultArray.set(resultArray, 0);
            resultArray = newResultArray;
            calculatedPreciseResultSize = true;
          }
          let pair = String.fromCodePoint(codePoint);
          resultArray[resultIdx] = pair.charCodeAt(0);
          resultArray[resultIdx + 1] = pair.charCodeAt(1);
          resultIdx += 2;
        }
        return resultArray;
      }
      charArraySize() {
        let result = 0;
        for (let i = 0; i < this._size; i++) {
          result += this._data[i] >= 65536 ? 2 : 1;
        }
        return result;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], IntegerList.prototype, "_data", void 0);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "toString", null);
    exports.IntegerList = IntegerList;
  }
});

// node_modules/antlr4ts/misc/Interval.js
var require_Interval = __commonJS({
  "node_modules/antlr4ts/misc/Interval.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Interval = void 0;
    var Decorators_1 = require_Decorators();
    var INTERVAL_POOL_MAX_VALUE = 1e3;
    var Interval = class {
      constructor(a, b) {
        this.a = a;
        this.b = b;
      }
      static get INVALID() {
        return Interval._INVALID;
      }
      static of(a, b) {
        if (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {
          return new Interval(a, b);
        }
        if (Interval.cache[a] == null) {
          Interval.cache[a] = new Interval(a, a);
        }
        return Interval.cache[a];
      }
      get length() {
        if (this.b < this.a) {
          return 0;
        }
        return this.b - this.a + 1;
      }
      equals(o) {
        if (o === this) {
          return true;
        } else if (!(o instanceof Interval)) {
          return false;
        }
        return this.a === o.a && this.b === o.b;
      }
      hashCode() {
        let hash = 23;
        hash = hash * 31 + this.a;
        hash = hash * 31 + this.b;
        return hash;
      }
      startsBeforeDisjoint(other) {
        return this.a < other.a && this.b < other.a;
      }
      startsBeforeNonDisjoint(other) {
        return this.a <= other.a && this.b >= other.a;
      }
      startsAfter(other) {
        return this.a > other.a;
      }
      startsAfterDisjoint(other) {
        return this.a > other.b;
      }
      startsAfterNonDisjoint(other) {
        return this.a > other.a && this.a <= other.b;
      }
      disjoint(other) {
        return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
      }
      adjacent(other) {
        return this.a === other.b + 1 || this.b === other.a - 1;
      }
      properlyContains(other) {
        return other.a >= this.a && other.b <= this.b;
      }
      union(other) {
        return Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));
      }
      intersection(other) {
        return Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));
      }
      differenceNotProperlyContained(other) {
        let diff;
        if (other.startsBeforeNonDisjoint(this)) {
          diff = Interval.of(Math.max(this.a, other.b + 1), this.b);
        } else if (other.startsAfterNonDisjoint(this)) {
          diff = Interval.of(this.a, other.a - 1);
        }
        return diff;
      }
      toString() {
        return this.a + ".." + this.b;
      }
    };
    Interval._INVALID = new Interval(-1, -2);
    Interval.cache = new Array(INTERVAL_POOL_MAX_VALUE + 1);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "toString", null);
    exports.Interval = Interval;
  }
});

// node_modules/antlr4ts/Token.js
var require_Token = __commonJS({
  "node_modules/antlr4ts/Token.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Token = void 0;
    var IntStream_1 = require_IntStream();
    var Token2;
    (function(Token3) {
      Token3.INVALID_TYPE = 0;
      Token3.EPSILON = -2;
      Token3.MIN_USER_TOKEN_TYPE = 1;
      Token3.EOF = IntStream_1.IntStream.EOF;
      Token3.DEFAULT_CHANNEL = 0;
      Token3.HIDDEN_CHANNEL = 1;
      Token3.MIN_USER_CHANNEL_VALUE = 2;
    })(Token2 = exports.Token || (exports.Token = {}));
  }
});

// node_modules/antlr4ts/CommonToken.js
var require_CommonToken = __commonJS({
  "node_modules/antlr4ts/CommonToken.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonToken = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var CommonToken = class CommonToken2 {
      constructor(type, text4, source = CommonToken2.EMPTY_SOURCE, channel = Token_1.Token.DEFAULT_CHANNEL, start = 0, stop = 0) {
        this._line = 0;
        this._charPositionInLine = -1;
        this._channel = Token_1.Token.DEFAULT_CHANNEL;
        this.index = -1;
        this._text = text4;
        this._type = type;
        this.source = source;
        this._channel = channel;
        this.start = start;
        this.stop = stop;
        if (source.source != null) {
          this._line = source.source.line;
          this._charPositionInLine = source.source.charPositionInLine;
        }
      }
      static fromToken(oldToken) {
        let result = new CommonToken2(oldToken.type, void 0, CommonToken2.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);
        result._line = oldToken.line;
        result.index = oldToken.tokenIndex;
        result._charPositionInLine = oldToken.charPositionInLine;
        if (oldToken instanceof CommonToken2) {
          result._text = oldToken._text;
          result.source = oldToken.source;
        } else {
          result._text = oldToken.text;
          result.source = { source: oldToken.tokenSource, stream: oldToken.inputStream };
        }
        return result;
      }
      get type() {
        return this._type;
      }
      set type(type) {
        this._type = type;
      }
      get line() {
        return this._line;
      }
      set line(line) {
        this._line = line;
      }
      get text() {
        if (this._text != null) {
          return this._text;
        }
        let input = this.inputStream;
        if (input == null) {
          return void 0;
        }
        let n = input.size;
        if (this.start < n && this.stop < n) {
          return input.getText(Interval_1.Interval.of(this.start, this.stop));
        } else {
          return "<EOF>";
        }
      }
      set text(text4) {
        this._text = text4;
      }
      get charPositionInLine() {
        return this._charPositionInLine;
      }
      set charPositionInLine(charPositionInLine) {
        this._charPositionInLine = charPositionInLine;
      }
      get channel() {
        return this._channel;
      }
      set channel(channel) {
        this._channel = channel;
      }
      get startIndex() {
        return this.start;
      }
      set startIndex(start) {
        this.start = start;
      }
      get stopIndex() {
        return this.stop;
      }
      set stopIndex(stop) {
        this.stop = stop;
      }
      get tokenIndex() {
        return this.index;
      }
      set tokenIndex(index2) {
        this.index = index2;
      }
      get tokenSource() {
        return this.source.source;
      }
      get inputStream() {
        return this.source.stream;
      }
      toString(recognizer) {
        let channelStr = "";
        if (this._channel > 0) {
          channelStr = ",channel=" + this._channel;
        }
        let txt = this.text;
        if (txt != null) {
          txt = txt.replace(/\n/g, "\\n");
          txt = txt.replace(/\r/g, "\\r");
          txt = txt.replace(/\t/g, "\\t");
        } else {
          txt = "<no text>";
        }
        let typeString = String(this._type);
        if (recognizer) {
          typeString = recognizer.vocabulary.getDisplayName(this._type);
        }
        return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + typeString + ">" + channelStr + "," + this._line + ":" + this.charPositionInLine + "]";
      }
    };
    CommonToken.EMPTY_SOURCE = { source: void 0, stream: void 0 };
    __decorate([
      Decorators_1.NotNull
    ], CommonToken.prototype, "source", void 0);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "type", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "channel", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "startIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "stopIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "tokenIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "toString", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], CommonToken, "fromToken", null);
    CommonToken = __decorate([
      __param(2, Decorators_1.NotNull)
    ], CommonToken);
    exports.CommonToken = CommonToken;
  }
});

// node_modules/antlr4ts/CommonTokenFactory.js
var require_CommonTokenFactory = __commonJS({
  "node_modules/antlr4ts/CommonTokenFactory.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonTokenFactory = void 0;
    var CommonToken_1 = require_CommonToken();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var CommonTokenFactory = class {
      constructor(copyText = false) {
        this.copyText = copyText;
      }
      create(source, type, text4, channel, start, stop, line, charPositionInLine) {
        let t = new CommonToken_1.CommonToken(type, text4, source, channel, start, stop);
        t.line = line;
        t.charPositionInLine = charPositionInLine;
        if (text4 == null && this.copyText && source.stream != null) {
          t.text = source.stream.getText(Interval_1.Interval.of(start, stop));
        }
        return t;
      }
      createSimple(type, text4) {
        return new CommonToken_1.CommonToken(type, text4);
      }
    };
    __decorate([
      Decorators_1.Override
    ], CommonTokenFactory.prototype, "create", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenFactory.prototype, "createSimple", null);
    exports.CommonTokenFactory = CommonTokenFactory;
    (function(CommonTokenFactory2) {
      CommonTokenFactory2.DEFAULT = new CommonTokenFactory2();
    })(CommonTokenFactory = exports.CommonTokenFactory || (exports.CommonTokenFactory = {}));
  }
});

// node_modules/antlr4ts/misc/IntegerStack.js
var require_IntegerStack = __commonJS({
  "node_modules/antlr4ts/misc/IntegerStack.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntegerStack = void 0;
    var IntegerList_1 = require_IntegerList();
    var IntegerStack = class extends IntegerList_1.IntegerList {
      constructor(arg) {
        super(arg);
      }
      push(value2) {
        this.add(value2);
      }
      pop() {
        return this.removeAt(this.size - 1);
      }
      peek() {
        return this.get(this.size - 1);
      }
    };
    exports.IntegerStack = IntegerStack;
  }
});

// node_modules/antlr4ts/dfa/AcceptStateInfo.js
var require_AcceptStateInfo = __commonJS({
  "node_modules/antlr4ts/dfa/AcceptStateInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AcceptStateInfo = void 0;
    var AcceptStateInfo = class {
      constructor(prediction, lexerActionExecutor) {
        this._prediction = prediction;
        this._lexerActionExecutor = lexerActionExecutor;
      }
      get prediction() {
        return this._prediction;
      }
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
    };
    exports.AcceptStateInfo = AcceptStateInfo;
  }
});

// node_modules/antlr4ts/misc/Array2DHashMap.js
var require_Array2DHashMap = __commonJS({
  "node_modules/antlr4ts/misc/Array2DHashMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Array2DHashMap = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var MapKeyEqualityComparator = class {
      constructor(keyComparator) {
        this.keyComparator = keyComparator;
      }
      hashCode(obj) {
        return this.keyComparator.hashCode(obj.key);
      }
      equals(a, b) {
        return this.keyComparator.equals(a.key, b.key);
      }
    };
    var Array2DHashMap = class {
      constructor(keyComparer) {
        if (keyComparer instanceof Array2DHashMap) {
          this.backingStore = new Array2DHashSet_1.Array2DHashSet(keyComparer.backingStore);
        } else {
          this.backingStore = new Array2DHashSet_1.Array2DHashSet(new MapKeyEqualityComparator(keyComparer));
        }
      }
      clear() {
        this.backingStore.clear();
      }
      containsKey(key) {
        return this.backingStore.contains({ key });
      }
      get(key) {
        let bucket = this.backingStore.get({ key });
        if (!bucket) {
          return void 0;
        }
        return bucket.value;
      }
      get isEmpty() {
        return this.backingStore.isEmpty;
      }
      put(key, value2) {
        let element2 = this.backingStore.get({ key, value: value2 });
        let result;
        if (!element2) {
          this.backingStore.add({ key, value: value2 });
        } else {
          result = element2.value;
          element2.value = value2;
        }
        return result;
      }
      putIfAbsent(key, value2) {
        let element2 = this.backingStore.get({ key, value: value2 });
        let result;
        if (!element2) {
          this.backingStore.add({ key, value: value2 });
        } else {
          result = element2.value;
        }
        return result;
      }
      get size() {
        return this.backingStore.size;
      }
      hashCode() {
        return this.backingStore.hashCode();
      }
      equals(o) {
        if (!(o instanceof Array2DHashMap)) {
          return false;
        }
        return this.backingStore.equals(o.backingStore);
      }
    };
    exports.Array2DHashMap = Array2DHashMap;
  }
});

// node_modules/antlr4ts/atn/DecisionState.js
var require_DecisionState = __commonJS({
  "node_modules/antlr4ts/atn/DecisionState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionState = void 0;
    var ATNState_1 = require_ATNState();
    var DecisionState = class extends ATNState_1.ATNState {
      constructor() {
        super(...arguments);
        this.decision = -1;
        this.nonGreedy = false;
        this.sll = false;
      }
    };
    exports.DecisionState = DecisionState;
  }
});

// node_modules/antlr4ts/atn/PredictionContextCache.js
var require_PredictionContextCache = __commonJS({
  "node_modules/antlr4ts/atn/PredictionContextCache.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredictionContextCache = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var assert = require("assert");
    var PredictionContextCache = class {
      constructor(enableCache = true) {
        this.contexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.childContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.joinContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.enableCache = enableCache;
      }
      getAsCached(context) {
        if (!this.enableCache) {
          return context;
        }
        let result = this.contexts.get(context);
        if (!result) {
          result = context;
          this.contexts.put(context, context);
        }
        return result;
      }
      getChild(context, invokingState) {
        if (!this.enableCache) {
          return context.getChild(invokingState);
        }
        let operands = new PredictionContextCache.PredictionContextAndInt(context, invokingState);
        let result = this.childContexts.get(operands);
        if (!result) {
          result = context.getChild(invokingState);
          result = this.getAsCached(result);
          this.childContexts.put(operands, result);
        }
        return result;
      }
      join(x, y) {
        if (!this.enableCache) {
          return PredictionContext_1.PredictionContext.join(x, y, this);
        }
        let operands = new PredictionContextCache.IdentityCommutativePredictionContextOperands(x, y);
        let result = this.joinContexts.get(operands);
        if (result) {
          return result;
        }
        result = PredictionContext_1.PredictionContext.join(x, y, this);
        result = this.getAsCached(result);
        this.joinContexts.put(operands, result);
        return result;
      }
    };
    exports.PredictionContextCache = PredictionContextCache;
    PredictionContextCache.UNCACHED = new PredictionContextCache(false);
    (function(PredictionContextCache2) {
      class PredictionContextAndInt {
        constructor(obj, value2) {
          this.obj = obj;
          this.value = value2;
        }
        equals(obj) {
          if (!(obj instanceof PredictionContextAndInt)) {
            return false;
          } else if (obj === this) {
            return true;
          }
          let other = obj;
          return this.value === other.value && (this.obj === other.obj || this.obj != null && this.obj.equals(other.obj));
        }
        hashCode() {
          let hashCode = 5;
          hashCode = 7 * hashCode + (this.obj != null ? this.obj.hashCode() : 0);
          hashCode = 7 * hashCode + this.value;
          return hashCode;
        }
      }
      __decorate([
        Decorators_1.Override
      ], PredictionContextAndInt.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], PredictionContextAndInt.prototype, "hashCode", null);
      PredictionContextCache2.PredictionContextAndInt = PredictionContextAndInt;
      class IdentityCommutativePredictionContextOperands {
        constructor(x, y) {
          assert(x != null);
          assert(y != null);
          this._x = x;
          this._y = y;
        }
        get x() {
          return this._x;
        }
        get y() {
          return this._y;
        }
        equals(o) {
          if (!(o instanceof IdentityCommutativePredictionContextOperands)) {
            return false;
          } else if (this === o) {
            return true;
          }
          let other = o;
          return this._x === other._x && this._y === other._y || this._x === other._y && this._y === other._x;
        }
        hashCode() {
          return this._x.hashCode() ^ this._y.hashCode();
        }
      }
      __decorate([
        Decorators_1.Override
      ], IdentityCommutativePredictionContextOperands.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], IdentityCommutativePredictionContextOperands.prototype, "hashCode", null);
      PredictionContextCache2.IdentityCommutativePredictionContextOperands = IdentityCommutativePredictionContextOperands;
    })(PredictionContextCache = exports.PredictionContextCache || (exports.PredictionContextCache = {}));
  }
});

// node_modules/antlr4ts/atn/PredictionContext.js
var require_PredictionContext = __commonJS({
  "node_modules/antlr4ts/atn/PredictionContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingletonPredictionContext = exports.PredictionContext = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var Arrays_1 = require_Arrays();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var assert = require("assert");
    var INITIAL_HASH = 1;
    var PredictionContext = class {
      constructor(cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
      }
      static calculateEmptyHashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        hash = MurmurHash_1.MurmurHash.finish(hash, 0);
        return hash;
      }
      static calculateSingleHashCode(parent, returnState) {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        hash = MurmurHash_1.MurmurHash.update(hash, parent);
        hash = MurmurHash_1.MurmurHash.update(hash, returnState);
        hash = MurmurHash_1.MurmurHash.finish(hash, 2);
        return hash;
      }
      static calculateHashCode(parents, returnStates) {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        for (let parent of parents) {
          hash = MurmurHash_1.MurmurHash.update(hash, parent);
        }
        for (let returnState of returnStates) {
          hash = MurmurHash_1.MurmurHash.update(hash, returnState);
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, 2 * parents.length);
        return hash;
      }
      static fromRuleContext(atn, outerContext, fullContext = true) {
        if (outerContext.isEmpty) {
          return fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
        }
        let parent;
        if (outerContext._parent) {
          parent = PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);
        } else {
          parent = fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
        }
        let state = atn.states[outerContext.invokingState];
        let transition = state.transition(0);
        return parent.getChild(transition.followState.stateNumber);
      }
      static addEmptyContext(context) {
        return context.addEmptyContext();
      }
      static removeEmptyContext(context) {
        return context.removeEmptyContext();
      }
      static join(context0, context1, contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED) {
        if (context0 === context1) {
          return context0;
        }
        if (context0.isEmpty) {
          return PredictionContext.isEmptyLocal(context0) ? context0 : PredictionContext.addEmptyContext(context1);
        } else if (context1.isEmpty) {
          return PredictionContext.isEmptyLocal(context1) ? context1 : PredictionContext.addEmptyContext(context0);
        }
        let context0size = context0.size;
        let context1size = context1.size;
        if (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {
          let merged = contextCache.join(context0.getParent(0), context1.getParent(0));
          if (merged === context0.getParent(0)) {
            return context0;
          } else if (merged === context1.getParent(0)) {
            return context1;
          } else {
            return merged.getChild(context0.getReturnState(0));
          }
        }
        let count = 0;
        let parentsList = new Array(context0size + context1size);
        let returnStatesList = new Array(parentsList.length);
        let leftIndex = 0;
        let rightIndex = 0;
        let canReturnLeft = true;
        let canReturnRight = true;
        while (leftIndex < context0size && rightIndex < context1size) {
          if (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {
            parentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));
            returnStatesList[count] = context0.getReturnState(leftIndex);
            canReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);
            canReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);
            leftIndex++;
            rightIndex++;
          } else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {
            parentsList[count] = context0.getParent(leftIndex);
            returnStatesList[count] = context0.getReturnState(leftIndex);
            canReturnRight = false;
            leftIndex++;
          } else {
            assert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));
            parentsList[count] = context1.getParent(rightIndex);
            returnStatesList[count] = context1.getReturnState(rightIndex);
            canReturnLeft = false;
            rightIndex++;
          }
          count++;
        }
        while (leftIndex < context0size) {
          parentsList[count] = context0.getParent(leftIndex);
          returnStatesList[count] = context0.getReturnState(leftIndex);
          leftIndex++;
          canReturnRight = false;
          count++;
        }
        while (rightIndex < context1size) {
          parentsList[count] = context1.getParent(rightIndex);
          returnStatesList[count] = context1.getReturnState(rightIndex);
          rightIndex++;
          canReturnLeft = false;
          count++;
        }
        if (canReturnLeft) {
          return context0;
        } else if (canReturnRight) {
          return context1;
        }
        if (count < parentsList.length) {
          parentsList = parentsList.slice(0, count);
          returnStatesList = returnStatesList.slice(0, count);
        }
        if (parentsList.length === 0) {
          return PredictionContext.EMPTY_FULL;
        } else if (parentsList.length === 1) {
          return new SingletonPredictionContext(parentsList[0], returnStatesList[0]);
        } else {
          return new ArrayPredictionContext(parentsList, returnStatesList);
        }
      }
      static isEmptyLocal(context) {
        return context === PredictionContext.EMPTY_LOCAL;
      }
      static getCachedContext(context, contextCache, visited) {
        if (context.isEmpty) {
          return context;
        }
        let existing = visited.get(context);
        if (existing) {
          return existing;
        }
        existing = contextCache.get(context);
        if (existing) {
          visited.put(context, existing);
          return existing;
        }
        let changed = false;
        let parents = new Array(context.size);
        for (let i = 0; i < parents.length; i++) {
          let parent = PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);
          if (changed || parent !== context.getParent(i)) {
            if (!changed) {
              parents = new Array(context.size);
              for (let j = 0; j < context.size; j++) {
                parents[j] = context.getParent(j);
              }
              changed = true;
            }
            parents[i] = parent;
          }
        }
        if (!changed) {
          existing = contextCache.putIfAbsent(context, context);
          visited.put(context, existing != null ? existing : context);
          return context;
        }
        let updated;
        if (parents.length === 1) {
          updated = new SingletonPredictionContext(parents[0], context.getReturnState(0));
        } else {
          let returnStates = new Array(context.size);
          for (let i = 0; i < context.size; i++) {
            returnStates[i] = context.getReturnState(i);
          }
          updated = new ArrayPredictionContext(parents, returnStates, context.hashCode());
        }
        existing = contextCache.putIfAbsent(updated, updated);
        visited.put(updated, existing || updated);
        visited.put(context, existing || updated);
        return updated;
      }
      appendSingleContext(returnContext, contextCache) {
        return this.appendContext(PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);
      }
      getChild(returnState) {
        return new SingletonPredictionContext(this, returnState);
      }
      hashCode() {
        return this.cachedHashCode;
      }
      toStrings(recognizer, currentState, stop = PredictionContext.EMPTY_FULL) {
        let result = [];
        outer:
          for (let perm = 0; ; perm++) {
            let offset = 0;
            let last = true;
            let p = this;
            let stateNumber = currentState;
            let localBuffer = "";
            localBuffer += "[";
            while (!p.isEmpty && p !== stop) {
              let index2 = 0;
              if (p.size > 0) {
                let bits = 1;
                while (1 << bits >>> 0 < p.size) {
                  bits++;
                }
                let mask = (1 << bits >>> 0) - 1;
                index2 = perm >> offset & mask;
                last = last && index2 >= p.size - 1;
                if (index2 >= p.size) {
                  continue outer;
                }
                offset += bits;
              }
              if (recognizer) {
                if (localBuffer.length > 1) {
                  localBuffer += " ";
                }
                let atn = recognizer.atn;
                let s = atn.states[stateNumber];
                let ruleName = recognizer.ruleNames[s.ruleIndex];
                localBuffer += ruleName;
              } else if (p.getReturnState(index2) !== PredictionContext.EMPTY_FULL_STATE_KEY) {
                if (!p.isEmpty) {
                  if (localBuffer.length > 1) {
                    localBuffer += " ";
                  }
                  localBuffer += p.getReturnState(index2);
                }
              }
              stateNumber = p.getReturnState(index2);
              p = p.getParent(index2);
            }
            localBuffer += "]";
            result.push(localBuffer);
            if (last) {
              break;
            }
          }
        return result;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PredictionContext.prototype, "hashCode", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], PredictionContext, "join", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], PredictionContext, "getCachedContext", null);
    exports.PredictionContext = PredictionContext;
    var EmptyPredictionContext = class extends PredictionContext {
      constructor(fullContext) {
        super(PredictionContext.calculateEmptyHashCode());
        this.fullContext = fullContext;
      }
      get isFullContext() {
        return this.fullContext;
      }
      addEmptyContext() {
        return this;
      }
      removeEmptyContext() {
        throw new Error("Cannot remove the empty context from itself.");
      }
      getParent(index2) {
        throw new Error("index out of bounds");
      }
      getReturnState(index2) {
        throw new Error("index out of bounds");
      }
      findReturnState(returnState) {
        return -1;
      }
      get size() {
        return 0;
      }
      appendSingleContext(returnContext, contextCache) {
        return contextCache.getChild(this, returnContext);
      }
      appendContext(suffix, contextCache) {
        return suffix;
      }
      get isEmpty() {
        return true;
      }
      get hasEmpty() {
        return true;
      }
      equals(o) {
        return this === o;
      }
      toStrings(recognizer, currentState, stop) {
        return ["[]"];
      }
    };
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "appendSingleContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "toStrings", null);
    var ArrayPredictionContext = class ArrayPredictionContext2 extends PredictionContext {
      constructor(parents, returnStates, hashCode) {
        super(hashCode || PredictionContext.calculateHashCode(parents, returnStates));
        assert(parents.length === returnStates.length);
        assert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, "Should be using PredictionContext.EMPTY instead.");
        this.parents = parents;
        this.returnStates = returnStates;
      }
      getParent(index2) {
        return this.parents[index2];
      }
      getReturnState(index2) {
        return this.returnStates[index2];
      }
      findReturnState(returnState) {
        return Arrays_1.Arrays.binarySearch(this.returnStates, returnState);
      }
      get size() {
        return this.returnStates.length;
      }
      get isEmpty() {
        return false;
      }
      get hasEmpty() {
        return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;
      }
      addEmptyContext() {
        if (this.hasEmpty) {
          return this;
        }
        let parents2 = this.parents.slice(0);
        let returnStates2 = this.returnStates.slice(0);
        parents2.push(PredictionContext.EMPTY_FULL);
        returnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);
        return new ArrayPredictionContext2(parents2, returnStates2);
      }
      removeEmptyContext() {
        if (!this.hasEmpty) {
          return this;
        }
        if (this.returnStates.length === 2) {
          return new SingletonPredictionContext(this.parents[0], this.returnStates[0]);
        } else {
          let parents2 = this.parents.slice(0, this.parents.length - 1);
          let returnStates2 = this.returnStates.slice(0, this.returnStates.length - 1);
          return new ArrayPredictionContext2(parents2, returnStates2);
        }
      }
      appendContext(suffix, contextCache) {
        return ArrayPredictionContext2.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());
      }
      static appendContextImpl(context, suffix, visited) {
        if (suffix.isEmpty) {
          if (PredictionContext.isEmptyLocal(suffix)) {
            if (context.hasEmpty) {
              return PredictionContext.EMPTY_LOCAL;
            }
            throw new Error("what to do here?");
          }
          return context;
        }
        if (suffix.size !== 1) {
          throw new Error("Appending a tree suffix is not yet supported.");
        }
        let result = visited.get(context);
        if (!result) {
          if (context.isEmpty) {
            result = suffix;
          } else {
            let parentCount = context.size;
            if (context.hasEmpty) {
              parentCount--;
            }
            let updatedParents = new Array(parentCount);
            let updatedReturnStates = new Array(parentCount);
            for (let i = 0; i < parentCount; i++) {
              updatedReturnStates[i] = context.getReturnState(i);
            }
            for (let i = 0; i < parentCount; i++) {
              updatedParents[i] = ArrayPredictionContext2.appendContextImpl(context.getParent(i), suffix, visited);
            }
            if (updatedParents.length === 1) {
              result = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);
            } else {
              assert(updatedParents.length > 1);
              result = new ArrayPredictionContext2(updatedParents, updatedReturnStates);
            }
            if (context.hasEmpty) {
              result = PredictionContext.join(result, suffix);
            }
          }
          visited.put(context, result);
        }
        return result;
      }
      equals(o) {
        if (this === o) {
          return true;
        } else if (!(o instanceof ArrayPredictionContext2)) {
          return false;
        }
        if (this.hashCode() !== o.hashCode()) {
          return false;
        }
        let other = o;
        return this.equalsImpl(other, new Array2DHashSet_1.Array2DHashSet());
      }
      equalsImpl(other, visited) {
        let selfWorkList = [];
        let otherWorkList = [];
        selfWorkList.push(this);
        otherWorkList.push(other);
        while (true) {
          let currentSelf = selfWorkList.pop();
          let currentOther = otherWorkList.pop();
          if (!currentSelf || !currentOther) {
            break;
          }
          let operands = new PredictionContextCache_1.PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);
          if (!visited.add(operands)) {
            continue;
          }
          let selfSize = operands.x.size;
          if (selfSize === 0) {
            if (!operands.x.equals(operands.y)) {
              return false;
            }
            continue;
          }
          let otherSize = operands.y.size;
          if (selfSize !== otherSize) {
            return false;
          }
          for (let i = 0; i < selfSize; i++) {
            if (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {
              return false;
            }
            let selfParent = operands.x.getParent(i);
            let otherParent = operands.y.getParent(i);
            if (selfParent.hashCode() !== otherParent.hashCode()) {
              return false;
            }
            if (selfParent !== otherParent) {
              selfWorkList.push(selfParent);
              otherWorkList.push(otherParent);
            }
          }
        }
        return true;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ArrayPredictionContext.prototype, "parents", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ArrayPredictionContext.prototype, "returnStates", void 0);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "equals", null);
    ArrayPredictionContext = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ArrayPredictionContext);
    var SingletonPredictionContext = class SingletonPredictionContext2 extends PredictionContext {
      constructor(parent, returnState) {
        super(PredictionContext.calculateSingleHashCode(parent, returnState));
        this.parent = parent;
        this.returnState = returnState;
      }
      getParent(index2) {
        return this.parent;
      }
      getReturnState(index2) {
        return this.returnState;
      }
      findReturnState(returnState) {
        return this.returnState === returnState ? 0 : -1;
      }
      get size() {
        return 1;
      }
      get isEmpty() {
        return false;
      }
      get hasEmpty() {
        return false;
      }
      appendContext(suffix, contextCache) {
        return contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);
      }
      addEmptyContext() {
        let parents = [this.parent, PredictionContext.EMPTY_FULL];
        let returnStates = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];
        return new ArrayPredictionContext(parents, returnStates);
      }
      removeEmptyContext() {
        return this;
      }
      equals(o) {
        if (o === this) {
          return true;
        } else if (!(o instanceof SingletonPredictionContext2)) {
          return false;
        }
        let other = o;
        if (this.hashCode() !== other.hashCode()) {
          return false;
        }
        return this.returnState === other.returnState && this.parent.equals(other.parent);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SingletonPredictionContext.prototype, "parent", void 0);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "equals", null);
    SingletonPredictionContext = __decorate([
      __param(0, Decorators_1.NotNull)
    ], SingletonPredictionContext);
    exports.SingletonPredictionContext = SingletonPredictionContext;
    (function(PredictionContext2) {
      PredictionContext2.EMPTY_LOCAL = new EmptyPredictionContext(false);
      PredictionContext2.EMPTY_FULL = new EmptyPredictionContext(true);
      PredictionContext2.EMPTY_LOCAL_STATE_KEY = -(1 << 31 >>> 0);
      PredictionContext2.EMPTY_FULL_STATE_KEY = (1 << 31 >>> 0) - 1;
      class IdentityHashMap extends Array2DHashMap_1.Array2DHashMap {
        constructor() {
          super(IdentityEqualityComparator.INSTANCE);
        }
      }
      PredictionContext2.IdentityHashMap = IdentityHashMap;
      class IdentityEqualityComparator {
        IdentityEqualityComparator() {
        }
        hashCode(obj) {
          return obj.hashCode();
        }
        equals(a, b) {
          return a === b;
        }
      }
      IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], IdentityEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], IdentityEqualityComparator.prototype, "equals", null);
      PredictionContext2.IdentityEqualityComparator = IdentityEqualityComparator;
    })(PredictionContext = exports.PredictionContext || (exports.PredictionContext = {}));
  }
});

// node_modules/antlr4ts/atn/ATNConfig.js
var require_ATNConfig = __commonJS({
  "node_modules/antlr4ts/atn/ATNConfig.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNConfig = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var DecisionState_1 = require_DecisionState();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var SemanticContext_1 = require_SemanticContext();
    var assert = require("assert");
    var SUPPRESS_PRECEDENCE_FILTER = 2147483648;
    var ATNConfig = class ATNConfig2 {
      constructor(state, altOrConfig, context) {
        if (typeof altOrConfig === "number") {
          assert((altOrConfig & 16777215) === altOrConfig);
          this._state = state;
          this.altAndOuterContextDepth = altOrConfig;
          this._context = context;
        } else {
          this._state = state;
          this.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;
          this._context = context;
        }
      }
      static create(state, alt, context, semanticContext = SemanticContext_1.SemanticContext.NONE, lexerActionExecutor) {
        if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
          if (lexerActionExecutor != null) {
            return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);
          } else {
            return new SemanticContextATNConfig(semanticContext, state, alt, context);
          }
        } else if (lexerActionExecutor != null) {
          return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);
        } else {
          return new ATNConfig2(state, alt, context);
        }
      }
      get state() {
        return this._state;
      }
      get alt() {
        return this.altAndOuterContextDepth & 16777215;
      }
      get context() {
        return this._context;
      }
      set context(context) {
        this._context = context;
      }
      get reachesIntoOuterContext() {
        return this.outerContextDepth !== 0;
      }
      get outerContextDepth() {
        return this.altAndOuterContextDepth >>> 24 & 127;
      }
      set outerContextDepth(outerContextDepth) {
        assert(outerContextDepth >= 0);
        outerContextDepth = Math.min(outerContextDepth, 127);
        this.altAndOuterContextDepth = outerContextDepth << 24 | (this.altAndOuterContextDepth & ~2130706432) >>> 0;
      }
      get lexerActionExecutor() {
        return void 0;
      }
      get semanticContext() {
        return SemanticContext_1.SemanticContext.NONE;
      }
      get hasPassedThroughNonGreedyDecision() {
        return false;
      }
      clone() {
        return this.transform(this.state, false);
      }
      transform(state, checkNonGreedy, arg2) {
        if (arg2 == null) {
          return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
        } else if (arg2 instanceof PredictionContext_1.PredictionContext) {
          return this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
        } else if (arg2 instanceof SemanticContext_1.SemanticContext) {
          return this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);
        } else {
          return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);
        }
      }
      transformImpl(state, context, semanticContext, checkNonGreedy, lexerActionExecutor) {
        let passedThroughNonGreedy = checkNonGreedy && ATNConfig2.checkNonGreedyDecision(this, state);
        if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
          if (lexerActionExecutor != null || passedThroughNonGreedy) {
            return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);
          } else {
            return new SemanticContextATNConfig(semanticContext, state, this, context);
          }
        } else if (lexerActionExecutor != null || passedThroughNonGreedy) {
          return new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);
        } else {
          return new ATNConfig2(state, this, context);
        }
      }
      static checkNonGreedyDecision(source, target) {
        return source.hasPassedThroughNonGreedyDecision || target instanceof DecisionState_1.DecisionState && target.nonGreedy;
      }
      appendContext(context, contextCache) {
        if (typeof context === "number") {
          let appendedContext = this.context.appendSingleContext(context, contextCache);
          let result = this.transform(this.state, false, appendedContext);
          return result;
        } else {
          let appendedContext = this.context.appendContext(context, contextCache);
          let result = this.transform(this.state, false, appendedContext);
          return result;
        }
      }
      contains(subconfig) {
        if (this.state.stateNumber !== subconfig.state.stateNumber || this.alt !== subconfig.alt || !this.semanticContext.equals(subconfig.semanticContext)) {
          return false;
        }
        let leftWorkList = [];
        let rightWorkList = [];
        leftWorkList.push(this.context);
        rightWorkList.push(subconfig.context);
        while (true) {
          let left = leftWorkList.pop();
          let right = rightWorkList.pop();
          if (!left || !right) {
            break;
          }
          if (left === right) {
            return true;
          }
          if (left.size < right.size) {
            return false;
          }
          if (right.isEmpty) {
            return left.hasEmpty;
          } else {
            for (let i = 0; i < right.size; i++) {
              let index2 = left.findReturnState(right.getReturnState(i));
              if (index2 < 0) {
                return false;
              }
              leftWorkList.push(left.getParent(index2));
              rightWorkList.push(right.getParent(i));
            }
          }
        }
        return false;
      }
      get isPrecedenceFilterSuppressed() {
        return (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;
      }
      set isPrecedenceFilterSuppressed(value2) {
        if (value2) {
          this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;
        } else {
          this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;
        }
      }
      equals(o) {
        if (this === o) {
          return true;
        } else if (!(o instanceof ATNConfig2)) {
          return false;
        }
        return this.state.stateNumber === o.state.stateNumber && this.alt === o.alt && this.reachesIntoOuterContext === o.reachesIntoOuterContext && this.context.equals(o.context) && this.semanticContext.equals(o.semanticContext) && this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed && this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision && ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);
      }
      hashCode() {
        let hashCode = MurmurHash_1.MurmurHash.initialize(7);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.state.stateNumber);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.alt);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.context);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.semanticContext);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.lexerActionExecutor);
        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 7);
        return hashCode;
      }
      toDotString() {
        let builder = "";
        builder += "digraph G {\n";
        builder += "rankdir=LR;\n";
        let visited = new Array2DHashMap_1.Array2DHashMap(PredictionContext_1.PredictionContext.IdentityEqualityComparator.INSTANCE);
        let workList = [];
        function getOrAddContext(context) {
          let newNumber = visited.size;
          let result = visited.putIfAbsent(context, newNumber);
          if (result != null) {
            return result;
          }
          workList.push(context);
          return newNumber;
        }
        workList.push(this.context);
        visited.put(this.context, 0);
        while (true) {
          let current = workList.pop();
          if (!current) {
            break;
          }
          for (let i = 0; i < current.size; i++) {
            builder += "  s" + getOrAddContext(current);
            builder += "->";
            builder += "s" + getOrAddContext(current.getParent(i));
            builder += '[label="' + current.getReturnState(i) + '"];\n';
          }
        }
        builder += "}\n";
        return builder.toString();
      }
      toString(recog, showAlt, showContext) {
        if (showContext == null) {
          showContext = showAlt != null;
        }
        if (showAlt == null) {
          showAlt = true;
        }
        let buf = "";
        let contexts;
        if (showContext) {
          contexts = this.context.toStrings(recog, this.state.stateNumber);
        } else {
          contexts = ["?"];
        }
        let first = true;
        for (let contextDesc of contexts) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          buf += "(";
          buf += this.state;
          if (showAlt) {
            buf += ",";
            buf += this.alt;
          }
          if (this.context) {
            buf += ",";
            buf += contextDesc;
          }
          if (this.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            buf += ",";
            buf += this.semanticContext;
          }
          if (this.reachesIntoOuterContext) {
            buf += ",up=" + this.outerContextDepth;
          }
          buf += ")";
        }
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "_state", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "_context", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "state", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ATNConfig.prototype, "context", null);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "semanticContext", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "clone", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ATNConfig.prototype, "transformImpl", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "hashCode", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ATNConfig, "create", null);
    ATNConfig = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ATNConfig);
    exports.ATNConfig = ATNConfig;
    var SemanticContextATNConfig = class SemanticContextATNConfig extends ATNConfig {
      constructor(semanticContext, state, altOrConfig, context) {
        if (typeof altOrConfig === "number") {
          super(state, altOrConfig, context);
        } else {
          super(state, altOrConfig, context);
        }
        this._semanticContext = semanticContext;
      }
      get semanticContext() {
        return this._semanticContext;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SemanticContextATNConfig.prototype, "_semanticContext", void 0);
    __decorate([
      Decorators_1.Override
    ], SemanticContextATNConfig.prototype, "semanticContext", null);
    SemanticContextATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], SemanticContextATNConfig);
    var ActionATNConfig = class ActionATNConfig extends ATNConfig {
      constructor(lexerActionExecutor, state, altOrConfig, context, passedThroughNonGreedyDecision) {
        if (typeof altOrConfig === "number") {
          super(state, altOrConfig, context);
        } else {
          super(state, altOrConfig, context);
          if (altOrConfig.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            throw new Error("Not supported");
          }
        }
        this._lexerActionExecutor = lexerActionExecutor;
        this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
      }
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
      get hasPassedThroughNonGreedyDecision() {
        return this.passedThroughNonGreedyDecision;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionATNConfig.prototype, "lexerActionExecutor", null);
    __decorate([
      Decorators_1.Override
    ], ActionATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
    ActionATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ActionATNConfig);
    var ActionSemanticContextATNConfig = class ActionSemanticContextATNConfig extends SemanticContextATNConfig {
      constructor(lexerActionExecutor, semanticContext, state, altOrConfig, context, passedThroughNonGreedyDecision) {
        if (typeof altOrConfig === "number") {
          super(semanticContext, state, altOrConfig, context);
        } else {
          super(semanticContext, state, altOrConfig, context);
        }
        this._lexerActionExecutor = lexerActionExecutor;
        this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
      }
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
      get hasPassedThroughNonGreedyDecision() {
        return this.passedThroughNonGreedyDecision;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionSemanticContextATNConfig.prototype, "lexerActionExecutor", null);
    __decorate([
      Decorators_1.Override
    ], ActionSemanticContextATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
    ActionSemanticContextATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ActionSemanticContextATNConfig);
  }
});

// node_modules/antlr4ts/misc/BitSet.js
var require_BitSet = __commonJS({
  "node_modules/antlr4ts/misc/BitSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitSet = void 0;
    var util = require("util");
    var MurmurHash_1 = require_MurmurHash();
    var EMPTY_DATA = new Uint16Array(0);
    function getIndex(bitNumber) {
      return bitNumber >>> 4;
    }
    function unIndex(n) {
      return n * 16;
    }
    function findLSBSet(word) {
      let bit = 1;
      for (let i = 0; i < 16; i++) {
        if ((word & bit) !== 0) {
          return i;
        }
        bit = bit << 1 >>> 0;
      }
      throw new RangeError("No specified bit found");
    }
    function findMSBSet(word) {
      let bit = 1 << 15 >>> 0;
      for (let i = 15; i >= 0; i--) {
        if ((word & bit) !== 0) {
          return i;
        }
        bit = bit >>> 1;
      }
      throw new RangeError("No specified bit found");
    }
    function bitsFor(fromBit, toBit) {
      fromBit &= 15;
      toBit &= 15;
      if (fromBit === toBit) {
        return 1 << fromBit >>> 0;
      }
      return 65535 >>> 15 - toBit ^ 65535 >>> 16 - fromBit;
    }
    var POP_CNT = new Uint8Array(65536);
    for (let i = 0; i < 16; i++) {
      const stride = 1 << i >>> 0;
      let index2 = 0;
      while (index2 < POP_CNT.length) {
        index2 += stride;
        for (let j = 0; j < stride; j++) {
          POP_CNT[index2]++;
          index2++;
        }
      }
    }
    var BitSet = class {
      constructor(arg) {
        if (!arg) {
          this.data = EMPTY_DATA;
        } else if (typeof arg === "number") {
          if (arg < 0) {
            throw new RangeError("nbits cannot be negative");
          } else {
            this.data = new Uint16Array(getIndex(arg - 1) + 1);
          }
        } else {
          if (arg instanceof BitSet) {
            this.data = arg.data.slice(0);
          } else {
            let max = -1;
            for (let v of arg) {
              if (max < v) {
                max = v;
              }
            }
            this.data = new Uint16Array(getIndex(max - 1) + 1);
            for (let v of arg) {
              this.set(v);
            }
          }
        }
      }
      and(set) {
        const data = this.data;
        const other = set.data;
        const words = Math.min(data.length, other.length);
        let lastWord = -1;
        for (let i = 0; i < words; i++) {
          let value2 = data[i] &= other[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        }
        if (lastWord < data.length - 1) {
          this.data = data.slice(0, lastWord + 1);
        }
      }
      andNot(set) {
        const data = this.data;
        const other = set.data;
        const words = Math.min(data.length, other.length);
        let lastWord = -1;
        for (let i = 0; i < words; i++) {
          let value2 = data[i] &= other[i] ^ 65535;
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        }
        if (lastWord < data.length - 1) {
          this.data = data.slice(0, lastWord + 1);
        }
      }
      cardinality() {
        if (this.isEmpty) {
          return 0;
        }
        const data = this.data;
        const length = data.length;
        let result = 0;
        for (let i = 0; i < length; i++) {
          result += POP_CNT[data[i]];
        }
        return result;
      }
      clear(fromIndex, toIndex) {
        if (fromIndex == null) {
          this.data.fill(0);
        } else if (toIndex == null) {
          this.set(fromIndex, false);
        } else {
          this.set(fromIndex, toIndex, false);
        }
      }
      flip(fromIndex, toIndex) {
        if (toIndex == null) {
          toIndex = fromIndex;
        }
        if (fromIndex < 0 || toIndex < fromIndex) {
          throw new RangeError();
        }
        let word = getIndex(fromIndex);
        const lastWord = getIndex(toIndex);
        if (word === lastWord) {
          this.data[word] ^= bitsFor(fromIndex, toIndex);
        } else {
          this.data[word++] ^= bitsFor(fromIndex, 15);
          while (word < lastWord) {
            this.data[word++] ^= 65535;
          }
          this.data[word++] ^= bitsFor(0, toIndex);
        }
      }
      get(fromIndex, toIndex) {
        if (toIndex === void 0) {
          return !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));
        } else {
          let result = new BitSet(toIndex + 1);
          for (let i = fromIndex; i <= toIndex; i++) {
            result.set(i, this.get(i));
          }
          return result;
        }
      }
      intersects(set) {
        let smallerLength = Math.min(this.length(), set.length());
        if (smallerLength === 0) {
          return false;
        }
        let bound = getIndex(smallerLength - 1);
        for (let i = 0; i <= bound; i++) {
          if ((this.data[i] & set.data[i]) !== 0) {
            return true;
          }
        }
        return false;
      }
      get isEmpty() {
        return this.length() === 0;
      }
      length() {
        if (!this.data.length) {
          return 0;
        }
        return this.previousSetBit(unIndex(this.data.length) - 1) + 1;
      }
      nextClearBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word > length) {
          return -1;
        }
        let ignore = 65535 ^ bitsFor(fromIndex, 15);
        if ((data[word] | ignore) === 65535) {
          word++;
          ignore = 0;
          for (; word < length; word++) {
            if (data[word] !== 65535) {
              break;
            }
          }
          if (word === length) {
            return -1;
          }
        }
        return unIndex(word) + findLSBSet((data[word] | ignore) ^ 65535);
      }
      nextSetBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word > length) {
          return -1;
        }
        let mask = bitsFor(fromIndex, 15);
        if ((data[word] & mask) === 0) {
          word++;
          mask = 65535;
          for (; word < length; word++) {
            if (data[word] !== 0) {
              break;
            }
          }
          if (word >= length) {
            return -1;
          }
        }
        return unIndex(word) + findLSBSet(data[word] & mask);
      }
      or(set) {
        const data = this.data;
        const other = set.data;
        const minWords = Math.min(data.length, other.length);
        const words = Math.max(data.length, other.length);
        const dest = data.length === words ? data : new Uint16Array(words);
        let lastWord = -1;
        for (let i = 0; i < minWords; i++) {
          let value2 = dest[i] = data[i] | other[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        const longer = data.length > other.length ? data : other;
        for (let i = minWords; i < words; i++) {
          let value2 = dest[i] = longer[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        } else if (dest.length === lastWord + 1) {
          this.data = dest;
        } else {
          this.data = dest.slice(0, lastWord);
        }
      }
      previousClearBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word >= length) {
          word = length - 1;
        }
        let ignore = 65535 ^ bitsFor(0, fromIndex);
        if ((data[word] | ignore) === 65535) {
          ignore = 0;
          word--;
          for (; word >= 0; word--) {
            if (data[word] !== 65535) {
              break;
            }
          }
          if (word < 0) {
            return -1;
          }
        }
        return unIndex(word) + findMSBSet((data[word] | ignore) ^ 65535);
      }
      previousSetBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word >= length) {
          word = length - 1;
        }
        let mask = bitsFor(0, fromIndex);
        if ((data[word] & mask) === 0) {
          word--;
          mask = 65535;
          for (; word >= 0; word--) {
            if (data[word] !== 0) {
              break;
            }
          }
          if (word < 0) {
            return -1;
          }
        }
        return unIndex(word) + findMSBSet(data[word] & mask);
      }
      set(fromIndex, toIndex, value2) {
        if (toIndex === void 0) {
          toIndex = fromIndex;
          value2 = true;
        } else if (typeof toIndex === "boolean") {
          value2 = toIndex;
          toIndex = fromIndex;
        }
        if (value2 === void 0) {
          value2 = true;
        }
        if (fromIndex < 0 || fromIndex > toIndex) {
          throw new RangeError();
        }
        let word = getIndex(fromIndex);
        let lastWord = getIndex(toIndex);
        if (value2 && lastWord >= this.data.length) {
          let temp = new Uint16Array(lastWord + 1);
          this.data.forEach((value3, index2) => temp[index2] = value3);
          this.data = temp;
        } else if (!value2) {
          if (word >= this.data.length) {
            return;
          }
          if (lastWord >= this.data.length) {
            lastWord = this.data.length - 1;
            toIndex = this.data.length * 16 - 1;
          }
        }
        if (word === lastWord) {
          this._setBits(word, value2, bitsFor(fromIndex, toIndex));
        } else {
          this._setBits(word++, value2, bitsFor(fromIndex, 15));
          while (word < lastWord) {
            this.data[word++] = value2 ? 65535 : 0;
          }
          this._setBits(word, value2, bitsFor(0, toIndex));
        }
      }
      _setBits(word, value2, mask) {
        if (value2) {
          this.data[word] |= mask;
        } else {
          this.data[word] &= 65535 ^ mask;
        }
      }
      get size() {
        return this.data.byteLength * 8;
      }
      hashCode() {
        return MurmurHash_1.MurmurHash.hashCode(this.data, 22);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof BitSet)) {
          return false;
        }
        const len = this.length();
        if (len !== obj.length()) {
          return false;
        }
        if (len === 0) {
          return true;
        }
        let bound = getIndex(len - 1);
        for (let i = 0; i <= bound; i++) {
          if (this.data[i] !== obj.data[i]) {
            return false;
          }
        }
        return true;
      }
      toString() {
        let result = "{";
        let first = true;
        for (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {
          if (first) {
            first = false;
          } else {
            result += ", ";
          }
          result += i;
        }
        result += "}";
        return result;
      }
      xor(set) {
        const data = this.data;
        const other = set.data;
        const minWords = Math.min(data.length, other.length);
        const words = Math.max(data.length, other.length);
        const dest = data.length === words ? data : new Uint16Array(words);
        let lastWord = -1;
        for (let i = 0; i < minWords; i++) {
          let value2 = dest[i] = data[i] ^ other[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        const longer = data.length > other.length ? data : other;
        for (let i = minWords; i < words; i++) {
          let value2 = dest[i] = longer[i];
          if (value2 !== 0) {
            lastWord = i;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        } else if (dest.length === lastWord + 1) {
          this.data = dest;
        } else {
          this.data = dest.slice(0, lastWord + 1);
        }
      }
      clone() {
        return new BitSet(this);
      }
      [Symbol.iterator]() {
        return new BitSetIterator(this.data);
      }
      [util.inspect.custom]() {
        return "BitSet " + this.toString();
      }
    };
    exports.BitSet = BitSet;
    var BitSetIterator = class {
      constructor(data) {
        this.data = data;
        this.index = 0;
        this.mask = 65535;
      }
      next() {
        while (this.index < this.data.length) {
          const bits = this.data[this.index] & this.mask;
          if (bits !== 0) {
            const bitNumber = unIndex(this.index) + findLSBSet(bits);
            this.mask = bitsFor(bitNumber + 1, 15);
            return { done: false, value: bitNumber };
          }
          this.index++;
          this.mask = 65535;
        }
        return { done: true, value: -1 };
      }
      [Symbol.iterator]() {
        return this;
      }
    };
  }
});

// node_modules/antlr4ts/atn/ATNConfigSet.js
var require_ATNConfigSet = __commonJS({
  "node_modules/antlr4ts/atn/ATNConfigSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNConfigSet = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var BitSet_1 = require_BitSet();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var SemanticContext_1 = require_SemanticContext();
    var assert = require("assert");
    var Utils3 = require_Utils();
    var KeyTypeEqualityComparer = class {
      hashCode(key) {
        return key.state ^ key.alt;
      }
      equals(a, b) {
        return a.state === b.state && a.alt === b.alt;
      }
    };
    KeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer();
    function NewKeyedConfigMap(map) {
      if (map) {
        return new Array2DHashMap_1.Array2DHashMap(map);
      } else {
        return new Array2DHashMap_1.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE);
      }
    }
    var ATNConfigSet = class {
      constructor(set, readonly) {
        this._uniqueAlt = 0;
        this._hasSemanticContext = false;
        this._dipsIntoOuterContext = false;
        this.outermostConfigSet = false;
        this.cachedHashCode = -1;
        if (!set) {
          this.mergedConfigs = NewKeyedConfigMap();
          this.unmerged = [];
          this.configs = [];
          this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        } else {
          if (readonly) {
            this.mergedConfigs = void 0;
            this.unmerged = void 0;
          } else if (!set.isReadOnly) {
            this.mergedConfigs = NewKeyedConfigMap(set.mergedConfigs);
            this.unmerged = set.unmerged.slice(0);
          } else {
            this.mergedConfigs = NewKeyedConfigMap();
            this.unmerged = [];
          }
          this.configs = set.configs.slice(0);
          this._dipsIntoOuterContext = set._dipsIntoOuterContext;
          this._hasSemanticContext = set._hasSemanticContext;
          this.outermostConfigSet = set.outermostConfigSet;
          if (readonly || !set.isReadOnly) {
            this._uniqueAlt = set._uniqueAlt;
            this._conflictInfo = set._conflictInfo;
          }
        }
      }
      getRepresentedAlternatives() {
        if (this._conflictInfo != null) {
          return this._conflictInfo.conflictedAlts.clone();
        }
        let alts = new BitSet_1.BitSet();
        for (let config of this) {
          alts.set(config.alt);
        }
        return alts;
      }
      get isReadOnly() {
        return this.mergedConfigs == null;
      }
      get isOutermostConfigSet() {
        return this.outermostConfigSet;
      }
      set isOutermostConfigSet(outermostConfigSet) {
        if (this.outermostConfigSet && !outermostConfigSet) {
          throw new Error("IllegalStateException");
        }
        assert(!outermostConfigSet || !this._dipsIntoOuterContext);
        this.outermostConfigSet = outermostConfigSet;
      }
      getStates() {
        let states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        for (let c of this.configs) {
          states.add(c.state);
        }
        return states;
      }
      optimizeConfigs(interpreter) {
        if (this.configs.length === 0) {
          return;
        }
        for (let config of this.configs) {
          config.context = interpreter.atn.getCachedContext(config.context);
        }
      }
      clone(readonly) {
        let copy = new ATNConfigSet(this, readonly);
        if (!readonly && this.isReadOnly) {
          copy.addAll(this.configs);
        }
        return copy;
      }
      get size() {
        return this.configs.length;
      }
      get isEmpty() {
        return this.configs.length === 0;
      }
      contains(o) {
        if (!(o instanceof ATNConfig_1.ATNConfig)) {
          return false;
        }
        if (this.mergedConfigs && this.unmerged) {
          let config = o;
          let configKey = this.getKey(config);
          let mergedConfig = this.mergedConfigs.get(configKey);
          if (mergedConfig != null && this.canMerge(config, configKey, mergedConfig)) {
            return mergedConfig.contains(config);
          }
          for (let c of this.unmerged) {
            if (c.contains(o)) {
              return true;
            }
          }
        } else {
          for (let c of this.configs) {
            if (c.contains(o)) {
              return true;
            }
          }
        }
        return false;
      }
      *[Symbol.iterator]() {
        yield* this.configs;
      }
      toArray() {
        return this.configs;
      }
      add(e, contextCache) {
        this.ensureWritable();
        if (!this.mergedConfigs || !this.unmerged) {
          throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
        }
        assert(!this.outermostConfigSet || !e.reachesIntoOuterContext);
        if (contextCache == null) {
          contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
        }
        let addKey;
        let key = this.getKey(e);
        let mergedConfig = this.mergedConfigs.get(key);
        addKey = mergedConfig == null;
        if (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {
          mergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);
          if (e.isPrecedenceFilterSuppressed) {
            mergedConfig.isPrecedenceFilterSuppressed = true;
          }
          let joined = PredictionContext_1.PredictionContext.join(mergedConfig.context, e.context, contextCache);
          this.updatePropertiesForMergedConfig(e);
          if (mergedConfig.context === joined) {
            return false;
          }
          mergedConfig.context = joined;
          return true;
        }
        for (let i = 0; i < this.unmerged.length; i++) {
          let unmergedConfig = this.unmerged[i];
          if (this.canMerge(e, key, unmergedConfig)) {
            unmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);
            if (e.isPrecedenceFilterSuppressed) {
              unmergedConfig.isPrecedenceFilterSuppressed = true;
            }
            let joined = PredictionContext_1.PredictionContext.join(unmergedConfig.context, e.context, contextCache);
            this.updatePropertiesForMergedConfig(e);
            if (unmergedConfig.context === joined) {
              return false;
            }
            unmergedConfig.context = joined;
            if (addKey) {
              this.mergedConfigs.put(key, unmergedConfig);
              this.unmerged.splice(i, 1);
            }
            return true;
          }
        }
        this.configs.push(e);
        if (addKey) {
          this.mergedConfigs.put(key, e);
        } else {
          this.unmerged.push(e);
        }
        this.updatePropertiesForAddedConfig(e);
        return true;
      }
      updatePropertiesForMergedConfig(config) {
        this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
        assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
      }
      updatePropertiesForAddedConfig(config) {
        if (this.configs.length === 1) {
          this._uniqueAlt = config.alt;
        } else if (this._uniqueAlt !== config.alt) {
          this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        this._hasSemanticContext = this._hasSemanticContext || !SemanticContext_1.SemanticContext.NONE.equals(config.semanticContext);
        this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
        assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
      }
      canMerge(left, leftKey, right) {
        if (left.state.stateNumber !== right.state.stateNumber) {
          return false;
        }
        if (leftKey.alt !== right.alt) {
          return false;
        }
        return left.semanticContext.equals(right.semanticContext);
      }
      getKey(e) {
        return { state: e.state.stateNumber, alt: e.alt };
      }
      containsAll(c) {
        for (let o of c) {
          if (!(o instanceof ATNConfig_1.ATNConfig)) {
            return false;
          }
          if (!this.contains(o)) {
            return false;
          }
        }
        return true;
      }
      addAll(c, contextCache) {
        this.ensureWritable();
        let changed = false;
        for (let group of c) {
          if (this.add(group, contextCache)) {
            changed = true;
          }
        }
        return changed;
      }
      clear() {
        this.ensureWritable();
        if (!this.mergedConfigs || !this.unmerged) {
          throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
        }
        this.mergedConfigs.clear();
        this.unmerged.length = 0;
        this.configs.length = 0;
        this._dipsIntoOuterContext = false;
        this._hasSemanticContext = false;
        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        this._conflictInfo = void 0;
      }
      equals(obj) {
        if (this === obj) {
          return true;
        }
        if (!(obj instanceof ATNConfigSet)) {
          return false;
        }
        return this.outermostConfigSet === obj.outermostConfigSet && Utils3.equals(this._conflictInfo, obj._conflictInfo) && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);
      }
      hashCode() {
        if (this.isReadOnly && this.cachedHashCode !== -1) {
          return this.cachedHashCode;
        }
        let hashCode = 1;
        hashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);
        hashCode = 5 * hashCode ^ ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);
        if (this.isReadOnly) {
          this.cachedHashCode = hashCode;
        }
        return hashCode;
      }
      toString(showContext) {
        if (showContext == null) {
          showContext = false;
        }
        let buf = "";
        let sortedConfigs = this.configs.slice(0);
        sortedConfigs.sort((o1, o2) => {
          if (o1.alt !== o2.alt) {
            return o1.alt - o2.alt;
          } else if (o1.state.stateNumber !== o2.state.stateNumber) {
            return o1.state.stateNumber - o2.state.stateNumber;
          } else {
            return o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());
          }
        });
        buf += "[";
        for (let i = 0; i < sortedConfigs.length; i++) {
          if (i > 0) {
            buf += ", ";
          }
          buf += sortedConfigs[i].toString(void 0, true, showContext);
        }
        buf += "]";
        if (this._hasSemanticContext) {
          buf += ",hasSemanticContext=" + this._hasSemanticContext;
        }
        if (this._uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          buf += ",uniqueAlt=" + this._uniqueAlt;
        }
        if (this._conflictInfo != null) {
          buf += ",conflictingAlts=" + this._conflictInfo.conflictedAlts;
          if (!this._conflictInfo.isExact) {
            buf += "*";
          }
        }
        if (this._dipsIntoOuterContext) {
          buf += ",dipsIntoOuterContext";
        }
        return buf.toString();
      }
      get uniqueAlt() {
        return this._uniqueAlt;
      }
      get hasSemanticContext() {
        return this._hasSemanticContext;
      }
      set hasSemanticContext(value2) {
        this.ensureWritable();
        this._hasSemanticContext = value2;
      }
      get conflictInfo() {
        return this._conflictInfo;
      }
      set conflictInfo(conflictInfo) {
        this.ensureWritable();
        this._conflictInfo = conflictInfo;
      }
      get conflictingAlts() {
        if (this._conflictInfo == null) {
          return void 0;
        }
        return this._conflictInfo.conflictedAlts;
      }
      get isExactConflict() {
        if (this._conflictInfo == null) {
          return false;
        }
        return this._conflictInfo.isExact;
      }
      get dipsIntoOuterContext() {
        return this._dipsIntoOuterContext;
      }
      get(index2) {
        return this.configs[index2];
      }
      ensureWritable() {
        if (this.isReadOnly) {
          throw new Error("This ATNConfigSet is read only.");
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNConfigSet.prototype, "getRepresentedAlternatives", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "contains", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, Symbol.iterator, null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "toArray", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "containsAll", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "clear", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "hashCode", null);
    exports.ATNConfigSet = ATNConfigSet;
  }
});

// node_modules/antlr4ts/dfa/DFAState.js
var require_DFAState = __commonJS({
  "node_modules/antlr4ts/dfa/DFAState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DFAState = void 0;
    var ATN_1 = require_ATN();
    var BitSet_1 = require_BitSet();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var assert = require("assert");
    var DFAState = class {
      constructor(configs) {
        this.stateNumber = -1;
        this.configs = configs;
        this.edges = /* @__PURE__ */ new Map();
        this.contextEdges = /* @__PURE__ */ new Map();
      }
      get isContextSensitive() {
        return !!this.contextSymbols;
      }
      isContextSymbol(symbol) {
        if (!this.isContextSensitive) {
          return false;
        }
        return this.contextSymbols.get(symbol);
      }
      setContextSymbol(symbol) {
        assert(this.isContextSensitive);
        this.contextSymbols.set(symbol);
      }
      setContextSensitive(atn) {
        assert(!this.configs.isOutermostConfigSet);
        if (this.isContextSensitive) {
          return;
        }
        if (!this.contextSymbols) {
          this.contextSymbols = new BitSet_1.BitSet();
        }
      }
      get acceptStateInfo() {
        return this._acceptStateInfo;
      }
      set acceptStateInfo(acceptStateInfo) {
        this._acceptStateInfo = acceptStateInfo;
      }
      get isAcceptState() {
        return !!this._acceptStateInfo;
      }
      get prediction() {
        if (!this._acceptStateInfo) {
          return ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        return this._acceptStateInfo.prediction;
      }
      get lexerActionExecutor() {
        if (!this._acceptStateInfo) {
          return void 0;
        }
        return this._acceptStateInfo.lexerActionExecutor;
      }
      getTarget(symbol) {
        return this.edges.get(symbol);
      }
      setTarget(symbol, target) {
        this.edges.set(symbol, target);
      }
      getEdgeMap() {
        return this.edges;
      }
      getContextTarget(invokingState) {
        if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          invokingState = -1;
        }
        return this.contextEdges.get(invokingState);
      }
      setContextTarget(invokingState, target) {
        if (!this.isContextSensitive) {
          throw new Error("The state is not context sensitive.");
        }
        if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          invokingState = -1;
        }
        this.contextEdges.set(invokingState, target);
      }
      getContextEdgeMap() {
        let map = new Map(this.contextEdges);
        let existing = map.get(-1);
        if (existing !== void 0) {
          if (map.size === 1) {
            let result = /* @__PURE__ */ new Map();
            result.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
            return result;
          } else {
            map.delete(-1);
            map.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
          }
        }
        return map;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize(7);
        hash = MurmurHash_1.MurmurHash.update(hash, this.configs.hashCode());
        hash = MurmurHash_1.MurmurHash.finish(hash, 1);
        return hash;
      }
      equals(o) {
        if (this === o) {
          return true;
        }
        if (!(o instanceof DFAState)) {
          return false;
        }
        let other = o;
        let sameSet = this.configs.equals(other.configs);
        return sameSet;
      }
      toString() {
        let buf = "";
        buf += this.stateNumber + ":" + this.configs;
        if (this.isAcceptState) {
          buf += "=>";
          if (this.predicates) {
            buf += this.predicates;
          } else {
            buf += this.prediction;
          }
        }
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "configs", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "edges", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "contextEdges", void 0);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "toString", null);
    exports.DFAState = DFAState;
    (function(DFAState2) {
      let PredPrediction = class PredPrediction {
        constructor(pred, alt) {
          this.alt = alt;
          this.pred = pred;
        }
        toString() {
          return "(" + this.pred + ", " + this.alt + ")";
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], PredPrediction.prototype, "pred", void 0);
      __decorate([
        Decorators_1.Override
      ], PredPrediction.prototype, "toString", null);
      PredPrediction = __decorate([
        __param(0, Decorators_1.NotNull)
      ], PredPrediction);
      DFAState2.PredPrediction = PredPrediction;
    })(DFAState = exports.DFAState || (exports.DFAState = {}));
  }
});

// node_modules/antlr4ts/atn/ATNSimulator.js
var require_ATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNSimulator = void 0;
    var ATNConfigSet_1 = require_ATNConfigSet();
    var DFAState_1 = require_DFAState();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var ATNSimulator = class ATNSimulator2 {
      constructor(atn) {
        this.atn = atn;
      }
      static get ERROR() {
        if (!ATNSimulator2._ERROR) {
          ATNSimulator2._ERROR = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
          ATNSimulator2._ERROR.stateNumber = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
        }
        return ATNSimulator2._ERROR;
      }
      clearDFA() {
        this.atn.clearDFA();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNSimulator.prototype, "atn", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNSimulator, "ERROR", null);
    ATNSimulator = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNSimulator);
    exports.ATNSimulator = ATNSimulator;
    (function(ATNSimulator2) {
      const RULE_VARIANT_DELIMITER = "$";
      const RULE_LF_VARIANT_MARKER = "$lf$";
      const RULE_NOLF_VARIANT_MARKER = "$nolf$";
    })(ATNSimulator = exports.ATNSimulator || (exports.ATNSimulator = {}));
    exports.ATNSimulator = ATNSimulator;
  }
});

// node_modules/antlr4ts/ConsoleErrorListener.js
var require_ConsoleErrorListener = __commonJS({
  "node_modules/antlr4ts/ConsoleErrorListener.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConsoleErrorListener = void 0;
    var ConsoleErrorListener = class {
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        console.error(`line ${line}:${charPositionInLine} ${msg}`);
      }
    };
    exports.ConsoleErrorListener = ConsoleErrorListener;
    ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
  }
});

// node_modules/antlr4ts/ProxyErrorListener.js
var require_ProxyErrorListener = __commonJS({
  "node_modules/antlr4ts/ProxyErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyErrorListener = void 0;
    var Decorators_1 = require_Decorators();
    var ProxyErrorListener = class {
      constructor(delegates) {
        this.delegates = delegates;
        if (!delegates) {
          throw new Error("Invalid delegates");
        }
      }
      getDelegates() {
        return this.delegates;
      }
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        this.delegates.forEach((listener) => {
          if (listener.syntaxError) {
            listener.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e);
          }
        });
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull)
    ], ProxyErrorListener.prototype, "syntaxError", null);
    exports.ProxyErrorListener = ProxyErrorListener;
  }
});

// node_modules/antlr4ts/Recognizer.js
var require_Recognizer = __commonJS({
  "node_modules/antlr4ts/Recognizer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Recognizer = void 0;
    var ConsoleErrorListener_1 = require_ConsoleErrorListener();
    var ProxyErrorListener_1 = require_ProxyErrorListener();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var Utils3 = require_Utils();
    var Recognizer = class {
      constructor() {
        this._listeners = [ConsoleErrorListener_1.ConsoleErrorListener.INSTANCE];
        this._stateNumber = -1;
      }
      getTokenTypeMap() {
        let vocabulary = this.vocabulary;
        let result = Recognizer.tokenTypeMapCache.get(vocabulary);
        if (result == null) {
          let intermediateResult = /* @__PURE__ */ new Map();
          for (let i = 0; i <= this.atn.maxTokenType; i++) {
            let literalName = vocabulary.getLiteralName(i);
            if (literalName != null) {
              intermediateResult.set(literalName, i);
            }
            let symbolicName = vocabulary.getSymbolicName(i);
            if (symbolicName != null) {
              intermediateResult.set(symbolicName, i);
            }
          }
          intermediateResult.set("EOF", Token_1.Token.EOF);
          result = intermediateResult;
          Recognizer.tokenTypeMapCache.set(vocabulary, result);
        }
        return result;
      }
      getRuleIndexMap() {
        let ruleNames = this.ruleNames;
        if (ruleNames == null) {
          throw new Error("The current recognizer does not provide a list of rule names.");
        }
        let result = Recognizer.ruleIndexMapCache.get(ruleNames);
        if (result == null) {
          result = Utils3.toMap(ruleNames);
          Recognizer.ruleIndexMapCache.set(ruleNames, result);
        }
        return result;
      }
      getTokenType(tokenName) {
        let ttype = this.getTokenTypeMap().get(tokenName);
        if (ttype != null) {
          return ttype;
        }
        return Token_1.Token.INVALID_TYPE;
      }
      get serializedATN() {
        throw new Error("there is no serialized ATN");
      }
      get atn() {
        return this._interp.atn;
      }
      get interpreter() {
        return this._interp;
      }
      set interpreter(interpreter) {
        this._interp = interpreter;
      }
      get parseInfo() {
        return Promise.resolve(void 0);
      }
      getErrorHeader(e) {
        let token = e.getOffendingToken();
        if (!token) {
          return "";
        }
        let line = token.line;
        let charPositionInLine = token.charPositionInLine;
        return "line " + line + ":" + charPositionInLine;
      }
      addErrorListener(listener) {
        if (!listener) {
          throw new TypeError("listener must not be null");
        }
        this._listeners.push(listener);
      }
      removeErrorListener(listener) {
        let position2 = this._listeners.indexOf(listener);
        if (position2 !== -1) {
          this._listeners.splice(position2, 1);
        }
      }
      removeErrorListeners() {
        this._listeners.length = 0;
      }
      getErrorListeners() {
        return this._listeners.slice(0);
      }
      getErrorListenerDispatch() {
        return new ProxyErrorListener_1.ProxyErrorListener(this.getErrorListeners());
      }
      sempred(_localctx, ruleIndex, actionIndex) {
        return true;
      }
      precpred(localctx, precedence) {
        return true;
      }
      action(_localctx, ruleIndex, actionIndex) {
      }
      get state() {
        return this._stateNumber;
      }
      set state(atnState) {
        this._stateNumber = atnState;
      }
    };
    Recognizer.EOF = -1;
    Recognizer.tokenTypeMapCache = /* @__PURE__ */ new WeakMap();
    Recognizer.ruleIndexMapCache = /* @__PURE__ */ new WeakMap();
    __decorate([
      Decorators_1.SuppressWarnings("serial"),
      Decorators_1.NotNull
    ], Recognizer.prototype, "_listeners", void 0);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getTokenTypeMap", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getRuleIndexMap", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "serializedATN", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "atn", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "interpreter", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "getErrorHeader", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "addErrorListener", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "removeErrorListener", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getErrorListeners", null);
    exports.Recognizer = Recognizer;
  }
});

// node_modules/antlr4ts/VocabularyImpl.js
var require_VocabularyImpl = __commonJS({
  "node_modules/antlr4ts/VocabularyImpl.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VocabularyImpl = void 0;
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var VocabularyImpl3 = class {
      constructor(literalNames, symbolicNames, displayNames) {
        this.literalNames = literalNames;
        this.symbolicNames = symbolicNames;
        this.displayNames = displayNames;
        this._maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
      }
      get maxTokenType() {
        return this._maxTokenType;
      }
      getLiteralName(tokenType) {
        if (tokenType >= 0 && tokenType < this.literalNames.length) {
          return this.literalNames[tokenType];
        }
        return void 0;
      }
      getSymbolicName(tokenType) {
        if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
          return this.symbolicNames[tokenType];
        }
        if (tokenType === Token_1.Token.EOF) {
          return "EOF";
        }
        return void 0;
      }
      getDisplayName(tokenType) {
        if (tokenType >= 0 && tokenType < this.displayNames.length) {
          let displayName = this.displayNames[tokenType];
          if (displayName) {
            return displayName;
          }
        }
        let literalName = this.getLiteralName(tokenType);
        if (literalName) {
          return literalName;
        }
        let symbolicName = this.getSymbolicName(tokenType);
        if (symbolicName) {
          return symbolicName;
        }
        return String(tokenType);
      }
    };
    VocabularyImpl3.EMPTY_VOCABULARY = new VocabularyImpl3([], [], []);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "literalNames", void 0);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "symbolicNames", void 0);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "displayNames", void 0);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl3.prototype, "maxTokenType", null);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl3.prototype, "getLiteralName", null);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl3.prototype, "getSymbolicName", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], VocabularyImpl3.prototype, "getDisplayName", null);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl3, "EMPTY_VOCABULARY", void 0);
    exports.VocabularyImpl = VocabularyImpl3;
  }
});

// node_modules/antlr4ts/dfa/DFASerializer.js
var require_DFASerializer = __commonJS({
  "node_modules/antlr4ts/dfa/DFASerializer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DFASerializer = void 0;
    var ATNSimulator_1 = require_ATNSimulator();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var Recognizer_1 = require_Recognizer();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var DFASerializer = class {
      constructor(dfa, vocabulary, ruleNames, atn) {
        if (vocabulary instanceof Recognizer_1.Recognizer) {
          ruleNames = vocabulary.ruleNames;
          atn = vocabulary.atn;
          vocabulary = vocabulary.vocabulary;
        } else if (!vocabulary) {
          vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        }
        this.dfa = dfa;
        this.vocabulary = vocabulary;
        this.ruleNames = ruleNames;
        this.atn = atn;
      }
      toString() {
        if (!this.dfa.s0) {
          return "";
        }
        let buf = "";
        if (this.dfa.states) {
          let states = new Array(...this.dfa.states.toArray());
          states.sort((o1, o2) => o1.stateNumber - o2.stateNumber);
          for (let s of states) {
            let edges = s.getEdgeMap();
            let edgeKeys = [...edges.keys()].sort((a, b) => a - b);
            let contextEdges = s.getContextEdgeMap();
            let contextEdgeKeys = [...contextEdges.keys()].sort((a, b) => a - b);
            for (let entry of edgeKeys) {
              let value2 = edges.get(entry);
              if ((value2 == null || value2 === ATNSimulator_1.ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {
                continue;
              }
              let contextSymbol = false;
              buf += this.getStateString(s) + "-" + this.getEdgeLabel(entry) + "->";
              if (s.isContextSymbol(entry)) {
                buf += "!";
                contextSymbol = true;
              }
              let t = value2;
              if (t && t.stateNumber !== ATNSimulator_1.ATNSimulator.ERROR.stateNumber) {
                buf += this.getStateString(t) + "\n";
              } else if (contextSymbol) {
                buf += "ctx\n";
              }
            }
            if (s.isContextSensitive) {
              for (let entry of contextEdgeKeys) {
                buf += this.getStateString(s) + "-" + this.getContextLabel(entry) + "->" + this.getStateString(contextEdges.get(entry)) + "\n";
              }
            }
          }
        }
        let output = buf;
        if (output.length === 0) {
          return "";
        }
        return output;
      }
      getContextLabel(i) {
        if (i === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          return "ctx:EMPTY_FULL";
        } else if (i === PredictionContext_1.PredictionContext.EMPTY_LOCAL_STATE_KEY) {
          return "ctx:EMPTY_LOCAL";
        }
        if (this.atn && i > 0 && i <= this.atn.states.length) {
          let state = this.atn.states[i];
          let ruleIndex = state.ruleIndex;
          if (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {
            return "ctx:" + String(i) + "(" + this.ruleNames[ruleIndex] + ")";
          }
        }
        return "ctx:" + String(i);
      }
      getEdgeLabel(i) {
        return this.vocabulary.getDisplayName(i);
      }
      getStateString(s) {
        if (s === ATNSimulator_1.ATNSimulator.ERROR) {
          return "ERROR";
        }
        let n = s.stateNumber;
        let stateStr = "s" + n;
        if (s.isAcceptState) {
          if (s.predicates) {
            stateStr = ":s" + n + "=>" + s.predicates;
          } else {
            stateStr = ":s" + n + "=>" + s.prediction;
          }
        }
        if (s.isContextSensitive) {
          stateStr += "*";
          for (let config of s.configs) {
            if (config.reachesIntoOuterContext) {
              stateStr += "*";
              break;
            }
          }
        }
        return stateStr;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFASerializer.prototype, "dfa", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFASerializer.prototype, "vocabulary", void 0);
    __decorate([
      Decorators_1.Override
    ], DFASerializer.prototype, "toString", null);
    exports.DFASerializer = DFASerializer;
  }
});

// node_modules/antlr4ts/dfa/LexerDFASerializer.js
var require_LexerDFASerializer = __commonJS({
  "node_modules/antlr4ts/dfa/LexerDFASerializer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerDFASerializer = void 0;
    var DFASerializer_1 = require_DFASerializer();
    var Decorators_1 = require_Decorators();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var LexerDFASerializer = class LexerDFASerializer extends DFASerializer_1.DFASerializer {
      constructor(dfa) {
        super(dfa, VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY);
      }
      getEdgeLabel(i) {
        return "'" + String.fromCodePoint(i) + "'";
      }
    };
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], LexerDFASerializer.prototype, "getEdgeLabel", null);
    LexerDFASerializer = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerDFASerializer);
    exports.LexerDFASerializer = LexerDFASerializer;
  }
});

// node_modules/antlr4ts/atn/StarLoopEntryState.js
var require_StarLoopEntryState = __commonJS({
  "node_modules/antlr4ts/atn/StarLoopEntryState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarLoopEntryState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BitSet_1 = require_BitSet();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var StarLoopEntryState = class extends DecisionState_1.DecisionState {
      constructor() {
        super(...arguments);
        this.precedenceRuleDecision = false;
        this.precedenceLoopbackStates = new BitSet_1.BitSet();
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarLoopEntryState.prototype, "stateType", null);
    exports.StarLoopEntryState = StarLoopEntryState;
  }
});

// node_modules/antlr4ts/dfa/DFA.js
var require_DFA = __commonJS({
  "node_modules/antlr4ts/dfa/DFA.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DFA = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var DFASerializer_1 = require_DFASerializer();
    var DFAState_1 = require_DFAState();
    var LexerDFASerializer_1 = require_LexerDFASerializer();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var DFA = class DFA {
      constructor(atnStartState, decision = 0) {
        this.states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.nextStateNumber = 0;
        if (!atnStartState.atn) {
          throw new Error("The ATNState must be associated with an ATN");
        }
        this.atnStartState = atnStartState;
        this.atn = atnStartState.atn;
        this.decision = decision;
        let isPrecedenceDfa = false;
        if (atnStartState instanceof StarLoopEntryState_1.StarLoopEntryState) {
          if (atnStartState.precedenceRuleDecision) {
            isPrecedenceDfa = true;
            this.s0 = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
            this.s0full = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
          }
        }
        this.precedenceDfa = isPrecedenceDfa;
      }
      get isPrecedenceDfa() {
        return this.precedenceDfa;
      }
      getPrecedenceStartState(precedence, fullContext) {
        if (!this.isPrecedenceDfa) {
          throw new Error("Only precedence DFAs may contain a precedence start state.");
        }
        if (fullContext) {
          return this.s0full.getTarget(precedence);
        } else {
          return this.s0.getTarget(precedence);
        }
      }
      setPrecedenceStartState(precedence, fullContext, startState) {
        if (!this.isPrecedenceDfa) {
          throw new Error("Only precedence DFAs may contain a precedence start state.");
        }
        if (precedence < 0) {
          return;
        }
        if (fullContext) {
          this.s0full.setTarget(precedence, startState);
        } else {
          this.s0.setTarget(precedence, startState);
        }
      }
      get isEmpty() {
        if (this.isPrecedenceDfa) {
          return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0;
        }
        return this.s0 == null && this.s0full == null;
      }
      get isContextSensitive() {
        if (this.isPrecedenceDfa) {
          return this.s0full.getEdgeMap().size > 0;
        }
        return this.s0full != null;
      }
      addState(state) {
        state.stateNumber = this.nextStateNumber++;
        return this.states.getOrAdd(state);
      }
      toString(vocabulary, ruleNames) {
        if (!vocabulary) {
          vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        }
        if (!this.s0) {
          return "";
        }
        let serializer;
        if (ruleNames) {
          serializer = new DFASerializer_1.DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);
        } else {
          serializer = new DFASerializer_1.DFASerializer(this, vocabulary);
        }
        return serializer.toString();
      }
      toLexerString() {
        if (!this.s0) {
          return "";
        }
        let serializer = new LexerDFASerializer_1.LexerDFASerializer(this);
        return serializer.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "states", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "atnStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "atn", void 0);
    DFA = __decorate([
      __param(0, Decorators_1.NotNull)
    ], DFA);
    exports.DFA = DFA;
  }
});

// node_modules/antlr4ts/atn/BasicState.js
var require_BasicState = __commonJS({
  "node_modules/antlr4ts/atn/BasicState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var BasicState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BASIC;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BasicState.prototype, "stateType", null);
    exports.BasicState = BasicState;
  }
});

// node_modules/antlr4ts/atn/InvalidState.js
var require_InvalidState = __commonJS({
  "node_modules/antlr4ts/atn/InvalidState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BasicState_1 = require_BasicState();
    var Decorators_1 = require_Decorators();
    var InvalidState = class extends BasicState_1.BasicState {
      get stateType() {
        return ATNStateType_1.ATNStateType.INVALID_TYPE;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InvalidState.prototype, "stateType", null);
    exports.InvalidState = InvalidState;
  }
});

// node_modules/antlr4ts/atn/SetTransition.js
var require_SetTransition = __commonJS({
  "node_modules/antlr4ts/atn/SetTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var Transition_1 = require_Transition();
    var SetTransition = class SetTransition extends Transition_1.Transition {
      constructor(target, set) {
        super(target);
        if (set == null) {
          set = IntervalSet_1.IntervalSet.of(Token_1.Token.INVALID_TYPE);
        }
        this.set = set;
      }
      get serializationType() {
        return 7;
      }
      get label() {
        return this.set;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this.set.contains(symbol);
      }
      toString() {
        return this.set.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SetTransition.prototype, "set", void 0);
    __decorate([
      Decorators_1.Override
    ], SetTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], SetTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], SetTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], SetTransition.prototype, "toString", null);
    SetTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.Nullable)
    ], SetTransition);
    exports.SetTransition = SetTransition;
  }
});

// node_modules/antlr4ts/atn/NotSetTransition.js
var require_NotSetTransition = __commonJS({
  "node_modules/antlr4ts/atn/NotSetTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotSetTransition = void 0;
    var Decorators_1 = require_Decorators();
    var SetTransition_1 = require_SetTransition();
    var NotSetTransition = class NotSetTransition extends SetTransition_1.SetTransition {
      constructor(target, set) {
        super(target, set);
      }
      get serializationType() {
        return 8;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
      }
      toString() {
        return "~" + super.toString();
      }
    };
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "toString", null);
    NotSetTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.Nullable)
    ], NotSetTransition);
    exports.NotSetTransition = NotSetTransition;
  }
});

// node_modules/antlr4ts/atn/RuleStopState.js
var require_RuleStopState = __commonJS({
  "node_modules/antlr4ts/atn/RuleStopState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleStopState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var RuleStopState = class extends ATNState_1.ATNState {
      get nonStopStateNumber() {
        return -1;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.RULE_STOP;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleStopState.prototype, "nonStopStateNumber", null);
    __decorate([
      Decorators_1.Override
    ], RuleStopState.prototype, "stateType", null);
    exports.RuleStopState = RuleStopState;
  }
});

// node_modules/antlr4ts/atn/RuleTransition.js
var require_RuleTransition = __commonJS({
  "node_modules/antlr4ts/atn/RuleTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var RuleTransition = class RuleTransition extends Transition_1.Transition {
      constructor(ruleStart, ruleIndex, precedence, followState) {
        super(ruleStart);
        this.tailCall = false;
        this.optimizedTailCall = false;
        this.ruleIndex = ruleIndex;
        this.precedence = precedence;
        this.followState = followState;
      }
      get serializationType() {
        return 3;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], RuleTransition.prototype, "followState", void 0);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "matches", null);
    RuleTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], RuleTransition);
    exports.RuleTransition = RuleTransition;
  }
});

// node_modules/antlr4ts/atn/WildcardTransition.js
var require_WildcardTransition = __commonJS({
  "node_modules/antlr4ts/atn/WildcardTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WildcardTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var WildcardTransition = class WildcardTransition extends Transition_1.Transition {
      constructor(target) {
        super(target);
      }
      get serializationType() {
        return 9;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
      }
      toString() {
        return ".";
      }
    };
    __decorate([
      Decorators_1.Override
    ], WildcardTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], WildcardTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], WildcardTransition.prototype, "toString", null);
    WildcardTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], WildcardTransition);
    exports.WildcardTransition = WildcardTransition;
  }
});

// node_modules/antlr4ts/atn/LL1Analyzer.js
var require_LL1Analyzer = __commonJS({
  "node_modules/antlr4ts/atn/LL1Analyzer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LL1Analyzer = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATNConfig_1 = require_ATNConfig();
    var BitSet_1 = require_BitSet();
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var Token_1 = require_Token();
    var WildcardTransition_1 = require_WildcardTransition();
    var LL1Analyzer = class LL1Analyzer2 {
      constructor(atn) {
        this.atn = atn;
      }
      getDecisionLookahead(s) {
        if (s == null) {
          return void 0;
        }
        let look = new Array(s.numberOfTransitions);
        for (let alt = 0; alt < s.numberOfTransitions; alt++) {
          let current = new IntervalSet_1.IntervalSet();
          look[alt] = current;
          let lookBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          let seeThruPreds = false;
          this._LOOK(s.transition(alt).target, void 0, PredictionContext_1.PredictionContext.EMPTY_LOCAL, current, lookBusy, new BitSet_1.BitSet(), seeThruPreds, false);
          if (current.size === 0 || current.contains(LL1Analyzer2.HIT_PRED)) {
            current = void 0;
            look[alt] = current;
          }
        }
        return look;
      }
      LOOK(s, ctx, stopState) {
        if (stopState === void 0) {
          if (s.atn == null) {
            throw new Error("Illegal state");
          }
          stopState = s.atn.ruleToStopState[s.ruleIndex];
        } else if (stopState === null) {
          stopState = void 0;
        }
        let r = new IntervalSet_1.IntervalSet();
        let seeThruPreds = true;
        let addEOF = true;
        this._LOOK(s, stopState, ctx, r, new Array2DHashSet_1.Array2DHashSet(), new BitSet_1.BitSet(), seeThruPreds, addEOF);
        return r;
      }
      _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
        let c = ATNConfig_1.ATNConfig.create(s, 0, ctx);
        if (!lookBusy.add(c)) {
          return;
        }
        if (s === stopState) {
          if (PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
            look.add(Token_1.Token.EPSILON);
            return;
          } else if (ctx.isEmpty) {
            if (addEOF) {
              look.add(Token_1.Token.EOF);
            }
            return;
          }
        }
        if (s instanceof RuleStopState_1.RuleStopState) {
          if (ctx.isEmpty && !PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
            if (addEOF) {
              look.add(Token_1.Token.EOF);
            }
            return;
          }
          let removed = calledRuleStack.get(s.ruleIndex);
          try {
            calledRuleStack.clear(s.ruleIndex);
            for (let i = 0; i < ctx.size; i++) {
              if (ctx.getReturnState(i) === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                continue;
              }
              let returnState = this.atn.states[ctx.getReturnState(i)];
              this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            }
          } finally {
            if (removed) {
              calledRuleStack.set(s.ruleIndex);
            }
          }
        }
        let n = s.numberOfTransitions;
        for (let i = 0; i < n; i++) {
          let t = s.transition(i);
          if (t instanceof RuleTransition_1.RuleTransition) {
            if (calledRuleStack.get(t.ruleIndex)) {
              continue;
            }
            let newContext = ctx.getChild(t.followState.stateNumber);
            try {
              calledRuleStack.set(t.ruleIndex);
              this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } finally {
              calledRuleStack.clear(t.ruleIndex);
            }
          } else if (t instanceof AbstractPredicateTransition_1.AbstractPredicateTransition) {
            if (seeThruPreds) {
              this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else {
              look.add(LL1Analyzer2.HIT_PRED);
            }
          } else if (t.isEpsilon) {
            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } else if (t instanceof WildcardTransition_1.WildcardTransition) {
            look.addAll(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
          } else {
            let set = t.label;
            if (set != null) {
              if (t instanceof NotSetTransition_1.NotSetTransition) {
                set = set.complement(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
              }
              look.addAll(set);
            }
          }
        }
      }
    };
    LL1Analyzer.HIT_PRED = Token_1.Token.INVALID_TYPE;
    __decorate([
      Decorators_1.NotNull
    ], LL1Analyzer.prototype, "atn", void 0);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LL1Analyzer.prototype, "LOOK", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], LL1Analyzer.prototype, "_LOOK", null);
    LL1Analyzer = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LL1Analyzer);
    exports.LL1Analyzer = LL1Analyzer;
  }
});

// node_modules/antlr4ts/atn/ATN.js
var require_ATN = __commonJS({
  "node_modules/antlr4ts/atn/ATN.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATN = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var DFA_1 = require_DFA();
    var IntervalSet_1 = require_IntervalSet();
    var InvalidState_1 = require_InvalidState();
    var LL1Analyzer_1 = require_LL1Analyzer();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var Token_1 = require_Token();
    var assert = require("assert");
    var ATN2 = class ATN {
      constructor(grammarType, maxTokenType) {
        this.states = [];
        this.decisionToState = [];
        this.modeNameToStartState = /* @__PURE__ */ new Map();
        this.modeToStartState = [];
        this.contextCache = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.decisionToDFA = [];
        this.modeToDFA = [];
        this.LL1Table = /* @__PURE__ */ new Map();
        this.grammarType = grammarType;
        this.maxTokenType = maxTokenType;
      }
      clearDFA() {
        this.decisionToDFA = new Array(this.decisionToState.length);
        for (let i = 0; i < this.decisionToDFA.length; i++) {
          this.decisionToDFA[i] = new DFA_1.DFA(this.decisionToState[i], i);
        }
        this.modeToDFA = new Array(this.modeToStartState.length);
        for (let i = 0; i < this.modeToDFA.length; i++) {
          this.modeToDFA[i] = new DFA_1.DFA(this.modeToStartState[i]);
        }
        this.contextCache.clear();
        this.LL1Table.clear();
      }
      get contextCacheSize() {
        return this.contextCache.size;
      }
      getCachedContext(context) {
        return PredictionContext_1.PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext_1.PredictionContext.IdentityHashMap());
      }
      getDecisionToDFA() {
        assert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);
        return this.decisionToDFA;
      }
      nextTokens(s, ctx) {
        if (ctx) {
          let anal = new LL1Analyzer_1.LL1Analyzer(this);
          let next = anal.LOOK(s, ctx);
          return next;
        } else {
          if (s.nextTokenWithinRule) {
            return s.nextTokenWithinRule;
          }
          s.nextTokenWithinRule = this.nextTokens(s, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
          s.nextTokenWithinRule.setReadonly(true);
          return s.nextTokenWithinRule;
        }
      }
      addState(state) {
        state.atn = this;
        state.stateNumber = this.states.length;
        this.states.push(state);
      }
      removeState(state) {
        let invalidState = new InvalidState_1.InvalidState();
        invalidState.atn = this;
        invalidState.stateNumber = state.stateNumber;
        this.states[state.stateNumber] = invalidState;
      }
      defineMode(name, s) {
        this.modeNameToStartState.set(name, s);
        this.modeToStartState.push(s);
        this.modeToDFA.push(new DFA_1.DFA(s));
        this.defineDecisionState(s);
      }
      defineDecisionState(s) {
        this.decisionToState.push(s);
        s.decision = this.decisionToState.length - 1;
        this.decisionToDFA.push(new DFA_1.DFA(s, s.decision));
        return s.decision;
      }
      getDecisionState(decision) {
        if (this.decisionToState.length > 0) {
          return this.decisionToState[decision];
        }
        return void 0;
      }
      get numberOfDecisions() {
        return this.decisionToState.length;
      }
      getExpectedTokens(stateNumber, context) {
        if (stateNumber < 0 || stateNumber >= this.states.length) {
          throw new RangeError("Invalid state number.");
        }
        let ctx = context;
        let s = this.states[stateNumber];
        let following = this.nextTokens(s);
        if (!following.contains(Token_1.Token.EPSILON)) {
          return following;
        }
        let expected = new IntervalSet_1.IntervalSet();
        expected.addAll(following);
        expected.remove(Token_1.Token.EPSILON);
        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
          let invokingState = this.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          following = this.nextTokens(rt.followState);
          expected.addAll(following);
          expected.remove(Token_1.Token.EPSILON);
          ctx = ctx._parent;
        }
        if (following.contains(Token_1.Token.EPSILON)) {
          expected.add(Token_1.Token.EOF);
        }
        return expected;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "states", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "decisionToState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "modeNameToStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "modeToStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "decisionToDFA", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "modeToDFA", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "nextTokens", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN2.prototype, "removeState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ATN2.prototype, "defineMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN2.prototype, "defineDecisionState", null);
    __decorate([
      Decorators_1.NotNull
    ], ATN2.prototype, "getExpectedTokens", null);
    ATN2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN2);
    exports.ATN = ATN2;
    (function(ATN3) {
      ATN3.INVALID_ALT_NUMBER = 0;
    })(ATN2 = exports.ATN || (exports.ATN = {}));
    exports.ATN = ATN2;
  }
});

// node_modules/antlr4ts/atn/LexerIndexedCustomAction.js
var require_LexerIndexedCustomAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerIndexedCustomAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerIndexedCustomAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerIndexedCustomAction = class LexerIndexedCustomAction2 {
      constructor(offset, action) {
        this._offset = offset;
        this._action = action;
      }
      get offset() {
        return this._offset;
      }
      get action() {
        return this._action;
      }
      get actionType() {
        return this._action.actionType;
      }
      get isPositionDependent() {
        return true;
      }
      execute(lexer) {
        this._action.execute(lexer);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this._offset);
        hash = MurmurHash_1.MurmurHash.update(hash, this._action);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerIndexedCustomAction2)) {
          return false;
        }
        return this._offset === obj._offset && this._action.equals(obj._action);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerIndexedCustomAction.prototype, "action", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "equals", null);
    LexerIndexedCustomAction = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerIndexedCustomAction);
    exports.LexerIndexedCustomAction = LexerIndexedCustomAction;
  }
});

// node_modules/antlr4ts/atn/LexerActionExecutor.js
var require_LexerActionExecutor = __commonJS({
  "node_modules/antlr4ts/atn/LexerActionExecutor.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerActionExecutor = void 0;
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var LexerIndexedCustomAction_1 = require_LexerIndexedCustomAction();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerActionExecutor = class LexerActionExecutor2 {
      constructor(lexerActions) {
        this._lexerActions = lexerActions;
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let lexerAction of lexerActions) {
          hash = MurmurHash_1.MurmurHash.update(hash, lexerAction);
        }
        this.cachedHashCode = MurmurHash_1.MurmurHash.finish(hash, lexerActions.length);
      }
      static append(lexerActionExecutor, lexerAction) {
        if (!lexerActionExecutor) {
          return new LexerActionExecutor2([lexerAction]);
        }
        let lexerActions = lexerActionExecutor._lexerActions.slice(0);
        lexerActions.push(lexerAction);
        return new LexerActionExecutor2(lexerActions);
      }
      fixOffsetBeforeMatch(offset) {
        let updatedLexerActions;
        for (let i = 0; i < this._lexerActions.length; i++) {
          if (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction)) {
            if (!updatedLexerActions) {
              updatedLexerActions = this._lexerActions.slice(0);
            }
            updatedLexerActions[i] = new LexerIndexedCustomAction_1.LexerIndexedCustomAction(offset, this._lexerActions[i]);
          }
        }
        if (!updatedLexerActions) {
          return this;
        }
        return new LexerActionExecutor2(updatedLexerActions);
      }
      get lexerActions() {
        return this._lexerActions;
      }
      execute(lexer, input, startIndex) {
        let requiresSeek = false;
        let stopIndex = input.index;
        try {
          for (let lexerAction of this._lexerActions) {
            if (lexerAction instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction) {
              let offset = lexerAction.offset;
              input.seek(startIndex + offset);
              lexerAction = lexerAction.action;
              requiresSeek = startIndex + offset !== stopIndex;
            } else if (lexerAction.isPositionDependent) {
              input.seek(stopIndex);
              requiresSeek = false;
            }
            lexerAction.execute(lexer);
          }
        } finally {
          if (requiresSeek) {
            input.seek(stopIndex);
          }
        }
      }
      hashCode() {
        return this.cachedHashCode;
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerActionExecutor2)) {
          return false;
        }
        return this.cachedHashCode === obj.cachedHashCode && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerActionExecutor.prototype, "_lexerActions", void 0);
    __decorate([
      Decorators_1.NotNull
    ], LexerActionExecutor.prototype, "lexerActions", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerActionExecutor.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerActionExecutor.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerActionExecutor.prototype, "equals", null);
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], LexerActionExecutor, "append", null);
    LexerActionExecutor = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerActionExecutor);
    exports.LexerActionExecutor = LexerActionExecutor;
  }
});

// node_modules/antlr4ts/LexerNoViableAltException.js
var require_LexerNoViableAltException = __commonJS({
  "node_modules/antlr4ts/LexerNoViableAltException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerNoViableAltException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var Interval_1 = require_Interval();
    var Utils3 = require_Utils();
    var LexerNoViableAltException = class LexerNoViableAltException extends RecognitionException_1.RecognitionException {
      constructor(lexer, input, startIndex, deadEndConfigs) {
        super(lexer, input);
        this._startIndex = startIndex;
        this._deadEndConfigs = deadEndConfigs;
      }
      get startIndex() {
        return this._startIndex;
      }
      get deadEndConfigs() {
        return this._deadEndConfigs;
      }
      get inputStream() {
        return super.inputStream;
      }
      toString() {
        let symbol = "";
        if (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {
          symbol = this.inputStream.getText(Interval_1.Interval.of(this._startIndex, this._startIndex));
          symbol = Utils3.escapeWhitespace(symbol, false);
        }
        return `LexerNoViableAltException('${symbol}')`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerNoViableAltException.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], LexerNoViableAltException.prototype, "toString", null);
    LexerNoViableAltException = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerNoViableAltException);
    exports.LexerNoViableAltException = LexerNoViableAltException;
  }
});

// node_modules/antlr4ts/atn/OrderedATNConfigSet.js
var require_OrderedATNConfigSet = __commonJS({
  "node_modules/antlr4ts/atn/OrderedATNConfigSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OrderedATNConfigSet = void 0;
    var ATNConfigSet_1 = require_ATNConfigSet();
    var Decorators_1 = require_Decorators();
    var OrderedATNConfigSet = class extends ATNConfigSet_1.ATNConfigSet {
      constructor(set, readonly) {
        if (set != null && readonly != null) {
          super(set, readonly);
        } else {
          super();
        }
      }
      clone(readonly) {
        let copy = new OrderedATNConfigSet(this, readonly);
        if (!readonly && this.isReadOnly) {
          copy.addAll(this);
        }
        return copy;
      }
      getKey(e) {
        return { state: 0, alt: e.hashCode() };
      }
      canMerge(left, leftKey, right) {
        return left.equals(right);
      }
    };
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "clone", null);
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "getKey", null);
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "canMerge", null);
    exports.OrderedATNConfigSet = OrderedATNConfigSet;
  }
});

// node_modules/antlr4ts/atn/LexerATNSimulator.js
var require_LexerATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/LexerATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerATNSimulator = void 0;
    var AcceptStateInfo_1 = require_AcceptStateInfo();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var ATNSimulator_1 = require_ATNSimulator();
    var DFAState_1 = require_DFAState();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var Lexer_1 = require_Lexer();
    var LexerActionExecutor_1 = require_LexerActionExecutor();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var Decorators_1 = require_Decorators();
    var OrderedATNConfigSet_1 = require_OrderedATNConfigSet();
    var PredictionContext_1 = require_PredictionContext();
    var RuleStopState_1 = require_RuleStopState();
    var Token_1 = require_Token();
    var assert = require("assert");
    var LexerATNSimulator2 = class LexerATNSimulator3 extends ATNSimulator_1.ATNSimulator {
      constructor(atn, recog) {
        super(atn);
        this.optimize_tail_calls = true;
        this.startIndex = -1;
        this._line = 1;
        this._charPositionInLine = 0;
        this.mode = Lexer_1.Lexer.DEFAULT_MODE;
        this.prevAccept = new LexerATNSimulator3.SimState();
        this.recog = recog;
      }
      copyState(simulator) {
        this._charPositionInLine = simulator.charPositionInLine;
        this._line = simulator._line;
        this.mode = simulator.mode;
        this.startIndex = simulator.startIndex;
      }
      match(input, mode) {
        this.mode = mode;
        let mark = input.mark();
        try {
          this.startIndex = input.index;
          this.prevAccept.reset();
          let s0 = this.atn.modeToDFA[mode].s0;
          if (s0 == null) {
            return this.matchATN(input);
          } else {
            return this.execATN(input, s0);
          }
        } finally {
          input.release(mark);
        }
      }
      reset() {
        this.prevAccept.reset();
        this.startIndex = -1;
        this._line = 1;
        this._charPositionInLine = 0;
        this.mode = Lexer_1.Lexer.DEFAULT_MODE;
      }
      matchATN(input) {
        let startState = this.atn.modeToStartState[this.mode];
        if (LexerATNSimulator3.debug) {
          console.log(`matchATN mode ${this.mode} start: ${startState}`);
        }
        let old_mode = this.mode;
        let s0_closure = this.computeStartState(input, startState);
        let suppressEdge = s0_closure.hasSemanticContext;
        if (suppressEdge) {
          s0_closure.hasSemanticContext = false;
        }
        let next = this.addDFAState(s0_closure);
        if (!suppressEdge) {
          let dfa = this.atn.modeToDFA[this.mode];
          if (!dfa.s0) {
            dfa.s0 = next;
          } else {
            next = dfa.s0;
          }
        }
        let predict = this.execATN(input, next);
        if (LexerATNSimulator3.debug) {
          console.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);
        }
        return predict;
      }
      execATN(input, ds0) {
        if (LexerATNSimulator3.debug) {
          console.log(`start state closure=${ds0.configs}`);
        }
        if (ds0.isAcceptState) {
          this.captureSimState(this.prevAccept, input, ds0);
        }
        let t = input.LA(1);
        let s = ds0;
        while (true) {
          if (LexerATNSimulator3.debug) {
            console.log(`execATN loop starting closure: ${s.configs}`);
          }
          let target = this.getExistingTargetState(s, t);
          if (target == null) {
            target = this.computeTargetState(input, s, t);
          }
          if (target === ATNSimulator_1.ATNSimulator.ERROR) {
            break;
          }
          if (t !== IntStream_1.IntStream.EOF) {
            this.consume(input);
          }
          if (target.isAcceptState) {
            this.captureSimState(this.prevAccept, input, target);
            if (t === IntStream_1.IntStream.EOF) {
              break;
            }
          }
          t = input.LA(1);
          s = target;
        }
        return this.failOrAccept(this.prevAccept, input, s.configs, t);
      }
      getExistingTargetState(s, t) {
        let target = s.getTarget(t);
        if (LexerATNSimulator3.debug && target != null) {
          console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
        }
        return target;
      }
      computeTargetState(input, s, t) {
        let reach = new OrderedATNConfigSet_1.OrderedATNConfigSet();
        this.getReachableConfigSet(input, s.configs, reach, t);
        if (reach.isEmpty) {
          if (!reach.hasSemanticContext) {
            this.addDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
          }
          return ATNSimulator_1.ATNSimulator.ERROR;
        }
        return this.addDFAEdge(s, t, reach);
      }
      failOrAccept(prevAccept, input, reach, t) {
        if (prevAccept.dfaState != null) {
          let lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
          this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.charPos);
          return prevAccept.dfaState.prediction;
        } else {
          if (t === IntStream_1.IntStream.EOF && input.index === this.startIndex) {
            return Token_1.Token.EOF;
          }
          throw new LexerNoViableAltException_1.LexerNoViableAltException(this.recog, input, this.startIndex, reach);
        }
      }
      getReachableConfigSet(input, closure, reach, t) {
        let skipAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        for (let c of closure) {
          let currentAltReachedAcceptState = c.alt === skipAlt;
          if (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {
            continue;
          }
          if (LexerATNSimulator3.debug) {
            console.log(`testing ${this.getTokenName(t)} at ${c.toString(this.recog, true)}`);
          }
          let n = c.state.numberOfOptimizedTransitions;
          for (let ti = 0; ti < n; ti++) {
            let trans = c.state.getOptimizedTransition(ti);
            let target = this.getReachableTarget(trans, t);
            if (target != null) {
              let lexerActionExecutor = c.lexerActionExecutor;
              let config;
              if (lexerActionExecutor != null) {
                lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
                config = c.transform(target, true, lexerActionExecutor);
              } else {
                assert(c.lexerActionExecutor == null);
                config = c.transform(target, true);
              }
              let treatEofAsEpsilon = t === IntStream_1.IntStream.EOF;
              if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
                skipAlt = c.alt;
                break;
              }
            }
          }
        }
      }
      accept(input, lexerActionExecutor, startIndex, index2, line, charPos) {
        if (LexerATNSimulator3.debug) {
          console.log(`ACTION ${lexerActionExecutor}`);
        }
        input.seek(index2);
        this._line = line;
        this._charPositionInLine = charPos;
        if (lexerActionExecutor != null && this.recog != null) {
          lexerActionExecutor.execute(this.recog, input, startIndex);
        }
      }
      getReachableTarget(trans, t) {
        if (trans.matches(t, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
          return trans.target;
        }
        return void 0;
      }
      computeStartState(input, p) {
        let initialContext = PredictionContext_1.PredictionContext.EMPTY_FULL;
        let configs = new OrderedATNConfigSet_1.OrderedATNConfigSet();
        for (let i = 0; i < p.numberOfTransitions; i++) {
          let target = p.transition(i).target;
          let c = ATNConfig_1.ATNConfig.create(target, i + 1, initialContext);
          this.closure(input, c, configs, false, false, false);
        }
        return configs;
      }
      closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
        if (LexerATNSimulator3.debug) {
          console.log("closure(" + config.toString(this.recog, true) + ")");
        }
        if (config.state instanceof RuleStopState_1.RuleStopState) {
          if (LexerATNSimulator3.debug) {
            if (this.recog != null) {
              console.log(`closure at ${this.recog.ruleNames[config.state.ruleIndex]} rule stop ${config}`);
            } else {
              console.log(`closure at rule stop ${config}`);
            }
          }
          let context = config.context;
          if (context.isEmpty) {
            configs.add(config);
            return true;
          } else if (context.hasEmpty) {
            configs.add(config.transform(config.state, true, PredictionContext_1.PredictionContext.EMPTY_FULL));
            currentAltReachedAcceptState = true;
          }
          for (let i = 0; i < context.size; i++) {
            let returnStateNumber = context.getReturnState(i);
            if (returnStateNumber === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              continue;
            }
            let newContext = context.getParent(i);
            let returnState = this.atn.states[returnStateNumber];
            let c = config.transform(returnState, false, newContext);
            currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
          }
          return currentAltReachedAcceptState;
        }
        if (!config.state.onlyHasEpsilonTransitions) {
          if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision) {
            configs.add(config);
          }
        }
        let p = config.state;
        for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
          let t = p.getOptimizedTransition(i);
          let c = this.getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon);
          if (c != null) {
            currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
          }
        }
        return currentAltReachedAcceptState;
      }
      getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon) {
        let c;
        switch (t.serializationType) {
          case 3:
            let ruleTransition = t;
            if (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config.context.hasEmpty) {
              c = config.transform(t.target, true);
            } else {
              let newContext = config.context.getChild(ruleTransition.followState.stateNumber);
              c = config.transform(t.target, true, newContext);
            }
            break;
          case 10:
            throw new Error("Precedence predicates are not supported in lexers.");
          case 4:
            let pt = t;
            if (LexerATNSimulator3.debug) {
              console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
            }
            configs.hasSemanticContext = true;
            if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
              c = config.transform(t.target, true);
            } else {
              c = void 0;
            }
            break;
          case 6:
            if (config.context.hasEmpty) {
              let lexerActionExecutor = LexerActionExecutor_1.LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[t.actionIndex]);
              c = config.transform(t.target, true, lexerActionExecutor);
              break;
            } else {
              c = config.transform(t.target, true);
              break;
            }
          case 1:
            c = config.transform(t.target, true);
            break;
          case 5:
          case 2:
          case 7:
            if (treatEofAsEpsilon) {
              if (t.matches(IntStream_1.IntStream.EOF, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
                c = config.transform(t.target, false);
                break;
              }
            }
            c = void 0;
            break;
          default:
            c = void 0;
            break;
        }
        return c;
      }
      evaluatePredicate(input, ruleIndex, predIndex, speculative) {
        if (this.recog == null) {
          return true;
        }
        if (!speculative) {
          return this.recog.sempred(void 0, ruleIndex, predIndex);
        }
        let savedCharPositionInLine = this._charPositionInLine;
        let savedLine = this._line;
        let index2 = input.index;
        let marker = input.mark();
        try {
          this.consume(input);
          return this.recog.sempred(void 0, ruleIndex, predIndex);
        } finally {
          this._charPositionInLine = savedCharPositionInLine;
          this._line = savedLine;
          input.seek(index2);
          input.release(marker);
        }
      }
      captureSimState(settings, input, dfaState) {
        settings.index = input.index;
        settings.line = this._line;
        settings.charPos = this._charPositionInLine;
        settings.dfaState = dfaState;
      }
      addDFAEdge(p, t, q) {
        if (q instanceof ATNConfigSet_1.ATNConfigSet) {
          let suppressEdge = q.hasSemanticContext;
          if (suppressEdge) {
            q.hasSemanticContext = false;
          }
          let to = this.addDFAState(q);
          if (suppressEdge) {
            return to;
          }
          this.addDFAEdge(p, t, to);
          return to;
        } else {
          if (LexerATNSimulator3.debug) {
            console.log("EDGE " + p + " -> " + q + " upon " + String.fromCharCode(t));
          }
          if (p != null) {
            p.setTarget(t, q);
          }
        }
      }
      addDFAState(configs) {
        assert(!configs.hasSemanticContext);
        let proposed = new DFAState_1.DFAState(configs);
        let existing = this.atn.modeToDFA[this.mode].states.get(proposed);
        if (existing != null) {
          return existing;
        }
        configs.optimizeConfigs(this);
        let newState = new DFAState_1.DFAState(configs.clone(true));
        let firstConfigWithRuleStopState;
        for (let c of configs) {
          if (c.state instanceof RuleStopState_1.RuleStopState) {
            firstConfigWithRuleStopState = c;
            break;
          }
        }
        if (firstConfigWithRuleStopState != null) {
          let prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
          let lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(prediction, lexerActionExecutor);
        }
        return this.atn.modeToDFA[this.mode].addState(newState);
      }
      getDFA(mode) {
        return this.atn.modeToDFA[mode];
      }
      getText(input) {
        return input.getText(Interval_1.Interval.of(this.startIndex, input.index - 1));
      }
      get line() {
        return this._line;
      }
      set line(line) {
        this._line = line;
      }
      get charPositionInLine() {
        return this._charPositionInLine;
      }
      set charPositionInLine(charPositionInLine) {
        this._charPositionInLine = charPositionInLine;
      }
      consume(input) {
        let curChar = input.LA(1);
        if (curChar === "\n".charCodeAt(0)) {
          this._line++;
          this._charPositionInLine = 0;
        } else {
          this._charPositionInLine++;
        }
        input.consume();
      }
      getTokenName(t) {
        if (t === -1) {
          return "EOF";
        }
        return "'" + String.fromCharCode(t) + "'";
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator2.prototype, "prevAccept", void 0);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "copyState", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "match", null);
    __decorate([
      Decorators_1.Override
    ], LexerATNSimulator2.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "matchATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "execATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "computeTargetState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getReachableConfigSet", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "accept", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "computeStartState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "closure", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getEpsilonTarget", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "evaluatePredicate", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "captureSimState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "addDFAState", null);
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator2.prototype, "getDFA", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "getText", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2.prototype, "consume", null);
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator2.prototype, "getTokenName", null);
    LexerATNSimulator2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator2);
    exports.LexerATNSimulator = LexerATNSimulator2;
    (function(LexerATNSimulator3) {
      LexerATNSimulator3.debug = false;
      LexerATNSimulator3.dfa_debug = false;
      class SimState {
        constructor() {
          this.index = -1;
          this.line = 0;
          this.charPos = -1;
        }
        reset() {
          this.index = -1;
          this.line = 0;
          this.charPos = -1;
          this.dfaState = void 0;
        }
      }
      LexerATNSimulator3.SimState = SimState;
    })(LexerATNSimulator2 = exports.LexerATNSimulator || (exports.LexerATNSimulator = {}));
    exports.LexerATNSimulator = LexerATNSimulator2;
  }
});

// node_modules/antlr4ts/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/antlr4ts/Lexer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lexer = void 0;
    var CommonTokenFactory_1 = require_CommonTokenFactory();
    var IntegerStack_1 = require_IntegerStack();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var Decorators_1 = require_Decorators();
    var Recognizer_1 = require_Recognizer();
    var Token_1 = require_Token();
    var Lexer2 = class extends Recognizer_1.Recognizer {
      constructor(input) {
        super();
        this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
        this._tokenStartCharIndex = -1;
        this._tokenStartLine = 0;
        this._tokenStartCharPositionInLine = 0;
        this._hitEOF = false;
        this._channel = 0;
        this._type = 0;
        this._modeStack = new IntegerStack_1.IntegerStack();
        this._mode = Lexer2.DEFAULT_MODE;
        this._input = input;
        this._tokenFactorySourcePair = { source: this, stream: input };
      }
      static get DEFAULT_TOKEN_CHANNEL() {
        return Token_1.Token.DEFAULT_CHANNEL;
      }
      static get HIDDEN() {
        return Token_1.Token.HIDDEN_CHANNEL;
      }
      reset(resetInput) {
        if (resetInput === void 0 || resetInput) {
          this._input.seek(0);
        }
        this._token = void 0;
        this._type = Token_1.Token.INVALID_TYPE;
        this._channel = Token_1.Token.DEFAULT_CHANNEL;
        this._tokenStartCharIndex = -1;
        this._tokenStartCharPositionInLine = -1;
        this._tokenStartLine = -1;
        this._text = void 0;
        this._hitEOF = false;
        this._mode = Lexer2.DEFAULT_MODE;
        this._modeStack.clear();
        this.interpreter.reset();
      }
      nextToken() {
        if (this._input == null) {
          throw new Error("nextToken requires a non-null input stream.");
        }
        let tokenStartMarker = this._input.mark();
        try {
          outer:
            while (true) {
              if (this._hitEOF) {
                return this.emitEOF();
              }
              this._token = void 0;
              this._channel = Token_1.Token.DEFAULT_CHANNEL;
              this._tokenStartCharIndex = this._input.index;
              this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;
              this._tokenStartLine = this.interpreter.line;
              this._text = void 0;
              do {
                this._type = Token_1.Token.INVALID_TYPE;
                let ttype;
                try {
                  ttype = this.interpreter.match(this._input, this._mode);
                } catch (e) {
                  if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
                    this.notifyListeners(e);
                    this.recover(e);
                    ttype = Lexer2.SKIP;
                  } else {
                    throw e;
                  }
                }
                if (this._input.LA(1) === IntStream_1.IntStream.EOF) {
                  this._hitEOF = true;
                }
                if (this._type === Token_1.Token.INVALID_TYPE) {
                  this._type = ttype;
                }
                if (this._type === Lexer2.SKIP) {
                  continue outer;
                }
              } while (this._type === Lexer2.MORE);
              if (this._token == null) {
                return this.emit();
              }
              return this._token;
            }
        } finally {
          this._input.release(tokenStartMarker);
        }
      }
      skip() {
        this._type = Lexer2.SKIP;
      }
      more() {
        this._type = Lexer2.MORE;
      }
      mode(m) {
        this._mode = m;
      }
      pushMode(m) {
        if (LexerATNSimulator_1.LexerATNSimulator.debug) {
          console.log("pushMode " + m);
        }
        this._modeStack.push(this._mode);
        this.mode(m);
      }
      popMode() {
        if (this._modeStack.isEmpty) {
          throw new Error("EmptyStackException");
        }
        if (LexerATNSimulator_1.LexerATNSimulator.debug) {
          console.log("popMode back to " + this._modeStack.peek());
        }
        this.mode(this._modeStack.pop());
        return this._mode;
      }
      get tokenFactory() {
        return this._factory;
      }
      set tokenFactory(factory) {
        this._factory = factory;
      }
      get inputStream() {
        return this._input;
      }
      set inputStream(input) {
        this.reset(false);
        this._input = input;
        this._tokenFactorySourcePair = { source: this, stream: this._input };
      }
      get sourceName() {
        return this._input.sourceName;
      }
      emit(token) {
        if (!token) {
          token = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine);
        }
        this._token = token;
        return token;
      }
      emitEOF() {
        let cpos = this.charPositionInLine;
        let line = this.line;
        let eof = this._factory.create(this._tokenFactorySourcePair, Token_1.Token.EOF, void 0, Token_1.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, line, cpos);
        this.emit(eof);
        return eof;
      }
      get line() {
        return this.interpreter.line;
      }
      set line(line) {
        this.interpreter.line = line;
      }
      get charPositionInLine() {
        return this.interpreter.charPositionInLine;
      }
      set charPositionInLine(charPositionInLine) {
        this.interpreter.charPositionInLine = charPositionInLine;
      }
      get charIndex() {
        return this._input.index;
      }
      get text() {
        if (this._text != null) {
          return this._text;
        }
        return this.interpreter.getText(this._input);
      }
      set text(text4) {
        this._text = text4;
      }
      get token() {
        return this._token;
      }
      set token(_token) {
        this._token = _token;
      }
      set type(ttype) {
        this._type = ttype;
      }
      get type() {
        return this._type;
      }
      set channel(channel) {
        this._channel = channel;
      }
      get channel() {
        return this._channel;
      }
      getAllTokens() {
        let tokens = [];
        let t = this.nextToken();
        while (t.type !== Token_1.Token.EOF) {
          tokens.push(t);
          t = this.nextToken();
        }
        return tokens;
      }
      notifyListeners(e) {
        let text4 = this._input.getText(Interval_1.Interval.of(this._tokenStartCharIndex, this._input.index));
        let msg = "token recognition error at: '" + this.getErrorDisplay(text4) + "'";
        let listener = this.getErrorListenerDispatch();
        if (listener.syntaxError) {
          listener.syntaxError(this, void 0, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);
        }
      }
      getErrorDisplay(s) {
        if (typeof s === "number") {
          switch (s) {
            case Token_1.Token.EOF:
              return "<EOF>";
            case 10:
              return "\\n";
            case 9:
              return "\\t";
            case 13:
              return "\\r";
          }
          return String.fromCharCode(s);
        }
        return s.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
      }
      getCharErrorDisplay(c) {
        let s = this.getErrorDisplay(c);
        return "'" + s + "'";
      }
      recover(re) {
        if (re instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
          if (this._input.LA(1) !== IntStream_1.IntStream.EOF) {
            this.interpreter.consume(this._input);
          }
        } else {
          this._input.consume();
        }
      }
    };
    Lexer2.DEFAULT_MODE = 0;
    Lexer2.MORE = -2;
    Lexer2.SKIP = -3;
    Lexer2.MIN_CHAR_VALUE = 0;
    Lexer2.MAX_CHAR_VALUE = 1114111;
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "nextToken", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "tokenFactory", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], Lexer2.prototype, "charPositionInLine", null);
    exports.Lexer = Lexer2;
  }
});

// node_modules/antlr4ts/misc/IntervalSet.js
var require_IntervalSet = __commonJS({
  "node_modules/antlr4ts/misc/IntervalSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntervalSet = void 0;
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var IntegerList_1 = require_IntegerList();
    var Interval_1 = require_Interval();
    var Lexer_1 = require_Lexer();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var IntervalSet = class {
      constructor(intervals) {
        this.readonly = false;
        if (intervals != null) {
          this._intervals = intervals.slice(0);
        } else {
          this._intervals = [];
        }
      }
      static get COMPLETE_CHAR_SET() {
        if (IntervalSet._COMPLETE_CHAR_SET === void 0) {
          IntervalSet._COMPLETE_CHAR_SET = IntervalSet.of(Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE);
          IntervalSet._COMPLETE_CHAR_SET.setReadonly(true);
        }
        return IntervalSet._COMPLETE_CHAR_SET;
      }
      static get EMPTY_SET() {
        if (IntervalSet._EMPTY_SET == null) {
          IntervalSet._EMPTY_SET = new IntervalSet();
          IntervalSet._EMPTY_SET.setReadonly(true);
        }
        return IntervalSet._EMPTY_SET;
      }
      static of(a, b = a) {
        let s = new IntervalSet();
        s.add(a, b);
        return s;
      }
      clear() {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        this._intervals.length = 0;
      }
      add(a, b = a) {
        this.addRange(Interval_1.Interval.of(a, b));
      }
      addRange(addition) {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        if (addition.b < addition.a) {
          return;
        }
        for (let i = 0; i < this._intervals.length; i++) {
          let r = this._intervals[i];
          if (addition.equals(r)) {
            return;
          }
          if (addition.adjacent(r) || !addition.disjoint(r)) {
            let bigger = addition.union(r);
            this._intervals[i] = bigger;
            while (i < this._intervals.length - 1) {
              i++;
              let next = this._intervals[i];
              if (!bigger.adjacent(next) && bigger.disjoint(next)) {
                break;
              }
              this._intervals.splice(i, 1);
              i--;
              this._intervals[i] = bigger.union(next);
            }
            return;
          }
          if (addition.startsBeforeDisjoint(r)) {
            this._intervals.splice(i, 0, addition);
            return;
          }
        }
        this._intervals.push(addition);
      }
      static or(sets) {
        let r = new IntervalSet();
        for (let s of sets) {
          r.addAll(s);
        }
        return r;
      }
      addAll(set) {
        if (set == null) {
          return this;
        }
        if (set instanceof IntervalSet) {
          let other = set;
          let n = other._intervals.length;
          for (let i = 0; i < n; i++) {
            let I = other._intervals[i];
            this.add(I.a, I.b);
          }
        } else {
          for (let value2 of set.toArray()) {
            this.add(value2);
          }
        }
        return this;
      }
      complementRange(minElement, maxElement) {
        return this.complement(IntervalSet.of(minElement, maxElement));
      }
      complement(vocabulary) {
        if (vocabulary.isNil) {
          return IntervalSet.EMPTY_SET;
        }
        let vocabularyIS;
        if (vocabulary instanceof IntervalSet) {
          vocabularyIS = vocabulary;
        } else {
          vocabularyIS = new IntervalSet();
          vocabularyIS.addAll(vocabulary);
        }
        return vocabularyIS.subtract(this);
      }
      subtract(a) {
        if (a == null || a.isNil) {
          return new IntervalSet(this._intervals);
        }
        if (a instanceof IntervalSet) {
          return IntervalSet.subtract(this, a);
        }
        let other = new IntervalSet();
        other.addAll(a);
        return IntervalSet.subtract(this, other);
      }
      static subtract(left, right) {
        if (left.isNil) {
          return new IntervalSet();
        }
        let result = new IntervalSet(left._intervals);
        if (right.isNil) {
          return result;
        }
        let resultI = 0;
        let rightI = 0;
        while (resultI < result._intervals.length && rightI < right._intervals.length) {
          let resultInterval = result._intervals[resultI];
          let rightInterval = right._intervals[rightI];
          if (rightInterval.b < resultInterval.a) {
            rightI++;
            continue;
          }
          if (rightInterval.a > resultInterval.b) {
            resultI++;
            continue;
          }
          let beforeCurrent;
          let afterCurrent;
          if (rightInterval.a > resultInterval.a) {
            beforeCurrent = new Interval_1.Interval(resultInterval.a, rightInterval.a - 1);
          }
          if (rightInterval.b < resultInterval.b) {
            afterCurrent = new Interval_1.Interval(rightInterval.b + 1, resultInterval.b);
          }
          if (beforeCurrent) {
            if (afterCurrent) {
              result._intervals[resultI] = beforeCurrent;
              result._intervals.splice(resultI + 1, 0, afterCurrent);
              resultI++;
              rightI++;
              continue;
            } else {
              result._intervals[resultI] = beforeCurrent;
              resultI++;
              continue;
            }
          } else {
            if (afterCurrent) {
              result._intervals[resultI] = afterCurrent;
              rightI++;
              continue;
            } else {
              result._intervals.splice(resultI, 1);
              continue;
            }
          }
        }
        return result;
      }
      or(a) {
        let o = new IntervalSet();
        o.addAll(this);
        o.addAll(a);
        return o;
      }
      and(other) {
        if (other.isNil) {
          return new IntervalSet();
        }
        let myIntervals = this._intervals;
        let theirIntervals = other._intervals;
        let intersection;
        let mySize = myIntervals.length;
        let theirSize = theirIntervals.length;
        let i = 0;
        let j = 0;
        while (i < mySize && j < theirSize) {
          let mine = myIntervals[i];
          let theirs = theirIntervals[j];
          if (mine.startsBeforeDisjoint(theirs)) {
            i++;
          } else if (theirs.startsBeforeDisjoint(mine)) {
            j++;
          } else if (mine.properlyContains(theirs)) {
            if (!intersection) {
              intersection = new IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            j++;
          } else if (theirs.properlyContains(mine)) {
            if (!intersection) {
              intersection = new IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            i++;
          } else if (!mine.disjoint(theirs)) {
            if (!intersection) {
              intersection = new IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            if (mine.startsAfterNonDisjoint(theirs)) {
              j++;
            } else if (theirs.startsAfterNonDisjoint(mine)) {
              i++;
            }
          }
        }
        if (!intersection) {
          return new IntervalSet();
        }
        return intersection;
      }
      contains(el) {
        let n = this._intervals.length;
        let l = 0;
        let r = n - 1;
        while (l <= r) {
          let m = l + r >> 1;
          let I = this._intervals[m];
          let a = I.a;
          let b = I.b;
          if (b < el) {
            l = m + 1;
          } else if (a > el) {
            r = m - 1;
          } else {
            return true;
          }
        }
        return false;
      }
      get isNil() {
        return this._intervals == null || this._intervals.length === 0;
      }
      get maxElement() {
        if (this.isNil) {
          throw new RangeError("set is empty");
        }
        let last = this._intervals[this._intervals.length - 1];
        return last.b;
      }
      get minElement() {
        if (this.isNil) {
          throw new RangeError("set is empty");
        }
        return this._intervals[0].a;
      }
      get intervals() {
        return this._intervals;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let I of this._intervals) {
          hash = MurmurHash_1.MurmurHash.update(hash, I.a);
          hash = MurmurHash_1.MurmurHash.update(hash, I.b);
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, this._intervals.length * 2);
        return hash;
      }
      equals(o) {
        if (o == null || !(o instanceof IntervalSet)) {
          return false;
        }
        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);
      }
      toString(elemAreChar = false) {
        let buf = "";
        if (this._intervals == null || this._intervals.length === 0) {
          return "{}";
        }
        if (this.size > 1) {
          buf += "{";
        }
        let first = true;
        for (let I of this._intervals) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          let a = I.a;
          let b = I.b;
          if (a === b) {
            if (a === Token_1.Token.EOF) {
              buf += "<EOF>";
            } else if (elemAreChar) {
              buf += "'" + String.fromCodePoint(a) + "'";
            } else {
              buf += a;
            }
          } else {
            if (elemAreChar) {
              buf += "'" + String.fromCodePoint(a) + "'..'" + String.fromCodePoint(b) + "'";
            } else {
              buf += a + ".." + b;
            }
          }
        }
        if (this.size > 1) {
          buf += "}";
        }
        return buf;
      }
      toStringVocabulary(vocabulary) {
        if (this._intervals == null || this._intervals.length === 0) {
          return "{}";
        }
        let buf = "";
        if (this.size > 1) {
          buf += "{";
        }
        let first = true;
        for (let I of this._intervals) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          let a = I.a;
          let b = I.b;
          if (a === b) {
            buf += this.elementName(vocabulary, a);
          } else {
            for (let i = a; i <= b; i++) {
              if (i > a) {
                buf += ", ";
              }
              buf += this.elementName(vocabulary, i);
            }
          }
        }
        if (this.size > 1) {
          buf += "}";
        }
        return buf;
      }
      elementName(vocabulary, a) {
        if (a === Token_1.Token.EOF) {
          return "<EOF>";
        } else if (a === Token_1.Token.EPSILON) {
          return "<EPSILON>";
        } else {
          return vocabulary.getDisplayName(a);
        }
      }
      get size() {
        let n = 0;
        let numIntervals = this._intervals.length;
        if (numIntervals === 1) {
          let firstInterval = this._intervals[0];
          return firstInterval.b - firstInterval.a + 1;
        }
        for (let i = 0; i < numIntervals; i++) {
          let I = this._intervals[i];
          n += I.b - I.a + 1;
        }
        return n;
      }
      toIntegerList() {
        let values = new IntegerList_1.IntegerList(this.size);
        let n = this._intervals.length;
        for (let i = 0; i < n; i++) {
          let I = this._intervals[i];
          let a = I.a;
          let b = I.b;
          for (let v = a; v <= b; v++) {
            values.add(v);
          }
        }
        return values;
      }
      toSet() {
        let s = /* @__PURE__ */ new Set();
        for (let I of this._intervals) {
          let a = I.a;
          let b = I.b;
          for (let v = a; v <= b; v++) {
            s.add(v);
          }
        }
        return s;
      }
      toArray() {
        let values = new Array();
        let n = this._intervals.length;
        for (let i = 0; i < n; i++) {
          let I = this._intervals[i];
          let a = I.a;
          let b = I.b;
          for (let v = a; v <= b; v++) {
            values.push(v);
          }
        }
        return values;
      }
      remove(el) {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        let n = this._intervals.length;
        for (let i = 0; i < n; i++) {
          let I = this._intervals[i];
          let a = I.a;
          let b = I.b;
          if (el < a) {
            break;
          }
          if (el === a && el === b) {
            this._intervals.splice(i, 1);
            break;
          }
          if (el === a) {
            this._intervals[i] = Interval_1.Interval.of(I.a + 1, I.b);
            break;
          }
          if (el === b) {
            this._intervals[i] = Interval_1.Interval.of(I.a, I.b - 1);
            break;
          }
          if (el > a && el < b) {
            let oldb = I.b;
            this._intervals[i] = Interval_1.Interval.of(I.a, el - 1);
            this.add(el + 1, oldb);
          }
        }
      }
      get isReadonly() {
        return this.readonly;
      }
      setReadonly(readonly) {
        if (this.readonly && !readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        this.readonly = readonly;
      }
    };
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "addAll", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "complement", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "subtract", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "or", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "and", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "contains", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "isNil", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "equals", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], IntervalSet.prototype, "toStringVocabulary", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], IntervalSet.prototype, "elementName", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "remove", null);
    __decorate([
      Decorators_1.NotNull
    ], IntervalSet, "of", null);
    __decorate([
      Decorators_1.NotNull
    ], IntervalSet, "subtract", null);
    exports.IntervalSet = IntervalSet;
  }
});

// node_modules/antlr4ts/atn/ATNDeserializationOptions.js
var require_ATNDeserializationOptions = __commonJS({
  "node_modules/antlr4ts/atn/ATNDeserializationOptions.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNDeserializationOptions = void 0;
    var Decorators_1 = require_Decorators();
    var ATNDeserializationOptions = class {
      constructor(options) {
        this.readOnly = false;
        if (options) {
          this.verifyATN = options.verifyATN;
          this.generateRuleBypassTransitions = options.generateRuleBypassTransitions;
          this.optimize = options.optimize;
        } else {
          this.verifyATN = true;
          this.generateRuleBypassTransitions = false;
          this.optimize = true;
        }
      }
      static get defaultOptions() {
        if (ATNDeserializationOptions._defaultOptions == null) {
          ATNDeserializationOptions._defaultOptions = new ATNDeserializationOptions();
          ATNDeserializationOptions._defaultOptions.makeReadOnly();
        }
        return ATNDeserializationOptions._defaultOptions;
      }
      get isReadOnly() {
        return this.readOnly;
      }
      makeReadOnly() {
        this.readOnly = true;
      }
      get isVerifyATN() {
        return this.verifyATN;
      }
      set isVerifyATN(verifyATN) {
        this.throwIfReadOnly();
        this.verifyATN = verifyATN;
      }
      get isGenerateRuleBypassTransitions() {
        return this.generateRuleBypassTransitions;
      }
      set isGenerateRuleBypassTransitions(generateRuleBypassTransitions) {
        this.throwIfReadOnly();
        this.generateRuleBypassTransitions = generateRuleBypassTransitions;
      }
      get isOptimize() {
        return this.optimize;
      }
      set isOptimize(optimize) {
        this.throwIfReadOnly();
        this.optimize = optimize;
      }
      throwIfReadOnly() {
        if (this.isReadOnly) {
          throw new Error("The object is read only.");
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNDeserializationOptions, "defaultOptions", null);
    exports.ATNDeserializationOptions = ATNDeserializationOptions;
  }
});

// node_modules/antlr4ts/atn/ActionTransition.js
var require_ActionTransition = __commonJS({
  "node_modules/antlr4ts/atn/ActionTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var ActionTransition = class ActionTransition extends Transition_1.Transition {
      constructor(target, ruleIndex, actionIndex = -1, isCtxDependent = false) {
        super(target);
        this.ruleIndex = ruleIndex;
        this.actionIndex = actionIndex;
        this.isCtxDependent = isCtxDependent;
      }
      get serializationType() {
        return 6;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      toString() {
        return "action_" + this.ruleIndex + ":" + this.actionIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "toString", null);
    ActionTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ActionTransition);
    exports.ActionTransition = ActionTransition;
  }
});

// node_modules/antlr4ts/atn/AtomTransition.js
var require_AtomTransition = __commonJS({
  "node_modules/antlr4ts/atn/AtomTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AtomTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var AtomTransition = class AtomTransition extends Transition_1.Transition {
      constructor(target, label) {
        super(target);
        this._label = label;
      }
      get serializationType() {
        return 5;
      }
      get label() {
        return IntervalSet_1.IntervalSet.of(this._label);
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this._label === symbol;
      }
      toString() {
        return String(this.label);
      }
    };
    __decorate([
      Decorators_1.Override
    ], AtomTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], AtomTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], AtomTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], AtomTransition.prototype, "toString", null);
    AtomTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], AtomTransition);
    exports.AtomTransition = AtomTransition;
  }
});

// node_modules/antlr4ts/atn/BlockStartState.js
var require_BlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/BlockStartState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockStartState = void 0;
    var DecisionState_1 = require_DecisionState();
    var BlockStartState = class extends DecisionState_1.DecisionState {
    };
    exports.BlockStartState = BlockStartState;
  }
});

// node_modules/antlr4ts/atn/BasicBlockStartState.js
var require_BasicBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/BasicBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var BasicBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BasicBlockStartState.prototype, "stateType", null);
    exports.BasicBlockStartState = BasicBlockStartState;
  }
});

// node_modules/antlr4ts/atn/BlockEndState.js
var require_BlockEndState = __commonJS({
  "node_modules/antlr4ts/atn/BlockEndState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockEndState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var BlockEndState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BLOCK_END;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BlockEndState.prototype, "stateType", null);
    exports.BlockEndState = BlockEndState;
  }
});

// node_modules/antlr4ts/atn/EpsilonTransition.js
var require_EpsilonTransition = __commonJS({
  "node_modules/antlr4ts/atn/EpsilonTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EpsilonTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var EpsilonTransition = class EpsilonTransition extends Transition_1.Transition {
      constructor(target, outermostPrecedenceReturn = -1) {
        super(target);
        this._outermostPrecedenceReturn = outermostPrecedenceReturn;
      }
      get outermostPrecedenceReturn() {
        return this._outermostPrecedenceReturn;
      }
      get serializationType() {
        return 1;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      toString() {
        return "epsilon";
      }
    };
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], EpsilonTransition.prototype, "toString", null);
    EpsilonTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], EpsilonTransition);
    exports.EpsilonTransition = EpsilonTransition;
  }
});

// node_modules/antlr4ts/atn/LexerChannelAction.js
var require_LexerChannelAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerChannelAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerChannelAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerChannelAction = class {
      constructor(channel) {
        this._channel = channel;
      }
      get channel() {
        return this._channel;
      }
      get actionType() {
        return 0;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.channel = this._channel;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._channel);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerChannelAction)) {
          return false;
        }
        return this._channel === obj._channel;
      }
      toString() {
        return `channel(${this._channel})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerChannelAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "toString", null);
    exports.LexerChannelAction = LexerChannelAction;
  }
});

// node_modules/antlr4ts/atn/LexerCustomAction.js
var require_LexerCustomAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerCustomAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerCustomAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerCustomAction = class {
      constructor(ruleIndex, actionIndex) {
        this._ruleIndex = ruleIndex;
        this._actionIndex = actionIndex;
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
      get actionIndex() {
        return this._actionIndex;
      }
      get actionType() {
        return 1;
      }
      get isPositionDependent() {
        return true;
      }
      execute(lexer) {
        lexer.action(void 0, this._ruleIndex, this._actionIndex);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._ruleIndex);
        hash = MurmurHash_1.MurmurHash.update(hash, this._actionIndex);
        return MurmurHash_1.MurmurHash.finish(hash, 3);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerCustomAction)) {
          return false;
        }
        return this._ruleIndex === obj._ruleIndex && this._actionIndex === obj._actionIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerCustomAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "equals", null);
    exports.LexerCustomAction = LexerCustomAction;
  }
});

// node_modules/antlr4ts/atn/LexerModeAction.js
var require_LexerModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerModeAction = class {
      constructor(mode) {
        this._mode = mode;
      }
      get mode() {
        return this._mode;
      }
      get actionType() {
        return 2;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.mode(this._mode);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerModeAction)) {
          return false;
        }
        return this._mode === obj._mode;
      }
      toString() {
        return `mode(${this._mode})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "toString", null);
    exports.LexerModeAction = LexerModeAction;
  }
});

// node_modules/antlr4ts/atn/LexerMoreAction.js
var require_LexerMoreAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerMoreAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerMoreAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerMoreAction = class {
      constructor() {
      }
      get actionType() {
        return 3;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.more();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "more";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerMoreAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "toString", null);
    exports.LexerMoreAction = LexerMoreAction;
    (function(LexerMoreAction2) {
      LexerMoreAction2.INSTANCE = new LexerMoreAction2();
    })(LexerMoreAction = exports.LexerMoreAction || (exports.LexerMoreAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerPopModeAction.js
var require_LexerPopModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerPopModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerPopModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerPopModeAction = class {
      constructor() {
      }
      get actionType() {
        return 4;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.popMode();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "popMode";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerPopModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "toString", null);
    exports.LexerPopModeAction = LexerPopModeAction;
    (function(LexerPopModeAction2) {
      LexerPopModeAction2.INSTANCE = new LexerPopModeAction2();
    })(LexerPopModeAction = exports.LexerPopModeAction || (exports.LexerPopModeAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerPushModeAction.js
var require_LexerPushModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerPushModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerPushModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerPushModeAction = class {
      constructor(mode) {
        this._mode = mode;
      }
      get mode() {
        return this._mode;
      }
      get actionType() {
        return 5;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.pushMode(this._mode);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerPushModeAction)) {
          return false;
        }
        return this._mode === obj._mode;
      }
      toString() {
        return `pushMode(${this._mode})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerPushModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "toString", null);
    exports.LexerPushModeAction = LexerPushModeAction;
  }
});

// node_modules/antlr4ts/atn/LexerSkipAction.js
var require_LexerSkipAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerSkipAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerSkipAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerSkipAction = class {
      constructor() {
      }
      get actionType() {
        return 6;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.skip();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "skip";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerSkipAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "toString", null);
    exports.LexerSkipAction = LexerSkipAction;
    (function(LexerSkipAction2) {
      LexerSkipAction2.INSTANCE = new LexerSkipAction2();
    })(LexerSkipAction = exports.LexerSkipAction || (exports.LexerSkipAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerTypeAction.js
var require_LexerTypeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerTypeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerTypeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerTypeAction = class {
      constructor(type) {
        this._type = type;
      }
      get type() {
        return this._type;
      }
      get actionType() {
        return 7;
      }
      get isPositionDependent() {
        return false;
      }
      execute(lexer) {
        lexer.type = this._type;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._type);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerTypeAction)) {
          return false;
        }
        return this._type === obj._type;
      }
      toString() {
        return `type(${this._type})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerTypeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "toString", null);
    exports.LexerTypeAction = LexerTypeAction;
  }
});

// node_modules/antlr4ts/atn/LoopEndState.js
var require_LoopEndState = __commonJS({
  "node_modules/antlr4ts/atn/LoopEndState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoopEndState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var LoopEndState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.LOOP_END;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LoopEndState.prototype, "stateType", null);
    exports.LoopEndState = LoopEndState;
  }
});

// node_modules/antlr4ts/atn/ConflictInfo.js
var require_ConflictInfo = __commonJS({
  "node_modules/antlr4ts/atn/ConflictInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConflictInfo = void 0;
    var Decorators_1 = require_Decorators();
    var Utils3 = require_Utils();
    var ConflictInfo = class {
      constructor(conflictedAlts, exact) {
        this._conflictedAlts = conflictedAlts;
        this.exact = exact;
      }
      get conflictedAlts() {
        return this._conflictedAlts;
      }
      get isExact() {
        return this.exact;
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof ConflictInfo)) {
          return false;
        }
        return this.isExact === obj.isExact && Utils3.equals(this.conflictedAlts, obj.conflictedAlts);
      }
      hashCode() {
        return this.conflictedAlts.hashCode();
      }
    };
    __decorate([
      Decorators_1.Override
    ], ConflictInfo.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ConflictInfo.prototype, "hashCode", null);
    exports.ConflictInfo = ConflictInfo;
  }
});

// node_modules/antlr4ts/tree/TerminalNode.js
var require_TerminalNode = __commonJS({
  "node_modules/antlr4ts/tree/TerminalNode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TerminalNode = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var TerminalNode = class {
      constructor(symbol) {
        this._symbol = symbol;
      }
      getChild(i) {
        throw new RangeError("Terminal Node has no children.");
      }
      get symbol() {
        return this._symbol;
      }
      get parent() {
        return this._parent;
      }
      setParent(parent) {
        this._parent = parent;
      }
      get payload() {
        return this._symbol;
      }
      get sourceInterval() {
        let tokenIndex = this._symbol.tokenIndex;
        return new Interval_1.Interval(tokenIndex, tokenIndex);
      }
      get childCount() {
        return 0;
      }
      accept(visitor) {
        return visitor.visitTerminal(this);
      }
      get text() {
        return this._symbol.text || "";
      }
      toStringTree(parser) {
        return this.toString();
      }
      toString() {
        if (this._symbol.type === Token_1.Token.EOF) {
          return "<EOF>";
        }
        return this._symbol.text || "";
      }
    };
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "getChild", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "setParent", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "payload", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "sourceInterval", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "accept", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "toStringTree", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "toString", null);
    exports.TerminalNode = TerminalNode;
  }
});

// node_modules/antlr4ts/tree/ErrorNode.js
var require_ErrorNode = __commonJS({
  "node_modules/antlr4ts/tree/ErrorNode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorNode = void 0;
    var Decorators_1 = require_Decorators();
    var TerminalNode_1 = require_TerminalNode();
    var ErrorNode = class extends TerminalNode_1.TerminalNode {
      constructor(token) {
        super(token);
      }
      accept(visitor) {
        return visitor.visitErrorNode(this);
      }
    };
    __decorate([
      Decorators_1.Override
    ], ErrorNode.prototype, "accept", null);
    exports.ErrorNode = ErrorNode;
  }
});

// node_modules/antlr4ts/tree/RuleNode.js
var require_RuleNode = __commonJS({
  "node_modules/antlr4ts/tree/RuleNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleNode = void 0;
    var RuleNode = class {
    };
    exports.RuleNode = RuleNode;
  }
});

// node_modules/antlr4ts/tree/Trees.js
var require_Trees = __commonJS({
  "node_modules/antlr4ts/tree/Trees.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Trees = void 0;
    var ATN_1 = require_ATN();
    var CommonToken_1 = require_CommonToken();
    var ErrorNode_1 = require_ErrorNode();
    var Decorators_1 = require_Decorators();
    var Parser_1 = require_Parser();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleNode_1 = require_RuleNode();
    var TerminalNode_1 = require_TerminalNode();
    var Token_1 = require_Token();
    var Utils3 = require_Utils();
    var Trees = class {
      static toStringTree(t, arg2) {
        let ruleNames;
        if (arg2 instanceof Parser_1.Parser) {
          ruleNames = arg2.ruleNames;
        } else {
          ruleNames = arg2;
        }
        let s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
        if (t.childCount === 0) {
          return s;
        }
        let buf = "";
        buf += "(";
        s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
        buf += s;
        buf += " ";
        for (let i = 0; i < t.childCount; i++) {
          if (i > 0) {
            buf += " ";
          }
          buf += this.toStringTree(t.getChild(i), ruleNames);
        }
        buf += ")";
        return buf;
      }
      static getNodeText(t, arg2) {
        let ruleNames;
        if (arg2 instanceof Parser_1.Parser) {
          ruleNames = arg2.ruleNames;
        } else if (arg2) {
          ruleNames = arg2;
        } else {
          let payload = t.payload;
          if (typeof payload.text === "string") {
            return payload.text;
          }
          return t.payload.toString();
        }
        if (t instanceof RuleNode_1.RuleNode) {
          let ruleContext = t.ruleContext;
          let ruleIndex = ruleContext.ruleIndex;
          let ruleName = ruleNames[ruleIndex];
          let altNumber = ruleContext.altNumber;
          if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            return ruleName + ":" + altNumber;
          }
          return ruleName;
        } else if (t instanceof ErrorNode_1.ErrorNode) {
          return t.toString();
        } else if (t instanceof TerminalNode_1.TerminalNode) {
          let symbol = t.symbol;
          return symbol.text || "";
        }
        throw new TypeError("Unexpected node type");
      }
      static getChildren(t) {
        let kids = [];
        for (let i = 0; i < t.childCount; i++) {
          kids.push(t.getChild(i));
        }
        return kids;
      }
      static getAncestors(t) {
        let ancestors = [];
        let p = t.parent;
        while (p) {
          ancestors.unshift(p);
          p = p.parent;
        }
        return ancestors;
      }
      static isAncestorOf(t, u) {
        if (!t || !u || !t.parent) {
          return false;
        }
        let p = u.parent;
        while (p) {
          if (t === p) {
            return true;
          }
          p = p.parent;
        }
        return false;
      }
      static findAllTokenNodes(t, ttype) {
        return Trees.findAllNodes(t, ttype, true);
      }
      static findAllRuleNodes(t, ruleIndex) {
        return Trees.findAllNodes(t, ruleIndex, false);
      }
      static findAllNodes(t, index2, findTokens) {
        let nodes = [];
        Trees._findAllNodes(t, index2, findTokens, nodes);
        return nodes;
      }
      static _findAllNodes(t, index2, findTokens, nodes) {
        if (findTokens && t instanceof TerminalNode_1.TerminalNode) {
          if (t.symbol.type === index2) {
            nodes.push(t);
          }
        } else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {
          if (t.ruleIndex === index2) {
            nodes.push(t);
          }
        }
        for (let i = 0; i < t.childCount; i++) {
          Trees._findAllNodes(t.getChild(i), index2, findTokens, nodes);
        }
      }
      static getDescendants(t) {
        let nodes = [];
        function recurse(e) {
          nodes.push(e);
          const n = e.childCount;
          for (let i = 0; i < n; i++) {
            recurse(e.getChild(i));
          }
        }
        recurse(t);
        return nodes;
      }
      static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
        let n = t.childCount;
        for (let i = 0; i < n; i++) {
          let child = t.getChild(i);
          let r = Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
          if (r) {
            return r;
          }
        }
        if (t instanceof ParserRuleContext_1.ParserRuleContext) {
          let stopToken = t.stop;
          if (startTokenIndex >= t.start.tokenIndex && (stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {
            return t;
          }
        }
        return void 0;
      }
      static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
        if (!t) {
          return;
        }
        let count = t.childCount;
        for (let i = 0; i < count; i++) {
          let child = t.getChild(i);
          let range = child.sourceInterval;
          if (child instanceof ParserRuleContext_1.ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {
            if (Trees.isAncestorOf(child, root)) {
              let abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, "...");
              t.children[i] = new TerminalNode_1.TerminalNode(abbrev);
            }
          }
        }
      }
      static findNodeSuchThat(t, pred) {
        if (pred(t)) {
          return t;
        }
        let n = t.childCount;
        for (let i = 0; i < n; i++) {
          let u = Trees.findNodeSuchThat(t.getChild(i), pred);
          if (u !== void 0) {
            return u;
          }
        }
        return void 0;
      }
    };
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Trees, "toStringTree", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Trees, "getAncestors", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Trees, "getRootOfSubtreeEnclosingRegion", null);
    exports.Trees = Trees;
  }
});

// node_modules/antlr4ts/RuleContext.js
var require_RuleContext = __commonJS({
  "node_modules/antlr4ts/RuleContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleContext = void 0;
    var ATN_1 = require_ATN();
    var Recognizer_1 = require_Recognizer();
    var RuleNode_1 = require_RuleNode();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleContext = class extends RuleNode_1.RuleNode {
      constructor(parent, invokingState) {
        super();
        this._parent = parent;
        this.invokingState = invokingState != null ? invokingState : -1;
      }
      static getChildContext(parent, invokingState) {
        return new RuleContext(parent, invokingState);
      }
      depth() {
        let n = 0;
        let p = this;
        while (p) {
          p = p._parent;
          n++;
        }
        return n;
      }
      get isEmpty() {
        return this.invokingState === -1;
      }
      get sourceInterval() {
        return Interval_1.Interval.INVALID;
      }
      get ruleContext() {
        return this;
      }
      get parent() {
        return this._parent;
      }
      setParent(parent) {
        this._parent = parent;
      }
      get payload() {
        return this;
      }
      get text() {
        if (this.childCount === 0) {
          return "";
        }
        let builder = "";
        for (let i = 0; i < this.childCount; i++) {
          builder += this.getChild(i).text;
        }
        return builder.toString();
      }
      get ruleIndex() {
        return -1;
      }
      get altNumber() {
        return ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      set altNumber(altNumber) {
      }
      getChild(i) {
        throw new RangeError("i must be greater than or equal to 0 and less than childCount");
      }
      get childCount() {
        return 0;
      }
      accept(visitor) {
        return visitor.visitChildren(this);
      }
      toStringTree(recog) {
        return Trees_1.Trees.toStringTree(this, recog);
      }
      toString(arg1, stop) {
        const ruleNames = arg1 instanceof Recognizer_1.Recognizer ? arg1.ruleNames : arg1;
        stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();
        let buf = "";
        let p = this;
        buf += "[";
        while (p && p !== stop) {
          if (!ruleNames) {
            if (!p.isEmpty) {
              buf += p.invokingState;
            }
          } else {
            let ruleIndex = p.ruleIndex;
            let ruleName = ruleIndex >= 0 && ruleIndex < ruleNames.length ? ruleNames[ruleIndex] : ruleIndex.toString();
            buf += ruleName;
          }
          if (p._parent && (ruleNames || !p._parent.isEmpty)) {
            buf += " ";
          }
          p = p._parent;
        }
        buf += "]";
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "sourceInterval", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "ruleContext", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "setParent", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "payload", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "getChild", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "accept", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "toStringTree", null);
    exports.RuleContext = RuleContext;
  }
});

// node_modules/antlr4ts/ParserRuleContext.js
var require_ParserRuleContext = __commonJS({
  "node_modules/antlr4ts/ParserRuleContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserRuleContext = void 0;
    var ErrorNode_1 = require_ErrorNode();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var RuleContext_1 = require_RuleContext();
    var TerminalNode_1 = require_TerminalNode();
    var ParserRuleContext3 = class extends RuleContext_1.RuleContext {
      constructor(parent, invokingStateNumber) {
        if (invokingStateNumber == null) {
          super();
        } else {
          super(parent, invokingStateNumber);
        }
      }
      static emptyContext() {
        return ParserRuleContext3.EMPTY;
      }
      copyFrom(ctx) {
        this._parent = ctx._parent;
        this.invokingState = ctx.invokingState;
        this._start = ctx._start;
        this._stop = ctx._stop;
        if (ctx.children) {
          this.children = [];
          for (let child of ctx.children) {
            if (child instanceof ErrorNode_1.ErrorNode) {
              this.addChild(child);
            }
          }
        }
      }
      enterRule(listener) {
      }
      exitRule(listener) {
      }
      addAnyChild(t) {
        if (!this.children) {
          this.children = [t];
        } else {
          this.children.push(t);
        }
        return t;
      }
      addChild(t) {
        let result;
        if (t instanceof TerminalNode_1.TerminalNode) {
          t.setParent(this);
          this.addAnyChild(t);
          return;
        } else if (t instanceof RuleContext_1.RuleContext) {
          this.addAnyChild(t);
          return;
        } else {
          t = new TerminalNode_1.TerminalNode(t);
          this.addAnyChild(t);
          t.setParent(this);
          return t;
        }
      }
      addErrorNode(node) {
        if (node instanceof ErrorNode_1.ErrorNode) {
          const errorNode = node;
          errorNode.setParent(this);
          return this.addAnyChild(errorNode);
        } else {
          const badToken = node;
          let t = new ErrorNode_1.ErrorNode(badToken);
          this.addAnyChild(t);
          t.setParent(this);
          return t;
        }
      }
      removeLastChild() {
        if (this.children) {
          this.children.pop();
        }
      }
      get parent() {
        let parent = super.parent;
        if (parent === void 0 || parent instanceof ParserRuleContext3) {
          return parent;
        }
        throw new TypeError("Invalid parent type for ParserRuleContext");
      }
      getChild(i, ctxType) {
        if (!this.children || i < 0 || i >= this.children.length) {
          throw new RangeError("index parameter must be between >= 0 and <= number of children.");
        }
        if (ctxType == null) {
          return this.children[i];
        }
        let result = this.tryGetChild(i, ctxType);
        if (result === void 0) {
          throw new Error("The specified node does not exist");
        }
        return result;
      }
      tryGetChild(i, ctxType) {
        if (!this.children || i < 0 || i >= this.children.length) {
          return void 0;
        }
        let j = -1;
        for (let o of this.children) {
          if (o instanceof ctxType) {
            j++;
            if (j === i) {
              return o;
            }
          }
        }
        return void 0;
      }
      getToken(ttype, i) {
        let result = this.tryGetToken(ttype, i);
        if (result === void 0) {
          throw new Error("The specified token does not exist");
        }
        return result;
      }
      tryGetToken(ttype, i) {
        if (!this.children || i < 0 || i >= this.children.length) {
          return void 0;
        }
        let j = -1;
        for (let o of this.children) {
          if (o instanceof TerminalNode_1.TerminalNode) {
            let symbol = o.symbol;
            if (symbol.type === ttype) {
              j++;
              if (j === i) {
                return o;
              }
            }
          }
        }
        return void 0;
      }
      getTokens(ttype) {
        let tokens = [];
        if (!this.children) {
          return tokens;
        }
        for (let o of this.children) {
          if (o instanceof TerminalNode_1.TerminalNode) {
            let symbol = o.symbol;
            if (symbol.type === ttype) {
              tokens.push(o);
            }
          }
        }
        return tokens;
      }
      get ruleContext() {
        return this;
      }
      getRuleContext(i, ctxType) {
        return this.getChild(i, ctxType);
      }
      tryGetRuleContext(i, ctxType) {
        return this.tryGetChild(i, ctxType);
      }
      getRuleContexts(ctxType) {
        let contexts = [];
        if (!this.children) {
          return contexts;
        }
        for (let o of this.children) {
          if (o instanceof ctxType) {
            contexts.push(o);
          }
        }
        return contexts;
      }
      get childCount() {
        return this.children ? this.children.length : 0;
      }
      get sourceInterval() {
        if (!this._start) {
          return Interval_1.Interval.INVALID;
        }
        if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {
          return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1);
        }
        return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);
      }
      get start() {
        return this._start;
      }
      get stop() {
        return this._stop;
      }
      toInfoString(recognizer) {
        let rules = recognizer.getRuleInvocationStack(this).reverse();
        return "ParserRuleContext" + rules + "{start=" + this._start + ", stop=" + this._stop + "}";
      }
    };
    ParserRuleContext3.EMPTY = new ParserRuleContext3();
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext3.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext3.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext3.prototype, "sourceInterval", null);
    exports.ParserRuleContext = ParserRuleContext3;
  }
});

// node_modules/antlr4ts/atn/PredictionMode.js
var require_PredictionMode = __commonJS({
  "node_modules/antlr4ts/atn/PredictionMode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredictionMode = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var RuleStopState_1 = require_RuleStopState();
    var PredictionMode;
    (function(PredictionMode2) {
      PredictionMode2[PredictionMode2["SLL"] = 0] = "SLL";
      PredictionMode2[PredictionMode2["LL"] = 1] = "LL";
      PredictionMode2[PredictionMode2["LL_EXACT_AMBIG_DETECTION"] = 2] = "LL_EXACT_AMBIG_DETECTION";
    })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
    (function(PredictionMode2) {
      class AltAndContextMap extends Array2DHashMap_1.Array2DHashMap {
        constructor() {
          super(AltAndContextConfigEqualityComparator.INSTANCE);
        }
      }
      class AltAndContextConfigEqualityComparator {
        AltAndContextConfigEqualityComparator() {
        }
        hashCode(o) {
          let hashCode = MurmurHash_1.MurmurHash.initialize(7);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.state.stateNumber);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.context);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 2);
          return hashCode;
        }
        equals(a, b) {
          if (a === b) {
            return true;
          }
          if (a == null || b == null) {
            return false;
          }
          return a.state.stateNumber === b.state.stateNumber && a.context.equals(b.context);
        }
      }
      AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], AltAndContextConfigEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], AltAndContextConfigEqualityComparator.prototype, "equals", null);
      function hasConfigInRuleStopState(configs) {
        for (let c of configs) {
          if (c.state instanceof RuleStopState_1.RuleStopState) {
            return true;
          }
        }
        return false;
      }
      PredictionMode2.hasConfigInRuleStopState = hasConfigInRuleStopState;
      function allConfigsInRuleStopStates(configs) {
        for (let config of configs) {
          if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
            return false;
          }
        }
        return true;
      }
      PredictionMode2.allConfigsInRuleStopStates = allConfigsInRuleStopStates;
    })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
  }
});

// node_modules/antlr4ts/atn/SimulatorState.js
var require_SimulatorState = __commonJS({
  "node_modules/antlr4ts/atn/SimulatorState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimulatorState = void 0;
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var SimulatorState = class SimulatorState {
      constructor(outerContext, s0, useContext, remainingOuterContext) {
        this.outerContext = outerContext != null ? outerContext : ParserRuleContext_1.ParserRuleContext.emptyContext();
        this.s0 = s0;
        this.useContext = useContext;
        this.remainingOuterContext = remainingOuterContext;
      }
    };
    SimulatorState = __decorate([
      __param(1, Decorators_1.NotNull)
    ], SimulatorState);
    exports.SimulatorState = SimulatorState;
  }
});

// node_modules/antlr4ts/atn/ParserATNSimulator.js
var require_ParserATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ParserATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserATNSimulator = void 0;
    var AcceptStateInfo_1 = require_AcceptStateInfo();
    var ActionTransition_1 = require_ActionTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var Arrays_1 = require_Arrays();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var ATNSimulator_1 = require_ATNSimulator();
    var ATNStateType_1 = require_ATNStateType();
    var AtomTransition_1 = require_AtomTransition();
    var BitSet_1 = require_BitSet();
    var ConflictInfo_1 = require_ConflictInfo();
    var DecisionState_1 = require_DecisionState();
    var DFAState_1 = require_DFAState();
    var IntegerList_1 = require_IntegerList();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var NoViableAltException_1 = require_NoViableAltException();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var PredictionContext_1 = require_PredictionContext();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var PredictionMode_1 = require_PredictionMode();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var SemanticContext_1 = require_SemanticContext();
    var SetTransition_1 = require_SetTransition();
    var SimulatorState_1 = require_SimulatorState();
    var Token_1 = require_Token();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var assert = require("assert");
    var MAX_SHORT_VALUE = 65535;
    var MIN_INTEGER_VALUE = -(1 << 31 >>> 0);
    var ParserATNSimulator2 = class ParserATNSimulator3 extends ATNSimulator_1.ATNSimulator {
      constructor(atn, parser) {
        super(atn);
        this.predictionMode = PredictionMode_1.PredictionMode.LL;
        this.force_global_context = false;
        this.always_try_local_context = true;
        this.enable_global_context_dfa = false;
        this.optimize_unique_closure = true;
        this.optimize_ll1 = true;
        this.optimize_tail_calls = true;
        this.tail_call_preserves_sll = true;
        this.treat_sllk1_conflict_as_ambiguity = false;
        this.reportAmbiguities = false;
        this.userWantsCtxSensitive = true;
        this._parser = parser;
      }
      getPredictionMode() {
        return this.predictionMode;
      }
      setPredictionMode(predictionMode) {
        this.predictionMode = predictionMode;
      }
      reset() {
      }
      adaptivePredict(input, decision, outerContext, useContext) {
        if (useContext === void 0) {
          useContext = false;
        }
        let dfa = this.atn.decisionToDFA[decision];
        assert(dfa != null);
        if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {
          let ll_1 = input.LA(1);
          if (ll_1 >= 0 && ll_1 <= 65535) {
            let key = (decision << 16 >>> 0) + ll_1;
            let alt = this.atn.LL1Table.get(key);
            if (alt != null) {
              return alt;
            }
          }
        }
        this.dfa = dfa;
        if (this.force_global_context) {
          useContext = true;
        } else if (!this.always_try_local_context) {
          useContext = useContext || dfa.isContextSensitive;
        }
        this.userWantsCtxSensitive = useContext || this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll;
        if (outerContext == null) {
          outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
        }
        let state;
        if (!dfa.isEmpty) {
          state = this.getStartState(dfa, input, outerContext, useContext);
        }
        if (state == null) {
          if (outerContext == null) {
            outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
          }
          if (ParserATNSimulator3.debug) {
            console.log("ATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
          }
          state = this.computeStartState(dfa, outerContext, useContext);
        }
        let m = input.mark();
        let index2 = input.index;
        try {
          let alt = this.execDFA(dfa, input, index2, state);
          if (ParserATNSimulator3.debug) {
            console.log("DFA after predictATN: " + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
          }
          return alt;
        } finally {
          this.dfa = void 0;
          input.seek(index2);
          input.release(m);
        }
      }
      getStartState(dfa, input, outerContext, useContext) {
        if (!useContext) {
          if (dfa.isPrecedenceDfa) {
            let state = dfa.getPrecedenceStartState(this._parser.precedence, false);
            if (state == null) {
              return void 0;
            }
            return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);
          } else {
            if (dfa.s0 == null) {
              return void 0;
            }
            return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);
          }
        }
        if (!this.enable_global_context_dfa) {
          return void 0;
        }
        let remainingContext = outerContext;
        assert(outerContext != null);
        let s0;
        if (dfa.isPrecedenceDfa) {
          s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);
        } else {
          s0 = dfa.s0full;
        }
        while (remainingContext != null && s0 != null && s0.isContextSensitive) {
          remainingContext = this.skipTailCalls(remainingContext);
          s0 = s0.getContextTarget(this.getReturnState(remainingContext));
          if (remainingContext.isEmpty) {
            assert(s0 == null || !s0.isContextSensitive);
          } else {
            remainingContext = remainingContext.parent;
          }
        }
        if (s0 == null) {
          return void 0;
        }
        return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);
      }
      execDFA(dfa, input, startIndex, state) {
        let outerContext = state.outerContext;
        if (ParserATNSimulator3.dfa_debug) {
          console.log("DFA decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
        }
        if (ParserATNSimulator3.dfa_debug) {
          console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
        }
        let s = state.s0;
        let t = input.LA(1);
        let remainingOuterContext = state.remainingOuterContext;
        while (true) {
          if (ParserATNSimulator3.dfa_debug) {
            console.log("DFA state " + s.stateNumber + " LA(1)==" + this.getLookaheadName(input));
          }
          if (state.useContext) {
            while (s.isContextSymbol(t)) {
              let next;
              if (remainingOuterContext != null) {
                remainingOuterContext = this.skipTailCalls(remainingOuterContext);
                next = s.getContextTarget(this.getReturnState(remainingOuterContext));
              }
              if (next == null) {
                let initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);
                return this.execATN(dfa, input, startIndex, initialState);
              }
              assert(remainingOuterContext != null);
              remainingOuterContext = remainingOuterContext.parent;
              s = next;
            }
          }
          if (this.isAcceptState(s, state.useContext)) {
            if (s.predicates != null) {
              if (ParserATNSimulator3.dfa_debug) {
                console.log("accept " + s);
              }
            } else {
              if (ParserATNSimulator3.dfa_debug) {
                console.log("accept; predict " + s.prediction + " in state " + s.stateNumber);
              }
            }
            break;
          }
          assert(!this.isAcceptState(s, state.useContext));
          let target = this.getExistingTargetState(s, t);
          if (target == null) {
            if (ParserATNSimulator3.dfa_debug && t >= 0) {
              console.log("no edge for " + this._parser.vocabulary.getDisplayName(t));
            }
            let alt;
            if (ParserATNSimulator3.dfa_debug) {
              let interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);
              console.log("ATN exec upon " + this._parser.inputStream.getText(interval) + " at DFA state " + s.stateNumber);
            }
            let initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
            alt = this.execATN(dfa, input, startIndex, initialState);
            if (ParserATNSimulator3.dfa_debug) {
              console.log("back from DFA update, alt=" + alt + ", dfa=\n" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
            }
            if (ParserATNSimulator3.dfa_debug) {
              console.log("DFA decision " + dfa.decision + " predicts " + alt);
            }
            return alt;
          } else if (target === ATNSimulator_1.ATNSimulator.ERROR) {
            let errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
            return this.handleNoViableAlt(input, startIndex, errorState);
          }
          s = target;
          if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
        if (!state.useContext && s.configs.conflictInfo != null) {
          if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {
            if (!this.userWantsCtxSensitive || !s.configs.dipsIntoOuterContext && s.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex) {
            } else {
              assert(!state.useContext);
              let conflictingAlts;
              let predicates2 = s.predicates;
              if (predicates2 != null) {
                let conflictIndex = input.index;
                if (conflictIndex !== startIndex) {
                  input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(predicates2, outerContext, true);
                if (conflictingAlts.cardinality() === 1) {
                  return conflictingAlts.nextSetBit(0);
                }
                if (conflictIndex !== startIndex) {
                  input.seek(conflictIndex);
                }
              }
              if (this.reportAmbiguities) {
                let conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
                this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);
              }
              input.seek(startIndex);
              return this.adaptivePredict(input, dfa.decision, outerContext, true);
            }
          }
        }
        let predicates = s.predicates;
        if (predicates != null) {
          let stopIndex = input.index;
          if (startIndex !== stopIndex) {
            input.seek(startIndex);
          }
          let alts = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);
          switch (alts.cardinality()) {
            case 0:
              throw this.noViableAlt(input, outerContext, s.configs, startIndex);
            case 1:
              return alts.nextSetBit(0);
            default:
              if (startIndex !== stopIndex) {
                input.seek(stopIndex);
              }
              this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);
              return alts.nextSetBit(0);
          }
        }
        if (ParserATNSimulator3.dfa_debug) {
          console.log("DFA decision " + dfa.decision + " predicts " + s.prediction);
        }
        return s.prediction;
      }
      isAcceptState(state, useContext) {
        if (!state.isAcceptState) {
          return false;
        }
        if (state.configs.conflictingAlts == null) {
          return true;
        }
        if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {
          return state.configs.isExactConflict;
        }
        return true;
      }
      execATN(dfa, input, startIndex, initialState) {
        if (ParserATNSimulator3.debug) {
          console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input));
        }
        let outerContext = initialState.outerContext;
        let useContext = initialState.useContext;
        let t = input.LA(1);
        let previous4 = initialState;
        let contextCache = new PredictionContextCache_1.PredictionContextCache();
        while (true) {
          let nextState = this.computeReachSet(dfa, previous4, t, contextCache);
          if (nextState == null) {
            this.setDFAEdge(previous4.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);
            return this.handleNoViableAlt(input, startIndex, previous4);
          }
          let D = nextState.s0;
          assert(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);
          assert(D.isAcceptState || D.configs.conflictInfo == null);
          if (this.isAcceptState(D, useContext)) {
            let conflictingAlts = D.configs.conflictingAlts;
            let predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;
            if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (this.optimize_ll1 && input.index === startIndex && !dfa.isPrecedenceDfa && nextState.outerContext === nextState.remainingOuterContext && dfa.decision >= 0 && !D.configs.hasSemanticContext) {
                if (t >= 0 && t <= MAX_SHORT_VALUE) {
                  let key = (dfa.decision << 16 >>> 0) + t;
                  this.atn.LL1Table.set(key, predictedAlt);
                }
              }
              if (useContext && this.always_try_local_context) {
                this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);
              }
            }
            predictedAlt = D.prediction;
            let attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;
            if (attemptFullContext) {
              attemptFullContext = !useContext && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);
            }
            if (D.configs.hasSemanticContext) {
              let predPredictions = D.predicates;
              if (predPredictions != null) {
                let conflictIndex = input.index;
                if (conflictIndex !== startIndex) {
                  input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);
                switch (conflictingAlts.cardinality()) {
                  case 0:
                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                  case 1:
                    return conflictingAlts.nextSetBit(0);
                  default:
                    break;
                }
                if (conflictIndex !== startIndex) {
                  input.seek(conflictIndex);
                }
              }
            }
            if (!attemptFullContext) {
              if (conflictingAlts != null) {
                if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {
                  this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);
                }
                predictedAlt = conflictingAlts.nextSetBit(0);
              }
              return predictedAlt;
            } else {
              assert(!useContext);
              assert(this.isAcceptState(D, false));
              if (ParserATNSimulator3.debug) {
                console.log("RETRY with outerContext=" + outerContext);
              }
              let fullContextState = this.computeStartState(dfa, outerContext, true);
              if (this.reportAmbiguities) {
                this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);
              }
              input.seek(startIndex);
              return this.execATN(dfa, input, startIndex, fullContextState);
            }
          }
          previous4 = nextState;
          if (t !== IntStream_1.IntStream.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
      }
      handleNoViableAlt(input, startIndex, previous4) {
        if (previous4.s0 != null) {
          let alts = new BitSet_1.BitSet();
          let maxAlt = 0;
          for (let config of previous4.s0.configs) {
            if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
              alts.set(config.alt);
              maxAlt = Math.max(maxAlt, config.alt);
            }
          }
          switch (alts.cardinality()) {
            case 0:
              break;
            case 1:
              return alts.nextSetBit(0);
            default:
              if (!previous4.s0.configs.hasSemanticContext) {
                return alts.nextSetBit(0);
              }
              let filteredConfigs = new ATNConfigSet_1.ATNConfigSet();
              for (let config of previous4.s0.configs) {
                if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
                  filteredConfigs.add(config);
                }
              }
              let altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);
              if (altToPred != null) {
                let predicates = this.getPredicatePredictions(alts, altToPred);
                if (predicates != null) {
                  let stopIndex = input.index;
                  try {
                    input.seek(startIndex);
                    let filteredAlts = this.evalSemanticContext(predicates, previous4.outerContext, false);
                    if (!filteredAlts.isEmpty) {
                      return filteredAlts.nextSetBit(0);
                    }
                  } finally {
                    input.seek(stopIndex);
                  }
                }
              }
              return alts.nextSetBit(0);
          }
        }
        throw this.noViableAlt(input, previous4.outerContext, previous4.s0.configs, startIndex);
      }
      computeReachSet(dfa, previous4, t, contextCache) {
        let useContext = previous4.useContext;
        let remainingGlobalContext = previous4.remainingOuterContext;
        let s = previous4.s0;
        if (useContext) {
          while (s.isContextSymbol(t)) {
            let next;
            if (remainingGlobalContext != null) {
              remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
              next = s.getContextTarget(this.getReturnState(remainingGlobalContext));
            }
            if (next == null) {
              break;
            }
            assert(remainingGlobalContext != null);
            remainingGlobalContext = remainingGlobalContext.parent;
            s = next;
          }
        }
        assert(!this.isAcceptState(s, useContext));
        if (this.isAcceptState(s, useContext)) {
          return new SimulatorState_1.SimulatorState(previous4.outerContext, s, useContext, remainingGlobalContext);
        }
        let s0 = s;
        let target = this.getExistingTargetState(s0, t);
        if (target == null) {
          let result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);
          target = result[0];
          remainingGlobalContext = result[1];
        }
        if (target === ATNSimulator_1.ATNSimulator.ERROR) {
          return void 0;
        }
        assert(!useContext || !target.configs.dipsIntoOuterContext);
        return new SimulatorState_1.SimulatorState(previous4.outerContext, target, useContext, remainingGlobalContext);
      }
      getExistingTargetState(s, t) {
        return s.getTarget(t);
      }
      computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
        let closureConfigs = s.configs.toArray();
        let contextElements;
        let reach = new ATNConfigSet_1.ATNConfigSet();
        let stepIntoGlobal;
        do {
          let hasMoreContext = !useContext || remainingGlobalContext != null;
          if (!hasMoreContext) {
            reach.isOutermostConfigSet = true;
          }
          let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
          let skippedStopStates;
          for (let c of closureConfigs) {
            if (ParserATNSimulator3.debug) {
              console.log("testing " + this.getTokenName(t) + " at " + c.toString());
            }
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              assert(c.context.isEmpty);
              if (useContext && !c.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {
                if (skippedStopStates == null) {
                  skippedStopStates = [];
                }
                skippedStopStates.push(c);
              }
              continue;
            }
            let n = c.state.numberOfOptimizedTransitions;
            for (let ti = 0; ti < n; ti++) {
              let trans = c.state.getOptimizedTransition(ti);
              let target = this.getReachableTarget(c, trans, t);
              if (target != null) {
                reachIntermediate.add(c.transform(target, false), contextCache);
              }
            }
          }
          if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;
            reach = reachIntermediate;
            break;
          }
          let collectPredicates = false;
          let treatEofAsEpsilon = t === Token_1.Token.EOF;
          this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);
          stepIntoGlobal = reach.dipsIntoOuterContext;
          if (t === IntStream_1.IntStream.EOF) {
            reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);
          }
          if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {
            assert(skippedStopStates.length > 0);
            for (let c of skippedStopStates) {
              reach.add(c, contextCache);
            }
          }
          if (useContext && stepIntoGlobal) {
            reach.clear();
            remainingGlobalContext = remainingGlobalContext;
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            let nextContextElement = this.getReturnState(remainingGlobalContext);
            if (contextElements == null) {
              contextElements = new IntegerList_1.IntegerList();
            }
            if (remainingGlobalContext.isEmpty) {
              remainingGlobalContext = void 0;
            } else {
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            contextElements.add(nextContextElement);
            if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              for (let i = 0; i < closureConfigs.length; i++) {
                closureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);
              }
            }
          }
        } while (useContext && stepIntoGlobal);
        if (reach.isEmpty) {
          this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
          return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];
        }
        let result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);
        return [result, remainingGlobalContext];
      }
      removeAllConfigsNotInRuleStopState(configs, contextCache) {
        if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {
          return configs;
        }
        let result = new ATNConfigSet_1.ATNConfigSet();
        for (let config of configs) {
          if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          result.add(config, contextCache);
        }
        return result;
      }
      computeStartState(dfa, globalContext, useContext) {
        let s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) : useContext ? dfa.s0full : dfa.s0;
        if (s0 != null) {
          if (!useContext) {
            return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);
          }
          s0.setContextSensitive(this.atn);
        }
        let decision = dfa.decision;
        let p = dfa.atnStartState;
        let previousContext = 0;
        let remainingGlobalContext = globalContext;
        let initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL;
        let contextCache = new PredictionContextCache_1.PredictionContextCache();
        if (useContext) {
          if (!this.enable_global_context_dfa) {
            while (remainingGlobalContext != null) {
              if (remainingGlobalContext.isEmpty) {
                previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                remainingGlobalContext = void 0;
              } else {
                previousContext = this.getReturnState(remainingGlobalContext);
                initialContext = initialContext.appendSingleContext(previousContext, contextCache);
                remainingGlobalContext = remainingGlobalContext.parent;
              }
            }
          }
          while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {
            let next;
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            if (remainingGlobalContext.isEmpty) {
              next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);
              previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
              remainingGlobalContext = void 0;
            } else {
              previousContext = this.getReturnState(remainingGlobalContext);
              next = s0.getContextTarget(previousContext);
              initialContext = initialContext.appendSingleContext(previousContext, contextCache);
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            if (next == null) {
              break;
            }
            s0 = next;
          }
        }
        if (s0 != null && !s0.isContextSensitive) {
          return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
        }
        let configs = new ATNConfigSet_1.ATNConfigSet();
        while (true) {
          let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
          let n = p.numberOfTransitions;
          for (let ti = 0; ti < n; ti++) {
            let target = p.transition(ti).target;
            reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));
          }
          let hasMoreContext = remainingGlobalContext != null;
          if (!hasMoreContext) {
            configs.isOutermostConfigSet = true;
          }
          let collectPredicates = true;
          this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);
          let stepIntoGlobal = configs.dipsIntoOuterContext;
          let next;
          if (useContext && !this.enable_global_context_dfa) {
            s0 = this.addDFAState(dfa, configs, contextCache);
            break;
          } else if (s0 == null) {
            if (!dfa.isPrecedenceDfa) {
              next = this.addDFAState(dfa, configs, contextCache);
              if (useContext) {
                if (!dfa.s0full) {
                  dfa.s0full = next;
                } else {
                  next = dfa.s0full;
                }
              } else {
                if (!dfa.s0) {
                  dfa.s0 = next;
                } else {
                  next = dfa.s0;
                }
              }
            } else {
              configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
              next = this.addDFAState(dfa, configs, contextCache);
              dfa.setPrecedenceStartState(this._parser.precedence, useContext, next);
            }
          } else {
            if (dfa.isPrecedenceDfa) {
              configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
            }
            next = this.addDFAState(dfa, configs, contextCache);
            s0.setContextTarget(previousContext, next);
          }
          s0 = next;
          if (!useContext || !stepIntoGlobal) {
            break;
          }
          next.setContextSensitive(this.atn);
          remainingGlobalContext = remainingGlobalContext;
          configs.clear();
          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
          let nextContextElement = this.getReturnState(remainingGlobalContext);
          if (remainingGlobalContext.isEmpty) {
            remainingGlobalContext = void 0;
          } else {
            remainingGlobalContext = remainingGlobalContext.parent;
          }
          if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);
          }
          previousContext = nextContextElement;
        }
        return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
      }
      applyPrecedenceFilter(configs, globalContext, contextCache) {
        let statesFromAlt1 = /* @__PURE__ */ new Map();
        let configSet = new ATNConfigSet_1.ATNConfigSet();
        for (let config of configs) {
          if (config.alt !== 1) {
            continue;
          }
          let updatedContext = config.semanticContext.evalPrecedence(this._parser, globalContext);
          if (updatedContext == null) {
            continue;
          }
          statesFromAlt1.set(config.state.stateNumber, config.context);
          if (updatedContext !== config.semanticContext) {
            configSet.add(config.transform(config.state, false, updatedContext), contextCache);
          } else {
            configSet.add(config, contextCache);
          }
        }
        for (let config of configs) {
          if (config.alt === 1) {
            continue;
          }
          if (!config.isPrecedenceFilterSuppressed) {
            let context = statesFromAlt1.get(config.state.stateNumber);
            if (context != null && context.equals(config.context)) {
              continue;
            }
          }
          configSet.add(config, contextCache);
        }
        return configSet;
      }
      getReachableTarget(source, trans, ttype) {
        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
          return trans.target;
        }
        return void 0;
      }
      predicateDFAState(D, configs, nalts) {
        let conflictingAlts = this.getConflictingAltsFromConfigSet(configs);
        if (!conflictingAlts) {
          throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");
        }
        if (ParserATNSimulator3.debug) {
          console.log("predicateDFAState " + D);
        }
        let altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);
        let predPredictions;
        if (altToPred != null) {
          predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);
          D.predicates = predPredictions;
        }
        return predPredictions;
      }
      getPredsForAmbigAlts(ambigAlts, configs, nalts) {
        let altToPred = new Array(nalts + 1);
        let n = altToPred.length;
        for (let c of configs) {
          if (ambigAlts.get(c.alt)) {
            altToPred[c.alt] = SemanticContext_1.SemanticContext.or(altToPred[c.alt], c.semanticContext);
          }
        }
        let nPredAlts = 0;
        for (let i = 0; i < n; i++) {
          if (altToPred[i] == null) {
            altToPred[i] = SemanticContext_1.SemanticContext.NONE;
          } else if (altToPred[i] !== SemanticContext_1.SemanticContext.NONE) {
            nPredAlts++;
          }
        }
        let result = altToPred;
        if (nPredAlts === 0) {
          result = void 0;
        }
        if (ParserATNSimulator3.debug) {
          console.log("getPredsForAmbigAlts result " + (result ? Arrays_1.Arrays.toString(result) : "undefined"));
        }
        return result;
      }
      getPredicatePredictions(ambigAlts, altToPred) {
        let pairs = [];
        let containsPredicate = false;
        for (let i = 1; i < altToPred.length; i++) {
          let pred = altToPred[i];
          assert(pred != null);
          if (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext_1.SemanticContext.NONE) {
            pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
          } else if (pred !== SemanticContext_1.SemanticContext.NONE) {
            containsPredicate = true;
            pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
          }
        }
        if (!containsPredicate) {
          return void 0;
        }
        return pairs;
      }
      evalSemanticContext(predPredictions, outerContext, complete) {
        let predictions = new BitSet_1.BitSet();
        for (let pair of predPredictions) {
          if (pair.pred === SemanticContext_1.SemanticContext.NONE) {
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
            continue;
          }
          let evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);
          if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
            console.log("eval pred " + pair + "=" + evaluatedResult);
          }
          if (evaluatedResult) {
            if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
              console.log("PREDICT " + pair.alt);
            }
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
          }
        }
        return predictions;
      }
      evalSemanticContextImpl(pred, parserCallStack, alt) {
        return pred.eval(this._parser, parserCallStack);
      }
      closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {
        if (contextCache == null) {
          contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
        }
        let currentConfigs = sourceConfigs;
        let closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        while (currentConfigs.size > 0) {
          let intermediate = new ATNConfigSet_1.ATNConfigSet();
          for (let config of currentConfigs) {
            this.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);
          }
          currentConfigs = intermediate;
        }
      }
      closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {
        if (ParserATNSimulator3.debug) {
          console.log("closure(" + config.toString(this._parser, true) + ")");
        }
        if (config.state instanceof RuleStopState_1.RuleStopState) {
          if (!config.context.isEmpty) {
            let hasEmpty = config.context.hasEmpty;
            let nonEmptySize = config.context.size - (hasEmpty ? 1 : 0);
            for (let i = 0; i < nonEmptySize; i++) {
              let newContext = config.context.getParent(i);
              let returnState = this.atn.states[config.context.getReturnState(i)];
              let c = ATNConfig_1.ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);
              c.outerContextDepth = config.outerContextDepth;
              c.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;
              assert(depth > MIN_INTEGER_VALUE);
              this.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);
            }
            if (!hasEmpty || !hasMoreContexts) {
              return;
            }
            config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
          } else if (!hasMoreContexts) {
            configs.add(config, contextCache);
            return;
          } else {
            if (ParserATNSimulator3.debug) {
              console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
            }
            if (config.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {
              config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
            } else if (!config.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
              configs.add(config, contextCache);
            }
          }
        }
        let p = config.state;
        if (!p.onlyHasEpsilonTransitions) {
          configs.add(config, contextCache);
          if (ParserATNSimulator3.debug) {
            console.log("added config " + configs);
          }
        }
        for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
          if (i === 0 && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY && p.precedenceRuleDecision && !config.context.hasEmpty) {
            let precedenceDecision = p;
            let suppress = true;
            for (let j = 0; j < config.context.size; j++) {
              if (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {
                suppress = false;
                break;
              }
            }
            if (suppress) {
              continue;
            }
          }
          let t = p.getOptimizedTransition(i);
          let continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;
          let c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);
          if (c != null) {
            if (t instanceof RuleTransition_1.RuleTransition) {
              if (intermediate != null && !collectPredicates) {
                intermediate.add(c, contextCache);
                continue;
              }
            }
            let newDepth = depth;
            if (config.state instanceof RuleStopState_1.RuleStopState) {
              if (this.dfa != null && this.dfa.isPrecedenceDfa) {
                let outermostPrecedenceReturn = t.outermostPrecedenceReturn;
                if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {
                  c.isPrecedenceFilterSuppressed = true;
                }
              }
              c.outerContextDepth = c.outerContextDepth + 1;
              if (!closureBusy.add(c)) {
                continue;
              }
              assert(newDepth > MIN_INTEGER_VALUE);
              newDepth--;
              if (ParserATNSimulator3.debug) {
                console.log("dips into outer ctx: " + c);
              }
            } else if (t instanceof RuleTransition_1.RuleTransition) {
              if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
                assert(c.context === config.context);
                if (newDepth === 0) {
                  newDepth--;
                  if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
                    c.outerContextDepth = c.outerContextDepth + 1;
                  }
                }
              } else {
                if (newDepth >= 0) {
                  newDepth++;
                }
              }
            } else {
              if (!t.isEpsilon && !closureBusy.add(c)) {
                continue;
              }
            }
            this.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);
          }
        }
      }
      getRuleName(index2) {
        if (this._parser != null && index2 >= 0) {
          return this._parser.ruleNames[index2];
        }
        return "<rule " + index2 + ">";
      }
      getEpsilonTarget(config, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {
        switch (t.serializationType) {
          case 3:
            return this.ruleTransition(config, t, contextCache);
          case 10:
            return this.precedenceTransition(config, t, collectPredicates, inContext);
          case 4:
            return this.predTransition(config, t, collectPredicates, inContext);
          case 6:
            return this.actionTransition(config, t);
          case 1:
            return config.transform(t.target, false);
          case 5:
          case 2:
          case 7:
            if (treatEofAsEpsilon) {
              if (t.matches(Token_1.Token.EOF, 0, 1)) {
                return config.transform(t.target, false);
              }
            }
            return void 0;
          default:
            return void 0;
        }
      }
      actionTransition(config, t) {
        if (ParserATNSimulator3.debug) {
          console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
        }
        return config.transform(t.target, false);
      }
      precedenceTransition(config, pt, collectPredicates, inContext) {
        if (ParserATNSimulator3.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
          if (this._parser != null) {
            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
          }
        }
        let c;
        if (collectPredicates && inContext) {
          let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
          c = config.transform(pt.target, false, newSemCtx);
        } else {
          c = config.transform(pt.target, false);
        }
        if (ParserATNSimulator3.debug) {
          console.log("config from pred transition=" + c);
        }
        return c;
      }
      predTransition(config, pt, collectPredicates, inContext) {
        if (ParserATNSimulator3.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
          if (this._parser != null) {
            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
          }
        }
        let c;
        if (collectPredicates && (!pt.isCtxDependent || pt.isCtxDependent && inContext)) {
          let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
          c = config.transform(pt.target, false, newSemCtx);
        } else {
          c = config.transform(pt.target, false);
        }
        if (ParserATNSimulator3.debug) {
          console.log("config from pred transition=" + c);
        }
        return c;
      }
      ruleTransition(config, t, contextCache) {
        if (ParserATNSimulator3.debug) {
          console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
        }
        let returnState = t.followState;
        let newContext;
        if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
          newContext = config.context;
        } else if (contextCache != null) {
          newContext = contextCache.getChild(config.context, returnState.stateNumber);
        } else {
          newContext = config.context.getChild(returnState.stateNumber);
        }
        return config.transform(t.target, false, newContext);
      }
      isConflicted(configset, contextCache) {
        if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {
          return void 0;
        }
        let configs = configset.toArray();
        configs.sort(ParserATNSimulator3.STATE_ALT_SORT_COMPARATOR);
        let exact = !configset.dipsIntoOuterContext;
        let alts = new BitSet_1.BitSet();
        let minAlt = configs[0].alt;
        alts.set(minAlt);
        let currentState = configs[0].state.nonStopStateNumber;
        for (let config of configs) {
          let stateNumber = config.state.nonStopStateNumber;
          if (stateNumber !== currentState) {
            if (config.alt !== minAlt) {
              return void 0;
            }
            currentState = stateNumber;
          }
        }
        let representedAlts;
        if (exact) {
          currentState = configs[0].state.nonStopStateNumber;
          representedAlts = new BitSet_1.BitSet();
          let maxAlt = minAlt;
          for (let config of configs) {
            if (config.state.nonStopStateNumber !== currentState) {
              break;
            }
            let alt = config.alt;
            representedAlts.set(alt);
            maxAlt = alt;
          }
          currentState = configs[0].state.nonStopStateNumber;
          let currentAlt = minAlt;
          for (let config of configs) {
            let stateNumber = config.state.nonStopStateNumber;
            let alt = config.alt;
            if (stateNumber !== currentState) {
              if (currentAlt !== maxAlt) {
                exact = false;
                break;
              }
              currentState = stateNumber;
              currentAlt = minAlt;
            } else if (alt !== currentAlt) {
              if (alt !== representedAlts.nextSetBit(currentAlt + 1)) {
                exact = false;
                break;
              }
              currentAlt = alt;
            }
          }
        }
        currentState = configs[0].state.nonStopStateNumber;
        let firstIndexCurrentState = 0;
        let lastIndexCurrentStateMinAlt = 0;
        let joinedCheckContext = configs[0].context;
        for (let i = 1; i < configs.length; i++) {
          let config = configs[i];
          if (config.alt !== minAlt) {
            break;
          }
          if (config.state.nonStopStateNumber !== currentState) {
            break;
          }
          lastIndexCurrentStateMinAlt = i;
          joinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);
        }
        for (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {
          let config = configs[i];
          let state = config.state;
          alts.set(config.alt);
          if (state.nonStopStateNumber !== currentState) {
            currentState = state.nonStopStateNumber;
            firstIndexCurrentState = i;
            lastIndexCurrentStateMinAlt = i;
            joinedCheckContext = config.context;
            for (let j = firstIndexCurrentState + 1; j < configs.length; j++) {
              let config2 = configs[j];
              if (config2.alt !== minAlt) {
                break;
              }
              if (config2.state.nonStopStateNumber !== currentState) {
                break;
              }
              lastIndexCurrentStateMinAlt = j;
              joinedCheckContext = contextCache.join(joinedCheckContext, config2.context);
            }
            i = lastIndexCurrentStateMinAlt;
            continue;
          }
          let joinedCheckContext2 = config.context;
          let currentAlt = config.alt;
          let lastIndexCurrentStateCurrentAlt = i;
          for (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {
            let config2 = configs[j];
            if (config2.alt !== currentAlt) {
              break;
            }
            if (config2.state.nonStopStateNumber !== currentState) {
              break;
            }
            lastIndexCurrentStateCurrentAlt = j;
            joinedCheckContext2 = contextCache.join(joinedCheckContext2, config2.context);
          }
          i = lastIndexCurrentStateCurrentAlt;
          let check = contextCache.join(joinedCheckContext, joinedCheckContext2);
          if (!joinedCheckContext.equals(check)) {
            return void 0;
          }
          exact = exact && joinedCheckContext.equals(joinedCheckContext2);
        }
        return new ConflictInfo_1.ConflictInfo(alts, exact);
      }
      getConflictingAltsFromConfigSet(configs) {
        let conflictingAlts = configs.conflictingAlts;
        if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          conflictingAlts = new BitSet_1.BitSet();
          conflictingAlts.set(configs.uniqueAlt);
        }
        return conflictingAlts;
      }
      getTokenName(t) {
        if (t === Token_1.Token.EOF) {
          return "EOF";
        }
        let vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        let displayName = vocabulary.getDisplayName(t);
        if (displayName === String(t)) {
          return displayName;
        }
        return displayName + "<" + t + ">";
      }
      getLookaheadName(input) {
        return this.getTokenName(input.LA(1));
      }
      dumpDeadEndConfigs(nvae) {
        console.log("dead end configs: ");
        let deadEndConfigs = nvae.deadEndConfigs;
        if (!deadEndConfigs) {
          return;
        }
        for (let c of deadEndConfigs) {
          let trans = "no edges";
          if (c.state.numberOfOptimizedTransitions > 0) {
            let t = c.state.getOptimizedTransition(0);
            if (t instanceof AtomTransition_1.AtomTransition) {
              trans = "Atom " + this.getTokenName(t._label);
            } else if (t instanceof SetTransition_1.SetTransition) {
              let not = t instanceof NotSetTransition_1.NotSetTransition;
              trans = (not ? "~" : "") + "Set " + t.set.toString();
            }
          }
          console.log(c.toString(this._parser, true) + ":" + trans);
        }
      }
      noViableAlt(input, outerContext, configs, startIndex) {
        return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
      }
      getUniqueAlt(configs) {
        let alt = ATN_1.ATN.INVALID_ALT_NUMBER;
        for (let c of configs) {
          if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {
            alt = c.alt;
          } else if (c.alt !== alt) {
            return ATN_1.ATN.INVALID_ALT_NUMBER;
          }
        }
        return alt;
      }
      configWithAltAtStopState(configs, alt) {
        for (let c of configs) {
          if (c.alt === alt) {
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              return true;
            }
          }
        }
        return false;
      }
      addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {
        assert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);
        let from = fromState;
        let to = this.addDFAState(dfa, toConfigs, contextCache);
        if (contextTransitions != null) {
          for (let context of contextTransitions.toArray()) {
            if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              if (from.configs.isOutermostConfigSet) {
                continue;
              }
            }
            from.setContextSensitive(this.atn);
            from.setContextSymbol(t);
            let next = from.getContextTarget(context);
            if (next != null) {
              from = next;
              continue;
            }
            next = this.addDFAContextState(dfa, from.configs, context, contextCache);
            assert(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);
            from.setContextTarget(context, next);
            from = next;
          }
        }
        if (ParserATNSimulator3.debug) {
          console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
        }
        this.setDFAEdge(from, t, to);
        if (ParserATNSimulator3.debug) {
          console.log("DFA=\n" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : void 0));
        }
        return to;
      }
      setDFAEdge(p, t, q) {
        if (p != null) {
          p.setTarget(t, q);
        }
      }
      addDFAContextState(dfa, configs, returnContext, contextCache) {
        if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          let contextConfigs = new ATNConfigSet_1.ATNConfigSet();
          for (let config of configs) {
            contextConfigs.add(config.appendContext(returnContext, contextCache));
          }
          return this.addDFAState(dfa, contextConfigs, contextCache);
        } else {
          assert(!configs.isOutermostConfigSet, "Shouldn't be adding a duplicate edge.");
          configs = configs.clone(true);
          configs.isOutermostConfigSet = true;
          return this.addDFAState(dfa, configs, contextCache);
        }
      }
      addDFAState(dfa, configs, contextCache) {
        let enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;
        if (enableDfa) {
          if (!configs.isReadOnly) {
            configs.optimizeConfigs(this);
          }
          let proposed = this.createDFAState(dfa, configs);
          let existing = dfa.states.get(proposed);
          if (existing != null) {
            return existing;
          }
        }
        if (!configs.isReadOnly) {
          if (configs.conflictInfo == null) {
            configs.conflictInfo = this.isConflicted(configs, contextCache);
          }
        }
        let newState = this.createDFAState(dfa, configs.clone(true));
        let decisionState = this.atn.getDecisionState(dfa.decision);
        let predictedAlt = this.getUniqueAlt(configs);
        if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);
        } else if (configs.conflictingAlts != null) {
          let conflictingAlts = configs.conflictingAlts;
          if (conflictingAlts) {
            newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));
          }
        }
        if (newState.isAcceptState && configs.hasSemanticContext) {
          this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);
        }
        if (!enableDfa) {
          return newState;
        }
        let added = dfa.addState(newState);
        if (ParserATNSimulator3.debug && added === newState) {
          console.log("adding new DFA state: " + newState);
        }
        return added;
      }
      createDFAState(dfa, configs) {
        return new DFAState_1.DFAState(configs);
      }
      reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
        if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + conflictState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportAttemptingFullContext) {
            listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
          }
        }
      }
      reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
        if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportContextSensitivity decision=" + dfa.decision + ":" + acceptState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportContextSensitivity) {
            listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);
          }
        }
      }
      reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportAmbiguity) {
            listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
          }
        }
      }
      getReturnState(context) {
        if (context.isEmpty) {
          return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
        }
        let state = this.atn.states[context.invokingState];
        let transition = state.transition(0);
        return transition.followState.stateNumber;
      }
      skipTailCalls(context) {
        if (!this.optimize_tail_calls) {
          return context;
        }
        while (!context.isEmpty) {
          let state = this.atn.states[context.invokingState];
          assert(state.numberOfTransitions === 1 && state.transition(0).serializationType === 3);
          let transition = state.transition(0);
          if (!transition.tailCall) {
            break;
          }
          context = context.parent;
        }
        return context;
      }
      get parser() {
        return this._parser;
      }
    };
    ParserATNSimulator2.debug = false;
    ParserATNSimulator2.dfa_debug = false;
    ParserATNSimulator2.retry_debug = false;
    ParserATNSimulator2.STATE_ALT_SORT_COMPARATOR = (o1, o2) => {
      let diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;
      if (diff !== 0) {
        return diff;
      }
      diff = o1.alt - o2.alt;
      if (diff !== 0) {
        return diff;
      }
      return 0;
    };
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "predictionMode", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "getPredictionMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "setPredictionMode", null);
    __decorate([
      Decorators_1.Override
    ], ParserATNSimulator2.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "adaptivePredict", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getStartState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "execDFA", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "execATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "handleNoViableAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "computeTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "removeAllConfigsNotInRuleStopState", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "computeStartState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "applyPrecedenceFilter", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getReachableTarget", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getPredsForAmbigAlts", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "evalSemanticContext", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "evalSemanticContextImpl", null);
    __decorate([
      __param(1, Decorators_1.NotNull),
      __param(4, Decorators_1.Nullable)
    ], ParserATNSimulator2.prototype, "closure", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.Nullable),
      __param(3, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "closureImpl", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "getRuleName", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getEpsilonTarget", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "actionTransition", null);
    __decorate([
      Decorators_1.Nullable,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "precedenceTransition", null);
    __decorate([
      Decorators_1.Nullable,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "predTransition", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.Nullable)
    ], ParserATNSimulator2.prototype, "ruleTransition", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "isConflicted", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator2.prototype, "getTokenName", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "dumpDeadEndConfigs", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "noViableAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "getUniqueAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "configWithAltAtStopState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "addDFAEdge", null);
    __decorate([
      __param(0, Decorators_1.Nullable),
      __param(2, Decorators_1.Nullable)
    ], ParserATNSimulator2.prototype, "setDFAEdge", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "addDFAContextState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "addDFAState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "createDFAState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "reportAttemptingFullContext", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "reportContextSensitivity", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ParserATNSimulator2.prototype, "reportAmbiguity", null);
    ParserATNSimulator2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator2);
    exports.ParserATNSimulator = ParserATNSimulator2;
  }
});

// node_modules/antlr4ts/atn/PlusBlockStartState.js
var require_PlusBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/PlusBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlusBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var PlusBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.PLUS_BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PlusBlockStartState.prototype, "stateType", null);
    exports.PlusBlockStartState = PlusBlockStartState;
  }
});

// node_modules/antlr4ts/atn/PlusLoopbackState.js
var require_PlusLoopbackState = __commonJS({
  "node_modules/antlr4ts/atn/PlusLoopbackState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlusLoopbackState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var PlusLoopbackState = class extends DecisionState_1.DecisionState {
      get stateType() {
        return ATNStateType_1.ATNStateType.PLUS_LOOP_BACK;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PlusLoopbackState.prototype, "stateType", null);
    exports.PlusLoopbackState = PlusLoopbackState;
  }
});

// node_modules/antlr4ts/atn/PrecedencePredicateTransition.js
var require_PrecedencePredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/PrecedencePredicateTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrecedencePredicateTransition = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Decorators_1 = require_Decorators();
    var SemanticContext_1 = require_SemanticContext();
    var PrecedencePredicateTransition = class PrecedencePredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
      constructor(target, precedence) {
        super(target);
        this.precedence = precedence;
      }
      get serializationType() {
        return 10;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      get predicate() {
        return new SemanticContext_1.SemanticContext.PrecedencePredicate(this.precedence);
      }
      toString() {
        return this.precedence + " >= _p";
      }
    };
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "toString", null);
    PrecedencePredicateTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], PrecedencePredicateTransition);
    exports.PrecedencePredicateTransition = PrecedencePredicateTransition;
  }
});

// node_modules/antlr4ts/atn/RangeTransition.js
var require_RangeTransition = __commonJS({
  "node_modules/antlr4ts/atn/RangeTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RangeTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var RangeTransition = class RangeTransition extends Transition_1.Transition {
      constructor(target, from, to) {
        super(target);
        this.from = from;
        this.to = to;
      }
      get serializationType() {
        return 2;
      }
      get label() {
        return IntervalSet_1.IntervalSet.of(this.from, this.to);
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= this.from && symbol <= this.to;
      }
      toString() {
        return "'" + String.fromCodePoint(this.from) + "'..'" + String.fromCodePoint(this.to) + "'";
      }
    };
    __decorate([
      Decorators_1.Override
    ], RangeTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], RangeTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], RangeTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], RangeTransition.prototype, "toString", null);
    RangeTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], RangeTransition);
    exports.RangeTransition = RangeTransition;
  }
});

// node_modules/antlr4ts/atn/RuleStartState.js
var require_RuleStartState = __commonJS({
  "node_modules/antlr4ts/atn/RuleStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleStartState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var RuleStartState = class extends ATNState_1.ATNState {
      constructor() {
        super(...arguments);
        this.isPrecedenceRule = false;
        this.leftFactored = false;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.RULE_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleStartState.prototype, "stateType", null);
    exports.RuleStartState = RuleStartState;
  }
});

// node_modules/antlr4ts/atn/StarBlockStartState.js
var require_StarBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/StarBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var StarBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarBlockStartState.prototype, "stateType", null);
    exports.StarBlockStartState = StarBlockStartState;
  }
});

// node_modules/antlr4ts/atn/StarLoopbackState.js
var require_StarLoopbackState = __commonJS({
  "node_modules/antlr4ts/atn/StarLoopbackState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarLoopbackState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var StarLoopbackState = class extends ATNState_1.ATNState {
      get loopEntryState() {
        return this.transition(0).target;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_LOOP_BACK;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarLoopbackState.prototype, "stateType", null);
    exports.StarLoopbackState = StarLoopbackState;
  }
});

// node_modules/antlr4ts/atn/TokensStartState.js
var require_TokensStartState = __commonJS({
  "node_modules/antlr4ts/atn/TokensStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokensStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var TokensStartState = class extends DecisionState_1.DecisionState {
      get stateType() {
        return ATNStateType_1.ATNStateType.TOKEN_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], TokensStartState.prototype, "stateType", null);
    exports.TokensStartState = TokensStartState;
  }
});

// node_modules/antlr4ts/misc/UUID.js
var require_UUID = __commonJS({
  "node_modules/antlr4ts/misc/UUID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UUID = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var UUID = class {
      constructor(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {
        this.data = new Uint32Array(4);
        this.data[0] = mostSigBits;
        this.data[1] = moreSigBits;
        this.data[2] = lessSigBits;
        this.data[3] = leastSigBits;
      }
      static fromString(data) {
        if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {
          throw new Error("Incorrectly formatted UUID");
        }
        let segments = data.split("-");
        let mostSigBits = parseInt(segments[0], 16);
        let moreSigBits = (parseInt(segments[1], 16) << 16 >>> 0) + parseInt(segments[2], 16);
        let lessSigBits = (parseInt(segments[3], 16) << 16 >>> 0) + parseInt(segments[4].substr(0, 4), 16);
        let leastSigBits = parseInt(segments[4].substr(-8), 16);
        return new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
      }
      hashCode() {
        return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof UUID)) {
          return false;
        }
        return this.data[0] === obj.data[0] && this.data[1] === obj.data[1] && this.data[2] === obj.data[2] && this.data[3] === obj.data[3];
      }
      toString() {
        return ("00000000" + this.data[0].toString(16)).substr(-8) + "-" + ("0000" + (this.data[1] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[1].toString(16)).substr(-4) + "-" + ("0000" + (this.data[2] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[2].toString(16)).substr(-4) + ("00000000" + this.data[3].toString(16)).substr(-8);
      }
    };
    exports.UUID = UUID;
  }
});

// node_modules/antlr4ts/atn/ATNDeserializer.js
var require_ATNDeserializer = __commonJS({
  "node_modules/antlr4ts/atn/ATNDeserializer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNDeserializer = void 0;
    var ActionTransition_1 = require_ActionTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATN_1 = require_ATN();
    var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
    var ATNStateType_1 = require_ATNStateType();
    var AtomTransition_1 = require_AtomTransition();
    var BasicBlockStartState_1 = require_BasicBlockStartState();
    var BasicState_1 = require_BasicState();
    var BitSet_1 = require_BitSet();
    var BlockEndState_1 = require_BlockEndState();
    var BlockStartState_1 = require_BlockStartState();
    var DecisionState_1 = require_DecisionState();
    var DFA_1 = require_DFA();
    var EpsilonTransition_1 = require_EpsilonTransition();
    var IntervalSet_1 = require_IntervalSet();
    var InvalidState_1 = require_InvalidState();
    var LexerChannelAction_1 = require_LexerChannelAction();
    var LexerCustomAction_1 = require_LexerCustomAction();
    var LexerModeAction_1 = require_LexerModeAction();
    var LexerMoreAction_1 = require_LexerMoreAction();
    var LexerPopModeAction_1 = require_LexerPopModeAction();
    var LexerPushModeAction_1 = require_LexerPushModeAction();
    var LexerSkipAction_1 = require_LexerSkipAction();
    var LexerTypeAction_1 = require_LexerTypeAction();
    var LoopEndState_1 = require_LoopEndState();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var PlusBlockStartState_1 = require_PlusBlockStartState();
    var PlusLoopbackState_1 = require_PlusLoopbackState();
    var PrecedencePredicateTransition_1 = require_PrecedencePredicateTransition();
    var PredicateTransition_1 = require_PredicateTransition();
    var RangeTransition_1 = require_RangeTransition();
    var RuleStartState_1 = require_RuleStartState();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var SetTransition_1 = require_SetTransition();
    var StarBlockStartState_1 = require_StarBlockStartState();
    var StarLoopbackState_1 = require_StarLoopbackState();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var Token_1 = require_Token();
    var TokensStartState_1 = require_TokensStartState();
    var UUID_1 = require_UUID();
    var WildcardTransition_1 = require_WildcardTransition();
    var UnicodeDeserializingMode;
    (function(UnicodeDeserializingMode2) {
      UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_BMP"] = 0] = "UNICODE_BMP";
      UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_SMP"] = 1] = "UNICODE_SMP";
    })(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));
    var ATNDeserializer3 = class {
      constructor(deserializationOptions) {
        if (deserializationOptions === void 0) {
          deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;
        }
        this.deserializationOptions = deserializationOptions;
      }
      static get SERIALIZED_VERSION() {
        return 3;
      }
      static isFeatureSupported(feature, actualUuid) {
        let featureIndex = ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));
        if (featureIndex < 0) {
          return false;
        }
        return ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;
      }
      static getUnicodeDeserializer(mode) {
        if (mode === 0) {
          return {
            readUnicode: (data, p) => {
              return ATNDeserializer3.toInt(data[p]);
            },
            size: 1
          };
        } else {
          return {
            readUnicode: (data, p) => {
              return ATNDeserializer3.toInt32(data, p);
            },
            size: 2
          };
        }
      }
      deserialize(data) {
        data = data.slice(0);
        for (let i = 1; i < data.length; i++) {
          data[i] = data[i] - 2 & 65535;
        }
        let p = 0;
        let version = ATNDeserializer3.toInt(data[p++]);
        if (version !== ATNDeserializer3.SERIALIZED_VERSION) {
          let reason = `Could not deserialize ATN with version ${version} (expected ${ATNDeserializer3.SERIALIZED_VERSION}).`;
          throw new Error(reason);
        }
        let uuid = ATNDeserializer3.toUUID(data, p);
        p += 8;
        if (ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {
          let reason = `Could not deserialize ATN with UUID ${uuid} (expected ${ATNDeserializer3.SERIALIZED_UUID} or a legacy UUID).`;
          throw new Error(reason);
        }
        let supportsLexerActions = ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_LEXER_ACTIONS, uuid);
        let grammarType = ATNDeserializer3.toInt(data[p++]);
        let maxTokenType = ATNDeserializer3.toInt(data[p++]);
        let atn = new ATN_1.ATN(grammarType, maxTokenType);
        let loopBackStateNumbers = [];
        let endStateNumbers = [];
        let nstates = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nstates; i++) {
          let stype = ATNDeserializer3.toInt(data[p++]);
          if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {
            atn.addState(new InvalidState_1.InvalidState());
            continue;
          }
          let ruleIndex = ATNDeserializer3.toInt(data[p++]);
          if (ruleIndex === 65535) {
            ruleIndex = -1;
          }
          let s = this.stateFactory(stype, ruleIndex);
          if (stype === ATNStateType_1.ATNStateType.LOOP_END) {
            let loopBackStateNumber = ATNDeserializer3.toInt(data[p++]);
            loopBackStateNumbers.push([s, loopBackStateNumber]);
          } else if (s instanceof BlockStartState_1.BlockStartState) {
            let endStateNumber = ATNDeserializer3.toInt(data[p++]);
            endStateNumbers.push([s, endStateNumber]);
          }
          atn.addState(s);
        }
        for (let pair of loopBackStateNumbers) {
          pair[0].loopBackState = atn.states[pair[1]];
        }
        for (let pair of endStateNumbers) {
          pair[0].endState = atn.states[pair[1]];
        }
        let numNonGreedyStates = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < numNonGreedyStates; i++) {
          let stateNumber = ATNDeserializer3.toInt(data[p++]);
          atn.states[stateNumber].nonGreedy = true;
        }
        let numSllDecisions = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < numSllDecisions; i++) {
          let stateNumber = ATNDeserializer3.toInt(data[p++]);
          atn.states[stateNumber].sll = true;
        }
        let numPrecedenceStates = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < numPrecedenceStates; i++) {
          let stateNumber = ATNDeserializer3.toInt(data[p++]);
          atn.states[stateNumber].isPrecedenceRule = true;
        }
        let nrules = ATNDeserializer3.toInt(data[p++]);
        if (atn.grammarType === 0) {
          atn.ruleToTokenType = new Int32Array(nrules);
        }
        atn.ruleToStartState = new Array(nrules);
        for (let i = 0; i < nrules; i++) {
          let s = ATNDeserializer3.toInt(data[p++]);
          let startState = atn.states[s];
          startState.leftFactored = ATNDeserializer3.toInt(data[p++]) !== 0;
          atn.ruleToStartState[i] = startState;
          if (atn.grammarType === 0) {
            let tokenType = ATNDeserializer3.toInt(data[p++]);
            if (tokenType === 65535) {
              tokenType = Token_1.Token.EOF;
            }
            atn.ruleToTokenType[i] = tokenType;
            if (!ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_LEXER_ACTIONS, uuid)) {
              let actionIndexIgnored = ATNDeserializer3.toInt(data[p++]);
              if (actionIndexIgnored === 65535) {
                actionIndexIgnored = -1;
              }
            }
          }
        }
        atn.ruleToStopState = new Array(nrules);
        for (let state of atn.states) {
          if (!(state instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          atn.ruleToStopState[state.ruleIndex] = state;
          atn.ruleToStartState[state.ruleIndex].stopState = state;
        }
        let nmodes = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nmodes; i++) {
          let s = ATNDeserializer3.toInt(data[p++]);
          atn.modeToStartState.push(atn.states[s]);
        }
        atn.modeToDFA = new Array(nmodes);
        for (let i = 0; i < nmodes; i++) {
          atn.modeToDFA[i] = new DFA_1.DFA(atn.modeToStartState[i]);
        }
        let sets = [];
        p = this.deserializeSets(data, p, sets, ATNDeserializer3.getUnicodeDeserializer(0));
        if (ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_UNICODE_SMP, uuid)) {
          p = this.deserializeSets(data, p, sets, ATNDeserializer3.getUnicodeDeserializer(1));
        }
        let nedges = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nedges; i++) {
          let src = ATNDeserializer3.toInt(data[p]);
          let trg = ATNDeserializer3.toInt(data[p + 1]);
          let ttype = ATNDeserializer3.toInt(data[p + 2]);
          let arg1 = ATNDeserializer3.toInt(data[p + 3]);
          let arg2 = ATNDeserializer3.toInt(data[p + 4]);
          let arg3 = ATNDeserializer3.toInt(data[p + 5]);
          let trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
          let srcState = atn.states[src];
          srcState.addTransition(trans);
          p += 6;
        }
        let returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({
          hashCode: (o) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,
          equals: (a, b) => {
            return a.stopState === b.stopState && a.returnState === b.returnState && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;
          }
        });
        let returnTransitions = [];
        for (let state of atn.states) {
          let returningToLeftFactored = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;
          for (let i = 0; i < state.numberOfTransitions; i++) {
            let t = state.transition(i);
            if (!(t instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            let ruleTransition = t;
            let returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;
            if (!returningFromLeftFactored && returningToLeftFactored) {
              continue;
            }
            let outermostPrecedenceReturn = -1;
            if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {
              if (ruleTransition.precedence === 0) {
                outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
              }
            }
            let current = { stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn };
            if (returnTransitionsSet.add(current)) {
              returnTransitions.push(current);
            }
          }
        }
        for (let returnTransition of returnTransitions) {
          let transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);
          atn.ruleToStopState[returnTransition.stopState].addTransition(transition);
        }
        for (let state of atn.states) {
          if (state instanceof BlockStartState_1.BlockStartState) {
            if (state.endState === void 0) {
              throw new Error("IllegalStateException");
            }
            if (state.endState.startState !== void 0) {
              throw new Error("IllegalStateException");
            }
            state.endState.startState = state;
          }
          if (state instanceof PlusLoopbackState_1.PlusLoopbackState) {
            let loopbackState = state;
            for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
              let target = loopbackState.transition(i).target;
              if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {
                target.loopBackState = loopbackState;
              }
            }
          } else if (state instanceof StarLoopbackState_1.StarLoopbackState) {
            let loopbackState = state;
            for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
              let target = loopbackState.transition(i).target;
              if (target instanceof StarLoopEntryState_1.StarLoopEntryState) {
                target.loopBackState = loopbackState;
              }
            }
          }
        }
        let ndecisions = ATNDeserializer3.toInt(data[p++]);
        for (let i = 1; i <= ndecisions; i++) {
          let s = ATNDeserializer3.toInt(data[p++]);
          let decState = atn.states[s];
          atn.decisionToState.push(decState);
          decState.decision = i - 1;
        }
        if (atn.grammarType === 0) {
          if (supportsLexerActions) {
            atn.lexerActions = new Array(ATNDeserializer3.toInt(data[p++]));
            for (let i = 0; i < atn.lexerActions.length; i++) {
              let actionType = ATNDeserializer3.toInt(data[p++]);
              let data1 = ATNDeserializer3.toInt(data[p++]);
              if (data1 === 65535) {
                data1 = -1;
              }
              let data2 = ATNDeserializer3.toInt(data[p++]);
              if (data2 === 65535) {
                data2 = -1;
              }
              let lexerAction = this.lexerActionFactory(actionType, data1, data2);
              atn.lexerActions[i] = lexerAction;
            }
          } else {
            let legacyLexerActions = [];
            for (let state of atn.states) {
              for (let i = 0; i < state.numberOfTransitions; i++) {
                let transition = state.transition(i);
                if (!(transition instanceof ActionTransition_1.ActionTransition)) {
                  continue;
                }
                let ruleIndex = transition.ruleIndex;
                let actionIndex = transition.actionIndex;
                let lexerAction = new LexerCustomAction_1.LexerCustomAction(ruleIndex, actionIndex);
                state.setTransition(i, new ActionTransition_1.ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));
                legacyLexerActions.push(lexerAction);
              }
            }
            atn.lexerActions = legacyLexerActions;
          }
        }
        this.markPrecedenceDecisions(atn);
        atn.decisionToDFA = new Array(ndecisions);
        for (let i = 0; i < ndecisions; i++) {
          atn.decisionToDFA[i] = new DFA_1.DFA(atn.decisionToState[i], i);
        }
        if (this.deserializationOptions.isVerifyATN) {
          this.verifyATN(atn);
        }
        if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1) {
          atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);
          for (let i = 0; i < atn.ruleToStartState.length; i++) {
            atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
          }
          for (let i = 0; i < atn.ruleToStartState.length; i++) {
            let bypassStart = new BasicBlockStartState_1.BasicBlockStartState();
            bypassStart.ruleIndex = i;
            atn.addState(bypassStart);
            let bypassStop = new BlockEndState_1.BlockEndState();
            bypassStop.ruleIndex = i;
            atn.addState(bypassStop);
            bypassStart.endState = bypassStop;
            atn.defineDecisionState(bypassStart);
            bypassStop.startState = bypassStart;
            let endState;
            let excludeTransition;
            if (atn.ruleToStartState[i].isPrecedenceRule) {
              endState = void 0;
              for (let state of atn.states) {
                if (state.ruleIndex !== i) {
                  continue;
                }
                if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                  continue;
                }
                let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
                if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {
                  continue;
                }
                if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                  endState = state;
                  break;
                }
              }
              if (!endState) {
                throw new Error("Couldn't identify final state of the precedence rule prefix section.");
              }
              excludeTransition = endState.loopBackState.transition(0);
            } else {
              endState = atn.ruleToStopState[i];
            }
            for (let state of atn.states) {
              for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {
                let transition = state.transition(i2);
                if (transition === excludeTransition) {
                  continue;
                }
                if (transition.target === endState) {
                  transition.target = bypassStop;
                }
              }
            }
            while (atn.ruleToStartState[i].numberOfTransitions > 0) {
              let transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);
              bypassStart.addTransition(transition);
            }
            atn.ruleToStartState[i].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));
            bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));
            let matchState = new BasicState_1.BasicState();
            atn.addState(matchState);
            matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[i]));
            bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
        }
        if (this.deserializationOptions.isOptimize) {
          while (true) {
            let optimizationCount = 0;
            optimizationCount += ATNDeserializer3.inlineSetRules(atn);
            optimizationCount += ATNDeserializer3.combineChainedEpsilons(atn);
            let preserveOrder = atn.grammarType === 0;
            optimizationCount += ATNDeserializer3.optimizeSets(atn, preserveOrder);
            if (optimizationCount === 0) {
              break;
            }
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
        }
        ATNDeserializer3.identifyTailCalls(atn);
        return atn;
      }
      deserializeSets(data, p, sets, unicodeDeserializer) {
        let nsets = ATNDeserializer3.toInt(data[p++]);
        for (let i = 0; i < nsets; i++) {
          let nintervals = ATNDeserializer3.toInt(data[p]);
          p++;
          let set = new IntervalSet_1.IntervalSet();
          sets.push(set);
          let containsEof = ATNDeserializer3.toInt(data[p++]) !== 0;
          if (containsEof) {
            set.add(-1);
          }
          for (let j = 0; j < nintervals; j++) {
            let a = unicodeDeserializer.readUnicode(data, p);
            p += unicodeDeserializer.size;
            let b = unicodeDeserializer.readUnicode(data, p);
            p += unicodeDeserializer.size;
            set.add(a, b);
          }
        }
        return p;
      }
      markPrecedenceDecisions(atn) {
        let rulePrecedenceDecisions = /* @__PURE__ */ new Map();
        for (let state of atn.states) {
          if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
            continue;
          }
          if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
            let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
            if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {
              if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                rulePrecedenceDecisions.set(state.ruleIndex, state);
                state.precedenceRuleDecision = true;
                state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);
              }
            }
          }
        }
        for (let precedenceDecision of rulePrecedenceDecisions) {
          for (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {
            if (transition.serializationType !== 1) {
              continue;
            }
            let epsilonTransition = transition;
            if (epsilonTransition.outermostPrecedenceReturn !== -1) {
              continue;
            }
            precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);
          }
        }
      }
      verifyATN(atn) {
        for (let state of atn.states) {
          this.checkCondition(state !== void 0, "ATN states should not be undefined.");
          if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {
            continue;
          }
          this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);
          if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {
            this.checkCondition(state.loopBackState !== void 0);
          }
          if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {
            let starLoopEntryState = state;
            this.checkCondition(starLoopEntryState.loopBackState !== void 0);
            this.checkCondition(starLoopEntryState.numberOfTransitions === 2);
            if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);
              this.checkCondition(!starLoopEntryState.nonGreedy);
            } else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);
              this.checkCondition(starLoopEntryState.nonGreedy);
            } else {
              throw new Error("IllegalStateException");
            }
          }
          if (state instanceof StarLoopbackState_1.StarLoopbackState) {
            this.checkCondition(state.numberOfTransitions === 1);
            this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);
          }
          if (state instanceof LoopEndState_1.LoopEndState) {
            this.checkCondition(state.loopBackState !== void 0);
          }
          if (state instanceof RuleStartState_1.RuleStartState) {
            this.checkCondition(state.stopState !== void 0);
          }
          if (state instanceof BlockStartState_1.BlockStartState) {
            this.checkCondition(state.endState !== void 0);
          }
          if (state instanceof BlockEndState_1.BlockEndState) {
            this.checkCondition(state.startState !== void 0);
          }
          if (state instanceof DecisionState_1.DecisionState) {
            let decisionState = state;
            this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);
          } else {
            this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);
          }
        }
      }
      checkCondition(condition, message) {
        if (!condition) {
          throw new Error("IllegalStateException: " + message);
        }
      }
      static inlineSetRules(atn) {
        let inlinedCalls = 0;
        let ruleToInlineTransition = new Array(atn.ruleToStartState.length);
        for (let i = 0; i < atn.ruleToStartState.length; i++) {
          let startState = atn.ruleToStartState[i];
          let middleState = startState;
          while (middleState.onlyHasEpsilonTransitions && middleState.numberOfOptimizedTransitions === 1 && middleState.getOptimizedTransition(0).serializationType === 1) {
            middleState = middleState.getOptimizedTransition(0).target;
          }
          if (middleState.numberOfOptimizedTransitions !== 1) {
            continue;
          }
          let matchTransition = middleState.getOptimizedTransition(0);
          let matchTarget = matchTransition.target;
          if (matchTransition.isEpsilon || !matchTarget.onlyHasEpsilonTransitions || matchTarget.numberOfOptimizedTransitions !== 1 || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          switch (matchTransition.serializationType) {
            case 5:
            case 2:
            case 7:
              ruleToInlineTransition[i] = matchTransition;
              break;
            case 8:
            case 9:
              continue;
            default:
              continue;
          }
        }
        for (let state of atn.states) {
          if (state.ruleIndex < 0) {
            continue;
          }
          let optimizedTransitions;
          for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
            let transition = state.getOptimizedTransition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            let ruleTransition = transition;
            let effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
            if (effective === void 0) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            if (optimizedTransitions === void 0) {
              optimizedTransitions = [];
              for (let j = 0; j < i; j++) {
                optimizedTransitions.push(state.getOptimizedTransition(i));
              }
            }
            inlinedCalls++;
            let target = ruleTransition.followState;
            let intermediateState = new BasicState_1.BasicState();
            intermediateState.setRuleIndex(target.ruleIndex);
            atn.addState(intermediateState);
            optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));
            switch (effective.serializationType) {
              case 5:
                intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));
                break;
              case 2:
                intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));
                break;
              case 7:
                intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));
                break;
              default:
                throw new Error("UnsupportedOperationException");
            }
          }
          if (optimizedTransitions !== void 0) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              state.addOptimizedTransition(transition);
            }
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + inlinedCalls + " rule invocations by inlining sets.");
        }
        return inlinedCalls;
      }
      static combineChainedEpsilons(atn) {
        let removedEdges = 0;
        for (let state of atn.states) {
          if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {
            continue;
          }
          let optimizedTransitions;
          nextTransition:
            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
              let transition = state.getOptimizedTransition(i);
              let intermediate = transition.target;
              if (transition.serializationType !== 1 || transition.outermostPrecedenceReturn !== -1 || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC || !intermediate.onlyHasEpsilonTransitions) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue nextTransition;
              }
              for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                if (intermediate.getOptimizedTransition(j).serializationType !== 1 || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {
                  if (optimizedTransitions !== void 0) {
                    optimizedTransitions.push(transition);
                  }
                  continue nextTransition;
                }
              }
              removedEdges++;
              if (optimizedTransitions === void 0) {
                optimizedTransitions = [];
                for (let j = 0; j < i; j++) {
                  optimizedTransitions.push(state.getOptimizedTransition(j));
                }
              }
              for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                let target = intermediate.getOptimizedTransition(j).target;
                optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));
              }
            }
          if (optimizedTransitions !== void 0) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              state.addOptimizedTransition(transition);
            }
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + removedEdges + " transitions by combining chained epsilon transitions.");
        }
        return removedEdges;
      }
      static optimizeSets(atn, preserveOrder) {
        if (preserveOrder) {
          return 0;
        }
        let removedPaths = 0;
        let decisions = atn.decisionToState;
        for (let decision of decisions) {
          let setTransitions = new IntervalSet_1.IntervalSet();
          for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
            let epsTransition = decision.getOptimizedTransition(i);
            if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {
              continue;
            }
            if (epsTransition.target.numberOfOptimizedTransitions !== 1) {
              continue;
            }
            let transition = epsTransition.target.getOptimizedTransition(0);
            if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {
              continue;
            }
            if (transition instanceof NotSetTransition_1.NotSetTransition) {
              continue;
            }
            if (transition instanceof AtomTransition_1.AtomTransition || transition instanceof RangeTransition_1.RangeTransition || transition instanceof SetTransition_1.SetTransition) {
              setTransitions.add(i);
            }
          }
          if (setTransitions.size <= 1) {
            continue;
          }
          let optimizedTransitions = [];
          for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
            if (!setTransitions.contains(i)) {
              optimizedTransitions.push(decision.getOptimizedTransition(i));
            }
          }
          let blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;
          let matchSet = new IntervalSet_1.IntervalSet();
          for (let interval of setTransitions.intervals) {
            for (let j = interval.a; j <= interval.b; j++) {
              let matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);
              if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {
                throw new Error("Not yet implemented.");
              } else {
                matchSet.addAll(matchTransition.label);
              }
            }
          }
          let newTransition;
          if (matchSet.intervals.length === 1) {
            if (matchSet.size === 1) {
              newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);
            } else {
              let matchInterval = matchSet.intervals[0];
              newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
            }
          } else {
            newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);
          }
          let setOptimizedState = new BasicState_1.BasicState();
          setOptimizedState.setRuleIndex(decision.ruleIndex);
          atn.addState(setOptimizedState);
          setOptimizedState.addTransition(newTransition);
          optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));
          removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;
          if (decision.isOptimized) {
            while (decision.numberOfOptimizedTransitions > 0) {
              decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);
            }
          }
          for (let transition of optimizedTransitions) {
            decision.addOptimizedTransition(transition);
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + removedPaths + " paths by collapsing sets.");
        }
        return removedPaths;
      }
      static identifyTailCalls(atn) {
        for (let state of atn.states) {
          for (let i = 0; i < state.numberOfTransitions; i++) {
            let transition = state.transition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            transition.tailCall = this.testTailCall(atn, transition, false);
            transition.optimizedTailCall = this.testTailCall(atn, transition, true);
          }
          if (!state.isOptimized) {
            continue;
          }
          for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
            let transition = state.getOptimizedTransition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            transition.tailCall = this.testTailCall(atn, transition, false);
            transition.optimizedTailCall = this.testTailCall(atn, transition, true);
          }
        }
      }
      static testTailCall(atn, transition, optimizedPath) {
        if (!optimizedPath && transition.tailCall) {
          return true;
        }
        if (optimizedPath && transition.optimizedTailCall) {
          return true;
        }
        let reachable = new BitSet_1.BitSet(atn.states.length);
        let worklist = [];
        worklist.push(transition.followState);
        while (true) {
          let state = worklist.pop();
          if (!state) {
            break;
          }
          if (reachable.get(state.stateNumber)) {
            continue;
          }
          if (state instanceof RuleStopState_1.RuleStopState) {
            continue;
          }
          if (!state.onlyHasEpsilonTransitions) {
            return false;
          }
          let transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;
          for (let i = 0; i < transitionCount; i++) {
            let t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);
            if (t.serializationType !== 1) {
              return false;
            }
            worklist.push(t.target);
          }
        }
        return true;
      }
      static toInt(c) {
        return c;
      }
      static toInt32(data, offset) {
        return (data[offset] | data[offset + 1] << 16) >>> 0;
      }
      static toUUID(data, offset) {
        let leastSigBits = ATNDeserializer3.toInt32(data, offset);
        let lessSigBits = ATNDeserializer3.toInt32(data, offset + 2);
        let moreSigBits = ATNDeserializer3.toInt32(data, offset + 4);
        let mostSigBits = ATNDeserializer3.toInt32(data, offset + 6);
        return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
      }
      edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
        let target = atn.states[trg];
        switch (type) {
          case 1:
            return new EpsilonTransition_1.EpsilonTransition(target);
          case 2:
            if (arg3 !== 0) {
              return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);
            } else {
              return new RangeTransition_1.RangeTransition(target, arg1, arg2);
            }
          case 3:
            let rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);
            return rt;
          case 4:
            let pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);
            return pt;
          case 10:
            return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);
          case 5:
            if (arg3 !== 0) {
              return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);
            } else {
              return new AtomTransition_1.AtomTransition(target, arg1);
            }
          case 6:
            let a = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);
            return a;
          case 7:
            return new SetTransition_1.SetTransition(target, sets[arg1]);
          case 8:
            return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);
          case 9:
            return new WildcardTransition_1.WildcardTransition(target);
        }
        throw new Error("The specified transition type is not valid.");
      }
      stateFactory(type, ruleIndex) {
        let s;
        switch (type) {
          case ATNStateType_1.ATNStateType.INVALID_TYPE:
            return new InvalidState_1.InvalidState();
          case ATNStateType_1.ATNStateType.BASIC:
            s = new BasicState_1.BasicState();
            break;
          case ATNStateType_1.ATNStateType.RULE_START:
            s = new RuleStartState_1.RuleStartState();
            break;
          case ATNStateType_1.ATNStateType.BLOCK_START:
            s = new BasicBlockStartState_1.BasicBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
            s = new PlusBlockStartState_1.PlusBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
            s = new StarBlockStartState_1.StarBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.TOKEN_START:
            s = new TokensStartState_1.TokensStartState();
            break;
          case ATNStateType_1.ATNStateType.RULE_STOP:
            s = new RuleStopState_1.RuleStopState();
            break;
          case ATNStateType_1.ATNStateType.BLOCK_END:
            s = new BlockEndState_1.BlockEndState();
            break;
          case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
            s = new StarLoopbackState_1.StarLoopbackState();
            break;
          case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
            s = new StarLoopEntryState_1.StarLoopEntryState();
            break;
          case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
            s = new PlusLoopbackState_1.PlusLoopbackState();
            break;
          case ATNStateType_1.ATNStateType.LOOP_END:
            s = new LoopEndState_1.LoopEndState();
            break;
          default:
            let message = `The specified state type ${type} is not valid.`;
            throw new Error(message);
        }
        s.ruleIndex = ruleIndex;
        return s;
      }
      lexerActionFactory(type, data1, data2) {
        switch (type) {
          case 0:
            return new LexerChannelAction_1.LexerChannelAction(data1);
          case 1:
            return new LexerCustomAction_1.LexerCustomAction(data1, data2);
          case 2:
            return new LexerModeAction_1.LexerModeAction(data1);
          case 3:
            return LexerMoreAction_1.LexerMoreAction.INSTANCE;
          case 4:
            return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;
          case 5:
            return new LexerPushModeAction_1.LexerPushModeAction(data1);
          case 6:
            return LexerSkipAction_1.LexerSkipAction.INSTANCE;
          case 7:
            return new LexerTypeAction_1.LexerTypeAction(data1);
          default:
            let message = `The specified lexer action type ${type} is not valid.`;
            throw new Error(message);
        }
      }
    };
    ATNDeserializer3.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3");
    ATNDeserializer3.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D");
    ATNDeserializer3.ADDED_UNICODE_SMP = UUID_1.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B");
    ATNDeserializer3.SUPPORTED_UUIDS = [
      ATNDeserializer3.BASE_SERIALIZED_UUID,
      ATNDeserializer3.ADDED_LEXER_ACTIONS,
      ATNDeserializer3.ADDED_UNICODE_SMP
    ];
    ATNDeserializer3.SERIALIZED_UUID = ATNDeserializer3.ADDED_UNICODE_SMP;
    __decorate([
      Decorators_1.NotNull
    ], ATNDeserializer3.prototype, "deserializationOptions", void 0);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer3.prototype, "deserialize", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer3.prototype, "markPrecedenceDecisions", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer3.prototype, "edgeFactory", null);
    exports.ATNDeserializer = ATNDeserializer3;
  }
});

// node_modules/antlr4ts/atn/ParseInfo.js
var require_ParseInfo = __commonJS({
  "node_modules/antlr4ts/atn/ParseInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseInfo = void 0;
    var Decorators_1 = require_Decorators();
    var ParseInfo = class ParseInfo {
      constructor(atnSimulator) {
        this.atnSimulator = atnSimulator;
      }
      getDecisionInfo() {
        return this.atnSimulator.getDecisionInfo();
      }
      getLLDecisions() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let LL = [];
        for (let i = 0; i < decisions.length; i++) {
          let fallBack = decisions[i].LL_Fallback;
          if (fallBack > 0) {
            LL.push(i);
          }
        }
        return LL;
      }
      getTotalTimeInPrediction() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let t = 0;
        for (let decision of decisions) {
          t += decision.timeInPrediction;
        }
        return t;
      }
      getTotalSLLLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_TotalLook;
        }
        return k;
      }
      getTotalLLLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.LL_TotalLook;
        }
        return k;
      }
      getTotalSLLATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_ATNTransitions;
        }
        return k;
      }
      getTotalLLATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.LL_ATNTransitions;
        }
        return k;
      }
      getTotalATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_ATNTransitions;
          k += decision.LL_ATNTransitions;
        }
        return k;
      }
      getDFASize(decision) {
        if (decision) {
          let decisionToDFA = this.atnSimulator.atn.decisionToDFA[decision];
          return decisionToDFA.states.size;
        } else {
          let n = 0;
          let decisionToDFA = this.atnSimulator.atn.decisionToDFA;
          for (let i = 0; i < decisionToDFA.length; i++) {
            n += this.getDFASize(i);
          }
          return n;
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParseInfo.prototype, "getDecisionInfo", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseInfo.prototype, "getLLDecisions", null);
    ParseInfo = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParseInfo);
    exports.ParseInfo = ParseInfo;
  }
});

// node_modules/antlr4ts/ProxyParserErrorListener.js
var require_ProxyParserErrorListener = __commonJS({
  "node_modules/antlr4ts/ProxyParserErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyParserErrorListener = void 0;
    var ProxyErrorListener_1 = require_ProxyErrorListener();
    var Decorators_1 = require_Decorators();
    var ProxyParserErrorListener = class extends ProxyErrorListener_1.ProxyErrorListener {
      constructor(delegates) {
        super(delegates);
      }
      reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportAmbiguity) {
            listener.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
          }
        });
      }
      reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportAttemptingFullContext) {
            listener.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
          }
        });
      }
      reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportContextSensitivity) {
            listener.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState);
          }
        });
      }
    };
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportAmbiguity", null);
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportContextSensitivity", null);
    exports.ProxyParserErrorListener = ProxyParserErrorListener;
  }
});

// node_modules/antlr4ts/misc/Character.js
var require_Character = __commonJS({
  "node_modules/antlr4ts/misc/Character.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSupplementaryCodePoint = exports.isLowSurrogate = exports.isHighSurrogate = void 0;
    function isHighSurrogate(ch) {
      return ch >= 55296 && ch <= 56319;
    }
    exports.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(ch) {
      return ch >= 56320 && ch <= 57343;
    }
    exports.isLowSurrogate = isLowSurrogate;
    function isSupplementaryCodePoint(ch) {
      return ch >= 65536;
    }
    exports.isSupplementaryCodePoint = isSupplementaryCodePoint;
  }
});

// node_modules/antlr4ts/CodePointBuffer.js
var require_CodePointBuffer = __commonJS({
  "node_modules/antlr4ts/CodePointBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodePointBuffer = void 0;
    var assert = require("assert");
    var Character = require_Character();
    var CodePointBuffer = class {
      constructor(buffer, size) {
        this.buffer = buffer;
        this._position = 0;
        this._size = size;
      }
      static withArray(buffer) {
        return new CodePointBuffer(buffer, buffer.length);
      }
      get position() {
        return this._position;
      }
      set position(newPosition) {
        if (newPosition < 0 || newPosition > this._size) {
          throw new RangeError();
        }
        this._position = newPosition;
      }
      get remaining() {
        return this._size - this.position;
      }
      get(offset) {
        return this.buffer[offset];
      }
      array() {
        return this.buffer.slice(0, this._size);
      }
      static builder(initialBufferSize) {
        return new CodePointBuffer.Builder(initialBufferSize);
      }
    };
    exports.CodePointBuffer = CodePointBuffer;
    (function(CodePointBuffer2) {
      let Type;
      (function(Type2) {
        Type2[Type2["BYTE"] = 0] = "BYTE";
        Type2[Type2["CHAR"] = 1] = "CHAR";
        Type2[Type2["INT"] = 2] = "INT";
      })(Type || (Type = {}));
      class Builder {
        constructor(initialBufferSize) {
          this.type = 0;
          this.buffer = new Uint8Array(initialBufferSize);
          this.prevHighSurrogate = -1;
          this.position = 0;
        }
        build() {
          return new CodePointBuffer2(this.buffer, this.position);
        }
        static roundUpToNextPowerOfTwo(i) {
          let nextPowerOfTwo = 32 - Math.clz32(i - 1);
          return Math.pow(2, nextPowerOfTwo);
        }
        ensureRemaining(remainingNeeded) {
          switch (this.type) {
            case 0:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Uint8Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
            case 1:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Uint16Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
            case 2:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Int32Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
          }
        }
        append(utf16In) {
          this.ensureRemaining(utf16In.length);
          this.appendArray(utf16In);
        }
        appendArray(utf16In) {
          switch (this.type) {
            case 0:
              this.appendArrayByte(utf16In);
              break;
            case 1:
              this.appendArrayChar(utf16In);
              break;
            case 2:
              this.appendArrayInt(utf16In);
              break;
          }
        }
        appendArrayByte(utf16In) {
          assert(this.prevHighSurrogate === -1);
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outByte = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            if (c <= 255) {
              outByte[outOffset] = c;
            } else {
              utf16In = utf16In.subarray(inOffset, inLimit);
              this.position = outOffset;
              if (!Character.isHighSurrogate(c)) {
                this.byteToCharBuffer(utf16In.length);
                this.appendArrayChar(utf16In);
                return;
              } else {
                this.byteToIntBuffer(utf16In.length);
                this.appendArrayInt(utf16In);
                return;
              }
            }
            inOffset++;
            outOffset++;
          }
          this.position = outOffset;
        }
        appendArrayChar(utf16In) {
          assert(this.prevHighSurrogate === -1);
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outChar = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            if (!Character.isHighSurrogate(c)) {
              outChar[outOffset] = c;
            } else {
              utf16In = utf16In.subarray(inOffset, inLimit);
              this.position = outOffset;
              this.charToIntBuffer(utf16In.length);
              this.appendArrayInt(utf16In);
              return;
            }
            inOffset++;
            outOffset++;
          }
          this.position = outOffset;
        }
        appendArrayInt(utf16In) {
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outInt = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            inOffset++;
            if (this.prevHighSurrogate !== -1) {
              if (Character.isLowSurrogate(c)) {
                outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0);
                outOffset++;
                this.prevHighSurrogate = -1;
              } else {
                outInt[outOffset] = this.prevHighSurrogate;
                outOffset++;
                if (Character.isHighSurrogate(c)) {
                  this.prevHighSurrogate = c;
                } else {
                  outInt[outOffset] = c;
                  outOffset++;
                  this.prevHighSurrogate = -1;
                }
              }
            } else if (Character.isHighSurrogate(c)) {
              this.prevHighSurrogate = c;
            } else {
              outInt[outOffset] = c;
              outOffset++;
            }
          }
          if (this.prevHighSurrogate !== -1) {
            outInt[outOffset] = this.prevHighSurrogate;
            outOffset++;
          }
          this.position = outOffset;
        }
        byteToCharBuffer(toAppend) {
          let newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 1;
          this.buffer = newBuffer;
        }
        byteToIntBuffer(toAppend) {
          let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 2;
          this.buffer = newBuffer;
        }
        charToIntBuffer(toAppend) {
          let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 2;
          this.buffer = newBuffer;
        }
      }
      CodePointBuffer2.Builder = Builder;
    })(CodePointBuffer = exports.CodePointBuffer || (exports.CodePointBuffer = {}));
  }
});

// node_modules/antlr4ts/CodePointCharStream.js
var require_CodePointCharStream = __commonJS({
  "node_modules/antlr4ts/CodePointCharStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodePointCharStream = void 0;
    var assert = require("assert");
    var IntStream_1 = require_IntStream();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var CodePointCharStream = class {
      constructor(array, position2, remaining, name) {
        assert(position2 === 0);
        this._array = array;
        this._size = remaining;
        this._name = name;
        this._position = 0;
      }
      get internalStorage() {
        return this._array;
      }
      static fromBuffer(codePointBuffer, name) {
        if (name === void 0 || name.length === 0) {
          name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        return new CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);
      }
      consume() {
        if (this._size - this._position === 0) {
          assert(this.LA(1) === IntStream_1.IntStream.EOF);
          throw new RangeError("cannot consume EOF");
        }
        this._position++;
      }
      get index() {
        return this._position;
      }
      get size() {
        return this._size;
      }
      mark() {
        return -1;
      }
      release(marker) {
      }
      seek(index2) {
        this._position = index2;
      }
      get sourceName() {
        return this._name;
      }
      toString() {
        return this.getText(Interval_1.Interval.of(0, this.size - 1));
      }
      LA(i) {
        let offset;
        switch (Math.sign(i)) {
          case -1:
            offset = this.index + i;
            if (offset < 0) {
              return IntStream_1.IntStream.EOF;
            }
            return this._array[offset];
          case 0:
            return 0;
          case 1:
            offset = this.index + i - 1;
            if (offset >= this.size) {
              return IntStream_1.IntStream.EOF;
            }
            return this._array[offset];
        }
        throw new RangeError("Not reached");
      }
      getText(interval) {
        const startIdx = Math.min(interval.a, this.size);
        const len = Math.min(interval.b - interval.a + 1, this.size - startIdx);
        if (this._array instanceof Int32Array) {
          return String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));
        } else {
          return String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));
        }
      }
    };
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "toString", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "LA", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "getText", null);
    exports.CodePointCharStream = CodePointCharStream;
  }
});

// node_modules/antlr4ts/CharStreams.js
var require_CharStreams = __commonJS({
  "node_modules/antlr4ts/CharStreams.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CharStreams = void 0;
    var CodePointBuffer_1 = require_CodePointBuffer();
    var CodePointCharStream_1 = require_CodePointCharStream();
    var IntStream_1 = require_IntStream();
    var CharStreams;
    (function(CharStreams2) {
      function fromString(s, sourceName) {
        if (sourceName === void 0 || sourceName.length === 0) {
          sourceName = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        let codePointBufferBuilder = CodePointBuffer_1.CodePointBuffer.builder(s.length);
        let cb = new Uint16Array(s.length);
        for (let i = 0; i < s.length; i++) {
          cb[i] = s.charCodeAt(i);
        }
        codePointBufferBuilder.append(cb);
        return CodePointCharStream_1.CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);
      }
      CharStreams2.fromString = fromString;
    })(CharStreams = exports.CharStreams || (exports.CharStreams = {}));
  }
});

// node_modules/antlr4ts/BufferedTokenStream.js
var require_BufferedTokenStream = __commonJS({
  "node_modules/antlr4ts/BufferedTokenStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BufferedTokenStream = void 0;
    var assert = require("assert");
    var CommonToken_1 = require_CommonToken();
    var Interval_1 = require_Interval();
    var Lexer_1 = require_Lexer();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var BufferedTokenStream = class BufferedTokenStream {
      constructor(tokenSource) {
        this.tokens = [];
        this.p = -1;
        this.fetchedEOF = false;
        if (tokenSource == null) {
          throw new Error("tokenSource cannot be null");
        }
        this._tokenSource = tokenSource;
      }
      get tokenSource() {
        return this._tokenSource;
      }
      set tokenSource(tokenSource) {
        this._tokenSource = tokenSource;
        this.tokens.length = 0;
        this.p = -1;
        this.fetchedEOF = false;
      }
      get index() {
        return this.p;
      }
      mark() {
        return 0;
      }
      release(marker) {
      }
      seek(index2) {
        this.lazyInit();
        this.p = this.adjustSeekIndex(index2);
      }
      get size() {
        return this.tokens.length;
      }
      consume() {
        let skipEofCheck;
        if (this.p >= 0) {
          if (this.fetchedEOF) {
            skipEofCheck = this.p < this.tokens.length - 1;
          } else {
            skipEofCheck = this.p < this.tokens.length;
          }
        } else {
          skipEofCheck = false;
        }
        if (!skipEofCheck && this.LA(1) === Token_1.Token.EOF) {
          throw new Error("cannot consume EOF");
        }
        if (this.sync(this.p + 1)) {
          this.p = this.adjustSeekIndex(this.p + 1);
        }
      }
      sync(i) {
        assert(i >= 0);
        let n = i - this.tokens.length + 1;
        if (n > 0) {
          let fetched = this.fetch(n);
          return fetched >= n;
        }
        return true;
      }
      fetch(n) {
        if (this.fetchedEOF) {
          return 0;
        }
        for (let i = 0; i < n; i++) {
          let t = this.tokenSource.nextToken();
          if (this.isWritableToken(t)) {
            t.tokenIndex = this.tokens.length;
          }
          this.tokens.push(t);
          if (t.type === Token_1.Token.EOF) {
            this.fetchedEOF = true;
            return i + 1;
          }
        }
        return n;
      }
      get(i) {
        if (i < 0 || i >= this.tokens.length) {
          throw new RangeError("token index " + i + " out of range 0.." + (this.tokens.length - 1));
        }
        return this.tokens[i];
      }
      getRange(start, stop) {
        if (start < 0 || stop < 0) {
          return [];
        }
        this.lazyInit();
        let subset = new Array();
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        for (let i = start; i <= stop; i++) {
          let t = this.tokens[i];
          if (t.type === Token_1.Token.EOF) {
            break;
          }
          subset.push(t);
        }
        return subset;
      }
      LA(i) {
        let token = this.LT(i);
        if (!token) {
          return Token_1.Token.INVALID_TYPE;
        }
        return token.type;
      }
      tryLB(k) {
        if (this.p - k < 0) {
          return void 0;
        }
        return this.tokens[this.p - k];
      }
      LT(k) {
        let result = this.tryLT(k);
        if (result === void 0) {
          throw new RangeError("requested lookback index out of range");
        }
        return result;
      }
      tryLT(k) {
        this.lazyInit();
        if (k === 0) {
          throw new RangeError("0 is not a valid lookahead index");
        }
        if (k < 0) {
          return this.tryLB(-k);
        }
        let i = this.p + k - 1;
        this.sync(i);
        if (i >= this.tokens.length) {
          return this.tokens[this.tokens.length - 1];
        }
        return this.tokens[i];
      }
      adjustSeekIndex(i) {
        return i;
      }
      lazyInit() {
        if (this.p === -1) {
          this.setup();
        }
      }
      setup() {
        this.sync(0);
        this.p = this.adjustSeekIndex(0);
      }
      getTokens(start, stop, types) {
        this.lazyInit();
        if (start === void 0) {
          assert(stop === void 0 && types === void 0);
          return this.tokens;
        } else if (stop === void 0) {
          stop = this.tokens.length - 1;
        }
        if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
          throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
        }
        if (start > stop) {
          return [];
        }
        if (types === void 0) {
          return this.tokens.slice(start, stop + 1);
        } else if (typeof types === "number") {
          types = (/* @__PURE__ */ new Set()).add(types);
        }
        let typesSet = types;
        let filteredTokens = this.tokens.slice(start, stop + 1);
        filteredTokens = filteredTokens.filter((value2) => typesSet.has(value2.type));
        return filteredTokens;
      }
      nextTokenOnChannel(i, channel) {
        this.sync(i);
        if (i >= this.size) {
          return this.size - 1;
        }
        let token = this.tokens[i];
        while (token.channel !== channel) {
          if (token.type === Token_1.Token.EOF) {
            return i;
          }
          i++;
          this.sync(i);
          token = this.tokens[i];
        }
        return i;
      }
      previousTokenOnChannel(i, channel) {
        this.sync(i);
        if (i >= this.size) {
          return this.size - 1;
        }
        while (i >= 0) {
          let token = this.tokens[i];
          if (token.type === Token_1.Token.EOF || token.channel === channel) {
            return i;
          }
          i--;
        }
        return i;
      }
      getHiddenTokensToRight(tokenIndex, channel = -1) {
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
        }
        let nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
        let to;
        let from = tokenIndex + 1;
        if (nextOnChannel === -1) {
          to = this.size - 1;
        } else {
          to = nextOnChannel;
        }
        return this.filterForChannel(from, to, channel);
      }
      getHiddenTokensToLeft(tokenIndex, channel = -1) {
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
        }
        if (tokenIndex === 0) {
          return [];
        }
        let prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
        if (prevOnChannel === tokenIndex - 1) {
          return [];
        }
        let from = prevOnChannel + 1;
        let to = tokenIndex - 1;
        return this.filterForChannel(from, to, channel);
      }
      filterForChannel(from, to, channel) {
        let hidden = new Array();
        for (let i = from; i <= to; i++) {
          let t = this.tokens[i];
          if (channel === -1) {
            if (t.channel !== Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL) {
              hidden.push(t);
            }
          } else {
            if (t.channel === channel) {
              hidden.push(t);
            }
          }
        }
        return hidden;
      }
      get sourceName() {
        return this.tokenSource.sourceName;
      }
      getText(interval) {
        if (interval === void 0) {
          interval = Interval_1.Interval.of(0, this.size - 1);
        } else if (!(interval instanceof Interval_1.Interval)) {
          interval = interval.sourceInterval;
        }
        let start = interval.a;
        let stop = interval.b;
        if (start < 0 || stop < 0) {
          return "";
        }
        this.fill();
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        let buf = "";
        for (let i = start; i <= stop; i++) {
          let t = this.tokens[i];
          if (t.type === Token_1.Token.EOF) {
            break;
          }
          buf += t.text;
        }
        return buf.toString();
      }
      getTextFromRange(start, stop) {
        if (this.isToken(start) && this.isToken(stop)) {
          return this.getText(Interval_1.Interval.of(start.tokenIndex, stop.tokenIndex));
        }
        return "";
      }
      fill() {
        this.lazyInit();
        const blockSize = 1e3;
        while (true) {
          let fetched = this.fetch(blockSize);
          if (fetched < blockSize) {
            return;
          }
        }
      }
      isWritableToken(t) {
        return t instanceof CommonToken_1.CommonToken;
      }
      isToken(t) {
        return t instanceof CommonToken_1.CommonToken;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], BufferedTokenStream.prototype, "_tokenSource", void 0);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "get", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "LA", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "LT", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "sourceName", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "getText", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "getTextFromRange", null);
    BufferedTokenStream = __decorate([
      __param(0, Decorators_1.NotNull)
    ], BufferedTokenStream);
    exports.BufferedTokenStream = BufferedTokenStream;
  }
});

// node_modules/antlr4ts/CommonTokenStream.js
var require_CommonTokenStream = __commonJS({
  "node_modules/antlr4ts/CommonTokenStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonTokenStream = void 0;
    var BufferedTokenStream_1 = require_BufferedTokenStream();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var CommonTokenStream2 = class CommonTokenStream extends BufferedTokenStream_1.BufferedTokenStream {
      constructor(tokenSource, channel = Token_1.Token.DEFAULT_CHANNEL) {
        super(tokenSource);
        this.channel = channel;
      }
      adjustSeekIndex(i) {
        return this.nextTokenOnChannel(i, this.channel);
      }
      tryLB(k) {
        if (this.p - k < 0) {
          return void 0;
        }
        let i = this.p;
        let n = 1;
        while (n <= k && i > 0) {
          i = this.previousTokenOnChannel(i - 1, this.channel);
          n++;
        }
        if (i < 0) {
          return void 0;
        }
        return this.tokens[i];
      }
      tryLT(k) {
        this.lazyInit();
        if (k === 0) {
          throw new RangeError("0 is not a valid lookahead index");
        }
        if (k < 0) {
          return this.tryLB(-k);
        }
        let i = this.p;
        let n = 1;
        while (n < k) {
          if (this.sync(i + 1)) {
            i = this.nextTokenOnChannel(i + 1, this.channel);
          }
          n++;
        }
        return this.tokens[i];
      }
      getNumberOfOnChannelTokens() {
        let n = 0;
        this.fill();
        for (let t of this.tokens) {
          if (t.channel === this.channel) {
            n++;
          }
          if (t.type === Token_1.Token.EOF) {
            break;
          }
        }
        return n;
      }
    };
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "adjustSeekIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "tryLB", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "tryLT", null);
    CommonTokenStream2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], CommonTokenStream2);
    exports.CommonTokenStream = CommonTokenStream2;
  }
});

// node_modules/antlr4ts/ListTokenSource.js
var require_ListTokenSource = __commonJS({
  "node_modules/antlr4ts/ListTokenSource.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListTokenSource = void 0;
    var CommonTokenFactory_1 = require_CommonTokenFactory();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var ListTokenSource = class ListTokenSource {
      constructor(tokens, sourceName) {
        this.i = 0;
        this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
        if (tokens == null) {
          throw new Error("tokens cannot be null");
        }
        this.tokens = tokens;
        this._sourceName = sourceName;
      }
      get charPositionInLine() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].charPositionInLine;
        } else if (this.eofToken != null) {
          return this.eofToken.charPositionInLine;
        } else if (this.tokens.length > 0) {
          let lastToken = this.tokens[this.tokens.length - 1];
          let tokenText = lastToken.text;
          if (tokenText != null) {
            let lastNewLine = tokenText.lastIndexOf("\n");
            if (lastNewLine >= 0) {
              return tokenText.length - lastNewLine - 1;
            }
          }
          return lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;
        }
        return 0;
      }
      nextToken() {
        if (this.i >= this.tokens.length) {
          if (this.eofToken == null) {
            let start = -1;
            if (this.tokens.length > 0) {
              let previousStop = this.tokens[this.tokens.length - 1].stopIndex;
              if (previousStop !== -1) {
                start = previousStop + 1;
              }
            }
            let stop = Math.max(-1, start - 1);
            this.eofToken = this._factory.create({ source: this, stream: this.inputStream }, Token_1.Token.EOF, "EOF", Token_1.Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);
          }
          return this.eofToken;
        }
        let t = this.tokens[this.i];
        if (this.i === this.tokens.length - 1 && t.type === Token_1.Token.EOF) {
          this.eofToken = t;
        }
        this.i++;
        return t;
      }
      get line() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].line;
        } else if (this.eofToken != null) {
          return this.eofToken.line;
        } else if (this.tokens.length > 0) {
          let lastToken = this.tokens[this.tokens.length - 1];
          let line = lastToken.line;
          let tokenText = lastToken.text;
          if (tokenText != null) {
            for (let i = 0; i < tokenText.length; i++) {
              if (tokenText.charAt(i) === "\n") {
                line++;
              }
            }
          }
          return line;
        }
        return 1;
      }
      get inputStream() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].inputStream;
        } else if (this.eofToken != null) {
          return this.eofToken.inputStream;
        } else if (this.tokens.length > 0) {
          return this.tokens[this.tokens.length - 1].inputStream;
        }
        return void 0;
      }
      get sourceName() {
        if (this._sourceName) {
          return this._sourceName;
        }
        let inputStream = this.inputStream;
        if (inputStream != null) {
          return inputStream.sourceName;
        }
        return "List";
      }
      set tokenFactory(factory) {
        this._factory = factory;
      }
      get tokenFactory() {
        return this._factory;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "nextToken", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ListTokenSource.prototype, "tokenFactory", null);
    ListTokenSource = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ListTokenSource);
    exports.ListTokenSource = ListTokenSource;
  }
});

// node_modules/antlr4ts/misc/MultiMap.js
var require_MultiMap = __commonJS({
  "node_modules/antlr4ts/misc/MultiMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiMap = void 0;
    var MultiMap = class extends Map {
      constructor() {
        super();
      }
      map(key, value2) {
        let elementsForKey = super.get(key);
        if (!elementsForKey) {
          elementsForKey = [];
          super.set(key, elementsForKey);
        }
        elementsForKey.push(value2);
      }
      getPairs() {
        let pairs = [];
        this.forEach((values, key) => {
          values.forEach((v) => {
            pairs.push([key, v]);
          });
        });
        return pairs;
      }
    };
    exports.MultiMap = MultiMap;
  }
});

// node_modules/antlr4ts/misc/ParseCancellationException.js
var require_ParseCancellationException = __commonJS({
  "node_modules/antlr4ts/misc/ParseCancellationException.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseCancellationException = void 0;
    var ParseCancellationException = class extends Error {
      constructor(cause) {
        super(cause.message);
        this.cause = cause;
        this.stack = cause.stack;
      }
      getCause() {
        return this.cause;
      }
    };
    exports.ParseCancellationException = ParseCancellationException;
  }
});

// node_modules/antlr4ts/InterpreterRuleContext.js
var require_InterpreterRuleContext = __commonJS({
  "node_modules/antlr4ts/InterpreterRuleContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InterpreterRuleContext = void 0;
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var InterpreterRuleContext = class extends ParserRuleContext_1.ParserRuleContext {
      constructor(ruleIndex, parent, invokingStateNumber) {
        if (invokingStateNumber !== void 0) {
          super(parent, invokingStateNumber);
        } else {
          super();
        }
        this._ruleIndex = ruleIndex;
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InterpreterRuleContext.prototype, "ruleIndex", null);
    exports.InterpreterRuleContext = InterpreterRuleContext;
  }
});

// node_modules/antlr4ts/ParserInterpreter.js
var require_ParserInterpreter = __commonJS({
  "node_modules/antlr4ts/ParserInterpreter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserInterpreter = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var BitSet_1 = require_BitSet();
    var FailedPredicateException_1 = require_FailedPredicateException();
    var InputMismatchException_1 = require_InputMismatchException();
    var InterpreterRuleContext_1 = require_InterpreterRuleContext();
    var LoopEndState_1 = require_LoopEndState();
    var Decorators_1 = require_Decorators();
    var Decorators_2 = require_Decorators();
    var Parser_1 = require_Parser();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var RecognitionException_1 = require_RecognitionException();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var Token_1 = require_Token();
    var ParserInterpreter = class ParserInterpreter2 extends Parser_1.Parser {
      constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
        super(grammarFileName instanceof ParserInterpreter2 ? grammarFileName.inputStream : input);
        this._parentContextStack = [];
        this.overrideDecision = -1;
        this.overrideDecisionInputIndex = -1;
        this.overrideDecisionAlt = -1;
        this.overrideDecisionReached = false;
        this._overrideDecisionRoot = void 0;
        if (grammarFileName instanceof ParserInterpreter2) {
          let old = grammarFileName;
          this._grammarFileName = old._grammarFileName;
          this._atn = old._atn;
          this.pushRecursionContextStates = old.pushRecursionContextStates;
          this._ruleNames = old._ruleNames;
          this._vocabulary = old._vocabulary;
          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this._atn, this);
        } else {
          vocabulary = vocabulary;
          ruleNames = ruleNames;
          atn = atn;
          this._grammarFileName = grammarFileName;
          this._atn = atn;
          this._ruleNames = ruleNames.slice(0);
          this._vocabulary = vocabulary;
          this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);
          for (let state of atn.states) {
            if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
              continue;
            }
            if (state.precedenceRuleDecision) {
              this.pushRecursionContextStates.set(state.stateNumber);
            }
          }
          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, this);
        }
      }
      reset(resetInput) {
        if (resetInput === void 0) {
          super.reset();
        } else {
          super.reset(resetInput);
        }
        this.overrideDecisionReached = false;
        this._overrideDecisionRoot = void 0;
      }
      get atn() {
        return this._atn;
      }
      get vocabulary() {
        return this._vocabulary;
      }
      get ruleNames() {
        return this._ruleNames;
      }
      get grammarFileName() {
        return this._grammarFileName;
      }
      parse(startRuleIndex) {
        let startRuleStartState = this._atn.ruleToStartState[startRuleIndex];
        this._rootContext = this.createInterpreterRuleContext(void 0, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);
        if (startRuleStartState.isPrecedenceRule) {
          this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
        } else {
          this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);
        }
        while (true) {
          let p = this.atnState;
          switch (p.stateType) {
            case ATNStateType_1.ATNStateType.RULE_STOP:
              if (this._ctx.isEmpty) {
                if (startRuleStartState.isPrecedenceRule) {
                  let result = this._ctx;
                  let parentContext = this._parentContextStack.pop();
                  this.unrollRecursionContexts(parentContext[0]);
                  return result;
                } else {
                  this.exitRule();
                  return this._rootContext;
                }
              }
              this.visitRuleStopState(p);
              break;
            default:
              try {
                this.visitState(p);
              } catch (e) {
                if (e instanceof RecognitionException_1.RecognitionException) {
                  this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;
                  this.context.exception = e;
                  this.errorHandler.reportError(this, e);
                  this.recover(e);
                } else {
                  throw e;
                }
              }
              break;
          }
        }
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this._parentContextStack.push([this._ctx, localctx.invokingState]);
        super.enterRecursionRule(localctx, state, ruleIndex, precedence);
      }
      get atnState() {
        return this._atn.states[this.state];
      }
      visitState(p) {
        let predictedAlt = 1;
        if (p.numberOfTransitions > 1) {
          predictedAlt = this.visitDecisionState(p);
        }
        let transition = p.transition(predictedAlt - 1);
        switch (transition.serializationType) {
          case 1:
            if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target instanceof LoopEndState_1.LoopEndState)) {
              let parentContext = this._parentContextStack[this._parentContextStack.length - 1];
              let localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);
              this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);
            }
            break;
          case 5:
            this.match(transition._label);
            break;
          case 2:
          case 7:
          case 8:
            if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {
              this.recoverInline();
            }
            this.matchWildcard();
            break;
          case 9:
            this.matchWildcard();
            break;
          case 3:
            let ruleStartState = transition.target;
            let ruleIndex = ruleStartState.ruleIndex;
            let newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);
            if (ruleStartState.isPrecedenceRule) {
              this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);
            } else {
              this.enterRule(newctx, transition.target.stateNumber, ruleIndex);
            }
            break;
          case 4:
            let predicateTransition = transition;
            if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
              throw new FailedPredicateException_1.FailedPredicateException(this);
            }
            break;
          case 6:
            let actionTransition = transition;
            this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);
            break;
          case 10:
            if (!this.precpred(this._ctx, transition.precedence)) {
              let precedence = transition.precedence;
              throw new FailedPredicateException_1.FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
            }
            break;
          default:
            throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
        }
        this.state = transition.target.stateNumber;
      }
      visitDecisionState(p) {
        let predictedAlt;
        this.errorHandler.sync(this);
        let decision = p.decision;
        if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {
          predictedAlt = this.overrideDecisionAlt;
          this.overrideDecisionReached = true;
        } else {
          predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);
        }
        return predictedAlt;
      }
      createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
        return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
      }
      visitRuleStopState(p) {
        let ruleStartState = this._atn.ruleToStartState[p.ruleIndex];
        if (ruleStartState.isPrecedenceRule) {
          let parentContext = this._parentContextStack.pop();
          this.unrollRecursionContexts(parentContext[0]);
          this.state = parentContext[1];
        } else {
          this.exitRule();
        }
        let ruleTransition = this._atn.states[this.state].transition(0);
        this.state = ruleTransition.followState.stateNumber;
      }
      addDecisionOverride(decision, tokenIndex, forcedAlt) {
        this.overrideDecision = decision;
        this.overrideDecisionInputIndex = tokenIndex;
        this.overrideDecisionAlt = forcedAlt;
      }
      get overrideDecisionRoot() {
        return this._overrideDecisionRoot;
      }
      recover(e) {
        let i = this._input.index;
        this.errorHandler.recover(this, e);
        if (this._input.index === i) {
          let tok = e.getOffendingToken();
          if (!tok) {
            throw new Error("Expected exception to have an offending token");
          }
          let source = tok.tokenSource;
          let stream = source !== void 0 ? source.inputStream : void 0;
          let sourcePair = { source, stream };
          if (e instanceof InputMismatchException_1.InputMismatchException) {
            let expectedTokens = e.expectedTokens;
            if (expectedTokens === void 0) {
              throw new Error("Expected the exception to provide expected tokens");
            }
            let expectedTokenType = Token_1.Token.INVALID_TYPE;
            if (!expectedTokens.isNil) {
              expectedTokenType = expectedTokens.minElement;
            }
            let errToken = this.tokenFactory.create(sourcePair, expectedTokenType, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, tok.line, tok.charPositionInLine);
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
          } else {
            let source2 = tok.tokenSource;
            let errToken = this.tokenFactory.create(sourcePair, Token_1.Token.INVALID_TYPE, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, tok.line, tok.charPositionInLine);
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
          }
        }
      }
      recoverInline() {
        return this._errHandler.recoverInline(this);
      }
      get rootContext() {
        return this._rootContext;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParserInterpreter.prototype, "_vocabulary", void 0);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "reset", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "atn", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "vocabulary", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "ruleNames", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "grammarFileName", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "enterRecursionRule", null);
    ParserInterpreter = __decorate([
      __param(1, Decorators_1.NotNull)
    ], ParserInterpreter);
    exports.ParserInterpreter = ParserInterpreter;
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js
var require_ParseTreeMatch = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreeMatch = void 0;
    var Decorators_1 = require_Decorators();
    var ParseTreeMatch = class ParseTreeMatch {
      constructor(tree, pattern, labels, mismatchedNode) {
        if (!tree) {
          throw new Error("tree cannot be null");
        }
        if (!pattern) {
          throw new Error("pattern cannot be null");
        }
        if (!labels) {
          throw new Error("labels cannot be null");
        }
        this._tree = tree;
        this._pattern = pattern;
        this._labels = labels;
        this._mismatchedNode = mismatchedNode;
      }
      get(label) {
        let parseTrees = this._labels.get(label);
        if (!parseTrees || parseTrees.length === 0) {
          return void 0;
        }
        return parseTrees[parseTrees.length - 1];
      }
      getAll(label) {
        const nodes = this._labels.get(label);
        if (!nodes) {
          return [];
        }
        return nodes;
      }
      get labels() {
        return this._labels;
      }
      get mismatchedNode() {
        return this._mismatchedNode;
      }
      get succeeded() {
        return !this._mismatchedNode;
      }
      get pattern() {
        return this._pattern;
      }
      get tree() {
        return this._tree;
      }
      toString() {
        return `Match ${this.succeeded ? "succeeded" : "failed"}; found ${this.labels.size} labels`;
      }
    };
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParseTreeMatch.prototype, "getAll", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "labels", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "pattern", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "tree", null);
    __decorate([
      Decorators_1.Override
    ], ParseTreeMatch.prototype, "toString", null);
    ParseTreeMatch = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParseTreeMatch);
    exports.ParseTreeMatch = ParseTreeMatch;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathLexer.js
var require_XPathLexer = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathLexer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathLexer = void 0;
    var ATNDeserializer_1 = require_ATNDeserializer();
    var Lexer_1 = require_Lexer();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var Utils3 = require_Utils();
    var XPathLexer = class extends Lexer_1.Lexer {
      constructor(input) {
        super(input);
        this._interp = new LexerATNSimulator_1.LexerATNSimulator(XPathLexer._ATN, this);
      }
      get vocabulary() {
        return XPathLexer.VOCABULARY;
      }
      get grammarFileName() {
        return "XPathLexer.g4";
      }
      get ruleNames() {
        return XPathLexer.ruleNames;
      }
      get serializedATN() {
        return XPathLexer._serializedATN;
      }
      get channelNames() {
        return XPathLexer.channelNames;
      }
      get modeNames() {
        return XPathLexer.modeNames;
      }
      action(_localctx, ruleIndex, actionIndex) {
        switch (ruleIndex) {
          case 4:
            this.ID_action(_localctx, actionIndex);
            break;
        }
      }
      ID_action(_localctx, actionIndex) {
        switch (actionIndex) {
          case 0:
            let text4 = this.text;
            if (text4.charAt(0) === text4.charAt(0).toUpperCase()) {
              this.type = XPathLexer.TOKEN_REF;
            } else {
              this.type = XPathLexer.RULE_REF;
            }
            break;
        }
      }
      static get _ATN() {
        if (!XPathLexer.__ATN) {
          XPathLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils3.toCharArray(XPathLexer._serializedATN));
        }
        return XPathLexer.__ATN;
      }
    };
    exports.XPathLexer = XPathLexer;
    XPathLexer.TOKEN_REF = 1;
    XPathLexer.RULE_REF = 2;
    XPathLexer.ANYWHERE = 3;
    XPathLexer.ROOT = 4;
    XPathLexer.WILDCARD = 5;
    XPathLexer.BANG = 6;
    XPathLexer.ID = 7;
    XPathLexer.STRING = 8;
    XPathLexer.channelNames = [
      "DEFAULT_TOKEN_CHANNEL",
      "HIDDEN"
    ];
    XPathLexer.modeNames = [
      "DEFAULT_MODE"
    ];
    XPathLexer.ruleNames = [
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "NameChar",
      "NameStartChar",
      "STRING"
    ];
    XPathLexer._LITERAL_NAMES = [
      void 0,
      void 0,
      void 0,
      "'//'",
      "'/'",
      "'*'",
      "'!'"
    ];
    XPathLexer._SYMBOLIC_NAMES = [
      void 0,
      "TOKEN_REF",
      "RULE_REF",
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "STRING"
    ];
    XPathLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);
    XPathLexer._serializedATNSegments = 2;
    XPathLexer._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\n2\b					\x07	\x07\b	\b			\x07\n\f"\v\x07\x07\b\b		\x07	,\n	\f		/\v			-\n\x07\x07	\b\v	\r\n\u02B6\n2;C\\aac|\x81\xA1\xAC\xAC\xAF\xAF\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0302\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u0485\u0489\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u0593\u05BF\u05C1\u05C1\u05C3\u05C4\u05C6\u05C7\u05C9\u05C9\u05D2\u05EC\u05F2\u05F4\u0602\u0607\u0612\u061C\u061E\u061E\u0622\u066B\u0670\u06D5\u06D7\u06DF\u06E1\u06EA\u06EC\u06FE\u0701\u0701\u0711\u074C\u074F\u07B3\u07C2\u07F7\u07FC\u07FC\u0802\u082F\u0842\u085D\u08A2\u08B6\u08B8\u08BF\u08D6\u0965\u0968\u0971\u0973\u0985\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BE\u09C6\u09C9\u09CA\u09CD\u09D0\u09D9\u09D9\u09DE\u09DF\u09E1\u09E5\u09E8\u09F3\u0A03\u0A05\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A3E\u0A3E\u0A40\u0A44\u0A49\u0A4A\u0A4D\u0A4F\u0A53\u0A53\u0A5B\u0A5E\u0A60\u0A60\u0A68\u0A77\u0A83\u0A85\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABE\u0AC7\u0AC9\u0ACB\u0ACD\u0ACF\u0AD2\u0AD2\u0AE2\u0AE5\u0AE8\u0AF1\u0AFB\u0AFB\u0B03\u0B05\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3E\u0B46\u0B49\u0B4A\u0B4D\u0B4F\u0B58\u0B59\u0B5E\u0B5F\u0B61\u0B65\u0B68\u0B71\u0B73\u0B73\u0B84\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BC0\u0BC4\u0BC8\u0BCA\u0BCC\u0BCF\u0BD2\u0BD2\u0BD9\u0BD9\u0BE8\u0BF1\u0C02\u0C05\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C46\u0C48\u0C4A\u0C4C\u0C4F\u0C57\u0C58\u0C5A\u0C5C\u0C62\u0C65\u0C68\u0C71\u0C82\u0C85\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBE\u0CC6\u0CC8\u0CCA\u0CCC\u0CCF\u0CD7\u0CD8\u0CE0\u0CE0\u0CE2\u0CE5\u0CE8\u0CF1\u0CF3\u0CF4\u0D03\u0D05\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D46\u0D48\u0D4A\u0D4C\u0D50\u0D56\u0D59\u0D61\u0D65\u0D68\u0D71\u0D7C\u0D81\u0D84\u0D85\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0DCC\u0DCC\u0DD1\u0DD6\u0DD8\u0DD8\u0DDA\u0DE1\u0DE8\u0DF1\u0DF4\u0DF5\u0E03\u0E3C\u0E42\u0E50\u0E52\u0E5B\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EBB\u0EBD\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0ECA\u0ECF\u0ED2\u0EDB\u0EDE\u0EE1\u0F02\u0F02\u0F1A\u0F1B\u0F22\u0F2B\u0F37\u0F37\u0F39\u0F39\u0F3B\u0F3B\u0F40\u0F49\u0F4B\u0F6E\u0F73\u0F86\u0F88\u0F99\u0F9B\u0FBE\u0FC8\u0FC8\u1002\u104B\u1052\u109F\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u135F\u1361\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1716\u1722\u1736\u1742\u1755\u1762\u176E\u1770\u1772\u1774\u1775\u1782\u17D5\u17D9\u17D9\u17DE\u17DF\u17E2\u17EB\u180D\u1810\u1812\u181B\u1822\u1879\u1882\u18AC\u18B2\u18F7\u1902\u1920\u1922\u192D\u1932\u193D\u1948\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u19D2\u19DB\u1A02\u1A1D\u1A22\u1A60\u1A62\u1A7E\u1A81\u1A8B\u1A92\u1A9B\u1AA9\u1AA9\u1AB2\u1ABF\u1B02\u1B4D\u1B52\u1B5B\u1B6D\u1B75\u1B82\u1BF5\u1C02\u1C39\u1C42\u1C4B\u1C4F\u1C7F\u1C82\u1C8A\u1CD2\u1CD4\u1CD6\u1CF8\u1CFA\u1CFB\u1D02\u1DF7\u1DFD\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u200D\u2011\u202C\u2030\u2041\u2042\u2056\u2056\u2062\u2066\u2068\u2071\u2073\u2073\u2081\u2081\u2092\u209E\u20D2\u20DE\u20E3\u20E3\u20E7\u20F2\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D81\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2DE2\u2E01\u2E31\u2E31\u3007\u3009\u3023\u3031\u3033\u3037\u303A\u303E\u3043\u3098\u309B\u309C\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA62D\uA642\uA671\uA676\uA67F\uA681\uA6F3\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA829\uA842\uA875\uA882\uA8C7\uA8D2\uA8DB\uA8E2\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA902\uA92F\uA932\uA955\uA962\uA97E\uA982\uA9C2\uA9D1\uA9DB\uA9E2\uAA00\uAA02\uAA38\uAA42\uAA4F\uAA52\uAA5B\uAA62\uAA78\uAA7C\uAAC4\uAADD\uAADF\uAAE2\uAAF1\uAAF4\uAAF8\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABEC\uABEE\uABEF\uABF2\uABFB\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE02\uFE11\uFE22\uFE31\uFE35\uFE36\uFE4F\uFE51\uFE72\uFE76\uFE78\uFEFE\uFF01\uFF01\uFF12\uFF1B\uFF23\uFF3C\uFF41\uFF41\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\uFFFB\uFFFD\r(*<>?AOR_\x82\xFC\u0142\u0176\u01FF\u01FF\u0282\u029E\u02A2\u02D2\u02E2\u02E2\u0302\u0321\u0332\u034C\u0352\u037C\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04A2\u04AB\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A05\u0A07\u0A08\u0A0E\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A3A\u0A3C\u0A41\u0A41\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE8\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1002\u1048\u1068\u1071\u1081\u10BC\u10BF\u10BF\u10D2\u10EA\u10F2\u10FB\u1102\u1136\u1138\u1141\u1152\u1175\u1178\u1178\u1182\u11C6\u11CC\u11CE\u11D2\u11DC\u11DE\u11DE\u1202\u1213\u1215\u1239\u1240\u1240\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12EC\u12F2\u12FB\u1302\u1305\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133E\u1346\u1349\u134A\u134D\u134F\u1352\u1352\u1359\u1359\u135F\u1365\u1368\u136E\u1372\u1376\u1402\u144C\u1452\u145B\u1482\u14C7\u14C9\u14C9\u14D2\u14DB\u1582\u15B7\u15BA\u15C2\u15DA\u15DF\u1602\u1642\u1646\u1646\u1652\u165B\u1682\u16B9\u16C2\u16CB\u1702\u171B\u171F\u172D\u1732\u173B\u18A2\u18EB\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C38\u1C3A\u1C42\u1C52\u1C5B\u1C74\u1C91\u1C94\u1CA9\u1CAB\u1CB8\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6A62\u6A6B\u6AD2\u6AEF\u6AF2\u6AF6\u6B02\u6B38\u6B42\u6B45\u6B52\u6B5B\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F80\u6F91\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uBC9F\uBCA0\uBCA2\uBCA5\uD167\uD16B\uD16F\uD184\uD187\uD18D\uD1AC\uD1AF\uD244\uD246\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uD7D0\uD801\uDA02\uDA38\uDA3D\uDA6E\uDA77\uDA77\uDA86\uDA86\uDA9D\uDAA1\uDAA3\uDAB1\uE002\uE008\uE00A\uE01A\uE01D\uE023\uE025\uE026\uE028\uE02C\uE802\uE8C6\uE8D2\uE8D8\uE902\uE94C\uE952\uE95B\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F"\x81\u0102\u01F1\u0240C\\c|\xAC\xAC\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0372\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u05D2\u05EC\u05F2\u05F4\u0622\u064C\u0670\u0671\u0673\u06D5\u06D7\u06D7\u06E7\u06E8\u06F0\u06F1\u06FC\u06FE\u0701\u0701\u0712\u0712\u0714\u0731\u074F\u07A7\u07B3\u07B3\u07CC\u07EC\u07F6\u07F7\u07FC\u07FC\u0802\u0817\u081C\u081C\u0826\u0826\u082A\u082A\u0842\u085A\u08A2\u08B6\u08B8\u08BF\u0906\u093B\u093F\u093F\u0952\u0952\u095A\u0963\u0973\u0982\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BF\u09BF\u09D0\u09D0\u09DE\u09DF\u09E1\u09E3\u09F2\u09F3\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A5B\u0A5E\u0A60\u0A60\u0A74\u0A76\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABF\u0ABF\u0AD2\u0AD2\u0AE2\u0AE3\u0AFB\u0AFB\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3F\u0B3F\u0B5E\u0B5F\u0B61\u0B63\u0B73\u0B73\u0B85\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BD2\u0BD2\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C3F\u0C5A\u0C5C\u0C62\u0C63\u0C82\u0C82\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBF\u0CBF\u0CE0\u0CE0\u0CE2\u0CE3\u0CF3\u0CF4\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D3F\u0D50\u0D50\u0D56\u0D58\u0D61\u0D63\u0D7C\u0D81\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0E03\u0E32\u0E34\u0E35\u0E42\u0E48\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EB2\u0EB4\u0EB5\u0EBF\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0EDE\u0EE1\u0F02\u0F02\u0F42\u0F49\u0F4B\u0F6E\u0F8A\u0F8E\u1002\u102C\u1041\u1041\u1052\u1057\u105C\u105F\u1063\u1063\u1067\u1068\u1070\u1072\u1077\u1083\u1090\u1090\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1713\u1722\u1733\u1742\u1753\u1762\u176E\u1770\u1772\u1782\u17B5\u17D9\u17D9\u17DE\u17DE\u1822\u1879\u1882\u1886\u1889\u18AA\u18AC\u18AC\u18B2\u18F7\u1902\u1920\u1952\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u1A02\u1A18\u1A22\u1A56\u1AA9\u1AA9\u1B07\u1B35\u1B47\u1B4D\u1B85\u1BA2\u1BB0\u1BB1\u1BBC\u1BE7\u1C02\u1C25\u1C4F\u1C51\u1C5C\u1C7F\u1C82\u1C8A\u1CEB\u1CEE\u1CF0\u1CF3\u1CF7\u1CF8\u1D02\u1DC1\u1E02\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u2073\u2073\u2081\u2081\u2092\u209E\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF0\u2CF4\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D82\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2E31\u2E31\u3007\u3009\u3023\u302B\u3033\u3037\u303A\u303E\u3043\u3098\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA621\uA62C\uA62D\uA642\uA670\uA681\uA69F\uA6A2\uA6F1\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA803\uA805\uA807\uA809\uA80C\uA80E\uA824\uA842\uA875\uA884\uA8B5\uA8F4\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA90C\uA927\uA932\uA948\uA962\uA97E\uA986\uA9B4\uA9D1\uA9D1\uA9E2\uA9E6\uA9E8\uA9F1\uA9FC\uAA00\uAA02\uAA2A\uAA42\uAA44\uAA46\uAA4D\uAA62\uAA78\uAA7C\uAA7C\uAA80\uAAB1\uAAB3\uAAB3\uAAB7\uAAB8\uAABB\uAABF\uAAC2\uAAC2\uAAC4\uAAC4\uAADD\uAADF\uAAE2\uAAEC\uAAF4\uAAF6\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABE4\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB1F\uFB21\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE72\uFE76\uFE78\uFEFE\uFF23\uFF3C\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\r(*<>?AOR_\x82\xFC\u0142\u0176\u0282\u029E\u02A2\u02D2\u0302\u0321\u0332\u034C\u0352\u0377\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A02\u0A12\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE6\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1005\u1039\u1085\u10B1\u10D2\u10EA\u1105\u1128\u1152\u1174\u1178\u1178\u1185\u11B4\u11C3\u11C6\u11DC\u11DC\u11DE\u11DE\u1202\u1213\u1215\u122D\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12E0\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133F\u133F\u1352\u1352\u135F\u1363\u1402\u1436\u1449\u144C\u1482\u14B1\u14C6\u14C7\u14C9\u14C9\u1582\u15B0\u15DA\u15DD\u1602\u1631\u1646\u1646\u1682\u16AC\u1702\u171B\u18A2\u18E1\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C30\u1C42\u1C42\u1C74\u1C91\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6AD2\u6AEF\u6B02\u6B31\u6B42\u6B45\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F52\u6F95\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548';
    XPathLexer._serializedATNSegment1 = `\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uE802\uE8C6\uE902\uE945\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F1\x07	\v\x07	\v\r%')\x071\x071\x071\x07,\b\x1B\x07#\x1B
 \b\r\x07"  !!#" #$\b$\f%&	&'(	()-\x07)*,\v+*,/-.-+.0/-01\x07)1 -`;
    XPathLexer._serializedATN = Utils3.join([
      XPathLexer._serializedATNSegment0,
      XPathLexer._serializedATNSegment1
    ], "");
  }
});

// node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js
var require_XPathLexerErrorListener = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathLexerErrorListener = void 0;
    var Decorators_1 = require_Decorators();
    var XPathLexerErrorListener = class {
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathLexerErrorListener.prototype, "syntaxError", null);
    exports.XPathLexerErrorListener = XPathLexerErrorListener;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathElement.js
var require_XPathElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathElement = void 0;
    var Decorators_1 = require_Decorators();
    var XPathElement = class {
      constructor(nodeName) {
        this.nodeName = nodeName;
        this.invert = false;
      }
      toString() {
        let inv = this.invert ? "!" : "";
        let className = Object.constructor.name;
        return className + "[" + inv + this.nodeName + "]";
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathElement.prototype, "toString", null);
    exports.XPathElement = XPathElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js
var require_XPathRuleAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathRuleAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathRuleAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        return Trees_1.Trees.findAllRuleNodes(t, this.ruleIndex);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathRuleAnywhereElement.prototype, "evaluate", null);
    exports.XPathRuleAnywhereElement = XPathRuleAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathRuleElement.js
var require_XPathRuleElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathRuleElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathRuleElement = void 0;
    var ParserRuleContext_1 = require_ParserRuleContext();
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathRuleElement = class extends XPathElement_1.XPathElement {
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        let nodes = [];
        for (let c of Trees_1.Trees.getChildren(t)) {
          if (c instanceof ParserRuleContext_1.ParserRuleContext) {
            if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
              nodes.push(c);
            }
          }
        }
        return nodes;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathRuleElement.prototype, "evaluate", null);
    exports.XPathRuleElement = XPathRuleElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js
var require_XPathTokenAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathTokenAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathTokenAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        return Trees_1.Trees.findAllTokenNodes(t, this.tokenType);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathTokenAnywhereElement.prototype, "evaluate", null);
    exports.XPathTokenAnywhereElement = XPathTokenAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathTokenElement.js
var require_XPathTokenElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathTokenElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathTokenElement = void 0;
    var Decorators_1 = require_Decorators();
    var TerminalNode_1 = require_TerminalNode();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathTokenElement = class extends XPathElement_1.XPathElement {
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        let nodes = [];
        for (let c of Trees_1.Trees.getChildren(t)) {
          if (c instanceof TerminalNode_1.TerminalNode) {
            if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
              nodes.push(c);
            }
          }
        }
        return nodes;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathTokenElement.prototype, "evaluate", null);
    exports.XPathTokenElement = XPathTokenElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js
var require_XPathWildcardAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathWildcardAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPath_1 = require_XPath();
    var XPathElement_1 = require_XPathElement();
    var XPathWildcardAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor() {
        super(XPath_1.XPath.WILDCARD);
      }
      evaluate(t) {
        if (this.invert) {
          return [];
        }
        return Trees_1.Trees.getDescendants(t);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathWildcardAnywhereElement.prototype, "evaluate", null);
    exports.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js
var require_XPathWildcardElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathWildcardElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPath_1 = require_XPath();
    var XPathElement_1 = require_XPathElement();
    var XPathWildcardElement = class extends XPathElement_1.XPathElement {
      constructor() {
        super(XPath_1.XPath.WILDCARD);
      }
      evaluate(t) {
        let kids = [];
        if (this.invert) {
          return kids;
        }
        for (let c of Trees_1.Trees.getChildren(t)) {
          kids.push(c);
        }
        return kids;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathWildcardElement.prototype, "evaluate", null);
    exports.XPathWildcardElement = XPathWildcardElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPath.js
var require_XPath = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPath = void 0;
    var CharStreams_1 = require_CharStreams();
    var CommonTokenStream_1 = require_CommonTokenStream();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var Token_1 = require_Token();
    var XPathLexer_1 = require_XPathLexer();
    var XPathLexerErrorListener_1 = require_XPathLexerErrorListener();
    var XPathRuleAnywhereElement_1 = require_XPathRuleAnywhereElement();
    var XPathRuleElement_1 = require_XPathRuleElement();
    var XPathTokenAnywhereElement_1 = require_XPathTokenAnywhereElement();
    var XPathTokenElement_1 = require_XPathTokenElement();
    var XPathWildcardAnywhereElement_1 = require_XPathWildcardAnywhereElement();
    var XPathWildcardElement_1 = require_XPathWildcardElement();
    var XPath = class {
      constructor(parser, path2) {
        this.parser = parser;
        this.path = path2;
        this.elements = this.split(path2);
      }
      split(path2) {
        let lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path2));
        lexer.recover = (e) => {
          throw e;
        };
        lexer.removeErrorListeners();
        lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());
        let tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);
        try {
          tokenStream.fill();
        } catch (e) {
          if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
            let pos = lexer.charPositionInLine;
            let msg = "Invalid tokens or characters at index " + pos + " in path '" + path2 + "' -- " + e.message;
            throw new RangeError(msg);
          }
          throw e;
        }
        let tokens = tokenStream.getTokens();
        let elements = [];
        let n = tokens.length;
        let i = 0;
        loop:
          while (i < n) {
            let el = tokens[i];
            let next;
            switch (el.type) {
              case XPathLexer_1.XPathLexer.ROOT:
              case XPathLexer_1.XPathLexer.ANYWHERE:
                let anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;
                i++;
                next = tokens[i];
                let invert = next.type === XPathLexer_1.XPathLexer.BANG;
                if (invert) {
                  i++;
                  next = tokens[i];
                }
                let pathElement = this.getXPathElement(next, anywhere);
                pathElement.invert = invert;
                elements.push(pathElement);
                i++;
                break;
              case XPathLexer_1.XPathLexer.TOKEN_REF:
              case XPathLexer_1.XPathLexer.RULE_REF:
              case XPathLexer_1.XPathLexer.WILDCARD:
                elements.push(this.getXPathElement(el, false));
                i++;
                break;
              case Token_1.Token.EOF:
                break loop;
              default:
                throw new Error("Unknowth path element " + el);
            }
          }
        return elements;
      }
      getXPathElement(wordToken, anywhere) {
        if (wordToken.type === Token_1.Token.EOF) {
          throw new Error("Missing path element at end of path");
        }
        let word = wordToken.text;
        if (word == null) {
          throw new Error("Expected wordToken to have text content.");
        }
        let ttype = this.parser.getTokenType(word);
        let ruleIndex = this.parser.getRuleIndex(word);
        switch (wordToken.type) {
          case XPathLexer_1.XPathLexer.WILDCARD:
            return anywhere ? new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() : new XPathWildcardElement_1.XPathWildcardElement();
          case XPathLexer_1.XPathLexer.TOKEN_REF:
          case XPathLexer_1.XPathLexer.STRING:
            if (ttype === Token_1.Token.INVALID_TYPE) {
              throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid token name");
            }
            return anywhere ? new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement_1.XPathTokenElement(word, ttype);
          default:
            if (ruleIndex === -1) {
              throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid rule name");
            }
            return anywhere ? new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);
        }
      }
      static findAll(tree, xpath, parser) {
        let p = new XPath(parser, xpath);
        return p.evaluate(tree);
      }
      evaluate(t) {
        let dummyRoot = new ParserRuleContext_1.ParserRuleContext();
        dummyRoot.addChild(t);
        let work = /* @__PURE__ */ new Set([dummyRoot]);
        let i = 0;
        while (i < this.elements.length) {
          let next = /* @__PURE__ */ new Set();
          for (let node of work) {
            if (node.childCount > 0) {
              let matching = this.elements[i].evaluate(node);
              matching.forEach(next.add, next);
            }
          }
          i++;
          work = next;
        }
        return work;
      }
    };
    exports.XPath = XPath;
    XPath.WILDCARD = "*";
    XPath.NOT = "!";
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreePattern.js
var require_ParseTreePattern = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreePattern.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreePattern = void 0;
    var Decorators_1 = require_Decorators();
    var XPath_1 = require_XPath();
    var ParseTreePattern = class ParseTreePattern {
      constructor(matcher, pattern, patternRuleIndex, patternTree) {
        this._matcher = matcher;
        this._patternRuleIndex = patternRuleIndex;
        this._pattern = pattern;
        this._patternTree = patternTree;
      }
      match(tree) {
        return this._matcher.match(tree, this);
      }
      matches(tree) {
        return this._matcher.match(tree, this).succeeded;
      }
      findAll(tree, xpath) {
        let subtrees = XPath_1.XPath.findAll(tree, xpath, this._matcher.parser);
        let matches = [];
        for (let t of subtrees) {
          let match = this.match(t);
          if (match.succeeded) {
            matches.push(match);
          }
        }
        return matches;
      }
      get matcher() {
        return this._matcher;
      }
      get pattern() {
        return this._pattern;
      }
      get patternRuleIndex() {
        return this._patternRuleIndex;
      }
      get patternTree() {
        return this._patternTree;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_pattern", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_patternTree", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_matcher", void 0);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "match", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "matches", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "findAll", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "matcher", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "pattern", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "patternTree", null);
    ParseTreePattern = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParseTreePattern);
    exports.ParseTreePattern = ParseTreePattern;
  }
});

// node_modules/antlr4ts/tree/pattern/RuleTagToken.js
var require_RuleTagToken = __commonJS({
  "node_modules/antlr4ts/tree/pattern/RuleTagToken.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleTagToken = void 0;
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var RuleTagToken = class RuleTagToken {
      constructor(ruleName, bypassTokenType, label) {
        if (ruleName == null || ruleName.length === 0) {
          throw new Error("ruleName cannot be null or empty.");
        }
        this._ruleName = ruleName;
        this.bypassTokenType = bypassTokenType;
        this._label = label;
      }
      get ruleName() {
        return this._ruleName;
      }
      get label() {
        return this._label;
      }
      get channel() {
        return Token_1.Token.DEFAULT_CHANNEL;
      }
      get text() {
        if (this._label != null) {
          return "<" + this._label + ":" + this._ruleName + ">";
        }
        return "<" + this._ruleName + ">";
      }
      get type() {
        return this.bypassTokenType;
      }
      get line() {
        return 0;
      }
      get charPositionInLine() {
        return -1;
      }
      get tokenIndex() {
        return -1;
      }
      get startIndex() {
        return -1;
      }
      get stopIndex() {
        return -1;
      }
      get tokenSource() {
        return void 0;
      }
      get inputStream() {
        return void 0;
      }
      toString() {
        return this._ruleName + ":" + this.bypassTokenType;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], RuleTagToken.prototype, "ruleName", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "channel", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "type", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "tokenIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "startIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "stopIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "toString", null);
    RuleTagToken = __decorate([
      __param(0, Decorators_1.NotNull)
    ], RuleTagToken);
    exports.RuleTagToken = RuleTagToken;
  }
});

// node_modules/antlr4ts/tree/pattern/Chunk.js
var require_Chunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/Chunk.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chunk = void 0;
    var Chunk = class {
    };
    exports.Chunk = Chunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TagChunk.js
var require_TagChunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TagChunk.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TagChunk = void 0;
    var Chunk_1 = require_Chunk();
    var Decorators_1 = require_Decorators();
    var TagChunk = class extends Chunk_1.Chunk {
      constructor(tag, label) {
        super();
        if (tag == null || tag.length === 0) {
          throw new Error("tag cannot be null or empty");
        }
        this._tag = tag;
        this._label = label;
      }
      get tag() {
        return this._tag;
      }
      get label() {
        return this._label;
      }
      toString() {
        if (this._label != null) {
          return this._label + ":" + this._tag;
        }
        return this._tag;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TagChunk.prototype, "tag", null);
    __decorate([
      Decorators_1.Override
    ], TagChunk.prototype, "toString", null);
    exports.TagChunk = TagChunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TextChunk.js
var require_TextChunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TextChunk.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextChunk = void 0;
    var Chunk_1 = require_Chunk();
    var Decorators_1 = require_Decorators();
    var TextChunk = class TextChunk extends Chunk_1.Chunk {
      constructor(text4) {
        super();
        if (text4 == null) {
          throw new Error("text cannot be null");
        }
        this._text = text4;
      }
      get text() {
        return this._text;
      }
      toString() {
        return "'" + this._text + "'";
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TextChunk.prototype, "_text", void 0);
    __decorate([
      Decorators_1.NotNull
    ], TextChunk.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TextChunk.prototype, "toString", null);
    TextChunk = __decorate([
      __param(0, Decorators_1.NotNull)
    ], TextChunk);
    exports.TextChunk = TextChunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TokenTagToken.js
var require_TokenTagToken = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TokenTagToken.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenTagToken = void 0;
    var CommonToken_1 = require_CommonToken();
    var Decorators_1 = require_Decorators();
    var TokenTagToken = class TokenTagToken extends CommonToken_1.CommonToken {
      constructor(tokenName, type, label) {
        super(type);
        this._tokenName = tokenName;
        this._label = label;
      }
      get tokenName() {
        return this._tokenName;
      }
      get label() {
        return this._label;
      }
      get text() {
        if (this._label != null) {
          return "<" + this._label + ":" + this._tokenName + ">";
        }
        return "<" + this._tokenName + ">";
      }
      toString() {
        return this._tokenName + ":" + this.type;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TokenTagToken.prototype, "_tokenName", void 0);
    __decorate([
      Decorators_1.NotNull
    ], TokenTagToken.prototype, "tokenName", null);
    __decorate([
      Decorators_1.Override
    ], TokenTagToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TokenTagToken.prototype, "toString", null);
    TokenTagToken = __decorate([
      __param(0, Decorators_1.NotNull)
    ], TokenTagToken);
    exports.TokenTagToken = TokenTagToken;
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js
var require_ParseTreePatternMatcher = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreePatternMatcher = void 0;
    var BailErrorStrategy_1 = require_BailErrorStrategy();
    var CharStreams_1 = require_CharStreams();
    var CommonTokenStream_1 = require_CommonTokenStream();
    var ListTokenSource_1 = require_ListTokenSource();
    var MultiMap_1 = require_MultiMap();
    var Decorators_1 = require_Decorators();
    var ParseCancellationException_1 = require_ParseCancellationException();
    var ParserInterpreter_1 = require_ParserInterpreter();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var ParseTreeMatch_1 = require_ParseTreeMatch();
    var ParseTreePattern_1 = require_ParseTreePattern();
    var RecognitionException_1 = require_RecognitionException();
    var RuleNode_1 = require_RuleNode();
    var RuleTagToken_1 = require_RuleTagToken();
    var TagChunk_1 = require_TagChunk();
    var TerminalNode_1 = require_TerminalNode();
    var TextChunk_1 = require_TextChunk();
    var Token_1 = require_Token();
    var TokenTagToken_1 = require_TokenTagToken();
    var ParseTreePatternMatcher = class {
      constructor(lexer, parser) {
        this.start = "<";
        this.stop = ">";
        this.escape = "\\";
        this.escapeRE = /\\/g;
        this._lexer = lexer;
        this._parser = parser;
      }
      setDelimiters(start, stop, escapeLeft) {
        if (!start) {
          throw new Error("start cannot be null or empty");
        }
        if (!stop) {
          throw new Error("stop cannot be null or empty");
        }
        this.start = start;
        this.stop = stop;
        this.escape = escapeLeft;
        this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
      }
      matches(tree, pattern, patternRuleIndex = 0) {
        if (typeof pattern === "string") {
          let p = this.compile(pattern, patternRuleIndex);
          return this.matches(tree, p);
        } else {
          let labels = new MultiMap_1.MultiMap();
          let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
          return !mismatchedNode;
        }
      }
      match(tree, pattern, patternRuleIndex = 0) {
        if (typeof pattern === "string") {
          let p = this.compile(pattern, patternRuleIndex);
          return this.match(tree, p);
        } else {
          let labels = new MultiMap_1.MultiMap();
          let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
          return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);
        }
      }
      compile(pattern, patternRuleIndex) {
        let tokenList = this.tokenize(pattern);
        let tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);
        let tokens = new CommonTokenStream_1.CommonTokenStream(tokenSrc);
        const parser = this._parser;
        let parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens);
        let tree;
        try {
          parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();
          tree = parserInterp.parse(patternRuleIndex);
        } catch (e) {
          if (e instanceof ParseCancellationException_1.ParseCancellationException) {
            throw e.getCause();
          } else if (e instanceof RecognitionException_1.RecognitionException) {
            throw e;
          } else if (e instanceof Error) {
            throw new ParseTreePatternMatcher.CannotInvokeStartRule(e);
          } else {
            throw e;
          }
        }
        if (tokens.LA(1) !== Token_1.Token.EOF) {
          throw new ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();
        }
        return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);
      }
      get lexer() {
        return this._lexer;
      }
      get parser() {
        return this._parser;
      }
      matchImpl(tree, patternTree, labels) {
        if (!tree) {
          throw new TypeError("tree cannot be null");
        }
        if (!patternTree) {
          throw new TypeError("patternTree cannot be null");
        }
        if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {
          let mismatchedNode;
          if (tree.symbol.type === patternTree.symbol.type) {
            if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) {
              let tokenTagToken = patternTree.symbol;
              labels.map(tokenTagToken.tokenName, tree);
              const l = tokenTagToken.label;
              if (l) {
                labels.map(l, tree);
              }
            } else if (tree.text === patternTree.text) {
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
          } else {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
          }
          return mismatchedNode;
        }
        if (tree instanceof ParserRuleContext_1.ParserRuleContext && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {
          let mismatchedNode;
          let ruleTagToken = this.getRuleTagToken(patternTree);
          if (ruleTagToken) {
            let m;
            if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {
              labels.map(ruleTagToken.ruleName, tree);
              const l = ruleTagToken.label;
              if (l) {
                labels.map(l, tree);
              }
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
            return mismatchedNode;
          }
          if (tree.childCount !== patternTree.childCount) {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
            return mismatchedNode;
          }
          let n = tree.childCount;
          for (let i = 0; i < n; i++) {
            let childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
            if (childMatch) {
              return childMatch;
            }
          }
          return mismatchedNode;
        }
        return tree;
      }
      getRuleTagToken(t) {
        if (t instanceof RuleNode_1.RuleNode) {
          if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {
            let c = t.getChild(0);
            if (c.symbol instanceof RuleTagToken_1.RuleTagToken) {
              return c.symbol;
            }
          }
        }
        return void 0;
      }
      tokenize(pattern) {
        let chunks = this.split(pattern);
        let tokens = [];
        for (let chunk of chunks) {
          if (chunk instanceof TagChunk_1.TagChunk) {
            let tagChunk = chunk;
            const firstChar = tagChunk.tag.substr(0, 1);
            if (firstChar === firstChar.toUpperCase()) {
              let ttype = this._parser.getTokenType(tagChunk.tag);
              if (ttype === Token_1.Token.INVALID_TYPE) {
                throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
              }
              let t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
              tokens.push(t);
            } else if (firstChar === firstChar.toLowerCase()) {
              let ruleIndex = this._parser.getRuleIndex(tagChunk.tag);
              if (ruleIndex === -1) {
                throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
              }
              let ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
              tokens.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
            } else {
              throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
            }
          } else {
            let textChunk = chunk;
            this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);
            let t = this._lexer.nextToken();
            while (t.type !== Token_1.Token.EOF) {
              tokens.push(t);
              t = this._lexer.nextToken();
            }
          }
        }
        return tokens;
      }
      split(pattern) {
        let p = 0;
        let n = pattern.length;
        let chunks = [];
        let buf;
        let starts = [];
        let stops = [];
        while (p < n) {
          if (p === pattern.indexOf(this.escape + this.start, p)) {
            p += this.escape.length + this.start.length;
          } else if (p === pattern.indexOf(this.escape + this.stop, p)) {
            p += this.escape.length + this.stop.length;
          } else if (p === pattern.indexOf(this.start, p)) {
            starts.push(p);
            p += this.start.length;
          } else if (p === pattern.indexOf(this.stop, p)) {
            stops.push(p);
            p += this.stop.length;
          } else {
            p++;
          }
        }
        if (starts.length > stops.length) {
          throw new Error("unterminated tag in pattern: " + pattern);
        }
        if (starts.length < stops.length) {
          throw new Error("missing start tag in pattern: " + pattern);
        }
        let ntags = starts.length;
        for (let i = 0; i < ntags; i++) {
          if (starts[i] >= stops[i]) {
            throw new Error("tag delimiters out of order in pattern: " + pattern);
          }
        }
        if (ntags === 0) {
          let text4 = pattern.substring(0, n);
          chunks.push(new TextChunk_1.TextChunk(text4));
        }
        if (ntags > 0 && starts[0] > 0) {
          let text4 = pattern.substring(0, starts[0]);
          chunks.push(new TextChunk_1.TextChunk(text4));
        }
        for (let i = 0; i < ntags; i++) {
          let tag = pattern.substring(starts[i] + this.start.length, stops[i]);
          let ruleOrToken = tag;
          let label;
          let colon = tag.indexOf(":");
          if (colon >= 0) {
            label = tag.substring(0, colon);
            ruleOrToken = tag.substring(colon + 1, tag.length);
          }
          chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));
          if (i + 1 < ntags) {
            let text4 = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);
            chunks.push(new TextChunk_1.TextChunk(text4));
          }
        }
        if (ntags > 0) {
          let afterLastTag = stops[ntags - 1] + this.stop.length;
          if (afterLastTag < n) {
            let text4 = pattern.substring(afterLastTag, n);
            chunks.push(new TextChunk_1.TextChunk(text4));
          }
        }
        for (let i = 0; i < chunks.length; i++) {
          let c = chunks[i];
          if (c instanceof TextChunk_1.TextChunk) {
            let unescaped = c.text.replace(this.escapeRE, "");
            if (unescaped.length < c.text.length) {
              chunks[i] = new TextChunk_1.TextChunk(unescaped);
            }
          }
        }
        return chunks;
      }
    };
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], ParseTreePatternMatcher.prototype, "match", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePatternMatcher.prototype, "lexer", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePatternMatcher.prototype, "parser", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParseTreePatternMatcher.prototype, "matchImpl", null);
    exports.ParseTreePatternMatcher = ParseTreePatternMatcher;
    (function(ParseTreePatternMatcher2) {
      class CannotInvokeStartRule extends Error {
        constructor(error) {
          super(`CannotInvokeStartRule: ${error}`);
          this.error = error;
        }
      }
      ParseTreePatternMatcher2.CannotInvokeStartRule = CannotInvokeStartRule;
      class StartRuleDoesNotConsumeFullPattern extends Error {
        constructor() {
          super("StartRuleDoesNotConsumeFullPattern");
        }
      }
      ParseTreePatternMatcher2.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;
    })(ParseTreePatternMatcher = exports.ParseTreePatternMatcher || (exports.ParseTreePatternMatcher = {}));
  }
});

// node_modules/antlr4ts/atn/DecisionEventInfo.js
var require_DecisionEventInfo = __commonJS({
  "node_modules/antlr4ts/atn/DecisionEventInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionEventInfo = void 0;
    var Decorators_1 = require_Decorators();
    var DecisionEventInfo = class DecisionEventInfo {
      constructor(decision, state, input, startIndex, stopIndex, fullCtx) {
        this.decision = decision;
        this.fullCtx = fullCtx;
        this.stopIndex = stopIndex;
        this.input = input;
        this.startIndex = startIndex;
        this.state = state;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DecisionEventInfo.prototype, "input", void 0);
    DecisionEventInfo = __decorate([
      __param(2, Decorators_1.NotNull)
    ], DecisionEventInfo);
    exports.DecisionEventInfo = DecisionEventInfo;
  }
});

// node_modules/antlr4ts/atn/AmbiguityInfo.js
var require_AmbiguityInfo = __commonJS({
  "node_modules/antlr4ts/atn/AmbiguityInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AmbiguityInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var AmbiguityInfo = class AmbiguityInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, ambigAlts, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
        this.ambigAlts = ambigAlts;
      }
      get ambiguousAlternatives() {
        return this.ambigAlts;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], AmbiguityInfo.prototype, "ambigAlts", void 0);
    __decorate([
      Decorators_1.NotNull
    ], AmbiguityInfo.prototype, "ambiguousAlternatives", null);
    AmbiguityInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], AmbiguityInfo);
    exports.AmbiguityInfo = AmbiguityInfo;
  }
});

// node_modules/antlr4ts/atn/ContextSensitivityInfo.js
var require_ContextSensitivityInfo = __commonJS({
  "node_modules/antlr4ts/atn/ContextSensitivityInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextSensitivityInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var ContextSensitivityInfo = class ContextSensitivityInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, true);
      }
    };
    ContextSensitivityInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ContextSensitivityInfo);
    exports.ContextSensitivityInfo = ContextSensitivityInfo;
  }
});

// node_modules/antlr4ts/atn/DecisionInfo.js
var require_DecisionInfo = __commonJS({
  "node_modules/antlr4ts/atn/DecisionInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionInfo = void 0;
    var Decorators_1 = require_Decorators();
    var DecisionInfo = class {
      constructor(decision) {
        this.invocations = 0;
        this.timeInPrediction = 0;
        this.SLL_TotalLook = 0;
        this.SLL_MinLook = 0;
        this.SLL_MaxLook = 0;
        this.LL_TotalLook = 0;
        this.LL_MinLook = 0;
        this.LL_MaxLook = 0;
        this.contextSensitivities = [];
        this.errors = [];
        this.ambiguities = [];
        this.predicateEvals = [];
        this.SLL_ATNTransitions = 0;
        this.SLL_DFATransitions = 0;
        this.LL_Fallback = 0;
        this.LL_ATNTransitions = 0;
        this.LL_DFATransitions = 0;
        this.decision = decision;
      }
      toString() {
        return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", SLL_lookahead=" + this.SLL_TotalLook + ", SLL_ATNTransitions=" + this.SLL_ATNTransitions + ", SLL_DFATransitions=" + this.SLL_DFATransitions + ", LL_Fallback=" + this.LL_Fallback + ", LL_lookahead=" + this.LL_TotalLook + ", LL_ATNTransitions=" + this.LL_ATNTransitions + "}";
      }
    };
    __decorate([
      Decorators_1.Override
    ], DecisionInfo.prototype, "toString", null);
    exports.DecisionInfo = DecisionInfo;
  }
});

// node_modules/antlr4ts/atn/ErrorInfo.js
var require_ErrorInfo = __commonJS({
  "node_modules/antlr4ts/atn/ErrorInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var ErrorInfo = class ErrorInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
      }
    };
    ErrorInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ErrorInfo);
    exports.ErrorInfo = ErrorInfo;
  }
});

// node_modules/antlr4ts/atn/LookaheadEventInfo.js
var require_LookaheadEventInfo = __commonJS({
  "node_modules/antlr4ts/atn/LookaheadEventInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LookaheadEventInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var LookaheadEventInfo = class LookaheadEventInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {
        super(decision, state, input, startIndex, stopIndex, fullCtx);
        this.predictedAlt = predictedAlt;
      }
    };
    LookaheadEventInfo = __decorate([
      __param(3, Decorators_1.NotNull)
    ], LookaheadEventInfo);
    exports.LookaheadEventInfo = LookaheadEventInfo;
  }
});

// node_modules/antlr4ts/atn/PredicateEvalInfo.js
var require_PredicateEvalInfo = __commonJS({
  "node_modules/antlr4ts/atn/PredicateEvalInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredicateEvalInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var PredicateEvalInfo = class PredicateEvalInfo extends DecisionEventInfo_1.DecisionEventInfo {
      constructor(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
        this.semctx = semctx;
        this.evalResult = evalResult;
        this.predictedAlt = predictedAlt;
      }
    };
    PredicateEvalInfo = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], PredicateEvalInfo);
    exports.PredicateEvalInfo = PredicateEvalInfo;
  }
});

// node_modules/antlr4ts/atn/ProfilingATNSimulator.js
var require_ProfilingATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ProfilingATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProfilingATNSimulator = void 0;
    var AmbiguityInfo_1 = require_AmbiguityInfo();
    var ATN_1 = require_ATN();
    var ATNSimulator_1 = require_ATNSimulator();
    var ContextSensitivityInfo_1 = require_ContextSensitivityInfo();
    var DecisionInfo_1 = require_DecisionInfo();
    var ErrorInfo_1 = require_ErrorInfo();
    var Decorators_1 = require_Decorators();
    var LookaheadEventInfo_1 = require_LookaheadEventInfo();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var PredicateEvalInfo_1 = require_PredicateEvalInfo();
    var SemanticContext_1 = require_SemanticContext();
    var SimulatorState_1 = require_SimulatorState();
    var ProfilingATNSimulator = class extends ParserATNSimulator_1.ParserATNSimulator {
      constructor(parser) {
        super(parser.interpreter.atn, parser);
        this._startIndex = 0;
        this._sllStopIndex = 0;
        this._llStopIndex = 0;
        this.currentDecision = 0;
        this.conflictingAltResolvedBySLL = 0;
        this.optimize_ll1 = false;
        this.reportAmbiguities = true;
        this.numDecisions = this.atn.decisionToState.length;
        this.decisions = [];
        for (let i = 0; i < this.numDecisions; i++) {
          this.decisions.push(new DecisionInfo_1.DecisionInfo(i));
        }
      }
      adaptivePredict(input, decision, outerContext, useContext) {
        if (useContext !== void 0) {
          return super.adaptivePredict(input, decision, outerContext, useContext);
        }
        try {
          this._input = input;
          this._startIndex = input.index;
          this._sllStopIndex = this._startIndex - 1;
          this._llStopIndex = -1;
          this.currentDecision = decision;
          this.currentState = void 0;
          this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;
          let start = process.hrtime();
          let alt = super.adaptivePredict(input, decision, outerContext);
          let stop = process.hrtime();
          let nanoseconds = (stop[0] - start[0]) * 1e9;
          if (nanoseconds === 0) {
            nanoseconds = stop[1] - start[1];
          } else {
            nanoseconds += 1e9 - start[1] + stop[1];
          }
          this.decisions[decision].timeInPrediction += nanoseconds;
          this.decisions[decision].invocations++;
          let SLL_k = this._sllStopIndex - this._startIndex + 1;
          this.decisions[decision].SLL_TotalLook += SLL_k;
          this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);
          if (SLL_k > this.decisions[decision].SLL_MaxLook) {
            this.decisions[decision].SLL_MaxLook = SLL_k;
            this.decisions[decision].SLL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._sllStopIndex, false);
          }
          if (this._llStopIndex >= 0) {
            let LL_k = this._llStopIndex - this._startIndex + 1;
            this.decisions[decision].LL_TotalLook += LL_k;
            this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);
            if (LL_k > this.decisions[decision].LL_MaxLook) {
              this.decisions[decision].LL_MaxLook = LL_k;
              this.decisions[decision].LL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._llStopIndex, true);
            }
          }
          return alt;
        } finally {
          this._input = void 0;
          this.currentDecision = -1;
        }
      }
      getStartState(dfa, input, outerContext, useContext) {
        let state = super.getStartState(dfa, input, outerContext, useContext);
        this.currentState = state;
        return state;
      }
      computeStartState(dfa, globalContext, useContext) {
        let state = super.computeStartState(dfa, globalContext, useContext);
        this.currentState = state;
        return state;
      }
      computeReachSet(dfa, previous4, t, contextCache) {
        if (this._input === void 0) {
          throw new Error("Invalid state");
        }
        let reachState = super.computeReachSet(dfa, previous4, t, contextCache);
        if (reachState == null) {
          this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous4, this._input, this._startIndex, this._input.index));
        }
        this.currentState = reachState;
        return reachState;
      }
      getExistingTargetState(previousD, t) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        if (this.currentState.useContext) {
          this._llStopIndex = this._input.index;
        } else {
          this._sllStopIndex = this._input.index;
        }
        let existingTargetState = super.getExistingTargetState(previousD, t);
        if (existingTargetState != null) {
          this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);
          if (this.currentState.useContext) {
            this.decisions[this.currentDecision].LL_DFATransitions++;
          } else {
            this.decisions[this.currentDecision].SLL_DFATransitions++;
          }
          if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {
            let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);
            this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));
          }
        }
        return existingTargetState;
      }
      computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
        let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);
        if (useContext) {
          this.decisions[this.currentDecision].LL_ATNTransitions++;
        } else {
          this.decisions[this.currentDecision].SLL_ATNTransitions++;
        }
        return targetState;
      }
      evalSemanticContextImpl(pred, parserCallStack, alt) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);
        if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {
          let fullContext = this._llStopIndex >= 0;
          let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;
          this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));
        }
        return result;
      }
      reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
        if (this._input === void 0) {
          throw new Error("Invalid state");
        }
        if (prediction !== this.conflictingAltResolvedBySLL) {
          this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));
        }
        super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);
      }
      reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
        if (conflictingAlts != null) {
          this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
        } else {
          this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);
        }
        this.decisions[this.currentDecision].LL_Fallback++;
        super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);
      }
      reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        let prediction;
        if (ambigAlts != null) {
          prediction = ambigAlts.nextSetBit(0);
        } else {
          prediction = configs.getRepresentedAlternatives().nextSetBit(0);
        }
        if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {
          this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));
        }
        this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));
        super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);
      }
      getDecisionInfo() {
        return this.decisions;
      }
      getCurrentState() {
        return this.currentState;
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], ProfilingATNSimulator.prototype, "adaptivePredict", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "getStartState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeStartState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeReachSet", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeTargetState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "evalSemanticContextImpl", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "reportContextSensitivity", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ProfilingATNSimulator.prototype, "reportAmbiguity", null);
    exports.ProfilingATNSimulator = ProfilingATNSimulator;
  }
});

// node_modules/antlr4ts/Parser.js
var require_Parser = __commonJS({
  "node_modules/antlr4ts/Parser.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Utils3 = require_Utils();
    var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
    var ATNDeserializer_1 = require_ATNDeserializer();
    var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
    var ErrorNode_1 = require_ErrorNode();
    var IntegerStack_1 = require_IntegerStack();
    var Lexer_1 = require_Lexer();
    var Decorators_1 = require_Decorators();
    var ParseInfo_1 = require_ParseInfo();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var ProxyParserErrorListener_1 = require_ProxyParserErrorListener();
    var Recognizer_1 = require_Recognizer();
    var TerminalNode_1 = require_TerminalNode();
    var Token_1 = require_Token();
    var TraceListener = class {
      constructor(ruleNames, tokenStream) {
        this.ruleNames = ruleNames;
        this.tokenStream = tokenStream;
      }
      enterEveryRule(ctx) {
        console.log("enter   " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
      }
      exitEveryRule(ctx) {
        console.log("exit    " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
      }
      visitErrorNode(node) {
      }
      visitTerminal(node) {
        let parent = node.parent.ruleContext;
        let token = node.symbol;
        console.log("consume " + token + " rule " + this.ruleNames[parent.ruleIndex]);
      }
    };
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "enterEveryRule", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "exitEveryRule", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "visitErrorNode", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "visitTerminal", null);
    var Parser2 = class extends Recognizer_1.Recognizer {
      constructor(input) {
        super();
        this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();
        this._precedenceStack = new IntegerStack_1.IntegerStack();
        this._buildParseTrees = true;
        this._parseListeners = [];
        this._syntaxErrors = 0;
        this.matchedEOF = false;
        this._precedenceStack.push(0);
        this.inputStream = input;
      }
      reset(resetInput) {
        if (resetInput === void 0 || resetInput) {
          this.inputStream.seek(0);
        }
        this._errHandler.reset(this);
        this._ctx = void 0;
        this._syntaxErrors = 0;
        this.matchedEOF = false;
        this.isTrace = false;
        this._precedenceStack.clear();
        this._precedenceStack.push(0);
        let interpreter = this.interpreter;
        if (interpreter != null) {
          interpreter.reset();
        }
      }
      match(ttype) {
        let t = this.currentToken;
        if (t.type === ttype) {
          if (ttype === Token_1.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        } else {
          t = this._errHandler.recoverInline(this);
          if (this._buildParseTrees && t.tokenIndex === -1) {
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
          }
        }
        return t;
      }
      matchWildcard() {
        let t = this.currentToken;
        if (t.type > 0) {
          this._errHandler.reportMatch(this);
          this.consume();
        } else {
          t = this._errHandler.recoverInline(this);
          if (this._buildParseTrees && t.tokenIndex === -1) {
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
          }
        }
        return t;
      }
      set buildParseTree(buildParseTrees) {
        this._buildParseTrees = buildParseTrees;
      }
      get buildParseTree() {
        return this._buildParseTrees;
      }
      getParseListeners() {
        return this._parseListeners;
      }
      addParseListener(listener) {
        if (listener == null) {
          throw new TypeError("listener cannot be null");
        }
        this._parseListeners.push(listener);
      }
      removeParseListener(listener) {
        let index2 = this._parseListeners.findIndex((l) => l === listener);
        if (index2 !== -1) {
          this._parseListeners.splice(index2, 1);
        }
      }
      removeParseListeners() {
        this._parseListeners.length = 0;
      }
      triggerEnterRuleEvent() {
        for (let listener of this._parseListeners) {
          if (listener.enterEveryRule) {
            listener.enterEveryRule(this._ctx);
          }
          this._ctx.enterRule(listener);
        }
      }
      triggerExitRuleEvent() {
        for (let i = this._parseListeners.length - 1; i >= 0; i--) {
          let listener = this._parseListeners[i];
          this._ctx.exitRule(listener);
          if (listener.exitEveryRule) {
            listener.exitEveryRule(this._ctx);
          }
        }
      }
      get numberOfSyntaxErrors() {
        return this._syntaxErrors;
      }
      get tokenFactory() {
        return this._input.tokenSource.tokenFactory;
      }
      getATNWithBypassAlts() {
        let serializedAtn = this.serializedATN;
        if (serializedAtn == null) {
          throw new Error("The current parser does not support an ATN with bypass alternatives.");
        }
        let result = Parser2.bypassAltsAtnCache.get(serializedAtn);
        if (result == null) {
          let deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();
          deserializationOptions.isGenerateRuleBypassTransitions = true;
          result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils3.toCharArray(serializedAtn));
          Parser2.bypassAltsAtnCache.set(serializedAtn, result);
        }
        return result;
      }
      compileParseTreePattern(pattern, patternRuleIndex, lexer) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!lexer) {
            if (this.inputStream) {
              let tokenSource = this.inputStream.tokenSource;
              if (tokenSource instanceof Lexer_1.Lexer) {
                lexer = tokenSource;
              }
            }
            if (!lexer) {
              throw new Error("Parser can't discover a lexer to use");
            }
          }
          let currentLexer = lexer;
          let m = yield Promise.resolve().then(() => require_ParseTreePatternMatcher());
          let matcher = new m.ParseTreePatternMatcher(currentLexer, this);
          return matcher.compile(pattern, patternRuleIndex);
        });
      }
      get errorHandler() {
        return this._errHandler;
      }
      set errorHandler(handler) {
        this._errHandler = handler;
      }
      get inputStream() {
        return this._input;
      }
      set inputStream(input) {
        this.reset(false);
        this._input = input;
      }
      get currentToken() {
        return this._input.LT(1);
      }
      notifyErrorListeners(msg, offendingToken, e) {
        if (offendingToken === void 0) {
          offendingToken = this.currentToken;
        } else if (offendingToken === null) {
          offendingToken = void 0;
        }
        this._syntaxErrors++;
        let line = -1;
        let charPositionInLine = -1;
        if (offendingToken != null) {
          line = offendingToken.line;
          charPositionInLine = offendingToken.charPositionInLine;
        }
        let listener = this.getErrorListenerDispatch();
        if (listener.syntaxError) {
          listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
        }
      }
      consume() {
        let o = this.currentToken;
        if (o.type !== Parser2.EOF) {
          this.inputStream.consume();
        }
        let hasListener = this._parseListeners.length !== 0;
        if (this._buildParseTrees || hasListener) {
          if (this._errHandler.inErrorRecoveryMode(this)) {
            let node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));
            if (hasListener) {
              for (let listener of this._parseListeners) {
                if (listener.visitErrorNode) {
                  listener.visitErrorNode(node);
                }
              }
            }
          } else {
            let node = this.createTerminalNode(this._ctx, o);
            this._ctx.addChild(node);
            if (hasListener) {
              for (let listener of this._parseListeners) {
                if (listener.visitTerminal) {
                  listener.visitTerminal(node);
                }
              }
            }
          }
        }
        return o;
      }
      createTerminalNode(parent, t) {
        return new TerminalNode_1.TerminalNode(t);
      }
      createErrorNode(parent, t) {
        return new ErrorNode_1.ErrorNode(t);
      }
      addContextToParseTree() {
        let parent = this._ctx._parent;
        if (parent != null) {
          parent.addChild(this._ctx);
        }
      }
      enterRule(localctx, state, ruleIndex) {
        this.state = state;
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        if (this._buildParseTrees) {
          this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
      }
      enterLeftFactoredRule(localctx, state, ruleIndex) {
        this.state = state;
        if (this._buildParseTrees) {
          let factoredContext = this._ctx.getChild(this._ctx.childCount - 1);
          this._ctx.removeLastChild();
          factoredContext._parent = localctx;
          localctx.addChild(factoredContext);
        }
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        if (this._buildParseTrees) {
          this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
      }
      exitRule() {
        if (this.matchedEOF) {
          this._ctx._stop = this._input.LT(1);
        } else {
          this._ctx._stop = this._input.tryLT(-1);
        }
        this.triggerExitRuleEvent();
        this.state = this._ctx.invokingState;
        this._ctx = this._ctx._parent;
      }
      enterOuterAlt(localctx, altNum) {
        localctx.altNumber = altNum;
        if (this._buildParseTrees && this._ctx !== localctx) {
          let parent = this._ctx._parent;
          if (parent != null) {
            parent.removeLastChild();
            parent.addChild(localctx);
          }
        }
        this._ctx = localctx;
      }
      get precedence() {
        if (this._precedenceStack.isEmpty) {
          return -1;
        }
        return this._precedenceStack.peek();
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this.state = state;
        this._precedenceStack.push(precedence);
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        this.triggerEnterRuleEvent();
      }
      pushNewRecursionContext(localctx, state, ruleIndex) {
        let previous4 = this._ctx;
        previous4._parent = localctx;
        previous4.invokingState = state;
        previous4._stop = this._input.tryLT(-1);
        this._ctx = localctx;
        this._ctx._start = previous4._start;
        if (this._buildParseTrees) {
          this._ctx.addChild(previous4);
        }
        this.triggerEnterRuleEvent();
      }
      unrollRecursionContexts(_parentctx) {
        this._precedenceStack.pop();
        this._ctx._stop = this._input.tryLT(-1);
        let retctx = this._ctx;
        if (this._parseListeners.length > 0) {
          while (this._ctx !== _parentctx) {
            this.triggerExitRuleEvent();
            this._ctx = this._ctx._parent;
          }
        } else {
          this._ctx = _parentctx;
        }
        retctx._parent = _parentctx;
        if (this._buildParseTrees && _parentctx != null) {
          _parentctx.addChild(retctx);
        }
      }
      getInvokingContext(ruleIndex) {
        let p = this._ctx;
        while (p && p.ruleIndex !== ruleIndex) {
          p = p._parent;
        }
        return p;
      }
      get context() {
        return this._ctx;
      }
      set context(ctx) {
        this._ctx = ctx;
      }
      precpred(localctx, precedence) {
        return precedence >= this._precedenceStack.peek();
      }
      getErrorListenerDispatch() {
        return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());
      }
      inContext(context) {
        return false;
      }
      isExpectedToken(symbol) {
        let atn = this.interpreter.atn;
        let ctx = this._ctx;
        let s = atn.states[this.state];
        let following = atn.nextTokens(s);
        if (following.contains(symbol)) {
          return true;
        }
        if (!following.contains(Token_1.Token.EPSILON)) {
          return false;
        }
        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
          let invokingState = atn.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          following = atn.nextTokens(rt.followState);
          if (following.contains(symbol)) {
            return true;
          }
          ctx = ctx._parent;
        }
        if (following.contains(Token_1.Token.EPSILON) && symbol === Token_1.Token.EOF) {
          return true;
        }
        return false;
      }
      get isMatchedEOF() {
        return this.matchedEOF;
      }
      getExpectedTokens() {
        return this.atn.getExpectedTokens(this.state, this.context);
      }
      getExpectedTokensWithinCurrentRule() {
        let atn = this.interpreter.atn;
        let s = atn.states[this.state];
        return atn.nextTokens(s);
      }
      getRuleIndex(ruleName) {
        let ruleIndex = this.getRuleIndexMap().get(ruleName);
        if (ruleIndex != null) {
          return ruleIndex;
        }
        return -1;
      }
      get ruleContext() {
        return this._ctx;
      }
      getRuleInvocationStack(ctx = this._ctx) {
        let p = ctx;
        let ruleNames = this.ruleNames;
        let stack = [];
        while (p != null) {
          let ruleIndex = p.ruleIndex;
          if (ruleIndex < 0) {
            stack.push("n/a");
          } else {
            stack.push(ruleNames[ruleIndex]);
          }
          p = p._parent;
        }
        return stack;
      }
      getDFAStrings() {
        let s = [];
        for (let dfa of this._interp.atn.decisionToDFA) {
          s.push(dfa.toString(this.vocabulary, this.ruleNames));
        }
        return s;
      }
      dumpDFA() {
        let seenOne = false;
        for (let dfa of this._interp.atn.decisionToDFA) {
          if (!dfa.isEmpty) {
            if (seenOne) {
              console.log();
            }
            console.log("Decision " + dfa.decision + ":");
            process.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));
            seenOne = true;
          }
        }
      }
      get sourceName() {
        return this._input.sourceName;
      }
      get parseInfo() {
        return Promise.resolve().then(() => require_ProfilingATNSimulator()).then((m) => {
          let interp = this.interpreter;
          if (interp instanceof m.ProfilingATNSimulator) {
            return new ParseInfo_1.ParseInfo(interp);
          }
          return void 0;
        });
      }
      setProfile(profile) {
        return __awaiter(this, void 0, void 0, function* () {
          let m = yield Promise.resolve().then(() => require_ProfilingATNSimulator());
          let interp = this.interpreter;
          if (profile) {
            if (!(interp instanceof m.ProfilingATNSimulator)) {
              this.interpreter = new m.ProfilingATNSimulator(this);
            }
          } else if (interp instanceof m.ProfilingATNSimulator) {
            this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);
          }
          this.interpreter.setPredictionMode(interp.getPredictionMode());
        });
      }
      set isTrace(trace) {
        if (!trace) {
          if (this._tracer) {
            this.removeParseListener(this._tracer);
            this._tracer = void 0;
          }
        } else {
          if (this._tracer) {
            this.removeParseListener(this._tracer);
          } else {
            this._tracer = new TraceListener(this.ruleNames, this._input);
          }
          this.addParseListener(this._tracer);
        }
      }
      get isTrace() {
        return this._tracer != null;
      }
    };
    Parser2.bypassAltsAtnCache = /* @__PURE__ */ new Map();
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "_errHandler", void 0);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "match", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "matchWildcard", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getParseListeners", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Parser2.prototype, "addParseListener", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getATNWithBypassAlts", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Parser2.prototype, "errorHandler", null);
    __decorate([
      Decorators_1.Override
    ], Parser2.prototype, "inputStream", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "currentToken", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Parser2.prototype, "enterRule", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.Nullable)
    ], Parser2.prototype, "precpred", null);
    __decorate([
      Decorators_1.Override
    ], Parser2.prototype, "getErrorListenerDispatch", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getExpectedTokens", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser2.prototype, "getExpectedTokensWithinCurrentRule", null);
    __decorate([
      Decorators_1.Override
    ], Parser2.prototype, "parseInfo", null);
    exports.Parser = Parser2;
  }
});

// node_modules/antlr4ts/NoViableAltException.js
var require_NoViableAltException = __commonJS({
  "node_modules/antlr4ts/NoViableAltException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoViableAltException = void 0;
    var Parser_1 = require_Parser();
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var NoViableAltException2 = class extends RecognitionException_1.RecognitionException {
      constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
        if (recognizer instanceof Parser_1.Parser) {
          if (input === void 0) {
            input = recognizer.inputStream;
          }
          if (startToken === void 0) {
            startToken = recognizer.currentToken;
          }
          if (offendingToken === void 0) {
            offendingToken = recognizer.currentToken;
          }
          if (ctx === void 0) {
            ctx = recognizer.context;
          }
        }
        super(recognizer, input, ctx);
        this._deadEndConfigs = deadEndConfigs;
        this._startToken = startToken;
        this.setOffendingToken(recognizer, offendingToken);
      }
      get startToken() {
        return this._startToken;
      }
      get deadEndConfigs() {
        return this._deadEndConfigs;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], NoViableAltException2.prototype, "_startToken", void 0);
    exports.NoViableAltException = NoViableAltException2;
  }
});

// node_modules/antlr4ts/DefaultErrorStrategy.js
var require_DefaultErrorStrategy = __commonJS({
  "node_modules/antlr4ts/DefaultErrorStrategy.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultErrorStrategy = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var FailedPredicateException_1 = require_FailedPredicateException();
    var InputMismatchException_1 = require_InputMismatchException();
    var IntervalSet_1 = require_IntervalSet();
    var NoViableAltException_1 = require_NoViableAltException();
    var PredictionContext_1 = require_PredictionContext();
    var Token_1 = require_Token();
    var Decorators_1 = require_Decorators();
    var DefaultErrorStrategy = class {
      constructor() {
        this.errorRecoveryMode = false;
        this.lastErrorIndex = -1;
        this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
      }
      reset(recognizer) {
        this.endErrorCondition(recognizer);
      }
      beginErrorCondition(recognizer) {
        this.errorRecoveryMode = true;
      }
      inErrorRecoveryMode(recognizer) {
        return this.errorRecoveryMode;
      }
      endErrorCondition(recognizer) {
        this.errorRecoveryMode = false;
        this.lastErrorStates = void 0;
        this.lastErrorIndex = -1;
      }
      reportMatch(recognizer) {
        this.endErrorCondition(recognizer);
      }
      reportError(recognizer, e) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        if (e instanceof NoViableAltException_1.NoViableAltException) {
          this.reportNoViableAlternative(recognizer, e);
        } else if (e instanceof InputMismatchException_1.InputMismatchException) {
          this.reportInputMismatch(recognizer, e);
        } else if (e instanceof FailedPredicateException_1.FailedPredicateException) {
          this.reportFailedPredicate(recognizer, e);
        } else {
          console.error(`unknown recognition error type: ${e}`);
          this.notifyErrorListeners(recognizer, e.toString(), e);
        }
      }
      notifyErrorListeners(recognizer, message, e) {
        let offendingToken = e.getOffendingToken(recognizer);
        if (offendingToken === void 0) {
          offendingToken = null;
        }
        recognizer.notifyErrorListeners(message, offendingToken, e);
      }
      recover(recognizer, e) {
        if (this.lastErrorIndex === recognizer.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(recognizer.state)) {
          recognizer.consume();
        }
        this.lastErrorIndex = recognizer.inputStream.index;
        if (!this.lastErrorStates) {
          this.lastErrorStates = new IntervalSet_1.IntervalSet();
        }
        this.lastErrorStates.add(recognizer.state);
        let followSet = this.getErrorRecoverySet(recognizer);
        this.consumeUntil(recognizer, followSet);
      }
      sync(recognizer) {
        let s = recognizer.interpreter.atn.states[recognizer.state];
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        let tokens = recognizer.inputStream;
        let la = tokens.LA(1);
        let nextTokens = recognizer.atn.nextTokens(s);
        if (nextTokens.contains(la)) {
          this.nextTokensContext = void 0;
          this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
          return;
        }
        if (nextTokens.contains(Token_1.Token.EPSILON)) {
          if (this.nextTokensContext === void 0) {
            this.nextTokensContext = recognizer.context;
            this.nextTokensState = recognizer.state;
          }
          return;
        }
        switch (s.stateType) {
          case ATNStateType_1.ATNStateType.BLOCK_START:
          case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
          case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
          case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
            if (this.singleTokenDeletion(recognizer)) {
              return;
            }
            throw new InputMismatchException_1.InputMismatchException(recognizer);
          case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
          case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
            this.reportUnwantedToken(recognizer);
            let expecting = recognizer.getExpectedTokens();
            let whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));
            this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
            break;
          default:
            break;
        }
      }
      reportNoViableAlternative(recognizer, e) {
        let tokens = recognizer.inputStream;
        let input;
        if (tokens) {
          if (e.startToken.type === Token_1.Token.EOF) {
            input = "<EOF>";
          } else {
            input = tokens.getTextFromRange(e.startToken, e.getOffendingToken());
          }
        } else {
          input = "<unknown input>";
        }
        let msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
        this.notifyErrorListeners(recognizer, msg, e);
      }
      reportInputMismatch(recognizer, e) {
        let expected = e.expectedTokens;
        let expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : "";
        let msg = "mismatched input " + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) + " expecting " + expectedString;
        this.notifyErrorListeners(recognizer, msg, e);
      }
      reportFailedPredicate(recognizer, e) {
        let ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
        let msg = "rule " + ruleName + " " + e.message;
        this.notifyErrorListeners(recognizer, msg, e);
      }
      reportUnwantedToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        let t = recognizer.currentToken;
        let tokenName = this.getTokenErrorDisplay(t);
        let expecting = this.getExpectedTokens(recognizer);
        let msg = "extraneous input " + tokenName + " expecting " + expecting.toStringVocabulary(recognizer.vocabulary);
        recognizer.notifyErrorListeners(msg, t, void 0);
      }
      reportMissingToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        let t = recognizer.currentToken;
        let expecting = this.getExpectedTokens(recognizer);
        let msg = "missing " + expecting.toStringVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
        recognizer.notifyErrorListeners(msg, t, void 0);
      }
      recoverInline(recognizer) {
        let matchedSymbol = this.singleTokenDeletion(recognizer);
        if (matchedSymbol) {
          recognizer.consume();
          return matchedSymbol;
        }
        if (this.singleTokenInsertion(recognizer)) {
          return this.getMissingSymbol(recognizer);
        }
        if (this.nextTokensContext === void 0) {
          throw new InputMismatchException_1.InputMismatchException(recognizer);
        } else {
          throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);
        }
      }
      singleTokenInsertion(recognizer) {
        let currentSymbolType = recognizer.inputStream.LA(1);
        let currentState = recognizer.interpreter.atn.states[recognizer.state];
        let next = currentState.transition(0).target;
        let atn = recognizer.interpreter.atn;
        let expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));
        if (expectingAtLL2.contains(currentSymbolType)) {
          this.reportMissingToken(recognizer);
          return true;
        }
        return false;
      }
      singleTokenDeletion(recognizer) {
        let nextTokenType = recognizer.inputStream.LA(2);
        let expecting = this.getExpectedTokens(recognizer);
        if (expecting.contains(nextTokenType)) {
          this.reportUnwantedToken(recognizer);
          recognizer.consume();
          let matchedSymbol = recognizer.currentToken;
          this.reportMatch(recognizer);
          return matchedSymbol;
        }
        return void 0;
      }
      getMissingSymbol(recognizer) {
        let currentSymbol = recognizer.currentToken;
        let expecting = this.getExpectedTokens(recognizer);
        let expectedTokenType = Token_1.Token.INVALID_TYPE;
        if (!expecting.isNil) {
          expectedTokenType = expecting.minElement;
        }
        let tokenText;
        if (expectedTokenType === Token_1.Token.EOF) {
          tokenText = "<missing EOF>";
        } else {
          tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
        }
        let current = currentSymbol;
        let lookback = recognizer.inputStream.tryLT(-1);
        if (current.type === Token_1.Token.EOF && lookback != null) {
          current = lookback;
        }
        return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);
      }
      constructToken(tokenSource, expectedTokenType, tokenText, current) {
        let factory = tokenSource.tokenFactory;
        let x = current.tokenSource;
        let stream = x ? x.inputStream : void 0;
        return factory.create({ source: tokenSource, stream }, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);
      }
      getExpectedTokens(recognizer) {
        return recognizer.getExpectedTokens();
      }
      getTokenErrorDisplay(t) {
        if (!t) {
          return "<no token>";
        }
        let s = this.getSymbolText(t);
        if (!s) {
          if (this.getSymbolType(t) === Token_1.Token.EOF) {
            s = "<EOF>";
          } else {
            s = `<${this.getSymbolType(t)}>`;
          }
        }
        return this.escapeWSAndQuote(s);
      }
      getSymbolText(symbol) {
        return symbol.text;
      }
      getSymbolType(symbol) {
        return symbol.type;
      }
      escapeWSAndQuote(s) {
        s = s.replace("\n", "\\n");
        s = s.replace("\r", "\\r");
        s = s.replace("	", "\\t");
        return "'" + s + "'";
      }
      getErrorRecoverySet(recognizer) {
        let atn = recognizer.interpreter.atn;
        let ctx = recognizer.context;
        let recoverSet = new IntervalSet_1.IntervalSet();
        while (ctx && ctx.invokingState >= 0) {
          let invokingState = atn.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          let follow = atn.nextTokens(rt.followState);
          recoverSet.addAll(follow);
          ctx = ctx._parent;
        }
        recoverSet.remove(Token_1.Token.EPSILON);
        return recoverSet;
      }
      consumeUntil(recognizer, set) {
        let ttype = recognizer.inputStream.LA(1);
        while (ttype !== Token_1.Token.EOF && !set.contains(ttype)) {
          recognizer.consume();
          ttype = recognizer.inputStream.LA(1);
        }
      }
    };
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "beginErrorCondition", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "inErrorRecoveryMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "endErrorCondition", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reportMatch", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reportError", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "notifyErrorListeners", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "recover", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "sync", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportNoViableAlternative", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportInputMismatch", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportFailedPredicate", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportUnwantedToken", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportMissingToken", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "recoverInline", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "singleTokenInsertion", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "singleTokenDeletion", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getMissingSymbol", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getExpectedTokens", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getSymbolText", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getSymbolType", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "escapeWSAndQuote", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getErrorRecoverySet", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "consumeUntil", null);
    exports.DefaultErrorStrategy = DefaultErrorStrategy;
  }
});

// node_modules/antlr4ts/BailErrorStrategy.js
var require_BailErrorStrategy = __commonJS({
  "node_modules/antlr4ts/BailErrorStrategy.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BailErrorStrategy = void 0;
    var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
    var InputMismatchException_1 = require_InputMismatchException();
    var Decorators_1 = require_Decorators();
    var ParseCancellationException_1 = require_ParseCancellationException();
    var BailErrorStrategy = class extends DefaultErrorStrategy_1.DefaultErrorStrategy {
      recover(recognizer, e) {
        for (let context = recognizer.context; context; context = context.parent) {
          context.exception = e;
        }
        throw new ParseCancellationException_1.ParseCancellationException(e);
      }
      recoverInline(recognizer) {
        let e = new InputMismatchException_1.InputMismatchException(recognizer);
        for (let context = recognizer.context; context; context = context.parent) {
          context.exception = e;
        }
        throw new ParseCancellationException_1.ParseCancellationException(e);
      }
      sync(recognizer) {
      }
    };
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "recover", null);
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "recoverInline", null);
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "sync", null);
    exports.BailErrorStrategy = BailErrorStrategy;
  }
});

// node_modules/antlr4ts/CharStream.js
var require_CharStream = __commonJS({
  "node_modules/antlr4ts/CharStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/Dependents.js
var require_Dependents = __commonJS({
  "node_modules/antlr4ts/Dependents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dependents = void 0;
    var Dependents;
    (function(Dependents2) {
      Dependents2[Dependents2["SELF"] = 0] = "SELF";
      Dependents2[Dependents2["PARENTS"] = 1] = "PARENTS";
      Dependents2[Dependents2["CHILDREN"] = 2] = "CHILDREN";
      Dependents2[Dependents2["ANCESTORS"] = 3] = "ANCESTORS";
      Dependents2[Dependents2["DESCENDANTS"] = 4] = "DESCENDANTS";
      Dependents2[Dependents2["SIBLINGS"] = 5] = "SIBLINGS";
      Dependents2[Dependents2["PRECEEDING_SIBLINGS"] = 6] = "PRECEEDING_SIBLINGS";
      Dependents2[Dependents2["FOLLOWING_SIBLINGS"] = 7] = "FOLLOWING_SIBLINGS";
      Dependents2[Dependents2["PRECEEDING"] = 8] = "PRECEEDING";
      Dependents2[Dependents2["FOLLOWING"] = 9] = "FOLLOWING";
    })(Dependents = exports.Dependents || (exports.Dependents = {}));
  }
});

// node_modules/antlr4ts/DiagnosticErrorListener.js
var require_DiagnosticErrorListener = __commonJS({
  "node_modules/antlr4ts/DiagnosticErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticErrorListener = void 0;
    var BitSet_1 = require_BitSet();
    var Decorators_1 = require_Decorators();
    var Interval_1 = require_Interval();
    var DiagnosticErrorListener = class {
      constructor(exactOnly = true) {
        this.exactOnly = exactOnly;
        this.exactOnly = exactOnly;
      }
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      }
      reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (this.exactOnly && !exact) {
          return;
        }
        let decision = this.getDecisionDescription(recognizer, dfa);
        let conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
        let text4 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text4}'`;
        recognizer.notifyErrorListeners(message);
      }
      reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
        let format = "reportAttemptingFullContext d=%s, input='%s'";
        let decision = this.getDecisionDescription(recognizer, dfa);
        let text4 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportAttemptingFullContext d=${decision}, input='${text4}'`;
        recognizer.notifyErrorListeners(message);
      }
      reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
        let format = "reportContextSensitivity d=%s, input='%s'";
        let decision = this.getDecisionDescription(recognizer, dfa);
        let text4 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportContextSensitivity d=${decision}, input='${text4}'`;
        recognizer.notifyErrorListeners(message);
      }
      getDecisionDescription(recognizer, dfa) {
        let decision = dfa.decision;
        let ruleIndex = dfa.atnStartState.ruleIndex;
        let ruleNames = recognizer.ruleNames;
        if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
          return decision.toString();
        }
        let ruleName = ruleNames[ruleIndex];
        if (!ruleName) {
          return decision.toString();
        }
        return `${decision} (${ruleName})`;
      }
      getConflictingAlts(reportedAlts, configs) {
        if (reportedAlts != null) {
          return reportedAlts;
        }
        let result = new BitSet_1.BitSet();
        for (let config of configs) {
          result.set(config.alt);
        }
        return result;
      }
    };
    __decorate([
      Decorators_1.Override
    ], DiagnosticErrorListener.prototype, "syntaxError", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportAmbiguity", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportContextSensitivity", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "getDecisionDescription", null);
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "getConflictingAlts", null);
    exports.DiagnosticErrorListener = DiagnosticErrorListener;
  }
});

// node_modules/antlr4ts/LexerInterpreter.js
var require_LexerInterpreter = __commonJS({
  "node_modules/antlr4ts/LexerInterpreter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerInterpreter = void 0;
    var Lexer_1 = require_Lexer();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var Decorators_1 = require_Decorators();
    var Decorators_2 = require_Decorators();
    var LexerInterpreter = class LexerInterpreter extends Lexer_1.Lexer {
      constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
        super(input);
        if (atn.grammarType !== 0) {
          throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
        }
        this._grammarFileName = grammarFileName;
        this._atn = atn;
        this._ruleNames = ruleNames.slice(0);
        this._channelNames = channelNames.slice(0);
        this._modeNames = modeNames.slice(0);
        this._vocabulary = vocabulary;
        this._interp = new LexerATNSimulator_1.LexerATNSimulator(atn, this);
      }
      get atn() {
        return this._atn;
      }
      get grammarFileName() {
        return this._grammarFileName;
      }
      get ruleNames() {
        return this._ruleNames;
      }
      get channelNames() {
        return this._channelNames;
      }
      get modeNames() {
        return this._modeNames;
      }
      get vocabulary() {
        return this._vocabulary;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerInterpreter.prototype, "_vocabulary", void 0);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "atn", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "grammarFileName", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "ruleNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "channelNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "modeNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "vocabulary", null);
    LexerInterpreter = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerInterpreter);
    exports.LexerInterpreter = LexerInterpreter;
  }
});

// node_modules/antlr4ts/ParserErrorListener.js
var require_ParserErrorListener = __commonJS({
  "node_modules/antlr4ts/ParserErrorListener.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/RuleContextWithAltNum.js
var require_RuleContextWithAltNum = __commonJS({
  "node_modules/antlr4ts/RuleContextWithAltNum.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleContextWithAltNum = void 0;
    var ATN_1 = require_ATN();
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleContextWithAltNum = class extends ParserRuleContext_1.ParserRuleContext {
      constructor(parent, invokingStateNumber) {
        if (invokingStateNumber !== void 0) {
          super(parent, invokingStateNumber);
        } else {
          super();
        }
        this._altNumber = ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      get altNumber() {
        return this._altNumber;
      }
      set altNumber(altNum) {
        this._altNumber = altNum;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleContextWithAltNum.prototype, "altNumber", null);
    exports.RuleContextWithAltNum = RuleContextWithAltNum;
  }
});

// node_modules/antlr4ts/RuleDependency.js
var require_RuleDependency = __commonJS({
  "node_modules/antlr4ts/RuleDependency.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleDependency = void 0;
    function RuleDependency(dependency) {
      return (target, propertyKey, propertyDescriptor) => {
      };
    }
    exports.RuleDependency = RuleDependency;
  }
});

// node_modules/antlr4ts/RuleVersion.js
var require_RuleVersion = __commonJS({
  "node_modules/antlr4ts/RuleVersion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleVersion = void 0;
    function RuleVersion(version) {
      return (target, propertyKey, propertyDescriptor) => {
      };
    }
    exports.RuleVersion = RuleVersion;
  }
});

// node_modules/antlr4ts/TokenFactory.js
var require_TokenFactory = __commonJS({
  "node_modules/antlr4ts/TokenFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenSource.js
var require_TokenSource = __commonJS({
  "node_modules/antlr4ts/TokenSource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenStream.js
var require_TokenStream = __commonJS({
  "node_modules/antlr4ts/TokenStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenStreamRewriter.js
var require_TokenStreamRewriter = __commonJS({
  "node_modules/antlr4ts/TokenStreamRewriter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RewriteOperation = exports.TokenStreamRewriter = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var TokenStreamRewriter = class {
      constructor(tokens) {
        this.tokens = tokens;
        this.programs = /* @__PURE__ */ new Map();
        this.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);
        this.lastRewriteTokenIndexes = /* @__PURE__ */ new Map();
      }
      getTokenStream() {
        return this.tokens;
      }
      rollback(instructionIndex, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let is = this.programs.get(programName);
        if (is != null) {
          this.programs.set(programName, is.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));
        }
      }
      deleteProgram(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        this.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, programName);
      }
      insertAfter(tokenOrIndex, text4, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let index2;
        if (typeof tokenOrIndex === "number") {
          index2 = tokenOrIndex;
        } else {
          index2 = tokenOrIndex.tokenIndex;
        }
        let rewrites = this.getProgram(programName);
        let op = new InsertAfterOp(this.tokens, index2, rewrites.length, text4);
        rewrites.push(op);
      }
      insertBefore(tokenOrIndex, text4, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let index2;
        if (typeof tokenOrIndex === "number") {
          index2 = tokenOrIndex;
        } else {
          index2 = tokenOrIndex.tokenIndex;
        }
        let rewrites = this.getProgram(programName);
        let op = new InsertBeforeOp(this.tokens, index2, rewrites.length, text4);
        rewrites.push(op);
      }
      replaceSingle(index2, text4) {
        if (typeof index2 === "number") {
          this.replace(index2, index2, text4);
        } else {
          this.replace(index2, index2, text4);
        }
      }
      replace(from, to, text4, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        if (typeof from !== "number") {
          from = from.tokenIndex;
        }
        if (typeof to !== "number") {
          to = to.tokenIndex;
        }
        if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
          throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);
        }
        let rewrites = this.getProgram(programName);
        let op = new ReplaceOp(this.tokens, from, to, rewrites.length, text4);
        rewrites.push(op);
      }
      delete(from, to, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        if (to === void 0) {
          to = from;
        }
        if (typeof from === "number") {
          this.replace(from, to, "", programName);
        } else {
          this.replace(from, to, "", programName);
        }
      }
      getLastRewriteTokenIndex(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let I = this.lastRewriteTokenIndexes.get(programName);
        if (I == null) {
          return -1;
        }
        return I;
      }
      setLastRewriteTokenIndex(programName, i) {
        this.lastRewriteTokenIndexes.set(programName, i);
      }
      getProgram(name) {
        let is = this.programs.get(name);
        if (is == null) {
          is = this.initializeProgram(name);
        }
        return is;
      }
      initializeProgram(name) {
        let is = [];
        this.programs.set(name, is);
        return is;
      }
      getText(intervalOrProgram, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let interval;
        if (intervalOrProgram instanceof Interval_1.Interval) {
          interval = intervalOrProgram;
        } else {
          interval = Interval_1.Interval.of(0, this.tokens.size - 1);
        }
        if (typeof intervalOrProgram === "string") {
          programName = intervalOrProgram;
        }
        let rewrites = this.programs.get(programName);
        let start = interval.a;
        let stop = interval.b;
        if (stop > this.tokens.size - 1) {
          stop = this.tokens.size - 1;
        }
        if (start < 0) {
          start = 0;
        }
        if (rewrites == null || rewrites.length === 0) {
          return this.tokens.getText(interval);
        }
        let buf = [];
        let indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
        let i = start;
        while (i <= stop && i < this.tokens.size) {
          let op = indexToOp.get(i);
          indexToOp.delete(i);
          let t = this.tokens.get(i);
          if (op == null) {
            if (t.type !== Token_1.Token.EOF) {
              buf.push(String(t.text));
            }
            i++;
          } else {
            i = op.execute(buf);
          }
        }
        if (stop === this.tokens.size - 1) {
          for (let op of indexToOp.values()) {
            if (op.index >= this.tokens.size - 1) {
              buf.push(op.text.toString());
            }
          }
        }
        return buf.join("");
      }
      reduceToSingleOperationPerIndex(rewrites) {
        for (let i = 0; i < rewrites.length; i++) {
          let op = rewrites[i];
          if (op == null) {
            continue;
          }
          if (!(op instanceof ReplaceOp)) {
            continue;
          }
          let rop = op;
          let inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
          for (let iop of inserts) {
            if (iop.index === rop.index) {
              rewrites[iop.instructionIndex] = void 0;
              rop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : "");
            } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
              rewrites[iop.instructionIndex] = void 0;
            }
          }
          let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
          for (let prevRop of prevReplaces) {
            if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
              rewrites[prevRop.instructionIndex] = void 0;
              continue;
            }
            let disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
            if (prevRop.text == null && rop.text == null && !disjoint) {
              rewrites[prevRop.instructionIndex] = void 0;
              rop.index = Math.min(prevRop.index, rop.index);
              rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
            } else if (!disjoint) {
              throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);
            }
          }
        }
        for (let i = 0; i < rewrites.length; i++) {
          let op = rewrites[i];
          if (op == null) {
            continue;
          }
          if (!(op instanceof InsertBeforeOp)) {
            continue;
          }
          let iop = op;
          let prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
          for (let prevIop of prevInserts) {
            if (prevIop.index === iop.index) {
              if (prevIop instanceof InsertAfterOp) {
                iop.text = this.catOpText(prevIop.text, iop.text);
                rewrites[prevIop.instructionIndex] = void 0;
              } else if (prevIop instanceof InsertBeforeOp) {
                iop.text = this.catOpText(iop.text, prevIop.text);
                rewrites[prevIop.instructionIndex] = void 0;
              }
            }
          }
          let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
          for (let rop of prevReplaces) {
            if (iop.index === rop.index) {
              rop.text = this.catOpText(iop.text, rop.text);
              rewrites[i] = void 0;
              continue;
            }
            if (iop.index >= rop.index && iop.index <= rop.lastIndex) {
              throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);
            }
          }
        }
        let m = /* @__PURE__ */ new Map();
        for (let op of rewrites) {
          if (op == null) {
            continue;
          }
          if (m.get(op.index) != null) {
            throw new Error("should only be one op per index");
          }
          m.set(op.index, op);
        }
        return m;
      }
      catOpText(a, b) {
        let x = "";
        let y = "";
        if (a != null) {
          x = a.toString();
        }
        if (b != null) {
          y = b.toString();
        }
        return x + y;
      }
      getKindOfOps(rewrites, kind, before) {
        let ops = [];
        for (let i = 0; i < before && i < rewrites.length; i++) {
          let op = rewrites[i];
          if (op == null) {
            continue;
          }
          if (op instanceof kind) {
            ops.push(op);
          }
        }
        return ops;
      }
    };
    exports.TokenStreamRewriter = TokenStreamRewriter;
    TokenStreamRewriter.DEFAULT_PROGRAM_NAME = "default";
    TokenStreamRewriter.PROGRAM_INIT_SIZE = 100;
    TokenStreamRewriter.MIN_TOKEN_INDEX = 0;
    var RewriteOperation = class {
      constructor(tokens, index2, instructionIndex, text4) {
        this.tokens = tokens;
        this.instructionIndex = instructionIndex;
        this.index = index2;
        this.text = text4 === void 0 ? "" : text4;
      }
      execute(buf) {
        return this.index;
      }
      toString() {
        let opName = this.constructor.name;
        let $index = opName.indexOf("$");
        opName = opName.substring($index + 1, opName.length);
        return "<" + opName + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
      }
    };
    __decorate([
      Decorators_1.Override
    ], RewriteOperation.prototype, "toString", null);
    exports.RewriteOperation = RewriteOperation;
    var InsertBeforeOp = class extends RewriteOperation {
      constructor(tokens, index2, instructionIndex, text4) {
        super(tokens, index2, instructionIndex, text4);
      }
      execute(buf) {
        buf.push(this.text.toString());
        if (this.tokens.get(this.index).type !== Token_1.Token.EOF) {
          buf.push(String(this.tokens.get(this.index).text));
        }
        return this.index + 1;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InsertBeforeOp.prototype, "execute", null);
    var InsertAfterOp = class extends InsertBeforeOp {
      constructor(tokens, index2, instructionIndex, text4) {
        super(tokens, index2 + 1, instructionIndex, text4);
      }
    };
    var ReplaceOp = class extends RewriteOperation {
      constructor(tokens, from, to, instructionIndex, text4) {
        super(tokens, from, instructionIndex, text4);
        this.lastIndex = to;
      }
      execute(buf) {
        if (this.text != null) {
          buf.push(this.text.toString());
        }
        return this.lastIndex + 1;
      }
      toString() {
        if (this.text == null) {
          return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
        }
        return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
      }
    };
    __decorate([
      Decorators_1.Override
    ], ReplaceOp.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], ReplaceOp.prototype, "toString", null);
  }
});

// node_modules/antlr4ts/Vocabulary.js
var require_Vocabulary = __commonJS({
  "node_modules/antlr4ts/Vocabulary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/WritableToken.js
var require_WritableToken = __commonJS({
  "node_modules/antlr4ts/WritableToken.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/index.js
var require_antlr4ts = __commonJS({
  "node_modules/antlr4ts/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ANTLRErrorListener(), exports);
    __exportStar(require_ANTLRErrorStrategy(), exports);
    __exportStar(require_ANTLRInputStream(), exports);
    __exportStar(require_BailErrorStrategy(), exports);
    __exportStar(require_BufferedTokenStream(), exports);
    __exportStar(require_CharStream(), exports);
    __exportStar(require_CharStreams(), exports);
    __exportStar(require_CodePointBuffer(), exports);
    __exportStar(require_CodePointCharStream(), exports);
    __exportStar(require_CommonToken(), exports);
    __exportStar(require_CommonTokenFactory(), exports);
    __exportStar(require_CommonTokenStream(), exports);
    __exportStar(require_ConsoleErrorListener(), exports);
    __exportStar(require_DefaultErrorStrategy(), exports);
    __exportStar(require_Dependents(), exports);
    __exportStar(require_DiagnosticErrorListener(), exports);
    __exportStar(require_FailedPredicateException(), exports);
    __exportStar(require_InputMismatchException(), exports);
    __exportStar(require_InterpreterRuleContext(), exports);
    __exportStar(require_IntStream(), exports);
    __exportStar(require_Lexer(), exports);
    __exportStar(require_LexerInterpreter(), exports);
    __exportStar(require_LexerNoViableAltException(), exports);
    __exportStar(require_ListTokenSource(), exports);
    __exportStar(require_NoViableAltException(), exports);
    __exportStar(require_Parser(), exports);
    __exportStar(require_ParserErrorListener(), exports);
    __exportStar(require_ParserInterpreter(), exports);
    __exportStar(require_ParserRuleContext(), exports);
    __exportStar(require_ProxyErrorListener(), exports);
    __exportStar(require_ProxyParserErrorListener(), exports);
    __exportStar(require_RecognitionException(), exports);
    __exportStar(require_Recognizer(), exports);
    __exportStar(require_RuleContext(), exports);
    __exportStar(require_RuleContextWithAltNum(), exports);
    __exportStar(require_RuleDependency(), exports);
    __exportStar(require_RuleVersion(), exports);
    __exportStar(require_Token(), exports);
    __exportStar(require_TokenFactory(), exports);
    __exportStar(require_TokenSource(), exports);
    __exportStar(require_TokenStream(), exports);
    __exportStar(require_TokenStreamRewriter(), exports);
    __exportStar(require_Vocabulary(), exports);
    __exportStar(require_VocabularyImpl(), exports);
    __exportStar(require_WritableToken(), exports);
  }
});

// node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js
var require_AbstractParseTreeVisitor = __commonJS({
  "node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractParseTreeVisitor = void 0;
    var Decorators_1 = require_Decorators();
    var AbstractParseTreeVisitor2 = class {
      visit(tree) {
        return tree.accept(this);
      }
      visitChildren(node) {
        let result = this.defaultResult();
        let n = node.childCount;
        for (let i = 0; i < n; i++) {
          if (!this.shouldVisitNextChild(node, result)) {
            break;
          }
          let c = node.getChild(i);
          let childResult = c.accept(this);
          result = this.aggregateResult(result, childResult);
        }
        return result;
      }
      visitTerminal(node) {
        return this.defaultResult();
      }
      visitErrorNode(node) {
        return this.defaultResult();
      }
      aggregateResult(aggregate, nextResult) {
        return nextResult;
      }
      shouldVisitNextChild(node, currentResult) {
        return true;
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visit", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visitChildren", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visitTerminal", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "visitErrorNode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor2.prototype, "shouldVisitNextChild", null);
    exports.AbstractParseTreeVisitor = AbstractParseTreeVisitor2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CopyDocumentAsHTMLPlugin
});
module.exports = __toCommonJS(main_exports);

// node_modules/mdast-util-to-string/index.js
function toString(node, options) {
  var { includeImageAlt = true } = options || {};
  return one(node, includeImageAlt);
}
function one(node, includeImageAlt) {
  return node && typeof node === "object" && (node.value || (includeImageAlt ? node.alt : "") || "children" in node && all(node.children, includeImageAlt) || Array.isArray(node) && all(node, includeImageAlt)) || "";
}
function all(values, includeImageAlt) {
  var result = [];
  var index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one(values[index2], includeImageAlt);
  }
  return result.join("");
}

// node_modules/micromark-util-chunked/index.js
function splice(list2, start, remove, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    [].splice.apply(list2, parameters);
  } else {
    if (remove)
      [].splice.apply(list2, [start, remove]);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      [].splice.apply(list2, parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    for (code2 in right) {
      if (!hasOwnProperty.call(left, code2))
        left[code2] = [];
      const value2 = right[code2];
      constructs(left[code2], Array.isArray(value2) ? value2 : value2 ? [value2] : []);
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    ;
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-character/lib/unicode-punctuation-regex.js
var unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

// node_modules/micromark-util-character/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return code2 !== null && (code2 < 32 || code2 === 127);
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
var unicodeWhitespace = regexCheck(/\s/);
var unicodePunctuation = regexCheck(unicodePunctuationRegex);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && regex.test(String.fromCharCode(code2));
  }
}

// node_modules/micromark-factory-space/index.js
function factorySpace(effects, ok2, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok2(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok2(code2);
  }
}

// node_modules/micromark/lib/initialize/content.js
var content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  let previous4;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous4
    });
    if (previous4) {
      previous4.next = token;
    }
    previous4 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/micromark/lib/initialize/document.js
var document2 = {
  tokenize: initializeDocument
};
var containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self.containerState = item[1];
      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self.containerState._closeFlow) {
      self.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
      return checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
    }
    self.containerState = {};
    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self.parser.lazy[self.now().line] = continued !== stack.length;
    lineStartOffset = self.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self.currentConstruct, self.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self.parser.flow(self.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self.interrupt = void 0;
      return start;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
          return;
        }
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point2;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point2 = self.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self.containerState = entry[1];
      entry[0].exit.call(self, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}

// node_modules/micromark-util-classify-character/index.js
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text4;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text4 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text4, context]
          ]);
          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
          nextEvents = push(nextEvents, [
            ["exit", text4, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous4 = this.previous;
  const before = classifyCharacter(previous4);
  let marker;
  return start;
  function start(code2) {
    effects.enter("attentionSequence");
    marker = code2;
    return sequence(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return sequence;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close2 = !before || before === 2 && after || attentionMarkers2.includes(previous4);
    token._open = Boolean(marker === 42 ? open : open && (before || !close2));
    token._close = Boolean(marker === 42 ? close2 : close2 && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point2, offset) {
  point2.column += offset;
  point2.offset += offset;
  point2._bufferIndex += offset;
}

// node_modules/micromark-core-commonmark/lib/autolink.js
var autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 1;
  return start;
  function start(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return asciiAtext(code2) ? emailAtext(code2) : nok(code2);
  }
  function schemeOrEmailAtext(code2) {
    return code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2) ? schemeInsideOrEmailAtext(code2) : emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      return end(code2);
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      return end(code2);
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
      effects.consume(code2);
      return code2 === 45 ? emailValue : emailLabel;
    }
    return nok(code2);
  }
  function end(code2) {
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.exit("autolink");
    return ok2;
  }
}

// node_modules/micromark-core-commonmark/lib/blank-line.js
var blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return factorySpace(effects, afterWhitespace, "linePrefix");
  function afterWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 === 62) {
      const state = self.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(blockQuote, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function exit(effects) {
  effects.exit("blockQuote");
}

// node_modules/micromark-core-commonmark/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return open;
  }
  function open(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value2) {
  const characterReference2 = "&" + value2 + ";";
  element.innerHTML = characterReference2;
  const char = element.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value2 !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}

// node_modules/micromark-core-commonmark/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value2(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value2;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value2(code2);
  }
  function value2(code2) {
    let token;
    if (code2 === 59 && size) {
      token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code2) && size++ < max) {
      effects.consume(code2);
      return value2;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/code-fenced.js
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self = this;
  const closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  };
  const nonLazyLine2 = {
    tokenize: tokenizeNonLazyLine2,
    partial: true
  };
  const tail = this.events[this.events.length - 1];
  const initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    marker = code2;
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeFencedFenceSequence");
    return sizeOpen < 3 ? nok(code2) : factorySpace(effects, infoOpen, "whitespace")(code2);
  }
  function infoOpen(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, infoAfter, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return info;
  }
  function infoAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return openAfter(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return meta;
  }
  function openAfter(code2) {
    effects.exit("codeFencedFence");
    return self.interrupt ? ok2(code2) : contentStart(code2);
  }
  function contentStart(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(nonLazyLine2, effects.attempt(closingFenceConstruct, after, initialPrefix ? factorySpace(effects, contentStart, "linePrefix", initialPrefix + 1) : contentStart), after)(code2);
    }
    effects.enter("codeFlowValue");
    return contentContinue(code2);
  }
  function contentContinue(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return contentStart(code2);
    }
    effects.consume(code2);
    return contentContinue;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeNonLazyLine2(effects2, ok3, nok2) {
    const self2 = this;
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self2.parser.lazy[self2.now().line] ? nok2(code2) : ok3(code2);
    }
  }
  function tokenizeClosingFence(effects2, ok3, nok2) {
    let size = 0;
    return factorySpace(effects2, closingSequenceStart, "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function closingSequenceStart(code2) {
      effects2.enter("codeFencedFence");
      effects2.enter("codeFencedFenceSequence");
      return closingSequence(code2);
    }
    function closingSequence(code2) {
      if (code2 === marker) {
        effects2.consume(code2);
        size++;
        return closingSequence;
      }
      if (size < sizeOpen)
        return nok2(code2);
      effects2.exit("codeFencedFenceSequence");
      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code2);
    }
    function closingSequenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}

// node_modules/micromark-core-commonmark/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var indentedContent = {
  tokenize: tokenizeIndentedContent,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterStartPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterStartPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code2) : nok(code2);
  }
  function afterPrefix(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(indentedContent, afterPrefix, after)(code2);
    }
    effects.enter("codeFlowValue");
    return content3(code2);
  }
  function content3(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return afterPrefix(code2);
    }
    effects.consume(code2);
    return content3;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeIndentedContent(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (self.parser.lazy[self.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return start;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? start(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  const self = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return openingSequence(code2);
  }
  function openingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return openingSequence;
    }
    effects.exit("codeTextSequence");
    return gap(code2);
  }
  function gap(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return closingSequence(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return gap;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return gap;
    }
    effects.enter("codeTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return gap(code2);
    }
    effects.consume(code2);
    return data;
  }
  function closingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size++;
      return closingSequence;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token.type = "codeTextData";
    return data(code2);
  }
}

// node_modules/micromark-util-subtokenize/index.js
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous4;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous4) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous4 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.unshift([start2, start2 + slice.length - 1]);
    splice(events, start2, 2, slice);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/lib/content.js
var content2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous4;
  return start;
  function start(code2) {
    effects.enter("content");
    previous4 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
    }
    effects.consume(code2);
    return data;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous4.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous4
    });
    previous4 = previous4.next;
    return data;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self.events[self.events.length - 1];
    if (!self.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self.parser.constructs.flow, nok, ok2)(code2);
  }
}

// node_modules/micromark-factory-destination/index.js
function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return destinationEnclosedBefore;
    }
    if (code2 === null || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationRaw(code2);
  }
  function destinationEnclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationEnclosed(code2);
  }
  function destinationEnclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return destinationEnclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? destinationEnclosedEscape : destinationEnclosed;
  }
  function destinationEnclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return destinationEnclosed;
    }
    return destinationEnclosed(code2);
  }
  function destinationRaw(code2) {
    if (code2 === 40) {
      if (++balance > limit)
        return nok(code2);
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === 41) {
      if (!balance--) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok2(code2);
      }
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      if (balance)
        return nok(code2);
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code2);
    }
    if (asciiControl(code2))
      return nok(code2);
    effects.consume(code2);
    return code2 === 92 ? destinationRawEscape : destinationRaw;
  }
  function destinationRawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return destinationRaw;
    }
    return destinationRaw(code2);
  }
}

// node_modules/micromark-factory-label/index.js
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
  const self = this;
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 && !data || code2 === 94 && !size && "_hiddenFootnoteSupport" in self.parser.constructs || size > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return label(code2);
  }
  function label(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    data = data || !markdownSpace(code2);
    return code2 === 92 ? labelEscape : label;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return label;
    }
    return label(code2);
  }
}

// node_modules/micromark-factory-title/index.js
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    marker = code2 === 40 ? 41 : code2;
    return atFirstTitleBreak;
  }
  function atFirstTitleBreak(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    return atTitleBreak(code2);
  }
  function atTitleBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return atFirstTitleBreak(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atTitleBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return title(code2);
  }
  function title(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atTitleBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? titleEscape : title;
  }
  function titleEscape(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return title;
    }
    return title(code2);
  }
}

// node_modules/micromark-factory-whitespace/index.js
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code2);
    }
    return ok2(code2);
  }
}

// node_modules/micromark-util-normalize-identifier/index.js
function normalizeIdentifier(value2) {
  return value2.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-core-commonmark/lib/definition.js
var definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleConstruct = {
  tokenize: tokenizeTitle,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self = this;
  let identifier;
  return start;
  function start(code2) {
    effects.enter("definition");
    return factoryLabel.call(self, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return factoryWhitespace(effects, factoryDestination(effects, effects.attempt(titleConstruct, factorySpace(effects, after, "whitespace"), factorySpace(effects, after, "whitespace")), nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString"));
    }
    return nok(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      if (!self.parser.defined.includes(identifier)) {
        self.parser.defined.push(identifier);
      }
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitle(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, before)(code2) : nok(code2);
  }
  function before(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, factorySpace(effects, after, "whitespace"), nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("hardBreakEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("escapeMarker");
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text4;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text4 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text4, context],
      ["exit", text4, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  const self = this;
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("atxHeading");
    effects.enter("atxHeadingSequence");
    return fenceOpenInside(code2);
  }
  function fenceOpenInside(code2) {
    if (code2 === 35 && size++ < 6) {
      effects.consume(code2);
      return fenceOpenInside;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return self.interrupt ? ok2(code2) : headingBreak(code2);
    }
    return nok(code2);
  }
  function headingBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequence(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, headingBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data(code2);
  }
  function sequence(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequence;
    }
    effects.exit("atxHeadingSequence");
    return headingBreak(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return headingBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var nextBlankConstruct = {
  tokenize: tokenizeNextBlank,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self = this;
  let kind;
  let startTag;
  let buffer;
  let index2;
  let marker;
  return start;
  function start(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationStart;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      kind = 3;
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      startTag = true;
      return tagName;
    }
    return nok(code2);
  }
  function declarationStart(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      kind = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      kind = 5;
      buffer = "CDATA[";
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      kind = 4;
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    if (code2 === buffer.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === buffer.length ? self.interrupt ? ok2 : continuation : cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      if (code2 !== 47 && startTag && htmlRawNames.includes(buffer.toLowerCase())) {
        kind = 1;
        return self.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        kind = 6;
        if (code2 === 47) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self.interrupt ? ok2(code2) : continuation(code2);
      }
      kind = 7;
      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code2) : startTag ? completeAttributeNameBefore(code2) : completeClosingTagAfter(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    marker = null;
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    if (code2 === marker) {
      effects.consume(code2);
      return completeAttributeValueQuotedAfter;
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return code2 === null || markdownLineEnding(code2) ? continuation(code2) : nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && kind === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && kind === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && kind === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && kind === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && kind === 5) {
      effects.consume(code2);
      return continuationCharacterDataInside;
    }
    if (markdownLineEnding(code2) && (kind === 6 || kind === 7)) {
      return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationAtLineEnding(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationAtLineEnding(code2) {
    effects.exit("htmlFlowData");
    return htmlContinueStart(code2);
  }
  function htmlContinueStart(code2) {
    if (code2 === null) {
      return done(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt({
        tokenize: htmlLineEnd,
        partial: true
      }, htmlContinueStart, done)(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function htmlLineEnd(effects2, ok3, nok2) {
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self.parser.lazy[self.now().line] ? nok2(code2) : ok3(code2);
    }
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62 && htmlRawNames.includes(buffer.toLowerCase())) {
      effects.consume(code2);
      return continuationClose;
    }
    if (asciiAlpha(code2) && buffer.length < 8) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCharacterDataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 45 && kind === 2) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return done(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function done(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNextBlank(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.exit("htmlFlowData");
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    return effects.attempt(blankLine, ok2, nok);
  }
}

// node_modules/micromark-core-commonmark/lib/html-text.js
var htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self = this;
  let marker;
  let buffer;
  let index2;
  let returnState;
  return start;
  function start(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpen;
    }
    if (code2 === 91) {
      effects.consume(code2);
      buffer = "CDATA[";
      index2 = 0;
      return cdataOpen;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentStart;
    }
    return nok(code2);
  }
  function commentStart(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentStartDash;
    }
    return comment(code2);
  }
  function commentStartDash(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    return comment(code2);
  }
  function comment(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return end;
    }
    return comment(code2);
  }
  function cdataOpen(code2) {
    if (code2 === buffer.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === buffer.length ? cdata : cdataOpen;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === null || code2 === 62) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    marker = void 0;
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 62 || code2 === 47 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function atLineEnding(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, afterPrefix, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
  }
  function afterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
  function end(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var fullReferenceConstruct = {
  tokenize: tokenizeFullReference
};
var collapsedReferenceConstruct = {
  tokenize: tokenizeCollapsedReference
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  let token;
  while (++index2 < events.length) {
    token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close2;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close2) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close2 = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close2][1].end)
  };
  const text4 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close2 - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text4, context]]);
  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close2 - 3), context));
  media = push(media, [
    ["exit", text4, context],
    events[close2 - 2],
    events[close2 - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close2 + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self = this;
  let index2 = self.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self.events[index2][1].type === "labelImage" || self.events[index2][1].type === "labelLink") && !self.events[index2][1]._balanced) {
      labelStart = self.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive)
      return balanced(code2);
    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({
      start: labelStart.end,
      end: self.now()
    })));
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return afterLabelEnd;
  }
  function afterLabelEnd(code2) {
    if (code2 === 40) {
      return effects.attempt(resourceConstruct, ok2, defined ? ok2 : balanced)(code2);
    }
    if (code2 === 91) {
      return effects.attempt(fullReferenceConstruct, ok2, defined ? effects.attempt(collapsedReferenceConstruct, ok2, balanced) : balanced)(code2);
    }
    return defined ? ok2(code2) : balanced(code2);
  }
  function balanced(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return factoryWhitespace(effects, open);
  }
  function open(code2) {
    if (code2 === 41) {
      return end(code2);
    }
    return factoryDestination(effects, destinationAfter, nok, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code2);
  }
  function destinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, between)(code2) : end(code2);
  }
  function between(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, factoryWhitespace(effects, end), nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
    }
    return end(code2);
  }
  function end(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeFullReference(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    return factoryLabel.call(self, effects, afterLabel, nok, "reference", "referenceMarker", "referenceString")(code2);
  }
  function afterLabel(code2) {
    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok2(code2) : nok(code2);
  }
}
function tokenizeCollapsedReference(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/line-ending.js
var lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}

// node_modules/micromark-core-commonmark/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("thematicBreak");
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    if (size < 3 || code2 !== null && !markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.exit("thematicBreak");
    return ok2(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return atBreak(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/list.js
var list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code2) {
    const kind = self.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self.containerState.marker || code2 === self.containerState.marker : asciiDigit(code2)) {
      if (!self.containerState.type) {
        self.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code2 === self.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self.containerState.marker = self.containerState.marker || code2;
    return effects.check(blankLine, self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
  }
  function onBlank(code2) {
    self.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self.containerState.size = initialSize + self.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self = this;
  self.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;
    return factorySpace(effects, ok2, "listItemIndent", self.containerState.size + 1)(code2);
  }
  function notBlank(code2) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self.containerState.furtherBlankLines = void 0;
      self.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self.containerState.furtherBlankLines = void 0;
    self.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self.containerState._closeFlow = true;
    self.interrupt = void 0;
    return factorySpace(effects, effects.attempt(list, ok2, nok), "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self.containerState.size + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text4;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text4 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading = {
    type: "setextHeading",
    start: Object.assign({}, events[text4][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text4][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text4, 0, ["enter", heading, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content3][1] = heading;
  }
  events.push(["exit", heading, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self = this;
  let index2 = self.events.length;
  let marker;
  let paragraph;
  while (index2--) {
    if (self.events[index2][1].type !== "lineEnding" && self.events[index2][1].type !== "linePrefix" && self.events[index2][1].type !== "content") {
      paragraph = self.events[index2][1].type === "paragraph";
      break;
    }
  }
  return start;
  function start(code2) {
    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {
      effects.enter("setextHeadingLine");
      effects.enter("setextHeadingLineSequence");
      marker = code2;
      return closingSequence(code2);
    }
    return nok(code2);
  }
  function closingSequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return closingSequence;
    }
    effects.exit("setextHeadingLineSequence");
    return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code2);
  }
  function closingSequenceEnd(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark/lib/initialize/flow.js
var flow = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self = this;
  const initial = effects.attempt(blankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), "linePrefix")));
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/lib/initialize/text.js
var resolver = {
  resolveAll: createResolver()
};
var string = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0)
  };
  function initializeText(effects) {
    const self = this;
    const constructs2 = this.parser.constructs[field];
    const text4 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text4(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text4(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self, self.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) {
        } else {
          index2++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/lib/create-tokenizer.js
function createTokenizer(parser, initialize, from) {
  let point2 = Object.assign(from ? Object.assign({}, from) : {
    line: 1,
    column: 1,
    offset: 0
  }, {
    _index: 0,
    _bufferIndex: -1
  });
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit3,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    return Object.assign({}, point2);
  }
  function defineSkip(value2) {
    columnStart[value2.line] = value2.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    consumed = void 0;
    expectedCode = code2;
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code2;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit3(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start;
        function start(code2) {
          const def = code2 !== null && map[code2];
          const all2 = code2 !== null && map.null;
          const list2 = [
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code2);
          }
          return construct.tokenize.call(fields ? Object.assign(Object.create(context), fields) : context, effects, ok2, nok)(code2);
        }
      }
      function ok2(code2) {
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      view[0] = view[0].slice(startBufferIndex);
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value2;
    if (typeof chunk === "string") {
      value2 = chunk;
    } else
      switch (chunk) {
        case -5: {
          value2 = "\r";
          break;
        }
        case -4: {
          value2 = "\n";
          break;
        }
        case -3: {
          value2 = "\r\n";
          break;
        }
        case -2: {
          value2 = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value2 = " ";
          break;
        }
        default: {
          value2 = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value2);
  }
  return result.join("");
}

// node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text2
});
var document3 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
var contentInitial = {
  [91]: definition
};
var flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
var flow2 = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
var string2 = {
  [38]: characterReference,
  [92]: characterEscape
};
var text2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
var insideSpan = {
  null: [attention, resolver]
};
var attentionMarkers = {
  null: [42, 95]
};
var disable = {
  null: []
};

// node_modules/micromark/lib/parse.js
function parse(options = {}) {
  const constructs2 = combineExtensions([constructs_exports].concat(options.extensions || []));
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content),
    document: create2(document2),
    flow: create2(flow),
    string: create2(string),
    text: create2(text)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/micromark/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value2, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value2 = buffer + value2.toString(encoding);
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value2.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value2.length) {
      search.lastIndex = startPosition;
      match = search.exec(value2);
      endPosition = match && match.index !== void 0 ? match.index : value2.length;
      code2 = value2.charCodeAt(endPosition);
      if (!match) {
        buffer = value2.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value2.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer)
        chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}

// node_modules/micromark/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark-util-decode-numeric-character-reference/index.js
function decodeNumericCharacterReference(value2, base) {
  const code2 = Number.parseInt(value2, base);
  if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
    return "\uFFFD";
  }
  return String.fromCharCode(code2);
}

// node_modules/micromark-util-decode-string/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value2) {
  return value2.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/unist-util-stringify-position/index.js
function stringifyPosition(value2) {
  if (!value2 || typeof value2 !== "object") {
    return "";
  }
  if ("position" in value2 || "type" in value2) {
    return position(value2.position);
  }
  if ("start" in value2 || "end" in value2) {
    return position(value2);
  }
  if ("line" in value2 || "column" in value2) {
    return point(value2);
  }
  return "";
}
function point(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value2) {
  return value2 && typeof value2 === "number" ? value2 : 1;
}

// node_modules/mdast-util-from-markdown/lib/index.js
var own = {}.hasOwnProperty;
var fromMarkdown = function(value2, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value2, encoding, true))));
};
function compiler(options = {}) {
  const config = configure({
    transforms: [],
    canContainEols: [
      "emphasis",
      "fragment",
      "heading",
      "paragraph",
      "strong"
    ],
    enter: {
      autolink: opener2(link),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener2(heading),
      blockQuote: opener2(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener2(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener2(codeFlow, buffer),
      codeText: opener2(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener2(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener2(emphasis),
      hardBreakEscape: opener2(hardBreak),
      hardBreakTrailing: opener2(hardBreak),
      htmlFlow: opener2(html, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener2(html, buffer),
      htmlTextData: onenterdata,
      image: opener2(image),
      label: buffer,
      link: opener2(link),
      listItem: opener2(listItem),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener2(list2, onenterlistordered),
      listUnordered: opener2(list2),
      paragraph: opener2(paragraph),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener2(heading),
      strong: opener2(strong),
      thematicBreak: opener2(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  }, options.mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const stack = [tree];
    const tokenStack = [];
    const listStack = [];
    const context = {
      stack,
      tokenStack,
      config,
      enter,
      exit: exit3,
      buffer,
      resume,
      setData,
      getData
    };
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(Object.assign({
          sliceSerialize: events[index2][2].sliceSerialize
        }, context), events[index2][1]);
      }
    }
    if (tokenStack.length > 0) {
      const tail = tokenStack[tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point2(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem2;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
      } else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem2) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem2._spread = true;
          }
          listItem2.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem2, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem2 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start)
          };
          events.splice(index2, 0, ["enter", listItem2, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function setData(key, value2) {
    data[key] = value2;
  }
  function getData(key) {
    return data[key];
  }
  function point2(d) {
    return {
      line: d.line,
      column: d.column,
      offset: d.offset
    };
  }
  function opener2(create2, and) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    parent.children.push(node);
    this.stack.push(node);
    this.tokenStack.push([token, errorHandler]);
    node.position = {
      start: point2(token.start)
    };
    return node;
  }
  function closer(and) {
    return close2;
    function close2(token) {
      if (and)
        and.call(this, token);
      exit3.call(this, token);
    }
  }
  function exit3(token, onExitError) {
    const node = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
        start: token.start,
        end: token.end
      }) + "): it\u2019s not open");
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node.position.end = point2(token.end);
    return node;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.meta = data2;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside"))
      return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node = this.stack[this.stack.length - 1];
    if (!node.depth) {
      const depth = this.sliceSerialize(token).length;
      node.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    const node = this.stack[this.stack.length - 1];
    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    const parent = this.stack[this.stack.length - 1];
    let tail = parent.children[parent.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text4();
      tail.position = {
        start: point2(token.start)
      };
      parent.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point2(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexitlink() {
    const context = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context.type += "Reference";
      context.referenceType = getData("referenceType") || "shortcut";
      delete context.url;
      delete context.title;
    } else {
      delete context.identifier;
      delete context.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const context = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context.type += "Reference";
      context.referenceType = getData("referenceType") || "shortcut";
      delete context.url;
      delete context.title;
    } else {
      delete context.identifier;
      delete context.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    const ancestor = this.stack[this.stack.length - 2];
    const string3 = this.sliceSerialize(token);
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    setData("inReference", true);
    if (node.type === "link") {
      node.children = fragment.children;
    } else {
      node.alt = value2;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.title = data2;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = getData("characterReferenceType");
    let value2;
    if (type) {
      value2 = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
      setData("characterReferenceType");
    } else {
      value2 = decodeNamedCharacterReference(data2);
    }
    const tail = this.stack.pop();
    tail.value += value2;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node = this.stack[this.stack.length - 1];
    node.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node = this.stack[this.stack.length - 1];
    node.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function hardBreak() {
    return {
      type: "break"
    };
  }
  function html() {
    return {
      type: "html",
      value: ""
    };
  }
  function image() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong() {
    return {
      type: "strong",
      children: []
    };
  }
  function text4() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value2 = extensions[index2];
    if (Array.isArray(value2)) {
      configure(combined, value2);
    } else {
      extension(combined, value2);
    }
  }
  return combined;
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own.call(extension2, key)) {
      const list2 = key === "canContainEols" || key === "transforms";
      const maybe = own.call(combined, key) ? combined[key] : void 0;
      const left = maybe || (combined[key] = list2 ? [] : {});
      const right = extension2[key];
      if (right) {
        if (list2) {
          combined[key] = [...left, ...right];
        } else {
          Object.assign(left, right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
      start: left.start,
      end: left.end
    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is open");
  } else {
    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is still open");
  }
}

// node_modules/micromark-extension-math/lib/math-flow.js
var mathFlow = {
  tokenize: tokenizeMathFenced,
  concrete: true
};
var nonLazyLine = {
  tokenize: tokenizeNonLazyLine,
  partial: true
};
function tokenizeMathFenced(effects, ok2, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  const initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  return start;
  function start(code2) {
    effects.enter("mathFlow");
    effects.enter("mathFlowFence");
    effects.enter("mathFlowFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 36) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("mathFlowFenceSequence");
    return sizeOpen < 2 ? nok(code2) : factorySpace(effects, metaOpen, "whitespace")(code2);
  }
  function metaOpen(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("mathFlowFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("mathFlowFenceMeta");
      return openAfter(code2);
    }
    if (code2 === 36)
      return nok(code2);
    effects.consume(code2);
    return meta;
  }
  function openAfter(code2) {
    effects.exit("mathFlowFence");
    return self.interrupt ? ok2(code2) : contentStart(code2);
  }
  function contentStart(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(nonLazyLine, effects.attempt({
        tokenize: tokenizeClosingFence,
        partial: true
      }, after, initialSize ? factorySpace(effects, contentStart, "linePrefix", initialSize + 1) : contentStart), after)(code2);
    }
    effects.enter("mathFlowValue");
    return contentContinue(code2);
  }
  function contentContinue(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("mathFlowValue");
      return contentStart(code2);
    }
    effects.consume(code2);
    return contentContinue;
  }
  function after(code2) {
    effects.exit("mathFlow");
    return ok2(code2);
  }
  function tokenizeClosingFence(effects2, ok3, nok2) {
    let size = 0;
    return factorySpace(effects2, closingPrefixAfter, "linePrefix", 4);
    function closingPrefixAfter(code2) {
      effects2.enter("mathFlowFence");
      effects2.enter("mathFlowFenceSequence");
      return closingSequence(code2);
    }
    function closingSequence(code2) {
      if (code2 === 36) {
        effects2.consume(code2);
        size++;
        return closingSequence;
      }
      if (size < sizeOpen)
        return nok2(code2);
      effects2.exit("mathFlowFenceSequence");
      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code2);
    }
    function closingSequenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("mathFlowFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyLine(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self.parser.lazy[self.now().line] ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-extension-math/lib/math-text.js
function mathText(options = {}) {
  let single = options.singleDollarTextMath;
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    tokenize: tokenizeMathText,
    resolve: resolveMathText,
    previous: previous2
  };
  function tokenizeMathText(effects, ok2, nok) {
    const self = this;
    let sizeOpen = 0;
    let size;
    let token;
    return start;
    function start(code2) {
      effects.enter("mathText");
      effects.enter("mathTextSequence");
      return openingSequence(code2);
    }
    function openingSequence(code2) {
      if (code2 === 36) {
        effects.consume(code2);
        sizeOpen++;
        return openingSequence;
      }
      if (sizeOpen < 2 && !single)
        return nok(code2);
      effects.exit("mathTextSequence");
      return gap(code2);
    }
    function gap(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 36) {
        token = effects.enter("mathTextSequence");
        size = 0;
        return closingSequence(code2);
      }
      if (code2 === 32) {
        effects.enter("space");
        effects.consume(code2);
        effects.exit("space");
        return gap;
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return gap;
      }
      effects.enter("mathTextData");
      return data(code2);
    }
    function data(code2) {
      if (code2 === null || code2 === 32 || code2 === 36 || markdownLineEnding(code2)) {
        effects.exit("mathTextData");
        return gap(code2);
      }
      effects.consume(code2);
      return data;
    }
    function closingSequence(code2) {
      if (code2 === 36) {
        effects.consume(code2);
        size++;
        return closingSequence;
      }
      if (size === sizeOpen) {
        effects.exit("mathTextSequence");
        effects.exit("mathText");
        return ok2(code2);
      }
      token.type = "mathTextData";
      return data(code2);
    }
  }
}
function resolveMathText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "mathTextData") {
        events[tailExitIndex][1].type = "mathTextPadding";
        events[headEnterIndex][1].type = "mathTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "mathTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous2(code2) {
  return code2 !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}

// node_modules/micromark-extension-math/lib/syntax.js
function math(options) {
  return {
    flow: {
      [36]: mathFlow
    },
    text: {
      [36]: mathText(options)
    }
  };
}

// node_modules/mdast-util-to-markdown/lib/util/track.js
function track(options_) {
  const options = options_ || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;
  return { move, current, shift };
  function current() {
    return { now: { line, column }, lineShift };
  }
  function shift(value2) {
    lineShift += value2;
  }
  function move(value2 = "") {
    const chunks = value2.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value2;
  }
}

// node_modules/mdast-util-math/index.js
function mathFromMarkdown() {
  return {
    enter: {
      mathFlow: enterMathFlow,
      mathFlowFenceMeta: enterMathFlowMeta,
      mathText: enterMathText
    },
    exit: {
      mathFlow: exitMathFlow,
      mathFlowFence: exitMathFlowFence,
      mathFlowFenceMeta: exitMathFlowMeta,
      mathFlowValue: exitMathData,
      mathText: exitMathText,
      mathTextData: exitMathData
    }
  };
  function enterMathFlow(token) {
    this.enter({
      type: "math",
      meta: null,
      value: "",
      data: {
        hName: "div",
        hProperties: { className: ["math", "math-display"] },
        hChildren: [{ type: "text", value: "" }]
      }
    }, token);
  }
  function enterMathFlowMeta() {
    this.buffer();
  }
  function exitMathFlowMeta() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.meta = data;
  }
  function exitMathFlowFence() {
    if (this.getData("mathFlowInside"))
      return;
    this.buffer();
    this.setData("mathFlowInside", true);
  }
  function exitMathFlow(token) {
    const data = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    const node = this.exit(token);
    node.value = data;
    node.data.hChildren[0].value = data;
    this.setData("mathFlowInside");
  }
  function enterMathText(token) {
    this.enter({
      type: "inlineMath",
      value: "",
      data: {
        hName: "span",
        hProperties: { className: ["math", "math-inline"] },
        hChildren: [{ type: "text", value: "" }]
      }
    }, token);
    this.buffer();
  }
  function exitMathText(token) {
    const data = this.resume();
    const node = this.exit(token);
    node.value = data;
    node.data.hChildren[0].value = data;
  }
  function exitMathData(token) {
    this.config.enter.data.call(this, token);
    this.config.exit.data.call(this, token);
  }
}

// node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
var tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};
var gfmTaskListItem = {
  text: {
    [91]: tasklistCheck
  }
};
function tokenizeTasklistCheck(effects, ok2, nok) {
  const self = this;
  return open;
  function open(code2) {
    if (self.previous !== null || !self._gfmTasklistFirstContentOfListItem) {
      return nok(code2);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code2);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code2) {
    if (markdownLineEndingOrSpace(code2)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueUnchecked");
      return close2;
    }
    if (code2 === 88 || code2 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueChecked");
      return close2;
    }
    return nok(code2);
  }
  function close2(code2) {
    if (code2 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code2);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return effects.check({
        tokenize: spaceThenNonSpace
      }, ok2, nok);
    }
    return nok(code2);
  }
}
function spaceThenNonSpace(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, after, "whitespace");
  function after(code2) {
    const tail = self.events[self.events.length - 1];
    return (tail && tail[1].type === "whitespace" || markdownLineEnding(code2)) && code2 !== null ? ok2(code2) : nok(code2);
  }
}

// node_modules/mdast-util-gfm-task-list-item/index.js
var gfmTaskListItemFromMarkdown = {
  exit: {
    taskListCheckValueChecked: exitCheck,
    taskListCheckValueUnchecked: exitCheck,
    paragraph: exitParagraphWithTaskListItem
  }
};
function exitCheck(token) {
  const node = this.stack[this.stack.length - 2];
  node.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  const node = this.stack[this.stack.length - 1];
  const siblings = parent.children;
  const head = node.children[0];
  let index2 = -1;
  let firstParaghraph;
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean" && head && head.type === "text") {
    while (++index2 < siblings.length) {
      const sibling = siblings[index2];
      if (sibling.type === "paragraph") {
        firstParaghraph = sibling;
        break;
      }
    }
    if (firstParaghraph === node) {
      head.value = head.value.slice(1);
      if (head.value.length === 0) {
        node.children.shift();
      } else if (node.position && head.position && typeof head.position.start.offset === "number") {
        head.position.start.column++;
        head.position.start.offset++;
        node.position.start = Object.assign({}, head.position.start);
      }
    }
  }
  this.exit(token);
}

// node_modules/micromark-extension-gfm-table/lib/syntax.js
var gfmTable = {
  flow: {
    null: {
      tokenize: tokenizeTable,
      resolve: resolveTable
    }
  }
};
var nextPrefixedOrBlank = {
  tokenize: tokenizeNextPrefixedOrBlank,
  partial: true
};
function resolveTable(events, context) {
  let index2 = -1;
  let inHead;
  let inDelimiterRow;
  let inRow;
  let contentStart;
  let contentEnd;
  let cellStart;
  let seenCellInRow;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (inRow) {
      if (token.type === "temporaryTableCellContent") {
        contentStart = contentStart || index2;
        contentEnd = index2;
      }
      if ((token.type === "tableCellDivider" || token.type === "tableRow") && contentEnd) {
        const content3 = {
          type: "tableContent",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        const text4 = {
          type: "chunkText",
          start: content3.start,
          end: content3.end,
          contentType: "text"
        };
        events.splice(contentStart, contentEnd - contentStart + 1, ["enter", content3, context], ["enter", text4, context], ["exit", text4, context], ["exit", content3, context]);
        index2 -= contentEnd - contentStart - 3;
        contentStart = void 0;
        contentEnd = void 0;
      }
    }
    if (events[index2][0] === "exit" && cellStart !== void 0 && cellStart + (seenCellInRow ? 0 : 1) < index2 && (token.type === "tableCellDivider" || token.type === "tableRow" && (cellStart + 3 < index2 || events[cellStart][1].type !== "whitespace"))) {
      const cell = {
        type: inDelimiterRow ? "tableDelimiter" : inHead ? "tableHeader" : "tableData",
        start: events[cellStart][1].start,
        end: events[index2][1].end
      };
      events.splice(index2 + (token.type === "tableCellDivider" ? 1 : 0), 0, [
        "exit",
        cell,
        context
      ]);
      events.splice(cellStart, 0, ["enter", cell, context]);
      index2 += 2;
      cellStart = index2 + 1;
      seenCellInRow = true;
    }
    if (token.type === "tableRow") {
      inRow = events[index2][0] === "enter";
      if (inRow) {
        cellStart = index2 + 1;
        seenCellInRow = false;
      }
    }
    if (token.type === "tableDelimiterRow") {
      inDelimiterRow = events[index2][0] === "enter";
      if (inDelimiterRow) {
        cellStart = index2 + 1;
        seenCellInRow = false;
      }
    }
    if (token.type === "tableHead") {
      inHead = events[index2][0] === "enter";
    }
  }
  return events;
}
function tokenizeTable(effects, ok2, nok) {
  const self = this;
  const align = [];
  let tableHeaderCount = 0;
  let seenDelimiter;
  let hasDash;
  return start;
  function start(code2) {
    effects.enter("table")._align = align;
    effects.enter("tableHead");
    effects.enter("tableRow");
    if (code2 === 124) {
      return cellDividerHead(code2);
    }
    tableHeaderCount++;
    effects.enter("temporaryTableCellContent");
    return inCellContentHead(code2);
  }
  function cellDividerHead(code2) {
    effects.enter("tableCellDivider");
    effects.consume(code2);
    effects.exit("tableCellDivider");
    seenDelimiter = true;
    return cellBreakHead;
  }
  function cellBreakHead(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return atRowEndHead(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceHead;
    }
    if (seenDelimiter) {
      seenDelimiter = void 0;
      tableHeaderCount++;
    }
    if (code2 === 124) {
      return cellDividerHead(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentHead(code2);
  }
  function inWhitespaceHead(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceHead;
    }
    effects.exit("whitespace");
    return cellBreakHead(code2);
  }
  function inCellContentHead(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("temporaryTableCellContent");
      return cellBreakHead(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? inCellContentEscapeHead : inCellContentHead;
  }
  function inCellContentEscapeHead(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return inCellContentHead;
    }
    return inCellContentHead(code2);
  }
  function atRowEndHead(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.exit("tableRow");
    effects.exit("tableHead");
    const originalInterrupt = self.interrupt;
    self.interrupt = true;
    return effects.attempt({
      tokenize: tokenizeRowEnd,
      partial: true
    }, function(code3) {
      self.interrupt = originalInterrupt;
      effects.enter("tableDelimiterRow");
      return atDelimiterRowBreak(code3);
    }, function(code3) {
      self.interrupt = originalInterrupt;
      return nok(code3);
    })(code2);
  }
  function atDelimiterRowBreak(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return rowEndDelimiter(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      effects.consume(code2);
      hasDash = true;
      align.push("none");
      return inFillerDelimiter;
    }
    if (code2 === 58) {
      effects.enter("tableDelimiterAlignment");
      effects.consume(code2);
      effects.exit("tableDelimiterAlignment");
      align.push("left");
      return afterLeftAlignment;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return atDelimiterRowBreak;
    }
    return nok(code2);
  }
  function inWhitespaceDelimiter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    effects.exit("whitespace");
    return atDelimiterRowBreak(code2);
  }
  function inFillerDelimiter(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return inFillerDelimiter;
    }
    effects.exit("tableDelimiterFiller");
    if (code2 === 58) {
      effects.enter("tableDelimiterAlignment");
      effects.consume(code2);
      effects.exit("tableDelimiterAlignment");
      align[align.length - 1] = align[align.length - 1] === "left" ? "center" : "right";
      return afterRightAlignment;
    }
    return atDelimiterRowBreak(code2);
  }
  function afterLeftAlignment(code2) {
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      effects.consume(code2);
      hasDash = true;
      return inFillerDelimiter;
    }
    return nok(code2);
  }
  function afterRightAlignment(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return rowEndDelimiter(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return atDelimiterRowBreak;
    }
    return nok(code2);
  }
  function rowEndDelimiter(code2) {
    effects.exit("tableDelimiterRow");
    if (!hasDash || tableHeaderCount !== align.length) {
      return nok(code2);
    }
    if (code2 === null) {
      return tableClose(code2);
    }
    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({
      tokenize: tokenizeRowEnd,
      partial: true
    }, factorySpace(effects, bodyStart, "linePrefix", 4), tableClose))(code2);
  }
  function tableClose(code2) {
    effects.exit("table");
    return ok2(code2);
  }
  function bodyStart(code2) {
    effects.enter("tableBody");
    return rowStartBody(code2);
  }
  function rowStartBody(code2) {
    effects.enter("tableRow");
    if (code2 === 124) {
      return cellDividerBody(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentBody(code2);
  }
  function cellDividerBody(code2) {
    effects.enter("tableCellDivider");
    effects.consume(code2);
    effects.exit("tableCellDivider");
    return cellBreakBody;
  }
  function cellBreakBody(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return atRowEndBody(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceBody;
    }
    if (code2 === 124) {
      return cellDividerBody(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentBody(code2);
  }
  function inWhitespaceBody(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceBody;
    }
    effects.exit("whitespace");
    return cellBreakBody(code2);
  }
  function inCellContentBody(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("temporaryTableCellContent");
      return cellBreakBody(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? inCellContentEscapeBody : inCellContentBody;
  }
  function inCellContentEscapeBody(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return inCellContentBody;
    }
    return inCellContentBody(code2);
  }
  function atRowEndBody(code2) {
    effects.exit("tableRow");
    if (code2 === null) {
      return tableBodyClose(code2);
    }
    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({
      tokenize: tokenizeRowEnd,
      partial: true
    }, factorySpace(effects, rowStartBody, "linePrefix", 4), tableBodyClose))(code2);
  }
  function tableBodyClose(code2) {
    effects.exit("tableBody");
    return tableClose(code2);
  }
  function tokenizeRowEnd(effects2, ok3, nok2) {
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return factorySpace(effects2, prefixed, "linePrefix");
    }
    function prefixed(code2) {
      if (self.parser.lazy[self.now().line] || code2 === null || markdownLineEnding(code2)) {
        return nok2(code2);
      }
      const tail = self.events[self.events.length - 1];
      if (!self.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
        return nok2(code2);
      }
      self._gfmTableDynamicInterruptHack = true;
      return effects2.check(self.parser.constructs.flow, function(code3) {
        self._gfmTableDynamicInterruptHack = false;
        return nok2(code3);
      }, function(code3) {
        self._gfmTableDynamicInterruptHack = false;
        return ok3(code3);
      })(code2);
    }
  }
}
function tokenizeNextPrefixedOrBlank(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("check");
    effects.consume(code2);
    return whitespace;
  }
  function whitespace(code2) {
    if (code2 === -1 || code2 === 32) {
      effects.consume(code2);
      size++;
      return size === 4 ? ok2 : whitespace;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, context, safeOptions) {
  const indexStack = context.indexStack;
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  let before = safeOptions.before;
  indexStack.push(-1);
  let tracker = track(safeOptions);
  while (++index2 < children.length) {
    const child = children[index2];
    let after;
    indexStack[indexStack.length - 1] = index2;
    if (index2 + 1 < children.length) {
      let handle = context.handle.handlers[children[index2 + 1].type];
      if (handle && handle.peek)
        handle = handle.peek;
      after = handle ? handle(children[index2 + 1], parent, context, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after = safeOptions.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
      before = " ";
      tracker = track(safeOptions);
      tracker.move(results.join(""));
    }
    results.push(tracker.move(context.handle(child, parent, context, {
      ...tracker.current(),
      before,
      after
    })));
    before = results[results.length - 1].slice(-1);
  }
  indexStack.pop();
  return results.join("");
}

// node_modules/mdast-util-gfm-table/lib/index.js
var gfmTableFromMarkdown = {
  enter: {
    table: enterTable,
    tableData: enterCell,
    tableHeader: enterCell,
    tableRow: enterRow
  },
  exit: {
    codeText: exitCodeText,
    table: exitTable,
    tableData: exit2,
    tableHeader: exit2,
    tableRow: exit2
  }
};
function enterTable(token) {
  const align = token._align;
  this.enter({
    type: "table",
    align: align.map((d) => d === "none" ? null : d),
    children: []
  }, token);
  this.setData("inTable", true);
}
function exitTable(token) {
  this.exit(token);
  this.setData("inTable");
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit2(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value2 = this.resume();
  if (this.getData("inTable")) {
    value2 = value2.replace(/\\([\\|])/g, replace);
  }
  const node = this.stack[this.stack.length - 1];
  node.value = value2;
  this.exit(token);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}

// node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
function gfmStrikethrough(options = {}) {
  let single = options.singleTilde;
  const tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text4 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text4, context]
            ];
            splice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text4, context],
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context],
              ["exit", strikethrough, context]
            ]);
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok2, nok) {
    const previous4 = this.previous;
    const events = this.events;
    let size = 0;
    return start;
    function start(code2) {
      if (previous4 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code2);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code2);
    }
    function more(code2) {
      const before = classifyCharacter(previous4);
      if (code2 === 126) {
        if (size > 1)
          return nok(code2);
        effects.consume(code2);
        size++;
        return more;
      }
      if (size < 2 && !single)
        return nok(code2);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code2);
      token._open = !after || after === 2 && Boolean(before);
      token._close = !before || before === 2 && Boolean(after);
      return ok2(code2);
    }
  }
}

// node_modules/mdast-util-gfm-strikethrough/index.js
var gfmStrikethroughFromMarkdown = {
  canContainEols: ["delete"],
  enter: { strikethrough: enterStrikethrough },
  exit: { strikethrough: exitStrikethrough }
};
handleDelete.peek = peekDelete;
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node, _, context, safeOptions) {
  const tracker = track(safeOptions);
  const exit3 = context.enter("emphasis");
  let value2 = tracker.move("~~");
  value2 += containerPhrasing(node, context, {
    ...tracker.current(),
    before: value2,
    after: "~"
  });
  value2 += tracker.move("~~");
  exit3();
  return value2;
}
function peekDelete() {
  return "~";
}

// node_modules/micromark-extension-gfm-footnote/lib/syntax.js
var indent = {
  tokenize: tokenizeIndent2,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
  const self = this;
  let index2 = self.events.length;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token = self.events[index2][1];
    if (token.type === "labelImage") {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code2);
    }
    const id = normalizeIdentifier(self.sliceSerialize({
      start: labelStart.end,
      end: self.now()
    }));
    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {
      return nok(code2);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok2(code2);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  let labelStart;
  while (index2--) {
    if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
      labelStart = events[index2][1];
      break;
    }
  }
  events[index2 + 1][1].type = "data";
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call, context],
    events[index2 + 3],
    events[index2 + 4],
    ["enter", marker, context],
    ["exit", marker, context],
    ["enter", string3, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string3, context],
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok2, nok) {
  const self = this;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code2) {
    if (code2 !== 94)
      return nok(code2);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code2) {
    let token;
    if (code2 === null || code2 === 91 || size++ > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      if (!data) {
        return nok(code2);
      }
      effects.exit("chunkString");
      token = effects.exit("gfmFootnoteCallString");
      return defined.includes(normalizeIdentifier(self.sliceSerialize(token))) ? end(code2) : nok(code2);
    }
    effects.consume(code2);
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    return code2 === 92 ? callEscape : callData;
  }
  function callEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return callData;
    }
    return callData(code2);
  }
  function end(code2) {
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    effects.exit("gfmFootnoteCall");
    return ok2;
  }
}
function tokenizeDefinitionStart(effects, ok2, nok) {
  const self = this;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let identifier;
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelStart;
  }
  function labelStart(code2) {
    if (code2 === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      return atBreak;
    }
    return nok(code2);
  }
  function atBreak(code2) {
    let token;
    if (code2 === null || code2 === 91 || size > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      if (!data) {
        return nok(code2);
      }
      token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      size++;
      return atBreak;
    }
    effects.enter("chunkString").contentType = "string";
    return label(code2);
  }
  function label(code2) {
    if (code2 === null || markdownLineEnding(code2) || code2 === 91 || code2 === 93 || size > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size++;
    effects.consume(code2);
    return code2 === 92 ? labelEscape : label;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return label;
    }
    return label(code2);
  }
  function labelAfter(code2) {
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return factorySpace(effects, done, "gfmFootnoteDefinitionWhitespace");
    }
    return nok(code2);
  }
  function done(code2) {
    if (!defined.includes(identifier)) {
      defined.push(identifier);
    }
    return ok2(code2);
  }
}
function tokenizeDefinitionContinuation(effects, ok2, nok) {
  return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent2(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 4 + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
  }
}

// node_modules/mdast-util-gfm-footnote/index.js
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
  function enterFootnoteDefinition(token) {
    this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, token);
  }
  function enterFootnoteDefinitionLabelString() {
    this.buffer();
  }
  function exitFootnoteDefinitionLabelString(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function exitFootnoteDefinition(token) {
    this.exit(token);
  }
  function enterFootnoteCall(token) {
    this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
  }
  function enterFootnoteCallString() {
    this.buffer();
  }
  function exitFootnoteCallString(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function exitFootnoteCall(token) {
    this.exit(token);
  }
}

// node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
var www = {
  tokenize: tokenizeWww,
  partial: true
};
var domain = {
  tokenize: tokenizeDomain,
  partial: true
};
var path = {
  tokenize: tokenizePath,
  partial: true
};
var punctuation = {
  tokenize: tokenizePunctuation,
  partial: true
};
var namedCharacterReference = {
  tokenize: tokenizeNamedCharacterReference,
  partial: true
};
var wwwAutolink = {
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
var httpAutolink = {
  tokenize: tokenizeHttpAutolink,
  previous: previousHttp
};
var emailAutolink = {
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
var text3 = {};
var gfmAutolinkLiteral = {
  text: text3
};
var code = 48;
while (code < 123) {
  text3[code] = emailAutolink;
  code++;
  if (code === 58)
    code = 65;
  else if (code === 91)
    code = 97;
}
text3[43] = emailAutolink;
text3[45] = emailAutolink;
text3[46] = emailAutolink;
text3[95] = emailAutolink;
text3[72] = [emailAutolink, httpAutolink];
text3[104] = [emailAutolink, httpAutolink];
text3[87] = [emailAutolink, wwwAutolink];
text3[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok2, nok) {
  const self = this;
  let hasDot;
  let hasDigitInLastSegment;
  return start;
  function start(code2) {
    if (!gfmAtext(code2) || !previousEmail(self.previous) || previousUnbalanced(self.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code2);
  }
  function atext(code2) {
    if (gfmAtext(code2)) {
      effects.consume(code2);
      return atext;
    }
    if (code2 === 64) {
      effects.consume(code2);
      return label;
    }
    return nok(code2);
  }
  function label(code2) {
    if (code2 === 46) {
      return effects.check(punctuation, done, dotContinuation)(code2);
    }
    if (code2 === 45 || code2 === 95) {
      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code2);
    }
    if (asciiAlphanumeric(code2)) {
      if (!hasDigitInLastSegment && asciiDigit(code2)) {
        hasDigitInLastSegment = true;
      }
      effects.consume(code2);
      return label;
    }
    return done(code2);
  }
  function dotContinuation(code2) {
    effects.consume(code2);
    hasDot = true;
    hasDigitInLastSegment = void 0;
    return label;
  }
  function dashOrUnderscoreContinuation(code2) {
    effects.consume(code2);
    return afterDashOrUnderscore;
  }
  function afterDashOrUnderscore(code2) {
    if (code2 === 46) {
      return effects.check(punctuation, nok, dotContinuation)(code2);
    }
    return label(code2);
  }
  function done(code2) {
    if (hasDot && !hasDigitInLastSegment) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeWwwAutolink(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 !== 87 && code2 !== 119 || !previousWww(self.previous) || previousUnbalanced(self.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(www, effects.attempt(domain, effects.attempt(path, done), nok), nok)(code2);
  }
  function done(code2) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeHttpAutolink(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 !== 72 && code2 !== 104 || !previousHttp(self.previous) || previousUnbalanced(self.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkHttp");
    effects.consume(code2);
    return t1;
  }
  function t1(code2) {
    if (code2 === 84 || code2 === 116) {
      effects.consume(code2);
      return t2;
    }
    return nok(code2);
  }
  function t2(code2) {
    if (code2 === 84 || code2 === 116) {
      effects.consume(code2);
      return p;
    }
    return nok(code2);
  }
  function p(code2) {
    if (code2 === 80 || code2 === 112) {
      effects.consume(code2);
      return s;
    }
    return nok(code2);
  }
  function s(code2) {
    if (code2 === 83 || code2 === 115) {
      effects.consume(code2);
      return colon;
    }
    return colon(code2);
  }
  function colon(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      return slash1;
    }
    return nok(code2);
  }
  function slash1(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return slash2;
    }
    return nok(code2);
  }
  function slash2(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || asciiControl(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path, done), nok)(code2);
  }
  function done(code2) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeWww(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return w2;
  }
  function w2(code2) {
    if (code2 === 87 || code2 === 119) {
      effects.consume(code2);
      return w3;
    }
    return nok(code2);
  }
  function w3(code2) {
    if (code2 === 87 || code2 === 119) {
      effects.consume(code2);
      return dot;
    }
    return nok(code2);
  }
  function dot(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? nok(code2) : ok2(code2);
  }
}
function tokenizeDomain(effects, ok2, nok) {
  let hasUnderscoreInLastSegment;
  let hasUnderscoreInLastLastSegment;
  return domain2;
  function domain2(code2) {
    if (code2 === 38) {
      return effects.check(namedCharacterReference, done, punctuationContinuation)(code2);
    }
    if (code2 === 46 || code2 === 95) {
      return effects.check(punctuation, done, punctuationContinuation)(code2);
    }
    if (code2 === null || asciiControl(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
      return done(code2);
    }
    effects.consume(code2);
    return domain2;
  }
  function punctuationContinuation(code2) {
    if (code2 === 46) {
      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
      hasUnderscoreInLastSegment = void 0;
      effects.consume(code2);
      return domain2;
    }
    if (code2 === 95)
      hasUnderscoreInLastSegment = true;
    effects.consume(code2);
    return domain2;
  }
  function done(code2) {
    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizePath(effects, ok2) {
  let balance = 0;
  return inPath;
  function inPath(code2) {
    if (code2 === 38) {
      return effects.check(namedCharacterReference, ok2, continuedPunctuation)(code2);
    }
    if (code2 === 40) {
      balance++;
    }
    if (code2 === 41) {
      return effects.check(punctuation, parenAtPathEnd, continuedPunctuation)(code2);
    }
    if (pathEnd(code2)) {
      return ok2(code2);
    }
    if (trailingPunctuation(code2)) {
      return effects.check(punctuation, ok2, continuedPunctuation)(code2);
    }
    effects.consume(code2);
    return inPath;
  }
  function continuedPunctuation(code2) {
    effects.consume(code2);
    return inPath;
  }
  function parenAtPathEnd(code2) {
    balance--;
    return balance < 0 ? ok2(code2) : continuedPunctuation(code2);
  }
}
function tokenizeNamedCharacterReference(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return inside;
  }
  function inside(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return inside;
    }
    if (code2 === 59) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return pathEnd(code2) ? ok2(code2) : nok(code2);
  }
}
function tokenizePunctuation(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (trailingPunctuation(code2)) {
      effects.consume(code2);
      return after;
    }
    return pathEnd(code2) ? ok2(code2) : nok(code2);
  }
}
function trailingPunctuation(code2) {
  return code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 95 || code2 === 126;
}
function pathEnd(code2) {
  return code2 === null || code2 === 60 || markdownLineEndingOrSpace(code2);
}
function gfmAtext(code2) {
  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
}
function previousWww(code2) {
  return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 126 || markdownLineEndingOrSpace(code2);
}
function previousHttp(code2) {
  return code2 === null || !asciiAlpha(code2);
}
function previousEmail(code2) {
  return code2 !== 47 && previousHttp(code2);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token = events[index2][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}

// node_modules/ccount/index.js
function ccount(value2, character) {
  const source = String(value2);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character, index2 + character.length);
  }
  return count;
}

// node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/unist-util-is/index.js
var convert = function(test) {
  if (test === void 0 || test === null) {
    return ok;
  }
  if (typeof test === "string") {
    return typeFactory(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
  }
  if (typeof test === "function") {
    return castFactory(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all2);
  function all2(node) {
    let key;
    for (key in check) {
      if (node[key] !== check[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node) {
    return node && node.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(...parameters) {
    return Boolean(check.call(this, ...parameters));
  }
}
function ok() {
  return true;
}

// node_modules/unist-util-visit-parents/color.browser.js
function color(d) {
  return d;
}

// node_modules/unist-util-visit-parents/index.js
var CONTINUE = true;
var SKIP = "skip";
var EXIT = false;
var visitParents = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  const is = convert(test);
  const step = reverse ? -1 : 1;
  factory(tree, null, [])();
  function factory(node, index2, parents) {
    const value2 = typeof node === "object" && node !== null ? node : {};
    let name;
    if (typeof value2.type === "string") {
      name = typeof value2.tagName === "string" ? value2.tagName : typeof value2.name === "string" ? value2.name : void 0;
      Object.defineProperty(visit, "name", {
        value: "node (" + color(value2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit;
    function visit() {
      let result = [];
      let subresult;
      let offset;
      let grandparents;
      if (!test || is(node, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if (node.children && result[0] !== SKIP) {
        offset = (reverse ? node.children.length : -1) + step;
        grandparents = parents.concat(node);
        while (offset > -1 && offset < node.children.length) {
          subresult = factory(node.children[offset], offset, grandparents)();
          if (subresult[0] === EXIT) {
            return subresult;
          }
          offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
        }
      }
      return result;
    }
  }
};
function toResult(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  if (typeof value2 === "number") {
    return [CONTINUE, value2];
  }
  return [value2];
}

// node_modules/mdast-util-find-and-replace/lib/index.js
var own2 = {}.hasOwnProperty;
var findAndReplace = function(tree, find, replace2, options) {
  let settings;
  let schema;
  if (typeof find === "string" || find instanceof RegExp) {
    schema = [[find, replace2]];
    settings = options;
  } else {
    schema = find;
    settings = replace2;
  }
  if (!settings) {
    settings = {};
  }
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(schema);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  return tree;
  function visitor(node, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      if (ignored(parent, grandparent ? grandparent.children.indexOf(parent) : void 0, grandparent)) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node, parents);
    }
  }
  function handler(node, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace3 = pairs[pairIndex][1];
    let start = 0;
    const index2 = parent.children.indexOf(node);
    let change = false;
    let nodes = [];
    let position2;
    find2.lastIndex = 0;
    let match = find2.exec(node.value);
    while (match) {
      position2 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node]
      };
      let value2 = replace3(...match, matchObject);
      if (typeof value2 === "string") {
        value2 = value2.length > 0 ? { type: "text", value: value2 } : void 0;
      }
      if (value2 !== false) {
        if (start !== position2) {
          nodes.push({
            type: "text",
            value: node.value.slice(start, position2)
          });
        }
        if (Array.isArray(value2)) {
          nodes.push(...value2);
        } else if (value2) {
          nodes.push(value2);
        }
        start = position2 + match[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match = find2.exec(node.value);
    }
    if (change) {
      if (start < node.value.length) {
        nodes.push({ type: "text", value: node.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node];
    }
    return index2 + nodes.length;
  }
};
function toPairs(schema) {
  const result = [];
  if (typeof schema !== "object") {
    throw new TypeError("Expected array or object as schema");
  }
  if (Array.isArray(schema)) {
    let index2 = -1;
    while (++index2 < schema.length) {
      result.push([
        toExpression(schema[index2][0]),
        toFunction(schema[index2][1])
      ]);
    }
  } else {
    let key;
    for (key in schema) {
      if (own2.call(schema, key)) {
        result.push([toExpression(key), toFunction(schema[key])]);
      }
    }
  }
  return result;
}
function toExpression(find) {
  return typeof find === "string" ? new RegExp(escapeStringRegexp(find), "g") : find;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : () => replace2;
}

// node_modules/mdast-util-gfm-autolink-literal/index.js
var gfmAutolinkLiteralFromMarkdown = {
  transforms: [transformGfmAutolinkLiterals],
  enter: {
    literalAutolink: enterLiteralAutolink,
    literalAutolinkEmail: enterLiteralAutolinkValue,
    literalAutolinkHttp: enterLiteralAutolinkValue,
    literalAutolinkWww: enterLiteralAutolinkValue
  },
  exit: {
    literalAutolink: exitLiteralAutolink,
    literalAutolinkEmail: exitLiteralAutolinkEmail,
    literalAutolinkHttp: exitLiteralAutolinkHttp,
    literalAutolinkWww: exitLiteralAutolinkWww
  }
};
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node = this.stack[this.stack.length - 1];
  node.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(tree, [
    [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
    [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
  ], { ignore: ["link", "linkReference"] });
}
function findUrl(_, protocol, domain2, path2, match) {
  let prefix = "";
  if (!previous3(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path2);
  if (!parts[0])
    return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_, atext, label, match) {
  if (!previous3(match, true) || /[_-\d]$/.test(label)) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  let closingParenIndex;
  let openingParens;
  let closingParens;
  let trail;
  if (trailExec) {
    url = url.slice(0, trailExec.index);
    trail = trailExec[0];
    closingParenIndex = trail.indexOf(")");
    openingParens = ccount(url, "(");
    closingParens = ccount(url, ")");
    while (closingParenIndex !== -1 && openingParens > closingParens) {
      url += trail.slice(0, closingParenIndex + 1);
      trail = trail.slice(closingParenIndex + 1);
      closingParenIndex = trail.indexOf(")");
      closingParens++;
    }
  }
  return [url, trail];
}
function previous3(match, email) {
  const code2 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
}

// node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral,
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable,
    gfmTaskListItem
  ]);
}

// node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown,
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown,
    gfmTableFromMarkdown,
    gfmTaskListItemFromMarkdown
  ];
}

// node_modules/fault/index.js
var import_format = __toESM(require_format(), 1);
var fault = Object.assign(create(Error), {
  eval: create(EvalError),
  range: create(RangeError),
  reference: create(ReferenceError),
  syntax: create(SyntaxError),
  type: create(TypeError),
  uri: create(URIError)
});
function create(Constructor) {
  FormattedError.displayName = Constructor.displayName || Constructor.name;
  return FormattedError;
  function FormattedError(format, ...values) {
    const reason = format ? (0, import_format.default)(format, ...values) : format;
    return new Constructor(reason);
  }
}

// node_modules/micromark-extension-frontmatter/matters.js
var own3 = {}.hasOwnProperty;
var markers = {
  yaml: "-",
  toml: "+"
};
function matters(options = "yaml") {
  const results = [];
  let index2 = -1;
  if (!Array.isArray(options)) {
    options = [options];
  }
  while (++index2 < options.length) {
    results[index2] = matter(options[index2]);
  }
  return results;
}
function matter(option) {
  let result = option;
  if (typeof result === "string") {
    if (!own3.call(markers, result)) {
      throw fault("Missing matter definition for `%s`", result);
    }
    result = {
      type: result,
      marker: markers[result]
    };
  } else if (typeof result !== "object") {
    throw fault("Expected matter to be an object, not `%j`", result);
  }
  if (!own3.call(result, "type")) {
    throw fault("Missing `type` in matter `%j`", result);
  }
  if (!own3.call(result, "fence") && !own3.call(result, "marker")) {
    throw fault("Missing `marker` or `fence` in matter `%j`", result);
  }
  return result;
}

// node_modules/micromark-extension-frontmatter/lib/syntax.js
function frontmatter(options) {
  const settings = matters(options);
  const flow3 = {};
  let index2 = -1;
  let matter2;
  let code2;
  while (++index2 < settings.length) {
    matter2 = settings[index2];
    code2 = fence(matter2, "open").charCodeAt(0);
    if (code2 in flow3) {
      flow3[code2].push(parse2(matter2));
    } else {
      flow3[code2] = [parse2(matter2)];
    }
  }
  return {
    flow: flow3
  };
}
function parse2(matter2) {
  const name = matter2.type;
  const anywhere = matter2.anywhere;
  const valueType = name + "Value";
  const fenceType = name + "Fence";
  const sequenceType = fenceType + "Sequence";
  const fenceConstruct = {
    tokenize: tokenizeFence,
    partial: true
  };
  let buffer;
  return {
    tokenize: tokenizeFrontmatter,
    concrete: true
  };
  function tokenizeFrontmatter(effects, ok2, nok) {
    const self = this;
    return start;
    function start(code2) {
      const position2 = self.now();
      if (position2.column !== 1 || !anywhere && position2.line !== 1) {
        return nok(code2);
      }
      effects.enter(name);
      buffer = fence(matter2, "open");
      return effects.attempt(fenceConstruct, afterOpeningFence, nok)(code2);
    }
    function afterOpeningFence(code2) {
      buffer = fence(matter2, "close");
      return lineEnd(code2);
    }
    function lineStart(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return lineEnd(code2);
      }
      effects.enter(valueType);
      return lineData(code2);
    }
    function lineData(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit(valueType);
        return lineEnd(code2);
      }
      effects.consume(code2);
      return lineData;
    }
    function lineEnd(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return effects.attempt(fenceConstruct, after, lineStart);
    }
    function after(code2) {
      effects.exit(name);
      return ok2(code2);
    }
  }
  function tokenizeFence(effects, ok2, nok) {
    let bufferIndex = 0;
    return start;
    function start(code2) {
      if (code2 === buffer.charCodeAt(bufferIndex)) {
        effects.enter(fenceType);
        effects.enter(sequenceType);
        return insideSequence(code2);
      }
      return nok(code2);
    }
    function insideSequence(code2) {
      if (bufferIndex === buffer.length) {
        effects.exit(sequenceType);
        if (markdownSpace(code2)) {
          effects.enter("whitespace");
          return insideWhitespace(code2);
        }
        return fenceEnd(code2);
      }
      if (code2 === buffer.charCodeAt(bufferIndex++)) {
        effects.consume(code2);
        return insideSequence;
      }
      return nok(code2);
    }
    function insideWhitespace(code2) {
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return insideWhitespace;
      }
      effects.exit("whitespace");
      return fenceEnd(code2);
    }
    function fenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit(fenceType);
        return ok2(code2);
      }
      return nok(code2);
    }
  }
}
function fence(matter2, prop) {
  return matter2.marker ? pick(matter2.marker, prop).repeat(3) : pick(matter2.fence, prop);
}
function pick(schema, prop) {
  return typeof schema === "string" ? schema : schema[prop];
}

// node_modules/mdast-util-frontmatter/index.js
function frontmatterFromMarkdown(options) {
  const settings = matters(options);
  const enter = {};
  const exit3 = {};
  let index2 = -1;
  while (++index2 < settings.length) {
    const matter2 = settings[index2];
    enter[matter2.type] = opener(matter2);
    exit3[matter2.type] = close;
    exit3[matter2.type + "Value"] = value;
  }
  return { enter, exit: exit3 };
}
function opener(matter2) {
  return open;
  function open(token) {
    this.enter({ type: matter2.type, value: "" }, token);
    this.buffer();
  }
}
function close(token) {
  const data = this.resume();
  this.exit(token).value = data.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
}
function value(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}

// main.ts
var import_obsidian = require("obsidian");

// SimpleText.ts
var import_antlr4ts = __toESM(require_antlr4ts());
var import_AbstractParseTreeVisitor = __toESM(require_AbstractParseTreeVisitor());

// grammar/SimpleTextParser.ts
var import_ATN = __toESM(require_ATN());
var import_ATNDeserializer = __toESM(require_ATNDeserializer());
var import_FailedPredicateException = __toESM(require_FailedPredicateException());
var import_NoViableAltException = __toESM(require_NoViableAltException());
var import_Parser = __toESM(require_Parser());
var import_ParserRuleContext = __toESM(require_ParserRuleContext());
var import_ParserATNSimulator = __toESM(require_ParserATNSimulator());
var import_RecognitionException = __toESM(require_RecognitionException());
var import_Token = __toESM(require_Token());
var import_VocabularyImpl = __toESM(require_VocabularyImpl());
var Utils = __toESM(require_Utils());
var _SimpleTextParser = class extends import_Parser.Parser {
  get vocabulary() {
    return _SimpleTextParser.VOCABULARY;
  }
  get grammarFileName() {
    return "SimpleText.g4";
  }
  get ruleNames() {
    return _SimpleTextParser.ruleNames;
  }
  get serializedATN() {
    return _SimpleTextParser._serializedATN;
  }
  createFailedPredicateException(predicate, message) {
    return new import_FailedPredicateException.FailedPredicateException(this, predicate, message);
  }
  constructor(input) {
    super(input);
    this._interp = new import_ParserATNSimulator.ParserATNSimulator(_SimpleTextParser._ATN, this);
  }
  paragraph() {
    let _localctx = new ParagraphContext(this._ctx, this.state);
    this.enterRule(_localctx, 0, _SimpleTextParser.RULE_paragraph);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 17;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
          {
            {
              this.state = 14;
              this.sentence();
            }
          }
          this.state = 19;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 20;
        this.match(_SimpleTextParser.EOF);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  sentence() {
    let _localctx = new SentenceContext(this._ctx, this.state);
    this.enterRule(_localctx, 2, _SimpleTextParser.RULE_sentence);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 23;
        this._errHandler.sync(this);
        _alt = 1;
        do {
          switch (_alt) {
            case 1:
              {
                {
                  this.state = 22;
                  this.proposition();
                }
              }
              break;
            default:
              throw new import_NoViableAltException.NoViableAltException(this);
          }
          this.state = 25;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 1, this._ctx);
        } while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER);
        this.state = 28;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.DOT | 1 << _SimpleTextParser.QUESTION_MARK | 1 << _SimpleTextParser.EXCLAMATION_MARK)) !== 0) {
          {
            this.state = 27;
            this.endPunctuation();
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  proposition() {
    let _localctx = new PropositionContext(this._ctx, this.state);
    this.enterRule(_localctx, 4, _SimpleTextParser.RULE_proposition);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 32;
        this._errHandler.sync(this);
        _alt = 1;
        do {
          switch (_alt) {
            case 1:
              {
                this.state = 32;
                this._errHandler.sync(this);
                switch (this._input.LA(1)) {
                  case _SimpleTextParser.Word:
                  case _SimpleTextParser.Smiley:
                  case _SimpleTextParser.Url:
                    {
                      this.state = 30;
                      this.word();
                    }
                    break;
                  case _SimpleTextParser.LPAREN:
                  case _SimpleTextParser.LACCOL:
                  case _SimpleTextParser.LBRACK:
                  case _SimpleTextParser.QUOTE:
                  case _SimpleTextParser.DQUOTE:
                    {
                      this.state = 31;
                      this.expression();
                    }
                    break;
                  default:
                    throw new import_NoViableAltException.NoViableAltException(this);
                }
              }
              break;
            default:
              throw new import_NoViableAltException.NoViableAltException(this);
          }
          this.state = 34;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 4, this._ctx);
        } while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER);
        this.state = 37;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.COLON | 1 << _SimpleTextParser.COMMA | 1 << _SimpleTextParser.SEMICOLON)) !== 0) {
          {
            this.state = 36;
            this.midPunctuation();
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  midPunctuation() {
    let _localctx = new MidPunctuationContext(this._ctx, this.state);
    this.enterRule(_localctx, 6, _SimpleTextParser.RULE_midPunctuation);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 39;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.COLON | 1 << _SimpleTextParser.COMMA | 1 << _SimpleTextParser.SEMICOLON)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  endPunctuation() {
    let _localctx = new EndPunctuationContext(this._ctx, this.state);
    this.enterRule(_localctx, 8, _SimpleTextParser.RULE_endPunctuation);
    let _la;
    try {
      this.state = 48;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SimpleTextParser.DOT:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 42;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
              {
                {
                  this.state = 41;
                  this.match(_SimpleTextParser.DOT);
                }
              }
              this.state = 44;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            } while (_la === _SimpleTextParser.DOT);
          }
          break;
        case _SimpleTextParser.QUESTION_MARK:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 46;
            this.match(_SimpleTextParser.QUESTION_MARK);
          }
          break;
        case _SimpleTextParser.EXCLAMATION_MARK:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 47;
            this.match(_SimpleTextParser.EXCLAMATION_MARK);
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  word() {
    let _localctx = new WordContext(this._ctx, this.state);
    this.enterRule(_localctx, 10, _SimpleTextParser.RULE_word);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 50;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  expression() {
    let _localctx = new ExpressionContext(this._ctx, this.state);
    this.enterRule(_localctx, 12, _SimpleTextParser.RULE_expression);
    let _la;
    try {
      let _alt;
      this.state = 92;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SimpleTextParser.LPAREN:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 52;
            this.match(_SimpleTextParser.LPAREN);
            this.state = 56;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
              {
                {
                  this.state = 53;
                  this.sentence();
                }
              }
              this.state = 58;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 59;
            this.match(_SimpleTextParser.RPAREN);
          }
          break;
        case _SimpleTextParser.QUOTE:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 60;
            this.match(_SimpleTextParser.QUOTE);
            this.state = 64;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
            while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 61;
                    this.sentence();
                  }
                }
              }
              this.state = 66;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
            }
            this.state = 67;
            this.match(_SimpleTextParser.QUOTE);
          }
          break;
        case _SimpleTextParser.DQUOTE:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 68;
            this.match(_SimpleTextParser.DQUOTE);
            this.state = 72;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 10, this._ctx);
            while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 69;
                    this.sentence();
                  }
                }
              }
              this.state = 74;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 10, this._ctx);
            }
            this.state = 75;
            this.match(_SimpleTextParser.DQUOTE);
          }
          break;
        case _SimpleTextParser.LBRACK:
          this.enterOuterAlt(_localctx, 4);
          {
            this.state = 76;
            this.match(_SimpleTextParser.LBRACK);
            this.state = 80;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
              {
                {
                  this.state = 77;
                  this.sentence();
                }
              }
              this.state = 82;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 83;
            this.match(_SimpleTextParser.RBRACK);
          }
          break;
        case _SimpleTextParser.LACCOL:
          this.enterOuterAlt(_localctx, 5);
          {
            this.state = 84;
            this.match(_SimpleTextParser.LACCOL);
            this.state = 88;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _SimpleTextParser.Word | 1 << _SimpleTextParser.Smiley | 1 << _SimpleTextParser.Url | 1 << _SimpleTextParser.LPAREN | 1 << _SimpleTextParser.LACCOL | 1 << _SimpleTextParser.LBRACK | 1 << _SimpleTextParser.QUOTE | 1 << _SimpleTextParser.DQUOTE)) !== 0) {
              {
                {
                  this.state = 85;
                  this.sentence();
                }
              }
              this.state = 90;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 91;
            this.match(_SimpleTextParser.RACCOL);
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  static get _ATN() {
    if (!_SimpleTextParser.__ATN) {
      _SimpleTextParser.__ATN = new import_ATNDeserializer.ATNDeserializer().deserialize(Utils.toCharArray(_SimpleTextParser._serializedATN));
    }
    return _SimpleTextParser.__ATN;
  }
};
var SimpleTextParser = _SimpleTextParser;
SimpleTextParser.Word = 1;
SimpleTextParser.Smiley = 2;
SimpleTextParser.Url = 3;
SimpleTextParser.DOT = 4;
SimpleTextParser.QUESTION_MARK = 5;
SimpleTextParser.EXCLAMATION_MARK = 6;
SimpleTextParser.LPAREN = 7;
SimpleTextParser.RPAREN = 8;
SimpleTextParser.LACCOL = 9;
SimpleTextParser.RACCOL = 10;
SimpleTextParser.LBRACK = 11;
SimpleTextParser.RBRACK = 12;
SimpleTextParser.QUOTE = 13;
SimpleTextParser.DQUOTE = 14;
SimpleTextParser.COLON = 15;
SimpleTextParser.COMMA = 16;
SimpleTextParser.SEMICOLON = 17;
SimpleTextParser.SMILEY = 18;
SimpleTextParser.WS = 19;
SimpleTextParser.RULE_paragraph = 0;
SimpleTextParser.RULE_sentence = 1;
SimpleTextParser.RULE_proposition = 2;
SimpleTextParser.RULE_midPunctuation = 3;
SimpleTextParser.RULE_endPunctuation = 4;
SimpleTextParser.RULE_word = 5;
SimpleTextParser.RULE_expression = 6;
SimpleTextParser.ruleNames = [
  "paragraph",
  "sentence",
  "proposition",
  "midPunctuation",
  "endPunctuation",
  "word",
  "expression"
];
SimpleTextParser._LITERAL_NAMES = [
  void 0,
  void 0,
  void 0,
  void 0,
  "'.'",
  "'?'",
  "'!'",
  "'('",
  "')'",
  "'{'",
  "'}'",
  "'['",
  "']'",
  void 0,
  `'"'`,
  "':'",
  "','",
  "';'"
];
SimpleTextParser._SYMBOLIC_NAMES = [
  void 0,
  "Word",
  "Smiley",
  "Url",
  "DOT",
  "QUESTION_MARK",
  "EXCLAMATION_MARK",
  "LPAREN",
  "RPAREN",
  "LACCOL",
  "RACCOL",
  "LBRACK",
  "RBRACK",
  "QUOTE",
  "DQUOTE",
  "COLON",
  "COMMA",
  "SEMICOLON",
  "SMILEY",
  "WS"
];
SimpleTextParser.VOCABULARY = new import_VocabularyImpl.VocabularyImpl(_SimpleTextParser._LITERAL_NAMES, _SimpleTextParser._SYMBOLIC_NAMES, []);
SimpleTextParser._serializedATN = `\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241a					\x07	\x07\b	\b\x07
\f\v
\r\x1B
#
\r$(
-
\r.3
\x07\x07\b\b\x07\b9
\b\f\b\b<\v\b\b\b\b\x07\bA
\b\f\b\bD\v\b\b\b\b\x07\bI
\b\f\b\bL\v\b\b\b\b\x07\bQ
\b\f\b\bT\v\b\b\b\b\x07\bY
\b\f\b\b\\\v\b\b\b_
\b\b	\b
\fk"\b)
2\f4^\x07\x1B\x1B\x1B
 #\f\x07!#\b" "!#$$"$%%'&(\b'&'((\x07)*	*	+-\x07,+-..,.//303\x07\x0713\x07\b2,20213\v45	5\r6:\x07	79879<:8:;;=<:=_\x07
>B\x07?A@?ADB@BCCEDBE_\x07FJ\x07GIHGILJHJKKMLJM_\x07NR\x07\rOQPOQTRPRSSUTRU_\x07VZ\x07\vWYXWY\\ZXZ[[]\\Z]_\x07\f^6^>^F^N^V_\x1B"$'.2:BJRZ^`;
var ParagraphContext = class extends import_ParserRuleContext.ParserRuleContext {
  EOF() {
    return this.getToken(SimpleTextParser.EOF, 0);
  }
  sentence(i) {
    if (i === void 0) {
      return this.getRuleContexts(SentenceContext);
    } else {
      return this.getRuleContext(i, SentenceContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_paragraph;
  }
  enterRule(listener) {
    if (listener.enterParagraph) {
      listener.enterParagraph(this);
    }
  }
  exitRule(listener) {
    if (listener.exitParagraph) {
      listener.exitParagraph(this);
    }
  }
  accept(visitor) {
    if (visitor.visitParagraph) {
      return visitor.visitParagraph(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var SentenceContext = class extends import_ParserRuleContext.ParserRuleContext {
  proposition(i) {
    if (i === void 0) {
      return this.getRuleContexts(PropositionContext);
    } else {
      return this.getRuleContext(i, PropositionContext);
    }
  }
  endPunctuation() {
    return this.tryGetRuleContext(0, EndPunctuationContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_sentence;
  }
  enterRule(listener) {
    if (listener.enterSentence) {
      listener.enterSentence(this);
    }
  }
  exitRule(listener) {
    if (listener.exitSentence) {
      listener.exitSentence(this);
    }
  }
  accept(visitor) {
    if (visitor.visitSentence) {
      return visitor.visitSentence(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var PropositionContext = class extends import_ParserRuleContext.ParserRuleContext {
  word(i) {
    if (i === void 0) {
      return this.getRuleContexts(WordContext);
    } else {
      return this.getRuleContext(i, WordContext);
    }
  }
  expression(i) {
    if (i === void 0) {
      return this.getRuleContexts(ExpressionContext);
    } else {
      return this.getRuleContext(i, ExpressionContext);
    }
  }
  midPunctuation() {
    return this.tryGetRuleContext(0, MidPunctuationContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_proposition;
  }
  enterRule(listener) {
    if (listener.enterProposition) {
      listener.enterProposition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitProposition) {
      listener.exitProposition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitProposition) {
      return visitor.visitProposition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var MidPunctuationContext = class extends import_ParserRuleContext.ParserRuleContext {
  COMMA() {
    return this.tryGetToken(SimpleTextParser.COMMA, 0);
  }
  COLON() {
    return this.tryGetToken(SimpleTextParser.COLON, 0);
  }
  SEMICOLON() {
    return this.tryGetToken(SimpleTextParser.SEMICOLON, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_midPunctuation;
  }
  enterRule(listener) {
    if (listener.enterMidPunctuation) {
      listener.enterMidPunctuation(this);
    }
  }
  exitRule(listener) {
    if (listener.exitMidPunctuation) {
      listener.exitMidPunctuation(this);
    }
  }
  accept(visitor) {
    if (visitor.visitMidPunctuation) {
      return visitor.visitMidPunctuation(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var EndPunctuationContext = class extends import_ParserRuleContext.ParserRuleContext {
  DOT(i) {
    if (i === void 0) {
      return this.getTokens(SimpleTextParser.DOT);
    } else {
      return this.getToken(SimpleTextParser.DOT, i);
    }
  }
  QUESTION_MARK() {
    return this.tryGetToken(SimpleTextParser.QUESTION_MARK, 0);
  }
  EXCLAMATION_MARK() {
    return this.tryGetToken(SimpleTextParser.EXCLAMATION_MARK, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_endPunctuation;
  }
  enterRule(listener) {
    if (listener.enterEndPunctuation) {
      listener.enterEndPunctuation(this);
    }
  }
  exitRule(listener) {
    if (listener.exitEndPunctuation) {
      listener.exitEndPunctuation(this);
    }
  }
  accept(visitor) {
    if (visitor.visitEndPunctuation) {
      return visitor.visitEndPunctuation(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var WordContext = class extends import_ParserRuleContext.ParserRuleContext {
  Word() {
    return this.tryGetToken(SimpleTextParser.Word, 0);
  }
  Smiley() {
    return this.tryGetToken(SimpleTextParser.Smiley, 0);
  }
  Url() {
    return this.tryGetToken(SimpleTextParser.Url, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_word;
  }
  enterRule(listener) {
    if (listener.enterWord) {
      listener.enterWord(this);
    }
  }
  exitRule(listener) {
    if (listener.exitWord) {
      listener.exitWord(this);
    }
  }
  accept(visitor) {
    if (visitor.visitWord) {
      return visitor.visitWord(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {
  LPAREN() {
    return this.tryGetToken(SimpleTextParser.LPAREN, 0);
  }
  RPAREN() {
    return this.tryGetToken(SimpleTextParser.RPAREN, 0);
  }
  sentence(i) {
    if (i === void 0) {
      return this.getRuleContexts(SentenceContext);
    } else {
      return this.getRuleContext(i, SentenceContext);
    }
  }
  QUOTE(i) {
    if (i === void 0) {
      return this.getTokens(SimpleTextParser.QUOTE);
    } else {
      return this.getToken(SimpleTextParser.QUOTE, i);
    }
  }
  DQUOTE(i) {
    if (i === void 0) {
      return this.getTokens(SimpleTextParser.DQUOTE);
    } else {
      return this.getToken(SimpleTextParser.DQUOTE, i);
    }
  }
  LBRACK() {
    return this.tryGetToken(SimpleTextParser.LBRACK, 0);
  }
  RBRACK() {
    return this.tryGetToken(SimpleTextParser.RBRACK, 0);
  }
  LACCOL() {
    return this.tryGetToken(SimpleTextParser.LACCOL, 0);
  }
  RACCOL() {
    return this.tryGetToken(SimpleTextParser.RACCOL, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SimpleTextParser.RULE_expression;
  }
  enterRule(listener) {
    if (listener.enterExpression) {
      listener.enterExpression(this);
    }
  }
  exitRule(listener) {
    if (listener.exitExpression) {
      listener.exitExpression(this);
    }
  }
  accept(visitor) {
    if (visitor.visitExpression) {
      return visitor.visitExpression(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};

// grammar/SimpleTextLexer.ts
var import_ATNDeserializer2 = __toESM(require_ATNDeserializer());
var import_Lexer = __toESM(require_Lexer());
var import_LexerATNSimulator = __toESM(require_LexerATNSimulator());
var import_VocabularyImpl2 = __toESM(require_VocabularyImpl());
var Utils2 = __toESM(require_Utils());
var _SimpleTextLexer = class extends import_Lexer.Lexer {
  get vocabulary() {
    return _SimpleTextLexer.VOCABULARY;
  }
  constructor(input) {
    super(input);
    this._interp = new import_LexerATNSimulator.LexerATNSimulator(_SimpleTextLexer._ATN, this);
  }
  get grammarFileName() {
    return "SimpleText.g4";
  }
  get ruleNames() {
    return _SimpleTextLexer.ruleNames;
  }
  get serializedATN() {
    return _SimpleTextLexer._serializedATN;
  }
  get channelNames() {
    return _SimpleTextLexer.channelNames;
  }
  get modeNames() {
    return _SimpleTextLexer.modeNames;
  }
  static get _ATN() {
    if (!_SimpleTextLexer.__ATN) {
      _SimpleTextLexer.__ATN = new import_ATNDeserializer2.ATNDeserializer().deserialize(Utils2.toCharArray(_SimpleTextLexer._serializedATN));
    }
    return _SimpleTextLexer.__ATN;
  }
};
var SimpleTextLexer = _SimpleTextLexer;
SimpleTextLexer.Word = 1;
SimpleTextLexer.Smiley = 2;
SimpleTextLexer.Url = 3;
SimpleTextLexer.DOT = 4;
SimpleTextLexer.QUESTION_MARK = 5;
SimpleTextLexer.EXCLAMATION_MARK = 6;
SimpleTextLexer.LPAREN = 7;
SimpleTextLexer.RPAREN = 8;
SimpleTextLexer.LACCOL = 9;
SimpleTextLexer.RACCOL = 10;
SimpleTextLexer.LBRACK = 11;
SimpleTextLexer.RBRACK = 12;
SimpleTextLexer.QUOTE = 13;
SimpleTextLexer.DQUOTE = 14;
SimpleTextLexer.COLON = 15;
SimpleTextLexer.COMMA = 16;
SimpleTextLexer.SEMICOLON = 17;
SimpleTextLexer.SMILEY = 18;
SimpleTextLexer.WS = 19;
SimpleTextLexer.channelNames = [
  "DEFAULT_TOKEN_CHANNEL",
  "HIDDEN"
];
SimpleTextLexer.modeNames = [
  "DEFAULT_MODE"
];
SimpleTextLexer.ruleNames = [
  "Word",
  "Smiley",
  "Url",
  "DOT",
  "QUESTION_MARK",
  "EXCLAMATION_MARK",
  "LPAREN",
  "RPAREN",
  "LACCOL",
  "RACCOL",
  "LBRACK",
  "RBRACK",
  "QUOTE",
  "DQUOTE",
  "COLON",
  "COMMA",
  "SEMICOLON",
  "SMILEY",
  "SPACE",
  "WS"
];
SimpleTextLexer._LITERAL_NAMES = [
  void 0,
  void 0,
  void 0,
  void 0,
  "'.'",
  "'?'",
  "'!'",
  "'('",
  "')'",
  "'{'",
  "'}'",
  "'['",
  "']'",
  void 0,
  `'"'`,
  "':'",
  "','",
  "';'"
];
SimpleTextLexer._SYMBOLIC_NAMES = [
  void 0,
  "Word",
  "Smiley",
  "Url",
  "DOT",
  "QUESTION_MARK",
  "EXCLAMATION_MARK",
  "LPAREN",
  "RPAREN",
  "LACCOL",
  "RACCOL",
  "LBRACK",
  "RBRACK",
  "QUOTE",
  "DQUOTE",
  "COLON",
  "COMMA",
  "SEMICOLON",
  "SMILEY",
  "WS"
];
SimpleTextLexer.VOCABULARY = new import_VocabularyImpl2.VocabularyImpl(_SimpleTextLexer._LITERAL_NAMES, _SimpleTextLexer._SYMBOLIC_NAMES, []);
SimpleTextLexer._serializedATN = `\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\x7F\b					\x07	\x07\b	\b			
	
\v	\v\f	\f\r	\r								\x07-
\f0\v3
\r4?
G
\rH\x07\x07\b\b		

\v\v\f\f\r\r\`
l
u
z
\r{\x07	\v\x07\r\b	
\v\f\r\x1B!#%')	\v\f"$*+..00==AA]]__}}\x7F\x7F\v\f"$)+..00<=AA]]__}}\x7F\x7F2;C\\c|\x07%%''-]__c|<=*+FFrr~~\v\f""\x85\x07	\v\r\x1B!#%).6\x078	J\vL\rNPRTVXZ\x1B_ac!e#g%t'v)y+-
,+-0.,.//20.13
21344245567%789\x07j9:\x07v:;\x07v;<\x07r<>=?\x07u>=>??@@A\x07<AB\x071BC\x071CDDF	EG	FEGHHFHII\bJK\x070K
LM\x07AM\fNO\x07#OPQ\x07*QRS\x07+STU\x07}UVW\x07\x7FWXY\x07]YZ[\x07_[\\]\x07"]\`\x07)^\`\x07)_\\_^\`ab\x07$bcd\x07<d ef\x07.f"gh\x07=h$ik	jl\x07/kjkllmmn	\x07nu'op\x07:pq\x07/qr\x07+rssu'titou&vw	\bw(xz'yxz{{y{||}}~\b~*\v.4>H_kt{\b`;

// SimpleText.ts
var BuildASTVisitor = class extends import_AbstractParseTreeVisitor.AbstractParseTreeVisitor {
  defaultResult() {
    return {
      type: "default"
    };
  }
  visitParagraph(ctx) {
    return this.processGroup(ctx, "paragraph");
  }
  visitSentence(ctx) {
    return this.processGroup(ctx, "sentence");
  }
  visitProposition(ctx) {
    return this.processGroup(ctx, "proposition");
  }
  visitExpression(ctx) {
    return this.processGroup(ctx, "expression");
  }
  processGroup(ctx, type) {
    var _a;
    const children = (_a = ctx.children) == null ? void 0 : _a.map((child) => this.visit(child));
    return this.createNode(ctx, type, children != null ? children : []);
  }
  visitWord(ctx) {
    return this.processTerminal(ctx, "word");
  }
  visitEndPunctuation(ctx) {
    return this.processTerminal(ctx, "punctuation");
  }
  visitMidPunctuation(ctx) {
    return this.processTerminal(ctx, "mid-punctuation");
  }
  processTerminal(ctx, type) {
    return {
      type,
      start: {
        line: ctx.start.line,
        column: ctx.start.charPositionInLine + 1
      },
      end: {
        line: ctx.start.line,
        column: ctx.start.charPositionInLine + ctx.text.length
      },
      text: ctx.text,
      children: []
    };
  }
  createNode(ctx, type, children) {
    var _a;
    const endToken = (_a = ctx.stop) != null ? _a : ctx.start;
    return {
      type,
      start: { line: ctx.start.line, column: 1 + ctx.start.charPositionInLine },
      end: { line: endToken.line, column: endToken.charPositionInLine },
      text: ctx.text,
      children
    };
  }
};
function fixupAst(node) {
  var _a, _b;
  (_a = node.children) == null ? void 0 : _a.forEach((child) => fixupAst(child));
  const lastChild = node.children ? node.children[node.children.length - 1] : void 0;
  node.end = (_b = lastChild == null ? void 0 : lastChild.end) != null ? _b : node.end;
}
var SimpleText;
((SimpleText2) => {
  function parse3(text4) {
    const inputStream = new import_antlr4ts.ANTLRInputStream(text4);
    const lexer = new SimpleTextLexer(inputStream);
    const tokenStream = new import_antlr4ts.CommonTokenStream(lexer);
    const parser = new SimpleTextParser(tokenStream);
    const tree = parser.paragraph();
    const builder = new BuildASTVisitor();
    const ast = builder.visit(tree);
    fixupAst(ast);
    return ast;
  }
  SimpleText2.parse = parse3;
})(SimpleText || (SimpleText = {}));

// main.ts
var DEFAULT_SETTINGS = {
  convertSvgToBitmap: true
};
var Pos = class {
  constructor(line, column) {
    this.line = line;
    this.column = column;
  }
  static fromEditorPosition(pos) {
    return new Pos(pos.line + 1, pos.ch + 1);
  }
  toEditorPosition() {
    return {
      line: this.line - 1,
      ch: this.column - 1
    };
  }
  static fromPoint(pos) {
    return new Pos(pos.line, pos.column);
  }
  compareTo(other) {
    if (this.line < other.line) {
      return -1;
    }
    if (this.line > other.line) {
      return 1;
    }
    if (this.column < other.column) {
      return -1;
    }
    if (this.column > other.column) {
      return 1;
    }
    return 0;
  }
  equals(other) {
    return this.compareTo(other) === 0;
  }
  inRange(start, end) {
    return this.compareTo(start) >= 0 && this.compareTo(end) <= 0;
  }
  static order(a, b) {
    if (a.compareTo(b) <= 0) {
      return {
        start: a,
        end: b
      };
    } else {
      return {
        start: b,
        end: a
      };
    }
  }
  minus(other) {
    return new Pos(this.line - other.line, this.column - other.column);
  }
  plus(other) {
    return new Pos(this.line + other.line, this.column - other.column);
  }
};
var Mdast = class {
  static inNode(node, pos) {
    if (!node.position) {
      return false;
    }
    return pos.inRange(Pos.fromPoint(node.position.start), Pos.fromPoint(node.position.end));
  }
  static fillsNode(node, { start, end }) {
    if (!node.position) {
      return false;
    }
    return Pos.fromPoint(node.position.start).compareTo(start) === 0 && Pos.fromPoint(node.position.end).compareTo(end) === 0;
  }
  static findNodeWithRange(root, { start, end }) {
    var _a;
    let currentParent = root;
    const nodeStack = [];
    while (true) {
      nodeStack.push(currentParent);
      const child = (_a = currentParent.children) == null ? void 0 : _a.find((node) => this.inNode(node, start) && this.inNode(node, end));
      if (!child) {
        break;
      }
      if ("children" in child) {
        currentParent = child;
      } else {
        nodeStack.push(child);
        break;
      }
    }
    const lastNode = nodeStack[nodeStack.length - 1];
    let sameNodeIndex;
    for (sameNodeIndex = nodeStack.length - 2; sameNodeIndex >= 0; --sameNodeIndex) {
      const parentNode = nodeStack[sameNodeIndex];
      if (Pos.fromPoint(parentNode.position.start).equals(Pos.fromPoint(lastNode.position.start)) && Pos.fromPoint(parentNode.position.end).equals(Pos.fromPoint(lastNode.position.end))) {
      } else {
        break;
      }
    }
    return {
      node: { ...nodeStack[sameNodeIndex + 1], parent: nodeStack[Math.max(0, sameNodeIndex)] },
      ancestors: nodeStack.slice(0, Math.max(0, sameNodeIndex + 1))
    };
  }
};
function isInParagraph(ancestors) {
  for (let i = ancestors.length - 1; i >= 0; --i) {
    if (ancestors[i].type === "paragraph") {
      return true;
    }
    if (ancestors[i].type === "section") {
      return false;
    }
  }
  return false;
}
var Antlr = class {
  static inNode(node, pos) {
    var _a, _b;
    if (((_a = node.start) == null ? void 0 : _a.line) === void 0 || ((_b = node.end) == null ? void 0 : _b.line) === void 0) {
      return false;
    }
    return pos.inRange(Pos.fromPoint(node.start), Pos.fromPoint(node.end));
  }
  static fillsNode(node, { start, end }) {
    var _a, _b;
    if (((_a = node.start) == null ? void 0 : _a.line) === void 0 || ((_b = node.end) == null ? void 0 : _b.line) === void 0) {
      return false;
    }
    return Pos.fromPoint(node.start).compareTo(start) === 0 && Pos.fromPoint(node.end).compareTo(end) === 0;
  }
  static findNodeWithRange(root, { start, end }) {
    var _a;
    let currentParent = root;
    const nodeStack = [];
    while (true) {
      console.log(`trying node`, currentParent);
      nodeStack.push(currentParent);
      const child = (_a = currentParent.children) == null ? void 0 : _a.find((node) => this.inNode(node, start) && this.inNode(node, end));
      if (!child) {
        console.log(`no matching child`);
        break;
      }
      if ("children" in child) {
        console.log(`child with children`);
        currentParent = child;
      } else {
        console.log(`child with no children`);
        nodeStack.push(child);
        break;
      }
    }
    const lastNode = nodeStack[nodeStack.length - 1];
    let sameNodeIndex;
    for (sameNodeIndex = nodeStack.length - 2; sameNodeIndex >= 0; --sameNodeIndex) {
      const parentNode = nodeStack[sameNodeIndex];
      if (Pos.fromPoint(parentNode.start).equals(Pos.fromPoint(lastNode.start)) && Pos.fromPoint(parentNode.end).equals(Pos.fromPoint(lastNode.end))) {
      } else {
        break;
      }
    }
    return {
      node: nodeStack[sameNodeIndex + 1],
      ancestors: nodeStack.slice(0, Math.max(0, sameNodeIndex + 1))
    };
  }
};
function nestSections(tree) {
  for (let depth = 6; depth >= 1; --depth) {
    let currentSection = void 0;
    for (let i = 0; i < tree.children.length; ++i) {
      if (tree.children[i].type === "heading") {
        let heading = tree.children[i];
        if (heading.depth === depth) {
          const sectionContent = {
            type: "section-content",
            children: [],
            position: {
              start: Pos.fromPoint(heading.position.end),
              end: Pos.fromPoint(heading.position.end)
            }
          };
          currentSection = {
            type: "section",
            children: [heading, sectionContent],
            position: {
              start: Pos.fromPoint(heading.position.start),
              end: Pos.fromPoint(heading.position.end)
            }
          };
          tree.children[i] = currentSection;
        } else if (heading.depth < depth) {
          currentSection = void 0;
        }
      } else {
        if (currentSection) {
          currentSection.children[1].children.push(tree.children[i]);
          let end = Pos.fromPoint(tree.children[i].position.end);
          currentSection.position.end = end;
          currentSection.children[1].position.end = end;
          tree.children[i] = void 0;
        }
      }
    }
    tree.children = tree.children.filter((node) => !!node);
  }
}
var CopyDocumentAsHTMLPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "grow-selection",
      name: "Grow selection",
      editorCallback: async (editor, view) => {
        const tree = fromMarkdown(view.data, {
          extensions: [
            math(),
            gfmTaskListItem,
            gfmTable,
            gfmStrikethrough(),
            gfmFootnote(),
            gfmAutolinkLiteral,
            gfm(),
            frontmatter(["yaml"])
          ],
          mdastExtensions: [
            mathFromMarkdown(),
            gfmTaskListItemFromMarkdown,
            gfmTableFromMarkdown,
            gfmStrikethroughFromMarkdown,
            gfmFootnoteFromMarkdown(),
            gfmAutolinkLiteralFromMarkdown,
            gfmFromMarkdown(),
            frontmatterFromMarkdown(["yaml"])
          ]
        });
        nestSections(tree);
        const { head, anchor } = editor.listSelections()[0];
        const range = Pos.order(Pos.fromEditorPosition(head), Pos.fromEditorPosition(anchor));
        console.log("selection start", range.start);
        console.log("selection end", range.end);
        let result = Mdast.findNodeWithRange(tree, range);
        let nodeWithSelection = result.node;
        console.log(result.ancestors.map((a) => a.type));
        if (nodeWithSelection.type === "paragraph" && !Mdast.fillsNode(nodeWithSelection, range) || isInParagraph(result.ancestors)) {
          let paragraphNode = nodeWithSelection;
          for (let i = result.ancestors.length - 1; i >= 0; --i) {
            if (result.ancestors[i].type === "paragraph") {
              paragraphNode = result.ancestors[i];
            }
          }
          const paragraphRange = {
            start: paragraphNode.position.start,
            end: paragraphNode.position.end
          };
          console.log("==================== Using sub-parser ==================== ");
          console.log("paragraph start", paragraphRange.start);
          console.log("paragraph end", paragraphRange.end);
          const text4 = view.data.substring(paragraphRange.start.offset, paragraphRange.end.offset);
          console.log(text4);
          const tree2 = SimpleText.parse(text4);
          console.log(tree2);
          const mappedSelection = {
            start: range.start.minus(Pos.fromPoint(paragraphRange.start)),
            end: range.end.minus(Pos.fromPoint(paragraphRange.start))
          };
          mappedSelection.start.line++;
          mappedSelection.end.line++;
          mappedSelection.start.column++;
          mappedSelection.end.column++;
          console.log(`mapped selection:`, mappedSelection);
          let antlrTree = Antlr.findNodeWithRange(tree2, mappedSelection);
          console.log("antlr result node", antlrTree);
          let textNode = antlrTree.node;
          if (Antlr.fillsNode(nodeWithSelection, range)) {
            console.log("selection already fills the node, growing !");
            textNode = antlrTree.ancestors[antlrTree.ancestors.length - 1];
          }
          console.log(`selecting`, textNode);
          console.log(`selecting text ${textNode.text}`);
          console.log("new selection start", textNode.start);
          console.log("new selection end", textNode.end);
          const remappedSelection = {
            start: {
              line: paragraphRange.start.line - 1 + textNode.start.line - 1,
              ch: paragraphRange.start.column - 1 + textNode.start.column - 1
            },
            end: {
              line: paragraphRange.start.line - 1 + textNode.end.line - 1,
              ch: paragraphRange.start.column - 1 + textNode.end.column
            }
          };
          console.log("mapped selection start", remappedSelection.start);
          console.log("mapped selection end", remappedSelection.end);
          editor.setSelection(remappedSelection.start, remappedSelection.end);
        } else {
          if (Mdast.fillsNode(nodeWithSelection, range) && nodeWithSelection.parent) {
            console.log("node is filled, selecting parent");
            nodeWithSelection = nodeWithSelection.parent;
          }
          console.log(`filling node of type ${nodeWithSelection.type}`);
          editor.setSelection(Pos.fromPoint(nodeWithSelection.position.start).toEditorPosition(), Pos.fromPoint(nodeWithSelection.position.end).toEditorPosition());
        }
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2Zvcm1hdC9mb3JtYXQuanMiLCAic3JjL0FOVExSRXJyb3JMaXN0ZW5lci50cyIsICJzcmMvQU5UTFJFcnJvclN0cmF0ZWd5LnRzIiwgInNyYy9EZWNvcmF0b3JzLnRzIiwgInNyYy9JbnRTdHJlYW0udHMiLCAic3JjL0FOVExSSW5wdXRTdHJlYW0udHMiLCAic3JjL2F0bi9BVE5TdGF0ZS50cyIsICJzcmMvYXRuL0FUTlN0YXRlVHlwZS50cyIsICJzcmMvUmVjb2duaXRpb25FeGNlcHRpb24udHMiLCAic3JjL2F0bi9UcmFuc2l0aW9uLnRzIiwgInNyYy9hdG4vQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uLnRzIiwgInNyYy9taXNjL011cm11ckhhc2gudHMiLCAic3JjL21pc2MvT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLnRzIiwgInNyYy9taXNjL0RlZmF1bHRFcXVhbGl0eUNvbXBhcmF0b3IudHMiLCAic3JjL21pc2MvQXJyYXkyREhhc2hTZXQudHMiLCAic3JjL21pc2MvQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IudHMiLCAic3JjL21pc2MvVXRpbHMudHMiLCAic3JjL2F0bi9TZW1hbnRpY0NvbnRleHQudHMiLCAic3JjL2F0bi9QcmVkaWNhdGVUcmFuc2l0aW9uLnRzIiwgInNyYy9GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24udHMiLCAic3JjL0lucHV0TWlzbWF0Y2hFeGNlcHRpb24udHMiLCAic3JjL21pc2MvQXJyYXlzLnRzIiwgInNyYy9taXNjL0ludGVnZXJMaXN0LnRzIiwgInNyYy9taXNjL0ludGVydmFsLnRzIiwgInNyYy9Ub2tlbi50cyIsICJzcmMvQ29tbW9uVG9rZW4udHMiLCAic3JjL0NvbW1vblRva2VuRmFjdG9yeS50cyIsICJzcmMvbWlzYy9JbnRlZ2VyU3RhY2sudHMiLCAic3JjL2RmYS9BY2NlcHRTdGF0ZUluZm8udHMiLCAic3JjL21pc2MvQXJyYXkyREhhc2hNYXAudHMiLCAic3JjL2F0bi9EZWNpc2lvblN0YXRlLnRzIiwgInNyYy9hdG4vUHJlZGljdGlvbkNvbnRleHRDYWNoZS50cyIsICJzcmMvYXRuL1ByZWRpY3Rpb25Db250ZXh0LnRzIiwgInNyYy9hdG4vQVROQ29uZmlnLnRzIiwgInNyYy9taXNjL0JpdFNldC50cyIsICJzcmMvYXRuL0FUTkNvbmZpZ1NldC50cyIsICJzcmMvZGZhL0RGQVN0YXRlLnRzIiwgInNyYy9hdG4vQVROU2ltdWxhdG9yLnRzIiwgInNyYy9Db25zb2xlRXJyb3JMaXN0ZW5lci50cyIsICJzcmMvUHJveHlFcnJvckxpc3RlbmVyLnRzIiwgInNyYy9SZWNvZ25pemVyLnRzIiwgInNyYy9Wb2NhYnVsYXJ5SW1wbC50cyIsICJzcmMvZGZhL0RGQVNlcmlhbGl6ZXIudHMiLCAic3JjL2RmYS9MZXhlckRGQVNlcmlhbGl6ZXIudHMiLCAic3JjL2F0bi9TdGFyTG9vcEVudHJ5U3RhdGUudHMiLCAic3JjL2RmYS9ERkEudHMiLCAic3JjL2F0bi9CYXNpY1N0YXRlLnRzIiwgInNyYy9hdG4vSW52YWxpZFN0YXRlLnRzIiwgInNyYy9hdG4vU2V0VHJhbnNpdGlvbi50cyIsICJzcmMvYXRuL05vdFNldFRyYW5zaXRpb24udHMiLCAic3JjL2F0bi9SdWxlU3RvcFN0YXRlLnRzIiwgInNyYy9hdG4vUnVsZVRyYW5zaXRpb24udHMiLCAic3JjL2F0bi9XaWxkY2FyZFRyYW5zaXRpb24udHMiLCAic3JjL2F0bi9MTDFBbmFseXplci50cyIsICJzcmMvYXRuL0FUTi50cyIsICJzcmMvYXRuL0xleGVySW5kZXhlZEN1c3RvbUFjdGlvbi50cyIsICJzcmMvYXRuL0xleGVyQWN0aW9uRXhlY3V0b3IudHMiLCAic3JjL0xleGVyTm9WaWFibGVBbHRFeGNlcHRpb24udHMiLCAic3JjL2F0bi9PcmRlcmVkQVROQ29uZmlnU2V0LnRzIiwgInNyYy9hdG4vTGV4ZXJBVE5TaW11bGF0b3IudHMiLCAic3JjL0xleGVyLnRzIiwgInNyYy9taXNjL0ludGVydmFsU2V0LnRzIiwgInNyYy9hdG4vQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy50cyIsICJzcmMvYXRuL0FjdGlvblRyYW5zaXRpb24udHMiLCAic3JjL2F0bi9BdG9tVHJhbnNpdGlvbi50cyIsICJzcmMvYXRuL0Jsb2NrU3RhcnRTdGF0ZS50cyIsICJzcmMvYXRuL0Jhc2ljQmxvY2tTdGFydFN0YXRlLnRzIiwgInNyYy9hdG4vQmxvY2tFbmRTdGF0ZS50cyIsICJzcmMvYXRuL0Vwc2lsb25UcmFuc2l0aW9uLnRzIiwgInNyYy9hdG4vTGV4ZXJDaGFubmVsQWN0aW9uLnRzIiwgInNyYy9hdG4vTGV4ZXJDdXN0b21BY3Rpb24udHMiLCAic3JjL2F0bi9MZXhlck1vZGVBY3Rpb24udHMiLCAic3JjL2F0bi9MZXhlck1vcmVBY3Rpb24udHMiLCAic3JjL2F0bi9MZXhlclBvcE1vZGVBY3Rpb24udHMiLCAic3JjL2F0bi9MZXhlclB1c2hNb2RlQWN0aW9uLnRzIiwgInNyYy9hdG4vTGV4ZXJTa2lwQWN0aW9uLnRzIiwgInNyYy9hdG4vTGV4ZXJUeXBlQWN0aW9uLnRzIiwgInNyYy9hdG4vTG9vcEVuZFN0YXRlLnRzIiwgInNyYy9hdG4vQ29uZmxpY3RJbmZvLnRzIiwgInNyYy90cmVlL1Rlcm1pbmFsTm9kZS50cyIsICJzcmMvdHJlZS9FcnJvck5vZGUudHMiLCAic3JjL3RyZWUvUnVsZU5vZGUudHMiLCAic3JjL3RyZWUvVHJlZXMudHMiLCAic3JjL1J1bGVDb250ZXh0LnRzIiwgInNyYy9QYXJzZXJSdWxlQ29udGV4dC50cyIsICJzcmMvYXRuL1ByZWRpY3Rpb25Nb2RlLnRzIiwgInNyYy9hdG4vU2ltdWxhdG9yU3RhdGUudHMiLCAic3JjL2F0bi9QYXJzZXJBVE5TaW11bGF0b3IudHMiLCAic3JjL2F0bi9QbHVzQmxvY2tTdGFydFN0YXRlLnRzIiwgInNyYy9hdG4vUGx1c0xvb3BiYWNrU3RhdGUudHMiLCAic3JjL2F0bi9QcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbi50cyIsICJzcmMvYXRuL1JhbmdlVHJhbnNpdGlvbi50cyIsICJzcmMvYXRuL1J1bGVTdGFydFN0YXRlLnRzIiwgInNyYy9hdG4vU3RhckJsb2NrU3RhcnRTdGF0ZS50cyIsICJzcmMvYXRuL1N0YXJMb29wYmFja1N0YXRlLnRzIiwgInNyYy9hdG4vVG9rZW5zU3RhcnRTdGF0ZS50cyIsICJzcmMvbWlzYy9VVUlELnRzIiwgInNyYy9hdG4vQVRORGVzZXJpYWxpemVyLnRzIiwgInNyYy9hdG4vUGFyc2VJbmZvLnRzIiwgInNyYy9Qcm94eVBhcnNlckVycm9yTGlzdGVuZXIudHMiLCAic3JjL21pc2MvQ2hhcmFjdGVyLnRzIiwgInNyYy9Db2RlUG9pbnRCdWZmZXIudHMiLCAic3JjL0NvZGVQb2ludENoYXJTdHJlYW0udHMiLCAic3JjL0NoYXJTdHJlYW1zLnRzIiwgInNyYy9CdWZmZXJlZFRva2VuU3RyZWFtLnRzIiwgInNyYy9Db21tb25Ub2tlblN0cmVhbS50cyIsICJzcmMvTGlzdFRva2VuU291cmNlLnRzIiwgInNyYy9taXNjL011bHRpTWFwLnRzIiwgInNyYy9taXNjL1BhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uLnRzIiwgInNyYy9JbnRlcnByZXRlclJ1bGVDb250ZXh0LnRzIiwgInNyYy9QYXJzZXJJbnRlcnByZXRlci50cyIsICJzcmMvdHJlZS9wYXR0ZXJuL1BhcnNlVHJlZU1hdGNoLnRzIiwgInNyYy90cmVlL3hwYXRoL1hQYXRoTGV4ZXIudHMiLCAic3JjL3RyZWUveHBhdGgvWFBhdGhMZXhlckVycm9yTGlzdGVuZXIudHMiLCAic3JjL3RyZWUveHBhdGgvWFBhdGhFbGVtZW50LnRzIiwgInNyYy90cmVlL3hwYXRoL1hQYXRoUnVsZUFueXdoZXJlRWxlbWVudC50cyIsICJzcmMvdHJlZS94cGF0aC9YUGF0aFJ1bGVFbGVtZW50LnRzIiwgInNyYy90cmVlL3hwYXRoL1hQYXRoVG9rZW5Bbnl3aGVyZUVsZW1lbnQudHMiLCAic3JjL3RyZWUveHBhdGgvWFBhdGhUb2tlbkVsZW1lbnQudHMiLCAic3JjL3RyZWUveHBhdGgvWFBhdGhXaWxkY2FyZEFueXdoZXJlRWxlbWVudC50cyIsICJzcmMvdHJlZS94cGF0aC9YUGF0aFdpbGRjYXJkRWxlbWVudC50cyIsICJzcmMvdHJlZS94cGF0aC9YUGF0aC50cyIsICJzcmMvdHJlZS9wYXR0ZXJuL1BhcnNlVHJlZVBhdHRlcm4udHMiLCAic3JjL3RyZWUvcGF0dGVybi9SdWxlVGFnVG9rZW4udHMiLCAic3JjL3RyZWUvcGF0dGVybi9DaHVuay50cyIsICJzcmMvdHJlZS9wYXR0ZXJuL1RhZ0NodW5rLnRzIiwgInNyYy90cmVlL3BhdHRlcm4vVGV4dENodW5rLnRzIiwgInNyYy90cmVlL3BhdHRlcm4vVG9rZW5UYWdUb2tlbi50cyIsICJzcmMvdHJlZS9wYXR0ZXJuL1BhcnNlVHJlZVBhdHRlcm5NYXRjaGVyLnRzIiwgInNyYy9hdG4vRGVjaXNpb25FdmVudEluZm8udHMiLCAic3JjL2F0bi9BbWJpZ3VpdHlJbmZvLnRzIiwgInNyYy9hdG4vQ29udGV4dFNlbnNpdGl2aXR5SW5mby50cyIsICJzcmMvYXRuL0RlY2lzaW9uSW5mby50cyIsICJzcmMvYXRuL0Vycm9ySW5mby50cyIsICJzcmMvYXRuL0xvb2thaGVhZEV2ZW50SW5mby50cyIsICJzcmMvYXRuL1ByZWRpY2F0ZUV2YWxJbmZvLnRzIiwgInNyYy9hdG4vUHJvZmlsaW5nQVROU2ltdWxhdG9yLnRzIiwgInNyYy9QYXJzZXIudHMiLCAic3JjL05vVmlhYmxlQWx0RXhjZXB0aW9uLnRzIiwgInNyYy9EZWZhdWx0RXJyb3JTdHJhdGVneS50cyIsICJzcmMvQmFpbEVycm9yU3RyYXRlZ3kudHMiLCAic3JjL0NoYXJTdHJlYW0udHMiLCAic3JjL0RlcGVuZGVudHMudHMiLCAic3JjL0RpYWdub3N0aWNFcnJvckxpc3RlbmVyLnRzIiwgInNyYy9MZXhlckludGVycHJldGVyLnRzIiwgInNyYy9QYXJzZXJFcnJvckxpc3RlbmVyLnRzIiwgInNyYy9SdWxlQ29udGV4dFdpdGhBbHROdW0udHMiLCAic3JjL1J1bGVEZXBlbmRlbmN5LnRzIiwgInNyYy9SdWxlVmVyc2lvbi50cyIsICJzcmMvVG9rZW5GYWN0b3J5LnRzIiwgInNyYy9Ub2tlblNvdXJjZS50cyIsICJzcmMvVG9rZW5TdHJlYW0udHMiLCAic3JjL1Rva2VuU3RyZWFtUmV3cml0ZXIudHMiLCAic3JjL1ZvY2FidWxhcnkudHMiLCAic3JjL1dyaXRhYmxlVG9rZW4udHMiLCAic3JjL2luZGV4LnRzIiwgInNyYy90cmVlL0Fic3RyYWN0UGFyc2VUcmVlVmlzaXRvci50cyIsICJtYWluLnRzIiwgIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLXN0cmluZy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtY2h1bmtlZC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtY29tYmluZS1leHRlbnNpb25zL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1jaGFyYWN0ZXIvbGliL3VuaWNvZGUtcHVuY3R1YXRpb24tcmVnZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWNoYXJhY3Rlci9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay9saWIvaW5pdGlhbGl6ZS9jb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmsvbGliL2luaXRpYWxpemUvZG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWNsYXNzaWZ5LWNoYXJhY3Rlci9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtcmVzb2x2ZS1hbGwvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2F0dGVudGlvbi5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvYXV0b2xpbmsuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2JsYW5rLWxpbmUuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2Jsb2NrLXF1b3RlLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9jaGFyYWN0ZXItZXNjYXBlLmpzIiwgIm5vZGVfbW9kdWxlcy9kZWNvZGUtbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZS9pbmRleC5kb20uanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2NoYXJhY3Rlci1yZWZlcmVuY2UuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2NvZGUtZmVuY2VkLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9jb2RlLWluZGVudGVkLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9jb2RlLXRleHQuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLXN1YnRva2VuaXplL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9jb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZmFjdG9yeS1kZXN0aW5hdGlvbi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWZhY3RvcnktbGFiZWwvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1mYWN0b3J5LXRpdGxlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZmFjdG9yeS13aGl0ZXNwYWNlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1ub3JtYWxpemUtaWRlbnRpZmllci9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvZGVmaW5pdGlvbi5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvaGFyZC1icmVhay1lc2NhcGUuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2hlYWRpbmctYXR4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1odG1sLXRhZy1uYW1lL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9odG1sLWZsb3cuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL2h0bWwtdGV4dC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvbGFiZWwtZW5kLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9sYWJlbC1zdGFydC1pbWFnZS5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvbGFiZWwtc3RhcnQtbGluay5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyay9saWIvbGluZS1lbmRpbmcuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsvbGliL3RoZW1hdGljLWJyZWFrLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9saXN0LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9zZXRleHQtdW5kZXJsaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmsvbGliL2luaXRpYWxpemUvZmxvdy5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrL2xpYi9pbml0aWFsaXplL3RleHQuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay9saWIvY3JlYXRlLXRva2VuaXplci5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrL2xpYi9jb25zdHJ1Y3RzLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmsvbGliL3BhcnNlLmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmsvbGliL3ByZXByb2Nlc3MuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay9saWIvcG9zdHByb2Nlc3MuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWRlY29kZS1udW1lcmljLWNoYXJhY3Rlci1yZWZlcmVuY2UvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWRlY29kZS1zdHJpbmcvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3VuaXN0LXV0aWwtc3RyaW5naWZ5LXBvc2l0aW9uL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZyb20tbWFya2Rvd24vbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLW1hdGgvbGliL21hdGgtZmxvdy5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1tYXRoL2xpYi9tYXRoLXRleHQuanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tbWF0aC9saWIvc3ludGF4LmpzIiwgIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL3RyYWNrLmpzIiwgIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLW1hdGgvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXRhc2stbGlzdC1pdGVtL2xpYi9zeW50YXguanMiLCAibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZ2ZtLXRhc2stbGlzdC1pdGVtL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9saWIvc3ludGF4LmpzIiwgIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NvbnRhaW5lci1waHJhc2luZy5qcyIsICJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1nZm0tdGFibGUvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1zdHJpa2V0aHJvdWdoL2xpYi9zeW50YXguanMiLCAibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZ2ZtLXN0cmlrZXRocm91Z2gvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLWZvb3Rub3RlL2xpYi9zeW50YXguanMiLCAibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZ2ZtLWZvb3Rub3RlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsL2xpYi9zeW50YXguanMiLCAibm9kZV9tb2R1bGVzL2Njb3VudC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL25vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvdW5pc3QtdXRpbC1pcy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvdW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzL2NvbG9yLmJyb3dzZXIuanMiLCAibm9kZV9tb2R1bGVzL3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1nZm0tYXV0b2xpbmstbGl0ZXJhbC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0vaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZ2ZtL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZmF1bHQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZnJvbnRtYXR0ZXIvbWF0dGVycy5qcyIsICJub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1mcm9udG1hdHRlci9saWIvc3ludGF4LmpzIiwgIm5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZyb250bWF0dGVyL2luZGV4LmpzIiwgIlNpbXBsZVRleHQudHMiLCAiZ3JhbW1hci9TaW1wbGVUZXh0UGFyc2VyLnRzIiwgImdyYW1tYXIvU2ltcGxlVGV4dExleGVyLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvL1xuLy8gZm9ybWF0IC0gcHJpbnRmLWxpa2Ugc3RyaW5nIGZvcm1hdHRpbmcgZm9yIEphdmFTY3JpcHRcbi8vIGdpdGh1Yi5jb20vc2Ftc29uanMvZm9ybWF0XG4vLyBAX3Nqc1xuLy9cbi8vIENvcHlyaWdodCAyMDEwIC0gMjAxMyBTYW1pIFNhbWh1cmkgPHNhbWlAc2FtaHVyaS5uZXQ+XG4vL1xuLy8gTUlUIExpY2Vuc2Vcbi8vIGh0dHA6Ly9zanMubWl0LWxpY2Vuc2Uub3JnXG4vL1xuXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8vLy8gRXhwb3J0IHRoZSBBUElcbiAgdmFyIG5hbWVzcGFjZTtcblxuICAvLyBDb21tb25KUyAvIE5vZGUgbW9kdWxlXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG5hbWVzcGFjZSA9IG1vZHVsZS5leHBvcnRzID0gZm9ybWF0O1xuICB9XG5cbiAgLy8gQnJvd3NlcnMgYW5kIG90aGVyIGVudmlyb25tZW50c1xuICBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIGdsb2JhbCBvYmplY3QuIFdvcmtzIGluIEVTMywgRVM1LCBhbmQgRVM1IHN0cmljdCBtb2RlLlxuICAgIG5hbWVzcGFjZSA9IChmdW5jdGlvbigpeyByZXR1cm4gdGhpcyB8fCAoMSxldmFsKSgndGhpcycpIH0oKSk7XG4gIH1cblxuICBuYW1lc3BhY2UuZm9ybWF0ID0gZm9ybWF0O1xuICBuYW1lc3BhY2UudnNwcmludGYgPSB2c3ByaW50ZjtcblxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5hbWVzcGFjZS5wcmludGYgPSBwcmludGY7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludGYoLyogLi4uICovKSB7XG4gICAgY29uc29sZS5sb2coZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgZnVuY3Rpb24gdnNwcmludGYoZm10LCByZXBsYWNlbWVudHMpIHtcbiAgICByZXR1cm4gZm9ybWF0LmFwcGx5KG51bGwsIFtmbXRdLmNvbmNhdChyZXBsYWNlbWVudHMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdChmbXQpIHtcbiAgICB2YXIgYXJnSW5kZXggPSAxIC8vIHNraXAgaW5pdGlhbCBmb3JtYXQgYXJndW1lbnRcbiAgICAgICwgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgLCBpID0gMFxuICAgICAgLCBuID0gZm10Lmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSAnJ1xuICAgICAgLCBjXG4gICAgICAsIGVzY2FwZWQgPSBmYWxzZVxuICAgICAgLCBhcmdcbiAgICAgICwgdG1wXG4gICAgICAsIGxlYWRpbmdaZXJvID0gZmFsc2VcbiAgICAgICwgcHJlY2lzaW9uXG4gICAgICAsIG5leHRBcmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH1cbiAgICAgICwgc2x1cnBOdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZGlnaXRzID0gJyc7XG4gICAgICAgICAgd2hpbGUgKC9cXGQvLnRlc3QoZm10W2ldKSkge1xuICAgICAgICAgICAgZGlnaXRzICs9IGZtdFtpKytdO1xuICAgICAgICAgICAgYyA9IGZtdFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpZ2l0cy5sZW5ndGggPiAwID8gcGFyc2VJbnQoZGlnaXRzKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgIDtcbiAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgYyA9IGZtdFtpXTtcbiAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGMgPT0gJy4nKSB7XG4gICAgICAgICAgbGVhZGluZ1plcm8gPSBmYWxzZTtcbiAgICAgICAgICBjID0gZm10WysraV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PSAnMCcgJiYgZm10W2kgKyAxXSA9PSAnLicpIHtcbiAgICAgICAgICBsZWFkaW5nWmVybyA9IHRydWU7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIGMgPSBmbXRbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbGVhZGluZ1plcm8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHByZWNpc2lvbiA9IHNsdXJwTnVtYmVyKCk7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlICdiJzogLy8gbnVtYmVyIGluIGJpbmFyeVxuICAgICAgICAgIHJlc3VsdCArPSBwYXJzZUludChuZXh0QXJnKCksIDEwKS50b1N0cmluZygyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYyc6IC8vIGNoYXJhY3RlclxuICAgICAgICAgIGFyZyA9IG5leHRBcmcoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHwgYXJnIGluc3RhbmNlb2YgU3RyaW5nKVxuICAgICAgICAgICAgcmVzdWx0ICs9IGFyZztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChhcmcsIDEwKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2QnOiAvLyBudW1iZXIgaW4gZGVjaW1hbFxuICAgICAgICAgIHJlc3VsdCArPSBwYXJzZUludChuZXh0QXJnKCksIDEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZic6IC8vIGZsb2F0aW5nIHBvaW50IG51bWJlclxuICAgICAgICAgIHRtcCA9IFN0cmluZyhwYXJzZUZsb2F0KG5leHRBcmcoKSkudG9GaXhlZChwcmVjaXNpb24gfHwgNikpO1xuICAgICAgICAgIHJlc3VsdCArPSBsZWFkaW5nWmVybyA/IHRtcCA6IHRtcC5yZXBsYWNlKC9eMC8sICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaic6IC8vIEpTT05cbiAgICAgICAgICByZXN1bHQgKz0gSlNPTi5zdHJpbmdpZnkobmV4dEFyZygpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbyc6IC8vIG51bWJlciBpbiBvY3RhbFxuICAgICAgICAgIHJlc3VsdCArPSAnMCcgKyBwYXJzZUludChuZXh0QXJnKCksIDEwKS50b1N0cmluZyg4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncyc6IC8vIHN0cmluZ1xuICAgICAgICAgIHJlc3VsdCArPSBuZXh0QXJnKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3gnOiAvLyBsb3dlcmNhc2UgaGV4YWRlY2ltYWxcbiAgICAgICAgICByZXN1bHQgKz0gJzB4JyArIHBhcnNlSW50KG5leHRBcmcoKSwgMTApLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnWCc6IC8vIHVwcGVyY2FzZSBoZXhhZGVjaW1hbFxuICAgICAgICAgIHJlc3VsdCArPSAnMHgnICsgcGFyc2VJbnQobmV4dEFyZygpLCAxMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVzdWx0ICs9IGM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJyUnKSB7XG4gICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IGM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxufSgpKTtcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0OC43NDk5OTk3LTA3OjAwXHJcblxyXG4vKiogSG93IHRvIGVtaXQgcmVjb2duaXRpb24gZXJyb3JzLiAqL1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4vUmVjb2duaXplclwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFOVExSRXJyb3JMaXN0ZW5lcjxUU3ltYm9sPiB7XHJcblx0LyoqXHJcblx0ICogVXBvbiBzeW50YXggZXJyb3IsIG5vdGlmeSBhbnkgaW50ZXJlc3RlZCBwYXJ0aWVzLiBUaGlzIGlzIG5vdCBob3cgdG9cclxuXHQgKiByZWNvdmVyIGZyb20gZXJyb3JzIG9yIGNvbXB1dGUgZXJyb3IgbWVzc2FnZXMuIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3l9XHJcblx0ICogc3BlY2lmaWVzIGhvdyB0byByZWNvdmVyIGZyb20gc3ludGF4IGVycm9ycyBhbmQgaG93IHRvIGNvbXB1dGUgZXJyb3JcclxuXHQgKiBtZXNzYWdlcy4gVGhpcyBsaXN0ZW5lcidzIGpvYiBpcyBzaW1wbHkgdG8gZW1pdCBhIGNvbXB1dGVkIG1lc3NhZ2UsXHJcblx0ICogdGhvdWdoIGl0IGhhcyBlbm91Z2ggaW5mb3JtYXRpb24gdG8gY3JlYXRlIGl0cyBvd24gbWVzc2FnZSBpbiBtYW55IGNhc2VzLlxyXG5cdCAqXHJcblx0ICogVGhlIHtAbGluayBSZWNvZ25pdGlvbkV4Y2VwdGlvbn0gaXMgbm9uLWB1bmRlZmluZWRgIGZvciBhbGwgc3ludGF4IGVycm9ycyBleGNlcHRcclxuXHQgKiB3aGVuIHdlIGRpc2NvdmVyIG1pc21hdGNoZWQgdG9rZW4gZXJyb3JzIHRoYXQgd2UgY2FuIHJlY292ZXIgZnJvbVxyXG5cdCAqIGluLWxpbmUsIHdpdGhvdXQgcmV0dXJuaW5nIGZyb20gdGhlIHN1cnJvdW5kaW5nIHJ1bGUgKHZpYSB0aGUgc2luZ2xlXHJcblx0ICogdG9rZW4gaW5zZXJ0aW9uIGFuZCBkZWxldGlvbiBtZWNoYW5pc20pLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXJcclxuXHQgKiAgICAgICAgV2hhdCBwYXJzZXIgZ290IHRoZSBlcnJvci4gRnJvbSB0aGlzXHJcblx0ICogXHRcdCAgb2JqZWN0LCB5b3UgY2FuIGFjY2VzcyB0aGUgY29udGV4dCBhcyB3ZWxsXHJcblx0ICogXHRcdCAgYXMgdGhlIGlucHV0IHN0cmVhbS5cclxuXHQgKiBAcGFyYW0gb2ZmZW5kaW5nU3ltYm9sXHJcblx0ICogICAgICAgIFRoZSBvZmZlbmRpbmcgdG9rZW4gaW4gdGhlIGlucHV0IHRva2VuXHJcblx0ICogXHRcdCAgc3RyZWFtLCB1bmxlc3MgcmVjb2duaXplciBpcyBhIGxleGVyICh0aGVuIGl0J3MgYHVuZGVmaW5lZGApLiBJZlxyXG5cdCAqIFx0XHQgIG5vIHZpYWJsZSBhbHRlcm5hdGl2ZSBlcnJvciwgYGVgIGhhcyB0b2tlbiBhdCB3aGljaCB3ZVxyXG5cdCAqIFx0XHQgIHN0YXJ0ZWQgcHJvZHVjdGlvbiBmb3IgdGhlIGRlY2lzaW9uLlxyXG5cdCAqIEBwYXJhbSBsaW5lXHJcblx0ICogXHRcdCAgVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBpbnB1dCB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQuXHJcblx0ICogQHBhcmFtIGNoYXJQb3NpdGlvbkluTGluZVxyXG5cdCAqIFx0XHQgIFRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gd2l0aGluIHRoYXQgbGluZSB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQuXHJcblx0ICogQHBhcmFtIG1zZ1xyXG5cdCAqIFx0XHQgIFRoZSBtZXNzYWdlIHRvIGVtaXQuXHJcblx0ICogQHBhcmFtIGVcclxuXHQgKiAgICAgICAgVGhlIGV4Y2VwdGlvbiBnZW5lcmF0ZWQgYnkgdGhlIHBhcnNlciB0aGF0IGxlZCB0b1xyXG5cdCAqICAgICAgICB0aGUgcmVwb3J0aW5nIG9mIGFuIGVycm9yLiBJdCBpcyBgdW5kZWZpbmVkYCBpbiB0aGUgY2FzZSB3aGVyZVxyXG5cdCAqICAgICAgICB0aGUgcGFyc2VyIHdhcyBhYmxlIHRvIHJlY292ZXIgaW4gbGluZSB3aXRob3V0IGV4aXRpbmcgdGhlXHJcblx0ICogICAgICAgIHN1cnJvdW5kaW5nIHJ1bGUuXHJcblx0ICovXHJcblx0c3ludGF4RXJyb3I/OiA8VCBleHRlbmRzIFRTeW1ib2w+KFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRyZWNvZ25pemVyOiBSZWNvZ25pemVyPFQsIGFueT4sXHJcblx0XHRvZmZlbmRpbmdTeW1ib2w6IFQgfCB1bmRlZmluZWQsXHJcblx0XHRsaW5lOiBudW1iZXIsXHJcblx0XHRjaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlcixcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0bXNnOiBzdHJpbmcsXHJcblx0XHRlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB8IHVuZGVmaW5lZCkgPT4gdm9pZDtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDguOTEwMjE3NC0wNzowMFxyXG5cclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBpbnRlcmZhY2UgZm9yIGRlZmluaW5nIHN0cmF0ZWdpZXMgdG8gZGVhbCB3aXRoIHN5bnRheCBlcnJvcnMgZW5jb3VudGVyZWRcclxuICogZHVyaW5nIGEgcGFyc2UgYnkgQU5UTFItZ2VuZXJhdGVkIHBhcnNlcnMuIFdlIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhyZWVcclxuICogZGlmZmVyZW50IGtpbmRzIG9mIGVycm9yczpcclxuICpcclxuICogKiBUaGUgcGFyc2VyIGNvdWxkIG5vdCBmaWd1cmUgb3V0IHdoaWNoIHBhdGggdG8gdGFrZSBpbiB0aGUgQVROIChub25lIG9mXHJcbiAqICAgdGhlIGF2YWlsYWJsZSBhbHRlcm5hdGl2ZXMgY291bGQgcG9zc2libHkgbWF0Y2gpXHJcbiAqICogVGhlIGN1cnJlbnQgaW5wdXQgZG9lcyBub3QgbWF0Y2ggd2hhdCB3ZSB3ZXJlIGxvb2tpbmcgZm9yXHJcbiAqICogQSBwcmVkaWNhdGUgZXZhbHVhdGVkIHRvIGZhbHNlXHJcbiAqXHJcbiAqIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGludGVyZmFjZSByZXBvcnQgc3ludGF4IGVycm9ycyBieSBjYWxsaW5nXHJcbiAqIHtAbGluayBQYXJzZXIjbm90aWZ5RXJyb3JMaXN0ZW5lcnN9LlxyXG4gKlxyXG4gKiBUT0RPOiB3aGF0IHRvIGRvIGFib3V0IGxleGVyc1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBBTlRMUkVycm9yU3RyYXRlZ3kge1xyXG5cdC8qKlxyXG5cdCAqIFJlc2V0IHRoZSBlcnJvciBoYW5kbGVyIHN0YXRlIGZvciB0aGUgc3BlY2lmaWVkIGByZWNvZ25pemVyYC5cclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICovXHJcblx0cmVzZXQoLypATm90TnVsbCovIHJlY29nbml6ZXI6IFBhcnNlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGFuIHVuZXhwZWN0ZWQgc3ltYm9sIGlzIGVuY291bnRlcmVkIGR1cmluZyBhblxyXG5cdCAqIGlubGluZSBtYXRjaCBvcGVyYXRpb24sIHN1Y2ggYXMge0BsaW5rIFBhcnNlciNtYXRjaH0uIElmIHRoZSBlcnJvclxyXG5cdCAqIHN0cmF0ZWd5IHN1Y2Nlc3NmdWxseSByZWNvdmVycyBmcm9tIHRoZSBtYXRjaCBmYWlsdXJlLCB0aGlzIG1ldGhvZFxyXG5cdCAqIHJldHVybnMgdGhlIHtAbGluayBUb2tlbn0gaW5zdGFuY2Ugd2hpY2ggc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdGhlXHJcblx0ICogc3VjY2Vzc2Z1bCByZXN1bHQgb2YgdGhlIG1hdGNoLlxyXG5cdCAqXHJcblx0ICogVGhpcyBtZXRob2QgaGFuZGxlcyB0aGUgY29uc3VtcHRpb24gb2YgYW55IHRva2VucyAtIHRoZSBjYWxsZXIgc2hvdWxkXHJcblx0ICogKm5vdCogY2FsbCB7QGxpbmsgUGFyc2VyI2NvbnN1bWV9IGFmdGVyIGEgc3VjY2Vzc2Z1bCByZWNvdmVyeS5cclxuXHQgKlxyXG5cdCAqIE5vdGUgdGhhdCB0aGUgY2FsbGluZyBjb2RlIHdpbGwgbm90IHJlcG9ydCBhbiBlcnJvciBpZiB0aGlzIG1ldGhvZFxyXG5cdCAqIHJldHVybnMgc3VjY2Vzc2Z1bGx5LiBUaGUgZXJyb3Igc3RyYXRlZ3kgaW1wbGVtZW50YXRpb24gaXMgcmVzcG9uc2libGVcclxuXHQgKiBmb3IgY2FsbGluZyB7QGxpbmsgUGFyc2VyI25vdGlmeUVycm9yTGlzdGVuZXJzfSBhcyBhcHByb3ByaWF0ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKiBAIGlmIHRoZSBlcnJvciBzdHJhdGVneSB3YXMgbm90IGFibGUgdG9cclxuXHQgKiByZWNvdmVyIGZyb20gdGhlIHVuZXhwZWN0ZWQgaW5wdXQgc3ltYm9sXHJcblx0ICovXHJcblx0cmVjb3ZlcklubGluZSgvKkBOb3ROdWxsKi8gcmVjb2duaXplcjogUGFyc2VyKTogVG9rZW47XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0byByZWNvdmVyIGZyb20gZXhjZXB0aW9uIGBlYC4gVGhpcyBtZXRob2QgaXNcclxuXHQgKiBjYWxsZWQgYWZ0ZXIge0BsaW5rICNyZXBvcnRFcnJvcn0gYnkgdGhlIGRlZmF1bHQgZXhjZXB0aW9uIGhhbmRsZXJcclxuXHQgKiBnZW5lcmF0ZWQgZm9yIGEgcnVsZSBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBAc2VlICNyZXBvcnRFcnJvclxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxyXG5cdCAqIEBwYXJhbSBlIHRoZSByZWNvZ25pdGlvbiBleGNlcHRpb24gdG8gcmVjb3ZlciBmcm9tXHJcblx0ICogQCBpZiB0aGUgZXJyb3Igc3RyYXRlZ3kgY291bGQgbm90IHJlY292ZXIgZnJvbVxyXG5cdCAqIHRoZSByZWNvZ25pdGlvbiBleGNlcHRpb25cclxuXHQgKi9cclxuXHRyZWNvdmVyKC8qQE5vdE51bGwqLyByZWNvZ25pemVyOiBQYXJzZXIsIC8qQE5vdE51bGwqLyBlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIHByb3ZpZGVzIHRoZSBlcnJvciBoYW5kbGVyIHdpdGggYW4gb3Bwb3J0dW5pdHkgdG8gaGFuZGxlXHJcblx0ICogc3ludGFjdGljIG9yIHNlbWFudGljIGVycm9ycyBpbiB0aGUgaW5wdXQgc3RyZWFtIGJlZm9yZSB0aGV5IHJlc3VsdCBpbiBhXHJcblx0ICoge0BsaW5rIFJlY29nbml0aW9uRXhjZXB0aW9ufS5cclxuXHQgKlxyXG5cdCAqIFRoZSBnZW5lcmF0ZWQgY29kZSBjdXJyZW50bHkgY29udGFpbnMgY2FsbHMgdG8ge0BsaW5rICNzeW5jfSBhZnRlclxyXG5cdCAqIGVudGVyaW5nIHRoZSBkZWNpc2lvbiBzdGF0ZSBvZiBhIGNsb3N1cmUgYmxvY2sgKGAoLi4uKSpgIG9yXHJcblx0ICogYCguLi4pK2ApLlxyXG5cdCAqXHJcblx0ICogRm9yIGFuIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uIEppbSBJZGxlJ3MgXCJtYWdpYyBzeW5jXCIgbWVjaGFuaXNtLCBzZWVcclxuXHQgKiB7QGxpbmsgRGVmYXVsdEVycm9yU3RyYXRlZ3kjc3luY30uXHJcblx0ICpcclxuXHQgKiBAc2VlIERlZmF1bHRFcnJvclN0cmF0ZWd5I3N5bmNcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKiBAIGlmIGFuIGVycm9yIGlzIGRldGVjdGVkIGJ5IHRoZSBlcnJvclxyXG5cdCAqIHN0cmF0ZWd5IGJ1dCBjYW5ub3QgYmUgYXV0b21hdGljYWxseSByZWNvdmVyZWQgYXQgdGhlIGN1cnJlbnQgc3RhdGUgaW5cclxuXHQgKiB0aGUgcGFyc2luZyBwcm9jZXNzXHJcblx0ICovXHJcblx0c3luYygvKkBOb3ROdWxsKi8gcmVjb2duaXplcjogUGFyc2VyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogVGVzdHMgd2hldGhlciBvciBub3QgYHJlY29nbml6ZXJgIGlzIGluIHRoZSBwcm9jZXNzIG9mIHJlY292ZXJpbmdcclxuXHQgKiBmcm9tIGFuIGVycm9yLiBJbiBlcnJvciByZWNvdmVyeSBtb2RlLCB7QGxpbmsgUGFyc2VyI2NvbnN1bWV9IGFkZHNcclxuXHQgKiBzeW1ib2xzIHRvIHRoZSBwYXJzZSB0cmVlIGJ5IGNhbGxpbmdcclxuXHQgKiB7QGxpbmsgUGFyc2VyI2NyZWF0ZUVycm9yTm9kZShQYXJzZXJSdWxlQ29udGV4dCwgVG9rZW4pfSB0aGVuXHJcblx0ICoge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0I2FkZEVycm9yTm9kZShFcnJvck5vZGUpfSBpbnN0ZWFkIG9mXHJcblx0ICoge0BsaW5rIFBhcnNlciNjcmVhdGVUZXJtaW5hbE5vZGUoUGFyc2VyUnVsZUNvbnRleHQsIFRva2VuKX0uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwYXJzZXIgaXMgY3VycmVudGx5IHJlY292ZXJpbmcgZnJvbSBhIHBhcnNlXHJcblx0ICogZXJyb3IsIG90aGVyd2lzZSBgZmFsc2VgXHJcblx0ICovXHJcblx0aW5FcnJvclJlY292ZXJ5TW9kZSgvKkBOb3ROdWxsKi8gcmVjb2duaXplcjogUGFyc2VyKTogYm9vbGVhbjtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHdoZW4gdGhlIHBhcnNlciBzdWNjZXNzZnVsbHkgbWF0Y2hlcyBhbiBpbnB1dFxyXG5cdCAqIHN5bWJvbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKi9cclxuXHRyZXBvcnRNYXRjaCgvKkBOb3ROdWxsKi8gcmVjb2duaXplcjogUGFyc2VyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUmVwb3J0IGFueSBraW5kIG9mIHtAbGluayBSZWNvZ25pdGlvbkV4Y2VwdGlvbn0uIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieVxyXG5cdCAqIHRoZSBkZWZhdWx0IGV4Y2VwdGlvbiBoYW5kbGVyIGdlbmVyYXRlZCBmb3IgYSBydWxlIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKiBAcGFyYW0gZSB0aGUgcmVjb2duaXRpb24gZXhjZXB0aW9uIHRvIHJlcG9ydFxyXG5cdCAqL1xyXG5cdHJlcG9ydEVycm9yKFxyXG5cdFx0LypATm90TnVsbCovIHJlY29nbml6ZXI6IFBhcnNlcixcclxuXHRcdC8qQE5vdE51bGwqLyBlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbik6IHZvaWQ7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIE5vdE51bGwoXHJcblx0dGFyZ2V0OiBhbnksXHJcblx0cHJvcGVydHlLZXk6IFByb3BlcnR5S2V5LFxyXG5cdHByb3BlcnR5RGVzY3JpcHRvcj86IFByb3BlcnR5RGVzY3JpcHRvciB8IG51bWJlcikge1xyXG5cdC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIE51bGxhYmxlKFxyXG5cdHRhcmdldDogYW55LFxyXG5cdHByb3BlcnR5S2V5OiBQcm9wZXJ0eUtleSxcclxuXHRwcm9wZXJ0eURlc2NyaXB0b3I/OiBQcm9wZXJ0eURlc2NyaXB0b3IgfCBudW1iZXIpIHtcclxuXHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBPdmVycmlkZShcclxuXHR0YXJnZXQ6IGFueSxcclxuXHRwcm9wZXJ0eUtleTogUHJvcGVydHlLZXksXHJcblx0cHJvcGVydHlEZXNjcmlwdG9yPzogUHJvcGVydHlEZXNjcmlwdG9yKSB7XHJcblx0Ly8gZG8gc29tZXRoaW5nIHdpdGggJ3RhcmdldCcgLi4uXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBTdXBwcmVzc1dhcm5pbmdzKG9wdGlvbnM6IHN0cmluZykge1xyXG5cdHJldHVybiAodGFyZ2V0OiBhbnksIHByb3BlcnR5S2V5OiBQcm9wZXJ0eUtleSwgZGVzY3JpcHRvcj86IFByb3BlcnR5RGVzY3JpcHRvcikgPT4ge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH07XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUxLjY5MzQzNzYtMDc6MDBcclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgSW50U3RyZWFtIHtcclxuXHQvKipcclxuXHQgKiBUaGUgdmFsdWUgcmV0dXJuZWQgYnkge0BsaW5rICNMQSBMQSgpfSB3aGVuIHRoZSBlbmQgb2YgdGhlIHN0cmVhbSBpc1xyXG5cdCAqIHJlYWNoZWQuXHJcblx0ICovXHJcblx0ZXhwb3J0IGNvbnN0IEVPRjogbnVtYmVyID0gLTE7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSB2YWx1ZSByZXR1cm5lZCBieSB7QGxpbmsgI2dldFNvdXJjZU5hbWV9IHdoZW4gdGhlIGFjdHVhbCBuYW1lIG9mIHRoZVxyXG5cdCAqIHVuZGVybHlpbmcgc291cmNlIGlzIG5vdCBrbm93bi5cclxuXHQgKi9cclxuXHRleHBvcnQgY29uc3QgVU5LTk9XTl9TT1VSQ0VfTkFNRTogc3RyaW5nID0gXCI8dW5rbm93bj5cIjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgc2ltcGxlIHN0cmVhbSBvZiBzeW1ib2xzIHdob3NlIHZhbHVlcyBhcmUgcmVwcmVzZW50ZWQgYXMgaW50ZWdlcnMuIFRoaXNcclxuICogaW50ZXJmYWNlIHByb3ZpZGVzICptYXJrZWQgcmFuZ2VzKiB3aXRoIHN1cHBvcnQgZm9yIGEgbWluaW11bSBsZXZlbFxyXG4gKiBvZiBidWZmZXJpbmcgbmVjZXNzYXJ5IHRvIGltcGxlbWVudCBhcmJpdHJhcnkgbG9va2FoZWFkIGR1cmluZyBwcmVkaWN0aW9uLlxyXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBtYXJrZWQgcmFuZ2VzLCBzZWUge0BsaW5rICNtYXJrfS5cclxuICpcclxuICogKipJbml0aWFsaXppbmcgTWV0aG9kczoqKiBTb21lIG1ldGhvZHMgaW4gdGhpcyBpbnRlcmZhY2UgaGF2ZVxyXG4gKiB1bnNwZWNpZmllZCBiZWhhdmlvciBpZiBubyBjYWxsIHRvIGFuIGluaXRpYWxpemluZyBtZXRob2QgaGFzIG9jY3VycmVkIGFmdGVyXHJcbiAqIHRoZSBzdHJlYW0gd2FzIGNvbnN0cnVjdGVkLiBUaGUgZm9sbG93aW5nIGlzIGEgbGlzdCBvZiBpbml0aWFsaXppbmcgbWV0aG9kczpcclxuICpcclxuICogKiB7QGxpbmsgI0xBfVxyXG4gKiAqIHtAbGluayAjY29uc3VtZX1cclxuICogKiB7QGxpbmsgI3NpemV9XHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEludFN0cmVhbSB7XHJcblx0LyoqXHJcblx0ICogQ29uc3VtZXMgdGhlIGN1cnJlbnQgc3ltYm9sIGluIHRoZSBzdHJlYW0uIFRoaXMgbWV0aG9kIGhhcyB0aGUgZm9sbG93aW5nXHJcblx0ICogZWZmZWN0czpcclxuXHQgKlxyXG5cdCAqICogKipGb3J3YXJkIG1vdmVtZW50OioqIFRoZSB2YWx1ZSBvZiBgaW5kZXhgXHJcblx0ICogICBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZCBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIGBpbmRleGBcclxuXHQgKiAgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QuXHJcblx0ICogKiAqKk9yZGVyZWQgbG9va2FoZWFkOioqIFRoZSB2YWx1ZSBvZiBgTEEoMSlgIGJlZm9yZVxyXG5cdCAqICAgY2FsbGluZyB0aGlzIG1ldGhvZCBiZWNvbWVzIHRoZSB2YWx1ZSBvZiBgTEEoLTEpYCBhZnRlciBjYWxsaW5nXHJcblx0ICogICB0aGlzIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIE5vdGUgdGhhdCBjYWxsaW5nIHRoaXMgbWV0aG9kIGRvZXMgbm90IGd1YXJhbnRlZSB0aGF0IGBpbmRleGAgaXNcclxuXHQgKiBpbmNyZW1lbnRlZCBieSBleGFjdGx5IDEsIGFzIHRoYXQgd291bGQgcHJlY2x1ZGUgdGhlIGFiaWxpdHkgdG8gaW1wbGVtZW50XHJcblx0ICogZmlsdGVyaW5nIHN0cmVhbXMgKGUuZy4ge0BsaW5rIENvbW1vblRva2VuU3RyZWFtfSB3aGljaCBkaXN0aW5ndWlzaGVzXHJcblx0ICogYmV0d2VlbiBcIm9uLWNoYW5uZWxcIiBhbmQgXCJvZmYtY2hhbm5lbFwiIHRva2VucykuXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IGlzIG1hZGUgdG8gY29uc3VtZSB0aGVcclxuXHQgKiBlbmQgb2YgdGhlIHN0cmVhbSAoaS5lLiBpZiBgTEEoMSk9PWB7QGxpbmsgI0VPRiBFT0Z9IGJlZm9yZSBjYWxsaW5nXHJcblx0ICogYGNvbnN1bWVgKS5cclxuXHQgKi9cclxuXHRjb25zdW1lKCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBzeW1ib2wgYXQgb2Zmc2V0IGBpYCBmcm9tIHRoZSBjdXJyZW50XHJcblx0ICogcG9zaXRpb24uIFdoZW4gYGk9PTFgLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudFxyXG5cdCAqIHN5bWJvbCBpbiB0aGUgc3RyZWFtICh3aGljaCBpcyB0aGUgbmV4dCBzeW1ib2wgdG8gYmUgY29uc3VtZWQpLiBXaGVuXHJcblx0ICogYGk9PS0xYCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHByZXZpb3VzbHkgcmVhZFxyXG5cdCAqIHN5bWJvbCBpbiB0aGUgc3RyZWFtLiBJdCBpcyBub3QgdmFsaWQgdG8gY2FsbCB0aGlzIG1ldGhvZCB3aXRoXHJcblx0ICogYGk9PTBgLCBidXQgdGhlIHNwZWNpZmljIGJlaGF2aW9yIGlzIHVuc3BlY2lmaWVkIGJlY2F1c2UgdGhpc1xyXG5cdCAqIG1ldGhvZCBpcyBmcmVxdWVudGx5IGNhbGxlZCBmcm9tIHBlcmZvcm1hbmNlLWNyaXRpY2FsIGNvZGUuXHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBndWFyYW50ZWVkIHRvIHN1Y2NlZWQgaWYgYW55IG9mIHRoZSBmb2xsb3dpbmcgYXJlIHRydWU6XHJcblx0ICpcclxuXHQgKiAqIGBpPjBgXHJcblx0ICogKiBgaT09LTFgIGFuZCBgaW5kZXhgIHJldHVybnMgYSB2YWx1ZSBncmVhdGVyXHJcblx0ICogICB0aGFuIHRoZSB2YWx1ZSBvZiBgaW5kZXhgIGFmdGVyIHRoZSBzdHJlYW0gd2FzIGNvbnN0cnVjdGVkXHJcblx0ICogICBhbmQgYExBKDEpYCB3YXMgY2FsbGVkIGluIHRoYXQgb3JkZXIuIFNwZWNpZnlpbmcgdGhlIGN1cnJlbnRcclxuXHQgKiAgIGBpbmRleGAgcmVsYXRpdmUgdG8gdGhlIGluZGV4IGFmdGVyIHRoZSBzdHJlYW0gd2FzIGNyZWF0ZWRcclxuXHQgKiAgIGFsbG93cyBmb3IgZmlsdGVyaW5nIGltcGxlbWVudGF0aW9ucyB0aGF0IGRvIG5vdCByZXR1cm4gZXZlcnkgc3ltYm9sXHJcblx0ICogICBmcm9tIHRoZSB1bmRlcmx5aW5nIHNvdXJjZS4gU3BlY2lmeWluZyB0aGUgY2FsbCB0byBgTEEoMSlgXHJcblx0ICogICBhbGxvd3MgZm9yIGxhemlseSBpbml0aWFsaXplZCBzdHJlYW1zLlxyXG5cdCAqICogYExBKGkpYCByZWZlcnMgdG8gYSBzeW1ib2wgY29uc3VtZWQgd2l0aGluIGEgbWFya2VkIHJlZ2lvblxyXG5cdCAqICAgdGhhdCBoYXMgbm90IHlldCBiZWVuIHJlbGVhc2VkLlxyXG5cdCAqXHJcblx0ICogSWYgYGlgIHJlcHJlc2VudHMgYSBwb3NpdGlvbiBhdCBvciBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgc3RyZWFtLFxyXG5cdCAqIHRoaXMgbWV0aG9kIHJldHVybnMge0BsaW5rICNFT0Z9LlxyXG5cdCAqXHJcblx0ICogVGhlIHJldHVybiB2YWx1ZSBpcyB1bnNwZWNpZmllZCBpZiBgaTwwYCBhbmQgZmV3ZXIgdGhhbiBgLWlgXHJcblx0ICogY2FsbHMgdG8ge0BsaW5rICNjb25zdW1lIGNvbnN1bWUoKX0gaGF2ZSBvY2N1cnJlZCBmcm9tIHRoZSBiZWdpbm5pbmcgb2ZcclxuXHQgKiB0aGUgc3RyZWFtIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxyXG5cdCAqXHJcblx0ICogQHRocm93cyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiBpZiB0aGUgc3RyZWFtIGRvZXMgbm90IHN1cHBvcnRcclxuXHQgKiByZXRyaWV2aW5nIHRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIHN5bWJvbFxyXG5cdCAqL1xyXG5cdExBKGk6IG51bWJlcik6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogQSBtYXJrIHByb3ZpZGVzIGEgZ3VhcmFudGVlIHRoYXQge0BsaW5rICNzZWVrIHNlZWsoKX0gb3BlcmF0aW9ucyB3aWxsIGJlXHJcblx0ICogdmFsaWQgb3ZlciBhIFwibWFya2VkIHJhbmdlXCIgZXh0ZW5kaW5nIGZyb20gdGhlIGluZGV4IHdoZXJlIGBtYXJrKClgXHJcblx0ICogd2FzIGNhbGxlZCB0byB0aGUgY3VycmVudCBgaW5kZXhgLiBUaGlzIGFsbG93cyB0aGUgdXNlIG9mXHJcblx0ICogc3RyZWFtaW5nIGlucHV0IHNvdXJjZXMgYnkgc3BlY2lmeWluZyB0aGUgbWluaW11bSBidWZmZXJpbmcgcmVxdWlyZW1lbnRzXHJcblx0ICogdG8gc3VwcG9ydCBhcmJpdHJhcnkgbG9va2FoZWFkIGR1cmluZyBwcmVkaWN0aW9uLlxyXG5cdCAqXHJcblx0ICogVGhlIHJldHVybmVkIG1hcmsgaXMgYW4gb3BhcXVlIGhhbmRsZSAodHlwZSBgaW50YCkgd2hpY2ggaXMgcGFzc2VkXHJcblx0ICogdG8ge0BsaW5rICNyZWxlYXNlIHJlbGVhc2UoKX0gd2hlbiB0aGUgZ3VhcmFudGVlcyBwcm92aWRlZCBieSB0aGUgbWFya2VkXHJcblx0ICogcmFuZ2UgYXJlIG5vIGxvbmdlciBuZWNlc3NhcnkuIFdoZW4gY2FsbHMgdG9cclxuXHQgKiBgbWFyaygpYC9gcmVsZWFzZSgpYCBhcmUgbmVzdGVkLCB0aGUgbWFya3MgbXVzdCBiZSByZWxlYXNlZFxyXG5cdCAqIGluIHJldmVyc2Ugb3JkZXIgb2Ygd2hpY2ggdGhleSB3ZXJlIG9idGFpbmVkLiBTaW5jZSBtYXJrZWQgcmVnaW9ucyBhcmVcclxuXHQgKiB1c2VkIGR1cmluZyBwZXJmb3JtYW5jZS1jcml0aWNhbCBzZWN0aW9ucyBvZiBwcmVkaWN0aW9uLCB0aGUgc3BlY2lmaWNcclxuXHQgKiBiZWhhdmlvciBvZiBpbnZhbGlkIHVzYWdlIGlzIHVuc3BlY2lmaWVkIChpLmUuIGEgbWFyayBpcyBub3QgcmVsZWFzZWQsIG9yXHJcblx0ICogYSBtYXJrIGlzIHJlbGVhc2VkIHR3aWNlLCBvciBtYXJrcyBhcmUgbm90IHJlbGVhc2VkIGluIHJldmVyc2Ugb3JkZXIgZnJvbVxyXG5cdCAqIHdoaWNoIHRoZXkgd2VyZSBjcmVhdGVkKS5cclxuXHQgKlxyXG5cdCAqIFRoZSBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZCBpcyB1bnNwZWNpZmllZCBpZiBubyBjYWxsIHRvIGFuXHJcblx0ICoge0BsaW5rIEludFN0cmVhbSBpbml0aWFsaXppbmcgbWV0aG9kfSBoYXMgb2NjdXJyZWQgYWZ0ZXIgdGhpcyBzdHJlYW0gd2FzXHJcblx0ICogY29uc3RydWN0ZWQuXHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjaGFuZ2UgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGlucHV0IHN0cmVhbS5cclxuXHQgKlxyXG5cdCAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyB0aGUgdXNlIG9mIHtAbGluayAjbWFyayBtYXJrKCl9LFxyXG5cdCAqIHtAbGluayAjcmVsZWFzZSByZWxlYXNlKG1hcmspfSwgYGluZGV4YCwgYW5kXHJcblx0ICoge0BsaW5rICNzZWVrIHNlZWsoaW5kZXgpfSBhcyBwYXJ0IG9mIGFuIG9wZXJhdGlvbiB0byBzYWZlbHkgd29yayB3aXRoaW4gYVxyXG5cdCAqIG1hcmtlZCByZWdpb24sIHRoZW4gcmVzdG9yZSB0aGUgc3RyZWFtIHBvc2l0aW9uIHRvIGl0cyBvcmlnaW5hbCB2YWx1ZSBhbmRcclxuXHQgKiByZWxlYXNlIHRoZSBtYXJrLlxyXG5cdCAqXHJcblx0ICogYGBgXHJcblx0ICogSW50U3RyZWFtIHN0cmVhbSA9IC4uLjtcclxuXHQgKiBpbnQgaW5kZXggPSAtMTtcclxuXHQgKiBpbnQgbWFyayA9IHN0cmVhbS5tYXJrKCk7XHJcblx0ICogdHJ5IHtcclxuXHQgKiAgIGluZGV4ID0gc3RyZWFtLmluZGV4O1xyXG5cdCAqICAgLy8gcGVyZm9ybSB3b3JrIGhlcmUuLi5cclxuXHQgKiB9IGZpbmFsbHkge1xyXG5cdCAqICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcblx0ICogICAgIHN0cmVhbS5zZWVrKGluZGV4KTtcclxuXHQgKiAgIH1cclxuXHQgKiAgIHN0cmVhbS5yZWxlYXNlKG1hcmspO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIEFuIG9wYXF1ZSBtYXJrZXIgd2hpY2ggc2hvdWxkIGJlIHBhc3NlZCB0b1xyXG5cdCAqIHtAbGluayAjcmVsZWFzZSByZWxlYXNlKCl9IHdoZW4gdGhlIG1hcmtlZCByYW5nZSBpcyBubyBsb25nZXIgcmVxdWlyZWQuXHJcblx0ICovXHJcblx0bWFyaygpOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIHJlbGVhc2VzIGEgbWFya2VkIHJhbmdlIGNyZWF0ZWQgYnkgYSBjYWxsIHRvXHJcblx0ICoge0BsaW5rICNtYXJrIG1hcmsoKX0uIENhbGxzIHRvIGByZWxlYXNlKClgIG11c3QgYXBwZWFyIGluIHRoZVxyXG5cdCAqIHJldmVyc2Ugb3JkZXIgb2YgdGhlIGNvcnJlc3BvbmRpbmcgY2FsbHMgdG8gYG1hcmsoKWAuIElmIGEgbWFyayBpc1xyXG5cdCAqIHJlbGVhc2VkIHR3aWNlLCBvciBpZiBtYXJrcyBhcmUgbm90IHJlbGVhc2VkIGluIHJldmVyc2Ugb3JkZXIgb2YgdGhlXHJcblx0ICogY29ycmVzcG9uZGluZyBjYWxscyB0byBgbWFyaygpYCwgdGhlIGJlaGF2aW9yIGlzIHVuc3BlY2lmaWVkLlxyXG5cdCAqXHJcblx0ICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGFuIGV4YW1wbGUsIHNlZSB7QGxpbmsgI21hcmt9LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIG1hcmtlciBBIG1hcmtlciByZXR1cm5lZCBieSBhIGNhbGwgdG8gYG1hcmsoKWAuXHJcblx0ICogQHNlZSAjbWFya1xyXG5cdCAqL1xyXG5cdHJlbGVhc2UobWFya2VyOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGhlIGluZGV4IGludG8gdGhlIHN0cmVhbSBvZiB0aGUgaW5wdXQgc3ltYm9sIHJlZmVycmVkIHRvIGJ5XHJcblx0ICogYExBKDEpYC5cclxuXHQgKlxyXG5cdCAqIFRoZSBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZCBpcyB1bnNwZWNpZmllZCBpZiBubyBjYWxsIHRvIGFuXHJcblx0ICoge0BsaW5rIEludFN0cmVhbSBpbml0aWFsaXppbmcgbWV0aG9kfSBoYXMgb2NjdXJyZWQgYWZ0ZXIgdGhpcyBzdHJlYW0gd2FzXHJcblx0ICogY29uc3RydWN0ZWQuXHJcblx0ICovXHJcblx0cmVhZG9ubHkgaW5kZXg6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSBpbnB1dCBjdXJzb3IgdG8gdGhlIHBvc2l0aW9uIGluZGljYXRlZCBieSBgaW5kZXhgLiBJZiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgaW5kZXggbGllcyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmVhbSwgdGhlIG9wZXJhdGlvbiBiZWhhdmVzIGFzXHJcblx0ICogdGhvdWdoIGBpbmRleGAgd2FzIHRoZSBpbmRleCBvZiB0aGUgRU9GIHN5bWJvbC4gQWZ0ZXIgdGhpcyBtZXRob2RcclxuXHQgKiByZXR1cm5zIHdpdGhvdXQgdGhyb3dpbmcgYW4gZXhjZXB0aW9uLCB0aGVuIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nXHJcblx0ICogd2lsbCBiZSB0cnVlLlxyXG5cdCAqXHJcblx0ICogKiBgaW5kZXhgIHdpbGwgcmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3ltYm9sXHJcblx0ICogICBhcHBlYXJpbmcgYXQgb3IgYWZ0ZXIgdGhlIHNwZWNpZmllZCBgaW5kZXhgLiBTcGVjaWZpY2FsbHksXHJcblx0ICogICBpbXBsZW1lbnRhdGlvbnMgd2hpY2ggZmlsdGVyIHRoZWlyIHNvdXJjZXMgc2hvdWxkIGF1dG9tYXRpY2FsbHlcclxuXHQgKiAgIGFkanVzdCBgaW5kZXhgIGZvcndhcmQgdGhlIG1pbmltdW0gYW1vdW50IHJlcXVpcmVkIGZvciB0aGVcclxuXHQgKiAgIG9wZXJhdGlvbiB0byB0YXJnZXQgYSBub24taWdub3JlZCBzeW1ib2wuXHJcblx0ICogKiBgTEEoMSlgIHJldHVybnMge0BsaW5rICNFT0Z9XHJcblx0ICpcclxuXHQgKiBUaGlzIG9wZXJhdGlvbiBpcyBndWFyYW50ZWVkIHRvIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYGluZGV4YFxyXG5cdCAqIGxpZXMgd2l0aGluIGEgbWFya2VkIHJlZ2lvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gbWFya2VkIHJlZ2lvbnMsIHNlZVxyXG5cdCAqIHtAbGluayAjbWFya30uIFRoZSBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZCBpcyB1bnNwZWNpZmllZCBpZiBubyBjYWxsIHRvXHJcblx0ICogYW4ge0BsaW5rIEludFN0cmVhbSBpbml0aWFsaXppbmcgbWV0aG9kfSBoYXMgb2NjdXJyZWQgYWZ0ZXIgdGhpcyBzdHJlYW1cclxuXHQgKiB3YXMgY29uc3RydWN0ZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gaW5kZXggVGhlIGFic29sdXRlIGluZGV4IHRvIHNlZWsgdG8uXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBgaW5kZXhgIGlzIGxlc3MgdGhhbiAwXHJcblx0ICogQHRocm93cyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiBpZiB0aGUgc3RyZWFtIGRvZXMgbm90IHN1cHBvcnRcclxuXHQgKiBzZWVraW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuXHQgKi9cclxuXHRzZWVrKGluZGV4OiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2Ygc3ltYm9scyBpbiB0aGUgc3RyZWFtLCBpbmNsdWRpbmcgYSBzaW5nbGUgRU9GXHJcblx0ICogc3ltYm9sLlxyXG5cdCAqXHJcblx0ICogQHRocm93cyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiBpZiB0aGUgc2l6ZSBvZiB0aGUgc3RyZWFtIGlzXHJcblx0ICogdW5rbm93bi5cclxuXHQgKi9cclxuXHRyZWFkb25seSBzaXplOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIHVuZGVybHlpbmcgc3ltYm9sIHNvdXJjZS4gVGhpcyBtZXRob2QgcmV0dXJucyBhXHJcblx0ICogbm9uLXVuZGVmaW5lZCwgbm9uLWVtcHR5IHN0cmluZy4gSWYgc3VjaCBhIG5hbWUgaXMgbm90IGtub3duLCB0aGlzIG1ldGhvZFxyXG5cdCAqIHJldHVybnMge0BsaW5rICNVTktOT1dOX1NPVVJDRV9OQU1FfS5cclxuXHQgKi9cclxuXHQvL0BOb3ROdWxsXHJcblx0cmVhZG9ubHkgc291cmNlTmFtZTogc3RyaW5nO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ5LjA4Mjg3NDgtMDc6MDBcclxuXHJcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XHJcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiLi9DaGFyU3RyZWFtXCI7XHJcbmltcG9ydCB7IEFycmF5cyB9IGZyb20gXCIuL21pc2MvQXJyYXlzXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBJbnRTdHJlYW0gfSBmcm9tIFwiLi9JbnRTdHJlYW1cIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsXCI7XHJcblxyXG5jb25zdCBSRUFEX0JVRkZFUl9TSVpFOiBudW1iZXIgPSAxMDI0O1xyXG5jb25zdCBJTklUSUFMX0JVRkZFUl9TSVpFOiBudW1iZXIgPSAxMDI0O1xyXG5cclxuLyoqXHJcbiAqIFZhY3V1bSBhbGwgaW5wdXQgZnJvbSBhIHtAbGluayBSZWFkZXJ9L3tAbGluayBJbnB1dFN0cmVhbX0gYW5kIHRoZW4gdHJlYXQgaXRcclxuICogbGlrZSBhIGBjaGFyW11gIGJ1ZmZlci4gQ2FuIGFsc28gcGFzcyBpbiBhIHtAbGluayBTdHJpbmd9IG9yXHJcbiAqIGBjaGFyW11gIHRvIHVzZS5cclxuICpcclxuICogSWYgeW91IG5lZWQgZW5jb2RpbmcsIHBhc3MgaW4gc3RyZWFtL3JlYWRlciB3aXRoIGNvcnJlY3QgZW5jb2RpbmcuXHJcbiAqXHJcbiAqIEBkZXByZWNhdGVkIGFzIG9mIDQuNywgcGxlYXNlIHVzZSBgQ2hhclN0cmVhbXNgIGludGVyZmFjZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBTlRMUklucHV0U3RyZWFtIGltcGxlbWVudHMgQ2hhclN0cmVhbSB7XHJcblx0LyoqIFRoZSBkYXRhIGJlaW5nIHNjYW5uZWQgKi9cclxuXHRwcm90ZWN0ZWQgZGF0YTogc3RyaW5nO1xyXG5cclxuXHQvKiogSG93IG1hbnkgY2hhcmFjdGVycyBhcmUgYWN0dWFsbHkgaW4gdGhlIGJ1ZmZlciAqL1xyXG5cdHByb3RlY3RlZCBuOiBudW1iZXI7XHJcblxyXG5cdC8qKiAwLi5uLTEgaW5kZXggaW50byBzdHJpbmcgb2YgbmV4dCBjaGFyICovXHJcblx0cHJvdGVjdGVkIHA6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKiBXaGF0IGlzIG5hbWUgb3Igc291cmNlIG9mIHRoaXMgY2hhciBzdHJlYW0/ICovXHJcblx0cHVibGljIG5hbWU/OiBzdHJpbmc7XHJcblxyXG5cdC8qKiBDb3B5IGRhdGEgaW4gc3RyaW5nIHRvIGEgbG9jYWwgY2hhciBhcnJheSAqL1xyXG5cdGNvbnN0cnVjdG9yKGlucHV0OiBzdHJpbmcpIHtcclxuXHRcdHRoaXMuZGF0YSA9IGlucHV0O1xyXG5cdFx0dGhpcy5uID0gaW5wdXQubGVuZ3RoO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlc2V0IHRoZSBzdHJlYW0gc28gdGhhdCBpdCdzIGluIHRoZSBzYW1lIHN0YXRlIGl0IHdhc1xyXG5cdCAqICB3aGVuIHRoZSBvYmplY3Qgd2FzIGNyZWF0ZWQgKmV4Y2VwdCogdGhlIGRhdGEgYXJyYXkgaXMgbm90XHJcblx0ICogIHRvdWNoZWQuXHJcblx0ICovXHJcblx0cHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG5cdFx0dGhpcy5wID0gMDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjb25zdW1lKCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMucCA+PSB0aGlzLm4pIHtcclxuXHRcdFx0YXNzZXJ0KHRoaXMuTEEoMSkgPT09IEludFN0cmVhbS5FT0YpO1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29uc3VtZSBFT0ZcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9TeXN0ZW0ub3V0LnByaW50bG4oXCJwcmV2IHA9XCIrcCtcIiwgYz1cIisoY2hhcilkYXRhW3BdKTtcclxuXHRcdGlmICh0aGlzLnAgPCB0aGlzLm4pIHtcclxuXHRcdFx0dGhpcy5wKys7XHJcblx0XHRcdC8vU3lzdGVtLm91dC5wcmludGxuKFwicCBtb3ZlcyB0byBcIitwK1wiIChjPSdcIisoY2hhcilkYXRhW3BdK1wiJylcIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgTEEoaTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGlmIChpID09PSAwKSB7XHJcblx0XHRcdHJldHVybiAwOyAvLyB1bmRlZmluZWRcclxuXHRcdH1cclxuXHRcdGlmIChpIDwgMCkge1xyXG5cdFx0XHRpKys7IC8vIGUuZy4sIHRyYW5zbGF0ZSBMQSgtMSkgdG8gdXNlIG9mZnNldCBpPTA7IHRoZW4gZGF0YVtwKzAtMV1cclxuXHRcdFx0aWYgKCh0aGlzLnAgKyBpIC0gMSkgPCAwKSB7XHJcblx0XHRcdFx0cmV0dXJuIEludFN0cmVhbS5FT0Y7IC8vIGludmFsaWQ7IG5vIGNoYXIgYmVmb3JlIGZpcnN0IGNoYXJcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgodGhpcy5wICsgaSAtIDEpID49IHRoaXMubikge1xyXG5cdFx0XHQvL1N5c3RlbS5vdXQucHJpbnRsbihcImNoYXIgTEEoXCIraStcIik9RU9GOyBwPVwiK3ApO1xyXG5cdFx0XHRyZXR1cm4gSW50U3RyZWFtLkVPRjtcclxuXHRcdH1cclxuXHRcdC8vU3lzdGVtLm91dC5wcmludGxuKFwiY2hhciBMQShcIitpK1wiKT1cIisoY2hhcilkYXRhW3AraS0xXStcIjsgcD1cIitwKTtcclxuXHRcdC8vU3lzdGVtLm91dC5wcmludGxuKFwiTEEoXCIraStcIik7IHA9XCIrcCtcIiBuPVwiK24rXCIgZGF0YS5sZW5ndGg9XCIrZGF0YS5sZW5ndGgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucCArIGkgLSAxKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBMVChpOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuTEEoaSk7XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIHRoZSBjdXJyZW50IGlucHV0IHN5bWJvbCBpbmRleCAwLi5uIHdoZXJlIG4gaW5kaWNhdGVzIHRoZVxyXG5cdCAqICBsYXN0IHN5bWJvbCBoYXMgYmVlbiByZWFkLiAgVGhlIGluZGV4IGlzIHRoZSBpbmRleCBvZiBjaGFyIHRvXHJcblx0ICogIGJlIHJldHVybmVkIGZyb20gTEEoMSkuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5wO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNpemUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLm47XHJcblx0fVxyXG5cclxuXHQvKiogbWFyay9yZWxlYXNlIGRvIG5vdGhpbmc7IHdlIGhhdmUgZW50aXJlIGJ1ZmZlciAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBtYXJrKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVsZWFzZShtYXJrZXI6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Ly8gTm8gZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW5jZSB0aGlzIHN0cmVhbSBidWZmZXJzIHRoZSBlbnRpcmUgaW5wdXRcclxuXHR9XHJcblxyXG5cdC8qKiBjb25zdW1lKCkgYWhlYWQgdW50aWwgcD09aW5kZXg7IGNhbid0IGp1c3Qgc2V0IHA9aW5kZXggYXMgd2UgbXVzdFxyXG5cdCAqICB1cGRhdGUgbGluZSBhbmQgY2hhclBvc2l0aW9uSW5MaW5lLiBJZiB3ZSBzZWVrIGJhY2t3YXJkcywganVzdCBzZXQgcFxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBzZWVrKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmIChpbmRleCA8PSB0aGlzLnApIHtcclxuXHRcdFx0dGhpcy5wID0gaW5kZXg7IC8vIGp1c3QganVtcDsgZG9uJ3QgdXBkYXRlIHN0cmVhbSBzdGF0ZSAobGluZSwgLi4uKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHQvLyBzZWVrIGZvcndhcmQsIGNvbnN1bWUgdW50aWwgcCBoaXRzIGluZGV4IG9yIG4gKHdoaWNoZXZlciBjb21lcyBmaXJzdClcclxuXHRcdGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRoaXMubik7XHJcblx0XHR3aGlsZSAodGhpcy5wIDwgaW5kZXgpIHtcclxuXHRcdFx0dGhpcy5jb25zdW1lKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0VGV4dChpbnRlcnZhbDogSW50ZXJ2YWwpOiBzdHJpbmcge1xyXG5cdFx0bGV0IHN0YXJ0OiBudW1iZXIgPSBpbnRlcnZhbC5hO1xyXG5cdFx0bGV0IHN0b3A6IG51bWJlciA9IGludGVydmFsLmI7XHJcblx0XHRpZiAoc3RvcCA+PSB0aGlzLm4pIHtcclxuXHRcdFx0c3RvcCA9IHRoaXMubiAtIDE7XHJcblx0XHR9XHJcblx0XHRsZXQgY291bnQ6IG51bWJlciA9IHN0b3AgLSBzdGFydCArIDE7XHJcblx0XHRpZiAoc3RhcnQgPj0gdGhpcy5uKSB7XHJcblx0XHRcdHJldHVybiBcIlwiO1xyXG5cdFx0fVxyXG5cdFx0Ly8gU3lzdGVtLmVyci5wcmludGxuKFwiZGF0YTogXCIrQXJyYXlzLnRvU3RyaW5nKGRhdGEpK1wiLCBuPVwiK24rXHJcblx0XHQvLyBcdFx0XHRcdCAgIFwiLCBzdGFydD1cIitzdGFydCtcclxuXHRcdC8vIFx0XHRcdFx0ICAgXCIsIHN0b3A9XCIrc3RvcCk7XHJcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnN1YnN0cihzdGFydCwgY291bnQpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNvdXJjZU5hbWUoKTogc3RyaW5nIHtcclxuXHRcdGlmICghdGhpcy5uYW1lKSB7XHJcblx0XHRcdHJldHVybiBJbnRTdHJlYW0uVU5LTk9XTl9TT1VSQ0VfTkFNRTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLm5hbWU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmRhdGE7IH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjcuNDczNDMyOC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vQVROXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlVHlwZSB9IGZyb20gXCIuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbFNldCB9IGZyb20gXCIuLi9taXNjL0ludGVydmFsU2V0XCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCIuL1RyYW5zaXRpb25cIjtcclxuXHJcbmNvbnN0IElOSVRJQUxfTlVNX1RSQU5TSVRJT05TOiBudW1iZXIgPSA0O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBmb2xsb3dpbmcgaW1hZ2VzIHNob3cgdGhlIHJlbGF0aW9uIG9mIHN0YXRlcyBhbmRcclxuICoge0BsaW5rIEFUTlN0YXRlI3RyYW5zaXRpb25zfSBmb3IgdmFyaW91cyBncmFtbWFyIGNvbnN0cnVjdHMuXHJcbiAqXHJcbiAqICogU29saWQgZWRnZXMgbWFya2VkIHdpdGggYW4gJiMwOTQ5OyBpbmRpY2F0ZSBhIHJlcXVpcmVkXHJcbiAqICAge0BsaW5rIEVwc2lsb25UcmFuc2l0aW9ufS5cclxuICpcclxuICogKiBEYXNoZWQgZWRnZXMgaW5kaWNhdGUgbG9jYXRpb25zIHdoZXJlIGFueSB0cmFuc2l0aW9uIGRlcml2ZWQgZnJvbVxyXG4gKiAgIHtAbGluayBUcmFuc2l0aW9ufSBtaWdodCBhcHBlYXIuXHJcbiAqXHJcbiAqICogRGFzaGVkIG5vZGVzIGFyZSBwbGFjZSBob2xkZXJzIGZvciBlaXRoZXIgYSBzZXF1ZW5jZSBvZiBsaW5rZWRcclxuICogICB7QGxpbmsgQmFzaWNTdGF0ZX0gc3RhdGVzIG9yIHRoZSBpbmNsdXNpb24gb2YgYSBibG9jayByZXByZXNlbnRpbmcgYSBuZXN0ZWRcclxuICogICBjb25zdHJ1Y3QgaW4gb25lIG9mIHRoZSBmb3JtcyBiZWxvdy5cclxuICpcclxuICogKiBOb2RlcyBzaG93aW5nIG11bHRpcGxlIG91dGdvaW5nIGFsdGVybmF0aXZlcyB3aXRoIGEgYC4uLmAgc3VwcG9ydFxyXG4gKiAgIGFueSBudW1iZXIgb2YgYWx0ZXJuYXRpdmVzIChvbmUgb3IgbW9yZSkuIE5vZGVzIHdpdGhvdXQgdGhlIGAuLi5gIG9ubHlcclxuICogICBzdXBwb3J0IHRoZSBleGFjdCBudW1iZXIgb2YgYWx0ZXJuYXRpdmVzIHNob3duIGluIHRoZSBkaWFncmFtLlxyXG4gKlxyXG4gKiA8aDI+QmFzaWMgQmxvY2tzPC9oMj5cclxuICpcclxuICogPGgzPlJ1bGU8L2gzPlxyXG4gKlxyXG4gKiA8ZW1iZWQgc3JjPVwiaW1hZ2VzL1J1bGUuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+XHJcbiAqXHJcbiAqIDxoMz5CbG9jayBvZiAxIG9yIG1vcmUgYWx0ZXJuYXRpdmVzPC9oMz5cclxuICpcclxuICogPGVtYmVkIHNyYz1cImltYWdlcy9CbG9jay5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz5cclxuICpcclxuICogPGgyPkdyZWVkeSBMb29wczwvaDI+XHJcbiAqXHJcbiAqIDxoMz5HcmVlZHkgQ2xvc3VyZTogYCguLi4pKmA8L2gzPlxyXG4gKlxyXG4gKiA8ZW1iZWQgc3JjPVwiaW1hZ2VzL0Nsb3N1cmVHcmVlZHkuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+XHJcbiAqXHJcbiAqIDxoMz5HcmVlZHkgUG9zaXRpdmUgQ2xvc3VyZTogYCguLi4pK2A8L2gzPlxyXG4gKlxyXG4gKiA8ZW1iZWQgc3JjPVwiaW1hZ2VzL1Bvc2l0aXZlQ2xvc3VyZUdyZWVkeS5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz5cclxuICpcclxuICogPGgzPkdyZWVkeSBPcHRpb25hbDogYCguLi4pP2A8L2gzPlxyXG4gKlxyXG4gKiA8ZW1iZWQgc3JjPVwiaW1hZ2VzL09wdGlvbmFsR3JlZWR5LnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxyXG4gKlxyXG4gKiA8aDI+Tm9uLUdyZWVkeSBMb29wczwvaDI+XHJcbiAqXHJcbiAqIDxoMz5Ob24tR3JlZWR5IENsb3N1cmU6IGAoLi4uKSo/YDwvaDM+XHJcbiAqXHJcbiAqIDxlbWJlZCBzcmM9XCJpbWFnZXMvQ2xvc3VyZU5vbkdyZWVkeS5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz5cclxuICpcclxuICogPGgzPk5vbi1HcmVlZHkgUG9zaXRpdmUgQ2xvc3VyZTogYCguLi4pKz9gPC9oMz5cclxuICpcclxuICogPGVtYmVkIHNyYz1cImltYWdlcy9Qb3NpdGl2ZUNsb3N1cmVOb25HcmVlZHkuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+XHJcbiAqXHJcbiAqIDxoMz5Ob24tR3JlZWR5IE9wdGlvbmFsOiBgKC4uLik/P2A8L2gzPlxyXG4gKlxyXG4gKiA8ZW1iZWQgc3JjPVwiaW1hZ2VzL09wdGlvbmFsTm9uR3JlZWR5LnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFUTlN0YXRlIHtcclxuXHJcblx0LyoqIFdoaWNoIEFUTiBhcmUgd2UgaW4/ICovXHJcblx0cHVibGljIGF0bj86IEFUTjtcclxuXHJcblx0cHVibGljIHN0YXRlTnVtYmVyOiBudW1iZXIgPSBBVE5TdGF0ZS5JTlZBTElEX1NUQVRFX05VTUJFUjtcclxuXHJcblx0cHVibGljIHJ1bGVJbmRleDogbnVtYmVyID0gMDsgIC8vIGF0IHJ1bnRpbWUsIHdlIGRvbid0IGhhdmUgUnVsZSBvYmplY3RzXHJcblxyXG5cdHB1YmxpYyBlcHNpbG9uT25seVRyYW5zaXRpb25zOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdC8qKiBUcmFjayB0aGUgdHJhbnNpdGlvbnMgZW1hbmF0aW5nIGZyb20gdGhpcyBBVE4gc3RhdGUuICovXHJcblx0cHJvdGVjdGVkIHRyYW5zaXRpb25zOiBUcmFuc2l0aW9uW10gPSBbXTtcclxuXHJcblx0cHJvdGVjdGVkIG9wdGltaXplZFRyYW5zaXRpb25zOiBUcmFuc2l0aW9uW10gPSB0aGlzLnRyYW5zaXRpb25zO1xyXG5cclxuXHQvKiogVXNlZCB0byBjYWNoZSBsb29rYWhlYWQgZHVyaW5nIHBhcnNpbmcsIG5vdCB1c2VkIGR1cmluZyBjb25zdHJ1Y3Rpb24gKi9cclxuXHRwdWJsaWMgbmV4dFRva2VuV2l0aGluUnVsZT86IEludGVydmFsU2V0O1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBzdGF0ZSBudW1iZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB0aGUgc3RhdGUgbnVtYmVyXHJcblx0ICovXHJcblx0cHVibGljIGdldFN0YXRlTnVtYmVyKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZU51bWJlcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEZvciBhbGwgc3RhdGVzIGV4Y2VwdCB7QGxpbmsgUnVsZVN0b3BTdGF0ZX0sIHRoaXMgcmV0dXJucyB0aGUgc3RhdGVcclxuXHQgKiBudW1iZXIuIFJldHVybnMgLTEgZm9yIHN0b3Agc3RhdGVzLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgLTEgZm9yIHtAbGluayBSdWxlU3RvcFN0YXRlfSwgb3RoZXJ3aXNlIHRoZSBzdGF0ZSBudW1iZXJcclxuXHQgKi9cclxuXHRnZXQgbm9uU3RvcFN0YXRlTnVtYmVyKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRTdGF0ZU51bWJlcigpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZU51bWJlcjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMobzogYW55KTogYm9vbGVhbiB7XHJcblx0XHQvLyBhcmUgdGhlc2Ugc3RhdGVzIHNhbWUgb2JqZWN0P1xyXG5cdFx0aWYgKG8gaW5zdGFuY2VvZiBBVE5TdGF0ZSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZU51bWJlciA9PT0gby5zdGF0ZU51bWJlcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRnZXQgaXNOb25HcmVlZHlFeGl0U3RhdGUoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBTdHJpbmcodGhpcy5zdGF0ZU51bWJlcik7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0VHJhbnNpdGlvbnMoKTogVHJhbnNpdGlvbltdIHtcclxuXHRcdHJldHVybiB0aGlzLnRyYW5zaXRpb25zLnNsaWNlKDApO1xyXG5cdH1cclxuXHJcblx0Z2V0IG51bWJlck9mVHJhbnNpdGlvbnMoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLnRyYW5zaXRpb25zLmxlbmd0aDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhZGRUcmFuc2l0aW9uKGU6IFRyYW5zaXRpb24sIGluZGV4PzogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy50cmFuc2l0aW9ucy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0dGhpcy5lcHNpbG9uT25seVRyYW5zaXRpb25zID0gZS5pc0Vwc2lsb247XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmICh0aGlzLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgIT09IGUuaXNFcHNpbG9uKSB7XHJcblx0XHRcdHRoaXMuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyA9IGZhbHNlO1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBVE4gc3RhdGUgXCIgKyB0aGlzLnN0YXRlTnVtYmVyICsgXCIgaGFzIGJvdGggZXBzaWxvbiBhbmQgbm9uLWVwc2lsb24gdHJhbnNpdGlvbnMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudHJhbnNpdGlvbnMuc3BsaWNlKGluZGV4ICE9PSB1bmRlZmluZWQgPyBpbmRleCA6IHRoaXMudHJhbnNpdGlvbnMubGVuZ3RoLCAwLCBlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0cmFuc2l0aW9uKGk6IG51bWJlcik6IFRyYW5zaXRpb24ge1xyXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNpdGlvbnNbaV07XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0VHJhbnNpdGlvbihpOiBudW1iZXIsIGU6IFRyYW5zaXRpb24pOiB2b2lkIHtcclxuXHRcdHRoaXMudHJhbnNpdGlvbnNbaV0gPSBlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlbW92ZVRyYW5zaXRpb24oaW5kZXg6IG51bWJlcik6IFRyYW5zaXRpb24ge1xyXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNpdGlvbnMuc3BsaWNlKGluZGV4LCAxKVswXTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBzdGF0ZVR5cGU6IEFUTlN0YXRlVHlwZTtcclxuXHJcblx0Z2V0IG9ubHlIYXNFcHNpbG9uVHJhbnNpdGlvbnMoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5lcHNpbG9uT25seVRyYW5zaXRpb25zO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldFJ1bGVJbmRleChydWxlSW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XHJcblx0fVxyXG5cclxuXHRnZXQgaXNPcHRpbWl6ZWQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpbWl6ZWRUcmFuc2l0aW9ucyAhPT0gdGhpcy50cmFuc2l0aW9ucztcclxuXHR9XHJcblxyXG5cdGdldCBudW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpbWl6ZWRUcmFuc2l0aW9ucy5sZW5ndGg7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihpOiBudW1iZXIpOiBUcmFuc2l0aW9uIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGltaXplZFRyYW5zaXRpb25zW2ldO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFkZE9wdGltaXplZFRyYW5zaXRpb24oZTogVHJhbnNpdGlvbik6IHZvaWQge1xyXG5cdFx0aWYgKCF0aGlzLmlzT3B0aW1pemVkKSB7XHJcblx0XHRcdHRoaXMub3B0aW1pemVkVHJhbnNpdGlvbnMgPSBuZXcgQXJyYXk8VHJhbnNpdGlvbj4oKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGltaXplZFRyYW5zaXRpb25zLnB1c2goZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0T3B0aW1pemVkVHJhbnNpdGlvbihpOiBudW1iZXIsIGU6IFRyYW5zaXRpb24pOiB2b2lkIHtcclxuXHRcdGlmICghdGhpcy5pc09wdGltaXplZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEFUTlN0YXRlIGlzIG5vdCBvcHRpbWl6ZWQuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW1pemVkVHJhbnNpdGlvbnNbaV0gPSBlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlbW92ZU9wdGltaXplZFRyYW5zaXRpb24oaTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAoIXRoaXMuaXNPcHRpbWl6ZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhpcyBBVE5TdGF0ZSBpcyBub3Qgb3B0aW1pemVkLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGltaXplZFRyYW5zaXRpb25zLnNwbGljZShpLCAxKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgQVROU3RhdGUge1xyXG5cdGV4cG9ydCBjb25zdCBJTlZBTElEX1NUQVRFX05VTUJFUjogbnVtYmVyID0gLTE7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI3LjQ3MzQzMjgtMDc6MDBcclxuXHJcbmV4cG9ydCBlbnVtIEFUTlN0YXRlVHlwZSB7XHJcblx0SU5WQUxJRF9UWVBFID0gMCxcclxuXHRCQVNJQyA9IDEsXHJcblx0UlVMRV9TVEFSVCA9IDIsXHJcblx0QkxPQ0tfU1RBUlQgPSAzLFxyXG5cdFBMVVNfQkxPQ0tfU1RBUlQgPSA0LFxyXG5cdFNUQVJfQkxPQ0tfU1RBUlQgPSA1LFxyXG5cdFRPS0VOX1NUQVJUID0gNixcclxuXHRSVUxFX1NUT1AgPSA3LFxyXG5cdEJMT0NLX0VORCA9IDgsXHJcblx0U1RBUl9MT09QX0JBQ0sgPSA5LFxyXG5cdFNUQVJfTE9PUF9FTlRSWSA9IDEwLFxyXG5cdFBMVVNfTE9PUF9CQUNLID0gMTEsXHJcblx0TE9PUF9FTkQgPSAxMixcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTcuMDY5NzY3NC0wNzowMFxyXG5pbXBvcnQgeyBDaGFyU3RyZWFtIH0gZnJvbSBcIi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbFNldCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxTZXRcIjtcclxuaW1wb3J0IHsgSW50U3RyZWFtIH0gZnJvbSBcIi4vSW50U3RyZWFtXCI7XHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4vTGV4ZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUmVjb2duaXplciB9IGZyb20gXCIuL1JlY29nbml6ZXJcIjtcclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9SdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcblxyXG5cclxuLyoqIFRoZSByb290IG9mIHRoZSBBTlRMUiBleGNlcHRpb24gaGllcmFyY2h5LiBJbiBnZW5lcmFsLCBBTlRMUiB0cmFja3MganVzdFxyXG4gKiAgMyBraW5kcyBvZiBlcnJvcnM6IHByZWRpY3Rpb24gZXJyb3JzLCBmYWlsZWQgcHJlZGljYXRlIGVycm9ycywgYW5kXHJcbiAqICBtaXNtYXRjaGVkIGlucHV0IGVycm9ycy4gSW4gZWFjaCBjYXNlLCB0aGUgcGFyc2VyIGtub3dzIHdoZXJlIGl0IGlzXHJcbiAqICBpbiB0aGUgaW5wdXQsIHdoZXJlIGl0IGlzIGluIHRoZSBBVE4sIHRoZSBydWxlIGludm9jYXRpb24gc3RhY2ssXHJcbiAqICBhbmQgd2hhdCBraW5kIG9mIHByb2JsZW0gb2NjdXJyZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVjb2duaXRpb25FeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XHJcblx0Ly8gcHJpdmF0ZSBzdGF0aWMgc2VyaWFsVmVyc2lvblVJRDogbnVtYmVyID0gIC0zODYxODI2OTU0NzUwMDIyMzc0TDtcclxuXHJcblx0LyoqIFRoZSB7QGxpbmsgUmVjb2duaXplcn0gd2hlcmUgdGhpcyBleGNlcHRpb24gb3JpZ2luYXRlZC4gKi9cclxuXHRwcml2YXRlIF9yZWNvZ25pemVyPzogUmVjb2duaXplcjxhbnksIGFueT47XHJcblxyXG5cdHByaXZhdGUgY3R4PzogUnVsZUNvbnRleHQ7XHJcblxyXG5cdHByaXZhdGUgaW5wdXQ/OiBJbnRTdHJlYW07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBjdXJyZW50IHtAbGluayBUb2tlbn0gd2hlbiBhbiBlcnJvciBvY2N1cnJlZC4gU2luY2Ugbm90IGFsbCBzdHJlYW1zXHJcblx0ICogc3VwcG9ydCBhY2Nlc3Npbmcgc3ltYm9scyBieSBpbmRleCwgd2UgaGF2ZSB0byB0cmFjayB0aGUge0BsaW5rIFRva2VufVxyXG5cdCAqIGluc3RhbmNlIGl0c2VsZi5cclxuXHQgKi9cclxuXHRwcml2YXRlIG9mZmVuZGluZ1Rva2VuPzogVG9rZW47XHJcblxyXG5cdHByaXZhdGUgX29mZmVuZGluZ1N0YXRlOiBudW1iZXIgPSAtMTtcclxuXHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRsZXhlcjogTGV4ZXIgfCB1bmRlZmluZWQsXHJcblx0XHRpbnB1dDogQ2hhclN0cmVhbSk7XHJcblxyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0cmVjb2duaXplcjogUmVjb2duaXplcjxUb2tlbiwgYW55PiB8IHVuZGVmaW5lZCxcclxuXHRcdGlucHV0OiBJbnRTdHJlYW0gfCB1bmRlZmluZWQsXHJcblx0XHRjdHg6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkKTtcclxuXHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRyZWNvZ25pemVyOiBSZWNvZ25pemVyPFRva2VuLCBhbnk+IHwgdW5kZWZpbmVkLFxyXG5cdFx0aW5wdXQ6IEludFN0cmVhbSB8IHVuZGVmaW5lZCxcclxuXHRcdGN0eDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsXHJcblx0XHRtZXNzYWdlOiBzdHJpbmcpO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdHJlY29nbml6ZXI6IExleGVyIHwgUmVjb2duaXplcjxUb2tlbiwgYW55PiB8IHVuZGVmaW5lZCxcclxuXHRcdGlucHV0OiBDaGFyU3RyZWFtIHwgSW50U3RyZWFtIHwgdW5kZWZpbmVkLFxyXG5cdFx0Y3R4PzogUGFyc2VyUnVsZUNvbnRleHQsXHJcblx0XHRtZXNzYWdlPzogc3RyaW5nKSB7XHJcblx0XHRzdXBlcihtZXNzYWdlKTtcclxuXHJcblx0XHR0aGlzLl9yZWNvZ25pemVyID0gcmVjb2duaXplcjtcclxuXHRcdHRoaXMuaW5wdXQgPSBpbnB1dDtcclxuXHRcdHRoaXMuY3R4ID0gY3R4O1xyXG5cdFx0aWYgKHJlY29nbml6ZXIpIHtcclxuXHRcdFx0dGhpcy5fb2ZmZW5kaW5nU3RhdGUgPSByZWNvZ25pemVyLnN0YXRlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBBVE4gc3RhdGUgbnVtYmVyIHRoZSBwYXJzZXIgd2FzIGluIGF0IHRoZSB0aW1lIHRoZSBlcnJvclxyXG5cdCAqIG9jY3VycmVkLiBGb3Ige0BsaW5rIE5vVmlhYmxlQWx0RXhjZXB0aW9ufSBhbmRcclxuXHQgKiB7QGxpbmsgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbn0gZXhjZXB0aW9ucywgdGhpcyBpcyB0aGVcclxuXHQgKiB7QGxpbmsgRGVjaXNpb25TdGF0ZX0gbnVtYmVyLiBGb3Igb3RoZXJzLCBpdCBpcyB0aGUgc3RhdGUgd2hvc2Ugb3V0Z29pbmdcclxuXHQgKiBlZGdlIHdlIGNvdWxkbid0IG1hdGNoLlxyXG5cdCAqXHJcblx0ICogSWYgdGhlIHN0YXRlIG51bWJlciBpcyBub3Qga25vd24sIHRoaXMgbWV0aG9kIHJldHVybnMgLTEuXHJcblx0ICovXHJcblx0Z2V0IG9mZmVuZGluZ1N0YXRlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fb2ZmZW5kaW5nU3RhdGU7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgc2V0T2ZmZW5kaW5nU3RhdGUob2ZmZW5kaW5nU3RhdGU6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5fb2ZmZW5kaW5nU3RhdGUgPSBvZmZlbmRpbmdTdGF0ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHNldCBvZiBpbnB1dCBzeW1ib2xzIHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IGZvbGxvdyB0aGVcclxuXHQgKiBwcmV2aW91c2x5IG1hdGNoZWQgc3ltYm9sIGF0IHRoZSB0aW1lIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24uXHJcblx0ICpcclxuXHQgKiBJZiB0aGUgc2V0IG9mIGV4cGVjdGVkIHRva2VucyBpcyBub3Qga25vd24gYW5kIGNvdWxkIG5vdCBiZSBjb21wdXRlZCxcclxuXHQgKiB0aGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIHNldCBvZiB0b2tlbiB0eXBlcyB0aGF0IGNvdWxkIHBvdGVudGlhbGx5IGZvbGxvdyB0aGUgY3VycmVudFxyXG5cdCAqIHN0YXRlIGluIHRoZSBBVE4sIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBpbmZvcm1hdGlvbiBpcyBub3QgYXZhaWxhYmxlLlxyXG5cdCAqL1xyXG5cdGdldCBleHBlY3RlZFRva2VucygpOiBJbnRlcnZhbFNldCB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAodGhpcy5fcmVjb2duaXplcikge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVjb2duaXplci5hdG4uZ2V0RXhwZWN0ZWRUb2tlbnModGhpcy5fb2ZmZW5kaW5nU3RhdGUsIHRoaXMuY3R4KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB7QGxpbmsgUnVsZUNvbnRleHR9IGF0IHRoZSB0aW1lIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24uXHJcblx0ICpcclxuXHQgKiBJZiB0aGUgY29udGV4dCBpcyBub3QgYXZhaWxhYmxlLCB0aGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIHtAbGluayBSdWxlQ29udGV4dH0gYXQgdGhlIHRpbWUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93bi5cclxuXHQgKiBJZiB0aGUgY29udGV4dCBpcyBub3QgYXZhaWxhYmxlLCB0aGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG5cdCAqL1xyXG5cdGdldCBjb250ZXh0KCk6IFJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLmN0eDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGlucHV0IHN0cmVhbSB3aGljaCBpcyB0aGUgc3ltYm9sIHNvdXJjZSBmb3IgdGhlIHJlY29nbml6ZXIgd2hlcmVcclxuXHQgKiB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxyXG5cdCAqXHJcblx0ICogSWYgdGhlIGlucHV0IHN0cmVhbSBpcyBub3QgYXZhaWxhYmxlLCB0aGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIGlucHV0IHN0cmVhbSB3aGljaCBpcyB0aGUgc3ltYm9sIHNvdXJjZSBmb3IgdGhlIHJlY29nbml6ZXJcclxuXHQgKiB3aGVyZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgc3RyZWFtIGlzIG5vdFxyXG5cdCAqIGF2YWlsYWJsZS5cclxuXHQgKi9cclxuXHJcblx0Z2V0IGlucHV0U3RyZWFtKCk6IEludFN0cmVhbSB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnB1dDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRPZmZlbmRpbmdUb2tlbihyZWNvZ25pemVyPzogUmVjb2duaXplcjxUb2tlbiwgYW55Pik6IFRva2VuIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmIChyZWNvZ25pemVyICYmIHJlY29nbml6ZXIgIT09IHRoaXMuX3JlY29nbml6ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLm9mZmVuZGluZ1Rva2VuO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHNldE9mZmVuZGluZ1Rva2VuPFRTeW1ib2wgZXh0ZW5kcyBUb2tlbj4oXHJcblx0XHRyZWNvZ25pemVyOiBSZWNvZ25pemVyPFRTeW1ib2wsIGFueT4sXHJcblx0XHRvZmZlbmRpbmdUb2tlbj86IFRTeW1ib2wpOiB2b2lkIHtcclxuXHRcdGlmIChyZWNvZ25pemVyID09PSB0aGlzLl9yZWNvZ25pemVyKSB7XHJcblx0XHRcdHRoaXMub2ZmZW5kaW5nVG9rZW4gPSBvZmZlbmRpbmdUb2tlbjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHtAbGluayBSZWNvZ25pemVyfSB3aGVyZSB0aGlzIGV4Y2VwdGlvbiBvY2N1cnJlZC5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSByZWNvZ25pemVyIGlzIG5vdCBhdmFpbGFibGUsIHRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgcmVjb2duaXplciB3aGVyZSB0aGlzIGV4Y2VwdGlvbiBvY2N1cnJlZCwgb3IgYHVuZGVmaW5lZGAgaWZcclxuXHQgKiB0aGUgcmVjb2duaXplciBpcyBub3QgYXZhaWxhYmxlLlxyXG5cdCAqL1xyXG5cdGdldCByZWNvZ25pemVyKCk6IFJlY29nbml6ZXI8YW55LCBhbnk+IHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLl9yZWNvZ25pemVyO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzcuODUzMDQ5Ni0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbFNldCB9IGZyb20gXCIuLi9taXNjL0ludGVydmFsU2V0XCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcblxyXG4vKiogQW4gQVROIHRyYW5zaXRpb24gYmV0d2VlbiBhbnkgdHdvIEFUTiBzdGF0ZXMuICBTdWJjbGFzc2VzIGRlZmluZVxyXG4gKiAgYXRvbSwgc2V0LCBlcHNpbG9uLCBhY3Rpb24sIHByZWRpY2F0ZSwgcnVsZSB0cmFuc2l0aW9ucy5cclxuICpcclxuICogIFRoaXMgaXMgYSBvbmUgd2F5IGxpbmsuICBJdCBlbWFuYXRlcyBmcm9tIGEgc3RhdGUgKHVzdWFsbHkgdmlhIGEgbGlzdCBvZlxyXG4gKiAgdHJhbnNpdGlvbnMpIGFuZCBoYXMgYSB0YXJnZXQgc3RhdGUuXHJcbiAqXHJcbiAqICBTaW5jZSB3ZSBuZXZlciBoYXZlIHRvIGNoYW5nZSB0aGUgQVROIHRyYW5zaXRpb25zIG9uY2Ugd2UgY29uc3RydWN0IGl0LFxyXG4gKiAgd2UgY2FuIGZpeCB0aGVzZSB0cmFuc2l0aW9ucyBhcyBzcGVjaWZpYyBjbGFzc2VzLiBUaGUgREZBIHRyYW5zaXRpb25zXHJcbiAqICBvbiB0aGUgb3RoZXIgaGFuZCBuZWVkIHRvIHVwZGF0ZSB0aGUgbGFiZWxzIGFzIGl0IGFkZHMgdHJhbnNpdGlvbnMgdG9cclxuICogIHRoZSBzdGF0ZXMuIFdlJ2xsIHVzZSB0aGUgdGVybSBFZGdlIGZvciB0aGUgREZBIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbVxyXG4gKiAgQVROIHRyYW5zaXRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRyYW5zaXRpb24ge1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgc2VyaWFsaXphdGlvbk5hbWVzOiBzdHJpbmdbXSA9IFtcclxuXHRcdFwiSU5WQUxJRFwiLFxyXG5cdFx0XCJFUFNJTE9OXCIsXHJcblx0XHRcIlJBTkdFXCIsXHJcblx0XHRcIlJVTEVcIixcclxuXHRcdFwiUFJFRElDQVRFXCIsXHJcblx0XHRcIkFUT01cIixcclxuXHRcdFwiQUNUSU9OXCIsXHJcblx0XHRcIlNFVFwiLFxyXG5cdFx0XCJOT1RfU0VUXCIsXHJcblx0XHRcIldJTERDQVJEXCIsXHJcblx0XHRcIlBSRUNFREVOQ0VcIixcclxuXHRdO1xyXG5cclxuXHQvLyBAU3VwcHJlc3NXYXJuaW5ncyhcInNlcmlhbFwiKVxyXG5cdC8vIHN0YXRpYyBzZXJpYWxpemF0aW9uVHlwZXM6IE1hcDxDbGFzczw/IGV4dGVuZHMgVHJhbnNpdGlvbj4sIG51bWJlcj4gPVxyXG5cdC8vIFx0Q29sbGVjdGlvbnMudW5tb2RpZmlhYmxlTWFwKG5ldyBIYXNoTWFwPENsYXNzPD8gZXh0ZW5kcyBUcmFuc2l0aW9uPiwgSW50ZWdlcj4oKSB7e1xyXG5cdC8vIFx0XHRwdXQoRXBzaWxvblRyYW5zaXRpb24uY2xhc3MsIEVQU0lMT04pO1xyXG5cdC8vIFx0XHRwdXQoUmFuZ2VUcmFuc2l0aW9uLmNsYXNzLCBSQU5HRSk7XHJcblx0Ly8gXHRcdHB1dChSdWxlVHJhbnNpdGlvbi5jbGFzcywgUlVMRSk7XHJcblx0Ly8gXHRcdHB1dChQcmVkaWNhdGVUcmFuc2l0aW9uLmNsYXNzLCBQUkVESUNBVEUpO1xyXG5cdC8vIFx0XHRwdXQoQXRvbVRyYW5zaXRpb24uY2xhc3MsIEFUT00pO1xyXG5cdC8vIFx0XHRwdXQoQWN0aW9uVHJhbnNpdGlvbi5jbGFzcywgQUNUSU9OKTtcclxuXHQvLyBcdFx0cHV0KFNldFRyYW5zaXRpb24uY2xhc3MsIFNFVCk7XHJcblx0Ly8gXHRcdHB1dChOb3RTZXRUcmFuc2l0aW9uLmNsYXNzLCBOT1RfU0VUKTtcclxuXHQvLyBcdFx0cHV0KFdpbGRjYXJkVHJhbnNpdGlvbi5jbGFzcywgV0lMRENBUkQpO1xyXG5cdC8vIFx0XHRwdXQoUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24uY2xhc3MsIFBSRUNFREVOQ0UpO1xyXG5cdC8vIFx0fX0pO1xyXG5cclxuXHQvKiogVGhlIHRhcmdldCBvZiB0aGlzIHRyYW5zaXRpb24uICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgdGFyZ2V0OiBBVE5TdGF0ZTtcclxuXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgdGFyZ2V0OiBBVE5TdGF0ZSkge1xyXG5cdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInRhcmdldCBjYW5ub3QgYmUgbnVsbC5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgc2VyaWFsaXphdGlvblR5cGU6IFRyYW5zaXRpb25UeXBlO1xyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGFuIFwiZXBzaWxvblwiIHRyYW5zaXRpb24uXHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWAuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdHJhdmVyc2luZyB0aGlzIHRyYW5zaXRpb24gaW4gdGhlIEFUTiBkb2VzIG5vdFxyXG5cdCAqIGNvbnN1bWUgYW4gaW5wdXQgc3ltYm9sOyBvdGhlcndpc2UsIGBmYWxzZWAgaWYgdHJhdmVyc2luZyB0aGlzXHJcblx0ICogdHJhbnNpdGlvbiBjb25zdW1lcyAobWF0Y2hlcykgYW4gaW5wdXQgc3ltYm9sLlxyXG5cdCAqL1xyXG5cdGdldCBpc0Vwc2lsb24oKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRnZXQgbGFiZWwoKTogSW50ZXJ2YWxTZXQgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCBtYXRjaGVzKHN5bWJvbDogbnVtYmVyLCBtaW5Wb2NhYlN5bWJvbDogbnVtYmVyLCBtYXhWb2NhYlN5bWJvbDogbnVtYmVyKTogYm9vbGVhbjtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjQuNjU5NjE3Ny0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24gZXh0ZW5kcyBUcmFuc2l0aW9uIHtcclxuXHJcblx0Y29uc3RydWN0b3IodGFyZ2V0OiBBVE5TdGF0ZSkge1xyXG5cdFx0c3VwZXIodGFyZ2V0KTtcclxuXHR9XHJcblxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wM1QwMjowOTo0Mi4xMjM5NjYwLTA3OjAwXHJcbmltcG9ydCB7IEVxdWF0YWJsZSB9IGZyb20gXCIuL1N0dWJzXCI7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IG5hbWVzcGFjZSBNdXJtdXJIYXNoIHtcclxuXHJcblx0Y29uc3QgREVGQVVMVF9TRUVEOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBoYXNoIHVzaW5nIHRoZSBzcGVjaWZpZWQgYHNlZWRgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHNlZWQgdGhlIHNlZWQgKG9wdGlvbmFsKVxyXG5cdCAqIEByZXR1cm5zIHRoZSBpbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxyXG5cdCAqL1xyXG5cdGV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplKHNlZWQ6IG51bWJlciA9IERFRkFVTFRfU0VFRCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gc2VlZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgaW50ZXJtZWRpYXRlIGhhc2ggdmFsdWUgZm9yIHRoZSBuZXh0IGlucHV0IGB2YWx1ZWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gaGFzaCB0aGUgaW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcclxuXHQgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGFkZCB0byB0aGUgY3VycmVudCBoYXNoXHJcblx0ICogQHJldHVybnMgdGhlIHVwZGF0ZWQgaW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcclxuXHQgKi9cclxuXHRleHBvcnQgZnVuY3Rpb24gdXBkYXRlKGhhc2g6IG51bWJlciwgdmFsdWU6IG51bWJlciB8IHN0cmluZyB8IEVxdWF0YWJsZSB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgYzE6IG51bWJlciA9IDB4Q0M5RTJENTE7XHJcblx0XHRjb25zdCBjMjogbnVtYmVyID0gMHgxQjg3MzU5MztcclxuXHRcdGNvbnN0IHIxOiBudW1iZXIgPSAxNTtcclxuXHRcdGNvbnN0IHIyOiBudW1iZXIgPSAxMztcclxuXHRcdGNvbnN0IG06IG51bWJlciA9IDU7XHJcblx0XHRjb25zdCBuOiBudW1iZXIgPSAweEU2NTQ2QjY0O1xyXG5cclxuXHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcblx0XHRcdHZhbHVlID0gMDtcclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdHZhbHVlID0gaGFzaFN0cmluZyh2YWx1ZSk7XHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLmhhc2hDb2RlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGs6IG51bWJlciA9IHZhbHVlO1xyXG5cdFx0ayA9IE1hdGguaW11bChrLCBjMSk7XHJcblx0XHRrID0gKGsgPDwgcjEpIHwgKGsgPj4+ICgzMiAtIHIxKSk7XHJcblx0XHRrID0gTWF0aC5pbXVsKGssIGMyKTtcclxuXHJcblx0XHRoYXNoID0gaGFzaCBeIGs7XHJcblx0XHRoYXNoID0gKGhhc2ggPDwgcjIpIHwgKGhhc2ggPj4+ICgzMiAtIHIyKSk7XHJcblx0XHRoYXNoID0gTWF0aC5pbXVsKGhhc2gsIG0pICsgbjtcclxuXHJcblx0XHRyZXR1cm4gaGFzaCAmIDB4RkZGRkZGRkY7XHJcblx0fVxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQXBwbHkgdGhlIGZpbmFsIGNvbXB1dGF0aW9uIHN0ZXBzIHRvIHRoZSBpbnRlcm1lZGlhdGUgdmFsdWUgYGhhc2hgXHJcblx0ICogdG8gZm9ybSB0aGUgZmluYWwgcmVzdWx0IG9mIHRoZSBNdXJtdXJIYXNoIDMgaGFzaCBmdW5jdGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBoYXNoIHRoZSBpbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSBudW1iZXJPZldvcmRzIHRoZSBudW1iZXIgb2YgaW50ZWdlciB2YWx1ZXMgYWRkZWQgdG8gdGhlIGhhc2hcclxuXHQgKiBAcmV0dXJucyB0aGUgZmluYWwgaGFzaCByZXN1bHRcclxuXHQgKi9cclxuXHRleHBvcnQgZnVuY3Rpb24gZmluaXNoKGhhc2g6IG51bWJlciwgbnVtYmVyT2ZXb3JkczogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGhhc2ggPSBoYXNoIF4gKG51bWJlck9mV29yZHMgKiA0KTtcclxuXHRcdGhhc2ggPSBoYXNoIF4gKGhhc2ggPj4+IDE2KTtcclxuXHRcdGhhc2ggPSBNYXRoLmltdWwoaGFzaCwgMHg4NUVCQ0E2Qik7XHJcblx0XHRoYXNoID0gaGFzaCBeIChoYXNoID4+PiAxMyk7XHJcblx0XHRoYXNoID0gTWF0aC5pbXVsKGhhc2gsIDB4QzJCMkFFMzUpO1xyXG5cdFx0aGFzaCA9IGhhc2ggXiAoaGFzaCA+Pj4gMTYpO1xyXG5cdFx0cmV0dXJuIGhhc2g7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNvbXB1dGUgdGhlIGhhc2ggY29kZSBvZiBhbiBhcnJheSB1c2luZyB0aGVcclxuXHQgKiBNdXJtdXJIYXNoIGFsZ29yaXRobS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSA8VD4gdGhlIGFycmF5IGVsZW1lbnQgdHlwZVxyXG5cdCAqIEBwYXJhbSBkYXRhIHRoZSBhcnJheSBkYXRhXHJcblx0ICogQHBhcmFtIHNlZWQgdGhlIHNlZWQgZm9yIHRoZSBNdXJtdXJIYXNoIGFsZ29yaXRobVxyXG5cdCAqIEByZXR1cm5zIHRoZSBoYXNoIGNvZGUgb2YgdGhlIGRhdGFcclxuXHQgKi9cclxuXHRleHBvcnQgZnVuY3Rpb24gaGFzaENvZGU8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZyB8IEVxdWF0YWJsZT4oZGF0YTogSXRlcmFibGU8VD4sIHNlZWQ6IG51bWJlciA9IERFRkFVTFRfU0VFRCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gaW5pdGlhbGl6ZShzZWVkKTtcclxuXHRcdGxldCBsZW5ndGggPSAwO1xyXG5cdFx0Zm9yIChsZXQgdmFsdWUgb2YgZGF0YSkge1xyXG5cdFx0XHRoYXNoID0gdXBkYXRlKGhhc2gsIHZhbHVlKTtcclxuXHRcdFx0bGVuZ3RoKys7XHJcblx0XHR9XHJcblxyXG5cdFx0aGFzaCA9IGZpbmlzaChoYXNoLCBsZW5ndGgpO1xyXG5cdFx0cmV0dXJuIGhhc2g7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBGdW5jdGlvbiB0byBoYXNoIGEgc3RyaW5nLiBCYXNlZCBvbiB0aGUgaW1wbGVtZW50YXRpb24gZm91bmQgaGVyZTpcclxuXHQgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83NjE2NDg0XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gaGFzaFN0cmluZyhzdHI6IHN0cmluZyk6IG51bWJlciB7XHJcblx0XHRsZXQgbGVuID0gc3RyLmxlbmd0aDtcclxuXHRcdGlmIChsZW4gPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGhhc2ggPSAwO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG5cdFx0XHRoYXNoID0gKCgoaGFzaCA8PCA1KSA+Pj4gMCkgLSBoYXNoKSArIGM7XHJcblx0XHRcdGhhc2ggfD0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaGFzaDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTAzVDAyOjA5OjQyLjIxMjcyNjAtMDc6MDBcclxuaW1wb3J0IHsgRXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4vRXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgRXF1YXRhYmxlIH0gZnJvbSBcIi4vU3R1YnNcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIEVxdWFsaXR5Q29tcGFyYXRvcn0gdXNlcyBvYmplY3QgZXF1YWxpdHlcclxuICogZm9yIGNvbXBhcmlzb25zIGJ5IGNhbGxpbmcge0BsaW5rIE9iamVjdCNoYXNoQ29kZX0gYW5kIHtAbGluayBPYmplY3QjZXF1YWxzfS5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvciBpbXBsZW1lbnRzIEVxdWFsaXR5Q29tcGFyYXRvcjxFcXVhdGFibGUgfCBudWxsIHwgdW5kZWZpbmVkPiB7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBJTlNUQU5DRTogT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yID0gbmV3IE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvcigpO1xyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGltcGxlbWVudGF0aW9uIHJldHVybnNcclxuXHQgKiBgb2JqLmB7QGxpbmsgT2JqZWN0I2hhc2hDb2RlIGhhc2hDb2RlKCl9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZShvYmo6IEVxdWF0YWJsZSB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIge1xyXG5cdFx0aWYgKG9iaiA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvYmouaGFzaENvZGUoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoaXMgaW1wbGVtZW50YXRpb24gcmVsaWVzIG9uIG9iamVjdCBlcXVhbGl0eS4gSWYgYm90aCBvYmplY3RzIGFyZVxyXG5cdCAqIGB1bmRlZmluZWRgIG9yIGBudWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuIE90aGVyd2lzZSBpZiBvbmx5XHJcblx0ICogYGFgIGlzIGB1bmRlZmluZWRgIG9yIGBudWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLiBPdGhlcndpc2UsXHJcblx0ICogdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgcmVzdWx0IG9mXHJcblx0ICogYGEuYHtAbGluayBPYmplY3QjZXF1YWxzIGVxdWFsc31gKGIpYC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKGE6IEVxdWF0YWJsZSB8IG51bGwgfCB1bmRlZmluZWQsIGI6IEVxdWF0YWJsZSB8IG51bGwgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcclxuXHRcdGlmIChhID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIGIgPT0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYS5lcXVhbHMoYik7XHJcblx0fVxyXG5cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG5pbXBvcnQgeyBFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi9FcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBFcXVhdGFibGUgfSBmcm9tIFwiLi9TdHVic1wiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4vTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIEVxdWFsaXR5Q29tcGFyYXRvcn0gdXNlcyBvYmplY3QgZXF1YWxpdHlcclxuICogZm9yIGNvbXBhcmlzb25zIGJ5IGNhbGxpbmcge0BsaW5rIE9iamVjdCNoYXNoQ29kZX0gYW5kIHtAbGluayBPYmplY3QjZXF1YWxzfS5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERlZmF1bHRFcXVhbGl0eUNvbXBhcmF0b3IgaW1wbGVtZW50cyBFcXVhbGl0eUNvbXBhcmF0b3I8YW55PiB7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBJTlNUQU5DRTogRGVmYXVsdEVxdWFsaXR5Q29tcGFyYXRvciA9IG5ldyBEZWZhdWx0RXF1YWxpdHlDb21wYXJhdG9yKCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoaXMgaW1wbGVtZW50YXRpb24gcmV0dXJuc1xyXG5cdCAqIGBvYmouYHtAbGluayBPYmplY3QjaGFzaENvZGUgaGFzaENvZGUoKX0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKG9iajogYW55KTogbnVtYmVyIHtcclxuXHRcdGlmIChvYmogPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygb2JqID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBNdXJtdXJIYXNoLmhhc2hDb2RlKFtvYmpdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuaGFzaENvZGUob2JqIGFzIEVxdWF0YWJsZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGltcGxlbWVudGF0aW9uIHJlbGllcyBvbiBvYmplY3QgZXF1YWxpdHkuIElmIGJvdGggb2JqZWN0cyBhcmVcclxuXHQgKiBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLiBPdGhlcndpc2UgaWYgb25seVxyXG5cdCAqIGBhYCBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC4gT3RoZXJ3aXNlLFxyXG5cdCAqIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHJlc3VsdCBvZlxyXG5cdCAqIGBhLmB7QGxpbmsgT2JqZWN0I2VxdWFscyBlcXVhbHN9YChiKWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhhOiBhbnksIGI6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKGEgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gYiA9PSBudWxsO1xyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gYSA9PT0gYjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuZXF1YWxzKGEgYXMgRXF1YXRhYmxlLCBiIGFzIEVxdWF0YWJsZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wM1QwMjowOTo0MS43NDM0MDg2LTA3OjAwXHJcblxyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5pbXBvcnQgeyBEZWZhdWx0RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4vRGVmYXVsdEVxdWFsaXR5Q29tcGFyYXRvclwiO1xyXG5pbXBvcnQgeyBFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi9FcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgTnVsbGFibGUsIE92ZXJyaWRlLCBTdXBwcmVzc1dhcm5pbmdzIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgSmF2YUNvbGxlY3Rpb24sIEphdmFTZXQgfSBmcm9tIFwiLi9TdHVic1wiO1xyXG5pbXBvcnQgeyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuL011cm11ckhhc2hcIjtcclxuXHJcbi8qKiB7QGxpbmsgU2V0fSBpbXBsZW1lbnRhdGlvbiB3aXRoIGNsb3NlZCBoYXNoaW5nIChvcGVuIGFkZHJlc3NpbmcpLiAqL1xyXG5cclxuLy8gTk9URTogIEphdmFTY3JpcHQncyBTZXQgaW50ZXJmYWNlIGhhcyBvbiBzaWduaWZpY2FudCBkaWZmZXJlbnQgZGlmZnJlbmNlIGZyb20gSmF2YSdzOlxyXG4vLyBcdFx0ICBlLmcuIHRoZSByZXR1cm4gdHlwZSBvZiBhZGQoKSBkaWZmZXJzIVxyXG4vLyAgICAgICAgRm9yIHRoaXMgcmVhc29uIEkndmUgY29tbWVudGVkIHR3ZWFrZWQgdGhlIGltcGxlbWVudHMgY2xhdXNlXHJcblxyXG5jb25zdCBJTklUQUxfQ0FQQUNJVFk6IG51bWJlciA9IDE2OyAvLyBtdXN0IGJlIHBvd2VyIG9mIDJcclxuY29uc3QgTE9BRF9GQUNUT1I6IG51bWJlciA9IDAuNzU7XHJcblxyXG5leHBvcnQgY2xhc3MgQXJyYXkyREhhc2hTZXQ8VCBleHRlbmRzIHsgdG9TdHJpbmcoKTogc3RyaW5nOyB9PiBpbXBsZW1lbnRzIEphdmFTZXQ8VD4ge1xyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGNvbXBhcmF0b3I6IEVxdWFsaXR5Q29tcGFyYXRvcjxUPjtcclxuXHJcblx0cHJvdGVjdGVkIGJ1Y2tldHM6IEFycmF5PFRbXSB8IHVuZGVmaW5lZD47XHJcblxyXG5cdC8qKiBIb3cgbWFueSBlbGVtZW50cyBpbiBzZXQgKi9cclxuXHRwcm90ZWN0ZWQgbjogbnVtYmVyID0gMDtcclxuXHJcblx0cHJvdGVjdGVkIHRocmVzaG9sZDogbnVtYmVyID0gTWF0aC5mbG9vcihJTklUQUxfQ0FQQUNJVFkgKiBMT0FEX0ZBQ1RPUik7IC8vIHdoZW4gdG8gZXhwYW5kXHJcblxyXG5cdGNvbnN0cnVjdG9yKGNvbXBhcmF0b3I/OiBFcXVhbGl0eUNvbXBhcmF0b3I8VD4sIGluaXRpYWxDYXBhY2l0eT86IG51bWJlcik7XHJcblx0Y29uc3RydWN0b3Ioc2V0OiBBcnJheTJESGFzaFNldDxUPik7XHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRjb21wYXJhdG9yT3JTZXQ/OiBFcXVhbGl0eUNvbXBhcmF0b3I8VD4gfCBBcnJheTJESGFzaFNldDxUPixcclxuXHRcdGluaXRpYWxDYXBhY2l0eTogbnVtYmVyID0gSU5JVEFMX0NBUEFDSVRZKSB7XHJcblxyXG5cdFx0aWYgKGNvbXBhcmF0b3JPclNldCBpbnN0YW5jZW9mIEFycmF5MkRIYXNoU2V0KSB7XHJcblx0XHRcdHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3JPclNldC5jb21wYXJhdG9yO1xyXG5cdFx0XHR0aGlzLmJ1Y2tldHMgPSBjb21wYXJhdG9yT3JTZXQuYnVja2V0cy5zbGljZSgwKTtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1Y2tldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRsZXQgYnVja2V0ID0gdGhpcy5idWNrZXRzW2ldO1xyXG5cdFx0XHRcdGlmIChidWNrZXQpIHtcclxuXHRcdFx0XHRcdHRoaXMuYnVja2V0c1tpXSA9IGJ1Y2tldC5zbGljZSgwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubiA9IGNvbXBhcmF0b3JPclNldC5uO1xyXG5cdFx0XHR0aGlzLnRocmVzaG9sZCA9IGNvbXBhcmF0b3JPclNldC50aHJlc2hvbGQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yT3JTZXQgfHwgRGVmYXVsdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRTtcclxuXHRcdFx0dGhpcy5idWNrZXRzID0gdGhpcy5jcmVhdGVCdWNrZXRzKGluaXRpYWxDYXBhY2l0eSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgYG9gIHRvIHNldCBpZiBub3QgdGhlcmU7IHJldHVybiBleGlzdGluZyB2YWx1ZSBpZiBhbHJlYWR5XHJcblx0ICogdGhlcmUuIFRoaXMgbWV0aG9kIHBlcmZvcm1zIHRoZSBzYW1lIG9wZXJhdGlvbiBhcyB7QGxpbmsgI2FkZH0gYXNpZGUgZnJvbVxyXG5cdCAqIHRoZSByZXR1cm4gdmFsdWUuXHJcblx0ICovXHJcblx0cHVibGljIGdldE9yQWRkKG86IFQpOiBUIHtcclxuXHRcdGlmICh0aGlzLm4gPiB0aGlzLnRocmVzaG9sZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T3JBZGRJbXBsKG8pO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldE9yQWRkSW1wbChvOiBUKTogVCB7XHJcblx0XHRsZXQgYjogbnVtYmVyID0gdGhpcy5nZXRCdWNrZXQobyk7XHJcblx0XHRsZXQgYnVja2V0ID0gdGhpcy5idWNrZXRzW2JdO1xyXG5cclxuXHRcdC8vIE5FVyBCVUNLRVRcclxuXHRcdGlmICghYnVja2V0KSB7XHJcblx0XHRcdGJ1Y2tldCA9IFtvXTtcclxuXHRcdFx0dGhpcy5idWNrZXRzW2JdID0gYnVja2V0O1xyXG5cdFx0XHR0aGlzLm4rKztcclxuXHRcdFx0cmV0dXJuIG87XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTE9PSyBGT1IgSVQgSU4gQlVDS0VUXHJcblx0XHRmb3IgKGxldCBleGlzdGluZyBvZiBidWNrZXQpIHtcclxuXHRcdFx0aWYgKHRoaXMuY29tcGFyYXRvci5lcXVhbHMoZXhpc3RpbmcsIG8pKSB7XHJcblx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nOyAvLyBmb3VuZCBleGlzdGluZywgcXVpdFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRlVMTCBCVUNLRVQsIGV4cGFuZCBhbmQgYWRkIHRvIGVuZFxyXG5cdFx0YnVja2V0LnB1c2gobyk7XHJcblx0XHR0aGlzLm4rKztcclxuXHRcdHJldHVybiBvO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldChvOiBUKTogVCB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAobyA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBvO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGI6IG51bWJlciA9IHRoaXMuZ2V0QnVja2V0KG8pO1xyXG5cdFx0bGV0IGJ1Y2tldCA9IHRoaXMuYnVja2V0c1tiXTtcclxuXHRcdGlmICghYnVja2V0KSB7XHJcblx0XHRcdC8vIG5vIGJ1Y2tldFxyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGUgb2YgYnVja2V0KSB7XHJcblx0XHRcdGlmICh0aGlzLmNvbXBhcmF0b3IuZXF1YWxzKGUsIG8pKSB7XHJcblx0XHRcdFx0cmV0dXJuIGU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldEJ1Y2tldChvOiBUKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSB0aGlzLmNvbXBhcmF0b3IuaGFzaENvZGUobyk7XHJcblx0XHRsZXQgYjogbnVtYmVyID0gaGFzaCAmICh0aGlzLmJ1Y2tldHMubGVuZ3RoIC0gMSk7IC8vIGFzc3VtZXMgbGVuIGlzIHBvd2VyIG9mIDJcclxuXHRcdHJldHVybiBiO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKCk7XHJcblx0XHRmb3IgKGxldCBidWNrZXQgb2YgdGhpcy5idWNrZXRzKSB7XHJcblx0XHRcdGlmIChidWNrZXQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAobGV0IG8gb2YgYnVja2V0KSB7XHJcblx0XHRcdFx0aWYgKG8gPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmNvbXBhcmF0b3IuaGFzaENvZGUobykpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aGFzaCA9IE11cm11ckhhc2guZmluaXNoKGhhc2gsIHRoaXMuc2l6ZSk7XHJcblx0XHRyZXR1cm4gaGFzaDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMobzogYW55KTogYm9vbGVhbiB7XHJcblx0XHRpZiAobyA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGlmICghKG8gaW5zdGFuY2VvZiBBcnJheTJESGFzaFNldCkpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG8uc2l6ZSAhPT0gdGhpcy5zaXplKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGxldCBzYW1lOiBib29sZWFuID0gdGhpcy5jb250YWluc0FsbChvKTtcclxuXHRcdHJldHVybiBzYW1lO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGV4cGFuZCgpOiB2b2lkIHtcclxuXHRcdGxldCBvbGQgPSB0aGlzLmJ1Y2tldHM7XHJcblx0XHRsZXQgbmV3Q2FwYWNpdHk6IG51bWJlciA9IHRoaXMuYnVja2V0cy5sZW5ndGggKiAyO1xyXG5cdFx0bGV0IG5ld1RhYmxlOiBBcnJheTxUW10gfCB1bmRlZmluZWQ+ID0gdGhpcy5jcmVhdGVCdWNrZXRzKG5ld0NhcGFjaXR5KTtcclxuXHRcdHRoaXMuYnVja2V0cyA9IG5ld1RhYmxlO1xyXG5cdFx0dGhpcy50aHJlc2hvbGQgPSBNYXRoLmZsb29yKG5ld0NhcGFjaXR5ICogTE9BRF9GQUNUT1IpO1xyXG4vL1x0XHRTeXN0ZW0ub3V0LnByaW50bG4oXCJuZXcgc2l6ZT1cIituZXdDYXBhY2l0eStcIiwgdGhyZXM9XCIrdGhyZXNob2xkKTtcclxuXHRcdC8vIHJlaGFzaCBhbGwgZXhpc3RpbmcgZW50cmllc1xyXG5cdFx0bGV0IG9sZFNpemU6IG51bWJlciA9IHRoaXMuc2l6ZTtcclxuXHRcdGZvciAobGV0IGJ1Y2tldCBvZiBvbGQpIHtcclxuXHRcdFx0aWYgKCFidWNrZXQpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yIChsZXQgbyBvZiBidWNrZXQpIHtcclxuXHRcdFx0XHRsZXQgYjogbnVtYmVyID0gdGhpcy5nZXRCdWNrZXQobyk7XHJcblx0XHRcdFx0bGV0IG5ld0J1Y2tldDogVFtdIHwgdW5kZWZpbmVkID0gdGhpcy5idWNrZXRzW2JdO1xyXG5cdFx0XHRcdGlmICghbmV3QnVja2V0KSB7XHJcblx0XHRcdFx0XHRuZXdCdWNrZXQgPSBbXTtcclxuXHRcdFx0XHRcdHRoaXMuYnVja2V0c1tiXSA9IG5ld0J1Y2tldDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG5ld0J1Y2tldC5wdXNoKG8pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YXNzZXJ0KHRoaXMubiA9PT0gb2xkU2l6ZSk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgYWRkKHQ6IFQpOiBib29sZWFuIHtcclxuXHRcdGxldCBleGlzdGluZzogVCA9IHRoaXMuZ2V0T3JBZGQodCk7XHJcblx0XHRyZXR1cm4gZXhpc3RpbmcgPT09IHQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMubjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMubiA9PT0gMDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjb250YWlucyhvOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5zRmFzdCh0aGlzLmFzRWxlbWVudFR5cGUobykpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGNvbnRhaW5zRmFzdChATnVsbGFibGUgb2JqOiBUKTogYm9vbGVhbiB7XHJcblx0XHRpZiAob2JqID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldChvYmopICE9IG51bGw7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgKltTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8VD4ge1xyXG5cdFx0eWllbGQqIHRoaXMudG9BcnJheSgpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvQXJyYXkoKTogVFtdIHtcclxuXHRcdGNvbnN0IGEgPSBuZXcgQXJyYXk8VD4odGhpcy5zaXplKTtcclxuXHJcblx0XHQvLyBDb3B5IGVsZW1lbnRzIGZyb20gdGhlIG5lc3RlZCBhcnJheXMgaW50byB0aGUgZGVzdGluYXRpb24gYXJyYXlcclxuXHRcdGxldCBpOiBudW1iZXIgPSAwOyAvLyBQb3NpdGlvbiB3aXRoaW4gZGVzdGluYXRpb24gYXJyYXlcclxuXHRcdGZvciAobGV0IGJ1Y2tldCBvZiB0aGlzLmJ1Y2tldHMpIHtcclxuXHRcdFx0aWYgKGJ1Y2tldCA9PSBudWxsKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAobGV0IG8gb2YgYnVja2V0KSB7XHJcblx0XHRcdFx0aWYgKG8gPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGFbaSsrXSA9IG87XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGNvbnRhaW5zQWxsKGNvbGxlY3Rpb246IEphdmFDb2xsZWN0aW9uPFQ+KTogYm9vbGVhbiB7XHJcblx0XHRpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIEFycmF5MkRIYXNoU2V0KSB7XHJcblx0XHRcdGxldCBzID0gY29sbGVjdGlvbiBhcyBhbnkgYXMgQXJyYXkyREhhc2hTZXQ8VD47XHJcblx0XHRcdGZvciAobGV0IGJ1Y2tldCBvZiBzLmJ1Y2tldHMpIHtcclxuXHRcdFx0XHRpZiAoYnVja2V0ID09IG51bGwpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRmb3IgKGxldCBvIG9mIGJ1Y2tldCkge1xyXG5cdFx0XHRcdFx0aWYgKG8gPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICghdGhpcy5jb250YWluc0Zhc3QodGhpcy5hc0VsZW1lbnRUeXBlKG8pKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0Zm9yIChsZXQgbyBvZiBjb2xsZWN0aW9uKSB7XHJcblx0XHRcdFx0aWYgKCF0aGlzLmNvbnRhaW5zRmFzdCh0aGlzLmFzRWxlbWVudFR5cGUobykpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBhZGRBbGwoYzogSXRlcmFibGU8VD4pOiBib29sZWFuIHtcclxuXHRcdGxldCBjaGFuZ2VkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yIChsZXQgbyBvZiBjKSB7XHJcblx0XHRcdGxldCBleGlzdGluZzogVCA9IHRoaXMuZ2V0T3JBZGQobyk7XHJcblx0XHRcdGlmIChleGlzdGluZyAhPT0gbykge1xyXG5cdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2hhbmdlZDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcclxuXHRcdHRoaXMuYnVja2V0cyA9IHRoaXMuY3JlYXRlQnVja2V0cyhJTklUQUxfQ0FQQUNJVFkpO1xyXG5cdFx0dGhpcy5uID0gMDtcclxuXHRcdHRoaXMudGhyZXNob2xkID0gTWF0aC5mbG9vcihJTklUQUxfQ0FQQUNJVFkgKiBMT0FEX0ZBQ1RPUik7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGlmICh0aGlzLnNpemUgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIFwie31cIjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYnVmID0gXCJ7XCI7XHJcblx0XHRsZXQgZmlyc3Q6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdFx0Zm9yIChsZXQgYnVja2V0IG9mIHRoaXMuYnVja2V0cykge1xyXG5cdFx0XHRpZiAoYnVja2V0ID09IG51bGwpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IgKGxldCBvIG9mIGJ1Y2tldCkge1xyXG5cdFx0XHRcdGlmIChvID09IG51bGwpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoZmlyc3QpIHtcclxuXHRcdFx0XHRcdGZpcnN0ID0gZmFsc2U7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGJ1ZiArPSBcIiwgXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJ1ZiArPSBvLnRvU3RyaW5nKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGJ1ZiArPSBcIn1cIjtcclxuXHRcdHJldHVybiBidWY7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdG9UYWJsZVN0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0bGV0IGJ1ZiA9IFwiXCI7XHJcblx0XHRmb3IgKGxldCBidWNrZXQgb2YgdGhpcy5idWNrZXRzKSB7XHJcblx0XHRcdGlmIChidWNrZXQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdGJ1ZiArPSBcIm51bGxcXG5cIjtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRidWYgKz0gXCJbXCI7XHJcblx0XHRcdGxldCBmaXJzdDogYm9vbGVhbiA9IHRydWU7XHJcblx0XHRcdGZvciAobGV0IG8gb2YgYnVja2V0KSB7XHJcblx0XHRcdFx0aWYgKGZpcnN0KSB7XHJcblx0XHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRidWYgKz0gXCIgXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChvID09IG51bGwpIHtcclxuXHRcdFx0XHRcdGJ1ZiArPSBcIl9cIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YnVmICs9IG8udG9TdHJpbmcoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0YnVmICs9IFwiXVxcblwiO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJ1ZjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiBgb2AgYXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQgdHlwZSBgVGAuIElmXHJcblx0ICogYG9gIGlzIG5vbi11bmRlZmluZWQgYnV0IGtub3duIHRvIG5vdCBiZSBhbiBpbnN0YW5jZSBvZiBgVGAsIHRoaXNcclxuXHQgKiBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC4gVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgcGVyZm9ybSBhbnlcclxuXHQgKiB0eXBlIGNoZWNrczsgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcHJvdmlkZSBzdHJvbmcgdHlwZSBjaGVja3MgZm9yIHRoZVxyXG5cdCAqIHtAbGluayAjY29udGFpbnN9IGFuZCB7QGxpbmsgI3JlbW92ZX0gbWV0aG9kcyB0byBlbnN1cmUgdGhlIGFyZ3VtZW50cyB0b1xyXG5cdCAqIHRoZSB7QGxpbmsgRXF1YWxpdHlDb21wYXJhdG9yfSBmb3IgdGhlIHNldCBhbHdheXMgaGF2ZSB0aGUgZXhwZWN0ZWRcclxuXHQgKiB0eXBlcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBvIHRoZSBvYmplY3QgdG8gdHJ5IGFuZCBjYXN0IHRvIHRoZSBlbGVtZW50IHR5cGUgb2YgdGhlIHNldFxyXG5cdCAqIEByZXR1cm5zIGBvYCBpZiBpdCBjb3VsZCBiZSBhbiBpbnN0YW5jZSBvZiBgVGAsIG90aGVyd2lzZVxyXG5cdCAqIGB1bmRlZmluZWRgLlxyXG5cdCAqL1xyXG5cdEBTdXBwcmVzc1dhcm5pbmdzKFwidW5jaGVja2VkXCIpXHJcblx0cHJvdGVjdGVkIGFzRWxlbWVudFR5cGUobzogYW55KTogVCB7XHJcblx0XHRyZXR1cm4gbyBhcyBUO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIGFuIGFycmF5IG9mIGBUW11gIHdpdGggbGVuZ3RoIGBjYXBhY2l0eWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gY2FwYWNpdHkgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgdG8gcmV0dXJuXHJcblx0ICogQHJldHVybnMgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIGFycmF5XHJcblx0ICovXHJcblx0QFN1cHByZXNzV2FybmluZ3MoXCJ1bmNoZWNrZWRcIilcclxuXHRwcm90ZWN0ZWQgY3JlYXRlQnVja2V0cyhjYXBhY2l0eTogbnVtYmVyKTogQXJyYXk8VFtdIHwgdW5kZWZpbmVkPiB7XHJcblx0XHRyZXR1cm4gbmV3IEFycmF5PFRbXT4oY2FwYWNpdHkpO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDNUMDI6MDk6NDIuMjEyNzI2MC0wNzowMFxyXG5pbXBvcnQgeyBFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi9FcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBFcXVhdGFibGUgfSBmcm9tIFwiLi9TdHVic1wiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4vTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIEVxdWFsaXR5Q29tcGFyYXRvcn0gdXNlcyBvYmplY3QgZXF1YWxpdHlcclxuICogZm9yIGNvbXBhcmlzb25zIGJ5IGNhbGxpbmcge0BsaW5rIE9iamVjdCNoYXNoQ29kZX0gYW5kIHtAbGluayBPYmplY3QjZXF1YWxzfS5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFycmF5RXF1YWxpdHlDb21wYXJhdG9yIGltcGxlbWVudHMgRXF1YWxpdHlDb21wYXJhdG9yPEVxdWF0YWJsZVtdPiB7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBJTlNUQU5DRTogQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IgPSBuZXcgQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IoKTtcclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhpcyBpbXBsZW1lbnRhdGlvbiByZXR1cm5zXHJcblx0ICogYG9iai5ge0BsaW5rIE9iamVjdCNoYXNoQ29kZSBoYXNoQ29kZSgpfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUob2JqOiBFcXVhdGFibGVbXSk6IG51bWJlciB7XHJcblx0XHRpZiAob2JqID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE11cm11ckhhc2guaGFzaENvZGUob2JqLCAwKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoaXMgaW1wbGVtZW50YXRpb24gcmVsaWVzIG9uIG9iamVjdCBlcXVhbGl0eS4gSWYgYm90aCBvYmplY3RzIGFyZVxyXG5cdCAqIGB1bmRlZmluZWRgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC4gT3RoZXJ3aXNlIGlmIG9ubHlcclxuXHQgKiBgYWAgaXMgYHVuZGVmaW5lZGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC4gT3RoZXJ3aXNlLFxyXG5cdCAqIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHJlc3VsdCBvZlxyXG5cdCAqIGBhLmB7QGxpbmsgT2JqZWN0I2VxdWFscyBlcXVhbHN9YChiKWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhhOiBFcXVhdGFibGVbXSwgYjogRXF1YXRhYmxlW10pOiBib29sZWFuIHtcclxuXHRcdGlmIChhID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIGIgPT0gbnVsbDtcclxuXHRcdH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCFPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuZXF1YWxzKGFbaV0sIGJbaV0pKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDUuMDgzMzc1Mi0wNzowMFxyXG5cclxuLy8gVGFraW5nIGEgY2FzZS1ieS1jYXNlIGFwcHJvYWNoIHRvIHBwb3J0aW5nIHRoaXMgZnVuY3Rpb25hbHRpeVxyXG4vLyBhcyBtdWNoIG9mIGl0IG1heSBiZSBzdXBwb3J0ZWQgbmF0aXZlbHkgYnkgSmF2YVNjcmlwdC4gT3Igb3RoZXJ3aXNlIG5lZWRcclxuLy8gc3Vic3RhbnRpYWwgcmV0aGlua1xyXG5cclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IEVxdWF0YWJsZSB9IGZyb20gXCIuL1N0dWJzXCI7XHJcbmltcG9ydCB7IEludGVnZXJMaXN0IH0gZnJvbSBcIi4vSW50ZWdlckxpc3RcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVXaGl0ZXNwYWNlKHM6IHN0cmluZywgZXNjYXBlU3BhY2VzOiBib29sZWFuKTogc3RyaW5nIHtcclxuXHRyZXR1cm4gZXNjYXBlU3BhY2VzID8gcy5yZXBsYWNlKC8gLywgXCJcXHUwMEI3XCIpIDogc1xyXG5cdFx0LnJlcGxhY2UoL1xcdC8sIFwiXFxcXHRcIilcclxuXHRcdC5yZXBsYWNlKC9cXG4vLCBcIlxcXFxuXCIpXHJcblx0XHQucmVwbGFjZSgvXFxyLywgXCJcXFxcclwiKTtcclxufVxyXG5cclxuLy8gU2VyaW91c2x5OiB3aHkgaXNuJ3QgdGhpcyBidWlsdCBpbiB0byBqYXZhPyB1Z2ghXHJcbmV4cG9ydCBmdW5jdGlvbiBqb2luKGNvbGxlY3Rpb246IEl0ZXJhYmxlPGFueT4sIHNlcGFyYXRvcjogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRsZXQgYnVmID0gXCJcIjtcclxuXHRsZXQgZmlyc3QgPSB0cnVlO1xyXG5cdGZvciAobGV0IGN1cnJlbnQgb2YgY29sbGVjdGlvbikge1xyXG5cdFx0aWYgKGZpcnN0KSB7XHJcblx0XHRcdGZpcnN0ID0gZmFsc2U7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRidWYgKz0gc2VwYXJhdG9yO1xyXG5cdFx0fVxyXG5cclxuXHRcdGJ1ZiArPSBjdXJyZW50O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGJ1ZjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyh4OiBFcXVhdGFibGUgfCB1bmRlZmluZWQsIHk6IEVxdWF0YWJsZSB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xyXG5cdGlmICh4ID09PSB5KSB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4geC5lcXVhbHMoeSk7XHJcbn1cclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiBudW1Ob25udWxsKGRhdGE6IGFueVtdKTogbnVtYmVyIHtcclxuLy8gXHRsZXQgbjogbnVtYmVyID0gIDA7XHJcbi8vIFx0aWYgKCBkYXRhID09IG51bGwgKSByZXR1cm4gbjtcclxuLy8gXHRmb3IgKGxldCBvIG9mIGRhdGEpIHtcclxuLy8gXHRcdGlmICggbyE9bnVsbCApIG4rKztcclxuLy8gXHR9XHJcbi8vIFx0cmV0dXJuIG47XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGxFbGVtZW50czxUPihkYXRhOiBDb2xsZWN0aW9uPFQ+LCB2YWx1ZTogVCk6IHZvaWQge1xyXG4vLyBcdGlmICggZGF0YT09bnVsbCApIHJldHVybjtcclxuLy8gXHR3aGlsZSAoIGRhdGEuY29udGFpbnModmFsdWUpICkgZGF0YS5yZW1vdmUodmFsdWUpO1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gd3JpdGVGaWxlKEBOb3ROdWxsIGZpbGU6IEZpbGUsIEBOb3ROdWxsIGNvbnRlbnQ6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcclxuLy8gXHRsZXQgZm9zOiBGaWxlT3V0cHV0U3RyZWFtID0gbmV3IEZpbGVPdXRwdXRTdHJlYW0oZmlsZSk7XHJcbi8vIFx0dHJ5IHtcclxuLy8gXHRcdGZvcy53cml0ZShjb250ZW50KTtcclxuLy8gXHR9IGZpbmFsbHkge1xyXG4vLyBcdFx0Zm9zLmNsb3NlKCk7XHJcbi8vIFx0fVxyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gd3JpdGVGaWxlKEBOb3ROdWxsIGZpbGVOYW1lOiBzdHJpbmcsIEBOb3ROdWxsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQge1xyXG4vLyBcdHdyaXRlRmlsZShmaWxlTmFtZSwgY29udGVudCwgbnVsbCk7XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiB3cml0ZUZpbGUoQE5vdE51bGwgZmlsZU5hbWU6IHN0cmluZywgQE5vdE51bGwgY29udGVudDogc3RyaW5nLCBATnVsbGFibGUgZW5jb2Rpbmc6IHN0cmluZyk6IHZvaWQge1xyXG4vLyBcdGxldCBmOiBGaWxlID0gIG5ldyBGaWxlKGZpbGVOYW1lKTtcclxuLy8gXHRsZXQgZm9zOiBGaWxlT3V0cHV0U3RyZWFtID0gIG5ldyBGaWxlT3V0cHV0U3RyZWFtKGYpO1xyXG4vLyBcdGxldCBvc3c6IE91dHB1dFN0cmVhbVdyaXRlcjtcclxuLy8gXHRpZiAoZW5jb2RpbmcgIT0gbnVsbCkge1xyXG4vLyBcdFx0b3N3ID0gbmV3IE91dHB1dFN0cmVhbVdyaXRlcihmb3MsIGVuY29kaW5nKTtcclxuLy8gXHR9XHJcbi8vIFx0ZWxzZSB7XHJcbi8vIFx0XHRvc3cgPSBuZXcgT3V0cHV0U3RyZWFtV3JpdGVyKGZvcyk7XHJcbi8vIFx0fVxyXG5cclxuLy8gXHR0cnkge1xyXG4vLyBcdFx0b3N3LndyaXRlKGNvbnRlbnQpO1xyXG4vLyBcdH1cclxuLy8gXHRmaW5hbGx5IHtcclxuLy8gXHRcdG9zdy5jbG9zZSgpO1xyXG4vLyBcdH1cclxuLy8gfVxyXG5cclxuLy8gQE5vdE51bGxcclxuLy8gZXhwb3J0IGZ1bmN0aW9uIHJlYWRGaWxlKEBOb3ROdWxsIGZpbGVOYW1lOiBzdHJpbmcpOiBjaGFyW10ge1xyXG4vLyBcdHJldHVybiByZWFkRmlsZShmaWxlTmFtZSwgbnVsbCk7XHJcbi8vIH1cclxuXHJcbi8vIEBOb3ROdWxsXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiByZWFkRmlsZShATm90TnVsbCBmaWxlTmFtZTogc3RyaW5nLCBATnVsbGFibGUgZW5jb2Rpbmc6IHN0cmluZyk6IGNoYXJbXSB7XHJcbi8vIFx0bGV0IGY6IEZpbGUgPSAgbmV3IEZpbGUoZmlsZU5hbWUpO1xyXG4vLyBcdGxldCBzaXplOiBudW1iZXIgPSAgKGludClmLmxlbmd0aCgpO1xyXG4vLyBcdGxldCBpc3I6IElucHV0U3RyZWFtUmVhZGVyO1xyXG4vLyBcdGxldCBmaXM6IEZpbGVJbnB1dFN0cmVhbSA9ICBuZXcgRmlsZUlucHV0U3RyZWFtKGZpbGVOYW1lKTtcclxuLy8gXHRpZiAoIGVuY29kaW5nIT1udWxsICkge1xyXG4vLyBcdFx0aXNyID0gbmV3IElucHV0U3RyZWFtUmVhZGVyKGZpcywgZW5jb2RpbmcpO1xyXG4vLyBcdH1cclxuLy8gXHRlbHNlIHtcclxuLy8gXHRcdGlzciA9IG5ldyBJbnB1dFN0cmVhbVJlYWRlcihmaXMpO1xyXG4vLyBcdH1cclxuLy8gXHRsZXQgZGF0YTogY2hhcltdID0gIG51bGw7XHJcbi8vIFx0dHJ5IHtcclxuLy8gXHRcdGRhdGEgPSBuZXcgY2hhcltzaXplXTtcclxuLy8gXHRcdGxldCBuOiBudW1iZXIgPSAgaXNyLnJlYWQoZGF0YSk7XHJcbi8vIFx0XHRpZiAobiA8IGRhdGEubGVuZ3RoKSB7XHJcbi8vIFx0XHRcdGRhdGEgPSBBcnJheXMuY29weU9mKGRhdGEsIG4pO1xyXG4vLyBcdFx0fVxyXG4vLyBcdH1cclxuLy8gXHRmaW5hbGx5IHtcclxuLy8gXHRcdGlzci5jbG9zZSgpO1xyXG4vLyBcdH1cclxuLy8gXHRyZXR1cm4gZGF0YTtcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbDxUPihATm90TnVsbCBwcmVkaWNhdGU6IExpc3Q8VD4gbGlzdCxATm90TnVsbCBQcmVkaWNhdGU8PyBzdXBlciBUPik6IHZvaWQge1xyXG4vLyBcdGxldCBqOiBudW1iZXIgPSAgMDtcclxuLy8gXHRmb3IgKGxldCBpID0gMDsgaSA8IGxpc3Quc2l6ZTsgaSsrKSB7XHJcbi8vIFx0XHRsZXQgaXRlbTogVCA9ICBsaXN0LmdldChpKTtcclxuLy8gXHRcdGlmICghcHJlZGljYXRlLmV2YWwoaXRlbSkpIHtcclxuLy8gXHRcdFx0aWYgKGogIT0gaSkge1xyXG4vLyBcdFx0XHRcdGxpc3Quc2V0KGosIGl0ZW0pO1xyXG4vLyBcdFx0XHR9XHJcblxyXG4vLyBcdFx0XHRqKys7XHJcbi8vIFx0XHR9XHJcbi8vIFx0fVxyXG5cclxuLy8gXHRpZiAoaiA8IGxpc3Quc2l6ZSkge1xyXG4vLyBcdFx0bGlzdC5zdWJMaXN0KGosIGxpc3Quc2l6ZSkuY2xlYXIoKTtcclxuLy8gXHR9XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGw8VD4oQE5vdE51bGwgcHJlZGljYXRlOiBJdGVyYWJsZTxUPiBpdGVyYWJsZSxATm90TnVsbCBQcmVkaWNhdGU8PyBzdXBlciBUPik6IHZvaWQge1xyXG4vLyBcdGlmIChpdGVyYWJsZSBpbnN0YW5jZW9mIExpc3Q8Pz4pIHtcclxuLy8gXHRcdHJlbW92ZUFsbCgoTGlzdDxUPilpdGVyYWJsZSwgcHJlZGljYXRlKTtcclxuLy8gXHRcdHJldHVybjtcclxuLy8gXHR9XHJcblxyXG4vLyBcdGZvciAoSXRlcmF0b3I8VD4gaXRlcmF0b3IgPSBpdGVyYWJsZS5pdGVyYXRvcigpOyBpdGVyYXRvci5oYXNOZXh0KCk7ICkge1xyXG4vLyBcdFx0bGV0IGl0ZW06IFQgPSAgaXRlcmF0b3IubmV4dCgpO1xyXG4vLyBcdFx0aWYgKHByZWRpY2F0ZS5ldmFsKGl0ZW0pKSB7XHJcbi8vIFx0XHRcdGl0ZXJhdG9yLnJlbW92ZSgpO1xyXG4vLyBcdFx0fVxyXG4vLyBcdH1cclxuLy8gfVxyXG5cclxuLyoqIENvbnZlcnQgYXJyYXkgb2Ygc3RyaW5ncyB0byBzdHJpbmcmcmFycjtpbmRleCBtYXAuIFVzZWZ1bCBmb3JcclxuICogIGNvbnZlcnRpbmcgcnVsZW5hbWVzIHRvIG5hbWUmcmFycjtydWxlaW5kZXggbWFwLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTWFwKGtleXM6IHN0cmluZ1tdKTogTWFwPHN0cmluZywgbnVtYmVyPiB7XHJcblx0bGV0IG06IE1hcDxzdHJpbmcsIG51bWJlcj4gPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0bS5zZXQoa2V5c1tpXSwgaSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2hhckFycmF5KHN0cjogc3RyaW5nKTogVWludDE2QXJyYXk7XHJcbmV4cG9ydCBmdW5jdGlvbiB0b0NoYXJBcnJheShkYXRhOiBJbnRlZ2VyTGlzdCk6IFVpbnQxNkFycmF5O1xyXG5leHBvcnQgZnVuY3Rpb24gdG9DaGFyQXJyYXkoc3RyOiBzdHJpbmcgfCBJbnRlZ2VyTGlzdCk6IFVpbnQxNkFycmF5IHtcclxuXHRpZiAodHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0bGV0IHJlc3VsdCA9IG5ldyBVaW50MTZBcnJheShzdHIubGVuZ3RoKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHJlc3VsdFtpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBzdHIudG9DaGFyQXJyYXkoKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIC8qKlxyXG4vLyBcdCogQHNpbmNlIDQuNVxyXG4vLyBcdCovXHJcbi8vIEBOb3ROdWxsXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiB0b1NldChATm90TnVsbCBiaXRzOiBCaXRTZXQpOiBJbnRlcnZhbFNldCB7XHJcbi8vIFx0bGV0IHM6IEludGVydmFsU2V0ID0gIG5ldyBJbnRlcnZhbFNldCgpO1xyXG4vLyBcdGxldCBpOiBudW1iZXIgPSAgYml0cy5uZXh0U2V0Qml0KDApO1xyXG4vLyBcdHdoaWxlICggaSA+PSAwICkge1xyXG4vLyBcdFx0cy5hZGQoaSk7XHJcbi8vIFx0XHRpID0gYml0cy5uZXh0U2V0Qml0KGkrMSk7XHJcbi8vIFx0fVxyXG4vLyBcdHJldHVybiBzO1xyXG4vLyB9XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNi45NTIxNDc4LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBcnJheTJESGFzaFNldCB9IGZyb20gXCIuLi9taXNjL0FycmF5MkRIYXNoU2V0XCI7XHJcbmltcG9ydCB7IEFycmF5RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgQ29tcGFyYWJsZSB9IGZyb20gXCIuLi9taXNjL1N0dWJzXCI7XHJcbmltcG9ydCB7IEVxdWF0YWJsZSB9IGZyb20gXCIuLi9taXNjL1N0dWJzXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi4vUmVjb2duaXplclwiO1xyXG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCIuLi9SdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiLi4vbWlzYy9VdGlsc1wiO1xyXG5cclxuZnVuY3Rpb24gbWF4PFQgZXh0ZW5kcyBDb21wYXJhYmxlPFQ+PihpdGVtczogSXRlcmFibGU8VD4pOiBUIHwgdW5kZWZpbmVkIHtcclxuXHRsZXQgcmVzdWx0OiBUIHwgdW5kZWZpbmVkO1xyXG5cdGZvciAobGV0IGN1cnJlbnQgb2YgaXRlbXMpIHtcclxuXHRcdGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXN1bHQgPSBjdXJyZW50O1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgY29tcGFyaXNvbiA9IHJlc3VsdC5jb21wYXJlVG8oY3VycmVudCk7XHJcblx0XHRpZiAoY29tcGFyaXNvbiA8IDApIHtcclxuXHRcdFx0cmVzdWx0ID0gY3VycmVudDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1pbjxUIGV4dGVuZHMgQ29tcGFyYWJsZTxUPj4oaXRlbXM6IEl0ZXJhYmxlPFQ+KTogVCB8IHVuZGVmaW5lZCB7XHJcblx0bGV0IHJlc3VsdDogVCB8IHVuZGVmaW5lZDtcclxuXHRmb3IgKGxldCBjdXJyZW50IG9mIGl0ZW1zKSB7XHJcblx0XHRpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmVzdWx0ID0gY3VycmVudDtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGNvbXBhcmlzb24gPSByZXN1bHQuY29tcGFyZVRvKGN1cnJlbnQpO1xyXG5cdFx0aWYgKGNvbXBhcmlzb24gPiAwKSB7XHJcblx0XHRcdHJlc3VsdCA9IGN1cnJlbnQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKiogQSB0cmVlIHN0cnVjdHVyZSB1c2VkIHRvIHJlY29yZCB0aGUgc2VtYW50aWMgY29udGV4dCBpbiB3aGljaFxyXG4gKiAgYW4gQVROIGNvbmZpZ3VyYXRpb24gaXMgdmFsaWQuICBJdCdzIGVpdGhlciBhIHNpbmdsZSBwcmVkaWNhdGUsXHJcbiAqICBhIGNvbmp1bmN0aW9uIGBwMSYmcDJgLCBvciBhIHN1bSBvZiBwcm9kdWN0cyBgcDF8fHAyYC5cclxuICpcclxuICogIEkgaGF2ZSBzY29wZWQgdGhlIHtAbGluayBBTkR9LCB7QGxpbmsgT1J9LCBhbmQge0BsaW5rIFByZWRpY2F0ZX0gc3ViY2xhc3NlcyBvZlxyXG4gKiAge0BsaW5rIFNlbWFudGljQ29udGV4dH0gd2l0aGluIHRoZSBzY29wZSBvZiB0aGlzIG91dGVyIGNsYXNzLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNlbWFudGljQ29udGV4dCBpbXBsZW1lbnRzIEVxdWF0YWJsZSB7XHJcblx0cHJpdmF0ZSBzdGF0aWMgX05PTkU6IFNlbWFudGljQ29udGV4dDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGRlZmF1bHQge0BsaW5rIFNlbWFudGljQ29udGV4dH0sIHdoaWNoIGlzIHNlbWFudGljYWxseSBlcXVpdmFsZW50IHRvXHJcblx0ICogYSBwcmVkaWNhdGUgb2YgdGhlIGZvcm0gYHt0cnVlfT9gLlxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgTk9ORSgpOiBTZW1hbnRpY0NvbnRleHQge1xyXG5cdFx0aWYgKFNlbWFudGljQ29udGV4dC5fTk9ORSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFNlbWFudGljQ29udGV4dC5fTk9ORSA9IG5ldyBTZW1hbnRpY0NvbnRleHQuUHJlZGljYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFNlbWFudGljQ29udGV4dC5fTk9ORTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEZvciBjb250ZXh0IGluZGVwZW5kZW50IHByZWRpY2F0ZXMsIHdlIGV2YWx1YXRlIHRoZW0gd2l0aG91dCBhIGxvY2FsXHJcblx0ICogY29udGV4dCAoaS5lLiwgdW5lZGZpbmVkIGNvbnRleHQpLiBUaGF0IHdheSwgd2UgY2FuIGV2YWx1YXRlIHRoZW0gd2l0aG91dFxyXG5cdCAqIGhhdmluZyB0byBjcmVhdGUgcHJvcGVyIHJ1bGUtc3BlY2lmaWMgY29udGV4dCBkdXJpbmcgcHJlZGljdGlvbiAoYXNcclxuXHQgKiBvcHBvc2VkIHRvIHRoZSBwYXJzZXIsIHdoaWNoIGNyZWF0ZXMgdGhlbSBuYXR1cmFsbHkpLiBJbiBhIHByYWN0aWNhbFxyXG5cdCAqIHNlbnNlLCB0aGlzIGF2b2lkcyBhIGNhc3QgZXhjZXB0aW9uIGZyb20gUnVsZUNvbnRleHQgdG8gbXlydWxlQ29udGV4dC5cclxuXHQgKlxyXG5cdCAqIEZvciBjb250ZXh0IGRlcGVuZGVudCBwcmVkaWNhdGVzLCB3ZSBtdXN0IHBhc3MgaW4gYSBsb2NhbCBjb250ZXh0IHNvIHRoYXRcclxuXHQgKiByZWZlcmVuY2VzIHN1Y2ggYXMgJGFyZyBldmFsdWF0ZSBwcm9wZXJseSBhcyBfbG9jYWxjdHguYXJnLiBXZSBvbmx5XHJcblx0ICogY2FwdHVyZSBjb250ZXh0IGRlcGVuZGVudCBwcmVkaWNhdGVzIGluIHRoZSBjb250ZXh0IGluIHdoaWNoIHdlIGJlZ2luXHJcblx0ICogcHJlZGljdGlvbiwgc28gd2UgcGFzc2VkIGluIHRoZSBvdXRlciBjb250ZXh0IGhlcmUgaW4gY2FzZSBvZiBjb250ZXh0XHJcblx0ICogZGVwZW5kZW50IHByZWRpY2F0ZSBldmFsdWF0aW9uLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBhYnN0cmFjdCBldmFsPFQ+KHBhcnNlcjogUmVjb2duaXplcjxULCBhbnk+LCBwYXJzZXJDYWxsU3RhY2s6IFJ1bGVDb250ZXh0KTogYm9vbGVhbjtcclxuXHJcblx0LyoqXHJcblx0ICogRXZhbHVhdGUgdGhlIHByZWNlZGVuY2UgcHJlZGljYXRlcyBmb3IgdGhlIGNvbnRleHQgYW5kIHJlZHVjZSB0aGUgcmVzdWx0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHBhcnNlciBUaGUgcGFyc2VyIGluc3RhbmNlLlxyXG5cdCAqIEBwYXJhbSBwYXJzZXJDYWxsU3RhY2tcclxuXHQgKiBAcmV0dXJucyBUaGUgc2ltcGxpZmllZCBzZW1hbnRpYyBjb250ZXh0IGFmdGVyIHByZWNlZGVuY2UgcHJlZGljYXRlcyBhcmVcclxuXHQgKiBldmFsdWF0ZWQsIHdoaWNoIHdpbGwgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzLlxyXG5cdCAqXHJcblx0ICogKiB7QGxpbmsgI05PTkV9OiBpZiB0aGUgcHJlZGljYXRlIHNpbXBsaWZpZXMgdG8gYHRydWVgIGFmdGVyXHJcblx0ICogICBwcmVjZWRlbmNlIHByZWRpY2F0ZXMgYXJlIGV2YWx1YXRlZC5cclxuXHQgKiAqIGB1bmRlZmluZWRgOiBpZiB0aGUgcHJlZGljYXRlIHNpbXBsaWZpZXMgdG8gYGZhbHNlYCBhZnRlclxyXG5cdCAqICAgcHJlY2VkZW5jZSBwcmVkaWNhdGVzIGFyZSBldmFsdWF0ZWQuXHJcblx0ICogKiBgdGhpc2A6IGlmIHRoZSBzZW1hbnRpYyBjb250ZXh0IGlzIG5vdCBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mXHJcblx0ICogICBwcmVjZWRlbmNlIHByZWRpY2F0ZSBldmFsdWF0aW9uLlxyXG5cdCAqICogQSBub24tYHVuZGVmaW5lZGAge0BsaW5rIFNlbWFudGljQ29udGV4dH06IHRoZSBuZXcgc2ltcGxpZmllZFxyXG5cdCAqICAgc2VtYW50aWMgY29udGV4dCBhZnRlciBwcmVjZWRlbmNlIHByZWRpY2F0ZXMgYXJlIGV2YWx1YXRlZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgZXZhbFByZWNlZGVuY2UocGFyc2VyOiBSZWNvZ25pemVyPGFueSwgYW55PiwgcGFyc2VyQ2FsbFN0YWNrOiBSdWxlQ29udGV4dCk6IFNlbWFudGljQ29udGV4dCB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCBoYXNoQ29kZSgpOiBudW1iZXI7XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuO1xyXG5cclxuXHRwdWJsaWMgc3RhdGljIGFuZChhOiBTZW1hbnRpY0NvbnRleHQgfCB1bmRlZmluZWQsIGI6IFNlbWFudGljQ29udGV4dCk6IFNlbWFudGljQ29udGV4dCB7XHJcblx0XHRpZiAoIWEgfHwgYSA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcclxuXHRcdFx0cmV0dXJuIGI7XHJcblx0XHR9XHJcblx0XHRpZiAoYiA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcclxuXHRcdFx0cmV0dXJuIGE7XHJcblx0XHR9XHJcblx0XHRsZXQgcmVzdWx0OiBTZW1hbnRpY0NvbnRleHQuQU5EID0gbmV3IFNlbWFudGljQ29udGV4dC5BTkQoYSwgYik7XHJcblx0XHRpZiAocmVzdWx0Lm9wbmRzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0Lm9wbmRzWzBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqICBAc2VlIFBhcnNlckFUTlNpbXVsYXRvciNnZXRQcmVkc0ZvckFtYmlnQWx0c1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgb3IoYTogU2VtYW50aWNDb250ZXh0IHwgdW5kZWZpbmVkLCBiOiBTZW1hbnRpY0NvbnRleHQpOiBTZW1hbnRpY0NvbnRleHQge1xyXG5cdFx0aWYgKCFhKSB7XHJcblx0XHRcdHJldHVybiBiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChhID09PSBTZW1hbnRpY0NvbnRleHQuTk9ORSB8fCBiID09PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xyXG5cdFx0XHRyZXR1cm4gU2VtYW50aWNDb250ZXh0Lk5PTkU7XHJcblx0XHR9XHJcblx0XHRsZXQgcmVzdWx0OiBTZW1hbnRpY0NvbnRleHQuT1IgPSBuZXcgU2VtYW50aWNDb250ZXh0Lk9SKGEsIGIpO1xyXG5cdFx0aWYgKHJlc3VsdC5vcG5kcy5sZW5ndGggPT09IDEpIHtcclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5vcG5kc1swXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IG5hbWVzcGFjZSBTZW1hbnRpY0NvbnRleHQge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgcmFuZG9tIDMwLWJpdCBwcmltZSByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZiBgQU5ELmNsYXNzLmhhc2hDb2RlKClgLlxyXG5cdCAqL1xyXG5cdGNvbnN0IEFORF9IQVNIQ09ERSA9IDQwMzYzNjEzO1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgcmFuZG9tIDMwLWJpdCBwcmltZSByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZiBgT1IuY2xhc3MuaGFzaENvZGUoKWAuXHJcblx0ICovXHJcblx0Y29uc3QgT1JfSEFTSENPREUgPSA0ODYyNzk5NzM7XHJcblxyXG5cdGZ1bmN0aW9uIGZpbHRlclByZWNlZGVuY2VQcmVkaWNhdGVzKGNvbGxlY3Rpb246IFNlbWFudGljQ29udGV4dFtdKTogU2VtYW50aWNDb250ZXh0LlByZWNlZGVuY2VQcmVkaWNhdGVbXSB7XHJcblx0XHRsZXQgcmVzdWx0OiBTZW1hbnRpY0NvbnRleHQuUHJlY2VkZW5jZVByZWRpY2F0ZVtdID0gW107XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGNvbnRleHQ6IFNlbWFudGljQ29udGV4dCA9IGNvbGxlY3Rpb25baV07XHJcblx0XHRcdGlmIChjb250ZXh0IGluc3RhbmNlb2YgU2VtYW50aWNDb250ZXh0LlByZWNlZGVuY2VQcmVkaWNhdGUpIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChjb250ZXh0KTtcclxuXHJcblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBpdGVtIGZyb20gJ2NvbGxlY3Rpb24nIGFuZCBtb3ZlIGkgYmFjayBzbyB3ZSBsb29rIGF0IHRoZSBzYW1lIGluZGV4IGFnYWluXHJcblx0XHRcdFx0Y29sbGVjdGlvbi5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0aS0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdGV4cG9ydCBjbGFzcyBQcmVkaWNhdGUgZXh0ZW5kcyBTZW1hbnRpY0NvbnRleHQge1xyXG5cdFx0cHVibGljIHJ1bGVJbmRleDogbnVtYmVyO1xyXG5cdFx0cHVibGljIHByZWRJbmRleDogbnVtYmVyO1xyXG5cdFx0cHVibGljIGlzQ3R4RGVwZW5kZW50OiBib29sZWFuOyAgIC8vIGUuZy4sICRpIHJlZiBpbiBwcmVkXHJcblxyXG5cdFx0Y29uc3RydWN0b3IoKTtcclxuXHRcdGNvbnN0cnVjdG9yKHJ1bGVJbmRleDogbnVtYmVyLCBwcmVkSW5kZXg6IG51bWJlciwgaXNDdHhEZXBlbmRlbnQ6IGJvb2xlYW4pO1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yKHJ1bGVJbmRleDogbnVtYmVyID0gLTEsIHByZWRJbmRleDogbnVtYmVyID0gLTEsIGlzQ3R4RGVwZW5kZW50OiBib29sZWFuID0gZmFsc2UpIHtcclxuXHRcdFx0c3VwZXIoKTtcclxuXHRcdFx0dGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XHJcblx0XHRcdHRoaXMucHJlZEluZGV4ID0gcHJlZEluZGV4O1xyXG5cdFx0XHR0aGlzLmlzQ3R4RGVwZW5kZW50ID0gaXNDdHhEZXBlbmRlbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgZXZhbDxUPihwYXJzZXI6IFJlY29nbml6ZXI8VCwgYW55PiwgcGFyc2VyQ2FsbFN0YWNrOiBSdWxlQ29udGV4dCk6IGJvb2xlYW4ge1xyXG5cdFx0XHRsZXQgbG9jYWxjdHg6IFJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkID0gdGhpcy5pc0N0eERlcGVuZGVudCA/IHBhcnNlckNhbGxTdGFjayA6IHVuZGVmaW5lZDtcclxuXHRcdFx0cmV0dXJuIHBhcnNlci5zZW1wcmVkKGxvY2FsY3R4LCB0aGlzLnJ1bGVJbmRleCwgdGhpcy5wcmVkSW5kZXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRcdGxldCBoYXNoQ29kZTogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKCk7XHJcblx0XHRcdGhhc2hDb2RlID0gTXVybXVySGFzaC51cGRhdGUoaGFzaENvZGUsIHRoaXMucnVsZUluZGV4KTtcclxuXHRcdFx0aGFzaENvZGUgPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5wcmVkSW5kZXgpO1xyXG5cdFx0XHRoYXNoQ29kZSA9IE11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCB0aGlzLmlzQ3R4RGVwZW5kZW50ID8gMSA6IDApO1xyXG5cdFx0XHRoYXNoQ29kZSA9IE11cm11ckhhc2guZmluaXNoKGhhc2hDb2RlLCAzKTtcclxuXHRcdFx0cmV0dXJuIGhhc2hDb2RlO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0XHRpZiAoIShvYmogaW5zdGFuY2VvZiBQcmVkaWNhdGUpKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzID09PSBvYmopIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5ydWxlSW5kZXggPT09IG9iai5ydWxlSW5kZXggJiZcclxuXHRcdFx0XHR0aGlzLnByZWRJbmRleCA9PT0gb2JqLnByZWRJbmRleCAmJlxyXG5cdFx0XHRcdHRoaXMuaXNDdHhEZXBlbmRlbnQgPT09IG9iai5pc0N0eERlcGVuZGVudDtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0XHRyZXR1cm4gXCJ7XCIgKyB0aGlzLnJ1bGVJbmRleCArIFwiOlwiICsgdGhpcy5wcmVkSW5kZXggKyBcIn0/XCI7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRleHBvcnQgY2xhc3MgUHJlY2VkZW5jZVByZWRpY2F0ZSBleHRlbmRzIFNlbWFudGljQ29udGV4dCBpbXBsZW1lbnRzIENvbXBhcmFibGU8UHJlY2VkZW5jZVByZWRpY2F0ZT4ge1xyXG5cdFx0cHVibGljIHByZWNlZGVuY2U6IG51bWJlcjtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcihwcmVjZWRlbmNlOiBudW1iZXIpIHtcclxuXHRcdFx0c3VwZXIoKTtcclxuXHRcdFx0dGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBldmFsPFQ+KHBhcnNlcjogUmVjb2duaXplcjxULCBhbnk+LCBwYXJzZXJDYWxsU3RhY2s6IFJ1bGVDb250ZXh0KTogYm9vbGVhbiB7XHJcblx0XHRcdHJldHVybiBwYXJzZXIucHJlY3ByZWQocGFyc2VyQ2FsbFN0YWNrLCB0aGlzLnByZWNlZGVuY2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGV2YWxQcmVjZWRlbmNlKHBhcnNlcjogUmVjb2duaXplcjxhbnksIGFueT4sIHBhcnNlckNhbGxTdGFjazogUnVsZUNvbnRleHQpOiBTZW1hbnRpY0NvbnRleHQgfCB1bmRlZmluZWQge1xyXG5cdFx0XHRpZiAocGFyc2VyLnByZWNwcmVkKHBhcnNlckNhbGxTdGFjaywgdGhpcy5wcmVjZWRlbmNlKSkge1xyXG5cdFx0XHRcdHJldHVybiBTZW1hbnRpY0NvbnRleHQuTk9ORTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgY29tcGFyZVRvKG86IFByZWNlZGVuY2VQcmVkaWNhdGUpOiBudW1iZXIge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjZWRlbmNlIC0gby5wcmVjZWRlbmNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRcdGxldCBoYXNoQ29kZTogbnVtYmVyID0gMTtcclxuXHRcdFx0aGFzaENvZGUgPSAzMSAqIGhhc2hDb2RlICsgdGhpcy5wcmVjZWRlbmNlO1xyXG5cdFx0XHRyZXR1cm4gaGFzaENvZGU7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbiB7XHJcblx0XHRcdGlmICghKG9iaiBpbnN0YW5jZW9mIFByZWNlZGVuY2VQcmVkaWNhdGUpKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpcyA9PT0gb2JqKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNlZGVuY2UgPT09IG9iai5wcmVjZWRlbmNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0Ly8gcHJlY2VkZW5jZSA+PSBfcHJlY2VkZW5jZVN0YWNrLnBlZWsoKVxyXG5cdFx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRcdHJldHVybiBcIntcIiArIHRoaXMucHJlY2VkZW5jZSArIFwiPj1wcmVjfT9cIjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIHNlbWFudGljIGNvbnRleHQgXCJvcGVyYXRvcnNcIiwgd2hpY2ggb3BlcmF0ZSBvblxyXG5cdCAqIGEgY29sbGVjdGlvbiBvZiBzZW1hbnRpYyBjb250ZXh0IFwib3BlcmFuZHNcIi5cclxuXHQgKlxyXG5cdCAqIEBzaW5jZSA0LjNcclxuXHQgKi9cclxuXHRleHBvcnQgYWJzdHJhY3QgY2xhc3MgT3BlcmF0b3IgZXh0ZW5kcyBTZW1hbnRpY0NvbnRleHQge1xyXG5cdFx0LyoqXHJcblx0XHQgKiBHZXRzIHRoZSBvcGVyYW5kcyBmb3IgdGhlIHNlbWFudGljIGNvbnRleHQgb3BlcmF0b3IuXHJcblx0XHQgKlxyXG5cdFx0ICogQHJldHVybnMgYSBjb2xsZWN0aW9uIG9mIHtAbGluayBTZW1hbnRpY0NvbnRleHR9IG9wZXJhbmRzIGZvciB0aGVcclxuXHRcdCAqIG9wZXJhdG9yLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBzaW5jZSA0LjNcclxuXHRcdCAqL1xyXG5cdFx0Ly8gQE5vdE51bGxcclxuXHRcdHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBvcGVyYW5kczogSXRlcmFibGU8U2VtYW50aWNDb250ZXh0PjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEEgc2VtYW50aWMgY29udGV4dCB3aGljaCBpcyB0cnVlIHdoZW5ldmVyIG5vbmUgb2YgdGhlIGNvbnRhaW5lZCBjb250ZXh0c1xyXG5cdCAqIGlzIGZhbHNlLlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBjbGFzcyBBTkQgZXh0ZW5kcyBPcGVyYXRvciB7XHJcblx0XHRwdWJsaWMgb3BuZHM6IFNlbWFudGljQ29udGV4dFtdO1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yKEBOb3ROdWxsIGE6IFNlbWFudGljQ29udGV4dCwgQE5vdE51bGwgYjogU2VtYW50aWNDb250ZXh0KSB7XHJcblx0XHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0XHRsZXQgb3BlcmFuZHM6IEFycmF5MkRIYXNoU2V0PFNlbWFudGljQ29udGV4dD4gPSBuZXcgQXJyYXkyREhhc2hTZXQ8U2VtYW50aWNDb250ZXh0PihPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xyXG5cdFx0XHRpZiAoYSBpbnN0YW5jZW9mIEFORCkge1xyXG5cdFx0XHRcdG9wZXJhbmRzLmFkZEFsbChhLm9wbmRzKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcGVyYW5kcy5hZGQoYSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChiIGluc3RhbmNlb2YgQU5EKSB7XHJcblx0XHRcdFx0b3BlcmFuZHMuYWRkQWxsKGIub3BuZHMpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wZXJhbmRzLmFkZChiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5vcG5kcyA9IG9wZXJhbmRzLnRvQXJyYXkoKTtcclxuXHRcdFx0bGV0IHByZWNlZGVuY2VQcmVkaWNhdGVzOiBQcmVjZWRlbmNlUHJlZGljYXRlW10gPSBmaWx0ZXJQcmVjZWRlbmNlUHJlZGljYXRlcyh0aGlzLm9wbmRzKTtcclxuXHJcblx0XHRcdC8vIGludGVyZXN0ZWQgaW4gdGhlIHRyYW5zaXRpb24gd2l0aCB0aGUgbG93ZXN0IHByZWNlZGVuY2VcclxuXHRcdFx0bGV0IHJlZHVjZWQgPSBtaW4ocHJlY2VkZW5jZVByZWRpY2F0ZXMpO1xyXG5cdFx0XHRpZiAocmVkdWNlZCkge1xyXG5cdFx0XHRcdHRoaXMub3BuZHMucHVzaChyZWR1Y2VkKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0Z2V0IG9wZXJhbmRzKCk6IEl0ZXJhYmxlPFNlbWFudGljQ29udGV4dD4ge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vcG5kcztcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdFx0aWYgKHRoaXMgPT09IG9iaikge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghKG9iaiBpbnN0YW5jZW9mIEFORCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIEFycmF5RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFLmVxdWFscyh0aGlzLm9wbmRzLCBvYmoub3BuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRcdHJldHVybiBNdXJtdXJIYXNoLmhhc2hDb2RlKHRoaXMub3BuZHMsIEFORF9IQVNIQ09ERSk7XHJcblx0XHR9XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiB7QGluaGVyaXREb2N9XHJcblx0XHQgKlxyXG5cdFx0ICogVGhlIGV2YWx1YXRpb24gb2YgcHJlZGljYXRlcyBieSB0aGlzIGNvbnRleHQgaXMgc2hvcnQtY2lyY3VpdGluZywgYnV0XHJcblx0XHQgKiB1bm9yZGVyZWQuXHJcblx0XHQgKi9cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGV2YWw8VD4ocGFyc2VyOiBSZWNvZ25pemVyPFQsIGFueT4sIHBhcnNlckNhbGxTdGFjazogUnVsZUNvbnRleHQpOiBib29sZWFuIHtcclxuXHRcdFx0Zm9yIChsZXQgb3BuZCBvZiB0aGlzLm9wbmRzKSB7XHJcblx0XHRcdFx0aWYgKCFvcG5kLmV2YWwocGFyc2VyLCBwYXJzZXJDYWxsU3RhY2spKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBldmFsUHJlY2VkZW5jZShwYXJzZXI6IFJlY29nbml6ZXI8YW55LCBhbnk+LCBwYXJzZXJDYWxsU3RhY2s6IFJ1bGVDb250ZXh0KTogU2VtYW50aWNDb250ZXh0IHwgdW5kZWZpbmVkIHtcclxuXHRcdFx0bGV0IGRpZmZlcnM6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdFx0bGV0IG9wZXJhbmRzOiBTZW1hbnRpY0NvbnRleHRbXSA9IFtdO1xyXG5cdFx0XHRmb3IgKGxldCBjb250ZXh0IG9mIHRoaXMub3BuZHMpIHtcclxuXHRcdFx0XHRsZXQgZXZhbHVhdGVkOiBTZW1hbnRpY0NvbnRleHQgfCB1bmRlZmluZWQgPSBjb250ZXh0LmV2YWxQcmVjZWRlbmNlKHBhcnNlciwgcGFyc2VyQ2FsbFN0YWNrKTtcclxuXHRcdFx0XHRkaWZmZXJzID0gZGlmZmVycyB8fCAoZXZhbHVhdGVkICE9PSBjb250ZXh0KTtcclxuXHRcdFx0XHRpZiAoZXZhbHVhdGVkID09IG51bGwpIHtcclxuXHRcdFx0XHRcdC8vIFRoZSBBTkQgY29udGV4dCBpcyBmYWxzZSBpZiBhbnkgZWxlbWVudCBpcyBmYWxzZVxyXG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoZXZhbHVhdGVkICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xyXG5cdFx0XHRcdFx0Ly8gUmVkdWNlIHRoZSByZXN1bHQgYnkgc2tpcHBpbmcgdHJ1ZSBlbGVtZW50c1xyXG5cdFx0XHRcdFx0b3BlcmFuZHMucHVzaChldmFsdWF0ZWQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFkaWZmZXJzKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvcGVyYW5kcy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHQvLyBhbGwgZWxlbWVudHMgd2VyZSB0cnVlLCBzbyB0aGUgQU5EIGNvbnRleHQgaXMgdHJ1ZVxyXG5cdFx0XHRcdHJldHVybiBTZW1hbnRpY0NvbnRleHQuTk9ORTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHJlc3VsdDogU2VtYW50aWNDb250ZXh0ID0gb3BlcmFuZHNbMF07XHJcblx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgb3BlcmFuZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRyZXN1bHQgPSBTZW1hbnRpY0NvbnRleHQuYW5kKHJlc3VsdCwgb3BlcmFuZHNbaV0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRcdHJldHVybiBVdGlscy5qb2luKHRoaXMub3BuZHMsIFwiJiZcIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBIHNlbWFudGljIGNvbnRleHQgd2hpY2ggaXMgdHJ1ZSB3aGVuZXZlciBhdCBsZWFzdCBvbmUgb2YgdGhlIGNvbnRhaW5lZFxyXG5cdCAqIGNvbnRleHRzIGlzIHRydWUuXHJcblx0ICovXHJcblx0ZXhwb3J0IGNsYXNzIE9SIGV4dGVuZHMgT3BlcmF0b3Ige1xyXG5cdFx0cHVibGljIG9wbmRzOiBTZW1hbnRpY0NvbnRleHRbXTtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcihATm90TnVsbCBhOiBTZW1hbnRpY0NvbnRleHQsIEBOb3ROdWxsIGI6IFNlbWFudGljQ29udGV4dCkge1xyXG5cdFx0XHRzdXBlcigpO1xyXG5cclxuXHRcdFx0bGV0IG9wZXJhbmRzOiBBcnJheTJESGFzaFNldDxTZW1hbnRpY0NvbnRleHQ+ID0gbmV3IEFycmF5MkRIYXNoU2V0PFNlbWFudGljQ29udGV4dD4oT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcclxuXHRcdFx0aWYgKGEgaW5zdGFuY2VvZiBPUikge1xyXG5cdFx0XHRcdG9wZXJhbmRzLmFkZEFsbChhLm9wbmRzKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcGVyYW5kcy5hZGQoYSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChiIGluc3RhbmNlb2YgT1IpIHtcclxuXHRcdFx0XHRvcGVyYW5kcy5hZGRBbGwoYi5vcG5kcyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3BlcmFuZHMuYWRkKGIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm9wbmRzID0gb3BlcmFuZHMudG9BcnJheSgpO1xyXG5cdFx0XHRsZXQgcHJlY2VkZW5jZVByZWRpY2F0ZXM6IFByZWNlZGVuY2VQcmVkaWNhdGVbXSA9IGZpbHRlclByZWNlZGVuY2VQcmVkaWNhdGVzKHRoaXMub3BuZHMpO1xyXG5cclxuXHRcdFx0Ly8gaW50ZXJlc3RlZCBpbiB0aGUgdHJhbnNpdGlvbiB3aXRoIHRoZSBoaWdoZXN0IHByZWNlZGVuY2VcclxuXHRcdFx0bGV0IHJlZHVjZWQgPSBtYXgocHJlY2VkZW5jZVByZWRpY2F0ZXMpO1xyXG5cdFx0XHRpZiAocmVkdWNlZCkge1xyXG5cdFx0XHRcdHRoaXMub3BuZHMucHVzaChyZWR1Y2VkKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0Z2V0IG9wZXJhbmRzKCk6IEl0ZXJhYmxlPFNlbWFudGljQ29udGV4dD4ge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vcG5kcztcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdFx0aWYgKHRoaXMgPT09IG9iaikge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghKG9iaiBpbnN0YW5jZW9mIE9SKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuZXF1YWxzKHRoaXMub3BuZHMsIG9iai5vcG5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdFx0cmV0dXJuIE11cm11ckhhc2guaGFzaENvZGUodGhpcy5vcG5kcywgT1JfSEFTSENPREUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdFx0ICpcclxuXHRcdCAqIFRoZSBldmFsdWF0aW9uIG9mIHByZWRpY2F0ZXMgYnkgdGhpcyBjb250ZXh0IGlzIHNob3J0LWNpcmN1aXRpbmcsIGJ1dFxyXG5cdFx0ICogdW5vcmRlcmVkLlxyXG5cdFx0ICovXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBldmFsPFQ+KHBhcnNlcjogUmVjb2duaXplcjxULCBhbnk+LCBwYXJzZXJDYWxsU3RhY2s6IFJ1bGVDb250ZXh0KTogYm9vbGVhbiB7XHJcblx0XHRcdGZvciAobGV0IG9wbmQgb2YgdGhpcy5vcG5kcykge1xyXG5cdFx0XHRcdGlmIChvcG5kLmV2YWwocGFyc2VyLCBwYXJzZXJDYWxsU3RhY2spKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBldmFsUHJlY2VkZW5jZShwYXJzZXI6IFJlY29nbml6ZXI8YW55LCBhbnk+LCBwYXJzZXJDYWxsU3RhY2s6IFJ1bGVDb250ZXh0KTogU2VtYW50aWNDb250ZXh0IHwgdW5kZWZpbmVkIHtcclxuXHRcdFx0bGV0IGRpZmZlcnM6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdFx0bGV0IG9wZXJhbmRzOiBTZW1hbnRpY0NvbnRleHRbXSA9IFtdO1xyXG5cdFx0XHRmb3IgKGxldCBjb250ZXh0IG9mIHRoaXMub3BuZHMpIHtcclxuXHRcdFx0XHRsZXQgZXZhbHVhdGVkOiBTZW1hbnRpY0NvbnRleHQgfCB1bmRlZmluZWQgPSBjb250ZXh0LmV2YWxQcmVjZWRlbmNlKHBhcnNlciwgcGFyc2VyQ2FsbFN0YWNrKTtcclxuXHRcdFx0XHRkaWZmZXJzID0gZGlmZmVycyB8fCAoZXZhbHVhdGVkICE9PSBjb250ZXh0KTtcclxuXHRcdFx0XHRpZiAoZXZhbHVhdGVkID09PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xyXG5cdFx0XHRcdFx0Ly8gVGhlIE9SIGNvbnRleHQgaXMgdHJ1ZSBpZiBhbnkgZWxlbWVudCBpcyB0cnVlXHJcblx0XHRcdFx0XHRyZXR1cm4gU2VtYW50aWNDb250ZXh0Lk5PTkU7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChldmFsdWF0ZWQpIHtcclxuXHRcdFx0XHRcdC8vIFJlZHVjZSB0aGUgcmVzdWx0IGJ5IHNraXBwaW5nIGZhbHNlIGVsZW1lbnRzXHJcblx0XHRcdFx0XHRvcGVyYW5kcy5wdXNoKGV2YWx1YXRlZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIWRpZmZlcnMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG9wZXJhbmRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdC8vIGFsbCBlbGVtZW50cyB3ZXJlIGZhbHNlLCBzbyB0aGUgT1IgY29udGV4dCBpcyBmYWxzZVxyXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCByZXN1bHQ6IFNlbWFudGljQ29udGV4dCA9IG9wZXJhbmRzWzBdO1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IG9wZXJhbmRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0cmVzdWx0ID0gU2VtYW50aWNDb250ZXh0Lm9yKHJlc3VsdCwgb3BlcmFuZHNbaV0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRcdHJldHVybiBVdGlscy5qb2luKHRoaXMub3BuZHMsIFwifHxcIik7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNS4yODI2OTYwLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9BYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFNlbWFudGljQ29udGV4dCB9IGZyb20gXCIuL1NlbWFudGljQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcblxyXG4vKiogVE9ETzogdGhpcyBpcyBvbGQgY29tbWVudDpcclxuICogIEEgdHJlZSBvZiBzZW1hbnRpYyBwcmVkaWNhdGVzIGZyb20gdGhlIGdyYW1tYXIgQVNUIGlmIGxhYmVsPT1TRU1QUkVELlxyXG4gKiAgSW4gdGhlIEFUTiwgbGFiZWxzIHdpbGwgYWx3YXlzIGJlIGV4YWN0bHkgb25lIHByZWRpY2F0ZSwgYnV0IHRoZSBERkFcclxuICogIG1heSBoYXZlIHRvIGNvbWJpbmUgYSBidW5jaCBvZiB0aGVtIGFzIGl0IGNvbGxlY3RzIHByZWRpY2F0ZXMgZnJvbVxyXG4gKiAgbXVsdGlwbGUgQVROIGNvbmZpZ3VyYXRpb25zIGludG8gYSBzaW5nbGUgREZBIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFByZWRpY2F0ZVRyYW5zaXRpb24gZXh0ZW5kcyBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24ge1xyXG5cdHB1YmxpYyBydWxlSW5kZXg6IG51bWJlcjtcclxuXHRwdWJsaWMgcHJlZEluZGV4OiBudW1iZXI7XHJcblx0cHVibGljIGlzQ3R4RGVwZW5kZW50OiBib29sZWFuOyAgIC8vIGUuZy4sICRpIHJlZiBpbiBwcmVkXHJcblxyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHRhcmdldDogQVROU3RhdGUsIHJ1bGVJbmRleDogbnVtYmVyLCBwcmVkSW5kZXg6IG51bWJlciwgaXNDdHhEZXBlbmRlbnQ6IGJvb2xlYW4pIHtcclxuXHRcdHN1cGVyKHRhcmdldCk7XHJcblx0XHR0aGlzLnJ1bGVJbmRleCA9IHJ1bGVJbmRleDtcclxuXHRcdHRoaXMucHJlZEluZGV4ID0gcHJlZEluZGV4O1xyXG5cdFx0dGhpcy5pc0N0eERlcGVuZGVudCA9IGlzQ3R4RGVwZW5kZW50O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNlcmlhbGl6YXRpb25UeXBlKCk6IFRyYW5zaXRpb25UeXBlIHtcclxuXHRcdHJldHVybiBUcmFuc2l0aW9uVHlwZS5QUkVESUNBVEU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaXNFcHNpbG9uKCk6IGJvb2xlYW4geyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgbWF0Y2hlcyhzeW1ib2w6IG51bWJlciwgbWluVm9jYWJTeW1ib2w6IG51bWJlciwgbWF4Vm9jYWJTeW1ib2w6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Z2V0IHByZWRpY2F0ZSgpOiBTZW1hbnRpY0NvbnRleHQuUHJlZGljYXRlIHtcclxuXHRcdHJldHVybiBuZXcgU2VtYW50aWNDb250ZXh0LlByZWRpY2F0ZSh0aGlzLnJ1bGVJbmRleCwgdGhpcy5wcmVkSW5kZXgsIHRoaXMuaXNDdHhEZXBlbmRlbnQpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcInByZWRfXCIgKyB0aGlzLnJ1bGVJbmRleCArIFwiOlwiICsgdGhpcy5wcmVkSW5kZXg7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1MS40MDk5OTQ2LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9hdG4vQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuL2F0bi9BVE5cIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9hdG4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFJlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4vUmVjb2duaXRpb25FeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgUmVjb2duaXplciB9IGZyb20gXCIuL1JlY29nbml6ZXJcIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUHJlZGljYXRlVHJhbnNpdGlvbiB9IGZyb20gXCIuL2F0bi9QcmVkaWNhdGVUcmFuc2l0aW9uXCI7XHJcblxyXG4vKiogQSBzZW1hbnRpYyBwcmVkaWNhdGUgZmFpbGVkIGR1cmluZyB2YWxpZGF0aW9uLiAgVmFsaWRhdGlvbiBvZiBwcmVkaWNhdGVzXHJcbiAqICBvY2N1cnMgd2hlbiBub3JtYWxseSBwYXJzaW5nIHRoZSBhbHRlcm5hdGl2ZSBqdXN0IGxpa2UgbWF0Y2hpbmcgYSB0b2tlbi5cclxuICogIERpc2FtYmlndWF0aW5nIHByZWRpY2F0ZSBldmFsdWF0aW9uIG9jY3VycyB3aGVuIHdlIHRlc3QgYSBwcmVkaWNhdGUgZHVyaW5nXHJcbiAqICBwcmVkaWN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbiBleHRlbmRzIFJlY29nbml0aW9uRXhjZXB0aW9uIHtcclxuXHQvL3ByaXZhdGUgc3RhdGljIHNlcmlhbFZlcnNpb25VSUQ6IG51bWJlciA9ICA1Mzc5MzMwODQxNDk1Nzc4NzA5TDtcclxuXHJcblx0cHJpdmF0ZSBfcnVsZUluZGV4OiBudW1iZXI7XHJcblx0cHJpdmF0ZSBfcHJlZGljYXRlSW5kZXg6IG51bWJlcjtcclxuXHRwcml2YXRlIF9wcmVkaWNhdGU/OiBzdHJpbmc7XHJcblxyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlciwgcHJlZGljYXRlPzogc3RyaW5nLCBtZXNzYWdlPzogc3RyaW5nKSB7XHJcblx0XHRzdXBlcihcclxuXHRcdFx0cmVjb2duaXplcixcclxuXHRcdFx0cmVjb2duaXplci5pbnB1dFN0cmVhbSxcclxuXHRcdFx0cmVjb2duaXplci5jb250ZXh0LFxyXG5cdFx0XHRGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24uZm9ybWF0TWVzc2FnZShwcmVkaWNhdGUsIG1lc3NhZ2UpKTtcclxuXHRcdGxldCBzOiBBVE5TdGF0ZSA9IHJlY29nbml6ZXIuaW50ZXJwcmV0ZXIuYXRuLnN0YXRlc1tyZWNvZ25pemVyLnN0YXRlXTtcclxuXHJcblx0XHRsZXQgdHJhbnMgPSBzLnRyYW5zaXRpb24oMCkgYXMgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uO1xyXG5cdFx0aWYgKHRyYW5zIGluc3RhbmNlb2YgUHJlZGljYXRlVHJhbnNpdGlvbikge1xyXG5cdFx0XHR0aGlzLl9ydWxlSW5kZXggPSB0cmFucy5ydWxlSW5kZXg7XHJcblx0XHRcdHRoaXMuX3ByZWRpY2F0ZUluZGV4ID0gdHJhbnMucHJlZEluZGV4O1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuX3J1bGVJbmRleCA9IDA7XHJcblx0XHRcdHRoaXMuX3ByZWRpY2F0ZUluZGV4ID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XHJcblx0XHRzdXBlci5zZXRPZmZlbmRpbmdUb2tlbihyZWNvZ25pemVyLCByZWNvZ25pemVyLmN1cnJlbnRUb2tlbik7XHJcblx0fVxyXG5cclxuXHRnZXQgcnVsZUluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcnVsZUluZGV4O1xyXG5cdH1cclxuXHJcblx0Z2V0IHByZWRpY2F0ZUluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcHJlZGljYXRlSW5kZXg7XHJcblx0fVxyXG5cclxuXHRnZXQgcHJlZGljYXRlKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcHJlZGljYXRlO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIHN0YXRpYyBmb3JtYXRNZXNzYWdlKHByZWRpY2F0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xyXG5cdFx0aWYgKG1lc3NhZ2UpIHtcclxuXHRcdFx0cmV0dXJuIG1lc3NhZ2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGBmYWlsZWQgcHJlZGljYXRlOiB7JHtwcmVkaWNhdGV9fT9gO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTEuNTE4NzY4Mi0wNzowMFxyXG5cclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi9QYXJzZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5cclxuLyoqIFRoaXMgc2lnbmlmaWVzIGFueSBraW5kIG9mIG1pc21hdGNoZWQgaW5wdXQgZXhjZXB0aW9ucyBzdWNoIGFzXHJcbiAqICB3aGVuIHRoZSBjdXJyZW50IGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCB0b2tlbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uIGV4dGVuZHMgUmVjb2duaXRpb25FeGNlcHRpb24ge1xyXG5cdC8vcHJpdmF0ZSBzdGF0aWMgc2VyaWFsVmVyc2lvblVJRDogbnVtYmVyID0gIDE1MzI1NjgzMzg3MDc0NDMwNjdMO1xyXG5cclxuXHRjb25zdHJ1Y3RvcigvKkBOb3ROdWxsKi8gcmVjb2duaXplcjogUGFyc2VyKTtcclxuXHRjb25zdHJ1Y3RvcigvKkBOb3ROdWxsKi8gcmVjb2duaXplcjogUGFyc2VyLCBzdGF0ZTogbnVtYmVyLCBjb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCk7XHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyLCBzdGF0ZT86IG51bWJlciwgY29udGV4dD86IFBhcnNlclJ1bGVDb250ZXh0KSB7XHJcblx0XHRpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGNvbnRleHQgPSByZWNvZ25pemVyLmNvbnRleHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0c3VwZXIocmVjb2duaXplciwgcmVjb2duaXplci5pbnB1dFN0cmVhbSwgY29udGV4dCk7XHJcblxyXG5cdFx0aWYgKHN0YXRlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zZXRPZmZlbmRpbmdTdGF0ZShzdGF0ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRPZmZlbmRpbmdUb2tlbihyZWNvZ25pemVyLCByZWNvZ25pemVyLmN1cnJlbnRUb2tlbik7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgQXJyYXlzIHtcclxuXHQvKipcclxuXHQgKiBTZWFyY2hlcyB0aGUgc3BlY2lmaWVkIGFycmF5IG9mIG51bWJlcnMgZm9yIHRoZSBzcGVjaWZpZWQgdmFsdWUgdXNpbmcgdGhlIGJpbmFyeSBzZWFyY2ggYWxnb3JpdGhtLiBUaGUgYXJyYXkgbXVzdFxyXG5cdCAqIGJlIHNvcnRlZCBwcmlvciB0byBtYWtpbmcgdGhpcyBjYWxsLiBJZiBpdCBpcyBub3Qgc29ydGVkLCB0aGUgcmVzdWx0cyBhcmUgdW5zcGVjaWZpZWQuIElmIHRoZSBhcnJheSBjb250YWluc1xyXG5cdCAqIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZSwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHdoaWNoIG9uZSB3aWxsIGJlIGZvdW5kLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgaW5kZXggb2YgdGhlIHNlYXJjaCBrZXksIGlmIGl0IGlzIGNvbnRhaW5lZCBpbiB0aGUgYXJyYXk7IG90aGVyd2lzZSwgKC0oaW5zZXJ0aW9uIHBvaW50KSAtIDEpLiBUaGVcclxuXHQgKiBpbnNlcnRpb24gcG9pbnQgaXMgZGVmaW5lZCBhcyB0aGUgcG9pbnQgYXQgd2hpY2ggdGhlIGtleSB3b3VsZCBiZSBpbnNlcnRlZCBpbnRvIHRoZSBhcnJheTogdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxyXG5cdCAqIGVsZW1lbnQgZ3JlYXRlciB0aGFuIHRoZSBrZXksIG9yIGFycmF5Lmxlbmd0aCBpZiBhbGwgZWxlbWVudHMgaW4gdGhlIGFycmF5IGFyZSBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCBrZXkuIE5vdGVcclxuXHQgKiB0aGF0IHRoaXMgZ3VhcmFudGVlcyB0aGF0IHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSA+PSAwIGlmIGFuZCBvbmx5IGlmIHRoZSBrZXkgaXMgZm91bmQuXHJcblx0ICovXHJcblx0ZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnJheTogQXJyYXlMaWtlPG51bWJlcj4sIGtleTogbnVtYmVyLCBmcm9tSW5kZXg/OiBudW1iZXIsIHRvSW5kZXg/OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIGJpbmFyeVNlYXJjaDAoYXJyYXksIGZyb21JbmRleCAhPT0gdW5kZWZpbmVkID8gZnJvbUluZGV4IDogMCwgdG9JbmRleCAhPT0gdW5kZWZpbmVkID8gdG9JbmRleCA6IGFycmF5Lmxlbmd0aCwga2V5KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGJpbmFyeVNlYXJjaDAoYXJyYXk6IEFycmF5TGlrZTxudW1iZXI+LCBmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyLCBrZXk6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRsZXQgbG93OiBudW1iZXIgPSBmcm9tSW5kZXg7XHJcblx0XHRsZXQgaGlnaDogbnVtYmVyID0gdG9JbmRleCAtIDE7XHJcblxyXG5cdFx0d2hpbGUgKGxvdyA8PSBoaWdoKSB7XHJcblx0XHRcdGxldCBtaWQ6IG51bWJlciA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcclxuXHRcdFx0bGV0IG1pZFZhbDogbnVtYmVyID0gYXJyYXlbbWlkXTtcclxuXHJcblx0XHRcdGlmIChtaWRWYWwgPCBrZXkpIHtcclxuXHRcdFx0XHRsb3cgPSBtaWQgKyAxO1xyXG5cdFx0XHR9IGVsc2UgaWYgKG1pZFZhbCA+IGtleSkge1xyXG5cdFx0XHRcdGhpZ2ggPSBtaWQgLSAxO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIGtleSBmb3VuZFxyXG5cdFx0XHRcdHJldHVybiBtaWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBrZXkgbm90IGZvdW5kLlxyXG5cdFx0cmV0dXJuIC0obG93ICsgMSk7XHJcblx0fVxyXG5cclxuXHRleHBvcnQgZnVuY3Rpb24gdG9TdHJpbmc8VD4oYXJyYXk6IEl0ZXJhYmxlPFQ+KSB7XHJcblx0XHRsZXQgcmVzdWx0ID0gXCJbXCI7XHJcblxyXG5cdFx0bGV0IGZpcnN0ID0gdHJ1ZTtcclxuXHRcdGZvciAobGV0IGVsZW1lbnQgb2YgYXJyYXkpIHtcclxuXHRcdFx0aWYgKGZpcnN0KSB7XHJcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQgKz0gXCIsIFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdHJlc3VsdCArPSBcIm51bGxcIjtcclxuXHRcdFx0fSBlbHNlIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRyZXN1bHQgKz0gXCJ1bmRlZmluZWRcIjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQgKz0gZWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJlc3VsdCArPSBcIl1cIjtcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0MC41MDk5NDI5LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBcnJheXMgfSBmcm9tIFwiLi9BcnJheXNcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBKYXZhQ29sbGVjdGlvbiB9IGZyb20gXCIuL1N0dWJzXCI7XHJcblxyXG5jb25zdCBFTVBUWV9EQVRBOiBJbnQzMkFycmF5ID0gbmV3IEludDMyQXJyYXkoMCk7XHJcblxyXG5jb25zdCBJTklUSUFMX1NJWkU6IG51bWJlciA9IDQ7XHJcbmNvbnN0IE1BWF9BUlJBWV9TSVpFOiBudW1iZXIgPSAoKCgxIDw8IDMxKSA+Pj4gMCkgLSAxKSAtIDg7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEludGVnZXJMaXN0IHtcclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgX2RhdGE6IEludDMyQXJyYXk7XHJcblxyXG5cdHByaXZhdGUgX3NpemU6IG51bWJlcjtcclxuXHJcblx0Y29uc3RydWN0b3IoYXJnPzogbnVtYmVyIHwgSW50ZWdlckxpc3QgfCBJdGVyYWJsZTxudW1iZXI+KSB7XHJcblx0XHRpZiAoIWFyZykge1xyXG5cdFx0XHR0aGlzLl9kYXRhID0gRU1QVFlfREFUQTtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IDA7XHJcblx0XHR9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEludGVnZXJMaXN0KSB7XHJcblx0XHRcdHRoaXMuX2RhdGEgPSBhcmcuX2RhdGEuc2xpY2UoMCk7XHJcblx0XHRcdHRoaXMuX3NpemUgPSBhcmcuX3NpemU7XHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0aWYgKGFyZyA9PT0gMCkge1xyXG5cdFx0XHRcdHRoaXMuX2RhdGEgPSBFTVBUWV9EQVRBO1xyXG5cdFx0XHRcdHRoaXMuX3NpemUgPSAwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuX2RhdGEgPSBuZXcgSW50MzJBcnJheShhcmcpO1xyXG5cdFx0XHRcdHRoaXMuX3NpemUgPSAwO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBhcmcgaXMgSXRlcmFibGU8bnVtYmVyPlxyXG5cdFx0XHR0aGlzLl9kYXRhID0gRU1QVFlfREFUQTtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IDA7XHJcblx0XHRcdGZvciAobGV0IHZhbHVlIG9mIGFyZykge1xyXG5cdFx0XHRcdHRoaXMuYWRkKHZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGFkZCh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5fZGF0YS5sZW5ndGggPT09IHRoaXMuX3NpemUpIHtcclxuXHRcdFx0dGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLl9zaXplICsgMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZGF0YVt0aGlzLl9zaXplXSA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fc2l6ZSsrO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFkZEFsbChsaXN0OiBudW1iZXJbXSB8IEludGVnZXJMaXN0IHwgSmF2YUNvbGxlY3Rpb248bnVtYmVyPik6IHZvaWQge1xyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkobGlzdCkpIHtcclxuXHRcdFx0dGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLl9zaXplICsgbGlzdC5sZW5ndGgpO1xyXG5cdFx0XHR0aGlzLl9kYXRhLnN1YmFycmF5KHRoaXMuX3NpemUsIHRoaXMuX3NpemUgKyBsaXN0Lmxlbmd0aCkuc2V0KGxpc3QpO1xyXG5cdFx0XHR0aGlzLl9zaXplICs9IGxpc3QubGVuZ3RoO1xyXG5cdFx0fSBlbHNlIGlmIChsaXN0IGluc3RhbmNlb2YgSW50ZWdlckxpc3QpIHtcclxuXHRcdFx0dGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLl9zaXplICsgbGlzdC5fc2l6ZSk7XHJcblx0XHRcdHRoaXMuX2RhdGEuc3ViYXJyYXkodGhpcy5fc2l6ZSwgdGhpcy5fc2l6ZSArIGxpc3Quc2l6ZSkuc2V0KGxpc3QuX2RhdGEpO1xyXG5cdFx0XHR0aGlzLl9zaXplICs9IGxpc3QuX3NpemU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBsaXN0IGlzIEphdmFDb2xsZWN0aW9uPG51bWJlcj5cclxuXHRcdFx0dGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLl9zaXplICsgbGlzdC5zaXplKTtcclxuXHRcdFx0bGV0IGN1cnJlbnQ6IG51bWJlciA9IDA7XHJcblx0XHRcdGZvciAobGV0IHhpIG9mIGxpc3QpIHtcclxuXHRcdFx0XHR0aGlzLl9kYXRhW3RoaXMuX3NpemUgKyBjdXJyZW50XSA9IHhpO1xyXG5cdFx0XHRcdGN1cnJlbnQrKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fc2l6ZSArPSBsaXN0LnNpemU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0KGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0aWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9zaXplKSB7XHJcblx0XHRcdHRocm93IFJhbmdlRXJyb3IoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fZGF0YVtpbmRleF07XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY29udGFpbnModmFsdWU6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX2RhdGFbaV0gPT09IHZhbHVlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0KGluZGV4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0aWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9zaXplKSB7XHJcblx0XHRcdHRocm93IFJhbmdlRXJyb3IoKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcHJldmlvdXM6IG51bWJlciA9IHRoaXMuX2RhdGFbaW5kZXhdO1xyXG5cdFx0dGhpcy5fZGF0YVtpbmRleF0gPSB2YWx1ZTtcclxuXHRcdHJldHVybiBwcmV2aW91cztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyByZW1vdmVBdChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGxldCB2YWx1ZTogbnVtYmVyID0gdGhpcy5nZXQoaW5kZXgpO1xyXG5cdFx0dGhpcy5fZGF0YS5jb3B5V2l0aGluKGluZGV4LCBpbmRleCArIDEsIHRoaXMuX3NpemUpO1xyXG5cdFx0dGhpcy5fZGF0YVt0aGlzLl9zaXplIC0gMV0gPSAwO1xyXG5cdFx0dGhpcy5fc2l6ZS0tO1xyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlbW92ZVJhbmdlKGZyb21JbmRleDogbnVtYmVyLCB0b0luZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmIChmcm9tSW5kZXggPCAwIHx8IHRvSW5kZXggPCAwIHx8IGZyb21JbmRleCA+IHRoaXMuX3NpemUgfHwgdG9JbmRleCA+IHRoaXMuX3NpemUpIHtcclxuXHRcdFx0dGhyb3cgUmFuZ2VFcnJvcigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChmcm9tSW5kZXggPiB0b0luZGV4KSB7XHJcblx0XHRcdHRocm93IFJhbmdlRXJyb3IoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9kYXRhLmNvcHlXaXRoaW4odG9JbmRleCwgZnJvbUluZGV4LCB0aGlzLl9zaXplKTtcclxuXHRcdHRoaXMuX2RhdGEuZmlsbCgwLCB0aGlzLl9zaXplIC0gKHRvSW5kZXggLSBmcm9tSW5kZXgpLCB0aGlzLl9zaXplKTtcclxuXHRcdHRoaXMuX3NpemUgLT0gKHRvSW5kZXggLSBmcm9tSW5kZXgpO1xyXG5cdH1cclxuXHJcblx0Z2V0IGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA9PT0gMDtcclxuXHR9XHJcblxyXG5cdGdldCBzaXplKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0cmltVG9TaXplKCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuX2RhdGEubGVuZ3RoID09PSB0aGlzLl9zaXplKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9kYXRhID0gdGhpcy5fZGF0YS5zbGljZSgwLCB0aGlzLl9zaXplKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcclxuXHRcdHRoaXMuX2RhdGEuZmlsbCgwLCAwLCB0aGlzLl9zaXplKTtcclxuXHRcdHRoaXMuX3NpemUgPSAwO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvQXJyYXkoKTogbnVtYmVyW10ge1xyXG5cdFx0aWYgKHRoaXMuX3NpemUgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2RhdGEuc3ViYXJyYXkoMCwgdGhpcy5fc2l6ZSkpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNvcnQoKTogdm9pZCB7XHJcblx0XHR0aGlzLl9kYXRhLnN1YmFycmF5KDAsIHRoaXMuX3NpemUpLnNvcnQoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXBhcmVzIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHdpdGggdGhpcyBsaXN0IGZvciBlcXVhbGl0eS4gIFJldHVybnNcclxuXHQgKiBgdHJ1ZWAgaWYgYW5kIG9ubHkgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYWxzbyBhbiB7QGxpbmsgSW50ZWdlckxpc3R9LFxyXG5cdCAqIGJvdGggbGlzdHMgaGF2ZSB0aGUgc2FtZSBzaXplLCBhbmQgYWxsIGNvcnJlc3BvbmRpbmcgcGFpcnMgb2YgZWxlbWVudHMgaW5cclxuXHQgKiB0aGUgdHdvIGxpc3RzIGFyZSBlcXVhbC4gIEluIG90aGVyIHdvcmRzLCB0d28gbGlzdHMgYXJlIGRlZmluZWQgdG8gYmVcclxuXHQgKiBlcXVhbCBpZiB0aGV5IGNvbnRhaW4gdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgb3JkZXIuXHJcblx0ICpcclxuXHQgKiBUaGlzIGltcGxlbWVudGF0aW9uIGZpcnN0IGNoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyB0aGlzXHJcblx0ICogbGlzdC4gSWYgc28sIGl0IHJldHVybnMgYHRydWVgOyBpZiBub3QsIGl0IGNoZWNrcyBpZiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgb2JqZWN0IGlzIGFuIHtAbGluayBJbnRlZ2VyTGlzdH0uIElmIG5vdCwgaXQgcmV0dXJucyBgZmFsc2VgO1xyXG5cdCAqIGlmIHNvLCBpdCBjaGVja3MgdGhlIHNpemUgb2YgYm90aCBsaXN0cy4gSWYgdGhlIGxpc3RzIGFyZSBub3QgdGhlIHNhbWUgc2l6ZSxcclxuXHQgKiBpdCByZXR1cm5zIGBmYWxzZWA7IG90aGVyd2lzZSBpdCBpdGVyYXRlcyBvdmVyIGJvdGggbGlzdHMsIGNvbXBhcmluZ1xyXG5cdCAqIGNvcnJlc3BvbmRpbmcgcGFpcnMgb2YgZWxlbWVudHMuICBJZiBhbnkgY29tcGFyaXNvbiByZXR1cm5zIGBmYWxzZWAsXHJcblx0ICogdGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIG8gdGhlIG9iamVjdCB0byBiZSBjb21wYXJlZCBmb3IgZXF1YWxpdHkgd2l0aCB0aGlzIGxpc3RcclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgZXF1YWwgdG8gdGhpcyBsaXN0XHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChvID09PSB0aGlzKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghKG8gaW5zdGFuY2VvZiBJbnRlZ2VyTGlzdCkpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaXplICE9PSBvLl9zaXplKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fZGF0YVtpXSAhPT0gby5fZGF0YVtpXSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgaGFzaCBjb2RlIHZhbHVlIGZvciB0aGlzIGxpc3QuXHJcblx0ICpcclxuXHQgKiBUaGlzIGltcGxlbWVudGF0aW9uIHVzZXMgZXhhY3RseSB0aGUgY29kZSB0aGF0IGlzIHVzZWQgdG8gZGVmaW5lIHRoZVxyXG5cdCAqIGxpc3QgaGFzaCBmdW5jdGlvbiBpbiB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIHtAbGluayBMaXN0I2hhc2hDb2RlfVxyXG5cdCAqIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHRoZSBoYXNoIGNvZGUgdmFsdWUgZm9yIHRoaXMgbGlzdFxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IGhhc2hDb2RlOiBudW1iZXIgPSAxO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcclxuXHRcdFx0aGFzaENvZGUgPSAzMSAqIGhhc2hDb2RlICsgdGhpcy5fZGF0YVtpXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaGFzaENvZGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbGlzdC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLl9kYXRhLnRvU3RyaW5nKCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYmluYXJ5U2VhcmNoKGtleTogbnVtYmVyLCBmcm9tSW5kZXg/OiBudW1iZXIsIHRvSW5kZXg/OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0aWYgKGZyb21JbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGZyb21JbmRleCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRvSW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0b0luZGV4ID0gdGhpcy5fc2l6ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZnJvbUluZGV4IDwgMCB8fCB0b0luZGV4IDwgMCB8fCBmcm9tSW5kZXggPiB0aGlzLl9zaXplIHx8IHRvSW5kZXggPiB0aGlzLl9zaXplKSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGZyb21JbmRleCA+IHRvSW5kZXgpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gQXJyYXlzLmJpbmFyeVNlYXJjaCh0aGlzLl9kYXRhLCBrZXksIGZyb21JbmRleCwgdG9JbmRleCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGVuc3VyZUNhcGFjaXR5KGNhcGFjaXR5OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmIChjYXBhY2l0eSA8IDAgfHwgY2FwYWNpdHkgPiBNQVhfQVJSQVlfU0laRSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBuZXdMZW5ndGg6IG51bWJlcjtcclxuXHRcdGlmICh0aGlzLl9kYXRhLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRuZXdMZW5ndGggPSBJTklUSUFMX1NJWkU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuZXdMZW5ndGggPSB0aGlzLl9kYXRhLmxlbmd0aDtcclxuXHRcdH1cclxuXHJcblx0XHR3aGlsZSAobmV3TGVuZ3RoIDwgY2FwYWNpdHkpIHtcclxuXHRcdFx0bmV3TGVuZ3RoID0gbmV3TGVuZ3RoICogMjtcclxuXHRcdFx0aWYgKG5ld0xlbmd0aCA8IDAgfHwgbmV3TGVuZ3RoID4gTUFYX0FSUkFZX1NJWkUpIHtcclxuXHRcdFx0XHRuZXdMZW5ndGggPSBNQVhfQVJSQVlfU0laRTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0bXAgPSBuZXcgSW50MzJBcnJheShuZXdMZW5ndGgpO1xyXG5cdFx0dG1wLnNldCh0aGlzLl9kYXRhKTtcclxuXHRcdHRoaXMuX2RhdGEgPSB0bXA7XHJcblx0fVxyXG5cclxuXHQvKiogQ29udmVydCB0aGUgbGlzdCB0byBhIFVURi0xNiBlbmNvZGVkIGNoYXIgYXJyYXkuIElmIGFsbCB2YWx1ZXMgYXJlIGxlc3NcclxuXHQgKiAgdGhhbiB0aGUgMHhGRkZGIDE2LWJpdCBjb2RlIHBvaW50IGxpbWl0IHRoZW4gdGhpcyBpcyBqdXN0IGEgY2hhciBhcnJheVxyXG5cdCAqICBvZiAxNi1iaXQgY2hhciBhcyB1c3VhbC4gRm9yIHZhbHVlcyBpbiB0aGUgc3VwcGxlbWVudGFyeSByYW5nZSwgZW5jb2RlXHJcblx0ICogdGhlbSBhcyB0d28gVVRGLTE2IGNvZGUgdW5pdHMuXHJcblx0ICovXHJcblx0cHVibGljIHRvQ2hhckFycmF5KCk6IFVpbnQxNkFycmF5IHtcclxuXHRcdC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2UgKGFsbCBkYXRhIHZhbHVlcyBhcmUgPCAweEZGRkYpIHRvIGF2b2lkIGFuIGV4dHJhIHNjYW5cclxuXHRcdGxldCByZXN1bHRBcnJheTogVWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkodGhpcy5fc2l6ZSk7XHJcblx0XHRsZXQgcmVzdWx0SWR4ID0gMDtcclxuXHRcdGxldCBjYWxjdWxhdGVkUHJlY2lzZVJlc3VsdFNpemUgPSBmYWxzZTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XHJcblx0XHRcdGxldCBjb2RlUG9pbnQgPSB0aGlzLl9kYXRhW2ldO1xyXG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDAgJiYgY29kZVBvaW50IDwgMHgxMDAwMCkge1xyXG5cdFx0XHRcdHJlc3VsdEFycmF5W3Jlc3VsdElkeF0gPSBjb2RlUG9pbnQ7XHJcblx0XHRcdFx0cmVzdWx0SWR4Kys7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgcHJlY2lzZSByZXN1bHQgc2l6ZSBpZiB3ZSBlbmNvdW50ZXIgYSBjb2RlIHBvaW50ID4gMHhGRkZGXHJcblx0XHRcdGlmICghY2FsY3VsYXRlZFByZWNpc2VSZXN1bHRTaXplKSB7XHJcblx0XHRcdFx0bGV0IG5ld1Jlc3VsdEFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuY2hhckFycmF5U2l6ZSgpKTtcclxuXHRcdFx0XHRuZXdSZXN1bHRBcnJheS5zZXQocmVzdWx0QXJyYXksIDApO1xyXG5cdFx0XHRcdHJlc3VsdEFycmF5ID0gbmV3UmVzdWx0QXJyYXk7XHJcblx0XHRcdFx0Y2FsY3VsYXRlZFByZWNpc2VSZXN1bHRTaXplID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IFJhbmdlRXJyb3IgaWYgdGhlIGNvZGUgcG9pbnQgaXMgbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XHJcblx0XHRcdGxldCBwYWlyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcclxuXHRcdFx0cmVzdWx0QXJyYXlbcmVzdWx0SWR4XSA9IHBhaXIuY2hhckNvZGVBdCgwKTtcclxuXHRcdFx0cmVzdWx0QXJyYXlbcmVzdWx0SWR4ICsgMV0gPSBwYWlyLmNoYXJDb2RlQXQoMSk7XHJcblx0XHRcdHJlc3VsdElkeCArPSAyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdEFycmF5O1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBjaGFyQXJyYXlTaXplKCk6IG51bWJlciB7XHJcblx0XHRsZXQgcmVzdWx0ID0gMDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XHJcblx0XHRcdHJlc3VsdCArPSB0aGlzLl9kYXRhW2ldID49IDB4MTAwMDAgPyAyIDogMTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0MC43NDAyMjE0LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IEVxdWF0YWJsZSB9IGZyb20gXCIuL1N0dWJzXCI7XHJcblxyXG5jb25zdCBJTlRFUlZBTF9QT09MX01BWF9WQUxVRTogbnVtYmVyID0gMTAwMDtcclxuXHJcbi8qKiBBbiBpbW11dGFibGUgaW5jbHVzaXZlIGludGVydmFsIGEuLmIgKi9cclxuZXhwb3J0IGNsYXNzIEludGVydmFsIGltcGxlbWVudHMgRXF1YXRhYmxlIHtcclxuXHRwcml2YXRlIHN0YXRpYyBfSU5WQUxJRDogSW50ZXJ2YWwgPSBuZXcgSW50ZXJ2YWwoLTEsIC0yKTtcclxuXHRzdGF0aWMgZ2V0IElOVkFMSUQoKTogSW50ZXJ2YWwge1xyXG5cdFx0cmV0dXJuIEludGVydmFsLl9JTlZBTElEO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgY2FjaGU6IEludGVydmFsW10gPSBuZXcgQXJyYXk8SW50ZXJ2YWw+KElOVEVSVkFMX1BPT0xfTUFYX1ZBTFVFICsgMSk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSBhIFRoZSBzdGFydCBvZiB0aGUgaW50ZXJ2YWxcclxuXHQgKiBAcGFyYW0gYiBUaGUgZW5kIG9mIHRoZSBpbnRlcnZhbCAoaW5jbHVzaXZlKVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHB1YmxpYyBhOiBudW1iZXIsIHB1YmxpYyBiOiBudW1iZXIpIHtcclxuXHR9XHJcblxyXG5cdC8qKiBJbnRlcnZhbCBvYmplY3RzIGFyZSB1c2VkIHJlYWRvbmx5IHNvIHNoYXJlIGFsbCB3aXRoIHRoZVxyXG5cdCAqICBzYW1lIHNpbmdsZSB2YWx1ZSBhPT1iIHVwIHRvIHNvbWUgbWF4IHNpemUuICBVc2UgYW4gYXJyYXkgYXMgYSBwZXJmZWN0IGhhc2guXHJcblx0ICogIFJldHVybiBzaGFyZWQgb2JqZWN0IGZvciAwLi5JTlRFUlZBTF9QT09MX01BWF9WQUxVRSBvciBhIG5ld1xyXG5cdCAqICBJbnRlcnZhbCBvYmplY3Qgd2l0aCBhLi5hIGluIGl0LiAgT24gSmF2YS5nNCwgMjE4NjIzIEludGVydmFsU2V0c1xyXG5cdCAqICBoYXZlIGEuLmEgKHNldCB3aXRoIDEgZWxlbWVudCkuXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyBvZihhOiBudW1iZXIsIGI6IG51bWJlcik6IEludGVydmFsIHtcclxuXHRcdC8vIGNhY2hlIGp1c3QgYS4uYVxyXG5cdFx0aWYgKGEgIT09IGIgfHwgYSA8IDAgfHwgYSA+IElOVEVSVkFMX1BPT0xfTUFYX1ZBTFVFKSB7XHJcblx0XHRcdHJldHVybiBuZXcgSW50ZXJ2YWwoYSwgYik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEludGVydmFsLmNhY2hlW2FdID09IG51bGwpIHtcclxuXHRcdFx0SW50ZXJ2YWwuY2FjaGVbYV0gPSBuZXcgSW50ZXJ2YWwoYSwgYSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEludGVydmFsLmNhY2hlW2FdO1xyXG5cdH1cclxuXHJcblx0LyoqIHJldHVybiBudW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiBhIGFuZCBiIGluY2x1c2l2ZWx5LiB4Li54IGlzIGxlbmd0aCAxLlxyXG5cdCAqICBpZiBiICZsdDsgYSwgdGhlbiBsZW5ndGggaXMgMC4gIDkuLjEwIGhhcyBsZW5ndGggMi5cclxuXHQgKi9cclxuXHRnZXQgbGVuZ3RoKCk6IG51bWJlciB7XHJcblx0XHRpZiAodGhpcy5iIDwgdGhpcy5hKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmIgLSB0aGlzLmEgKyAxO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChvID09PSB0aGlzKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoIShvIGluc3RhbmNlb2YgSW50ZXJ2YWwpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hID09PSBvLmEgJiYgdGhpcy5iID09PSBvLmI7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSAyMztcclxuXHRcdGhhc2ggPSBoYXNoICogMzEgKyB0aGlzLmE7XHJcblx0XHRoYXNoID0gaGFzaCAqIDMxICsgdGhpcy5iO1xyXG5cdFx0cmV0dXJuIGhhc2g7XHJcblx0fVxyXG5cclxuXHQvKiogRG9lcyB0aGlzIHN0YXJ0IGNvbXBsZXRlbHkgYmVmb3JlIG90aGVyPyBEaXNqb2ludCAqL1xyXG5cdHB1YmxpYyBzdGFydHNCZWZvcmVEaXNqb2ludChvdGhlcjogSW50ZXJ2YWwpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmEgPCBvdGhlci5hICYmIHRoaXMuYiA8IG90aGVyLmE7XHJcblx0fVxyXG5cclxuXHQvKiogRG9lcyB0aGlzIHN0YXJ0IGF0IG9yIGJlZm9yZSBvdGhlcj8gTm9uZGlzam9pbnQgKi9cclxuXHRwdWJsaWMgc3RhcnRzQmVmb3JlTm9uRGlzam9pbnQob3RoZXI6IEludGVydmFsKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5hIDw9IG90aGVyLmEgJiYgdGhpcy5iID49IG90aGVyLmE7XHJcblx0fVxyXG5cclxuXHQvKiogRG9lcyB0aGlzLmEgc3RhcnQgYWZ0ZXIgb3RoZXIuYj8gTWF5IG9yIG1heSBub3QgYmUgZGlzam9pbnQgKi9cclxuXHRwdWJsaWMgc3RhcnRzQWZ0ZXIob3RoZXI6IEludGVydmFsKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5hID4gb3RoZXIuYTtcclxuXHR9XHJcblxyXG5cdC8qKiBEb2VzIHRoaXMgc3RhcnQgY29tcGxldGVseSBhZnRlciBvdGhlcj8gRGlzam9pbnQgKi9cclxuXHRwdWJsaWMgc3RhcnRzQWZ0ZXJEaXNqb2ludChvdGhlcjogSW50ZXJ2YWwpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmEgPiBvdGhlci5iO1xyXG5cdH1cclxuXHJcblx0LyoqIERvZXMgdGhpcyBzdGFydCBhZnRlciBvdGhlcj8gTm9uRGlzam9pbnQgKi9cclxuXHRwdWJsaWMgc3RhcnRzQWZ0ZXJOb25EaXNqb2ludChvdGhlcjogSW50ZXJ2YWwpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmEgPiBvdGhlci5hICYmIHRoaXMuYSA8PSBvdGhlci5iOyAvLyB0aGlzLmI+PW90aGVyLmIgaW1wbGllZFxyXG5cdH1cclxuXHJcblx0LyoqIEFyZSBib3RoIHJhbmdlcyBkaXNqb2ludD8gSS5lLiwgbm8gb3ZlcmxhcD8gKi9cclxuXHRwdWJsaWMgZGlzam9pbnQob3RoZXI6IEludGVydmFsKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGFydHNCZWZvcmVEaXNqb2ludChvdGhlcikgfHwgdGhpcy5zdGFydHNBZnRlckRpc2pvaW50KG90aGVyKTtcclxuXHR9XHJcblxyXG5cdC8qKiBBcmUgdHdvIGludGVydmFscyBhZGphY2VudCBzdWNoIGFzIDAuLjQxIGFuZCA0Mi4uNDI/ICovXHJcblx0cHVibGljIGFkamFjZW50KG90aGVyOiBJbnRlcnZhbCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuYSA9PT0gb3RoZXIuYiArIDEgfHwgdGhpcy5iID09PSBvdGhlci5hIC0gMTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBwcm9wZXJseUNvbnRhaW5zKG90aGVyOiBJbnRlcnZhbCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIG90aGVyLmEgPj0gdGhpcy5hICYmIG90aGVyLmIgPD0gdGhpcy5iO1xyXG5cdH1cclxuXHJcblx0LyoqIFJldHVybiB0aGUgaW50ZXJ2YWwgY29tcHV0ZWQgZnJvbSBjb21iaW5pbmcgdGhpcyBhbmQgb3RoZXIgKi9cclxuXHRwdWJsaWMgdW5pb24ob3RoZXI6IEludGVydmFsKTogSW50ZXJ2YWwge1xyXG5cdFx0cmV0dXJuIEludGVydmFsLm9mKE1hdGgubWluKHRoaXMuYSwgb3RoZXIuYSksIE1hdGgubWF4KHRoaXMuYiwgb3RoZXIuYikpO1xyXG5cdH1cclxuXHJcblx0LyoqIFJldHVybiB0aGUgaW50ZXJ2YWwgaW4gY29tbW9uIGJldHdlZW4gdGhpcyBhbmQgbyAqL1xyXG5cdHB1YmxpYyBpbnRlcnNlY3Rpb24ob3RoZXI6IEludGVydmFsKTogSW50ZXJ2YWwge1xyXG5cdFx0cmV0dXJuIEludGVydmFsLm9mKE1hdGgubWF4KHRoaXMuYSwgb3RoZXIuYSksIE1hdGgubWluKHRoaXMuYiwgb3RoZXIuYikpO1xyXG5cdH1cclxuXHJcblx0LyoqIFJldHVybiB0aGUgaW50ZXJ2YWwgd2l0aCBlbGVtZW50cyBmcm9tIGB0aGlzYCBub3QgaW4gYG90aGVyYDtcclxuXHQgKiAgYG90aGVyYCBtdXN0IG5vdCBiZSB0b3RhbGx5IGVuY2xvc2VkIChwcm9wZXJseSBjb250YWluZWQpXHJcblx0ICogIHdpdGhpbiBgdGhpc2AsIHdoaWNoIHdvdWxkIHJlc3VsdCBpbiB0d28gZGlzam9pbnQgaW50ZXJ2YWxzXHJcblx0ICogIGluc3RlYWQgb2YgdGhlIHNpbmdsZSBvbmUgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QuXHJcblx0ICovXHJcblx0cHVibGljIGRpZmZlcmVuY2VOb3RQcm9wZXJseUNvbnRhaW5lZChvdGhlcjogSW50ZXJ2YWwpOiBJbnRlcnZhbCB8IHVuZGVmaW5lZCB7XHJcblx0XHRsZXQgZGlmZjogSW50ZXJ2YWwgfCB1bmRlZmluZWQ7XHJcblx0XHRpZiAob3RoZXIuc3RhcnRzQmVmb3JlTm9uRGlzam9pbnQodGhpcykpIHtcclxuXHRcdFx0Ly8gb3RoZXIuYSB0byBsZWZ0IG9mIHRoaXMuYSAob3Igc2FtZSlcclxuXHRcdFx0ZGlmZiA9IEludGVydmFsLm9mKE1hdGgubWF4KHRoaXMuYSwgb3RoZXIuYiArIDEpLCB0aGlzLmIpO1xyXG5cdFx0fSBlbHNlIGlmIChvdGhlci5zdGFydHNBZnRlck5vbkRpc2pvaW50KHRoaXMpKSB7XHJcblx0XHRcdC8vIG90aGVyLmEgdG8gcmlnaHQgb2YgdGhpcy5hXHJcblx0XHRcdGRpZmYgPSBJbnRlcnZhbC5vZih0aGlzLmEsIG90aGVyLmEgLSAxKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGlmZjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuYSArIFwiLi5cIiArIHRoaXMuYjtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU3Ljc4NjI4MDItMDc6MDBcclxuXHJcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiLi9DaGFyU3RyZWFtXCI7XHJcbmltcG9ydCB7IEludFN0cmVhbSB9IGZyb20gXCIuL0ludFN0cmVhbVwiO1xyXG5pbXBvcnQgeyBUb2tlblNvdXJjZSB9IGZyb20gXCIuL1Rva2VuU291cmNlXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4vVG9rZW5TdHJlYW1cIjtcclxuXHJcbi8qKiBBIHRva2VuIGhhcyBwcm9wZXJ0aWVzOiB0ZXh0LCB0eXBlLCBsaW5lLCBjaGFyYWN0ZXIgcG9zaXRpb24gaW4gdGhlIGxpbmVcclxuICogIChzbyB3ZSBjYW4gaWdub3JlIHRhYnMpLCB0b2tlbiBjaGFubmVsLCBpbmRleCwgYW5kIHNvdXJjZSBmcm9tIHdoaWNoXHJcbiAqICB3ZSBvYnRhaW5lZCB0aGlzIHRva2VuLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUb2tlbiB7XHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSB0ZXh0IG9mIHRoZSB0b2tlbi5cclxuXHQgKi9cclxuXHRyZWFkb25seSB0ZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKiBHZXQgdGhlIHRva2VuIHR5cGUgb2YgdGhlIHRva2VuICovXHJcblx0cmVhZG9ubHkgdHlwZTogbnVtYmVyO1xyXG5cclxuXHQvKiogVGhlIGxpbmUgbnVtYmVyIG9uIHdoaWNoIHRoZSAxc3QgY2hhcmFjdGVyIG9mIHRoaXMgdG9rZW4gd2FzIG1hdGNoZWQsXHJcblx0ICogIGxpbmU9MS4ublxyXG5cdCAqL1xyXG5cdHJlYWRvbmx5IGxpbmU6IG51bWJlcjtcclxuXHJcblx0LyoqIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoaXMgdG9rZW4gcmVsYXRpdmUgdG8gdGhlXHJcblx0ICogIGJlZ2lubmluZyBvZiB0aGUgbGluZSBhdCB3aGljaCBpdCBvY2N1cnMsIDAuLm4tMVxyXG5cdCAqL1xyXG5cdHJlYWRvbmx5IGNoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyO1xyXG5cclxuXHQvKiogUmV0dXJuIHRoZSBjaGFubmVsIHRoaXMgdG9rZW4uIEVhY2ggdG9rZW4gY2FuIGFycml2ZSBhdCB0aGUgcGFyc2VyXHJcblx0ICogIG9uIGEgZGlmZmVyZW50IGNoYW5uZWwsIGJ1dCB0aGUgcGFyc2VyIG9ubHkgXCJ0dW5lc1wiIHRvIGEgc2luZ2xlIGNoYW5uZWwuXHJcblx0ICogIFRoZSBwYXJzZXIgaWdub3JlcyBldmVyeXRoaW5nIG5vdCBvbiBERUZBVUxUX0NIQU5ORUwuXHJcblx0ICovXHJcblx0cmVhZG9ubHkgY2hhbm5lbDogbnVtYmVyO1xyXG5cclxuXHQvKiogQW4gaW5kZXggZnJvbSAwLi5uLTEgb2YgdGhlIHRva2VuIG9iamVjdCBpbiB0aGUgaW5wdXQgc3RyZWFtLlxyXG5cdCAqICBUaGlzIG11c3QgYmUgdmFsaWQgaW4gb3JkZXIgdG8gcHJpbnQgdG9rZW4gc3RyZWFtcyBhbmRcclxuXHQgKiAgdXNlIFRva2VuUmV3cml0ZVN0cmVhbS5cclxuXHQgKlxyXG5cdCAqICBSZXR1cm4gLTEgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHRva2VuIHdhcyBjb25qdXJlZCB1cCBzaW5jZVxyXG5cdCAqICBpdCBkb2Vzbid0IGhhdmUgYSB2YWxpZCBpbmRleC5cclxuXHQgKi9cclxuXHRyZWFkb25seSB0b2tlbkluZGV4OiBudW1iZXI7XHJcblxyXG5cdC8qKiBUaGUgc3RhcnRpbmcgY2hhcmFjdGVyIGluZGV4IG9mIHRoZSB0b2tlblxyXG5cdCAqICBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbDsgcmV0dXJuIC0xIGlmIG5vdCBpbXBsZW1lbnRlZC5cclxuXHQgKi9cclxuXHRyZWFkb25seSBzdGFydEluZGV4OiBudW1iZXI7XHJcblxyXG5cdC8qKiBUaGUgbGFzdCBjaGFyYWN0ZXIgaW5kZXggb2YgdGhlIHRva2VuLlxyXG5cdCAqICBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbDsgcmV0dXJuIC0xIGlmIG5vdCBpbXBsZW1lbnRlZC5cclxuXHQgKi9cclxuXHRyZWFkb25seSBzdG9wSW5kZXg6IG51bWJlcjtcclxuXHJcblx0LyoqIEdldHMgdGhlIHtAbGluayBUb2tlblNvdXJjZX0gd2hpY2ggY3JlYXRlZCB0aGlzIHRva2VuLlxyXG5cdCAqL1xyXG5cdHJlYWRvbmx5IHRva2VuU291cmNlOiBUb2tlblNvdXJjZSB8IHVuZGVmaW5lZDtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUge0BsaW5rIENoYXJTdHJlYW19IGZyb20gd2hpY2ggdGhpcyB0b2tlbiB3YXMgZGVyaXZlZC5cclxuXHQgKi9cclxuXHRyZWFkb25seSBpbnB1dFN0cmVhbTogQ2hhclN0cmVhbSB8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZXhwb3J0IG5hbWVzcGFjZSBUb2tlbiB7XHJcblx0ZXhwb3J0IGNvbnN0IElOVkFMSURfVFlQRTogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqIER1cmluZyBsb29rYWhlYWQgb3BlcmF0aW9ucywgdGhpcyBcInRva2VuXCIgc2lnbmlmaWVzIHdlIGhpdCBydWxlIGVuZCBBVE4gc3RhdGVcclxuXHQgKiAgYW5kIGRpZCBub3QgZm9sbG93IGl0IGRlc3BpdGUgbmVlZGluZyB0by5cclxuXHQgKi9cclxuXHRleHBvcnQgY29uc3QgRVBTSUxPTjogbnVtYmVyID0gLTI7XHJcblxyXG5cdGV4cG9ydCBjb25zdCBNSU5fVVNFUl9UT0tFTl9UWVBFOiBudW1iZXIgPSAxO1xyXG5cclxuXHRleHBvcnQgY29uc3QgRU9GOiBudW1iZXIgPSBJbnRTdHJlYW0uRU9GO1xyXG5cclxuXHQvKiogQWxsIHRva2VucyBnbyB0byB0aGUgcGFyc2VyICh1bmxlc3Mgc2tpcCgpIGlzIGNhbGxlZCBpbiB0aGF0IHJ1bGUpXHJcblx0ICogIG9uIGEgcGFydGljdWxhciBcImNoYW5uZWxcIi4gIFRoZSBwYXJzZXIgdHVuZXMgdG8gYSBwYXJ0aWN1bGFyIGNoYW5uZWxcclxuXHQgKiAgc28gdGhhdCB3aGl0ZXNwYWNlIGV0Yy4uLiBjYW4gZ28gdG8gdGhlIHBhcnNlciBvbiBhIFwiaGlkZGVuXCIgY2hhbm5lbC5cclxuXHQgKi9cclxuXHRleHBvcnQgY29uc3QgREVGQVVMVF9DSEFOTkVMOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKiogQW55dGhpbmcgb24gZGlmZmVyZW50IGNoYW5uZWwgdGhhbiBERUZBVUxUX0NIQU5ORUwgaXMgbm90IHBhcnNlZFxyXG5cdCAqICBieSBwYXJzZXIuXHJcblx0ICovXHJcblx0ZXhwb3J0IGNvbnN0IEhJRERFTl9DSEFOTkVMOiBudW1iZXIgPSAxO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBtaW5pbXVtIGNvbnN0YW50IHZhbHVlIHdoaWNoIGNhbiBiZSBhc3NpZ25lZCB0byBhXHJcblx0ICogdXNlci1kZWZpbmVkIHRva2VuIGNoYW5uZWwuXHJcblx0ICpcclxuXHQgKiBUaGUgbm9uLW5lZ2F0aXZlIG51bWJlcnMgbGVzcyB0aGFuIHtAbGluayAjTUlOX1VTRVJfQ0hBTk5FTF9WQUxVRX0gYXJlXHJcblx0ICogYXNzaWduZWQgdG8gdGhlIHByZWRlZmluZWQgY2hhbm5lbHMge0BsaW5rICNERUZBVUxUX0NIQU5ORUx9IGFuZFxyXG5cdCAqIHtAbGluayAjSElEREVOX0NIQU5ORUx9LlxyXG5cdCAqXHJcblx0ICogQHNlZSBgVG9rZW4uY2hhbm5lbGBcclxuXHQgKi9cclxuXHRleHBvcnQgY29uc3QgTUlOX1VTRVJfQ0hBTk5FTF9WQUxVRTogbnVtYmVyID0gMjtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTAuMTYxNDQwNC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU2ltdWxhdG9yIH0gZnJvbSBcIi4vYXRuL0FUTlNpbXVsYXRvclwiO1xyXG5pbXBvcnQgeyBDaGFyU3RyZWFtIH0gZnJvbSBcIi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5Tb3VyY2UgfSBmcm9tIFwiLi9Ub2tlblNvdXJjZVwiO1xyXG5pbXBvcnQgeyBXcml0YWJsZVRva2VuIH0gZnJvbSBcIi4vV3JpdGFibGVUb2tlblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIENvbW1vblRva2VuIGltcGxlbWVudHMgV3JpdGFibGVUb2tlbiB7XHJcblx0LyoqXHJcblx0ICogQW4gZW1wdHkge0BsaW5rIFR1cGxlMn0gd2hpY2ggaXMgdXNlZCBhcyB0aGUgZGVmYXVsdCB2YWx1ZSBvZlxyXG5cdCAqIHtAbGluayAjc291cmNlfSBmb3IgdG9rZW5zIHRoYXQgZG8gbm90IGhhdmUgYSBzb3VyY2UuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBFTVBUWV9TT1VSQ0U6IHsgc291cmNlPzogVG9rZW5Tb3VyY2UsIHN0cmVhbT86IENoYXJTdHJlYW0gfSA9XHJcblx0XHR7IHNvdXJjZTogdW5kZWZpbmVkLCBzdHJlYW06IHVuZGVmaW5lZCB9O1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgdHlwZWAuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfdHlwZTogbnVtYmVyO1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIHtAbGluayAjZ2V0TGluZX0gYW5kIHtAbGluayAjc2V0TGluZX0uXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfbGluZTogbnVtYmVyID0gMDtcclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciB7QGxpbmsgI2dldENoYXJQb3NpdGlvbkluTGluZX0gYW5kXHJcblx0ICoge0BsaW5rICNzZXRDaGFyUG9zaXRpb25JbkxpbmV9LlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX2NoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyID0gLTE7IC8vIHNldCB0byBpbnZhbGlkIHBvc2l0aW9uXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3Ige0BsaW5rICNnZXRDaGFubmVsfSBhbmRcclxuXHQgKiB7QGxpbmsgI3NldENoYW5uZWx9LlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX2NoYW5uZWw6IG51bWJlciA9IFRva2VuLkRFRkFVTFRfQ0hBTk5FTDtcclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciB7QGxpbmsgI2dldFRva2VuU291cmNlfSBhbmRcclxuXHQgKiB7QGxpbmsgI2dldElucHV0U3RyZWFtfS5cclxuXHQgKlxyXG5cdCAqIFRoZXNlIHByb3BlcnRpZXMgc2hhcmUgYSBmaWVsZCB0byByZWR1Y2UgdGhlIG1lbW9yeSBmb290cHJpbnQgb2ZcclxuXHQgKiB7QGxpbmsgQ29tbW9uVG9rZW59LiBUb2tlbnMgY3JlYXRlZCBieSBhIHtAbGluayBDb21tb25Ub2tlbkZhY3Rvcnl9IGZyb21cclxuXHQgKiB0aGUgc2FtZSBzb3VyY2UgYW5kIGlucHV0IHN0cmVhbSBzaGFyZSBhIHJlZmVyZW5jZSB0byB0aGUgc2FtZVxyXG5cdCAqIHtAbGluayBUdXBsZTJ9IGNvbnRhaW5pbmcgdGhlc2UgdmFsdWVzLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIHNvdXJjZTogeyBzb3VyY2U/OiBUb2tlblNvdXJjZSwgc3RyZWFtPzogQ2hhclN0cmVhbSB9O1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciB7QGxpbmsgI2dldFRleHR9IHdoZW4gdGhlIHRva2VuIHRleHQgaXNcclxuXHQgKiBleHBsaWNpdGx5IHNldCBpbiB0aGUgY29uc3RydWN0b3Igb3IgdmlhIHtAbGluayAjc2V0VGV4dH0uXHJcblx0ICpcclxuXHQgKiBAc2VlIGB0ZXh0YFxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX3RleHQ/OiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGB0b2tlbkluZGV4YC5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgaW5kZXg6IG51bWJlciA9IC0xO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgc3RhcnRJbmRleGAuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHN0YXJ0OiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBzdG9wSW5kZXhgLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgc3RvcDogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcih0eXBlOiBudW1iZXIsIHRleHQ/OiBzdHJpbmcsIEBOb3ROdWxsIHNvdXJjZTogeyBzb3VyY2U/OiBUb2tlblNvdXJjZSwgc3RyZWFtPzogQ2hhclN0cmVhbSB9ID0gQ29tbW9uVG9rZW4uRU1QVFlfU09VUkNFLCBjaGFubmVsOiBudW1iZXIgPSBUb2tlbi5ERUZBVUxUX0NIQU5ORUwsIHN0YXJ0OiBudW1iZXIgPSAwLCBzdG9wOiBudW1iZXIgPSAwKSB7XHJcblx0XHR0aGlzLl90ZXh0ID0gdGV4dDtcclxuXHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xyXG5cdFx0dGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblx0XHR0aGlzLl9jaGFubmVsID0gY2hhbm5lbDtcclxuXHRcdHRoaXMuc3RhcnQgPSBzdGFydDtcclxuXHRcdHRoaXMuc3RvcCA9IHN0b3A7XHJcblx0XHRpZiAoc291cmNlLnNvdXJjZSAhPSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2xpbmUgPSBzb3VyY2Uuc291cmNlLmxpbmU7XHJcblx0XHRcdHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSA9IHNvdXJjZS5zb3VyY2UuY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyB7QGxpbmsgQ29tbW9uVG9rZW59IGFzIGEgY29weSBvZiBhbm90aGVyIHtAbGluayBUb2tlbn0uXHJcblx0ICpcclxuXHQgKiBJZiBgb2xkVG9rZW5gIGlzIGFsc28gYSB7QGxpbmsgQ29tbW9uVG9rZW59IGluc3RhbmNlLCB0aGUgbmV3bHlcclxuXHQgKiBjb25zdHJ1Y3RlZCB0b2tlbiB3aWxsIHNoYXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB7QGxpbmsgI3RleHR9IGZpZWxkIGFuZFxyXG5cdCAqIHRoZSB7QGxpbmsgVHVwbGUyfSBzdG9yZWQgaW4ge0BsaW5rICNzb3VyY2V9LiBPdGhlcndpc2UsIHtAbGluayAjdGV4dH0gd2lsbFxyXG5cdCAqIGJlIGFzc2lnbmVkIHRoZSByZXN1bHQgb2YgY2FsbGluZyB7QGxpbmsgI2dldFRleHR9LCBhbmQge0BsaW5rICNzb3VyY2V9XHJcblx0ICogd2lsbCBiZSBjb25zdHJ1Y3RlZCBmcm9tIHRoZSByZXN1bHQgb2Yge0BsaW5rIFRva2VuI2dldFRva2VuU291cmNlfSBhbmRcclxuXHQgKiB7QGxpbmsgVG9rZW4jZ2V0SW5wdXRTdHJlYW19LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIG9sZFRva2VuIFRoZSB0b2tlbiB0byBjb3B5LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgZnJvbVRva2VuKEBOb3ROdWxsIG9sZFRva2VuOiBUb2tlbik6IENvbW1vblRva2VuIHtcclxuXHRcdGxldCByZXN1bHQ6IENvbW1vblRva2VuID0gbmV3IENvbW1vblRva2VuKG9sZFRva2VuLnR5cGUsIHVuZGVmaW5lZCwgQ29tbW9uVG9rZW4uRU1QVFlfU09VUkNFLCBvbGRUb2tlbi5jaGFubmVsLCBvbGRUb2tlbi5zdGFydEluZGV4LCBvbGRUb2tlbi5zdG9wSW5kZXgpO1xyXG5cdFx0cmVzdWx0Ll9saW5lID0gb2xkVG9rZW4ubGluZTtcclxuXHRcdHJlc3VsdC5pbmRleCA9IG9sZFRva2VuLnRva2VuSW5kZXg7XHJcblx0XHRyZXN1bHQuX2NoYXJQb3NpdGlvbkluTGluZSA9IG9sZFRva2VuLmNoYXJQb3NpdGlvbkluTGluZTtcclxuXHJcblx0XHRpZiAob2xkVG9rZW4gaW5zdGFuY2VvZiBDb21tb25Ub2tlbikge1xyXG5cdFx0XHRyZXN1bHQuX3RleHQgPSBvbGRUb2tlbi5fdGV4dDtcclxuXHRcdFx0cmVzdWx0LnNvdXJjZSA9IG9sZFRva2VuLnNvdXJjZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlc3VsdC5fdGV4dCA9IG9sZFRva2VuLnRleHQ7XHJcblx0XHRcdHJlc3VsdC5zb3VyY2UgPSB7IHNvdXJjZTogb2xkVG9rZW4udG9rZW5Tb3VyY2UsIHN0cmVhbTogb2xkVG9rZW4uaW5wdXRTdHJlYW0gfTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHR5cGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl90eXBlO1xyXG5cdH1cclxuXHJcblx0Ly8gQE92ZXJyaWRlXHJcblx0c2V0IHR5cGUodHlwZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBsaW5lKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGluZTtcclxuXHR9XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHNldCBsaW5lKGxpbmU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5fbGluZSA9IGxpbmU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgdGV4dCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKHRoaXMuX3RleHQgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fdGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgaW5wdXQ6IENoYXJTdHJlYW0gfCB1bmRlZmluZWQgPSB0aGlzLmlucHV0U3RyZWFtO1xyXG5cdFx0aWYgKGlucHV0ID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbjogbnVtYmVyID0gaW5wdXQuc2l6ZTtcclxuXHRcdGlmICh0aGlzLnN0YXJ0IDwgbiAmJiB0aGlzLnN0b3AgPCBuKSB7XHJcblx0XHRcdHJldHVybiBpbnB1dC5nZXRUZXh0KEludGVydmFsLm9mKHRoaXMuc3RhcnQsIHRoaXMuc3RvcCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIFwiPEVPRj5cIjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4cGxpY2l0bHkgc2V0IHRoZSB0ZXh0IGZvciB0aGlzIHRva2VuLiBJZiB7Y29kZSB0ZXh0fSBpcyBub3RcclxuXHQgKiBgdW5kZWZpbmVkYCwgdGhlbiB7QGxpbmsgI2dldFRleHR9IHdpbGwgcmV0dXJuIHRoaXMgdmFsdWUgcmF0aGVyIHRoYW5cclxuXHQgKiBleHRyYWN0aW5nIHRoZSB0ZXh0IGZyb20gdGhlIGlucHV0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHRleHQgVGhlIGV4cGxpY2l0IHRleHQgb2YgdGhlIHRva2VuLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgdGV4dFxyXG5cdCAqIHNob3VsZCBiZSBvYnRhaW5lZCBmcm9tIHRoZSBpbnB1dCBhbG9uZyB3aXRoIHRoZSBzdGFydCBhbmQgc3RvcCBpbmRleGVzXHJcblx0ICogb2YgdGhlIHRva2VuLlxyXG5cdCAqL1xyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHNldCB0ZXh0KHRleHQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5fdGV4dCA9IHRleHQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgY2hhclBvc2l0aW9uSW5MaW5lKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdH1cclxuXHJcblx0Ly8gQE92ZXJyaWRlXHJcblx0c2V0IGNoYXJQb3NpdGlvbkluTGluZShjaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lID0gY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGNoYW5uZWwoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9jaGFubmVsO1xyXG5cdH1cclxuXHJcblx0Ly8gQE92ZXJyaWRlXHJcblx0c2V0IGNoYW5uZWwoY2hhbm5lbDogbnVtYmVyKSB7XHJcblx0XHR0aGlzLl9jaGFubmVsID0gY2hhbm5lbDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdGFydEluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGFydDtcclxuXHR9XHJcblxyXG5cdHNldCBzdGFydEluZGV4KHN0YXJ0OiBudW1iZXIpIHtcclxuXHRcdHRoaXMuc3RhcnQgPSBzdGFydDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdG9wSW5kZXgoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLnN0b3A7XHJcblx0fVxyXG5cclxuXHRzZXQgc3RvcEluZGV4KHN0b3A6IG51bWJlcikge1xyXG5cdFx0dGhpcy5zdG9wID0gc3RvcDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCB0b2tlbkluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbmRleDtcclxuXHR9XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHNldCB0b2tlbkluZGV4KGluZGV4OiBudW1iZXIpIHtcclxuXHRcdHRoaXMuaW5kZXggPSBpbmRleDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCB0b2tlblNvdXJjZSgpOiBUb2tlblNvdXJjZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5zb3VyY2Uuc291cmNlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlucHV0U3RyZWFtKCk6IENoYXJTdHJlYW0gfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuc291cmNlLnN0cmVhbTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmc7XHJcblx0cHVibGljIHRvU3RyaW5nPFRTeW1ib2wsIEFUTkludGVycHJldGVyIGV4dGVuZHMgQVROU2ltdWxhdG9yPihyZWNvZ25pemVyOiBSZWNvZ25pemVyPFRTeW1ib2wsIEFUTkludGVycHJldGVyPiB8IHVuZGVmaW5lZCk6IHN0cmluZztcclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nPFRTeW1ib2wsIEFUTkludGVycHJldGVyIGV4dGVuZHMgQVROU2ltdWxhdG9yPihyZWNvZ25pemVyPzogUmVjb2duaXplcjxUU3ltYm9sLCBBVE5JbnRlcnByZXRlcj4pOiBzdHJpbmcge1xyXG5cdFx0bGV0IGNoYW5uZWxTdHI6IHN0cmluZyA9IFwiXCI7XHJcblx0XHRpZiAodGhpcy5fY2hhbm5lbCA+IDApIHtcclxuXHRcdFx0Y2hhbm5lbFN0ciA9IFwiLGNoYW5uZWw9XCIgKyB0aGlzLl9jaGFubmVsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0eHQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHRoaXMudGV4dDtcclxuXHRcdGlmICh0eHQgIT0gbnVsbCkge1xyXG5cdFx0XHR0eHQgPSB0eHQucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIik7XHJcblx0XHRcdHR4dCA9IHR4dC5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKTtcclxuXHRcdFx0dHh0ID0gdHh0LnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHh0ID0gXCI8bm8gdGV4dD5cIjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdHlwZVN0cmluZyA9IFN0cmluZyh0aGlzLl90eXBlKTtcclxuXHRcdGlmIChyZWNvZ25pemVyKSB7XHJcblx0XHRcdHR5cGVTdHJpbmcgPSByZWNvZ25pemVyLnZvY2FidWxhcnkuZ2V0RGlzcGxheU5hbWUodGhpcy5fdHlwZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFwiW0BcIiArIHRoaXMudG9rZW5JbmRleCArIFwiLFwiICsgdGhpcy5zdGFydCArIFwiOlwiICsgdGhpcy5zdG9wICsgXCI9J1wiICsgdHh0ICsgXCInLDxcIiArIHR5cGVTdHJpbmcgKyBcIj5cIiArIGNoYW5uZWxTdHIgKyBcIixcIiArIHRoaXMuX2xpbmUgKyBcIjpcIiArIHRoaXMuY2hhclBvc2l0aW9uSW5MaW5lICsgXCJdXCI7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1MC4zMDEwMTEyLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBDaGFyU3RyZWFtIH0gZnJvbSBcIi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBDb21tb25Ub2tlbiB9IGZyb20gXCIuL0NvbW1vblRva2VuXCI7XHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVG9rZW5GYWN0b3J5IH0gZnJvbSBcIi4vVG9rZW5GYWN0b3J5XCI7XHJcbmltcG9ydCB7IFRva2VuU291cmNlIH0gZnJvbSBcIi4vVG9rZW5Tb3VyY2VcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFRva2VuRmFjdG9yeX0gY3JlYXRlc1xyXG4gKiB7QGxpbmsgQ29tbW9uVG9rZW59IG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ29tbW9uVG9rZW5GYWN0b3J5IGltcGxlbWVudHMgVG9rZW5GYWN0b3J5IHtcclxuXHQvKipcclxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB7QGxpbmsgQ29tbW9uVG9rZW4jc2V0VGV4dH0gc2hvdWxkIGJlIGNhbGxlZCBhZnRlclxyXG5cdCAqIGNvbnN0cnVjdGluZyB0b2tlbnMgdG8gZXhwbGljaXRseSBzZXQgdGhlIHRleHQuIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlc1xyXG5cdCAqIHdoZXJlIHRoZSBpbnB1dCBzdHJlYW0gbWlnaHQgbm90IGJlIGFibGUgdG8gcHJvdmlkZSBhcmJpdHJhcnkgc3Vic3RyaW5nc1xyXG5cdCAqIG9mIHRleHQgZnJvbSB0aGUgaW5wdXQgYWZ0ZXIgdGhlIGxleGVyIGNyZWF0ZXMgYSB0b2tlbiAoZS5nLiB0aGVcclxuXHQgKiBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ2hhclN0cmVhbSNnZXRUZXh0fSBpblxyXG5cdCAqIHtAbGluayBVbmJ1ZmZlcmVkQ2hhclN0cmVhbX1cclxuXHQgKiB7QGxpbmsgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb259KS4gRXhwbGljaXRseSBzZXR0aW5nIHRoZSB0b2tlbiB0ZXh0XHJcblx0ICogYWxsb3dzIHtAbGluayBUb2tlbiNnZXRUZXh0fSB0byBiZSBjYWxsZWQgYXQgYW55IHRpbWUgcmVnYXJkbGVzcyBvZiB0aGVcclxuXHQgKiBpbnB1dCBzdHJlYW0gaW1wbGVtZW50YXRpb24uXHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgIHRvIGF2b2lkIHRoZSBwZXJmb3JtYW5jZSBhbmQgbWVtb3J5XHJcblx0ICogb3ZlcmhlYWQgb2YgY29weWluZyB0ZXh0IGZvciBldmVyeSB0b2tlbiB1bmxlc3MgZXhwbGljaXRseSByZXF1ZXN0ZWQuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGNvcHlUZXh0OiBib29sZWFuO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIENvbW1vblRva2VuRmFjdG9yeX0gd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlIGZvclxyXG5cdCAqIHtAbGluayAjY29weVRleHR9LlxyXG5cdCAqXHJcblx0ICogV2hlbiBgY29weVRleHRgIGlzIGBmYWxzZWAsIHRoZSB7QGxpbmsgI0RFRkFVTFR9IGluc3RhbmNlXHJcblx0ICogc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiBjb25zdHJ1Y3RpbmcgYSBuZXcgaW5zdGFuY2UuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gY29weVRleHQgVGhlIHZhbHVlIGZvciB7QGxpbmsgI2NvcHlUZXh0fS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcihjb3B5VGV4dDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcblx0XHR0aGlzLmNvcHlUZXh0ID0gY29weVRleHQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgY3JlYXRlKFxyXG5cdFx0c291cmNlOiB7IHNvdXJjZT86IFRva2VuU291cmNlLCBzdHJlYW0/OiBDaGFyU3RyZWFtIH0sXHJcblx0XHR0eXBlOiBudW1iZXIsXHJcblx0XHR0ZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQsXHJcblx0XHRjaGFubmVsOiBudW1iZXIsXHJcblx0XHRzdGFydDogbnVtYmVyLFxyXG5cdFx0c3RvcDogbnVtYmVyLFxyXG5cdFx0bGluZTogbnVtYmVyLFxyXG5cdFx0Y2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXIpOiBDb21tb25Ub2tlbiB7XHJcblxyXG5cdFx0bGV0IHQ6IENvbW1vblRva2VuID0gbmV3IENvbW1vblRva2VuKHR5cGUsIHRleHQsIHNvdXJjZSwgY2hhbm5lbCwgc3RhcnQsIHN0b3ApO1xyXG5cdFx0dC5saW5lID0gbGluZTtcclxuXHRcdHQuY2hhclBvc2l0aW9uSW5MaW5lID0gY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdFx0aWYgKHRleHQgPT0gbnVsbCAmJiB0aGlzLmNvcHlUZXh0ICYmIHNvdXJjZS5zdHJlYW0gIT0gbnVsbCkge1xyXG5cdFx0XHR0LnRleHQgPSBzb3VyY2Uuc3RyZWFtLmdldFRleHQoSW50ZXJ2YWwub2Yoc3RhcnQsIHN0b3ApKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjcmVhdGVTaW1wbGUodHlwZTogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpOiBDb21tb25Ub2tlbiB7XHJcblx0XHRyZXR1cm4gbmV3IENvbW1vblRva2VuKHR5cGUsIHRleHQpO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IG5hbWVzcGFjZSBDb21tb25Ub2tlbkZhY3Rvcnkge1xyXG5cdC8qKlxyXG5cdCAqIFRoZSBkZWZhdWx0IHtAbGluayBDb21tb25Ub2tlbkZhY3Rvcnl9IGluc3RhbmNlLlxyXG5cdCAqXHJcblx0ICogVGhpcyB0b2tlbiBmYWN0b3J5IGRvZXMgbm90IGV4cGxpY2l0bHkgY29weSB0b2tlbiB0ZXh0IHdoZW4gY29uc3RydWN0aW5nXHJcblx0ICogdG9rZW5zLlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBjb25zdCBERUZBVUxUOiBUb2tlbkZhY3RvcnkgPSBuZXcgQ29tbW9uVG9rZW5GYWN0b3J5KCk7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQwLjY2NDcxMDEtMDc6MDBcclxuXHJcbmltcG9ydCB7IEludGVnZXJMaXN0IH0gZnJvbSBcIi4vSW50ZWdlckxpc3RcIjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW50ZWdlclN0YWNrIGV4dGVuZHMgSW50ZWdlckxpc3Qge1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihhcmc/OiBudW1iZXIgfCBJbnRlZ2VyU3RhY2spIHtcclxuXHRcdHN1cGVyKGFyZyk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcHVzaCh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLmFkZCh2YWx1ZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcG9wKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVBdCh0aGlzLnNpemUgLSAxKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBwZWVrKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXQodGhpcy5zaXplIC0gMSk7XHJcblx0fVxyXG5cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzguMTE3MjA3Ni0wNzowMFxyXG5cclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb25FeGVjdXRvciB9IGZyb20gXCIuLi9hdG4vTGV4ZXJBY3Rpb25FeGVjdXRvclwiO1xyXG5cclxuLyoqXHJcbiAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBhIHtAbGluayBERkFTdGF0ZX0gd2hpY2ggaXMgYW4gYWNjZXB0IHN0YXRlIHVuZGVyXHJcbiAqIHNvbWUgY29uZGl0aW9uLiBDZXJ0YWluIHNldHRpbmdzLCBzdWNoIGFzXHJcbiAqIHtAbGluayBQYXJzZXJBVE5TaW11bGF0b3IjZ2V0UHJlZGljdGlvbk1vZGUoKX0sIG1heSBiZSB1c2VkIGluIGFkZGl0aW9uIHRvXHJcbiAqIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGEgcGFydGljdWxhciBzdGF0ZSBpcyBhbiBhY2NlcHRcclxuICogc3RhdGUuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBY2NlcHRTdGF0ZUluZm8ge1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgX3ByZWRpY3Rpb246IG51bWJlcjtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9sZXhlckFjdGlvbkV4ZWN1dG9yPzogTGV4ZXJBY3Rpb25FeGVjdXRvcjtcclxuXHJcblx0Y29uc3RydWN0b3IocHJlZGljdGlvbjogbnVtYmVyKTtcclxuXHRjb25zdHJ1Y3RvcihwcmVkaWN0aW9uOiBudW1iZXIsIGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQpO1xyXG5cdGNvbnN0cnVjdG9yKHByZWRpY3Rpb246IG51bWJlciwgbGV4ZXJBY3Rpb25FeGVjdXRvcj86IExleGVyQWN0aW9uRXhlY3V0b3IpIHtcclxuXHRcdHRoaXMuX3ByZWRpY3Rpb24gPSBwcmVkaWN0aW9uO1xyXG5cdFx0dGhpcy5fbGV4ZXJBY3Rpb25FeGVjdXRvciA9IGxleGVyQWN0aW9uRXhlY3V0b3I7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBwcmVkaWN0aW9uIG1hZGUgYnkgdGhpcyBhY2NlcHQgc3RhdGUuIE5vdGUgdGhhdCB0aGlzIHZhbHVlXHJcblx0ICogYXNzdW1lcyB0aGUgcHJlZGljYXRlcywgaWYgYW55LCBpbiB0aGUge0BsaW5rIERGQVN0YXRlfSBldmFsdWF0ZSB0b1xyXG5cdCAqIGB0cnVlYC4gSWYgcHJlZGljYXRlIGV2YWx1YXRpb24gaXMgZW5hYmxlZCwgdGhlIGZpbmFsIHByZWRpY3Rpb24gb2ZcclxuXHQgKiB0aGUgYWNjZXB0IHN0YXRlIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB0aGUgcmVzdWx0IG9mIHByZWRpY2F0ZVxyXG5cdCAqIGV2YWx1YXRpb24uXHJcblx0ICovXHJcblx0Z2V0IHByZWRpY3Rpb24oKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9wcmVkaWN0aW9uO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUge0BsaW5rIExleGVyQWN0aW9uRXhlY3V0b3J9IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGV4ZWN1dGUgYWN0aW9uc1xyXG5cdCAqIGFuZC9vciBjb21tYW5kcyBhZnRlciB0aGUgbGV4ZXIgbWF0Y2hlcyBhIHRva2VuLlxyXG5cdCAqL1xyXG5cdGdldCBsZXhlckFjdGlvbkV4ZWN1dG9yKCk6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xleGVyQWN0aW9uRXhlY3V0b3I7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEFycmF5MkRIYXNoU2V0IH0gZnJvbSBcIi4vQXJyYXkyREhhc2hTZXRcIjtcclxuaW1wb3J0IHsgRGVmYXVsdEVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuL0RlZmF1bHRFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgRXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4vRXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IEVxdWF0YWJsZSwgSmF2YUNvbGxlY3Rpb24sIEphdmFNYXAsIEphdmFTZXQgfSBmcm9tIFwiLi9TdHVic1wiO1xyXG5cclxuLy8gU2luY2UgYEFycmF5MkRIYXNoTWFwYCBpcyBpbXBsZW1lbnRlZCBvbiB0b3Agb2YgYEFycmF5MkRIYXNoU2V0YCwgd2UgZGVmaW5lZCBhIGJ1Y2tldCB0eXBlIHdoaWNoIGNhbiBzdG9yZSBhXHJcbi8vIGtleS12YWx1ZSBwYWlyLiBUaGUgdmFsdWUgaXMgb3B0aW9uYWwgc2luY2UgbG9va2luZyB1cCB2YWx1ZXMgaW4gdGhlIG1hcCBieSBhIGtleSBvbmx5IG5lZWRzIHRvIGluY2x1ZGUgdGhlIGtleS5cclxuaW50ZXJmYWNlIEJ1Y2tldDxLLCBWPiB7IGtleTogSzsgdmFsdWU/OiBWOyB9XHJcblxyXG5jbGFzcyBNYXBLZXlFcXVhbGl0eUNvbXBhcmF0b3I8SywgVj4gaW1wbGVtZW50cyBFcXVhbGl0eUNvbXBhcmF0b3I8QnVja2V0PEssIFY+PiB7XHJcblx0cHJpdmF0ZSByZWFkb25seSBrZXlDb21wYXJhdG9yOiBFcXVhbGl0eUNvbXBhcmF0b3I8Sz47XHJcblxyXG5cdGNvbnN0cnVjdG9yKGtleUNvbXBhcmF0b3I6IEVxdWFsaXR5Q29tcGFyYXRvcjxLPikge1xyXG5cdFx0dGhpcy5rZXlDb21wYXJhdG9yID0ga2V5Q29tcGFyYXRvcjtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBoYXNoQ29kZShvYmo6IEJ1Y2tldDxLLCBWPik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5rZXlDb21wYXJhdG9yLmhhc2hDb2RlKG9iai5rZXkpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGVxdWFscyhhOiBCdWNrZXQ8SywgVj4sIGI6IEJ1Y2tldDxLLCBWPik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMua2V5Q29tcGFyYXRvci5lcXVhbHMoYS5rZXksIGIua2V5KTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBBcnJheTJESGFzaE1hcDxLLCBWPiBpbXBsZW1lbnRzIEphdmFNYXA8SywgVj4ge1xyXG5cdHByaXZhdGUgYmFja2luZ1N0b3JlOiBBcnJheTJESGFzaFNldDxCdWNrZXQ8SywgVj4+O1xyXG5cclxuXHRjb25zdHJ1Y3RvcihrZXlDb21wYXJlcjogRXF1YWxpdHlDb21wYXJhdG9yPEs+KTtcclxuXHRjb25zdHJ1Y3RvcihtYXA6IEFycmF5MkRIYXNoTWFwPEssIFY+KTtcclxuXHRjb25zdHJ1Y3RvcihrZXlDb21wYXJlcjogRXF1YWxpdHlDb21wYXJhdG9yPEs+IHwgQXJyYXkyREhhc2hNYXA8SywgVj4pIHtcclxuXHRcdGlmIChrZXlDb21wYXJlciBpbnN0YW5jZW9mIEFycmF5MkRIYXNoTWFwKSB7XHJcblx0XHRcdHRoaXMuYmFja2luZ1N0b3JlID0gbmV3IEFycmF5MkRIYXNoU2V0PEJ1Y2tldDxLLCBWPj4oa2V5Q29tcGFyZXIuYmFja2luZ1N0b3JlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuYmFja2luZ1N0b3JlID0gbmV3IEFycmF5MkRIYXNoU2V0PEJ1Y2tldDxLLCBWPj4obmV3IE1hcEtleUVxdWFsaXR5Q29tcGFyYXRvcjxLLCBWPihrZXlDb21wYXJlcikpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGNsZWFyKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5iYWNraW5nU3RvcmUuY2xlYXIoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBjb250YWluc0tleShrZXk6IEspOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmJhY2tpbmdTdG9yZS5jb250YWlucyh7IGtleSB9KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXQoa2V5OiBLKTogViB8IHVuZGVmaW5lZCB7XHJcblx0XHRsZXQgYnVja2V0ID0gdGhpcy5iYWNraW5nU3RvcmUuZ2V0KHsga2V5IH0pO1xyXG5cdFx0aWYgKCFidWNrZXQpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYnVja2V0LnZhbHVlO1xyXG5cdH1cclxuXHJcblx0Z2V0IGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUuaXNFbXB0eTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBwdXQoa2V5OiBLLCB2YWx1ZTogVik6IFYgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IGVsZW1lbnQgPSB0aGlzLmJhY2tpbmdTdG9yZS5nZXQoeyBrZXksIHZhbHVlIH0pO1xyXG5cdFx0bGV0IHJlc3VsdDogViB8IHVuZGVmaW5lZDtcclxuXHRcdGlmICghZWxlbWVudCkge1xyXG5cdFx0XHR0aGlzLmJhY2tpbmdTdG9yZS5hZGQoeyBrZXksIHZhbHVlIH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVzdWx0ID0gZWxlbWVudC52YWx1ZTtcclxuXHRcdFx0ZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcHV0SWZBYnNlbnQoa2V5OiBLLCB2YWx1ZTogVik6IFYgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IGVsZW1lbnQgPSB0aGlzLmJhY2tpbmdTdG9yZS5nZXQoeyBrZXksIHZhbHVlIH0pO1xyXG5cdFx0bGV0IHJlc3VsdDogViB8IHVuZGVmaW5lZDtcclxuXHRcdGlmICghZWxlbWVudCkge1xyXG5cdFx0XHR0aGlzLmJhY2tpbmdTdG9yZS5hZGQoeyBrZXksIHZhbHVlIH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVzdWx0ID0gZWxlbWVudC52YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0Z2V0IHNpemUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmJhY2tpbmdTdG9yZS5zaXplO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUuaGFzaENvZGUoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBlcXVhbHMobzogYW55KTogYm9vbGVhbiB7XHJcblx0XHRpZiAoIShvIGluc3RhbmNlb2YgQXJyYXkyREhhc2hNYXApKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUuZXF1YWxzKG8uYmFja2luZ1N0b3JlKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI4LjQzODExMDMtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEZWNpc2lvblN0YXRlIGV4dGVuZHMgQVROU3RhdGUge1xyXG5cdHB1YmxpYyBkZWNpc2lvbjogbnVtYmVyID0gLTE7XHJcblx0cHVibGljIG5vbkdyZWVkeTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHB1YmxpYyBzbGw6IGJvb2xlYW4gPSBmYWxzZTtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzUuNjM5MDYxNC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQXJyYXkyREhhc2hNYXAgfSBmcm9tIFwiLi4vbWlzYy9BcnJheTJESGFzaE1hcFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IEphdmFNYXAgfSBmcm9tIFwiLi4vbWlzYy9TdHVic1wiO1xyXG5pbXBvcnQgeyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi4vbWlzYy9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbkNvbnRleHQgfSBmcm9tIFwiLi9QcmVkaWN0aW9uQ29udGV4dFwiO1xyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5cclxuLyoqIFVzZWQgdG8gY2FjaGUge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0fSBvYmplY3RzLiBJdHMgdXNlZCBmb3IgdGhlIHNoYXJlZFxyXG4gKiAgY29udGV4dCBjYXNoIGFzc29jaWF0ZWQgd2l0aCBjb250ZXh0cyBpbiBERkEgc3RhdGVzLiBUaGlzIGNhY2hlXHJcbiAqICBjYW4gYmUgdXNlZCBmb3IgYm90aCBsZXhlcnMgYW5kIHBhcnNlcnMuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcmVkaWN0aW9uQ29udGV4dENhY2hlIHtcclxuXHRwdWJsaWMgc3RhdGljIFVOQ0FDSEVEOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlID0gbmV3IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUoZmFsc2UpO1xyXG5cclxuXHRwcml2YXRlIGNvbnRleHRzOiBKYXZhTWFwPFByZWRpY3Rpb25Db250ZXh0LCBQcmVkaWN0aW9uQ29udGV4dD4gPVxyXG5cdFx0bmV3IEFycmF5MkRIYXNoTWFwPFByZWRpY3Rpb25Db250ZXh0LCBQcmVkaWN0aW9uQ29udGV4dD4oT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcclxuXHRwcml2YXRlIGNoaWxkQ29udGV4dHM6IEphdmFNYXA8UHJlZGljdGlvbkNvbnRleHRDYWNoZS5QcmVkaWN0aW9uQ29udGV4dEFuZEludCwgUHJlZGljdGlvbkNvbnRleHQ+ID1cclxuXHRcdG5ldyBBcnJheTJESGFzaE1hcDxQcmVkaWN0aW9uQ29udGV4dENhY2hlLlByZWRpY3Rpb25Db250ZXh0QW5kSW50LCBQcmVkaWN0aW9uQ29udGV4dD4oT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcclxuXHRwcml2YXRlIGpvaW5Db250ZXh0czogSmF2YU1hcDxQcmVkaWN0aW9uQ29udGV4dENhY2hlLklkZW50aXR5Q29tbXV0YXRpdmVQcmVkaWN0aW9uQ29udGV4dE9wZXJhbmRzLCBQcmVkaWN0aW9uQ29udGV4dD4gPVxyXG5cdFx0bmV3IEFycmF5MkRIYXNoTWFwPFByZWRpY3Rpb25Db250ZXh0Q2FjaGUuSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHMsIFByZWRpY3Rpb25Db250ZXh0PihPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xyXG5cclxuXHRwcml2YXRlIGVuYWJsZUNhY2hlOiBib29sZWFuO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihlbmFibGVDYWNoZTogYm9vbGVhbiA9IHRydWUpIHtcclxuXHRcdHRoaXMuZW5hYmxlQ2FjaGUgPSBlbmFibGVDYWNoZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRBc0NhY2hlZChjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdGlmICghdGhpcy5lbmFibGVDYWNoZSkge1xyXG5cdFx0XHRyZXR1cm4gY29udGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVzdWx0ID0gdGhpcy5jb250ZXh0cy5nZXQoY29udGV4dCk7XHJcblx0XHRpZiAoIXJlc3VsdCkge1xyXG5cdFx0XHRyZXN1bHQgPSBjb250ZXh0O1xyXG5cdFx0XHR0aGlzLmNvbnRleHRzLnB1dChjb250ZXh0LCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldENoaWxkKGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LCBpbnZva2luZ1N0YXRlOiBudW1iZXIpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRpZiAoIXRoaXMuZW5hYmxlQ2FjaGUpIHtcclxuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0Q2hpbGQoaW52b2tpbmdTdGF0ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG9wZXJhbmRzOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlLlByZWRpY3Rpb25Db250ZXh0QW5kSW50ID0gbmV3IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUuUHJlZGljdGlvbkNvbnRleHRBbmRJbnQoY29udGV4dCwgaW52b2tpbmdTdGF0ZSk7XHJcblx0XHRsZXQgcmVzdWx0ID0gdGhpcy5jaGlsZENvbnRleHRzLmdldChvcGVyYW5kcyk7XHJcblx0XHRpZiAoIXJlc3VsdCkge1xyXG5cdFx0XHRyZXN1bHQgPSBjb250ZXh0LmdldENoaWxkKGludm9raW5nU3RhdGUpO1xyXG5cdFx0XHRyZXN1bHQgPSB0aGlzLmdldEFzQ2FjaGVkKHJlc3VsdCk7XHJcblx0XHRcdHRoaXMuY2hpbGRDb250ZXh0cy5wdXQob3BlcmFuZHMsIHJlc3VsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBqb2luKHg6IFByZWRpY3Rpb25Db250ZXh0LCB5OiBQcmVkaWN0aW9uQ29udGV4dCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdGlmICghdGhpcy5lbmFibGVDYWNoZSkge1xyXG5cdFx0XHRyZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuam9pbih4LCB5LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgb3BlcmFuZHM6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUuSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHMgPSBuZXcgUHJlZGljdGlvbkNvbnRleHRDYWNoZS5JZGVudGl0eUNvbW11dGF0aXZlUHJlZGljdGlvbkNvbnRleHRPcGVyYW5kcyh4LCB5KTtcclxuXHRcdGxldCByZXN1bHQgPSB0aGlzLmpvaW5Db250ZXh0cy5nZXQob3BlcmFuZHMpO1xyXG5cdFx0aWYgKHJlc3VsdCkge1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJlc3VsdCA9IFByZWRpY3Rpb25Db250ZXh0LmpvaW4oeCwgeSwgdGhpcyk7XHJcblx0XHRyZXN1bHQgPSB0aGlzLmdldEFzQ2FjaGVkKHJlc3VsdCk7XHJcblx0XHR0aGlzLmpvaW5Db250ZXh0cy5wdXQob3BlcmFuZHMsIHJlc3VsdCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IG5hbWVzcGFjZSBQcmVkaWN0aW9uQ29udGV4dENhY2hlIHtcclxuXHRleHBvcnQgY2xhc3MgUHJlZGljdGlvbkNvbnRleHRBbmRJbnQge1xyXG5cdFx0cHJpdmF0ZSBvYmo6IFByZWRpY3Rpb25Db250ZXh0O1xyXG5cdFx0cHJpdmF0ZSB2YWx1ZTogbnVtYmVyO1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yKG9iajogUHJlZGljdGlvbkNvbnRleHQsIHZhbHVlOiBudW1iZXIpIHtcclxuXHRcdFx0dGhpcy5vYmogPSBvYmo7XHJcblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdFx0aWYgKCEob2JqIGluc3RhbmNlb2YgUHJlZGljdGlvbkNvbnRleHRBbmRJbnQpKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9IGVsc2UgaWYgKG9iaiA9PT0gdGhpcykge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgb3RoZXI6IFByZWRpY3Rpb25Db250ZXh0QW5kSW50ID0gb2JqO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWVcclxuXHRcdFx0XHQmJiAodGhpcy5vYmogPT09IG90aGVyLm9iaiB8fCAodGhpcy5vYmogIT0gbnVsbCAmJiB0aGlzLm9iai5lcXVhbHMob3RoZXIub2JqKSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRcdGxldCBoYXNoQ29kZTogbnVtYmVyID0gNTtcclxuXHRcdFx0aGFzaENvZGUgPSA3ICogaGFzaENvZGUgKyAodGhpcy5vYmogIT0gbnVsbCA/IHRoaXMub2JqLmhhc2hDb2RlKCkgOiAwKTtcclxuXHRcdFx0aGFzaENvZGUgPSA3ICogaGFzaENvZGUgKyB0aGlzLnZhbHVlO1xyXG5cdFx0XHRyZXR1cm4gaGFzaENvZGU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRleHBvcnQgY2xhc3MgSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHMge1xyXG5cdFx0cHJpdmF0ZSBfeDogUHJlZGljdGlvbkNvbnRleHQ7XHJcblx0XHRwcml2YXRlIF95OiBQcmVkaWN0aW9uQ29udGV4dDtcclxuXHJcblx0XHRjb25zdHJ1Y3Rvcih4OiBQcmVkaWN0aW9uQ29udGV4dCwgeTogUHJlZGljdGlvbkNvbnRleHQpIHtcclxuXHRcdFx0YXNzZXJ0KHggIT0gbnVsbCk7XHJcblx0XHRcdGFzc2VydCh5ICE9IG51bGwpO1xyXG5cdFx0XHR0aGlzLl94ID0geDtcclxuXHRcdFx0dGhpcy5feSA9IHk7XHJcblx0XHR9XHJcblxyXG5cdFx0Z2V0IHgoKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5feDtcclxuXHRcdH1cclxuXHJcblx0XHRnZXQgeSgpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRcdHJldHVybiB0aGlzLl95O1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGVxdWFscyhvOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdFx0aWYgKCEobyBpbnN0YW5jZW9mIElkZW50aXR5Q29tbXV0YXRpdmVQcmVkaWN0aW9uQ29udGV4dE9wZXJhbmRzKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fSBlbHNlIGlmICh0aGlzID09PSBvKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBvdGhlcjogSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHMgPSBvO1xyXG5cdFx0XHRyZXR1cm4gKHRoaXMuX3ggPT09IG90aGVyLl94ICYmIHRoaXMuX3kgPT09IG90aGVyLl95KSB8fCAodGhpcy5feCA9PT0gb3RoZXIuX3kgJiYgdGhpcy5feSA9PT0gb3RoZXIuX3gpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRcdHJldHVybiB0aGlzLl94Lmhhc2hDb2RlKCkgXiB0aGlzLl95Lmhhc2hDb2RlKCk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNS4zODEyNjM2LTA3OjAwXHJcblxyXG5cclxuaW1wb3J0IHsgQXJyYXkyREhhc2hNYXAgfSBmcm9tIFwiLi4vbWlzYy9BcnJheTJESGFzaE1hcFwiO1xyXG5pbXBvcnQgeyBBcnJheTJESGFzaFNldCB9IGZyb20gXCIuLi9taXNjL0FycmF5MkRIYXNoU2V0XCI7XHJcbmltcG9ydCB7IEFycmF5cyB9IGZyb20gXCIuLi9taXNjL0FycmF5c1wiO1xyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9BVE5cIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi4vbWlzYy9FcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuLi9taXNjL011cm11ckhhc2hcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBFcXVhdGFibGUsIEphdmFTZXQgfSBmcm9tIFwiLi4vbWlzYy9TdHVic1wiO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uQ29udGV4dENhY2hlIH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRDYWNoZVwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4uL1JlY29nbml6ZXJcIjtcclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUnVsZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9SdWxlVHJhbnNpdGlvblwiO1xyXG5cclxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcclxuXHJcbmNvbnN0IElOSVRJQUxfSEFTSDogbnVtYmVyID0gMTtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQcmVkaWN0aW9uQ29udGV4dCBpbXBsZW1lbnRzIEVxdWF0YWJsZSB7XHJcblx0LyoqXHJcblx0ICogU3RvcmVzIHRoZSBjb21wdXRlZCBoYXNoIGNvZGUgb2YgdGhpcyB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHR9LiBUaGUgaGFzaFxyXG5cdCAqIGNvZGUgaXMgY29tcHV0ZWQgaW4gcGFydHMgdG8gbWF0Y2ggdGhlIGZvbGxvd2luZyByZWZlcmVuY2UgYWxnb3JpdGhtLlxyXG5cdCAqXHJcblx0ICogYGBgXHJcblx0ICogcHJpdmF0ZSBpbnQgcmVmZXJlbmNlSGFzaENvZGUoKSB7XHJcblx0ICogICBpbnQgaGFzaCA9IHtAbGluayBNdXJtdXJIYXNoI2luaXRpYWxpemUgTXVybXVySGFzaC5pbml0aWFsaXplfSh7QGxpbmsgI0lOSVRJQUxfSEFTSH0pO1xyXG5cdCAqXHJcblx0ICogICBmb3IgKGludCBpID0gMDsgaSAmbHQ7IHRoaXMuc2l6ZTsgaSsrKSB7XHJcblx0ICogICAgIGhhc2ggPSB7QGxpbmsgTXVybXVySGFzaCN1cGRhdGUgTXVybXVySGFzaC51cGRhdGV9KGhhc2gsIHtAbGluayAjZ2V0UGFyZW50IGdldFBhcmVudH0oaSkpO1xyXG5cdCAqICAgfVxyXG5cdCAqXHJcblx0ICogICBmb3IgKGludCBpID0gMDsgaSAmbHQ7IHRoaXMuc2l6ZTsgaSsrKSB7XHJcblx0ICogICAgIGhhc2ggPSB7QGxpbmsgTXVybXVySGFzaCN1cGRhdGUgTXVybXVySGFzaC51cGRhdGV9KGhhc2gsIHtAbGluayAjZ2V0UmV0dXJuU3RhdGUgZ2V0UmV0dXJuU3RhdGV9KGkpKTtcclxuXHQgKiAgIH1cclxuXHQgKlxyXG5cdCAqICAgaGFzaCA9IHtAbGluayBNdXJtdXJIYXNoI2ZpbmlzaCBNdXJtdXJIYXNoLmZpbmlzaH0oaGFzaCwgMiAqIHRoaXMuc2l6ZSk7XHJcblx0ICogICByZXR1cm4gaGFzaDtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICovXHJcblx0cHJpdmF0ZSByZWFkb25seSBjYWNoZWRIYXNoQ29kZTogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihjYWNoZWRIYXNoQ29kZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLmNhY2hlZEhhc2hDb2RlID0gY2FjaGVkSGFzaENvZGU7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgc3RhdGljIGNhbGN1bGF0ZUVtcHR5SGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoSU5JVElBTF9IQVNIKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAwKTtcclxuXHRcdHJldHVybiBoYXNoO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHN0YXRpYyBjYWxjdWxhdGVTaW5nbGVIYXNoQ29kZShwYXJlbnQ6IFByZWRpY3Rpb25Db250ZXh0LCByZXR1cm5TdGF0ZTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoSU5JVElBTF9IQVNIKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCBwYXJlbnQpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHJldHVyblN0YXRlKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAyKTtcclxuXHRcdHJldHVybiBoYXNoO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHN0YXRpYyBjYWxjdWxhdGVIYXNoQ29kZShwYXJlbnRzOiBQcmVkaWN0aW9uQ29udGV4dFtdLCByZXR1cm5TdGF0ZXM6IG51bWJlcltdKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoSU5JVElBTF9IQVNIKTtcclxuXHJcblx0XHRmb3IgKGxldCBwYXJlbnQgb2YgcGFyZW50cykge1xyXG5cdFx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgcGFyZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCByZXR1cm5TdGF0ZSBvZiByZXR1cm5TdGF0ZXMpIHtcclxuXHRcdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHJldHVyblN0YXRlKTtcclxuXHRcdH1cclxuXHJcblx0XHRoYXNoID0gTXVybXVySGFzaC5maW5pc2goaGFzaCwgMiAqIHBhcmVudHMubGVuZ3RoKTtcclxuXHRcdHJldHVybiBoYXNoO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHNpemU6IG51bWJlcjtcclxuXHJcblx0cHVibGljIGFic3RyYWN0IGdldFJldHVyblN0YXRlKGluZGV4OiBudW1iZXIpOiBudW1iZXI7XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCBmaW5kUmV0dXJuU3RhdGUocmV0dXJuU3RhdGU6IG51bWJlcik6IG51bWJlcjtcclxuXHJcblx0Ly8gQE5vdE51bGxcclxuXHRwdWJsaWMgYWJzdHJhY3QgZ2V0UGFyZW50KGluZGV4OiBudW1iZXIpOiBQcmVkaWN0aW9uQ29udGV4dDtcclxuXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IGFkZEVtcHR5Q29udGV4dCgpOiBQcmVkaWN0aW9uQ29udGV4dDtcclxuXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IHJlbW92ZUVtcHR5Q29udGV4dCgpOiBQcmVkaWN0aW9uQ29udGV4dDtcclxuXHJcblx0cHVibGljIHN0YXRpYyBmcm9tUnVsZUNvbnRleHQoYXRuOiBBVE4sIG91dGVyQ29udGV4dDogUnVsZUNvbnRleHQsIGZ1bGxDb250ZXh0OiBib29sZWFuID0gdHJ1ZSk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdGlmIChvdXRlckNvbnRleHQuaXNFbXB0eSkge1xyXG5cdFx0XHRyZXR1cm4gZnVsbENvbnRleHQgPyBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMIDogUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfTE9DQUw7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHBhcmVudDogUHJlZGljdGlvbkNvbnRleHQ7XHJcblx0XHRpZiAob3V0ZXJDb250ZXh0Ll9wYXJlbnQpIHtcclxuXHRcdFx0cGFyZW50ID0gUHJlZGljdGlvbkNvbnRleHQuZnJvbVJ1bGVDb250ZXh0KGF0biwgb3V0ZXJDb250ZXh0Ll9wYXJlbnQsIGZ1bGxDb250ZXh0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhcmVudCA9IGZ1bGxDb250ZXh0ID8gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTCA6IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBzdGF0ZTogQVROU3RhdGUgPSBhdG4uc3RhdGVzW291dGVyQ29udGV4dC5pbnZva2luZ1N0YXRlXTtcclxuXHRcdGxldCB0cmFuc2l0aW9uOiBSdWxlVHJhbnNpdGlvbiA9IHN0YXRlLnRyYW5zaXRpb24oMCkgYXMgUnVsZVRyYW5zaXRpb247XHJcblx0XHRyZXR1cm4gcGFyZW50LmdldENoaWxkKHRyYW5zaXRpb24uZm9sbG93U3RhdGUuc3RhdGVOdW1iZXIpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgYWRkRW1wdHlDb250ZXh0KGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0KTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0cmV0dXJuIGNvbnRleHQuYWRkRW1wdHlDb250ZXh0KCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHN0YXRpYyByZW1vdmVFbXB0eUNvbnRleHQoY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gY29udGV4dC5yZW1vdmVFbXB0eUNvbnRleHQoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgam9pbihATm90TnVsbCBjb250ZXh0MDogUHJlZGljdGlvbkNvbnRleHQsIEBOb3ROdWxsIGNvbnRleHQxOiBQcmVkaWN0aW9uQ29udGV4dCwgQE5vdE51bGwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlID0gUHJlZGljdGlvbkNvbnRleHRDYWNoZS5VTkNBQ0hFRCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdGlmIChjb250ZXh0MCA9PT0gY29udGV4dDEpIHtcclxuXHRcdFx0cmV0dXJuIGNvbnRleHQwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0MC5pc0VtcHR5KSB7XHJcblx0XHRcdHJldHVybiBQcmVkaWN0aW9uQ29udGV4dC5pc0VtcHR5TG9jYWwoY29udGV4dDApID8gY29udGV4dDAgOiBQcmVkaWN0aW9uQ29udGV4dC5hZGRFbXB0eUNvbnRleHQoY29udGV4dDEpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250ZXh0MS5pc0VtcHR5KSB7XHJcblx0XHRcdHJldHVybiBQcmVkaWN0aW9uQ29udGV4dC5pc0VtcHR5TG9jYWwoY29udGV4dDEpID8gY29udGV4dDEgOiBQcmVkaWN0aW9uQ29udGV4dC5hZGRFbXB0eUNvbnRleHQoY29udGV4dDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjb250ZXh0MHNpemU6IG51bWJlciA9IGNvbnRleHQwLnNpemU7XHJcblx0XHRsZXQgY29udGV4dDFzaXplOiBudW1iZXIgPSBjb250ZXh0MS5zaXplO1xyXG5cdFx0aWYgKGNvbnRleHQwc2l6ZSA9PT0gMSAmJiBjb250ZXh0MXNpemUgPT09IDEgJiYgY29udGV4dDAuZ2V0UmV0dXJuU3RhdGUoMCkgPT09IGNvbnRleHQxLmdldFJldHVyblN0YXRlKDApKSB7XHJcblx0XHRcdGxldCBtZXJnZWQ6IFByZWRpY3Rpb25Db250ZXh0ID0gY29udGV4dENhY2hlLmpvaW4oY29udGV4dDAuZ2V0UGFyZW50KDApLCBjb250ZXh0MS5nZXRQYXJlbnQoMCkpO1xyXG5cdFx0XHRpZiAobWVyZ2VkID09PSBjb250ZXh0MC5nZXRQYXJlbnQoMCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gY29udGV4dDA7XHJcblx0XHRcdH0gZWxzZSBpZiAobWVyZ2VkID09PSBjb250ZXh0MS5nZXRQYXJlbnQoMCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gY29udGV4dDE7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIG1lcmdlZC5nZXRDaGlsZChjb250ZXh0MC5nZXRSZXR1cm5TdGF0ZSgwKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgY291bnQ6IG51bWJlciA9IDA7XHJcblx0XHRsZXQgcGFyZW50c0xpc3Q6IFByZWRpY3Rpb25Db250ZXh0W10gPSBuZXcgQXJyYXk8UHJlZGljdGlvbkNvbnRleHQ+KGNvbnRleHQwc2l6ZSArIGNvbnRleHQxc2l6ZSk7XHJcblx0XHRsZXQgcmV0dXJuU3RhdGVzTGlzdDogbnVtYmVyW10gPSBuZXcgQXJyYXk8bnVtYmVyPihwYXJlbnRzTGlzdC5sZW5ndGgpO1xyXG5cdFx0bGV0IGxlZnRJbmRleDogbnVtYmVyID0gMDtcclxuXHRcdGxldCByaWdodEluZGV4OiBudW1iZXIgPSAwO1xyXG5cdFx0bGV0IGNhblJldHVybkxlZnQ6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdFx0bGV0IGNhblJldHVyblJpZ2h0OiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdHdoaWxlIChsZWZ0SW5kZXggPCBjb250ZXh0MHNpemUgJiYgcmlnaHRJbmRleCA8IGNvbnRleHQxc2l6ZSkge1xyXG5cdFx0XHRpZiAoY29udGV4dDAuZ2V0UmV0dXJuU3RhdGUobGVmdEluZGV4KSA9PT0gY29udGV4dDEuZ2V0UmV0dXJuU3RhdGUocmlnaHRJbmRleCkpIHtcclxuXHRcdFx0XHRwYXJlbnRzTGlzdFtjb3VudF0gPSBjb250ZXh0Q2FjaGUuam9pbihjb250ZXh0MC5nZXRQYXJlbnQobGVmdEluZGV4KSwgY29udGV4dDEuZ2V0UGFyZW50KHJpZ2h0SW5kZXgpKTtcclxuXHRcdFx0XHRyZXR1cm5TdGF0ZXNMaXN0W2NvdW50XSA9IGNvbnRleHQwLmdldFJldHVyblN0YXRlKGxlZnRJbmRleCk7XHJcblx0XHRcdFx0Y2FuUmV0dXJuTGVmdCA9IGNhblJldHVybkxlZnQgJiYgcGFyZW50c0xpc3RbY291bnRdID09PSBjb250ZXh0MC5nZXRQYXJlbnQobGVmdEluZGV4KTtcclxuXHRcdFx0XHRjYW5SZXR1cm5SaWdodCA9IGNhblJldHVyblJpZ2h0ICYmIHBhcmVudHNMaXN0W2NvdW50XSA9PT0gY29udGV4dDEuZ2V0UGFyZW50KHJpZ2h0SW5kZXgpO1xyXG5cdFx0XHRcdGxlZnRJbmRleCsrO1xyXG5cdFx0XHRcdHJpZ2h0SW5kZXgrKztcclxuXHRcdFx0fSBlbHNlIGlmIChjb250ZXh0MC5nZXRSZXR1cm5TdGF0ZShsZWZ0SW5kZXgpIDwgY29udGV4dDEuZ2V0UmV0dXJuU3RhdGUocmlnaHRJbmRleCkpIHtcclxuXHRcdFx0XHRwYXJlbnRzTGlzdFtjb3VudF0gPSBjb250ZXh0MC5nZXRQYXJlbnQobGVmdEluZGV4KTtcclxuXHRcdFx0XHRyZXR1cm5TdGF0ZXNMaXN0W2NvdW50XSA9IGNvbnRleHQwLmdldFJldHVyblN0YXRlKGxlZnRJbmRleCk7XHJcblx0XHRcdFx0Y2FuUmV0dXJuUmlnaHQgPSBmYWxzZTtcclxuXHRcdFx0XHRsZWZ0SW5kZXgrKztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRhc3NlcnQoY29udGV4dDEuZ2V0UmV0dXJuU3RhdGUocmlnaHRJbmRleCkgPCBjb250ZXh0MC5nZXRSZXR1cm5TdGF0ZShsZWZ0SW5kZXgpKTtcclxuXHRcdFx0XHRwYXJlbnRzTGlzdFtjb3VudF0gPSBjb250ZXh0MS5nZXRQYXJlbnQocmlnaHRJbmRleCk7XHJcblx0XHRcdFx0cmV0dXJuU3RhdGVzTGlzdFtjb3VudF0gPSBjb250ZXh0MS5nZXRSZXR1cm5TdGF0ZShyaWdodEluZGV4KTtcclxuXHRcdFx0XHRjYW5SZXR1cm5MZWZ0ID0gZmFsc2U7XHJcblx0XHRcdFx0cmlnaHRJbmRleCsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb3VudCsrO1xyXG5cdFx0fVxyXG5cclxuXHRcdHdoaWxlIChsZWZ0SW5kZXggPCBjb250ZXh0MHNpemUpIHtcclxuXHRcdFx0cGFyZW50c0xpc3RbY291bnRdID0gY29udGV4dDAuZ2V0UGFyZW50KGxlZnRJbmRleCk7XHJcblx0XHRcdHJldHVyblN0YXRlc0xpc3RbY291bnRdID0gY29udGV4dDAuZ2V0UmV0dXJuU3RhdGUobGVmdEluZGV4KTtcclxuXHRcdFx0bGVmdEluZGV4Kys7XHJcblx0XHRcdGNhblJldHVyblJpZ2h0ID0gZmFsc2U7XHJcblx0XHRcdGNvdW50Kys7XHJcblx0XHR9XHJcblxyXG5cdFx0d2hpbGUgKHJpZ2h0SW5kZXggPCBjb250ZXh0MXNpemUpIHtcclxuXHRcdFx0cGFyZW50c0xpc3RbY291bnRdID0gY29udGV4dDEuZ2V0UGFyZW50KHJpZ2h0SW5kZXgpO1xyXG5cdFx0XHRyZXR1cm5TdGF0ZXNMaXN0W2NvdW50XSA9IGNvbnRleHQxLmdldFJldHVyblN0YXRlKHJpZ2h0SW5kZXgpO1xyXG5cdFx0XHRyaWdodEluZGV4Kys7XHJcblx0XHRcdGNhblJldHVybkxlZnQgPSBmYWxzZTtcclxuXHRcdFx0Y291bnQrKztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY2FuUmV0dXJuTGVmdCkge1xyXG5cdFx0XHRyZXR1cm4gY29udGV4dDA7XHJcblx0XHR9IGVsc2UgaWYgKGNhblJldHVyblJpZ2h0KSB7XHJcblx0XHRcdHJldHVybiBjb250ZXh0MTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY291bnQgPCBwYXJlbnRzTGlzdC5sZW5ndGgpIHtcclxuXHRcdFx0cGFyZW50c0xpc3QgPSBwYXJlbnRzTGlzdC5zbGljZSgwLCBjb3VudCk7XHJcblx0XHRcdHJldHVyblN0YXRlc0xpc3QgPSByZXR1cm5TdGF0ZXNMaXN0LnNsaWNlKDAsIGNvdW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAocGFyZW50c0xpc3QubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdC8vIGlmIG9uZSBvZiB0aGVtIHdhcyBFTVBUWV9MT0NBTCwgaXQgd291bGQgYmUgZW1wdHkgYW5kIGhhbmRsZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbWV0aG9kXHJcblx0XHRcdHJldHVybiBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMO1xyXG5cdFx0fSBlbHNlIGlmIChwYXJlbnRzTGlzdC5sZW5ndGggPT09IDEpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzTGlzdFswXSwgcmV0dXJuU3RhdGVzTGlzdFswXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQocGFyZW50c0xpc3QsIHJldHVyblN0YXRlc0xpc3QpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIHN0YXRpYyBpc0VtcHR5TG9jYWwoY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBjb250ZXh0ID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9MT0NBTDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZ2V0Q2FjaGVkQ29udGV4dChcclxuXHRcdEBOb3ROdWxsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LFxyXG5cdFx0QE5vdE51bGwgY29udGV4dENhY2hlOiBBcnJheTJESGFzaE1hcDxQcmVkaWN0aW9uQ29udGV4dCwgUHJlZGljdGlvbkNvbnRleHQ+LFxyXG5cdFx0QE5vdE51bGwgdmlzaXRlZDogUHJlZGljdGlvbkNvbnRleHQuSWRlbnRpdHlIYXNoTWFwKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0aWYgKGNvbnRleHQuaXNFbXB0eSkge1xyXG5cdFx0XHRyZXR1cm4gY29udGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZXhpc3RpbmcgPSB2aXNpdGVkLmdldChjb250ZXh0KTtcclxuXHRcdGlmIChleGlzdGluZykge1xyXG5cdFx0XHRyZXR1cm4gZXhpc3Rpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0ZXhpc3RpbmcgPSBjb250ZXh0Q2FjaGUuZ2V0KGNvbnRleHQpO1xyXG5cdFx0aWYgKGV4aXN0aW5nKSB7XHJcblx0XHRcdHZpc2l0ZWQucHV0KGNvbnRleHQsIGV4aXN0aW5nKTtcclxuXHRcdFx0cmV0dXJuIGV4aXN0aW5nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjaGFuZ2VkOiBib29sZWFuID0gZmFsc2U7XHJcblx0XHRsZXQgcGFyZW50czogUHJlZGljdGlvbkNvbnRleHRbXSA9IG5ldyBBcnJheTxQcmVkaWN0aW9uQ29udGV4dD4oY29udGV4dC5zaXplKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgcGFyZW50OiBQcmVkaWN0aW9uQ29udGV4dCA9IFByZWRpY3Rpb25Db250ZXh0LmdldENhY2hlZENvbnRleHQoY29udGV4dC5nZXRQYXJlbnQoaSksIGNvbnRleHRDYWNoZSwgdmlzaXRlZCk7XHJcblx0XHRcdGlmIChjaGFuZ2VkIHx8IHBhcmVudCAhPT0gY29udGV4dC5nZXRQYXJlbnQoaSkpIHtcclxuXHRcdFx0XHRpZiAoIWNoYW5nZWQpIHtcclxuXHRcdFx0XHRcdHBhcmVudHMgPSBuZXcgQXJyYXk8UHJlZGljdGlvbkNvbnRleHQ+KGNvbnRleHQuc2l6ZSk7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGNvbnRleHQuc2l6ZTsgaisrKSB7XHJcblx0XHRcdFx0XHRcdHBhcmVudHNbal0gPSBjb250ZXh0LmdldFBhcmVudChqKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHBhcmVudHNbaV0gPSBwYXJlbnQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNoYW5nZWQpIHtcclxuXHRcdFx0ZXhpc3RpbmcgPSBjb250ZXh0Q2FjaGUucHV0SWZBYnNlbnQoY29udGV4dCwgY29udGV4dCk7XHJcblx0XHRcdHZpc2l0ZWQucHV0KGNvbnRleHQsIGV4aXN0aW5nICE9IG51bGwgPyBleGlzdGluZyA6IGNvbnRleHQpO1xyXG5cdFx0XHRyZXR1cm4gY29udGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXZSBrbm93IHBhcmVudHMubGVuZ3RoPjAgYmVjYXVzZSBjb250ZXh0LmlzRW1wdHkgaXMgY2hlY2tlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtZXRob2QuXHJcblx0XHRsZXQgdXBkYXRlZDogUHJlZGljdGlvbkNvbnRleHQ7XHJcblx0XHRpZiAocGFyZW50cy5sZW5ndGggPT09IDEpIHtcclxuXHRcdFx0dXBkYXRlZCA9IG5ldyBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzWzBdLCBjb250ZXh0LmdldFJldHVyblN0YXRlKDApKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCByZXR1cm5TdGF0ZXM6IG51bWJlcltdID0gbmV3IEFycmF5PG51bWJlcj4oY29udGV4dC5zaXplKTtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZXh0LnNpemU7IGkrKykge1xyXG5cdFx0XHRcdHJldHVyblN0YXRlc1tpXSA9IGNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVwZGF0ZWQgPSBuZXcgQXJyYXlQcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzLCByZXR1cm5TdGF0ZXMsIGNvbnRleHQuaGFzaENvZGUoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZXhpc3RpbmcgPSBjb250ZXh0Q2FjaGUucHV0SWZBYnNlbnQodXBkYXRlZCwgdXBkYXRlZCk7XHJcblx0XHR2aXNpdGVkLnB1dCh1cGRhdGVkLCBleGlzdGluZyB8fCB1cGRhdGVkKTtcclxuXHRcdHZpc2l0ZWQucHV0KGNvbnRleHQsIGV4aXN0aW5nIHx8IHVwZGF0ZWQpO1xyXG5cclxuXHRcdHJldHVybiB1cGRhdGVkO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFwcGVuZFNpbmdsZUNvbnRleHQocmV0dXJuQ29udGV4dDogbnVtYmVyLCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmRDb250ZXh0KFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTEwuZ2V0Q2hpbGQocmV0dXJuQ29udGV4dCksIGNvbnRleHRDYWNoZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgYXBwZW5kQ29udGV4dChzdWZmaXg6IFByZWRpY3Rpb25Db250ZXh0LCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBQcmVkaWN0aW9uQ29udGV4dDtcclxuXHJcblx0cHVibGljIGdldENoaWxkKHJldHVyblN0YXRlOiBudW1iZXIpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gbmV3IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0KHRoaXMsIHJldHVyblN0YXRlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBpc0VtcHR5OiBib29sZWFuO1xyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgaGFzRW1wdHk6IGJvb2xlYW47XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVkSGFzaENvZGU7XHJcblx0fVxyXG5cclxuXHQvLyBAT3ZlcnJpZGVcclxuXHRwdWJsaWMgYWJzdHJhY3QgZXF1YWxzKG86IGFueSk6IGJvb2xlYW47XHJcblxyXG5cdHB1YmxpYyB0b1N0cmluZ3MocmVjb2duaXplcjogUmVjb2duaXplcjxhbnksIGFueT4gfCB1bmRlZmluZWQsIGN1cnJlbnRTdGF0ZTogbnVtYmVyLCBzdG9wOiBQcmVkaWN0aW9uQ29udGV4dCA9IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTEwpOiBzdHJpbmdbXSB7XHJcblx0XHRsZXQgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuXHRcdG91dGVyOlxyXG5cdFx0Zm9yIChsZXQgcGVybSA9IDA7IDsgcGVybSsrKSB7XHJcblx0XHRcdGxldCBvZmZzZXQ6IG51bWJlciA9IDA7XHJcblx0XHRcdGxldCBsYXN0OiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdFx0bGV0IHA6IFByZWRpY3Rpb25Db250ZXh0ID0gdGhpcztcclxuXHRcdFx0bGV0IHN0YXRlTnVtYmVyOiBudW1iZXIgPSBjdXJyZW50U3RhdGU7XHJcblx0XHRcdGxldCBsb2NhbEJ1ZmZlcjogc3RyaW5nID0gXCJcIjtcclxuXHRcdFx0bG9jYWxCdWZmZXIgKz0gXCJbXCI7XHJcblx0XHRcdHdoaWxlICghcC5pc0VtcHR5ICYmIHAgIT09IHN0b3ApIHtcclxuXHRcdFx0XHRsZXQgaW5kZXg6IG51bWJlciA9IDA7XHJcblx0XHRcdFx0aWYgKHAuc2l6ZSA+IDApIHtcclxuXHRcdFx0XHRcdGxldCBiaXRzOiBudW1iZXIgPSAxO1xyXG5cdFx0XHRcdFx0d2hpbGUgKCgoMSA8PCBiaXRzKSA+Pj4gMCkgPCBwLnNpemUpIHtcclxuXHRcdFx0XHRcdFx0Yml0cysrO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCBtYXNrOiBudW1iZXIgPSAoKDEgPDwgYml0cykgPj4+IDApIC0gMTtcclxuXHRcdFx0XHRcdGluZGV4ID0gKHBlcm0gPj4gb2Zmc2V0KSAmIG1hc2s7XHJcblx0XHRcdFx0XHRsYXN0ID0gbGFzdCAmJiBpbmRleCA+PSBwLnNpemUgLSAxO1xyXG5cdFx0XHRcdFx0aWYgKGluZGV4ID49IHAuc2l6ZSkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZSBvdXRlcjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRvZmZzZXQgKz0gYml0cztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChyZWNvZ25pemVyKSB7XHJcblx0XHRcdFx0XHRpZiAobG9jYWxCdWZmZXIubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRcdFx0XHQvLyBmaXJzdCBjaGFyIGlzICdbJywgaWYgbW9yZSB0aGFuIHRoYXQgdGhpcyBpc24ndCB0aGUgZmlyc3QgcnVsZVxyXG5cdFx0XHRcdFx0XHRsb2NhbEJ1ZmZlciArPSBcIiBcIjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsZXQgYXRuOiBBVE4gPSByZWNvZ25pemVyLmF0bjtcclxuXHRcdFx0XHRcdGxldCBzOiBBVE5TdGF0ZSA9IGF0bi5zdGF0ZXNbc3RhdGVOdW1iZXJdO1xyXG5cdFx0XHRcdFx0bGV0IHJ1bGVOYW1lOiBzdHJpbmcgPSByZWNvZ25pemVyLnJ1bGVOYW1lc1tzLnJ1bGVJbmRleF07XHJcblx0XHRcdFx0XHRsb2NhbEJ1ZmZlciArPSBydWxlTmFtZTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHAuZ2V0UmV0dXJuU3RhdGUoaW5kZXgpICE9PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSkge1xyXG5cdFx0XHRcdFx0aWYgKCFwLmlzRW1wdHkpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGxvY2FsQnVmZmVyLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBmaXJzdCBjaGFyIGlzICdbJywgaWYgbW9yZSB0aGFuIHRoYXQgdGhpcyBpc24ndCB0aGUgZmlyc3QgcnVsZVxyXG5cdFx0XHRcdFx0XHRcdGxvY2FsQnVmZmVyICs9IFwiIFwiO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRsb2NhbEJ1ZmZlciArPSBwLmdldFJldHVyblN0YXRlKGluZGV4KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN0YXRlTnVtYmVyID0gcC5nZXRSZXR1cm5TdGF0ZShpbmRleCk7XHJcblx0XHRcdFx0cCA9IHAuZ2V0UGFyZW50KGluZGV4KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bG9jYWxCdWZmZXIgKz0gXCJdXCI7XHJcblx0XHRcdHJlc3VsdC5wdXNoKGxvY2FsQnVmZmVyKTtcclxuXHJcblx0XHRcdGlmIChsYXN0KSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxufVxyXG5cclxuY2xhc3MgRW1wdHlQcmVkaWN0aW9uQ29udGV4dCBleHRlbmRzIFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRwcml2YXRlIGZ1bGxDb250ZXh0OiBib29sZWFuO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihmdWxsQ29udGV4dDogYm9vbGVhbikge1xyXG5cdFx0c3VwZXIoUHJlZGljdGlvbkNvbnRleHQuY2FsY3VsYXRlRW1wdHlIYXNoQ29kZSgpKTtcclxuXHRcdHRoaXMuZnVsbENvbnRleHQgPSBmdWxsQ29udGV4dDtcclxuXHR9XHJcblxyXG5cdGdldCBpc0Z1bGxDb250ZXh0KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuZnVsbENvbnRleHQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgYWRkRW1wdHlDb250ZXh0KCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIHJlbW92ZUVtcHR5Q29udGV4dCgpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVtb3ZlIHRoZSBlbXB0eSBjb250ZXh0IGZyb20gaXRzZWxmLlwiKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXRQYXJlbnQoaW5kZXg6IG51bWJlcik6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcImluZGV4IG91dCBvZiBib3VuZHNcIik7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0UmV0dXJuU3RhdGUoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGZpbmRSZXR1cm5TdGF0ZShyZXR1cm5TdGF0ZTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzaXplKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBhcHBlbmRTaW5nbGVDb250ZXh0KHJldHVybkNvbnRleHQ6IG51bWJlciwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0cmV0dXJuIGNvbnRleHRDYWNoZS5nZXRDaGlsZCh0aGlzLCByZXR1cm5Db250ZXh0KTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBhcHBlbmRDb250ZXh0KHN1ZmZpeDogUHJlZGljdGlvbkNvbnRleHQsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdHJldHVybiBzdWZmaXg7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGhhc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG86IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMgPT09IG87XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmdzKHJlY29nbml6ZXI6IGFueSwgY3VycmVudFN0YXRlOiBudW1iZXIsIHN0b3A/OiBQcmVkaWN0aW9uQ29udGV4dCk6IHN0cmluZ1tdIHtcclxuXHRcdHJldHVybiBbXCJbXVwiXTtcclxuXHR9XHJcblxyXG59XHJcblxyXG5jbGFzcyBBcnJheVByZWRpY3Rpb25Db250ZXh0IGV4dGVuZHMgUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHBhcmVudHM6IFByZWRpY3Rpb25Db250ZXh0W107XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHJldHVyblN0YXRlczogbnVtYmVyW107XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBATm90TnVsbCBwYXJlbnRzOiBQcmVkaWN0aW9uQ29udGV4dFtdLCByZXR1cm5TdGF0ZXM6IG51bWJlcltdLCBoYXNoQ29kZT86IG51bWJlcikge1xyXG5cdFx0c3VwZXIoaGFzaENvZGUgfHwgUHJlZGljdGlvbkNvbnRleHQuY2FsY3VsYXRlSGFzaENvZGUocGFyZW50cywgcmV0dXJuU3RhdGVzKSk7XHJcblx0XHRhc3NlcnQocGFyZW50cy5sZW5ndGggPT09IHJldHVyblN0YXRlcy5sZW5ndGgpO1xyXG5cdFx0YXNzZXJ0KHJldHVyblN0YXRlcy5sZW5ndGggPiAxIHx8IHJldHVyblN0YXRlc1swXSAhPT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVksIFwiU2hvdWxkIGJlIHVzaW5nIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZIGluc3RlYWQuXCIpO1xyXG5cclxuXHRcdHRoaXMucGFyZW50cyA9IHBhcmVudHM7XHJcblx0XHR0aGlzLnJldHVyblN0YXRlcyA9IHJldHVyblN0YXRlcztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXRQYXJlbnQoaW5kZXg6IG51bWJlcik6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdHJldHVybiB0aGlzLnBhcmVudHNbaW5kZXhdO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGdldFJldHVyblN0YXRlKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMucmV0dXJuU3RhdGVzW2luZGV4XTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBmaW5kUmV0dXJuU3RhdGUocmV0dXJuU3RhdGU6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gQXJyYXlzLmJpbmFyeVNlYXJjaCh0aGlzLnJldHVyblN0YXRlcywgcmV0dXJuU3RhdGUpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNpemUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLnJldHVyblN0YXRlcy5sZW5ndGg7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBoYXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnJldHVyblN0YXRlc1t0aGlzLnJldHVyblN0YXRlcy5sZW5ndGggLSAxXSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgYWRkRW1wdHlDb250ZXh0KCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdGlmICh0aGlzLmhhc0VtcHR5KSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBwYXJlbnRzMjogUHJlZGljdGlvbkNvbnRleHRbXSA9IHRoaXMucGFyZW50cy5zbGljZSgwKTtcclxuXHRcdGxldCByZXR1cm5TdGF0ZXMyOiBudW1iZXJbXSA9IHRoaXMucmV0dXJuU3RhdGVzLnNsaWNlKDApO1xyXG5cdFx0cGFyZW50czIucHVzaChQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMKTtcclxuXHRcdHJldHVyblN0YXRlczIucHVzaChQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSk7XHJcblx0XHRyZXR1cm4gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQocGFyZW50czIsIHJldHVyblN0YXRlczIpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIHJlbW92ZUVtcHR5Q29udGV4dCgpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRpZiAoIXRoaXMuaGFzRW1wdHkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMucmV0dXJuU3RhdGVzLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0KHRoaXMucGFyZW50c1swXSwgdGhpcy5yZXR1cm5TdGF0ZXNbMF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IHBhcmVudHMyOiBQcmVkaWN0aW9uQ29udGV4dFtdID0gdGhpcy5wYXJlbnRzLnNsaWNlKDAsIHRoaXMucGFyZW50cy5sZW5ndGggLSAxKTtcclxuXHRcdFx0bGV0IHJldHVyblN0YXRlczI6IG51bWJlcltdID0gdGhpcy5yZXR1cm5TdGF0ZXMuc2xpY2UoMCwgdGhpcy5yZXR1cm5TdGF0ZXMubGVuZ3RoIC0gMSk7XHJcblx0XHRcdHJldHVybiBuZXcgQXJyYXlQcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzMiwgcmV0dXJuU3RhdGVzMik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgYXBwZW5kQ29udGV4dChzdWZmaXg6IFByZWRpY3Rpb25Db250ZXh0LCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gQXJyYXlQcmVkaWN0aW9uQ29udGV4dC5hcHBlbmRDb250ZXh0SW1wbCh0aGlzLCBzdWZmaXgsIG5ldyBQcmVkaWN0aW9uQ29udGV4dC5JZGVudGl0eUhhc2hNYXAoKSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBhcHBlbmRDb250ZXh0SW1wbChjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCwgc3VmZml4OiBQcmVkaWN0aW9uQ29udGV4dCwgdmlzaXRlZDogUHJlZGljdGlvbkNvbnRleHQuSWRlbnRpdHlIYXNoTWFwKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0aWYgKHN1ZmZpeC5pc0VtcHR5KSB7XHJcblx0XHRcdGlmIChQcmVkaWN0aW9uQ29udGV4dC5pc0VtcHR5TG9jYWwoc3VmZml4KSkge1xyXG5cdFx0XHRcdGlmIChjb250ZXh0Lmhhc0VtcHR5KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfTE9DQUw7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ3aGF0IHRvIGRvIGhlcmU/XCIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY29udGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3VmZml4LnNpemUgIT09IDEpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXBwZW5kaW5nIGEgdHJlZSBzdWZmaXggaXMgbm90IHlldCBzdXBwb3J0ZWQuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZXN1bHQgPSB2aXNpdGVkLmdldChjb250ZXh0KTtcclxuXHRcdGlmICghcmVzdWx0KSB7XHJcblx0XHRcdGlmIChjb250ZXh0LmlzRW1wdHkpIHtcclxuXHRcdFx0XHRyZXN1bHQgPSBzdWZmaXg7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IHBhcmVudENvdW50OiBudW1iZXIgPSBjb250ZXh0LnNpemU7XHJcblx0XHRcdFx0aWYgKGNvbnRleHQuaGFzRW1wdHkpIHtcclxuXHRcdFx0XHRcdHBhcmVudENvdW50LS07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgdXBkYXRlZFBhcmVudHM6IFByZWRpY3Rpb25Db250ZXh0W10gPSBuZXcgQXJyYXk8UHJlZGljdGlvbkNvbnRleHQ+KHBhcmVudENvdW50KTtcclxuXHRcdFx0XHRsZXQgdXBkYXRlZFJldHVyblN0YXRlczogbnVtYmVyW10gPSBuZXcgQXJyYXk8bnVtYmVyPihwYXJlbnRDb3VudCk7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRDb3VudDsgaSsrKSB7XHJcblx0XHRcdFx0XHR1cGRhdGVkUmV0dXJuU3RhdGVzW2ldID0gY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50Q291bnQ7IGkrKykge1xyXG5cdFx0XHRcdFx0dXBkYXRlZFBhcmVudHNbaV0gPSBBcnJheVByZWRpY3Rpb25Db250ZXh0LmFwcGVuZENvbnRleHRJbXBsKGNvbnRleHQuZ2V0UGFyZW50KGkpLCBzdWZmaXgsIHZpc2l0ZWQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHVwZGF0ZWRQYXJlbnRzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRcdFx0cmVzdWx0ID0gbmV3IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0KHVwZGF0ZWRQYXJlbnRzWzBdLCB1cGRhdGVkUmV0dXJuU3RhdGVzWzBdKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YXNzZXJ0KHVwZGF0ZWRQYXJlbnRzLmxlbmd0aCA+IDEpO1xyXG5cdFx0XHRcdFx0cmVzdWx0ID0gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQodXBkYXRlZFBhcmVudHMsIHVwZGF0ZWRSZXR1cm5TdGF0ZXMpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGNvbnRleHQuaGFzRW1wdHkpIHtcclxuXHRcdFx0XHRcdHJlc3VsdCA9IFByZWRpY3Rpb25Db250ZXh0LmpvaW4ocmVzdWx0LCBzdWZmaXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmlzaXRlZC5wdXQoY29udGV4dCwgcmVzdWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzID09PSBvKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIGlmICghKG8gaW5zdGFuY2VvZiBBcnJheVByZWRpY3Rpb25Db250ZXh0KSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzaENvZGUoKSAhPT0gby5oYXNoQ29kZSgpKSB7XHJcblx0XHRcdC8vIGNhbid0IGJlIHNhbWUgaWYgaGFzaCBpcyBkaWZmZXJlbnRcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBvdGhlcjogQXJyYXlQcmVkaWN0aW9uQ29udGV4dCA9IG87XHJcblx0XHRyZXR1cm4gdGhpcy5lcXVhbHNJbXBsKG90aGVyLCBuZXcgQXJyYXkyREhhc2hTZXQ8UHJlZGljdGlvbkNvbnRleHRDYWNoZS5JZGVudGl0eUNvbW11dGF0aXZlUHJlZGljdGlvbkNvbnRleHRPcGVyYW5kcz4oKSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGVxdWFsc0ltcGwob3RoZXI6IEFycmF5UHJlZGljdGlvbkNvbnRleHQsIHZpc2l0ZWQ6IEphdmFTZXQ8UHJlZGljdGlvbkNvbnRleHRDYWNoZS5JZGVudGl0eUNvbW11dGF0aXZlUHJlZGljdGlvbkNvbnRleHRPcGVyYW5kcz4pOiBib29sZWFuIHtcclxuXHRcdGxldCBzZWxmV29ya0xpc3Q6IFByZWRpY3Rpb25Db250ZXh0W10gPSBbXTtcclxuXHRcdGxldCBvdGhlcldvcmtMaXN0OiBQcmVkaWN0aW9uQ29udGV4dFtdID0gW107XHJcblx0XHRzZWxmV29ya0xpc3QucHVzaCh0aGlzKTtcclxuXHRcdG90aGVyV29ya0xpc3QucHVzaChvdGhlcik7XHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRsZXQgY3VycmVudFNlbGYgPSBzZWxmV29ya0xpc3QucG9wKCk7XHJcblx0XHRcdGxldCBjdXJyZW50T3RoZXIgPSBvdGhlcldvcmtMaXN0LnBvcCgpO1xyXG5cdFx0XHRpZiAoIWN1cnJlbnRTZWxmIHx8ICFjdXJyZW50T3RoZXIpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IG9wZXJhbmRzOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlLklkZW50aXR5Q29tbXV0YXRpdmVQcmVkaWN0aW9uQ29udGV4dE9wZXJhbmRzID0gbmV3IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUuSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHMoY3VycmVudFNlbGYsIGN1cnJlbnRPdGhlcik7XHJcblx0XHRcdGlmICghdmlzaXRlZC5hZGQob3BlcmFuZHMpKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBzZWxmU2l6ZTogbnVtYmVyID0gb3BlcmFuZHMueC5zaXplO1xyXG5cdFx0XHRpZiAoc2VsZlNpemUgPT09IDApIHtcclxuXHRcdFx0XHRpZiAoIW9wZXJhbmRzLnguZXF1YWxzKG9wZXJhbmRzLnkpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IG90aGVyU2l6ZTogbnVtYmVyID0gb3BlcmFuZHMueS5zaXplO1xyXG5cdFx0XHRpZiAoc2VsZlNpemUgIT09IG90aGVyU2l6ZSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWxmU2l6ZTsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKG9wZXJhbmRzLnguZ2V0UmV0dXJuU3RhdGUoaSkgIT09IG9wZXJhbmRzLnkuZ2V0UmV0dXJuU3RhdGUoaSkpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBzZWxmUGFyZW50OiBQcmVkaWN0aW9uQ29udGV4dCA9IG9wZXJhbmRzLnguZ2V0UGFyZW50KGkpO1xyXG5cdFx0XHRcdGxldCBvdGhlclBhcmVudDogUHJlZGljdGlvbkNvbnRleHQgPSBvcGVyYW5kcy55LmdldFBhcmVudChpKTtcclxuXHRcdFx0XHRpZiAoc2VsZlBhcmVudC5oYXNoQ29kZSgpICE9PSBvdGhlclBhcmVudC5oYXNoQ29kZSgpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoc2VsZlBhcmVudCAhPT0gb3RoZXJQYXJlbnQpIHtcclxuXHRcdFx0XHRcdHNlbGZXb3JrTGlzdC5wdXNoKHNlbGZQYXJlbnQpO1xyXG5cdFx0XHRcdFx0b3RoZXJXb3JrTGlzdC5wdXNoKG90aGVyUGFyZW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCBleHRlbmRzIFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgcGFyZW50OiBQcmVkaWN0aW9uQ29udGV4dDtcclxuXHRwdWJsaWMgcmV0dXJuU3RhdGU6IG51bWJlcjtcclxuXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgcGFyZW50OiBQcmVkaWN0aW9uQ29udGV4dCwgcmV0dXJuU3RhdGU6IG51bWJlcikge1xyXG5cdFx0c3VwZXIoUHJlZGljdGlvbkNvbnRleHQuY2FsY3VsYXRlU2luZ2xlSGFzaENvZGUocGFyZW50LCByZXR1cm5TdGF0ZSkpO1xyXG5cdFx0Ly8gYXNzZXJ0KHJldHVyblN0YXRlICE9IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZICYmIHJldHVyblN0YXRlICE9IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMX1NUQVRFX0tFWSk7XHJcblx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuXHRcdHRoaXMucmV0dXJuU3RhdGUgPSByZXR1cm5TdGF0ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXRQYXJlbnQoaW5kZXg6IG51bWJlcik6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdC8vIGFzc2VydChpbmRleCA9PSAwKTtcclxuXHRcdHJldHVybiB0aGlzLnBhcmVudDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXRSZXR1cm5TdGF0ZShpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdC8vIGFzc2VydChpbmRleCA9PSAwKTtcclxuXHRcdHJldHVybiB0aGlzLnJldHVyblN0YXRlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGZpbmRSZXR1cm5TdGF0ZShyZXR1cm5TdGF0ZTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLnJldHVyblN0YXRlID09PSByZXR1cm5TdGF0ZSA/IDAgOiAtMTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzaXplKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gMTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGhhc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGFwcGVuZENvbnRleHQoc3VmZml4OiBQcmVkaWN0aW9uQ29udGV4dCwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0cmV0dXJuIGNvbnRleHRDYWNoZS5nZXRDaGlsZCh0aGlzLnBhcmVudC5hcHBlbmRDb250ZXh0KHN1ZmZpeCwgY29udGV4dENhY2hlKSwgdGhpcy5yZXR1cm5TdGF0ZSk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgYWRkRW1wdHlDb250ZXh0KCk6IFByZWRpY3Rpb25Db250ZXh0IHtcclxuXHRcdGxldCBwYXJlbnRzOiBQcmVkaWN0aW9uQ29udGV4dFtdID0gW3RoaXMucGFyZW50LCBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMXTtcclxuXHRcdGxldCByZXR1cm5TdGF0ZXM6IG51bWJlcltdID0gW3RoaXMucmV0dXJuU3RhdGUsIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZXTtcclxuXHRcdHJldHVybiBuZXcgQXJyYXlQcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzLCByZXR1cm5TdGF0ZXMpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIHJlbW92ZUVtcHR5Q29udGV4dCgpOiBQcmVkaWN0aW9uQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMobzogYW55KTogYm9vbGVhbiB7XHJcblx0XHRpZiAobyA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAoIShvIGluc3RhbmNlb2YgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgb3RoZXI6IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0ID0gbztcclxuXHRcdGlmICh0aGlzLmhhc2hDb2RlKCkgIT09IG90aGVyLmhhc2hDb2RlKCkpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnJldHVyblN0YXRlID09PSBvdGhlci5yZXR1cm5TdGF0ZVxyXG5cdFx0XHQmJiB0aGlzLnBhcmVudC5lcXVhbHMob3RoZXIucGFyZW50KTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdGV4cG9ydCBjb25zdCBFTVBUWV9MT0NBTDogUHJlZGljdGlvbkNvbnRleHQgPSBuZXcgRW1wdHlQcmVkaWN0aW9uQ29udGV4dChmYWxzZSk7XHJcblx0ZXhwb3J0IGNvbnN0IEVNUFRZX0ZVTEw6IFByZWRpY3Rpb25Db250ZXh0ID0gbmV3IEVtcHR5UHJlZGljdGlvbkNvbnRleHQodHJ1ZSk7XHJcblx0ZXhwb3J0IGNvbnN0IEVNUFRZX0xPQ0FMX1NUQVRFX0tFWTogbnVtYmVyID0gLSgoMSA8PCAzMSkgPj4+IDApO1xyXG5cdGV4cG9ydCBjb25zdCBFTVBUWV9GVUxMX1NUQVRFX0tFWTogbnVtYmVyID0gKCgxIDw8IDMxKSA+Pj4gMCkgLSAxO1xyXG5cclxuXHRleHBvcnQgY2xhc3MgSWRlbnRpdHlIYXNoTWFwIGV4dGVuZHMgQXJyYXkyREhhc2hNYXA8UHJlZGljdGlvbkNvbnRleHQsIFByZWRpY3Rpb25Db250ZXh0PiB7XHJcblx0XHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdFx0c3VwZXIoSWRlbnRpdHlFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZXhwb3J0IGNsYXNzIElkZW50aXR5RXF1YWxpdHlDb21wYXJhdG9yIGltcGxlbWVudHMgRXF1YWxpdHlDb21wYXJhdG9yPFByZWRpY3Rpb25Db250ZXh0PiB7XHJcblx0XHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IElOU1RBTkNFOiBJZGVudGl0eUVxdWFsaXR5Q29tcGFyYXRvciA9IG5ldyBJZGVudGl0eUVxdWFsaXR5Q29tcGFyYXRvcigpO1xyXG5cclxuXHRcdHByaXZhdGUgSWRlbnRpdHlFcXVhbGl0eUNvbXBhcmF0b3IoKSB7XHJcblx0XHRcdC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBoYXNoQ29kZShvYmo6IFByZWRpY3Rpb25Db250ZXh0KTogbnVtYmVyIHtcclxuXHRcdFx0cmV0dXJuIG9iai5oYXNoQ29kZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEBPdmVycmlkZVxyXG5cdFx0cHVibGljIGVxdWFscyhhOiBQcmVkaWN0aW9uQ29udGV4dCwgYjogUHJlZGljdGlvbkNvbnRleHQpOiBib29sZWFuIHtcclxuXHRcdFx0cmV0dXJuIGEgPT09IGI7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyNS4yNzk2NjkyLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBcnJheTJESGFzaE1hcCB9IGZyb20gXCIuLi9taXNjL0FycmF5MkRIYXNoTWFwXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgRGVjaXNpb25TdGF0ZSB9IGZyb20gXCIuL0RlY2lzaW9uU3RhdGVcIjtcclxuaW1wb3J0IHsgRXF1YXRhYmxlIH0gZnJvbSBcIi4uL21pc2MvU3R1YnNcIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb25FeGVjdXRvciB9IGZyb20gXCIuL0xleGVyQWN0aW9uRXhlY3V0b3JcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuLi9taXNjL011cm11ckhhc2hcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi4vbWlzYy9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbkNvbnRleHQgfSBmcm9tIFwiLi9QcmVkaWN0aW9uQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uQ29udGV4dENhY2hlIH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRDYWNoZVwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4uL1JlY29nbml6ZXJcIjtcclxuaW1wb3J0IHsgU2VtYW50aWNDb250ZXh0IH0gZnJvbSBcIi4vU2VtYW50aWNDb250ZXh0XCI7XHJcblxyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZmllbGQgc3RvcmVzIHRoZSBiaXQgbWFzayBmb3IgaW1wbGVtZW50aW5nIHRoZVxyXG4gKiB7QGxpbmsgI2lzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWR9IHByb3BlcnR5IGFzIGEgYml0IHdpdGhpbiB0aGVcclxuICogZXhpc3Rpbmcge0BsaW5rICNhbHRBbmRPdXRlckNvbnRleHREZXB0aH0gZmllbGQuXHJcbiAqL1xyXG5jb25zdCBTVVBQUkVTU19QUkVDRURFTkNFX0ZJTFRFUjogbnVtYmVyID0gMHg4MDAwMDAwMDtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbG9jYXRpb24gd2l0aCBjb250ZXh0IGluIGFuIEFUTi4gVGhlIGxvY2F0aW9uIGlzIGlkZW50aWZpZWQgYnkgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XHJcbiAqXHJcbiAqICogVGhlIGN1cnJlbnQgQVROIHN0YXRlXHJcbiAqICogVGhlIHByZWRpY3RlZCBhbHRlcm5hdGl2ZVxyXG4gKiAqIFRoZSBzZW1hbnRpYyBjb250ZXh0IHdoaWNoIG11c3QgYmUgdHJ1ZSBmb3IgdGhpcyBjb25maWd1cmF0aW9uIHRvIGJlIGVuYWJsZWRcclxuICogKiBUaGUgc3ludGFjdGljIGNvbnRleHQsIHdoaWNoIGlzIHJlcHJlc2VudGVkIGFzIGEgZ3JhcGgtc3RydWN0dXJlZCBzdGFjayB3aG9zZSBwYXRoKHMpIGxlYWQgdG8gdGhlIHJvb3Qgb2YgdGhlIHJ1bGVcclxuICogICBpbnZvY2F0aW9ucyBsZWFkaW5nIHRvIHRoaXMgc3RhdGVcclxuICpcclxuICogSW4gYWRkaXRpb24gdG8gdGhlc2UgdmFsdWVzLCBgQVROQ29uZmlnYCBzdG9yZXMgc2V2ZXJhbCBwcm9wZXJ0aWVzIGFib3V0IHBhdGhzIHRha2VuIHRvIGdldCB0byB0aGUgbG9jYXRpb24gd2hpY2hcclxuICogd2VyZSBhZGRlZCBvdmVyIHRpbWUgdG8gaGVscCB3aXRoIHBlcmZvcm1hbmNlLCBjb3JyZWN0bmVzcywgYW5kL29yIGRlYnVnZ2luZy5cclxuICpcclxuICogKiBgcmVhY2hlc0ludG9PdXRlckNvbnRleHRgOjogVXNlZCB0byBlbnN1cmUgc2VtYW50aWMgcHJlZGljYXRlcyBhcmUgbm90IGV2YWx1YXRlZCBpbiB0aGUgd3JvbmcgY29udGV4dC5cclxuICogKiBgaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uYDogVXNlZCBmb3IgZW5hYmxpbmcgZmlyc3QtbWF0Y2gtd2lucyBpbnN0ZWFkIG9mIGxvbmdlc3QtbWF0Y2gtd2lucyBhZnRlclxyXG4gKiAgIGNyb3NzaW5nIGEgbm9uLWdyZWVkeSBkZWNpc2lvbi5cclxuICogKiBgbGV4ZXJBY3Rpb25FeGVjdXRvcmA6IFVzZWQgZm9yIHRyYWNraW5nIHRoZSBsZXhlciBhY3Rpb24ocykgdG8gZXhlY3V0ZSBzaG91bGQgdGhpcyBpbnN0YW5jZSBiZSBzZWxlY3RlZCBkdXJpbmdcclxuICogICBsZXhpbmcuXHJcbiAqICogYGlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWRgOiBBIHN0YXRlIHZhcmlhYmxlIGZvciBvbmUgb2YgdGhlIGR5bmFtaWMgZGlzYW1iaWd1YXRpb24gc3RyYXRlZ2llcyBlbXBsb3llZCBieVxyXG4gKiAgIGBQYXJzZXJBVE5TaW11bGF0b3IuYXBwbHlQcmVjZWRlbmNlRmlsdGVyYC5cclxuICpcclxuICogRHVlIHRvIHRoZSB1c2Ugb2YgYSBncmFwaC1zdHJ1Y3R1cmVkIHN0YWNrLCBhIHNpbmdsZSBgQVROQ29uZmlnYCBpcyBjYXBhYmxlIG9mIHJlcHJlc2VudGluZyBtYW55IGluZGl2aWR1YWwgQVROXHJcbiAqIGNvbmZpZ3VyYXRpb25zIHdoaWNoIHJlYWNoZWQgdGhlIHNhbWUgbG9jYXRpb24gaW4gYW4gQVROIGJ5IGZvbGxvd2luZyBkaWZmZXJlbnQgcGF0aHMuXHJcbiAqXHJcbiAqIFBFUkY6IFRvIGNvbnNlcnZlIG1lbW9yeSwgYEFUTkNvbmZpZ2AgaXMgc3BsaXQgaW50byBzZXZlcmFsIGRpZmZlcmVudCBjb25jcmV0ZSB0eXBlcy4gYEFUTkNvbmZpZ2AgaXRzZWxmIHN0b3JlcyB0aGVcclxuICogbWluaW11bSBhbW91bnQgb2YgaW5mb3JtYXRpb24gdHlwaWNhbGx5IHVzZWQgdG8gZGVmaW5lIGFuIGBBVE5Db25maWdgIGluc3RhbmNlLiBWYXJpb3VzIGRlcml2ZWQgdHlwZXMgcHJvdmlkZVxyXG4gKiBhZGRpdGlvbmFsIHN0b3JhZ2Ugc3BhY2UgZm9yIGNhc2VzIHdoZXJlIGEgbm9uLWRlZmF1bHQgdmFsdWUgaXMgdXNlZCBmb3Igc29tZSBvZiB0aGUgb2JqZWN0IHByb3BlcnRpZXMuIFRoZVxyXG4gKiBgQVROQ29uZmlnLmNyZWF0ZWAgYW5kIGBBVE5Db25maWcudHJhbnNmb3JtYCBtZXRob2RzIGF1dG9tYXRpY2FsbHkgc2VsZWN0IHRoZSBzbWFsbGVzdCBjb25jcmV0ZSB0eXBlIGNhcGFibGUgb2ZcclxuICogcmVwcmVzZW50aW5nIHRoZSB1bmlxdWUgaW5mb3JtYXRpb24gZm9yIGFueSBnaXZlbiBgQVROQ29uZmlnYC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBVE5Db25maWcgaW1wbGVtZW50cyBFcXVhdGFibGUge1xyXG5cdC8qKiBUaGUgQVROIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbmZpZ3VyYXRpb24gKi9cclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgX3N0YXRlOiBBVE5TdGF0ZTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyBhIGJpdC1maWVsZCBjdXJyZW50bHkgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlcy5cclxuXHQgKlxyXG5cdCAqICogMHgwMEZGRkZGRjogQWx0ZXJuYXRpdmVcclxuXHQgKiAqIDB4N0YwMDAwMDA6IE91dGVyIGNvbnRleHQgZGVwdGhcclxuXHQgKiAqIDB4ODAwMDAwMDA6IFN1cHByZXNzIHByZWNlZGVuY2UgZmlsdGVyXHJcblx0ICovXHJcblx0cHJpdmF0ZSBhbHRBbmRPdXRlckNvbnRleHREZXB0aDogbnVtYmVyO1xyXG5cclxuXHQvKiogVGhlIHN0YWNrIG9mIGludm9raW5nIHN0YXRlcyBsZWFkaW5nIHRvIHRoZSBydWxlL3N0YXRlcyBhc3NvY2lhdGVkXHJcblx0ICogIHdpdGggdGhpcyBjb25maWcuICBXZSB0cmFjayBvbmx5IHRob3NlIGNvbnRleHRzIHB1c2hlZCBkdXJpbmdcclxuXHQgKiAgZXhlY3V0aW9uIG9mIHRoZSBBVE4gc2ltdWxhdG9yLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSBfY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQ7XHJcblxyXG5cdGNvbnN0cnVjdG9yKC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIGFsdDogbnVtYmVyLCAvKkBOb3ROdWxsKi8gY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpO1xyXG5cdGNvbnN0cnVjdG9yKC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIC8qQE5vdE51bGwqLyBjOiBBVE5Db25maWcsIC8qQE5vdE51bGwqLyBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCk7XHJcblxyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHN0YXRlOiBBVE5TdGF0ZSwgYWx0T3JDb25maWc6IG51bWJlciB8IEFUTkNvbmZpZywgQE5vdE51bGwgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQpIHtcclxuXHRcdGlmICh0eXBlb2YgYWx0T3JDb25maWcgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0YXNzZXJ0KChhbHRPckNvbmZpZyAmIDB4RkZGRkZGKSA9PT0gYWx0T3JDb25maWcpO1xyXG5cdFx0XHR0aGlzLl9zdGF0ZSA9IHN0YXRlO1xyXG5cdFx0XHR0aGlzLmFsdEFuZE91dGVyQ29udGV4dERlcHRoID0gYWx0T3JDb25maWc7XHJcblx0XHRcdHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fc3RhdGUgPSBzdGF0ZTtcclxuXHRcdFx0dGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCA9IGFsdE9yQ29uZmlnLmFsdEFuZE91dGVyQ29udGV4dERlcHRoO1xyXG5cdFx0XHR0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgY3JlYXRlKC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIGFsdDogbnVtYmVyLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCk6IEFUTkNvbmZpZztcclxuXHJcblx0cHVibGljIHN0YXRpYyBjcmVhdGUoLypATm90TnVsbCovIHN0YXRlOiBBVE5TdGF0ZSwgYWx0OiBudW1iZXIsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LCAvKkBOb3ROdWxsKi8gc2VtYW50aWNDb250ZXh0OiBTZW1hbnRpY0NvbnRleHQpOiBBVE5Db25maWc7XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgY3JlYXRlKC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIGFsdDogbnVtYmVyLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCwgLypAKi8gc2VtYW50aWNDb250ZXh0OiBTZW1hbnRpY0NvbnRleHQsIGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQpOiBBVE5Db25maWc7XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgY3JlYXRlKEBOb3ROdWxsIHN0YXRlOiBBVE5TdGF0ZSwgYWx0OiBudW1iZXIsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LCBATm90TnVsbCBzZW1hbnRpY0NvbnRleHQ6IFNlbWFudGljQ29udGV4dCA9IFNlbWFudGljQ29udGV4dC5OT05FLCBsZXhlckFjdGlvbkV4ZWN1dG9yPzogTGV4ZXJBY3Rpb25FeGVjdXRvcik6IEFUTkNvbmZpZyB7XHJcblx0XHRpZiAoc2VtYW50aWNDb250ZXh0ICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xyXG5cdFx0XHRpZiAobGV4ZXJBY3Rpb25FeGVjdXRvciAhPSBudWxsKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBBY3Rpb25TZW1hbnRpY0NvbnRleHRBVE5Db25maWcobGV4ZXJBY3Rpb25FeGVjdXRvciwgc2VtYW50aWNDb250ZXh0LCBzdGF0ZSwgYWx0LCBjb250ZXh0LCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBTZW1hbnRpY0NvbnRleHRBVE5Db25maWcoc2VtYW50aWNDb250ZXh0LCBzdGF0ZSwgYWx0LCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAobGV4ZXJBY3Rpb25FeGVjdXRvciAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBuZXcgQWN0aW9uQVROQ29uZmlnKGxleGVyQWN0aW9uRXhlY3V0b3IsIHN0YXRlLCBhbHQsIGNvbnRleHQsIGZhbHNlKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEFUTkNvbmZpZyhzdGF0ZSwgYWx0LCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBHZXRzIHRoZSBBVE4gc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29uZmlndXJhdGlvbiAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IHN0YXRlKCk6IEFUTlN0YXRlIHtcclxuXHRcdHJldHVybiB0aGlzLl9zdGF0ZTtcclxuXHR9XHJcblxyXG5cdC8qKiBXaGF0IGFsdCAob3IgbGV4ZXIgcnVsZSkgaXMgcHJlZGljdGVkIGJ5IHRoaXMgY29uZmlndXJhdGlvbiAqL1xyXG5cdGdldCBhbHQoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmFsdEFuZE91dGVyQ29udGV4dERlcHRoICYgMHgwMEZGRkZGRjtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGNvbnRleHQoKTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRleHQ7XHJcblx0fVxyXG5cclxuXHRzZXQgY29udGV4dChATm90TnVsbCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCkge1xyXG5cdFx0dGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcblx0fVxyXG5cclxuXHRnZXQgcmVhY2hlc0ludG9PdXRlckNvbnRleHQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5vdXRlckNvbnRleHREZXB0aCAhPT0gMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdlIGNhbm5vdCBleGVjdXRlIHByZWRpY2F0ZXMgZGVwZW5kZW50IHVwb24gbG9jYWwgY29udGV4dCB1bmxlc3NcclxuXHQgKiB3ZSBrbm93IGZvciBzdXJlIHdlIGFyZSBpbiB0aGUgY29ycmVjdCBjb250ZXh0LiBCZWNhdXNlIHRoZXJlIGlzXHJcblx0ICogbm8gd2F5IHRvIGRvIHRoaXMgZWZmaWNpZW50bHksIHdlIHNpbXBseSBjYW5ub3QgZXZhbHVhdGVcclxuXHQgKiBkZXBlbmRlbnQgcHJlZGljYXRlcyB1bmxlc3Mgd2UgYXJlIGluIHRoZSBydWxlIHRoYXQgaW5pdGlhbGx5XHJcblx0ICogaW52b2tlcyB0aGUgQVROIHNpbXVsYXRvci5cclxuXHQgKlxyXG5cdCAqIGNsb3N1cmUoKSB0cmFja3MgdGhlIGRlcHRoIG9mIGhvdyBmYXIgd2UgZGlwIGludG8gdGhlIG91dGVyIGNvbnRleHQ6XHJcblx0ICogZGVwdGggJmd0OyAwLiAgTm90ZSB0aGF0IGl0IG1heSBub3QgYmUgdG90YWxseSBhY2N1cmF0ZSBkZXB0aCBzaW5jZSBJXHJcblx0ICogZG9uJ3QgZXZlciBkZWNyZW1lbnQuIFRPRE86IG1ha2UgaXQgYSBib29sZWFuIHRoZW5cclxuXHQgKi9cclxuXHRnZXQgb3V0ZXJDb250ZXh0RGVwdGgoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiAodGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCA+Pj4gMjQpICYgMHg3RjtcclxuXHR9XHJcblxyXG5cdHNldCBvdXRlckNvbnRleHREZXB0aChvdXRlckNvbnRleHREZXB0aDogbnVtYmVyKSB7XHJcblx0XHRhc3NlcnQob3V0ZXJDb250ZXh0RGVwdGggPj0gMCk7XHJcblx0XHQvLyBzYXR1cmF0ZSBhdCAweDdGIC0gZXZlcnl0aGluZyBidXQgemVyby9wb3NpdGl2ZSBpcyBvbmx5IHVzZWQgZm9yIGRlYnVnIGluZm9ybWF0aW9uIGFueXdheVxyXG5cdFx0b3V0ZXJDb250ZXh0RGVwdGggPSBNYXRoLm1pbihvdXRlckNvbnRleHREZXB0aCwgMHg3Rik7XHJcblx0XHR0aGlzLmFsdEFuZE91dGVyQ29udGV4dERlcHRoID0gKChvdXRlckNvbnRleHREZXB0aCA8PCAyNCkgfCAodGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCAmIH4weDdGMDAwMDAwKSA+Pj4gMCk7XHJcblx0fVxyXG5cclxuXHRnZXQgbGV4ZXJBY3Rpb25FeGVjdXRvcigpOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdGdldCBzZW1hbnRpY0NvbnRleHQoKTogU2VtYW50aWNDb250ZXh0IHtcclxuXHRcdHJldHVybiBTZW1hbnRpY0NvbnRleHQuTk9ORTtcclxuXHR9XHJcblxyXG5cdGdldCBoYXNQYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24oKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgY2xvbmUoKTogQVROQ29uZmlnIHtcclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybSh0aGlzLnN0YXRlLCBmYWxzZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdHJhbnNmb3JtKC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIGNoZWNrTm9uR3JlZWR5OiBib29sZWFuKTogQVROQ29uZmlnO1xyXG5cdHB1YmxpYyB0cmFuc2Zvcm0oLypATm90TnVsbCovIHN0YXRlOiBBVE5TdGF0ZSwgY2hlY2tOb25HcmVlZHk6IGJvb2xlYW4sIC8qQE5vdE51bGwqLyBzZW1hbnRpY0NvbnRleHQ6IFNlbWFudGljQ29udGV4dCk6IEFUTkNvbmZpZztcclxuXHRwdWJsaWMgdHJhbnNmb3JtKC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIGNoZWNrTm9uR3JlZWR5OiBib29sZWFuLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCk6IEFUTkNvbmZpZztcclxuXHRwdWJsaWMgdHJhbnNmb3JtKC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIGNoZWNrTm9uR3JlZWR5OiBib29sZWFuLCBsZXhlckFjdGlvbkV4ZWN1dG9yOiBMZXhlckFjdGlvbkV4ZWN1dG9yKTogQVROQ29uZmlnO1xyXG5cdHB1YmxpYyB0cmFuc2Zvcm0oLypATm90TnVsbCovIHN0YXRlOiBBVE5TdGF0ZSwgY2hlY2tOb25HcmVlZHk6IGJvb2xlYW4sIGFyZzI/OiBTZW1hbnRpY0NvbnRleHQgfCBQcmVkaWN0aW9uQ29udGV4dCB8IExleGVyQWN0aW9uRXhlY3V0b3IpOiBBVE5Db25maWcge1xyXG5cdFx0aWYgKGFyZzIgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1JbXBsKHN0YXRlLCB0aGlzLl9jb250ZXh0LCB0aGlzLnNlbWFudGljQ29udGV4dCwgY2hlY2tOb25HcmVlZHksIHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvcik7XHJcblx0XHR9IGVsc2UgaWYgKGFyZzIgaW5zdGFuY2VvZiBQcmVkaWN0aW9uQ29udGV4dCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1JbXBsKHN0YXRlLCBhcmcyLCB0aGlzLnNlbWFudGljQ29udGV4dCwgY2hlY2tOb25HcmVlZHksIHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvcik7XHJcblx0XHR9IGVsc2UgaWYgKGFyZzIgaW5zdGFuY2VvZiBTZW1hbnRpY0NvbnRleHQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtSW1wbChzdGF0ZSwgdGhpcy5fY29udGV4dCwgYXJnMiwgY2hlY2tOb25HcmVlZHksIHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1JbXBsKHN0YXRlLCB0aGlzLl9jb250ZXh0LCB0aGlzLnNlbWFudGljQ29udGV4dCwgY2hlY2tOb25HcmVlZHksIGFyZzIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSB0cmFuc2Zvcm1JbXBsKEBOb3ROdWxsIHN0YXRlOiBBVE5TdGF0ZSwgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQsIEBOb3ROdWxsIHNlbWFudGljQ29udGV4dDogU2VtYW50aWNDb250ZXh0LCBjaGVja05vbkdyZWVkeTogYm9vbGVhbiwgbGV4ZXJBY3Rpb25FeGVjdXRvcjogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCk6IEFUTkNvbmZpZyB7XHJcblx0XHRsZXQgcGFzc2VkVGhyb3VnaE5vbkdyZWVkeTogYm9vbGVhbiA9IGNoZWNrTm9uR3JlZWR5ICYmIEFUTkNvbmZpZy5jaGVja05vbkdyZWVkeURlY2lzaW9uKHRoaXMsIHN0YXRlKTtcclxuXHRcdGlmIChzZW1hbnRpY0NvbnRleHQgIT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XHJcblx0XHRcdGlmIChsZXhlckFjdGlvbkV4ZWN1dG9yICE9IG51bGwgfHwgcGFzc2VkVGhyb3VnaE5vbkdyZWVkeSkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgQWN0aW9uU2VtYW50aWNDb250ZXh0QVROQ29uZmlnKGxleGVyQWN0aW9uRXhlY3V0b3IsIHNlbWFudGljQ29udGV4dCwgc3RhdGUsIHRoaXMsIGNvbnRleHQsIHBhc3NlZFRocm91Z2hOb25HcmVlZHkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgU2VtYW50aWNDb250ZXh0QVROQ29uZmlnKHNlbWFudGljQ29udGV4dCwgc3RhdGUsIHRoaXMsIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChsZXhlckFjdGlvbkV4ZWN1dG9yICE9IG51bGwgfHwgcGFzc2VkVGhyb3VnaE5vbkdyZWVkeSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEFjdGlvbkFUTkNvbmZpZyhsZXhlckFjdGlvbkV4ZWN1dG9yLCBzdGF0ZSwgdGhpcywgY29udGV4dCwgcGFzc2VkVGhyb3VnaE5vbkdyZWVkeSk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBBVE5Db25maWcoc3RhdGUsIHRoaXMsIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgY2hlY2tOb25HcmVlZHlEZWNpc2lvbihzb3VyY2U6IEFUTkNvbmZpZywgdGFyZ2V0OiBBVE5TdGF0ZSk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHNvdXJjZS5oYXNQYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb25cclxuXHRcdFx0fHwgdGFyZ2V0IGluc3RhbmNlb2YgRGVjaXNpb25TdGF0ZSAmJiB0YXJnZXQubm9uR3JlZWR5O1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFwcGVuZENvbnRleHQoY29udGV4dDogbnVtYmVyLCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBBVE5Db25maWc7XHJcblx0cHVibGljIGFwcGVuZENvbnRleHQoY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IEFUTkNvbmZpZztcclxuXHRwdWJsaWMgYXBwZW5kQ29udGV4dChjb250ZXh0OiBudW1iZXIgfCBQcmVkaWN0aW9uQ29udGV4dCwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogQVROQ29uZmlnIHtcclxuXHRcdGlmICh0eXBlb2YgY29udGV4dCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRsZXQgYXBwZW5kZWRDb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCA9IHRoaXMuY29udGV4dC5hcHBlbmRTaW5nbGVDb250ZXh0KGNvbnRleHQsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdGxldCByZXN1bHQ6IEFUTkNvbmZpZyA9IHRoaXMudHJhbnNmb3JtKHRoaXMuc3RhdGUsIGZhbHNlLCBhcHBlbmRlZENvbnRleHQpO1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGFwcGVuZGVkQ29udGV4dDogUHJlZGljdGlvbkNvbnRleHQgPSB0aGlzLmNvbnRleHQuYXBwZW5kQ29udGV4dChjb250ZXh0LCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRsZXQgcmVzdWx0OiBBVE5Db25maWcgPSB0aGlzLnRyYW5zZm9ybSh0aGlzLnN0YXRlLCBmYWxzZSwgYXBwZW5kZWRDb250ZXh0KTtcclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZXMgaWYgdGhpcyBgQVROQ29uZmlnYCBmdWxseSBjb250YWlucyBhbm90aGVyIGBBVE5Db25maWdgLlxyXG5cdCAqXHJcblx0ICogQW4gQVROIGNvbmZpZ3VyYXRpb24gcmVwcmVzZW50cyBhIHBvc2l0aW9uIChpbmNsdWRpbmcgY29udGV4dCkgaW4gYW4gQVROIGR1cmluZyBwYXJzaW5nLiBTaW5jZSBgQVROQ29uZmlnYCBzdG9yZXNcclxuXHQgKiB0aGUgY29udGV4dCBhcyBhIGdyYXBoLCBhIHNpbmdsZSBgQVROQ29uZmlnYCBpbnN0YW5jZSBpcyBjYXBhYmxlIG9mIHJlcHJlc2VudGluZyBtYW55IEFUTiBjb25maWd1cmF0aW9ucyB3aGljaFxyXG5cdCAqIGFyZSBhbGwgaW4gdGhlIHNhbWUgXCJsb2NhdGlvblwiIGJ1dCBoYXZlIGRpZmZlcmVudCBjb250ZXh0cy4gVGhlc2UgYEFUTkNvbmZpZ2AgaW5zdGFuY2VzIGFyZSBhZ2FpbiBtZXJnZWQgd2hlblxyXG5cdCAqIHRoZXkgYXJlIGFkZGVkIHRvIGFuIGBBVE5Db25maWdTZXRgLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBgQVROQ29uZmlnU2V0LmNvbnRhaW5zYCBieSBldmFsdWF0aW5nIHdoZXRoZXIgYVxyXG5cdCAqIHBhcnRpY3VsYXIgYEFUTkNvbmZpZ2AgY29udGFpbnMgYWxsIG9mIHRoZSBBVE4gY29uZmlndXJhdGlvbnMgcmVwcmVzZW50ZWQgYnkgYW5vdGhlciBgQVROQ29uZmlnYC5cclxuXHQgKlxyXG5cdCAqIEFuIGBBVE5Db25maWdgIF9hXyBjb250YWlucyBhbm90aGVyIGBBVE5Db25maWdgIF9iXyBpZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblx0ICpcclxuXHQgKiAqIFRoZSBjb25maWd1cmF0aW9ucyBhcmUgaW4gdGhlIHNhbWUgc3RhdGUgKGBzdGF0ZWApXHJcblx0ICogKiBUaGUgY29uZmlndXJhdGlvbnMgcHJlZGljdCB0aGUgc2FtZSBhbHRlcm5hdGl2ZSAoYGFsdGApXHJcblx0ICogKiBUaGUgc2VtYW50aWMgY29udGV4dCBvZiBfYV8gaW1wbGllcyB0aGUgc2VtYW50aWMgY29udGV4dCBvZiBfYl8gKHRoaXMgbWV0aG9kIHBlcmZvcm1zIGEgd2Vha2VyIGVxdWFsaXR5IGNoZWNrKVxyXG5cdCAqICogSm9pbmluZyB0aGUgcHJlZGljdGlvbiBjb250ZXh0cyBvZiBfYV8gYW5kIF9iXyByZXN1bHRzIGluIHRoZSBwcmVkaWN0aW9uIGNvbnRleHQgb2YgX2FfXHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIGEgY29uc2VydmF0aXZlIGFwcHJveGltYXRpb24gb2YgY29udGFpbm1lbnQuIEFzIGEgcmVzdWx0LCB3aGVuIHRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgXHJcblx0ICogaXQgaXMga25vd24gdGhhdCBwYXJzaW5nIGZyb20gYHN1YmNvbmZpZ2AgY2FuIG9ubHkgcmVjb2duaXplIGEgc3Vic2V0IG9mIHRoZSBpbnB1dHMgd2hpY2ggY2FuIGJlIHJlY29nbml6ZWRcclxuXHQgKiBzdGFydGluZyBhdCB0aGUgY3VycmVudCBgQVROQ29uZmlnYC4gSG93ZXZlciwgZHVlIHRvIHRoZSBpbXByZWNpc2UgZXZhbHVhdGlvbiBvZiBpbXBsaWNhdGlvbiBmb3IgdGhlIHNlbWFudGljXHJcblx0ICogY29udGV4dHMsIG5vIGFzc3VtcHRpb25zIGNhbiBiZSBtYWRlIGFib3V0IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgY29uZmlndXJhdGlvbnMgd2hlbiB0aGlzIG1ldGhvZCByZXR1cm5zXHJcblx0ICogYGZhbHNlYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBzdWJjb25maWcgVGhlIHN1YiBjb25maWd1cmF0aW9uLlxyXG5cdCAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGNvbmZpZ3VyYXRpb24gY29udGFpbnMgYHN1YmNvbmZpZ2A7IG90aGVyd2lzZSwgYGZhbHNlYC5cclxuXHQgKi9cclxuXHRwdWJsaWMgY29udGFpbnMoc3ViY29uZmlnOiBBVE5Db25maWcpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLnN0YXRlLnN0YXRlTnVtYmVyICE9PSBzdWJjb25maWcuc3RhdGUuc3RhdGVOdW1iZXJcclxuXHRcdFx0fHwgdGhpcy5hbHQgIT09IHN1YmNvbmZpZy5hbHRcclxuXHRcdFx0fHwgIXRoaXMuc2VtYW50aWNDb250ZXh0LmVxdWFscyhzdWJjb25maWcuc2VtYW50aWNDb250ZXh0KSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGxlZnRXb3JrTGlzdDogUHJlZGljdGlvbkNvbnRleHRbXSA9IFtdO1xyXG5cdFx0bGV0IHJpZ2h0V29ya0xpc3Q6IFByZWRpY3Rpb25Db250ZXh0W10gPSBbXTtcclxuXHRcdGxlZnRXb3JrTGlzdC5wdXNoKHRoaXMuY29udGV4dCk7XHJcblx0XHRyaWdodFdvcmtMaXN0LnB1c2goc3ViY29uZmlnLmNvbnRleHQpO1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0bGV0IGxlZnQgPSBsZWZ0V29ya0xpc3QucG9wKCk7XHJcblx0XHRcdGxldCByaWdodCA9IHJpZ2h0V29ya0xpc3QucG9wKCk7XHJcblx0XHRcdGlmICghbGVmdCB8fCAhcmlnaHQpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGxlZnQgPT09IHJpZ2h0KSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChsZWZ0LnNpemUgPCByaWdodC5zaXplKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAocmlnaHQuaXNFbXB0eSkge1xyXG5cdFx0XHRcdHJldHVybiBsZWZ0Lmhhc0VtcHR5O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmlnaHQuc2l6ZTsgaSsrKSB7XHJcblx0XHRcdFx0XHRsZXQgaW5kZXg6IG51bWJlciA9IGxlZnQuZmluZFJldHVyblN0YXRlKHJpZ2h0LmdldFJldHVyblN0YXRlKGkpKTtcclxuXHRcdFx0XHRcdGlmIChpbmRleCA8IDApIHtcclxuXHRcdFx0XHRcdFx0Ly8gYXNzdW1lcyBpbnZva2luZ1N0YXRlcyBoYXMgbm8gZHVwbGljYXRlIGVudHJpZXNcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxlZnRXb3JrTGlzdC5wdXNoKGxlZnQuZ2V0UGFyZW50KGluZGV4KSk7XHJcblx0XHRcdFx0XHRyaWdodFdvcmtMaXN0LnB1c2gocmlnaHQuZ2V0UGFyZW50KGkpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRnZXQgaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAodGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCAmIFNVUFBSRVNTX1BSRUNFREVOQ0VfRklMVEVSKSAhPT0gMDtcclxuXHR9XHJcblxyXG5cdHNldCBpc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkKHZhbHVlOiBib29sZWFuKSB7XHJcblx0XHRpZiAodmFsdWUpIHtcclxuXHRcdFx0dGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCB8PSBTVVBQUkVTU19QUkVDRURFTkNFX0ZJTFRFUjtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0aGlzLmFsdEFuZE91dGVyQ29udGV4dERlcHRoICY9IH5TVVBQUkVTU19QUkVDRURFTkNFX0ZJTFRFUjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBBbiBBVE4gY29uZmlndXJhdGlvbiBpcyBlcXVhbCB0byBhbm90aGVyIGlmIGJvdGggaGF2ZVxyXG5cdCAqICB0aGUgc2FtZSBzdGF0ZSwgdGhleSBwcmVkaWN0IHRoZSBzYW1lIGFsdGVybmF0aXZlLCBhbmRcclxuXHQgKiAgc3ludGFjdGljL3NlbWFudGljIGNvbnRleHRzIGFyZSB0aGUgc2FtZS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG86IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKHRoaXMgPT09IG8pIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKCEobyBpbnN0YW5jZW9mIEFUTkNvbmZpZykpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnN0YXRlLnN0YXRlTnVtYmVyID09PSBvLnN0YXRlLnN0YXRlTnVtYmVyXHJcblx0XHRcdCYmIHRoaXMuYWx0ID09PSBvLmFsdFxyXG5cdFx0XHQmJiB0aGlzLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0ID09PSBvLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0XHJcblx0XHRcdCYmIHRoaXMuY29udGV4dC5lcXVhbHMoby5jb250ZXh0KVxyXG5cdFx0XHQmJiB0aGlzLnNlbWFudGljQ29udGV4dC5lcXVhbHMoby5zZW1hbnRpY0NvbnRleHQpXHJcblx0XHRcdCYmIHRoaXMuaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCA9PT0gby5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkXHJcblx0XHRcdCYmIHRoaXMuaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uID09PSBvLmhhc1Bhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvblxyXG5cdFx0XHQmJiBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuZXF1YWxzKHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvciwgby5sZXhlckFjdGlvbkV4ZWN1dG9yKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IGhhc2hDb2RlOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoNyk7XHJcblx0XHRoYXNoQ29kZSA9IE11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCB0aGlzLnN0YXRlLnN0YXRlTnVtYmVyKTtcclxuXHRcdGhhc2hDb2RlID0gTXVybXVySGFzaC51cGRhdGUoaGFzaENvZGUsIHRoaXMuYWx0KTtcclxuXHRcdGhhc2hDb2RlID0gTXVybXVySGFzaC51cGRhdGUoaGFzaENvZGUsIHRoaXMucmVhY2hlc0ludG9PdXRlckNvbnRleHQgPyAxIDogMCk7XHJcblx0XHRoYXNoQ29kZSA9IE11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCB0aGlzLmNvbnRleHQpO1xyXG5cdFx0aGFzaENvZGUgPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5zZW1hbnRpY0NvbnRleHQpO1xyXG5cdFx0aGFzaENvZGUgPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5oYXNQYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24gPyAxIDogMCk7XHJcblx0XHRoYXNoQ29kZSA9IE11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCB0aGlzLmxleGVyQWN0aW9uRXhlY3V0b3IpO1xyXG5cdFx0aGFzaENvZGUgPSBNdXJtdXJIYXNoLmZpbmlzaChoYXNoQ29kZSwgNyk7XHJcblx0XHRyZXR1cm4gaGFzaENvZGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IGBBVE5Db25maWdgIGluIEdyYXBodml6IGZvcm1hdC4gVGhlIGdyYXBoIGNhbiBiZSBzdG9yZWQgdG8gYVxyXG5cdCAqICoqLmRvdCoqIGZpbGUgYW5kIHRoZW4gcmVuZGVyZWQgdG8gYW4gaW1hZ2UgdXNpbmcgR3JhcGh2aXouXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBBIEdyYXBodml6IGdyYXBoIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBgQVROQ29uZmlnYC5cclxuXHQgKlxyXG5cdCAqIEBzZWUgaHR0cDovL3d3dy5ncmFwaHZpei5vcmcvXHJcblx0ICovXHJcblx0cHVibGljIHRvRG90U3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRsZXQgYnVpbGRlciA9IFwiXCI7XHJcblx0XHRidWlsZGVyICs9IChcImRpZ3JhcGggRyB7XFxuXCIpO1xyXG5cdFx0YnVpbGRlciArPSAoXCJyYW5rZGlyPUxSO1xcblwiKTtcclxuXHJcblx0XHRsZXQgdmlzaXRlZCA9IG5ldyBBcnJheTJESGFzaE1hcDxQcmVkaWN0aW9uQ29udGV4dCwgbnVtYmVyPihQcmVkaWN0aW9uQ29udGV4dC5JZGVudGl0eUVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSk7XHJcblx0XHRsZXQgd29ya0xpc3Q6IFByZWRpY3Rpb25Db250ZXh0W10gPSBbXTtcclxuXHRcdGZ1bmN0aW9uIGdldE9yQWRkQ29udGV4dChjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCk6IG51bWJlciB7XHJcblx0XHRcdGxldCBuZXdOdW1iZXIgPSB2aXNpdGVkLnNpemU7XHJcblx0XHRcdGxldCByZXN1bHQgPSB2aXNpdGVkLnB1dElmQWJzZW50KGNvbnRleHQsIG5ld051bWJlcik7XHJcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdC8vIEFscmVhZHkgc2F3IHRoaXMgY29udGV4dFxyXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHdvcmtMaXN0LnB1c2goY29udGV4dCk7XHJcblx0XHRcdHJldHVybiBuZXdOdW1iZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0d29ya0xpc3QucHVzaCh0aGlzLmNvbnRleHQpO1xyXG5cdFx0dmlzaXRlZC5wdXQodGhpcy5jb250ZXh0LCAwKTtcclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGxldCBjdXJyZW50ID0gd29ya0xpc3QucG9wKCk7XHJcblx0XHRcdGlmICghY3VycmVudCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnQuc2l6ZTsgaSsrKSB7XHJcblx0XHRcdFx0YnVpbGRlciArPSAoXCIgIHNcIikgKyAoZ2V0T3JBZGRDb250ZXh0KGN1cnJlbnQpKTtcclxuXHRcdFx0XHRidWlsZGVyICs9IChcIi0+XCIpO1xyXG5cdFx0XHRcdGJ1aWxkZXIgKz0gKFwic1wiKSArIChnZXRPckFkZENvbnRleHQoY3VycmVudC5nZXRQYXJlbnQoaSkpKTtcclxuXHRcdFx0XHRidWlsZGVyICs9IChcIltsYWJlbD1cXFwiXCIpICsgKGN1cnJlbnQuZ2V0UmV0dXJuU3RhdGUoaSkpICsgKFwiXFxcIl07XFxuXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YnVpbGRlciArPSAoXCJ9XFxuXCIpO1xyXG5cdFx0cmV0dXJuIGJ1aWxkZXIudG9TdHJpbmcoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmc7XHJcblx0cHVibGljIHRvU3RyaW5nKHJlY29nOiBSZWNvZ25pemVyPGFueSwgYW55PiB8IHVuZGVmaW5lZCwgc2hvd0FsdDogYm9vbGVhbik6IHN0cmluZztcclxuXHRwdWJsaWMgdG9TdHJpbmcocmVjb2c6IFJlY29nbml6ZXI8YW55LCBhbnk+IHwgdW5kZWZpbmVkLCBzaG93QWx0OiBib29sZWFuLCBzaG93Q29udGV4dDogYm9vbGVhbik6IHN0cmluZztcclxuXHRwdWJsaWMgdG9TdHJpbmcocmVjb2c/OiBSZWNvZ25pemVyPGFueSwgYW55Piwgc2hvd0FsdD86IGJvb2xlYW4sIHNob3dDb250ZXh0PzogYm9vbGVhbik6IHN0cmluZyB7XHJcblx0XHQvLyBNdXN0IGNoZWNrIHNob3dDb250ZXh0IGJlZm9yZSBzaG93QWx0IHRvIHByZXNlcnZlIG9yaWdpbmFsIG92ZXJsb2FkIGJlaGF2aW9yXHJcblx0XHRpZiAoc2hvd0NvbnRleHQgPT0gbnVsbCkge1xyXG5cdFx0XHRzaG93Q29udGV4dCA9IHNob3dBbHQgIT0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2hvd0FsdCA9PSBudWxsKSB7XHJcblx0XHRcdHNob3dBbHQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBidWYgPSBcIlwiO1xyXG5cdFx0Ly8gaWYgKHRoaXMuc3RhdGUucnVsZUluZGV4ID49IDApIHtcclxuXHRcdC8vIFx0aWYgKHJlY29nICE9IG51bGwpIHtcclxuXHRcdC8vIFx0XHRidWYgKz0gKHJlY29nLnJ1bGVOYW1lc1t0aGlzLnN0YXRlLnJ1bGVJbmRleF0gKyBcIjpcIik7XHJcblx0XHQvLyBcdH0gZWxzZSB7XHJcblx0XHQvLyBcdFx0YnVmICs9ICh0aGlzLnN0YXRlLnJ1bGVJbmRleCArIFwiOlwiKTtcclxuXHRcdC8vIFx0fVxyXG5cdFx0Ly8gfVxyXG5cdFx0bGV0IGNvbnRleHRzOiBzdHJpbmdbXTtcclxuXHRcdGlmIChzaG93Q29udGV4dCkge1xyXG5cdFx0XHRjb250ZXh0cyA9IHRoaXMuY29udGV4dC50b1N0cmluZ3MocmVjb2csIHRoaXMuc3RhdGUuc3RhdGVOdW1iZXIpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGNvbnRleHRzID0gW1wiP1wiXTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZmlyc3Q6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdFx0Zm9yIChsZXQgY29udGV4dERlc2Mgb2YgY29udGV4dHMpIHtcclxuXHRcdFx0aWYgKGZpcnN0KSB7XHJcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRidWYgKz0gKFwiLCBcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJ1ZiArPSAoXCIoXCIpO1xyXG5cdFx0XHRidWYgKz0gKHRoaXMuc3RhdGUpO1xyXG5cdFx0XHRpZiAoc2hvd0FsdCkge1xyXG5cdFx0XHRcdGJ1ZiArPSAoXCIsXCIpO1xyXG5cdFx0XHRcdGJ1ZiArPSAodGhpcy5hbHQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLmNvbnRleHQpIHtcclxuXHRcdFx0XHRidWYgKz0gKFwiLFwiKTtcclxuXHRcdFx0XHRidWYgKz0gKGNvbnRleHREZXNjKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5zZW1hbnRpY0NvbnRleHQgIT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XHJcblx0XHRcdFx0YnVmICs9IChcIixcIik7XHJcblx0XHRcdFx0YnVmICs9ICh0aGlzLnNlbWFudGljQ29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMucmVhY2hlc0ludG9PdXRlckNvbnRleHQpIHtcclxuXHRcdFx0XHRidWYgKz0gKFwiLHVwPVwiKSArICh0aGlzLm91dGVyQ29udGV4dERlcHRoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRidWYgKz0gKFwiKVwiKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBidWYudG9TdHJpbmcoKTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHdhcyBkZXJpdmVkIGZyb20gYEFUTkNvbmZpZ2AgcHVyZWx5IGFzIGEgbWVtb3J5IG9wdGltaXphdGlvbi4gSXQgYWxsb3dzIGZvciB0aGUgY3JlYXRpb24gb2YgYW4gYEFUTkNvbmZpZ2BcclxuICogd2l0aCBhIG5vbi1kZWZhdWx0IHNlbWFudGljIGNvbnRleHQuXHJcbiAqXHJcbiAqIFNlZSB0aGUgYEFUTkNvbmZpZ2AgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjb25zZXJ2aW5nIG1lbW9yeSB0aHJvdWdoIHRoZSB1c2Ugb2Ygc2V2ZXJhbCBjb25jcmV0ZVxyXG4gKiB0eXBlcy5cclxuICovXHJcbmNsYXNzIFNlbWFudGljQ29udGV4dEFUTkNvbmZpZyBleHRlbmRzIEFUTkNvbmZpZyB7XHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIF9zZW1hbnRpY0NvbnRleHQ6IFNlbWFudGljQ29udGV4dDtcclxuXHJcblx0Y29uc3RydWN0b3Ioc2VtYW50aWNDb250ZXh0OiBTZW1hbnRpY0NvbnRleHQsIC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIGFsdDogbnVtYmVyLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCk7XHJcblx0Y29uc3RydWN0b3Ioc2VtYW50aWNDb250ZXh0OiBTZW1hbnRpY0NvbnRleHQsIC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIC8qQE5vdE51bGwqLyBjOiBBVE5Db25maWcsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0KTtcclxuXHRjb25zdHJ1Y3RvcihzZW1hbnRpY0NvbnRleHQ6IFNlbWFudGljQ29udGV4dCwgQE5vdE51bGwgc3RhdGU6IEFUTlN0YXRlLCBATm90TnVsbCBhbHRPckNvbmZpZzogbnVtYmVyIHwgQVROQ29uZmlnLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCkge1xyXG5cdFx0aWYgKHR5cGVvZiBhbHRPckNvbmZpZyA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRzdXBlcihzdGF0ZSwgYWx0T3JDb25maWcsIGNvbnRleHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3VwZXIoc3RhdGUsIGFsdE9yQ29uZmlnLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZW1hbnRpY0NvbnRleHQgPSBzZW1hbnRpY0NvbnRleHQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2VtYW50aWNDb250ZXh0KCk6IFNlbWFudGljQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc2VtYW50aWNDb250ZXh0O1xyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHdhcyBkZXJpdmVkIGZyb20gYEFUTkNvbmZpZ2AgcHVyZWx5IGFzIGEgbWVtb3J5IG9wdGltaXphdGlvbi4gSXQgYWxsb3dzIGZvciB0aGUgY3JlYXRpb24gb2YgYW4gYEFUTkNvbmZpZ2BcclxuICogd2l0aCBhIGxleGVyIGFjdGlvbi5cclxuICpcclxuICogU2VlIHRoZSBgQVROQ29uZmlnYCBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGNvbnNlcnZpbmcgbWVtb3J5IHRocm91Z2ggdGhlIHVzZSBvZiBzZXZlcmFsIGNvbmNyZXRlXHJcbiAqIHR5cGVzLlxyXG4gKi9cclxuY2xhc3MgQWN0aW9uQVROQ29uZmlnIGV4dGVuZHMgQVROQ29uZmlnIHtcclxuXHRwcml2YXRlIF9sZXhlckFjdGlvbkV4ZWN1dG9yPzogTGV4ZXJBY3Rpb25FeGVjdXRvcjtcclxuXHRwcml2YXRlIHBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbjogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IobGV4ZXJBY3Rpb25FeGVjdXRvcjogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCwgLypATm90TnVsbCovIHN0YXRlOiBBVE5TdGF0ZSwgYWx0OiBudW1iZXIsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LCBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb246IGJvb2xlYW4pO1xyXG5cdGNvbnN0cnVjdG9yKGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQsIC8qQE5vdE51bGwqLyBzdGF0ZTogQVROU3RhdGUsIC8qQE5vdE51bGwqLyBjOiBBVE5Db25maWcsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LCBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb246IGJvb2xlYW4pO1xyXG5cdGNvbnN0cnVjdG9yKGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQsIEBOb3ROdWxsIHN0YXRlOiBBVE5TdGF0ZSwgQE5vdE51bGwgYWx0T3JDb25maWc6IG51bWJlciB8IEFUTkNvbmZpZywgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQsIHBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbjogYm9vbGVhbikge1xyXG5cdFx0aWYgKHR5cGVvZiBhbHRPckNvbmZpZyA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRzdXBlcihzdGF0ZSwgYWx0T3JDb25maWcsIGNvbnRleHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3VwZXIoc3RhdGUsIGFsdE9yQ29uZmlnLCBjb250ZXh0KTtcclxuXHRcdFx0aWYgKGFsdE9yQ29uZmlnLnNlbWFudGljQ29udGV4dCAhPT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGV4ZXJBY3Rpb25FeGVjdXRvciA9IGxleGVyQWN0aW9uRXhlY3V0b3I7XHJcblx0XHR0aGlzLnBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbiA9IHBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBsZXhlckFjdGlvbkV4ZWN1dG9yKCk6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xleGVyQWN0aW9uRXhlY3V0b3I7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uO1xyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3Mgd2FzIGRlcml2ZWQgZnJvbSBgU2VtYW50aWNDb250ZXh0QVROQ29uZmlnYCBwdXJlbHkgYXMgYSBtZW1vcnkgb3B0aW1pemF0aW9uLiBJdCBhbGxvd3MgZm9yIHRoZSBjcmVhdGlvbiBvZlxyXG4gKiBhbiBgQVROQ29uZmlnYCB3aXRoIGJvdGggYSBsZXhlciBhY3Rpb24gYW5kIGEgbm9uLWRlZmF1bHQgc2VtYW50aWMgY29udGV4dC5cclxuICpcclxuICogU2VlIHRoZSBgQVROQ29uZmlnYCBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGNvbnNlcnZpbmcgbWVtb3J5IHRocm91Z2ggdGhlIHVzZSBvZiBzZXZlcmFsIGNvbmNyZXRlXHJcbiAqIHR5cGVzLlxyXG4gKi9cclxuY2xhc3MgQWN0aW9uU2VtYW50aWNDb250ZXh0QVROQ29uZmlnIGV4dGVuZHMgU2VtYW50aWNDb250ZXh0QVROQ29uZmlnIHtcclxuXHRwcml2YXRlIF9sZXhlckFjdGlvbkV4ZWN1dG9yPzogTGV4ZXJBY3Rpb25FeGVjdXRvcjtcclxuXHRwcml2YXRlIHBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbjogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IobGV4ZXJBY3Rpb25FeGVjdXRvcjogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCwgLypATm90TnVsbCovIHNlbWFudGljQ29udGV4dDogU2VtYW50aWNDb250ZXh0LCAvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCBhbHQ6IG51bWJlciwgY29udGV4dDogUHJlZGljdGlvbkNvbnRleHQsIHBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbjogYm9vbGVhbik7XHJcblx0Y29uc3RydWN0b3IobGV4ZXJBY3Rpb25FeGVjdXRvcjogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCwgLypATm90TnVsbCovIHNlbWFudGljQ29udGV4dDogU2VtYW50aWNDb250ZXh0LCAvKkBOb3ROdWxsKi8gc3RhdGU6IEFUTlN0YXRlLCAvKkBOb3ROdWxsKi8gYzogQVROQ29uZmlnLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCwgcGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uOiBib29sZWFuKTtcclxuXHRjb25zdHJ1Y3RvcihsZXhlckFjdGlvbkV4ZWN1dG9yOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHwgdW5kZWZpbmVkLCBATm90TnVsbCBzZW1hbnRpY0NvbnRleHQ6IFNlbWFudGljQ29udGV4dCwgQE5vdE51bGwgc3RhdGU6IEFUTlN0YXRlLCBhbHRPckNvbmZpZzogbnVtYmVyIHwgQVROQ29uZmlnLCBjb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCwgcGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uOiBib29sZWFuKSB7XHJcblx0XHRpZiAodHlwZW9mIGFsdE9yQ29uZmlnID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHN1cGVyKHNlbWFudGljQ29udGV4dCwgc3RhdGUsIGFsdE9yQ29uZmlnLCBjb250ZXh0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN1cGVyKHNlbWFudGljQ29udGV4dCwgc3RhdGUsIGFsdE9yQ29uZmlnLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sZXhlckFjdGlvbkV4ZWN1dG9yID0gbGV4ZXJBY3Rpb25FeGVjdXRvcjtcclxuXHRcdHRoaXMucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uID0gcGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGxleGVyQWN0aW9uRXhlY3V0b3IoKTogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGV4ZXJBY3Rpb25FeGVjdXRvcjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBoYXNQYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24oKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5wYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb247XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XHJcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSBcInV0aWxcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuL011cm11ckhhc2hcIjtcclxuXHJcbi8qKlxyXG4gKiBQcml2YXRlIGVtcHR5IGFycmF5IHVzZWQgdG8gY29uc3RydWN0IGVtcHR5IEJpdFNldHNcclxuICovXHJcbmNvbnN0IEVNUFRZX0RBVEE6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KDApO1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHdvcmQgaW5kZXggb2YgdGhlIGBVSW50MTZgIGVsZW1lbnQgaW4gYEJpdFNldC5kYXRhYCBjb250YWluaW5nIHRoZSBiaXQgd2l0aCB0aGUgc3BlY2lmaWVkIGluZGV4LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW5kZXgoYml0TnVtYmVyOiBudW1iZXIpIHtcclxuXHRyZXR1cm4gYml0TnVtYmVyID4+PiA0O1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhIHdvcmQgaW5kZXggaW50byB0aGUgYml0IGluZGV4IG9mIHRoZSBMU0Igb2YgdGhhdCB3b3JkXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gdW5JbmRleChuOiBudW1iZXIpIHtcclxuXHRyZXR1cm4gbiAqIDE2O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0J3MgdGhlIGJpdCBudW1iZXIgb2YgdGhlIGxlYXN0IHNpZ25maWNhbnQgYml0IHNldCBMU0Igd2hpY2ggaXMgc2V0IGluIGEgd29yZCBub24temVybyB3b3JkO1xyXG4gKiBCaXQgbnVtYmVycyBydW4gZnJvbSBMU0IgdG8gTVNCIHN0YXJ0aW5nIHdpdGggMC5cclxuICovXHJcbmZ1bmN0aW9uIGZpbmRMU0JTZXQod29yZDogbnVtYmVyKSB7XHJcblx0bGV0IGJpdCA9IDE7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcblx0XHRpZiAoKHdvcmQgJiBiaXQpICE9PSAwKSB7XHJcblx0XHRcdHJldHVybiBpO1xyXG5cdFx0fVxyXG5cdFx0Yml0ID0gKGJpdCA8PCAxKSA+Pj4gMDtcclxuXHR9XHJcblx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBzcGVjaWZpZWQgYml0IGZvdW5kXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5kTVNCU2V0KHdvcmQ6IG51bWJlcikge1xyXG5cdGxldCBiaXQgPSAoMSA8PCAxNSkgPj4+IDA7XHJcblx0Zm9yIChsZXQgaSA9IDE1OyBpID49IDA7IGktLSkge1xyXG5cdFx0aWYgKCh3b3JkICYgYml0KSAhPT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gaTtcclxuXHRcdH1cclxuXHRcdGJpdCA9IGJpdCA+Pj4gMTtcclxuXHR9XHJcblx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBzcGVjaWZpZWQgYml0IGZvdW5kXCIpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBhIDE2LWJpdCBtYXNrIHdpdGggYml0IG51bWJlcnMgZnJvbUJpdCB0byB0b0JpdCAoaW5jbHVzaXZlKSBzZXQuXHJcbiAqIEJpdCBudW1iZXJzIHJ1biBmcm9tIExTQiB0byBNU0Igc3RhcnRpbmcgd2l0aCAwLlxyXG4gKi9cclxuZnVuY3Rpb24gYml0c0Zvcihmcm9tQml0OiBudW1iZXIsIHRvQml0OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdGZyb21CaXQgJj0gMHhGO1xyXG5cdHRvQml0ICY9IDB4RjtcclxuXHRpZiAoZnJvbUJpdCA9PT0gdG9CaXQpIHtcclxuXHRcdHJldHVybiAoMSA8PCBmcm9tQml0KSA+Pj4gMDtcclxuXHR9XHJcblx0cmV0dXJuICgoMHhGRkZGID4+PiAoMTUgLSB0b0JpdCkpIF4gKDB4RkZGRiA+Pj4gKDE2IC0gZnJvbUJpdCkpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgbG9va3VwIHRhYmxlIGZvciBudW1iZXIgb2Ygc2V0IGJpdHMgaW4gYSAxNi1iaXQgaW50ZWdlci4gICBUaGlzIGlzIHVzZWQgdG8gcXVpY2tseSBjb3VudCB0aGUgY2FyZGluYWxpdHkgKG51bWJlciBvZiB1bmlxdWUgZWxlbWVudHMpIG9mIGEgQml0U2V0LlxyXG4gKi9cclxuY29uc3QgUE9QX0NOVDogVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDY1NTM2KTtcclxuZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcblx0Y29uc3Qgc3RyaWRlID0gKDEgPDwgaSkgPj4+IDA7XHJcblx0bGV0IGluZGV4ID0gMDtcclxuXHR3aGlsZSAoaW5kZXggPCBQT1BfQ05ULmxlbmd0aCkge1xyXG5cdFx0Ly8gc2tpcCB0aGUgbnVtYmVycyB3aGVyZSB0aGUgYml0IGlzbid0IHNldFxyXG5cdFx0aW5kZXggKz0gc3RyaWRlO1xyXG5cclxuXHRcdC8vIGluY3JlbWVudCB0aGUgb25lcyB3aGVyZSB0aGUgYml0IGlzIHNldFxyXG5cdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBzdHJpZGU7IGorKykge1xyXG5cdFx0XHRQT1BfQ05UW2luZGV4XSsrO1xyXG5cdFx0XHRpbmRleCsrO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEJpdFNldCBpbXBsZW1lbnRzIEl0ZXJhYmxlPG51bWJlcj57XHJcblx0cHJpdmF0ZSBkYXRhOiBVaW50MTZBcnJheTtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIG5ldyBiaXQgc2V0LiBBbGwgYml0cyBhcmUgaW5pdGlhbGx5IGBmYWxzZWAuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoKTtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIGJpdCBzZXQgd2hvc2UgaW5pdGlhbCBzaXplIGlzIGxhcmdlIGVub3VnaCB0byBleHBsaWNpdGx5IHJlcHJlc2VudCBiaXRzIHdpdGggaW5kaWNlcyBpbiB0aGUgcmFuZ2UgYDBgXHJcblx0ICogdGhyb3VnaCBgbmJpdHMtMWAuIEFsbCBiaXRzIGFyZSBpbml0aWFsbHkgYGZhbHNlYC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihuYml0czogbnVtYmVyKTtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIGJpdCBzZXQgZnJvbSBhIGl0ZXJhYmxlIGxpc3Qgb2YgbnVtYmVycyAoaW5jbHVkaW5nIGFub3RoZXIgQml0U2V0KTtcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihudW1iZXJzOiBJdGVyYWJsZTxudW1iZXI+KTtcclxuXHJcblx0LypcclxuXHQqKiBjb25zdHJ1Y3RvciBpbXBsZW1lbnRhdGlvblxyXG5cdCovXHJcblx0Y29uc3RydWN0b3IoYXJnPzogbnVtYmVyIHwgSXRlcmFibGU8bnVtYmVyPikge1xyXG5cdFx0aWYgKCFhcmcpIHtcclxuXHRcdFx0Ly8gY292ZXJpbmcgdGhlIGNhc2Ugb2YgdW5zcGVjaWZpZWQgYW5kIG5iaXRzPT09MFxyXG5cdFx0XHR0aGlzLmRhdGEgPSBFTVBUWV9EQVRBO1xyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdGlmIChhcmcgPCAwKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJuYml0cyBjYW5ub3QgYmUgbmVnYXRpdmVcIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5kYXRhID0gbmV3IFVpbnQxNkFycmF5KGdldEluZGV4KGFyZyAtIDEpICsgMSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChhcmcgaW5zdGFuY2VvZiBCaXRTZXQpIHtcclxuXHRcdFx0XHR0aGlzLmRhdGEgPSBhcmcuZGF0YS5zbGljZSgwKTsgLy8gQ2xvbmUgdGhlIGRhdGFcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgbWF4ID0gLTE7XHJcblx0XHRcdFx0Zm9yIChsZXQgdiBvZiBhcmcpIHtcclxuXHRcdFx0XHRcdGlmIChtYXggPCB2KSB7XHJcblx0XHRcdFx0XHRcdG1heCA9IHY7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuZGF0YSA9IG5ldyBVaW50MTZBcnJheShnZXRJbmRleChtYXggLSAxKSArIDEpO1xyXG5cdFx0XHRcdGZvciAobGV0IHYgb2YgYXJnKSB7XHJcblx0XHRcdFx0XHR0aGlzLnNldCh2KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBlcmZvcm1zIGEgbG9naWNhbCAqKkFORCoqIG9mIHRoaXMgdGFyZ2V0IGJpdCBzZXQgd2l0aCB0aGUgYXJndW1lbnQgYml0IHNldC4gVGhpcyBiaXQgc2V0IGlzIG1vZGlmaWVkIHNvIHRoYXRcclxuXHQgKiBlYWNoIGJpdCBpbiBpdCBoYXMgdGhlIHZhbHVlIGB0cnVlYCBpZiBhbmQgb25seSBpZiBpdCBib3RoIGluaXRpYWxseSBoYWQgdGhlIHZhbHVlIGB0cnVlYCBhbmQgdGhlIGNvcnJlc3BvbmRpbmdcclxuXHQgKiBiaXQgaW4gdGhlIGJpdCBzZXQgYXJndW1lbnQgYWxzbyBoYWQgdGhlIHZhbHVlIGB0cnVlYC5cclxuXHQgKi9cclxuXHRwdWJsaWMgYW5kKHNldDogQml0U2V0KTogdm9pZCB7XHJcblx0XHRjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0Y29uc3Qgb3RoZXIgPSBzZXQuZGF0YTtcclxuXHRcdGNvbnN0IHdvcmRzID0gTWF0aC5taW4oZGF0YS5sZW5ndGgsIG90aGVyLmxlbmd0aCk7XHJcblxyXG5cdFx0bGV0IGxhc3RXb3JkID0gLTE7XHQvLyBLZWVwIHRyYWNrIG9mIGluZGV4IG9mIGxhc3Qgbm9uLXplcm8gd29yZFxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHM7IGkrKykge1xyXG5cdFx0XHRsZXQgdmFsdWUgPSBkYXRhW2ldICY9IG90aGVyW2ldO1xyXG5cdFx0XHRpZiAodmFsdWUgIT09IDApIHtcclxuXHRcdFx0XHRsYXN0V29yZCA9IGk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGFzdFdvcmQgPT09IC0xKSB7XHJcblx0XHRcdHRoaXMuZGF0YSA9IEVNUFRZX0RBVEE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhc3RXb3JkIDwgZGF0YS5sZW5ndGggLSAxKSB7XHJcblx0XHRcdHRoaXMuZGF0YSA9IGRhdGEuc2xpY2UoMCwgbGFzdFdvcmQgKyAxKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsZWFycyBhbGwgb2YgdGhlIGJpdHMgaW4gdGhpcyBgQml0U2V0YCB3aG9zZSBjb3JyZXNwb25kaW5nIGJpdCBpcyBzZXQgaW4gdGhlIHNwZWNpZmllZCBgQml0U2V0YC5cclxuXHQgKi9cclxuXHRwdWJsaWMgYW5kTm90KHNldDogQml0U2V0KTogdm9pZCB7XHJcblx0XHRjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0Y29uc3Qgb3RoZXIgPSBzZXQuZGF0YTtcclxuXHRcdGNvbnN0IHdvcmRzID0gTWF0aC5taW4oZGF0YS5sZW5ndGgsIG90aGVyLmxlbmd0aCk7XHJcblxyXG5cdFx0bGV0IGxhc3RXb3JkID0gLTE7XHQvLyBLZWVwIHRyYWNrIG9mIGluZGV4IG9mIGxhc3Qgbm9uLXplcm8gd29yZFxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHM7IGkrKykge1xyXG5cdFx0XHRsZXQgdmFsdWUgPSBkYXRhW2ldICY9IChvdGhlcltpXSBeIDB4RkZGRik7XHJcblx0XHRcdGlmICh2YWx1ZSAhPT0gMCkge1xyXG5cdFx0XHRcdGxhc3RXb3JkID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXN0V29yZCA9PT0gLTEpIHtcclxuXHRcdFx0dGhpcy5kYXRhID0gRU1QVFlfREFUQTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGFzdFdvcmQgPCBkYXRhLmxlbmd0aCAtIDEpIHtcclxuXHRcdFx0dGhpcy5kYXRhID0gZGF0YS5zbGljZSgwLCBsYXN0V29yZCArIDEpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBiaXRzIHNldCB0byBgdHJ1ZWAgaW4gdGhpcyBgQml0U2V0YC5cclxuXHQgKi9cclxuXHRwdWJsaWMgY2FyZGluYWxpdHkoKTogbnVtYmVyIHtcclxuXHRcdGlmICh0aGlzLmlzRW1wdHkpIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblx0XHRjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0Y29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcblx0XHRsZXQgcmVzdWx0ID0gMDtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHJlc3VsdCArPSBQT1BfQ05UW2RhdGFbaV1dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIGFsbCBvZiB0aGUgYml0cyBpbiB0aGlzIGBCaXRTZXRgIHRvIGBmYWxzZWAuXHJcblx0ICovXHJcblx0cHVibGljIGNsZWFyKCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGJpdCBzcGVjaWZpZWQgYnkgdGhlIGluZGV4IHRvIGBmYWxzZWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gYml0SW5kZXggdGhlIGluZGV4IG9mIHRoZSBiaXQgdG8gYmUgY2xlYXJlZFxyXG5cdCAqXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgbmVnYXRpdmVcclxuXHQgKi9cclxuXHRwdWJsaWMgY2xlYXIoYml0SW5kZXg6IG51bWJlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIGBmcm9tSW5kZXhgIChpbmNsdXNpdmUpIHRvIHRoZSBzcGVjaWZpZWQgYHRvSW5kZXhgIChleGNsdXNpdmUpIHRvIGBmYWxzZWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gZnJvbUluZGV4IGluZGV4IG9mIHRoZSBmaXJzdCBiaXQgdG8gYmUgY2xlYXJlZFxyXG5cdCAqIEBwYXJhbSB0b0luZGV4IGluZGV4IGFmdGVyIHRoZSBsYXN0IGJpdCB0byBiZSBjbGVhcmVkXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIG9yIGB0b0luZGV4YCBpcyBuZWdhdGl2ZSwgb3IgYGZyb21JbmRleGAgaXMgbGFyZ2VyIHRoYW4gYHRvSW5kZXhgXHJcblx0ICovXHJcblx0cHVibGljIGNsZWFyKGZyb21JbmRleDogbnVtYmVyLCB0b0luZGV4OiBudW1iZXIpOiB2b2lkO1xyXG5cdHB1YmxpYyBjbGVhcihmcm9tSW5kZXg/OiBudW1iZXIsIHRvSW5kZXg/OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmIChmcm9tSW5kZXggPT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLmRhdGEuZmlsbCgwKTtcclxuXHRcdH0gZWxzZSBpZiAodG9JbmRleCA9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuc2V0KGZyb21JbmRleCwgZmFsc2UpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5zZXQoZnJvbUluZGV4LCB0b0luZGV4LCBmYWxzZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBiaXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCB0byB0aGUgY29tcGxlbWVudCBvZiBpdHMgY3VycmVudCB2YWx1ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBiaXRJbmRleCB0aGUgaW5kZXggb2YgdGhlIGJpdCB0byBmbGlwXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgdGhlIHNwZWNpZmllZCBpbmRleCBpcyBuZWdhdGl2ZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBmbGlwKGJpdEluZGV4OiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIGVhY2ggYml0IGZyb20gdGhlIHNwZWNpZmllZCBgZnJvbUluZGV4YCAoaW5jbHVzaXZlKSB0byB0aGUgc3BlY2lmaWVkIGB0b0luZGV4YCAoZXhjbHVzaXZlKSB0byB0aGUgY29tcGxlbWVudFxyXG5cdCAqIG9mIGl0cyBjdXJyZW50IHZhbHVlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGZyb21JbmRleCBpbmRleCBvZiB0aGUgZmlyc3QgYml0IHRvIGZsaXBcclxuXHQgKiBAcGFyYW0gdG9JbmRleCBpbmRleCBhZnRlciB0aGUgbGFzdCBiaXQgdG8gZmxpcFxyXG5cdCAqXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBvciBgdG9JbmRleGAgaXMgbmVnYXRpdmUsIG9yIGBmcm9tSW5kZXhgIGlzIGxhcmdlciB0aGFuIGB0b0luZGV4YFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBmbGlwKGZyb21JbmRleDogbnVtYmVyLCB0b0luZGV4OiBudW1iZXIpOiB2b2lkO1xyXG5cdHB1YmxpYyBmbGlwKGZyb21JbmRleDogbnVtYmVyLCB0b0luZGV4PzogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodG9JbmRleCA9PSBudWxsKSB7XHJcblx0XHRcdHRvSW5kZXggPSBmcm9tSW5kZXg7XHJcblx0XHR9XHJcblx0XHRpZiAoZnJvbUluZGV4IDwgMCB8fCB0b0luZGV4IDwgZnJvbUluZGV4KSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHdvcmQgPSBnZXRJbmRleChmcm9tSW5kZXgpO1xyXG5cdFx0Y29uc3QgbGFzdFdvcmQgPSBnZXRJbmRleCh0b0luZGV4KTtcclxuXHJcblx0XHRpZiAod29yZCA9PT0gbGFzdFdvcmQpIHtcclxuXHRcdFx0dGhpcy5kYXRhW3dvcmRdIF49IGJpdHNGb3IoZnJvbUluZGV4LCB0b0luZGV4KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuZGF0YVt3b3JkKytdIF49IGJpdHNGb3IoZnJvbUluZGV4LCAxNSk7XHJcblx0XHRcdHdoaWxlICh3b3JkIDwgbGFzdFdvcmQpIHtcclxuXHRcdFx0XHR0aGlzLmRhdGFbd29yZCsrXSBePSAweEZGRkY7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5kYXRhW3dvcmQrK10gXj0gYml0c0ZvcigwLCB0b0luZGV4KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBiaXQgd2l0aCB0aGUgc3BlY2lmaWVkIGluZGV4LiBUaGUgdmFsdWUgaXMgYHRydWVgIGlmIHRoZSBiaXQgd2l0aCB0aGUgaW5kZXggYGJpdEluZGV4YFxyXG5cdCAqIGlzIGN1cnJlbnRseSBzZXQgaW4gdGhpcyBgQml0U2V0YDsgb3RoZXJ3aXNlLCB0aGUgcmVzdWx0IGlzIGBmYWxzZWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gYml0SW5kZXggdGhlIGJpdCBpbmRleFxyXG5cdCAqXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgbmVnYXRpdmVcclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0KGJpdEluZGV4OiBudW1iZXIpOiBib29sZWFuO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbmV3IGBCaXRTZXRgIGNvbXBvc2VkIG9mIGJpdHMgZnJvbSB0aGlzIGBCaXRTZXRgIGZyb20gYGZyb21JbmRleGAgKGluY2x1c2l2ZSkgdG8gYHRvSW5kZXhgIChleGNsdXNpdmUpLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGZyb21JbmRleCBpbmRleCBvZiB0aGUgZmlyc3QgYml0IHRvIGluY2x1ZGVcclxuXHQgKiBAcGFyYW0gdG9JbmRleCBpbmRleCBhZnRlciB0aGUgbGFzdCBiaXQgdG8gaW5jbHVkZVxyXG5cdCAqXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBvciBgdG9JbmRleGAgaXMgbmVnYXRpdmUsIG9yIGBmcm9tSW5kZXhgIGlzIGxhcmdlciB0aGFuIGB0b0luZGV4YFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXQoZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg6IG51bWJlcik6IEJpdFNldDtcclxuXHRwdWJsaWMgZ2V0KGZyb21JbmRleDogbnVtYmVyLCB0b0luZGV4PzogbnVtYmVyKTogYm9vbGVhbiB8IEJpdFNldCB7XHJcblx0XHRpZiAodG9JbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiAhISh0aGlzLmRhdGFbZ2V0SW5kZXgoZnJvbUluZGV4KV0gJiBiaXRzRm9yKGZyb21JbmRleCwgZnJvbUluZGV4KSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyByZXR1cm4gYSBCaXRTZXRcclxuXHRcdFx0bGV0IHJlc3VsdCA9IG5ldyBCaXRTZXQodG9JbmRleCArIDEpO1xyXG5cdFx0XHRmb3IgKGxldCBpID0gZnJvbUluZGV4OyBpIDw9IHRvSW5kZXg7IGkrKykge1xyXG5cdFx0XHRcdHJlc3VsdC5zZXQoaSwgdGhpcy5nZXQoaSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBgQml0U2V0YCBoYXMgYW55IGJpdHMgc2V0IHRvIGB0cnVlYCB0aGF0IGFyZSBhbHNvIHNldCB0byBgdHJ1ZWAgaW4gdGhpcyBgQml0U2V0YC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBzZXQgYEJpdFNldGAgdG8gaW50ZXJzZWN0IHdpdGhcclxuXHQgKi9cclxuXHRwdWJsaWMgaW50ZXJzZWN0cyhzZXQ6IEJpdFNldCk6IGJvb2xlYW4ge1xyXG5cdFx0bGV0IHNtYWxsZXJMZW5ndGggPSBNYXRoLm1pbih0aGlzLmxlbmd0aCgpLCBzZXQubGVuZ3RoKCkpO1xyXG5cdFx0aWYgKHNtYWxsZXJMZW5ndGggPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBib3VuZCA9IGdldEluZGV4KHNtYWxsZXJMZW5ndGggLSAxKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IGJvdW5kOyBpKyspIHtcclxuXHRcdFx0aWYgKCh0aGlzLmRhdGFbaV0gJiBzZXQuZGF0YVtpXSkgIT09IDApIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBCaXRTZXRgIGNvbnRhaW5zIG5vIGJpdHMgdGhhdCBhcmUgc2V0IHRvIGB0cnVlYC5cclxuXHQgKi9cclxuXHRnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmxlbmd0aCgpID09PSAwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgXCJsb2dpY2FsIHNpemVcIiBvZiB0aGlzIGBCaXRTZXRgOiB0aGUgaW5kZXggb2YgdGhlIGhpZ2hlc3Qgc2V0IGJpdCBpbiB0aGUgYEJpdFNldGAgcGx1cyBvbmUuIFJldHVybnNcclxuXHQgKiB6ZXJvIGlmIHRoZSBgQml0U2V0YCBjb250YWlucyBubyBzZXQgYml0cy5cclxuXHQgKi9cclxuXHRwdWJsaWMgbGVuZ3RoKCk6IG51bWJlciB7XHJcblx0XHRpZiAoIXRoaXMuZGF0YS5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5wcmV2aW91c1NldEJpdCh1bkluZGV4KHRoaXMuZGF0YS5sZW5ndGgpIC0gMSkgKyAxO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGJpdCB0aGF0IGlzIHNldCB0byBgZmFsc2VgIHRoYXQgb2NjdXJzIG9uIG9yIGFmdGVyIHRoZSBzcGVjaWZpZWQgc3RhcnRpbmcgaW5kZXgsXHJcblx0ICogSWYgbm8gc3VjaCBiaXQgZXhpc3RzIHRoZW4gYC0xYCBpcyByZXR1cm5lZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBmcm9tSW5kZXggdGhlIGluZGV4IHRvIHN0YXJ0IGNoZWNraW5nIGZyb20gKGluY2x1c2l2ZSlcclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiB0aGUgc3BlY2lmaWVkIGluZGV4IGlzIG5lZ2F0aXZlXHJcblx0ICovXHJcblx0cHVibGljIG5leHRDbGVhckJpdChmcm9tSW5kZXg6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRpZiAoZnJvbUluZGV4IDwgMCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImZyb21JbmRleCBjYW5ub3QgYmUgbmVnYXRpdmVcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG5cdFx0bGV0IHdvcmQgPSBnZXRJbmRleChmcm9tSW5kZXgpO1xyXG5cdFx0aWYgKHdvcmQgPiBsZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBpZ25vcmUgPSAweEZGRkYgXiBiaXRzRm9yKGZyb21JbmRleCwgMTUpO1xyXG5cclxuXHRcdGlmICgoZGF0YVt3b3JkXSB8IGlnbm9yZSkgPT09IDB4RkZGRikge1xyXG5cdFx0XHR3b3JkKys7XHJcblx0XHRcdGlnbm9yZSA9IDA7XHJcblx0XHRcdGZvciAoOyB3b3JkIDwgbGVuZ3RoOyB3b3JkKyspIHtcclxuXHRcdFx0XHRpZiAoZGF0YVt3b3JkXSAhPT0gMHhGRkZGKSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHdvcmQgPT09IGxlbmd0aCkge1xyXG5cdFx0XHRcdC8vIEhpdCB0aGUgZW5kXHJcblx0XHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdW5JbmRleCh3b3JkKSArIGZpbmRMU0JTZXQoKGRhdGFbd29yZF0gfCBpZ25vcmUpIF4gMHhGRkZGKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBiaXQgdGhhdCBpcyBzZXQgdG8gYHRydWVgIHRoYXQgb2NjdXJzIG9uIG9yIGFmdGVyIHRoZSBzcGVjaWZpZWQgc3RhcnRpbmcgaW5kZXguXHJcblx0ICogSWYgbm8gc3VjaCBiaXQgZXhpc3RzIHRoZW4gYC0xYCBpcyByZXR1cm5lZC5cclxuXHQgKlxyXG5cdCAqIFRvIGl0ZXJhdGUgb3ZlciB0aGUgYHRydWVgIGJpdHMgaW4gYSBgQml0U2V0YCwgdXNlIHRoZSBmb2xsb3dpbmcgbG9vcDpcclxuXHQgKlxyXG5cdCAqIGBgYFxyXG5cdCAqIGZvciAobGV0IGkgPSBicy5uZXh0U2V0Qml0KDApOyBpID49IDA7IGkgPSBicy5uZXh0U2V0Qml0KGkgKyAxKSkge1xyXG5cdCAqICAgLy8gb3BlcmF0ZSBvbiBpbmRleCBpIGhlcmVcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gZnJvbUluZGV4IHRoZSBpbmRleCB0byBzdGFydCBjaGVja2luZyBmcm9tIChpbmNsdXNpdmUpXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgdGhlIHNwZWNpZmllZCBpbmRleCBpcyBuZWdhdGl2ZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBuZXh0U2V0Qml0KGZyb21JbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGlmIChmcm9tSW5kZXggPCAwKSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiZnJvbUluZGV4IGNhbm5vdCBiZSBuZWdhdGl2ZVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0Y29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcblx0XHRsZXQgd29yZCA9IGdldEluZGV4KGZyb21JbmRleCk7XHJcblx0XHRpZiAod29yZCA+IGxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9XHJcblx0XHRsZXQgbWFzayA9IGJpdHNGb3IoZnJvbUluZGV4LCAxNSk7XHJcblxyXG5cdFx0aWYgKChkYXRhW3dvcmRdICYgbWFzaykgPT09IDApIHtcclxuXHRcdFx0d29yZCsrO1xyXG5cdFx0XHRtYXNrID0gMHhGRkZGO1xyXG5cdFx0XHRmb3IgKDsgd29yZCA8IGxlbmd0aDsgd29yZCsrKSB7XHJcblx0XHRcdFx0aWYgKGRhdGFbd29yZF0gIT09IDApIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAod29yZCA+PSBsZW5ndGgpIHtcclxuXHRcdFx0XHRyZXR1cm4gLTE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB1bkluZGV4KHdvcmQpICsgZmluZExTQlNldChkYXRhW3dvcmRdICYgbWFzayk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBQZXJmb3JtcyBhIGxvZ2ljYWwgKipPUioqIG9mIHRoaXMgYml0IHNldCB3aXRoIHRoZSBiaXQgc2V0IGFyZ3VtZW50LiBUaGlzIGJpdCBzZXQgaXMgbW9kaWZpZWQgc28gdGhhdCBhIGJpdCBpbiBpdFxyXG5cdCAqIGhhcyB0aGUgdmFsdWUgYHRydWVgIGlmIGFuZCBvbmx5IGlmIGl0IGVpdGhlciBhbHJlYWR5IGhhZCB0aGUgdmFsdWUgYHRydWVgIG9yIHRoZSBjb3JyZXNwb25kaW5nIGJpdCBpbiB0aGUgYml0XHJcblx0ICogc2V0IGFyZ3VtZW50IGhhcyB0aGUgdmFsdWUgYHRydWVgLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBvcihzZXQ6IEJpdFNldCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdGNvbnN0IG90aGVyID0gc2V0LmRhdGE7XHJcblx0XHRjb25zdCBtaW5Xb3JkcyA9IE1hdGgubWluKGRhdGEubGVuZ3RoLCBvdGhlci5sZW5ndGgpO1xyXG5cdFx0Y29uc3Qgd29yZHMgPSBNYXRoLm1heChkYXRhLmxlbmd0aCwgb3RoZXIubGVuZ3RoKTtcclxuXHRcdGNvbnN0IGRlc3QgPSBkYXRhLmxlbmd0aCA9PT0gd29yZHMgPyBkYXRhIDogbmV3IFVpbnQxNkFycmF5KHdvcmRzKTtcclxuXHJcblx0XHRsZXQgbGFzdFdvcmQgPSAtMTtcclxuXHJcblx0XHQvLyBPciB0aG9zZSB3b3JkcyBib3RoIHNldHMgaGF2ZSBpbiBjb21tb25cclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG1pbldvcmRzOyBpKyspIHtcclxuXHRcdFx0bGV0IHZhbHVlID0gZGVzdFtpXSA9IGRhdGFbaV0gfCBvdGhlcltpXTtcclxuXHRcdFx0aWYgKHZhbHVlICE9PSAwKSB7XHJcblx0XHRcdFx0bGFzdFdvcmQgPSBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ29weSB3b3JkcyBmcm9tIGxhcmdlciBzZXQgKGlmIHRoZXJlIGlzIG9uZSlcclxuXHJcblx0XHRjb25zdCBsb25nZXIgPSBkYXRhLmxlbmd0aCA+IG90aGVyLmxlbmd0aCA/IGRhdGEgOiBvdGhlcjtcclxuXHRcdGZvciAobGV0IGkgPSBtaW5Xb3JkczsgaSA8IHdvcmRzOyBpKyspIHtcclxuXHRcdFx0bGV0IHZhbHVlID0gZGVzdFtpXSA9IGxvbmdlcltpXTtcclxuXHRcdFx0aWYgKHZhbHVlICE9PSAwKSB7XHJcblx0XHRcdFx0bGFzdFdvcmQgPSBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhc3RXb3JkID09PSAtMSkge1xyXG5cdFx0XHR0aGlzLmRhdGEgPSBFTVBUWV9EQVRBO1xyXG5cdFx0fSBlbHNlIGlmIChkZXN0Lmxlbmd0aCA9PT0gbGFzdFdvcmQgKyAxKSB7XHJcblx0XHRcdHRoaXMuZGF0YSA9IGRlc3Q7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmRhdGEgPSBkZXN0LnNsaWNlKDAsIGxhc3RXb3JkKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBuZWFyZXN0IGJpdCB0aGF0IGlzIHNldCB0byBgZmFsc2VgIHRoYXQgb2NjdXJzIG9uIG9yIGJlZm9yZSB0aGUgc3BlY2lmaWVkIHN0YXJ0aW5nXHJcblx0ICogaW5kZXguIElmIG5vIHN1Y2ggYml0IGV4aXN0cywgb3IgaWYgYC0xYCBpcyBnaXZlbiBhcyB0aGUgc3RhcnRpbmcgaW5kZXgsIHRoZW4gYC0xYCBpcyByZXR1cm5lZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBmcm9tSW5kZXggdGhlIGluZGV4IHRvIHN0YXJ0IGNoZWNraW5nIGZyb20gKGluY2x1c2l2ZSlcclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiB0aGUgc3BlY2lmaWVkIGluZGV4IGlzIGxlc3MgdGhhbiBgLTFgXHJcblx0ICovXHJcblx0cHVibGljIHByZXZpb3VzQ2xlYXJCaXQoZnJvbUluZGV4OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0aWYgKGZyb21JbmRleCA8IDApIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJmcm9tSW5kZXggY2Fubm90IGJlIG5lZ2F0aXZlXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuXHRcdGxldCB3b3JkID0gZ2V0SW5kZXgoZnJvbUluZGV4KTtcclxuXHRcdGlmICh3b3JkID49IGxlbmd0aCkge1xyXG5cdFx0XHR3b3JkID0gbGVuZ3RoIC0gMTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgaWdub3JlID0gMHhGRkZGIF4gYml0c0ZvcigwLCBmcm9tSW5kZXgpO1xyXG5cclxuXHRcdGlmICgoZGF0YVt3b3JkXSB8IGlnbm9yZSkgPT09IDB4RkZGRikge1xyXG5cdFx0XHRpZ25vcmUgPSAwO1xyXG5cdFx0XHR3b3JkLS07XHJcblx0XHRcdGZvciAoOyB3b3JkID49IDA7IHdvcmQtLSkge1xyXG5cdFx0XHRcdGlmIChkYXRhW3dvcmRdICE9PSAweEZGRkYpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAod29yZCA8IDApIHtcclxuXHRcdFx0XHQvLyBIaXQgdGhlIGVuZFxyXG5cdFx0XHRcdHJldHVybiAtMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHVuSW5kZXgod29yZCkgKyBmaW5kTVNCU2V0KChkYXRhW3dvcmRdIHwgaWdub3JlKSBeIDB4RkZGRik7XHJcblx0fVxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG5lYXJlc3QgYml0IHRoYXQgaXMgc2V0IHRvIGB0cnVlYCB0aGF0IG9jY3VycyBvbiBvciBiZWZvcmUgdGhlIHNwZWNpZmllZCBzdGFydGluZyBpbmRleC5cclxuXHQgKiBJZiBubyBzdWNoIGJpdCBleGlzdHMsIG9yIGlmIGAtMWAgaXMgZ2l2ZW4gYXMgdGhlIHN0YXJ0aW5nIGluZGV4LCB0aGVuIGAtMWAgaXMgcmV0dXJuZWQuXHJcblx0ICpcclxuXHQgKiBUbyBpdGVyYXRlIG92ZXIgdGhlIGB0cnVlYCBiaXRzIGluIGEgYEJpdFNldGAsIHVzZSB0aGUgZm9sbG93aW5nIGxvb3A6XHJcblx0ICpcclxuXHQgKiBgYGBcclxuXHQgKiBmb3IgKGxldCBpID0gYnMubGVuZ3RoKCk7IChpID0gYnMucHJldmlvdXNTZXRCaXQoaS0xKSkgPj0gMDsgKSB7XHJcblx0ICogICAvLyBvcGVyYXRlIG9uIGluZGV4IGkgaGVyZVxyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBmcm9tSW5kZXggdGhlIGluZGV4IHRvIHN0YXJ0IGNoZWNraW5nIGZyb20gKGluY2x1c2l2ZSlcclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiB0aGUgc3BlY2lmaWVkIGluZGV4IGlzIGxlc3MgdGhhbiBgLTFgXHJcblx0ICovXHJcblx0cHVibGljIHByZXZpb3VzU2V0Qml0KGZyb21JbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGlmIChmcm9tSW5kZXggPCAwKSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiZnJvbUluZGV4IGNhbm5vdCBiZSBuZWdhdGl2ZVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0Y29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcblx0XHRsZXQgd29yZCA9IGdldEluZGV4KGZyb21JbmRleCk7XHJcblx0XHRpZiAod29yZCA+PSBsZW5ndGgpIHtcclxuXHRcdFx0d29yZCA9IGxlbmd0aCAtIDE7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG1hc2sgPSBiaXRzRm9yKDAsIGZyb21JbmRleCk7XHJcblxyXG5cdFx0aWYgKChkYXRhW3dvcmRdICYgbWFzaykgPT09IDApIHtcclxuXHRcdFx0d29yZC0tO1xyXG5cdFx0XHRtYXNrID0gMHhGRkZGO1xyXG5cdFx0XHRmb3IgKDsgd29yZCA+PSAwOyB3b3JkLS0pIHtcclxuXHRcdFx0XHRpZiAoZGF0YVt3b3JkXSAhPT0gMCkge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh3b3JkIDwgMCkge1xyXG5cdFx0XHRcdHJldHVybiAtMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHVuSW5kZXgod29yZCkgKyBmaW5kTVNCU2V0KGRhdGFbd29yZF0gJiBtYXNrKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGJpdCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHRvIGB0cnVlYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBiaXRJbmRleCBhIGJpdCBpbmRleFxyXG5cdCAqXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgbmVnYXRpdmVcclxuXHQgKi9cclxuXHRwdWJsaWMgc2V0KGJpdEluZGV4OiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBiaXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGJpdEluZGV4IGEgYml0IGluZGV4XHJcblx0ICogQHBhcmFtIHZhbHVlIGEgYm9vbGVhbiB2YWx1ZSB0byBzZXRcclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiB0aGUgc3BlY2lmaWVkIGluZGV4IGlzIG5lZ2F0aXZlXHJcblx0ICovXHJcblx0cHVibGljIHNldChiaXRJbmRleDogbnVtYmVyLCB2YWx1ZTogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIGBmcm9tSW5kZXhgIChpbmNsdXNpdmUpIHRvIHRoZSBzcGVjaWZpZWQgYHRvSW5kZXhgIChleGNsdXNpdmUpIHRvIGB0cnVlYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBmcm9tSW5kZXggaW5kZXggb2YgdGhlIGZpcnN0IGJpdCB0byBiZSBzZXRcclxuXHQgKiBAcGFyYW0gdG9JbmRleCBpbmRleCBhZnRlciB0aGUgbGFzdCBiaXQgdG8gYmUgc2V0XHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIG9yIGB0b0luZGV4YCBpcyBuZWdhdGl2ZSwgb3IgYGZyb21JbmRleGAgaXMgbGFyZ2VyIHRoYW4gYHRvSW5kZXhgXHJcblx0ICovXHJcblx0cHVibGljIHNldChmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgYGZyb21JbmRleGAgKGluY2x1c2l2ZSkgdG8gdGhlIHNwZWNpZmllZCBgdG9JbmRleGAgKGV4Y2x1c2l2ZSkgdG8gdGhlIHNwZWNpZmllZFxyXG5cdCAqIHZhbHVlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGZyb21JbmRleCBpbmRleCBvZiB0aGUgZmlyc3QgYml0IHRvIGJlIHNldFxyXG5cdCAqIEBwYXJhbSB0b0luZGV4IGluZGV4IGFmdGVyIHRoZSBsYXN0IGJpdCB0byBiZSBzZXRcclxuXHQgKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gc2V0IHRoZSBzZWxlY3RlZCBiaXRzIHRvXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIG9yIGB0b0luZGV4YCBpcyBuZWdhdGl2ZSwgb3IgYGZyb21JbmRleGAgaXMgbGFyZ2VyIHRoYW4gYHRvSW5kZXhgXHJcblx0ICovXHJcblx0cHVibGljIHNldChmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyLCB2YWx1ZTogYm9vbGVhbik6IHZvaWQ7XHJcblx0cHVibGljIHNldChmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleD86IGJvb2xlYW4gfCBudW1iZXIsIHZhbHVlPzogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0aWYgKHRvSW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0b0luZGV4ID0gZnJvbUluZGV4O1xyXG5cdFx0XHR2YWx1ZSA9IHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0b0luZGV4ID09PSBcImJvb2xlYW5cIikge1xyXG5cdFx0XHR2YWx1ZSA9IHRvSW5kZXg7XHJcblx0XHRcdHRvSW5kZXggPSBmcm9tSW5kZXg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dmFsdWUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChmcm9tSW5kZXggPCAwIHx8IGZyb21JbmRleCA+IHRvSW5kZXgpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgd29yZCA9IGdldEluZGV4KGZyb21JbmRleCk7XHJcblx0XHRsZXQgbGFzdFdvcmQgPSBnZXRJbmRleCh0b0luZGV4KTtcclxuXHJcblx0XHRpZiAodmFsdWUgJiYgbGFzdFdvcmQgPj0gdGhpcy5kYXRhLmxlbmd0aCkge1xyXG5cdFx0XHQvLyBHcm93IGFycmF5IFwianVzdCBlbm91Z2hcIiBmb3IgYml0cyB3ZSBuZWVkIHRvIHNldFxyXG5cdFx0XHRsZXQgdGVtcCA9IG5ldyBVaW50MTZBcnJheShsYXN0V29yZCArIDEpO1xyXG5cdFx0XHR0aGlzLmRhdGEuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB0ZW1wW2luZGV4XSA9IHZhbHVlKTtcclxuXHRcdFx0dGhpcy5kYXRhID0gdGVtcDtcclxuXHRcdH0gZWxzZSBpZiAoIXZhbHVlKSB7XHJcblx0XHRcdC8vIEJ1dCB0aGVyZSBpcyBubyBuZWVkIHRvIGdyb3cgYXJyYXkgdG8gY2xlYXIgYml0cy5cclxuXHRcdFx0aWYgKHdvcmQgPj0gdGhpcy5kYXRhLmxlbmd0aCkge1xyXG5cdFx0XHRcdC8vIEVhcmx5IGV4aXRcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGxhc3RXb3JkID49IHRoaXMuZGF0YS5sZW5ndGgpIHtcclxuXHRcdFx0XHQvLyBBZGp1c3Qgd29yayB0byBmaXQgYXJyYXlcclxuXHRcdFx0XHRsYXN0V29yZCA9IHRoaXMuZGF0YS5sZW5ndGggLSAxO1xyXG5cdFx0XHRcdHRvSW5kZXggPSB0aGlzLmRhdGEubGVuZ3RoICogMTYgLSAxO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHdvcmQgPT09IGxhc3RXb3JkKSB7XHJcblx0XHRcdHRoaXMuX3NldEJpdHMod29yZCwgdmFsdWUsIGJpdHNGb3IoZnJvbUluZGV4LCB0b0luZGV4KSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9zZXRCaXRzKHdvcmQrKywgdmFsdWUsIGJpdHNGb3IoZnJvbUluZGV4LCAxNSkpO1xyXG5cdFx0XHR3aGlsZSAod29yZCA8IGxhc3RXb3JkKSB7XHJcblx0XHRcdFx0dGhpcy5kYXRhW3dvcmQrK10gPSB2YWx1ZSA/IDB4RkZGRiA6IDA7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fc2V0Qml0cyh3b3JkLCB2YWx1ZSwgYml0c0ZvcigwLCB0b0luZGV4KSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIF9zZXRCaXRzKHdvcmQ6IG51bWJlciwgdmFsdWU6IGJvb2xlYW4sIG1hc2s6IG51bWJlcikge1xyXG5cdFx0aWYgKHZhbHVlKSB7XHJcblx0XHRcdHRoaXMuZGF0YVt3b3JkXSB8PSBtYXNrO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5kYXRhW3dvcmRdICY9IDB4RkZGRiBeIG1hc2s7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYml0cyBvZiBzcGFjZSBhY3R1YWxseSBpbiB1c2UgYnkgdGhpcyBgQml0U2V0YCB0byByZXByZXNlbnQgYml0IHZhbHVlcy4gVGhlIG1heGltdW0gZWxlbWVudFxyXG5cdCAqIGluIHRoZSBzZXQgaXMgdGhlIHNpemUgLSAxc3QgZWxlbWVudC5cclxuXHQgKi9cclxuXHRnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5ieXRlTGVuZ3RoICogODtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBuZXcgYnl0ZSBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgYml0cyBpbiB0aGlzIGJpdCBzZXQuXHJcblx0ICpcclxuXHQgKiBNb3JlIHByZWNpc2VseSwgaWZcclxuXHQgKiBgbGV0IGJ5dGVzID0gcy50b0J5dGVBcnJheSgpO2BcclxuXHQgKiB0aGVuIGBieXRlcy5sZW5ndGggPT09IChzLmxlbmd0aCgpKzcpLzhgIGFuZCBgcy5nZXQobikgPT09ICgoYnl0ZXNbbi84XSAmICgxPDwobiU4KSkpICE9IDApYCBmb3IgYWxsXHJcblx0ICogYG4gPCA4ICogYnl0ZXMubGVuZ3RoYC5cclxuXHQgKi9cclxuXHQvLyB0b0J5dGVBcnJheSgpOiBJbnQ4QXJyYXkge1xyXG5cdC8vIFx0dGhyb3cgbmV3IEVycm9yKFwiTk9UIElNUExFTUVOVEVEXCIpO1xyXG5cdC8vIH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIG5ldyBpbnRlZ2VyIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBiaXRzIGluIHRoaXMgYml0IHNldC5cclxuXHQgKlxyXG5cdCAqIE1vcmUgcHJlY2lzZWx5LCBpZlxyXG5cdCAqIGBsZXQgaW50ZWdlcnMgPSBzLnRvSW50ZWdlckFycmF5KCk7YFxyXG5cdCAqIHRoZW4gYGludGVnZXJzLmxlbmd0aCA9PT0gKHMubGVuZ3RoKCkrMzEpLzMyYCBhbmQgYHMuZ2V0KG4pID09PSAoKGludGVnZXJzW24vMzJdICYgKDE8PChuJTMyKSkpICE9IDApYCBmb3IgYWxsXHJcblx0ICogYG4gPCAzMiAqIGludGVnZXJzLmxlbmd0aGAuXHJcblx0ICovXHJcblx0Ly8gdG9JbnRlZ2VyQXJyYXkoKTogSW50MzJBcnJheSB7XHJcblx0Ly8gXHR0aHJvdyBuZXcgRXJyb3IoXCJOT1QgSU1QTEVNRU5URURcIik7XHJcblx0Ly8gfVxyXG5cclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBNdXJtdXJIYXNoLmhhc2hDb2RlKHRoaXMuZGF0YSwgMjIpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29tcGFyZXMgdGhpcyBvYmplY3QgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIG9iamVjdC4gVGhlIHJlc3VsdCBpcyBgdHJ1ZWAgaWYgYW5kIG9ubHkgaWYgdGhlIGFyZ3VtZW50IGlzIG5vdFxyXG5cdCAqIGB1bmRlZmluZWRgIGFuZCBpcyBhIGBCaXRzZXRgIG9iamVjdCB0aGF0IGhhcyBleGFjdGx5IHRoZSBzYW1lIHNldCBvZiBiaXRzIHNldCB0byBgdHJ1ZWAgYXMgdGhpcyBiaXQgc2V0LiBUaGF0XHJcblx0ICogaXMsIGZvciBldmVyeSBub25uZWdhdGl2ZSBpbmRleCBga2AsXHJcblx0ICpcclxuXHQgKiBgYGBcclxuXHQgKiAoKEJpdFNldClvYmopLmdldChrKSA9PSB0aGlzLmdldChrKVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogbXVzdCBiZSB0cnVlLiBUaGUgY3VycmVudCBzaXplcyBvZiB0aGUgdHdvIGJpdCBzZXRzIGFyZSBub3QgY29tcGFyZWQuXHJcblx0ICovXHJcblx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG9iaiA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAoIShvYmogaW5zdGFuY2VvZiBCaXRTZXQpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBsZW4gPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdGlmIChsZW4gIT09IG9iai5sZW5ndGgoKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxlbiA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYm91bmQgPSBnZXRJbmRleChsZW4gLSAxKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IGJvdW5kOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuZGF0YVtpXSAhPT0gb2JqLmRhdGFbaV0pIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBiaXQgc2V0LiBGb3IgZXZlcnkgaW5kZXggZm9yIHdoaWNoIHRoaXMgYEJpdFNldGAgY29udGFpbnMgYSBiaXQgaW4gdGhlXHJcblx0ICogc2V0IHN0YXRlLCB0aGUgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGF0IGluZGV4IGlzIGluY2x1ZGVkIGluIHRoZSByZXN1bHQuIFN1Y2ggaW5kaWNlcyBhcmUgbGlzdGVkIGluIG9yZGVyXHJcblx0ICogZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCwgc2VwYXJhdGVkIGJ5IFwiLCBcIiAoYSBjb21tYSBhbmQgYSBzcGFjZSkgYW5kIHN1cnJvdW5kZWQgYnkgYnJhY2VzLCByZXN1bHRpbmcgaW4gdGhlIHVzdWFsXHJcblx0ICogbWF0aGVtYXRpY2FsIG5vdGF0aW9uIGZvciBhIHNldCBvZiBpbnRlZ2Vycy5cclxuXHQgKlxyXG5cdCAqIEV4YW1wbGU6XHJcblx0ICpcclxuXHQgKiAgICAgQml0U2V0IGRyUGVwcGVyID0gbmV3IEJpdFNldCgpO1xyXG5cdCAqXHJcblx0ICogTm93IGBkclBlcHBlci50b1N0cmluZygpYCByZXR1cm5zIGBcInt9XCJgLlxyXG5cdCAqXHJcblx0ICogICAgIGRyUGVwcGVyLnNldCgyKTtcclxuXHQgKlxyXG5cdCAqIE5vdyBgZHJQZXBwZXIudG9TdHJpbmcoKWAgcmV0dXJucyBgXCJ7Mn1cImAuXHJcblx0ICpcclxuXHQgKiAgICAgZHJQZXBwZXIuc2V0KDQpO1xyXG5cdCAqICAgICBkclBlcHBlci5zZXQoMTApO1xyXG5cdCAqXHJcblx0ICogTm93IGBkclBlcHBlci50b1N0cmluZygpYCByZXR1cm5zIGBcInsyLCA0LCAxMH1cImAuXHJcblx0ICovXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRsZXQgcmVzdWx0ID0gXCJ7XCI7XHJcblxyXG5cdFx0bGV0IGZpcnN0ID0gdHJ1ZTtcclxuXHRcdGZvciAobGV0IGkgPSB0aGlzLm5leHRTZXRCaXQoMCk7IGkgPj0gMDsgaSA9IHRoaXMubmV4dFNldEJpdChpICsgMSkpIHtcclxuXHRcdFx0aWYgKGZpcnN0KSB7XHJcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQgKz0gXCIsIFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXN1bHQgKz0gaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXN1bHQgKz0gXCJ9XCI7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0Ly8gc3RhdGljIHZhbHVlT2YoYnl0ZXM6IEludDhBcnJheSk6IEJpdFNldDtcclxuXHQvLyBzdGF0aWMgdmFsdWVPZihidWZmZXI6IEFycmF5QnVmZmVyKTogQml0U2V0O1xyXG5cdC8vIHN0YXRpYyB2YWx1ZU9mKGludGVnZXJzOiBJbnQzMkFycmF5KTogQml0U2V0O1xyXG5cdC8vIHN0YXRpYyB2YWx1ZU9mKGRhdGE6IEludDhBcnJheSB8IEludDMyQXJyYXkgfCBBcnJheUJ1ZmZlcik6IEJpdFNldCB7XHJcblx0Ly8gXHR0aHJvdyBuZXcgRXJyb3IoXCJOT1QgSU1QTEVNRU5URURcIik7XHJcblx0Ly8gfVxyXG5cclxuXHQvKipcclxuXHQgKiBQZXJmb3JtcyBhIGxvZ2ljYWwgKipYT1IqKiBvZiB0aGlzIGJpdCBzZXQgd2l0aCB0aGUgYml0IHNldCBhcmd1bWVudC4gVGhpcyBiaXQgc2V0IGlzIG1vZGlmaWVkIHNvIHRoYXQgYSBiaXQgaW5cclxuXHQgKiBpdCBoYXMgdGhlIHZhbHVlIGB0cnVlYCBpZiBhbmQgb25seSBpZiBvbmUgb2YgdGhlIGZvbGxvd2luZyBzdGF0ZW1lbnRzIGhvbGRzOlxyXG5cdCAqXHJcblx0ICogKiBUaGUgYml0IGluaXRpYWxseSBoYXMgdGhlIHZhbHVlIGB0cnVlYCwgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGJpdCBpbiB0aGUgYXJndW1lbnQgaGFzIHRoZSB2YWx1ZSBgZmFsc2VgLlxyXG5cdCAqICogVGhlIGJpdCBpbml0aWFsbHkgaGFzIHRoZSB2YWx1ZSBgZmFsc2VgLCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgYml0IGluIHRoZSBhcmd1bWVudCBoYXMgdGhlIHZhbHVlIGB0cnVlYC5cclxuXHQgKi9cclxuXHRwdWJsaWMgeG9yKHNldDogQml0U2V0KTogdm9pZCB7XHJcblx0XHRjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0Y29uc3Qgb3RoZXIgPSBzZXQuZGF0YTtcclxuXHRcdGNvbnN0IG1pbldvcmRzID0gTWF0aC5taW4oZGF0YS5sZW5ndGgsIG90aGVyLmxlbmd0aCk7XHJcblx0XHRjb25zdCB3b3JkcyA9IE1hdGgubWF4KGRhdGEubGVuZ3RoLCBvdGhlci5sZW5ndGgpO1xyXG5cdFx0Y29uc3QgZGVzdCA9IGRhdGEubGVuZ3RoID09PSB3b3JkcyA/IGRhdGEgOiBuZXcgVWludDE2QXJyYXkod29yZHMpO1xyXG5cclxuXHRcdGxldCBsYXN0V29yZCA9IC0xO1xyXG5cclxuXHRcdC8vIFhvciB0aG9zZSB3b3JkcyBib3RoIHNldHMgaGF2ZSBpbiBjb21tb25cclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG1pbldvcmRzOyBpKyspIHtcclxuXHRcdFx0bGV0IHZhbHVlID0gZGVzdFtpXSA9IGRhdGFbaV0gXiBvdGhlcltpXTtcclxuXHRcdFx0aWYgKHZhbHVlICE9PSAwKSB7XHJcblx0XHRcdFx0bGFzdFdvcmQgPSBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ29weSB3b3JkcyBmcm9tIGxhcmdlciBzZXQgKGlmIHRoZXJlIGlzIG9uZSlcclxuXHJcblx0XHRjb25zdCBsb25nZXIgPSBkYXRhLmxlbmd0aCA+IG90aGVyLmxlbmd0aCA/IGRhdGEgOiBvdGhlcjtcclxuXHRcdGZvciAobGV0IGkgPSBtaW5Xb3JkczsgaSA8IHdvcmRzOyBpKyspIHtcclxuXHRcdFx0bGV0IHZhbHVlID0gZGVzdFtpXSA9IGxvbmdlcltpXTtcclxuXHRcdFx0aWYgKHZhbHVlICE9PSAwKSB7XHJcblx0XHRcdFx0bGFzdFdvcmQgPSBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhc3RXb3JkID09PSAtMSkge1xyXG5cdFx0XHR0aGlzLmRhdGEgPSBFTVBUWV9EQVRBO1xyXG5cdFx0fSBlbHNlIGlmIChkZXN0Lmxlbmd0aCA9PT0gbGFzdFdvcmQgKyAxKSB7XHJcblx0XHRcdHRoaXMuZGF0YSA9IGRlc3Q7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmRhdGEgPSBkZXN0LnNsaWNlKDAsIGxhc3RXb3JkICsgMSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY2xvbmUoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEJpdFNldCh0aGlzKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYWJsZUl0ZXJhdG9yPG51bWJlcj4ge1xyXG5cdFx0cmV0dXJuIG5ldyBCaXRTZXRJdGVyYXRvcih0aGlzLmRhdGEpO1xyXG5cdH1cclxuXHJcblx0Ly8gT3ZlcnJpZGVzIGZvcm1hdHRpbmcgZm9yIG5vZGVqcyBhc3NlcnQgZXRjLlxyXG5cdHB1YmxpYyBbKHV0aWwuaW5zcGVjdCBhcyBhbnkpLmN1c3RvbV0oKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIkJpdFNldCBcIiArIHRoaXMudG9TdHJpbmcoKTtcclxuXHR9XHJcbn1cclxuXHJcbmNsYXNzIEJpdFNldEl0ZXJhdG9yIGltcGxlbWVudHMgSXRlcmFibGVJdGVyYXRvcjxudW1iZXI+e1xyXG5cdHByaXZhdGUgaW5kZXggPSAwO1xyXG5cdHByaXZhdGUgbWFzayA9IDB4RkZGRjtcclxuXHJcblx0Y29uc3RydWN0b3IocHJpdmF0ZSBkYXRhOiBVaW50MTZBcnJheSkgeyB9XHJcblxyXG5cdHB1YmxpYyBuZXh0KCkge1xyXG5cdFx0d2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoKSB7XHJcblx0XHRcdGNvbnN0IGJpdHMgPSB0aGlzLmRhdGFbdGhpcy5pbmRleF0gJiB0aGlzLm1hc2s7XHJcblx0XHRcdGlmIChiaXRzICE9PSAwKSB7XHJcblx0XHRcdFx0Y29uc3QgYml0TnVtYmVyID0gdW5JbmRleCh0aGlzLmluZGV4KSArIGZpbmRMU0JTZXQoYml0cyk7XHJcblx0XHRcdFx0dGhpcy5tYXNrID0gYml0c0ZvcihiaXROdW1iZXIgKyAxLCAxNSk7XHJcblx0XHRcdFx0cmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBiaXROdW1iZXIgfTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmluZGV4Kys7XHJcblx0XHRcdHRoaXMubWFzayA9IDB4RkZGRjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiAtMSB9O1xyXG5cdH1cclxuXHJcblx0cHVibGljIFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8bnVtYmVyPiB7IHJldHVybiB0aGlzOyB9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI1LjU0ODgwMTMtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFycmF5MkRIYXNoTWFwIH0gZnJvbSBcIi4uL21pc2MvQXJyYXkyREhhc2hNYXBcIjtcclxuaW1wb3J0IHsgQXJyYXkyREhhc2hTZXQgfSBmcm9tIFwiLi4vbWlzYy9BcnJheTJESGFzaFNldFwiO1xyXG5pbXBvcnQgeyBBcnJheUVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuLi9taXNjL0FycmF5RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5Db25maWcgfSBmcm9tIFwiLi9BVE5Db25maWdcIjtcclxuaW1wb3J0IHsgQVROU2ltdWxhdG9yIH0gZnJvbSBcIi4vQVROU2ltdWxhdG9yXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQml0U2V0IH0gZnJvbSBcIi4uL21pc2MvQml0U2V0XCI7XHJcbmltcG9ydCB7IENvbmZsaWN0SW5mbyB9IGZyb20gXCIuL0NvbmZsaWN0SW5mb1wiO1xyXG5pbXBvcnQgeyBFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi4vbWlzYy9FcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgSmF2YVNldCB9IGZyb20gXCIuLi9taXNjL1N0dWJzXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IFByZWRpY3Rpb25Db250ZXh0IH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRcIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbkNvbnRleHRDYWNoZSB9IGZyb20gXCIuL1ByZWRpY3Rpb25Db250ZXh0Q2FjaGVcIjtcclxuaW1wb3J0IHsgU2VtYW50aWNDb250ZXh0IH0gZnJvbSBcIi4vU2VtYW50aWNDb250ZXh0XCI7XHJcblxyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiLi4vbWlzYy9VdGlsc1wiO1xyXG5cclxuaW50ZXJmYWNlIEtleVR5cGUgeyBzdGF0ZTogbnVtYmVyOyBhbHQ6IG51bWJlcjsgfVxyXG5cclxuY2xhc3MgS2V5VHlwZUVxdWFsaXR5Q29tcGFyZXIgaW1wbGVtZW50cyBFcXVhbGl0eUNvbXBhcmF0b3I8S2V5VHlwZT4ge1xyXG5cdHB1YmxpYyBoYXNoQ29kZShrZXk6IEtleVR5cGUpIHtcclxuXHRcdHJldHVybiBrZXkuc3RhdGUgXiBrZXkuYWx0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIGVxdWFscyhhOiBLZXlUeXBlLCBiOiBLZXlUeXBlKSB7XHJcblx0XHRyZXR1cm4gYS5zdGF0ZSA9PT0gYi5zdGF0ZSAmJiBhLmFsdCA9PT0gYi5hbHQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IElOU1RBTkNFID0gbmV3IEtleVR5cGVFcXVhbGl0eUNvbXBhcmVyKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE5ld0tleWVkQ29uZmlnTWFwKG1hcD86IEFycmF5MkRIYXNoTWFwPEtleVR5cGUsIEFUTkNvbmZpZz4pIHtcclxuXHRpZiAobWFwKSB7XHJcblx0XHRyZXR1cm4gbmV3IEFycmF5MkRIYXNoTWFwPEtleVR5cGUsIEFUTkNvbmZpZz4obWFwKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIG5ldyBBcnJheTJESGFzaE1hcDxLZXlUeXBlLCBBVE5Db25maWc+KEtleVR5cGVFcXVhbGl0eUNvbXBhcmVyLklOU1RBTkNFKTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc2V0IG9mIEFUTiBjb25maWd1cmF0aW9ucyAoc2VlIGBBVE5Db25maWdgKS4gQXMgY29uZmlndXJhdGlvbnMgYXJlIGFkZGVkIHRvIHRoZSBzZXQsIHRoZXkgYXJlIG1lcmdlZFxyXG4gKiB3aXRoIG90aGVyIGBBVE5Db25maWdgIGluc3RhbmNlcyBhbHJlYWR5IGluIHRoZSBzZXQgd2hlbiBwb3NzaWJsZSB1c2luZyB0aGUgZ3JhcGgtc3RydWN0dXJlZCBzdGFjay5cclxuICpcclxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBjb21wbGV0ZSBzZXQgb2YgcG9zaXRpb25zICh3aXRoIGNvbnRleHQpIGluIGFuIEFUTiB3aGljaCB3b3VsZCBiZSBhc3NvY2lhdGVkXHJcbiAqIHdpdGggYSBzaW5nbGUgREZBIHN0YXRlLiBJdHMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gaXMgbW9yZSBjb21wbGV4IHRoYW4gdHJhZGl0aW9uYWwgc3RhdGUgdXNlZCBmb3IgTkZBIHRvIERGQVxyXG4gKiBjb252ZXJzaW9uIGR1ZSB0byBwZXJmb3JtYW5jZSByZXF1aXJlbWVudHMgKGJvdGggaW1wcm92aW5nIHNwZWVkIGFuZCByZWR1Y2luZyBtZW1vcnkgb3ZlcmhlYWQpIGFzIHdlbGwgYXMgc3VwcG9ydGluZ1xyXG4gKiBmZWF0dXJlcyBzdWNoIGFzIHNlbWFudGljIHByZWRpY2F0ZXMgYW5kIG5vbi1ncmVlZHkgb3BlcmF0b3JzIGluIGEgZm9ybSB0byBzdXBwb3J0IEFOVExSJ3MgcHJlZGljdGlvbiBhbGdvcml0aG0uXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBVE5Db25maWdTZXQgaW1wbGVtZW50cyBKYXZhU2V0PEFUTkNvbmZpZz4ge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWFwcyAoc3RhdGUsIGFsdCkgLT4gbWVyZ2VkIHtAbGluayBBVE5Db25maWd9LiBUaGUga2V5IGRvZXMgbm90IGFjY291bnQgZm9yXHJcblx0ICogdGhlIHtAbGluayBBVE5Db25maWcjZ2V0U2VtYW50aWNDb250ZXh0fSBvZiB0aGUgdmFsdWUsIHdoaWNoIGlzIG9ubHkgYSBwcm9ibGVtIGlmIGEgc2luZ2xlXHJcblx0ICogYEFUTkNvbmZpZ1NldGAgY29udGFpbnMgdHdvIGNvbmZpZ3Mgd2l0aCB0aGUgc2FtZSBzdGF0ZSBhbmQgYWx0ZXJuYXRpdmVcclxuXHQgKiBidXQgZGlmZmVyZW50IHNlbWFudGljIGNvbnRleHRzLiBXaGVuIHRoaXMgY2FzZSBhcmlzZXMsIHRoZSBmaXJzdCBjb25maWdcclxuXHQgKiBhZGRlZCB0byB0aGlzIG1hcCBzdGF5cywgYW5kIHRoZSByZW1haW5pbmcgY29uZmlncyBhcmUgcGxhY2VkIGluIHtAbGluayAjdW5tZXJnZWR9LlxyXG5cdCAqXHJcblx0ICogVGhpcyBtYXAgaXMgb25seSB1c2VkIGZvciBvcHRpbWl6aW5nIHRoZSBwcm9jZXNzIG9mIGFkZGluZyBjb25maWdzIHRvIHRoZSBzZXQsXHJcblx0ICogYW5kIGlzIGB1bmRlZmluZWRgIGZvciByZWFkLW9ubHkgc2V0cyBzdG9yZWQgaW4gdGhlIERGQS5cclxuXHQgKi9cclxuXHRwcml2YXRlIG1lcmdlZENvbmZpZ3M/OiBBcnJheTJESGFzaE1hcDxLZXlUeXBlLCBBVE5Db25maWc+O1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIGFuIFwib3ZlcmZsb3dcIiBsaXN0IGhvbGRpbmcgY29uZmlncyB3aGljaCBjYW5ub3QgYmUgbWVyZ2VkIHdpdGggb25lXHJcblx0ICogb2YgdGhlIGNvbmZpZ3MgaW4ge0BsaW5rICNtZXJnZWRDb25maWdzfSBidXQgaGF2ZSBhIGNvbGxpZGluZyBrZXkuIFRoaXNcclxuXHQgKiBvY2N1cnMgd2hlbiB0d28gY29uZmlncyBpbiB0aGUgc2V0IGhhdmUgdGhlIHNhbWUgc3RhdGUgYW5kIGFsdGVybmF0aXZlIGJ1dFxyXG5cdCAqIGRpZmZlcmVudCBzZW1hbnRpYyBjb250ZXh0cy5cclxuXHQgKlxyXG5cdCAqIFRoaXMgbGlzdCBpcyBvbmx5IHVzZWQgZm9yIG9wdGltaXppbmcgdGhlIHByb2Nlc3Mgb2YgYWRkaW5nIGNvbmZpZ3MgdG8gdGhlIHNldCxcclxuXHQgKiBhbmQgaXMgYHVuZGVmaW5lZGAgZm9yIHJlYWQtb25seSBzZXRzIHN0b3JlZCBpbiB0aGUgREZBLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgdW5tZXJnZWQ/OiBBVE5Db25maWdbXTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIGNvbmZpZ3MgaW4gdGhpcyBzZXQuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBjb25maWdzOiBBVE5Db25maWdbXTtcclxuXHJcblx0cHJpdmF0ZSBfdW5pcXVlQWx0OiBudW1iZXIgPSAwO1xyXG5cdHByaXZhdGUgX2NvbmZsaWN0SW5mbz86IENvbmZsaWN0SW5mbztcclxuXHQvLyBVc2VkIGluIHBhcnNlciBhbmQgbGV4ZXIuIEluIGxleGVyLCBpdCBpbmRpY2F0ZXMgd2UgaGl0IGEgcHJlZFxyXG5cdC8vIHdoaWxlIGNvbXB1dGluZyBhIGNsb3N1cmUgb3BlcmF0aW9uLiAgRG9uJ3QgbWFrZSBhIERGQSBzdGF0ZSBmcm9tIHRoaXMuXHJcblx0cHJpdmF0ZSBfaGFzU2VtYW50aWNDb250ZXh0OiBib29sZWFuID0gZmFsc2U7XHJcblx0cHJpdmF0ZSBfZGlwc0ludG9PdXRlckNvbnRleHQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHQvKipcclxuXHQgKiBXaGVuIGB0cnVlYCwgdGhpcyBjb25maWcgc2V0IHJlcHJlc2VudHMgY29uZmlndXJhdGlvbnMgd2hlcmUgdGhlIGVudGlyZVxyXG5cdCAqIG91dGVyIGNvbnRleHQgaGFzIGJlZW4gY29uc3VtZWQgYnkgdGhlIEFUTiBpbnRlcnByZXRlci4gVGhpcyBwcmV2ZW50cyB0aGVcclxuXHQgKiB7QGxpbmsgUGFyc2VyQVROU2ltdWxhdG9yI2Nsb3N1cmV9IGZyb20gcHVyc3VpbmcgdGhlIGdsb2JhbCBGT0xMT1cgd2hlbiBhXHJcblx0ICogcnVsZSBzdG9wIHN0YXRlIGlzIHJlYWNoZWQgd2l0aCBhbiBlbXB0eSBwcmVkaWN0aW9uIGNvbnRleHQuXHJcblx0ICpcclxuXHQgKiBOb3RlOiBgb3V0ZXJtb3N0Q29uZmlnU2V0YCBhbmQge0BsaW5rICNkaXBzSW50b091dGVyQ29udGV4dH0gc2hvdWxkIG5ldmVyXHJcblx0ICogYmUgdHJ1ZSBhdCB0aGUgc2FtZSB0aW1lLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgb3V0ZXJtb3N0Q29uZmlnU2V0OiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdHByaXZhdGUgY2FjaGVkSGFzaENvZGU6IG51bWJlciA9IC0xO1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpO1xyXG5cdGNvbnN0cnVjdG9yKHNldDogQVROQ29uZmlnU2V0LCByZWFkb25seTogYm9vbGVhbik7XHJcblx0Y29uc3RydWN0b3Ioc2V0PzogQVROQ29uZmlnU2V0LCByZWFkb25seT86IGJvb2xlYW4pIHtcclxuXHRcdGlmICghc2V0KSB7XHJcblx0XHRcdHRoaXMubWVyZ2VkQ29uZmlncyA9IE5ld0tleWVkQ29uZmlnTWFwKCk7XHJcblx0XHRcdHRoaXMudW5tZXJnZWQgPSBbXTtcclxuXHRcdFx0dGhpcy5jb25maWdzID0gW107XHJcblxyXG5cdFx0XHR0aGlzLl91bmlxdWVBbHQgPSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmIChyZWFkb25seSkge1xyXG5cdFx0XHRcdHRoaXMubWVyZ2VkQ29uZmlncyA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHR0aGlzLnVubWVyZ2VkID0gdW5kZWZpbmVkO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFzZXQuaXNSZWFkT25seSkge1xyXG5cdFx0XHRcdHRoaXMubWVyZ2VkQ29uZmlncyA9IE5ld0tleWVkQ29uZmlnTWFwKHNldC5tZXJnZWRDb25maWdzKTtcclxuXHRcdFx0XHR0aGlzLnVubWVyZ2VkID0gKHNldC51bm1lcmdlZCBhcyBBVE5Db25maWdbXSkuc2xpY2UoMCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5tZXJnZWRDb25maWdzID0gTmV3S2V5ZWRDb25maWdNYXAoKTtcclxuXHRcdFx0XHR0aGlzLnVubWVyZ2VkID0gW107XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuY29uZmlncyA9IHNldC5jb25maWdzLnNsaWNlKDApO1xyXG5cclxuXHRcdFx0dGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQgPSBzZXQuX2RpcHNJbnRvT3V0ZXJDb250ZXh0O1xyXG5cdFx0XHR0aGlzLl9oYXNTZW1hbnRpY0NvbnRleHQgPSBzZXQuX2hhc1NlbWFudGljQ29udGV4dDtcclxuXHRcdFx0dGhpcy5vdXRlcm1vc3RDb25maWdTZXQgPSBzZXQub3V0ZXJtb3N0Q29uZmlnU2V0O1xyXG5cclxuXHRcdFx0aWYgKHJlYWRvbmx5IHx8ICFzZXQuaXNSZWFkT25seSkge1xyXG5cdFx0XHRcdHRoaXMuX3VuaXF1ZUFsdCA9IHNldC5fdW5pcXVlQWx0O1xyXG5cdFx0XHRcdHRoaXMuX2NvbmZsaWN0SW5mbyA9IHNldC5fY29uZmxpY3RJbmZvO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpZiAoIXJlYWRvbmx5ICYmIHNldC5pc1JlYWRPbmx5KSAtPiBhZGRBbGwgaXMgY2FsbGVkIGZyb20gY2xvbmUoKVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBzZXQgb2YgYWxsIGFsdGVybmF0aXZlcyByZXByZXNlbnRlZCBieSBjb25maWd1cmF0aW9ucyBpbiB0aGlzXHJcblx0ICogc2V0LlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGdldFJlcHJlc2VudGVkQWx0ZXJuYXRpdmVzKCk6IEJpdFNldCB7XHJcblx0XHRpZiAodGhpcy5fY29uZmxpY3RJbmZvICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbmZsaWN0SW5mby5jb25mbGljdGVkQWx0cy5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBhbHRzOiBCaXRTZXQgPSBuZXcgQml0U2V0KCk7XHJcblx0XHRmb3IgKGxldCBjb25maWcgb2YgdGhpcykge1xyXG5cdFx0XHRhbHRzLnNldChjb25maWcuYWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYWx0cztcclxuXHR9XHJcblxyXG5cdGdldCBpc1JlYWRPbmx5KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMubWVyZ2VkQ29uZmlncyA9PSBudWxsO1xyXG5cdH1cclxuXHJcblx0Z2V0IGlzT3V0ZXJtb3N0Q29uZmlnU2V0KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMub3V0ZXJtb3N0Q29uZmlnU2V0O1xyXG5cdH1cclxuXHJcblx0c2V0IGlzT3V0ZXJtb3N0Q29uZmlnU2V0KG91dGVybW9zdENvbmZpZ1NldDogYm9vbGVhbikge1xyXG5cdFx0aWYgKHRoaXMub3V0ZXJtb3N0Q29uZmlnU2V0ICYmICFvdXRlcm1vc3RDb25maWdTZXQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbFN0YXRlRXhjZXB0aW9uXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGFzc2VydCghb3V0ZXJtb3N0Q29uZmlnU2V0IHx8ICF0aGlzLl9kaXBzSW50b091dGVyQ29udGV4dCk7XHJcblx0XHR0aGlzLm91dGVybW9zdENvbmZpZ1NldCA9IG91dGVybW9zdENvbmZpZ1NldDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRTdGF0ZXMoKTogQXJyYXkyREhhc2hTZXQ8QVROU3RhdGU+IHtcclxuXHRcdGxldCBzdGF0ZXMgPSBuZXcgQXJyYXkyREhhc2hTZXQ8QVROU3RhdGU+KE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSk7XHJcblx0XHRmb3IgKGxldCBjIG9mIHRoaXMuY29uZmlncykge1xyXG5cdFx0XHRzdGF0ZXMuYWRkKGMuc3RhdGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdGF0ZXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgb3B0aW1pemVDb25maWdzKGludGVycHJldGVyOiBBVE5TaW11bGF0b3IpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLmNvbmZpZ3MubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBjb25maWcgb2YgdGhpcy5jb25maWdzKSB7XHJcblx0XHRcdGNvbmZpZy5jb250ZXh0ID0gaW50ZXJwcmV0ZXIuYXRuLmdldENhY2hlZENvbnRleHQoY29uZmlnLmNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGNsb25lKHJlYWRvbmx5OiBib29sZWFuKTogQVROQ29uZmlnU2V0IHtcclxuXHRcdGxldCBjb3B5OiBBVE5Db25maWdTZXQgPSBuZXcgQVROQ29uZmlnU2V0KHRoaXMsIHJlYWRvbmx5KTtcclxuXHRcdGlmICghcmVhZG9ubHkgJiYgdGhpcy5pc1JlYWRPbmx5KSB7XHJcblx0XHRcdGNvcHkuYWRkQWxsKHRoaXMuY29uZmlncyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvcHk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlncy5sZW5ndGg7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZ3MubGVuZ3RoID09PSAwO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGNvbnRhaW5zKG86IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKCEobyBpbnN0YW5jZW9mIEFUTkNvbmZpZykpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm1lcmdlZENvbmZpZ3MgJiYgdGhpcy51bm1lcmdlZCkge1xyXG5cdFx0XHRsZXQgY29uZmlnOiBBVE5Db25maWcgPSBvO1xyXG5cdFx0XHRsZXQgY29uZmlnS2V5ID0gdGhpcy5nZXRLZXkoY29uZmlnKTtcclxuXHRcdFx0bGV0IG1lcmdlZENvbmZpZyA9IHRoaXMubWVyZ2VkQ29uZmlncy5nZXQoY29uZmlnS2V5KTtcclxuXHRcdFx0aWYgKG1lcmdlZENvbmZpZyAhPSBudWxsICYmIHRoaXMuY2FuTWVyZ2UoY29uZmlnLCBjb25maWdLZXksIG1lcmdlZENvbmZpZykpIHtcclxuXHRcdFx0XHRyZXR1cm4gbWVyZ2VkQ29uZmlnLmNvbnRhaW5zKGNvbmZpZyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAobGV0IGMgb2YgdGhpcy51bm1lcmdlZCkge1xyXG5cdFx0XHRcdGlmIChjLmNvbnRhaW5zKG8pKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZvciAobGV0IGMgb2YgdGhpcy5jb25maWdzKSB7XHJcblx0XHRcdFx0aWYgKGMuY29udGFpbnMobykpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyAqW1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmFibGVJdGVyYXRvcjxBVE5Db25maWc+IHtcclxuXHRcdHlpZWxkKiB0aGlzLmNvbmZpZ3M7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9BcnJheSgpOiBBVE5Db25maWdbXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWdzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFkZChlOiBBVE5Db25maWcpOiBib29sZWFuO1xyXG5cdHB1YmxpYyBhZGQoZTogQVROQ29uZmlnLCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUgfCB1bmRlZmluZWQpOiBib29sZWFuO1xyXG5cdHB1YmxpYyBhZGQoZTogQVROQ29uZmlnLCBjb250ZXh0Q2FjaGU/OiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogYm9vbGVhbiB7XHJcblx0XHR0aGlzLmVuc3VyZVdyaXRhYmxlKCk7XHJcblx0XHRpZiAoIXRoaXMubWVyZ2VkQ29uZmlncyB8fCAhdGhpcy51bm1lcmdlZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3ZlcmVkIGJ5IGVuc3VyZVdyaXRhYmxlIGJ1dCBkdXBsaWNhdGVkIGhlcmUgZm9yIHN0cmljdCBudWxsIGNoZWNrIGxpbWl0YXRpb25cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0YXNzZXJ0KCF0aGlzLm91dGVybW9zdENvbmZpZ1NldCB8fCAhZS5yZWFjaGVzSW50b091dGVyQ29udGV4dCk7XHJcblxyXG5cdFx0aWYgKGNvbnRleHRDYWNoZSA9PSBudWxsKSB7XHJcblx0XHRcdGNvbnRleHRDYWNoZSA9IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUuVU5DQUNIRUQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGFkZEtleTogYm9vbGVhbjtcclxuXHRcdGxldCBrZXkgPSB0aGlzLmdldEtleShlKTtcclxuXHRcdGxldCBtZXJnZWRDb25maWcgPSB0aGlzLm1lcmdlZENvbmZpZ3MuZ2V0KGtleSk7XHJcblx0XHRhZGRLZXkgPSAobWVyZ2VkQ29uZmlnID09IG51bGwpO1xyXG5cdFx0aWYgKG1lcmdlZENvbmZpZyAhPSBudWxsICYmIHRoaXMuY2FuTWVyZ2UoZSwga2V5LCBtZXJnZWRDb25maWcpKSB7XHJcblx0XHRcdG1lcmdlZENvbmZpZy5vdXRlckNvbnRleHREZXB0aCA9IE1hdGgubWF4KG1lcmdlZENvbmZpZy5vdXRlckNvbnRleHREZXB0aCwgZS5vdXRlckNvbnRleHREZXB0aCk7XHJcblx0XHRcdGlmIChlLmlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQpIHtcclxuXHRcdFx0XHRtZXJnZWRDb25maWcuaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBqb2luZWQ6IFByZWRpY3Rpb25Db250ZXh0ID0gUHJlZGljdGlvbkNvbnRleHQuam9pbihtZXJnZWRDb25maWcuY29udGV4dCwgZS5jb250ZXh0LCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZVByb3BlcnRpZXNGb3JNZXJnZWRDb25maWcoZSk7XHJcblx0XHRcdGlmIChtZXJnZWRDb25maWcuY29udGV4dCA9PT0gam9pbmVkKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtZXJnZWRDb25maWcuY29udGV4dCA9IGpvaW5lZDtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnVubWVyZ2VkLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCB1bm1lcmdlZENvbmZpZzogQVROQ29uZmlnID0gdGhpcy51bm1lcmdlZFtpXTtcclxuXHRcdFx0aWYgKHRoaXMuY2FuTWVyZ2UoZSwga2V5LCB1bm1lcmdlZENvbmZpZykpIHtcclxuXHRcdFx0XHR1bm1lcmdlZENvbmZpZy5vdXRlckNvbnRleHREZXB0aCA9IE1hdGgubWF4KHVubWVyZ2VkQ29uZmlnLm91dGVyQ29udGV4dERlcHRoLCBlLm91dGVyQ29udGV4dERlcHRoKTtcclxuXHRcdFx0XHRpZiAoZS5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkKSB7XHJcblx0XHRcdFx0XHR1bm1lcmdlZENvbmZpZy5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBqb2luZWQ6IFByZWRpY3Rpb25Db250ZXh0ID0gUHJlZGljdGlvbkNvbnRleHQuam9pbih1bm1lcmdlZENvbmZpZy5jb250ZXh0LCBlLmNvbnRleHQsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0dGhpcy51cGRhdGVQcm9wZXJ0aWVzRm9yTWVyZ2VkQ29uZmlnKGUpO1xyXG5cdFx0XHRcdGlmICh1bm1lcmdlZENvbmZpZy5jb250ZXh0ID09PSBqb2luZWQpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHVubWVyZ2VkQ29uZmlnLmNvbnRleHQgPSBqb2luZWQ7XHJcblxyXG5cdFx0XHRcdGlmIChhZGRLZXkpIHtcclxuXHRcdFx0XHRcdHRoaXMubWVyZ2VkQ29uZmlncy5wdXQoa2V5LCB1bm1lcmdlZENvbmZpZyk7XHJcblx0XHRcdFx0XHR0aGlzLnVubWVyZ2VkLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb25maWdzLnB1c2goZSk7XHJcblx0XHRpZiAoYWRkS2V5KSB7XHJcblx0XHRcdHRoaXMubWVyZ2VkQ29uZmlncy5wdXQoa2V5LCBlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMudW5tZXJnZWQucHVzaChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnVwZGF0ZVByb3BlcnRpZXNGb3JBZGRlZENvbmZpZyhlKTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSB1cGRhdGVQcm9wZXJ0aWVzRm9yTWVyZ2VkQ29uZmlnKGNvbmZpZzogQVROQ29uZmlnKTogdm9pZCB7XHJcblx0XHQvLyBtZXJnZWQgY29uZmlncyBjYW4ndCBjaGFuZ2UgdGhlIGFsdCBvciBzZW1hbnRpYyBjb250ZXh0XHJcblx0XHR0aGlzLl9kaXBzSW50b091dGVyQ29udGV4dCA9IHRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0IHx8IGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dDtcclxuXHRcdGFzc2VydCghdGhpcy5vdXRlcm1vc3RDb25maWdTZXQgfHwgIXRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0KTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgdXBkYXRlUHJvcGVydGllc0ZvckFkZGVkQ29uZmlnKGNvbmZpZzogQVROQ29uZmlnKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5jb25maWdzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHR0aGlzLl91bmlxdWVBbHQgPSBjb25maWcuYWx0O1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLl91bmlxdWVBbHQgIT09IGNvbmZpZy5hbHQpIHtcclxuXHRcdFx0dGhpcy5fdW5pcXVlQWx0ID0gQVROLklOVkFMSURfQUxUX05VTUJFUjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYXNTZW1hbnRpY0NvbnRleHQgPSB0aGlzLl9oYXNTZW1hbnRpY0NvbnRleHQgfHwgIVNlbWFudGljQ29udGV4dC5OT05FLmVxdWFscyhjb25maWcuc2VtYW50aWNDb250ZXh0KTtcclxuXHRcdHRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0ID0gdGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQgfHwgY29uZmlnLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0O1xyXG5cdFx0YXNzZXJ0KCF0aGlzLm91dGVybW9zdENvbmZpZ1NldCB8fCAhdGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGNhbk1lcmdlKGxlZnQ6IEFUTkNvbmZpZywgbGVmdEtleTogeyBzdGF0ZTogbnVtYmVyLCBhbHQ6IG51bWJlciB9LCByaWdodDogQVROQ29uZmlnKTogYm9vbGVhbiB7XHJcblx0XHRpZiAobGVmdC5zdGF0ZS5zdGF0ZU51bWJlciAhPT0gcmlnaHQuc3RhdGUuc3RhdGVOdW1iZXIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsZWZ0S2V5LmFsdCAhPT0gcmlnaHQuYWx0KSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGVmdC5zZW1hbnRpY0NvbnRleHQuZXF1YWxzKHJpZ2h0LnNlbWFudGljQ29udGV4dCk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0S2V5KGU6IEFUTkNvbmZpZyk6IHsgc3RhdGU6IG51bWJlciwgYWx0OiBudW1iZXIgfSB7XHJcblx0XHRyZXR1cm4geyBzdGF0ZTogZS5zdGF0ZS5zdGF0ZU51bWJlciwgYWx0OiBlLmFsdCB9O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGNvbnRhaW5zQWxsKGM6IEl0ZXJhYmxlPGFueT4pOiBib29sZWFuIHtcclxuXHRcdGZvciAobGV0IG8gb2YgYykge1xyXG5cdFx0XHRpZiAoIShvIGluc3RhbmNlb2YgQVROQ29uZmlnKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCF0aGlzLmNvbnRhaW5zKG8pKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWRkQWxsKGM6IEl0ZXJhYmxlPEFUTkNvbmZpZz4pOiBib29sZWFuO1xyXG5cdHB1YmxpYyBhZGRBbGwoYzogSXRlcmFibGU8QVROQ29uZmlnPiwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogYm9vbGVhbjtcclxuXHRwdWJsaWMgYWRkQWxsKGM6IEl0ZXJhYmxlPEFUTkNvbmZpZz4sIGNvbnRleHRDYWNoZT86IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBib29sZWFuIHtcclxuXHRcdHRoaXMuZW5zdXJlV3JpdGFibGUoKTtcclxuXHJcblx0XHRsZXQgY2hhbmdlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdFx0Zm9yIChsZXQgZ3JvdXAgb2YgYykge1xyXG5cdFx0XHRpZiAodGhpcy5hZGQoZ3JvdXAsIGNvbnRleHRDYWNoZSkpIHtcclxuXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjaGFuZ2VkO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGNsZWFyKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5lbnN1cmVXcml0YWJsZSgpO1xyXG5cdFx0aWYgKCF0aGlzLm1lcmdlZENvbmZpZ3MgfHwgIXRoaXMudW5tZXJnZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ292ZXJlZCBieSBlbnN1cmVXcml0YWJsZSBidXQgZHVwbGljYXRlZCBoZXJlIGZvciBzdHJpY3QgbnVsbCBjaGVjayBsaW1pdGF0aW9uXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubWVyZ2VkQ29uZmlncy5jbGVhcigpO1xyXG5cdFx0dGhpcy51bm1lcmdlZC5sZW5ndGggPSAwO1xyXG5cdFx0dGhpcy5jb25maWdzLmxlbmd0aCA9IDA7XHJcblxyXG5cdFx0dGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX2hhc1NlbWFudGljQ29udGV4dCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdW5pcXVlQWx0ID0gQVROLklOVkFMSURfQUxUX05VTUJFUjtcclxuXHRcdHRoaXMuX2NvbmZsaWN0SW5mbyA9IHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzID09PSBvYmopIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCEob2JqIGluc3RhbmNlb2YgQVROQ29uZmlnU2V0KSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub3V0ZXJtb3N0Q29uZmlnU2V0ID09PSBvYmoub3V0ZXJtb3N0Q29uZmlnU2V0XHJcblx0XHRcdCYmIFV0aWxzLmVxdWFscyh0aGlzLl9jb25mbGljdEluZm8sIG9iai5fY29uZmxpY3RJbmZvKVxyXG5cdFx0XHQmJiBBcnJheUVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRS5lcXVhbHModGhpcy5jb25maWdzLCBvYmouY29uZmlncyk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGlmICh0aGlzLmlzUmVhZE9ubHkgJiYgdGhpcy5jYWNoZWRIYXNoQ29kZSAhPT0gLTEpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVkSGFzaENvZGU7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGhhc2hDb2RlOiBudW1iZXIgPSAxO1xyXG5cdFx0aGFzaENvZGUgPSA1ICogaGFzaENvZGUgXiAodGhpcy5vdXRlcm1vc3RDb25maWdTZXQgPyAxIDogMCk7XHJcblx0XHRoYXNoQ29kZSA9IDUgKiBoYXNoQ29kZSBeIEFycmF5RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFLmhhc2hDb2RlKHRoaXMuY29uZmlncyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuaXNSZWFkT25seSkge1xyXG5cdFx0XHR0aGlzLmNhY2hlZEhhc2hDb2RlID0gaGFzaENvZGU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGhhc2hDb2RlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZztcclxuXHRwdWJsaWMgdG9TdHJpbmcoc2hvd0NvbnRleHQ6IGJvb2xlYW4pOiBzdHJpbmc7XHJcblx0cHVibGljIHRvU3RyaW5nKHNob3dDb250ZXh0PzogYm9vbGVhbik6IHN0cmluZyB7XHJcblx0XHRpZiAoc2hvd0NvbnRleHQgPT0gbnVsbCkge1xyXG5cdFx0XHRzaG93Q29udGV4dCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBidWYgPSBcIlwiO1xyXG5cdFx0bGV0IHNvcnRlZENvbmZpZ3MgPSB0aGlzLmNvbmZpZ3Muc2xpY2UoMCk7XHJcblx0XHRzb3J0ZWRDb25maWdzLnNvcnQoKG8xLCBvMikgPT4ge1xyXG5cdFx0XHRpZiAobzEuYWx0ICE9PSBvMi5hbHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gbzEuYWx0IC0gbzIuYWx0O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKG8xLnN0YXRlLnN0YXRlTnVtYmVyICE9PSBvMi5zdGF0ZS5zdGF0ZU51bWJlcikge1xyXG5cdFx0XHRcdHJldHVybiBvMS5zdGF0ZS5zdGF0ZU51bWJlciAtIG8yLnN0YXRlLnN0YXRlTnVtYmVyO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBvMS5zZW1hbnRpY0NvbnRleHQudG9TdHJpbmcoKS5sb2NhbGVDb21wYXJlKG8yLnNlbWFudGljQ29udGV4dC50b1N0cmluZygpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0YnVmICs9IChcIltcIik7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZENvbmZpZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKGkgPiAwKSB7XHJcblx0XHRcdFx0YnVmICs9IChcIiwgXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJ1ZiArPSAoc29ydGVkQ29uZmlnc1tpXS50b1N0cmluZyh1bmRlZmluZWQsIHRydWUsIHNob3dDb250ZXh0KSk7XHJcblx0XHR9XHJcblx0XHRidWYgKz0gKFwiXVwiKTtcclxuXHJcblx0XHRpZiAodGhpcy5faGFzU2VtYW50aWNDb250ZXh0KSB7XHJcblx0XHRcdGJ1ZiArPSAoXCIsaGFzU2VtYW50aWNDb250ZXh0PVwiKSArICh0aGlzLl9oYXNTZW1hbnRpY0NvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3VuaXF1ZUFsdCAhPT0gQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG5cdFx0XHRidWYgKz0gKFwiLHVuaXF1ZUFsdD1cIikgKyAodGhpcy5fdW5pcXVlQWx0KTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9jb25mbGljdEluZm8gIT0gbnVsbCkge1xyXG5cdFx0XHRidWYgKz0gKFwiLGNvbmZsaWN0aW5nQWx0cz1cIikgKyAodGhpcy5fY29uZmxpY3RJbmZvLmNvbmZsaWN0ZWRBbHRzKTtcclxuXHRcdFx0aWYgKCF0aGlzLl9jb25mbGljdEluZm8uaXNFeGFjdCkge1xyXG5cdFx0XHRcdGJ1ZiArPSAoXCIqXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQpIHtcclxuXHRcdFx0YnVmICs9IChcIixkaXBzSW50b091dGVyQ29udGV4dFwiKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBidWYudG9TdHJpbmcoKTtcclxuXHR9XHJcblxyXG5cdGdldCB1bmlxdWVBbHQoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl91bmlxdWVBbHQ7XHJcblx0fVxyXG5cclxuXHRnZXQgaGFzU2VtYW50aWNDb250ZXh0KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2hhc1NlbWFudGljQ29udGV4dDtcclxuXHR9XHJcblxyXG5cdHNldCBoYXNTZW1hbnRpY0NvbnRleHQodmFsdWU6IGJvb2xlYW4pIHtcclxuXHRcdHRoaXMuZW5zdXJlV3JpdGFibGUoKTtcclxuXHRcdHRoaXMuX2hhc1NlbWFudGljQ29udGV4dCA9IHZhbHVlO1xyXG5cdH1cclxuXHJcblx0Z2V0IGNvbmZsaWN0SW5mbygpOiBDb25mbGljdEluZm8gfCB1bmRlZmluZWQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbmZsaWN0SW5mbztcclxuXHR9XHJcblxyXG5cdHNldCBjb25mbGljdEluZm8oY29uZmxpY3RJbmZvOiBDb25mbGljdEluZm8gfCB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuZW5zdXJlV3JpdGFibGUoKTtcclxuXHRcdHRoaXMuX2NvbmZsaWN0SW5mbyA9IGNvbmZsaWN0SW5mbztcclxuXHR9XHJcblxyXG5cdGdldCBjb25mbGljdGluZ0FsdHMoKTogQml0U2V0IHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICh0aGlzLl9jb25mbGljdEluZm8gPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb25mbGljdEluZm8uY29uZmxpY3RlZEFsdHM7XHJcblx0fVxyXG5cclxuXHRnZXQgaXNFeGFjdENvbmZsaWN0KCk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKHRoaXMuX2NvbmZsaWN0SW5mbyA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29uZmxpY3RJbmZvLmlzRXhhY3Q7XHJcblx0fVxyXG5cclxuXHRnZXQgZGlwc0ludG9PdXRlckNvbnRleHQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0KGluZGV4OiBudW1iZXIpOiBBVE5Db25maWcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnc1tpbmRleF07XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZW5zdXJlV3JpdGFibGUoKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5pc1JlYWRPbmx5KSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRoaXMgQVROQ29uZmlnU2V0IGlzIHJlYWQgb25seS5cIik7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozOC43NzcxMDU2LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBY2NlcHRTdGF0ZUluZm8gfSBmcm9tIFwiLi9BY2NlcHRTdGF0ZUluZm9cIjtcclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4uL2F0bi9BVE5cIjtcclxuaW1wb3J0IHsgQVROQ29uZmlnU2V0IH0gZnJvbSBcIi4uL2F0bi9BVE5Db25maWdTZXRcIjtcclxuaW1wb3J0IHsgQml0U2V0IH0gZnJvbSBcIi4uL21pc2MvQml0U2V0XCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uRXhlY3V0b3IgfSBmcm9tIFwiLi4vYXRuL0xleGVyQWN0aW9uRXhlY3V0b3JcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuLi9taXNjL011cm11ckhhc2hcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uQ29udGV4dCB9IGZyb20gXCIuLi9hdG4vUHJlZGljdGlvbkNvbnRleHRcIjtcclxuaW1wb3J0IHsgU2VtYW50aWNDb250ZXh0IH0gZnJvbSBcIi4uL2F0bi9TZW1hbnRpY0NvbnRleHRcIjtcclxuXHJcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XHJcblxyXG4vKiogQSBERkEgc3RhdGUgcmVwcmVzZW50cyBhIHNldCBvZiBwb3NzaWJsZSBBVE4gY29uZmlndXJhdGlvbnMuXHJcbiAqICBBcyBBaG8sIFNldGhpLCBVbGxtYW4gcC4gMTE3IHNheXMgXCJUaGUgREZBIHVzZXMgaXRzIHN0YXRlXHJcbiAqICB0byBrZWVwIHRyYWNrIG9mIGFsbCBwb3NzaWJsZSBzdGF0ZXMgdGhlIEFUTiBjYW4gYmUgaW4gYWZ0ZXJcclxuICogIHJlYWRpbmcgZWFjaCBpbnB1dCBzeW1ib2wuICBUaGF0IGlzIHRvIHNheSwgYWZ0ZXIgcmVhZGluZ1xyXG4gKiAgaW5wdXQgYTFhMi4uYW4sIHRoZSBERkEgaXMgaW4gYSBzdGF0ZSB0aGF0IHJlcHJlc2VudHMgdGhlXHJcbiAqICBzdWJzZXQgVCBvZiB0aGUgc3RhdGVzIG9mIHRoZSBBVE4gdGhhdCBhcmUgcmVhY2hhYmxlIGZyb20gdGhlXHJcbiAqICBBVE4ncyBzdGFydCBzdGF0ZSBhbG9uZyBzb21lIHBhdGggbGFiZWxlZCBhMWEyLi5hbi5cIlxyXG4gKiAgSW4gY29udmVudGlvbmFsIE5GQSZyYXJyO0RGQSBjb252ZXJzaW9uLCB0aGVyZWZvcmUsIHRoZSBzdWJzZXQgVFxyXG4gKiAgd291bGQgYmUgYSBiaXRzZXQgcmVwcmVzZW50aW5nIHRoZSBzZXQgb2Ygc3RhdGVzIHRoZVxyXG4gKiAgQVROIGNvdWxkIGJlIGluLiAgV2UgbmVlZCB0byB0cmFjayB0aGUgYWx0IHByZWRpY3RlZCBieSBlYWNoXHJcbiAqICBzdGF0ZSBhcyB3ZWxsLCBob3dldmVyLiAgTW9yZSBpbXBvcnRhbnRseSwgd2UgbmVlZCB0byBtYWludGFpblxyXG4gKiAgYSBzdGFjayBvZiBzdGF0ZXMsIHRyYWNraW5nIHRoZSBjbG9zdXJlIG9wZXJhdGlvbnMgYXMgdGhleVxyXG4gKiAganVtcCBmcm9tIHJ1bGUgdG8gcnVsZSwgZW11bGF0aW5nIHJ1bGUgaW52b2NhdGlvbnMgKG1ldGhvZCBjYWxscykuXHJcbiAqICBJIGhhdmUgdG8gYWRkIGEgc3RhY2sgdG8gc2ltdWxhdGUgdGhlIHByb3BlciBsb29rYWhlYWQgc2VxdWVuY2VzIGZvclxyXG4gKiAgdGhlIHVuZGVybHlpbmcgTEwgZ3JhbW1hciBmcm9tIHdoaWNoIHRoZSBBVE4gd2FzIGRlcml2ZWQuXHJcbiAqXHJcbiAqICBJIHVzZSBhIHNldCBvZiBBVE5Db25maWcgb2JqZWN0cyBub3Qgc2ltcGxlIHN0YXRlcy4gIEFuIEFUTkNvbmZpZ1xyXG4gKiAgaXMgYm90aCBhIHN0YXRlIChhbGEgbm9ybWFsIGNvbnZlcnNpb24pIGFuZCBhIFJ1bGVDb250ZXh0IGRlc2NyaWJpbmdcclxuICogIHRoZSBjaGFpbiBvZiBydWxlcyAoaWYgYW55KSBmb2xsb3dlZCB0byBhcnJpdmUgYXQgdGhhdCBzdGF0ZS5cclxuICpcclxuICogIEEgREZBIHN0YXRlIG1heSBoYXZlIG11bHRpcGxlIHJlZmVyZW5jZXMgdG8gYSBwYXJ0aWN1bGFyIHN0YXRlLFxyXG4gKiAgYnV0IHdpdGggZGlmZmVyZW50IEFUTiBjb250ZXh0cyAod2l0aCBzYW1lIG9yIGRpZmZlcmVudCBhbHRzKVxyXG4gKiAgbWVhbmluZyB0aGF0IHN0YXRlIHdhcyByZWFjaGVkIHZpYSBhIGRpZmZlcmVudCBzZXQgb2YgcnVsZSBpbnZvY2F0aW9ucy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBERkFTdGF0ZSB7XHJcblx0cHVibGljIHN0YXRlTnVtYmVyOiBudW1iZXIgPSAtMTtcclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgY29uZmlnczogQVROQ29uZmlnU2V0O1xyXG5cclxuXHQvKiogYGVkZ2VzLmdldChzeW1ib2wpYCBwb2ludHMgdG8gdGFyZ2V0IG9mIHN5bWJvbC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgcmVhZG9ubHkgZWRnZXM6IE1hcDxudW1iZXIsIERGQVN0YXRlPjtcclxuXHJcblx0cHJpdmF0ZSBfYWNjZXB0U3RhdGVJbmZvOiBBY2NlcHRTdGF0ZUluZm8gfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKiBUaGVzZSBrZXlzIGZvciB0aGVzZSBlZGdlcyBhcmUgdGhlIHRvcCBsZXZlbCBlbGVtZW50IG9mIHRoZSBnbG9iYWwgY29udGV4dC4gKi9cclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgcmVhZG9ubHkgY29udGV4dEVkZ2VzOiBNYXA8bnVtYmVyLCBERkFTdGF0ZT47XHJcblxyXG5cdC8qKiBTeW1ib2xzIGluIHRoaXMgc2V0IHJlcXVpcmUgYSBnbG9iYWwgY29udGV4dCB0cmFuc2l0aW9uIGJlZm9yZSBtYXRjaGluZyBhbiBpbnB1dCBzeW1ib2wuICovXHJcblx0cHJpdmF0ZSBjb250ZXh0U3ltYm9sczogQml0U2V0IHwgdW5kZWZpbmVkO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGxpc3QgaXMgY29tcHV0ZWQgYnkge0BsaW5rIFBhcnNlckFUTlNpbXVsYXRvciNwcmVkaWNhdGVERkFTdGF0ZX0uXHJcblx0ICovXHJcblx0cHVibGljIHByZWRpY2F0ZXM6IERGQVN0YXRlLlByZWRQcmVkaWN0aW9uW10gfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYERGQVN0YXRlYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBjb25maWdzIFRoZSBzZXQgb2YgQVROIGNvbmZpZ3VyYXRpb25zIGRlZmluaW5nIHRoaXMgc3RhdGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoY29uZmlnczogQVROQ29uZmlnU2V0KSB7XHJcblx0XHR0aGlzLmNvbmZpZ3MgPSBjb25maWdzO1xyXG5cdFx0dGhpcy5lZGdlcyA9IG5ldyBNYXA8bnVtYmVyLCBERkFTdGF0ZT4oKTtcclxuXHRcdHRoaXMuY29udGV4dEVkZ2VzID0gbmV3IE1hcDxudW1iZXIsIERGQVN0YXRlPigpO1xyXG5cdH1cclxuXHJcblx0Z2V0IGlzQ29udGV4dFNlbnNpdGl2ZSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAhIXRoaXMuY29udGV4dFN5bWJvbHM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaXNDb250ZXh0U3ltYm9sKHN5bWJvbDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRpZiAoIXRoaXMuaXNDb250ZXh0U2Vuc2l0aXZlKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0U3ltYm9scyEuZ2V0KHN5bWJvbCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0Q29udGV4dFN5bWJvbChzeW1ib2w6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0YXNzZXJ0KHRoaXMuaXNDb250ZXh0U2Vuc2l0aXZlKTtcclxuXHRcdHRoaXMuY29udGV4dFN5bWJvbHMhLnNldChzeW1ib2wpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldENvbnRleHRTZW5zaXRpdmUoYXRuOiBBVE4pOiB2b2lkIHtcclxuXHRcdGFzc2VydCghdGhpcy5jb25maWdzLmlzT3V0ZXJtb3N0Q29uZmlnU2V0KTtcclxuXHRcdGlmICh0aGlzLmlzQ29udGV4dFNlbnNpdGl2ZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLmNvbnRleHRTeW1ib2xzKSB7XHJcblx0XHRcdHRoaXMuY29udGV4dFN5bWJvbHMgPSBuZXcgQml0U2V0KCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXQgYWNjZXB0U3RhdGVJbmZvKCk6IEFjY2VwdFN0YXRlSW5mbyB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYWNjZXB0U3RhdGVJbmZvO1xyXG5cdH1cclxuXHJcblx0c2V0IGFjY2VwdFN0YXRlSW5mbyhhY2NlcHRTdGF0ZUluZm86IEFjY2VwdFN0YXRlSW5mbyB8IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5fYWNjZXB0U3RhdGVJbmZvID0gYWNjZXB0U3RhdGVJbmZvO1xyXG5cdH1cclxuXHJcblx0Z2V0IGlzQWNjZXB0U3RhdGUoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9hY2NlcHRTdGF0ZUluZm87XHJcblx0fVxyXG5cclxuXHRnZXQgcHJlZGljdGlvbigpOiBudW1iZXIge1xyXG5cdFx0aWYgKCF0aGlzLl9hY2NlcHRTdGF0ZUluZm8pIHtcclxuXHRcdFx0cmV0dXJuIEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2FjY2VwdFN0YXRlSW5mby5wcmVkaWN0aW9uO1xyXG5cdH1cclxuXHJcblx0Z2V0IGxleGVyQWN0aW9uRXhlY3V0b3IoKTogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAoIXRoaXMuX2FjY2VwdFN0YXRlSW5mbykge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9hY2NlcHRTdGF0ZUluZm8ubGV4ZXJBY3Rpb25FeGVjdXRvcjtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRUYXJnZXQoc3ltYm9sOiBudW1iZXIpOiBERkFTdGF0ZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5lZGdlcy5nZXQoc3ltYm9sKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXRUYXJnZXQoc3ltYm9sOiBudW1iZXIsIHRhcmdldDogREZBU3RhdGUpOiB2b2lkIHtcclxuXHRcdHRoaXMuZWRnZXMuc2V0KHN5bWJvbCwgdGFyZ2V0KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRFZGdlTWFwKCk6IE1hcDxudW1iZXIsIERGQVN0YXRlPiB7XHJcblx0XHRyZXR1cm4gdGhpcy5lZGdlcztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRDb250ZXh0VGFyZ2V0KGludm9raW5nU3RhdGU6IG51bWJlcik6IERGQVN0YXRlIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmIChpbnZva2luZ1N0YXRlID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSkge1xyXG5cdFx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dEVkZ2VzLmdldChpbnZva2luZ1N0YXRlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXRDb250ZXh0VGFyZ2V0KGludm9raW5nU3RhdGU6IG51bWJlciwgdGFyZ2V0OiBERkFTdGF0ZSk6IHZvaWQge1xyXG5cdFx0aWYgKCF0aGlzLmlzQ29udGV4dFNlbnNpdGl2ZSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RhdGUgaXMgbm90IGNvbnRleHQgc2Vuc2l0aXZlLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaW52b2tpbmdTdGF0ZSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVkpIHtcclxuXHRcdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29udGV4dEVkZ2VzLnNldChpbnZva2luZ1N0YXRlLCB0YXJnZXQpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldENvbnRleHRFZGdlTWFwKCk6IE1hcDxudW1iZXIsIERGQVN0YXRlPiB7XHJcblx0XHRsZXQgbWFwID0gbmV3IE1hcDxudW1iZXIsIERGQVN0YXRlPih0aGlzLmNvbnRleHRFZGdlcyk7XHJcblx0XHRsZXQgZXhpc3RpbmcgPSBtYXAuZ2V0KC0xKTtcclxuXHRcdGlmIChleGlzdGluZyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGlmIChtYXAuc2l6ZSA9PT0gMSkge1xyXG5cdFx0XHRcdGxldCByZXN1bHQgPSBuZXcgTWFwPG51bWJlciwgREZBU3RhdGU+KCk7XHJcblx0XHRcdFx0cmVzdWx0LnNldChQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSwgZXhpc3RpbmcpO1xyXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0bWFwLmRlbGV0ZSgtMSk7XHJcblx0XHRcdFx0bWFwLnNldChQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSwgZXhpc3RpbmcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hcDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IGhhc2g6IG51bWJlciA9IE11cm11ckhhc2guaW5pdGlhbGl6ZSg3KTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmNvbmZpZ3MuaGFzaENvZGUoKSk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC5maW5pc2goaGFzaCwgMSk7XHJcblx0XHRyZXR1cm4gaGFzaDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFR3byB7QGxpbmsgREZBU3RhdGV9IGluc3RhbmNlcyBhcmUgZXF1YWwgaWYgdGhlaXIgQVROIGNvbmZpZ3VyYXRpb24gc2V0c1xyXG5cdCAqIGFyZSB0aGUgc2FtZS4gVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzZWUgaWYgYSBzdGF0ZSBhbHJlYWR5IGV4aXN0cy5cclxuXHQgKlxyXG5cdCAqIEJlY2F1c2UgdGhlIG51bWJlciBvZiBhbHRlcm5hdGl2ZXMgYW5kIG51bWJlciBvZiBBVE4gY29uZmlndXJhdGlvbnMgYXJlXHJcblx0ICogZmluaXRlLCB0aGVyZSBpcyBhIGZpbml0ZSBudW1iZXIgb2YgREZBIHN0YXRlcyB0aGF0IGNhbiBiZSBwcm9jZXNzZWQuXHJcblx0ICogVGhpcyBpcyBuZWNlc3NhcnkgdG8gc2hvdyB0aGF0IHRoZSBhbGdvcml0aG0gdGVybWluYXRlcy5cclxuXHQgKlxyXG5cdCAqIENhbm5vdCB0ZXN0IHRoZSBERkEgc3RhdGUgbnVtYmVycyBoZXJlIGJlY2F1c2UgaW5cclxuXHQgKiB7QGxpbmsgUGFyc2VyQVROU2ltdWxhdG9yI2FkZERGQVN0YXRlfSB3ZSBuZWVkIHRvIGtub3cgaWYgYW55IG90aGVyIHN0YXRlXHJcblx0ICogZXhpc3RzIHRoYXQgaGFzIHRoaXMgZXhhY3Qgc2V0IG9mIEFUTiBjb25maWd1cmF0aW9ucy4gVGhlXHJcblx0ICoge0BsaW5rICNzdGF0ZU51bWJlcn0gaXMgaXJyZWxldmFudC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG86IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0Ly8gY29tcGFyZSBzZXQgb2YgQVROIGNvbmZpZ3VyYXRpb25zIGluIHRoaXMgc2V0IHdpdGggb3RoZXJcclxuXHRcdGlmICh0aGlzID09PSBvKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghKG8gaW5zdGFuY2VvZiBERkFTdGF0ZSkpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBvdGhlcjogREZBU3RhdGUgPSBvO1xyXG5cdFx0bGV0IHNhbWVTZXQ6IGJvb2xlYW4gPSB0aGlzLmNvbmZpZ3MuZXF1YWxzKG90aGVyLmNvbmZpZ3MpO1xyXG4vL1x0XHRTeXN0ZW0ub3V0LnByaW50bG4oXCJERkFTdGF0ZS5lcXVhbHM6IFwiK2NvbmZpZ3MrKHNhbWVTZXQ/XCI9PVwiOlwiIT1cIikrb3RoZXIuY29uZmlncyk7XHJcblx0XHRyZXR1cm4gc2FtZVNldDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0bGV0IGJ1ZiA9IFwiXCI7XHJcblx0XHRidWYgKz0gKHRoaXMuc3RhdGVOdW1iZXIpICsgKFwiOlwiKSArICh0aGlzLmNvbmZpZ3MpO1xyXG5cdFx0aWYgKHRoaXMuaXNBY2NlcHRTdGF0ZSkge1xyXG5cdFx0XHRidWYgKz0gKFwiPT5cIik7XHJcblx0XHRcdGlmICh0aGlzLnByZWRpY2F0ZXMpIHtcclxuXHRcdFx0XHRidWYgKz0gdGhpcy5wcmVkaWNhdGVzO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGJ1ZiArPSAodGhpcy5wcmVkaWN0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJ1Zi50b1N0cmluZygpO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IG5hbWVzcGFjZSBERkFTdGF0ZSB7XHJcblx0LyoqIE1hcCBhIHByZWRpY2F0ZSB0byBhIHByZWRpY3RlZCBhbHRlcm5hdGl2ZS4gKi9cclxuXHRleHBvcnQgY2xhc3MgUHJlZFByZWRpY3Rpb24ge1xyXG5cdFx0QE5vdE51bGxcclxuXHRcdHB1YmxpYyBwcmVkOiBTZW1hbnRpY0NvbnRleHQ7ICAvLyBuZXZlciBudWxsOyBhdCBsZWFzdCBTZW1hbnRpY0NvbnRleHQuTk9ORVxyXG5cdFx0cHVibGljIGFsdDogbnVtYmVyO1xyXG5cdFx0Y29uc3RydWN0b3IoQE5vdE51bGwgcHJlZDogU2VtYW50aWNDb250ZXh0LCBhbHQ6IG51bWJlcikge1xyXG5cdFx0XHR0aGlzLmFsdCA9IGFsdDtcclxuXHRcdFx0dGhpcy5wcmVkID0gcHJlZDtcclxuXHRcdH1cclxuXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0XHRyZXR1cm4gXCIoXCIgKyB0aGlzLnByZWQgKyBcIiwgXCIgKyB0aGlzLmFsdCArIFwiKVwiO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjcuMzE4NDMxMS0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vQVROXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuL0FUTkNvbmZpZ1NldFwiO1xyXG5pbXBvcnQgeyBERkFTdGF0ZSB9IGZyb20gXCIuLi9kZmEvREZBU3RhdGVcIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFByZWRpY3Rpb25Db250ZXh0IH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBVE5TaW11bGF0b3Ige1xyXG5cdC8qKiBNdXN0IGRpc3Rpbmd1aXNoIGJldHdlZW4gbWlzc2luZyBlZGdlIGFuZCBlZGdlIHdlIGtub3cgbGVhZHMgbm93aGVyZSAqL1xyXG5cdHByaXZhdGUgc3RhdGljIF9FUlJPUjogREZBU3RhdGU7XHJcblx0QE5vdE51bGxcclxuXHRzdGF0aWMgZ2V0IEVSUk9SKCk6IERGQVN0YXRlIHtcclxuXHRcdGlmICghQVROU2ltdWxhdG9yLl9FUlJPUikge1xyXG5cdFx0XHRBVE5TaW11bGF0b3IuX0VSUk9SID0gbmV3IERGQVN0YXRlKG5ldyBBVE5Db25maWdTZXQoKSk7XHJcblx0XHRcdEFUTlNpbXVsYXRvci5fRVJST1Iuc3RhdGVOdW1iZXIgPSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gQVROU2ltdWxhdG9yLl9FUlJPUjtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGF0bjogQVROO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCBhdG46IEFUTikge1xyXG5cdFx0dGhpcy5hdG4gPSBhdG47XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVzZXQoKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogQ2xlYXIgdGhlIERGQSBjYWNoZSB1c2VkIGJ5IHRoZSBjdXJyZW50IGluc3RhbmNlLiBTaW5jZSB0aGUgREZBIGNhY2hlIG1heVxyXG5cdCAqIGJlIHNoYXJlZCBieSBtdWx0aXBsZSBBVE4gc2ltdWxhdG9ycywgdGhpcyBtZXRob2QgbWF5IGFmZmVjdCB0aGVcclxuXHQgKiBwZXJmb3JtYW5jZSAoYnV0IG5vdCBhY2N1cmFjeSkgb2Ygb3RoZXIgcGFyc2VycyB3aGljaCBhcmUgYmVpbmcgdXNlZFxyXG5cdCAqIGNvbmN1cnJlbnRseS5cclxuXHQgKlxyXG5cdCAqIEAgaWYgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3RcclxuXHQgKiBzdXBwb3J0IGNsZWFyaW5nIHRoZSBERkEuXHJcblx0ICpcclxuXHQgKiBAc2luY2UgNC4zXHJcblx0ICovXHJcblx0cHVibGljIGNsZWFyREZBKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5hdG4uY2xlYXJERkEoKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgQVROU2ltdWxhdG9yIHtcclxuXHRjb25zdCBSVUxFX1ZBUklBTlRfREVMSU1JVEVSOiBzdHJpbmcgPSBcIiRcIjtcclxuXHRjb25zdCBSVUxFX0xGX1ZBUklBTlRfTUFSS0VSOiBzdHJpbmcgPSBcIiRsZiRcIjtcclxuXHRjb25zdCBSVUxFX05PTEZfVkFSSUFOVF9NQVJLRVI6IHN0cmluZyA9IFwiJG5vbGYkXCI7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUwLjU0Nzk2MDItMDc6MDBcclxuXHJcbmltcG9ydCB7IEFOVExSRXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL0FOVExSRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbnNvbGVFcnJvckxpc3RlbmVyIGltcGxlbWVudHMgQU5UTFJFcnJvckxpc3RlbmVyPGFueT4ge1xyXG5cdC8qKlxyXG5cdCAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbnN0YW5jZSBvZiB7QGxpbmsgQ29uc29sZUVycm9yTGlzdGVuZXJ9LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSU5TVEFOQ0U6IENvbnNvbGVFcnJvckxpc3RlbmVyID0gbmV3IENvbnNvbGVFcnJvckxpc3RlbmVyKCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoaXMgaW1wbGVtZW50YXRpb24gcHJpbnRzIG1lc3NhZ2VzIHRvIHtAbGluayBTeXN0ZW0jZXJyfSBjb250YWluaW5nIHRoZVxyXG5cdCAqIHZhbHVlcyBvZiBgbGluZWAsIGBjaGFyUG9zaXRpb25JbkxpbmVgLCBhbmQgYG1zZ2AgdXNpbmdcclxuXHQgKiB0aGUgZm9sbG93aW5nIGZvcm1hdC5cclxuXHQgKlxyXG5cdCAqIDxwcmU+XHJcblx0ICogbGluZSAqbGluZSo6KmNoYXJQb3NpdGlvbkluTGluZSogKm1zZypcclxuXHQgKiA8L3ByZT5cclxuXHQgKi9cclxuXHRwdWJsaWMgc3ludGF4RXJyb3I8VD4oXHJcblx0XHRyZWNvZ25pemVyOiBSZWNvZ25pemVyPFQsIGFueT4sXHJcblx0XHRvZmZlbmRpbmdTeW1ib2w6IFQsXHJcblx0XHRsaW5lOiBudW1iZXIsXHJcblx0XHRjaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlcixcclxuXHRcdG1zZzogc3RyaW5nLFxyXG5cdFx0ZTogUmVjb2duaXRpb25FeGNlcHRpb24gfCB1bmRlZmluZWQpOiB2b2lkIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoYGxpbmUgJHtsaW5lfToke2NoYXJQb3NpdGlvbkluTGluZX0gJHttc2d9YCk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Ni44MTI2NjkwLTA3OjAwXHJcbmltcG9ydCB7IEFOVExSRXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL0FOVExSRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlLCBOb3ROdWxsIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIEFOVExSRXJyb3JMaXN0ZW5lcn0gZGlzcGF0Y2hlcyBhbGwgY2FsbHMgdG8gYVxyXG4gKiBjb2xsZWN0aW9uIG9mIGRlbGVnYXRlIGxpc3RlbmVycy4gVGhpcyByZWR1Y2VzIHRoZSBlZmZvcnQgcmVxdWlyZWQgdG8gc3VwcG9ydCBtdWx0aXBsZVxyXG4gKiBsaXN0ZW5lcnMuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcm94eUVycm9yTGlzdGVuZXI8VFN5bWJvbCwgVExpc3RlbmVyIGV4dGVuZHMgQU5UTFJFcnJvckxpc3RlbmVyPFRTeW1ib2w+PiBpbXBsZW1lbnRzIEFOVExSRXJyb3JMaXN0ZW5lcjxUU3ltYm9sPiB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgZGVsZWdhdGVzOiBUTGlzdGVuZXJbXSkge1xyXG5cdFx0aWYgKCFkZWxlZ2F0ZXMpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkZWxlZ2F0ZXNcIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0RGVsZWdhdGVzKCk6IFJlYWRvbmx5QXJyYXk8VExpc3RlbmVyPiB7XHJcblx0XHRyZXR1cm4gdGhpcy5kZWxlZ2F0ZXM7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgc3ludGF4RXJyb3I8VCBleHRlbmRzIFRTeW1ib2w+KFxyXG5cdFx0QE5vdE51bGwgcmVjb2duaXplcjogUmVjb2duaXplcjxULCBhbnk+LFxyXG5cdFx0b2ZmZW5kaW5nU3ltYm9sOiBUIHwgdW5kZWZpbmVkLFxyXG5cdFx0bGluZTogbnVtYmVyLFxyXG5cdFx0Y2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXIsXHJcblx0XHRATm90TnVsbCBtc2c6IHN0cmluZyxcclxuXHRcdGU6IFJlY29nbml0aW9uRXhjZXB0aW9uIHwgdW5kZWZpbmVkKTogdm9pZCB7XHJcblx0XHR0aGlzLmRlbGVnYXRlcy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xyXG5cdFx0XHRpZiAobGlzdGVuZXIuc3ludGF4RXJyb3IpIHtcclxuXHRcdFx0XHRsaXN0ZW5lci5zeW50YXhFcnJvcihyZWNvZ25pemVyLCBvZmZlbmRpbmdTeW1ib2wsIGxpbmUsIGNoYXJQb3NpdGlvbkluTGluZSwgbXNnLCBlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Ny4xOTU0NDQxLTA3OjAwXHJcbmltcG9ydCB7IEFOVExSRXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL0FOVExSRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9hdG4vQVROXCI7XHJcbmltcG9ydCB7IEFUTlNpbXVsYXRvciB9IGZyb20gXCIuL2F0bi9BVE5TaW11bGF0b3JcIjtcclxuaW1wb3J0IHsgQ29uc29sZUVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi9Db25zb2xlRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBJbnRTdHJlYW0gfSBmcm9tIFwiLi9JbnRTdHJlYW1cIjtcclxuaW1wb3J0IHsgUGFyc2VJbmZvIH0gZnJvbSBcIi4vYXRuL1BhcnNlSW5mb1wiO1xyXG5pbXBvcnQgeyBQcm94eUVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi9Qcm94eUVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCIuL1J1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IFN1cHByZXNzV2FybmluZ3MsIE5vdE51bGwgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVm9jYWJ1bGFyeSB9IGZyb20gXCIuL1ZvY2FidWxhcnlcIjtcclxuaW1wb3J0IHsgVm9jYWJ1bGFyeUltcGwgfSBmcm9tIFwiLi9Wb2NhYnVsYXJ5SW1wbFwiO1xyXG5cclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4vbWlzYy9VdGlsc1wiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlY29nbml6ZXI8VFN5bWJvbCwgQVROSW50ZXJwcmV0ZXIgZXh0ZW5kcyBBVE5TaW11bGF0b3I+IHtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEVPRjogbnVtYmVyID0gLTE7XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIHRva2VuVHlwZU1hcENhY2hlID1cclxuXHRcdG5ldyBXZWFrTWFwPFZvY2FidWxhcnksIFJlYWRvbmx5TWFwPHN0cmluZywgbnVtYmVyPj4oKTtcclxuXHRwcml2YXRlIHN0YXRpYyBydWxlSW5kZXhNYXBDYWNoZSA9XHJcblx0XHRuZXcgV2Vha01hcDxzdHJpbmdbXSwgUmVhZG9ubHlNYXA8c3RyaW5nLCBudW1iZXI+PigpO1xyXG5cclxuXHRAU3VwcHJlc3NXYXJuaW5ncyhcInNlcmlhbFwiKVxyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSByZWFkb25seSBfbGlzdGVuZXJzOiBBcnJheTxBTlRMUkVycm9yTGlzdGVuZXI8VFN5bWJvbD4+ID0gW0NvbnNvbGVFcnJvckxpc3RlbmVyLklOU1RBTkNFXTtcclxuXHJcblx0cHJvdGVjdGVkIF9pbnRlcnAhOiBBVE5JbnRlcnByZXRlcjtcclxuXHJcblx0cHJpdmF0ZSBfc3RhdGVOdW1iZXIgPSAtMTtcclxuXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHJ1bGVOYW1lczogc3RyaW5nW107XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdm9jYWJ1bGFyeSB1c2VkIGJ5IHRoZSByZWNvZ25pemVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgQSB7QGxpbmsgVm9jYWJ1bGFyeX0gaW5zdGFuY2UgcHJvdmlkaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZVxyXG5cdCAqIHZvY2FidWxhcnkgdXNlZCBieSB0aGUgZ3JhbW1hci5cclxuXHQgKi9cclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgdm9jYWJ1bGFyeTogVm9jYWJ1bGFyeTtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGEgbWFwIGZyb20gdG9rZW4gbmFtZXMgdG8gdG9rZW4gdHlwZXMuXHJcblx0ICpcclxuXHQgKiBVc2VkIGZvciBYUGF0aCBhbmQgdHJlZSBwYXR0ZXJuIGNvbXBpbGF0aW9uLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGdldFRva2VuVHlwZU1hcCgpOiBSZWFkb25seU1hcDxzdHJpbmcsIG51bWJlcj4ge1xyXG5cdFx0bGV0IHZvY2FidWxhcnk6IFZvY2FidWxhcnkgPSB0aGlzLnZvY2FidWxhcnk7XHJcblx0XHRsZXQgcmVzdWx0ID0gUmVjb2duaXplci50b2tlblR5cGVNYXBDYWNoZS5nZXQodm9jYWJ1bGFyeSk7XHJcblx0XHRpZiAocmVzdWx0ID09IG51bGwpIHtcclxuXHRcdFx0bGV0IGludGVybWVkaWF0ZVJlc3VsdCA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMuYXRuLm1heFRva2VuVHlwZTsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IGxpdGVyYWxOYW1lID0gdm9jYWJ1bGFyeS5nZXRMaXRlcmFsTmFtZShpKTtcclxuXHRcdFx0XHRpZiAobGl0ZXJhbE5hbWUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0aW50ZXJtZWRpYXRlUmVzdWx0LnNldChsaXRlcmFsTmFtZSwgaSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgc3ltYm9saWNOYW1lID0gdm9jYWJ1bGFyeS5nZXRTeW1ib2xpY05hbWUoaSk7XHJcblx0XHRcdFx0aWYgKHN5bWJvbGljTmFtZSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRpbnRlcm1lZGlhdGVSZXN1bHQuc2V0KHN5bWJvbGljTmFtZSwgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpbnRlcm1lZGlhdGVSZXN1bHQuc2V0KFwiRU9GXCIsIFRva2VuLkVPRik7XHJcblx0XHRcdHJlc3VsdCA9IGludGVybWVkaWF0ZVJlc3VsdDtcclxuXHRcdFx0UmVjb2duaXplci50b2tlblR5cGVNYXBDYWNoZS5zZXQodm9jYWJ1bGFyeSwgcmVzdWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGEgbWFwIGZyb20gcnVsZSBuYW1lcyB0byBydWxlIGluZGV4ZXMuXHJcblx0ICpcclxuXHQgKiBVc2VkIGZvciBYUGF0aCBhbmQgdHJlZSBwYXR0ZXJuIGNvbXBpbGF0aW9uLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGdldFJ1bGVJbmRleE1hcCgpOiBSZWFkb25seU1hcDxzdHJpbmcsIG51bWJlcj4ge1xyXG5cdFx0bGV0IHJ1bGVOYW1lczogc3RyaW5nW10gPSB0aGlzLnJ1bGVOYW1lcztcclxuXHRcdGlmIChydWxlTmFtZXMgPT0gbnVsbCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCByZWNvZ25pemVyIGRvZXMgbm90IHByb3ZpZGUgYSBsaXN0IG9mIHJ1bGUgbmFtZXMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZXN1bHQ6IFJlYWRvbmx5TWFwPHN0cmluZywgbnVtYmVyPiB8IHVuZGVmaW5lZCA9IFJlY29nbml6ZXIucnVsZUluZGV4TWFwQ2FjaGUuZ2V0KHJ1bGVOYW1lcyk7XHJcblx0XHRpZiAocmVzdWx0ID09IG51bGwpIHtcclxuXHRcdFx0cmVzdWx0ID0gVXRpbHMudG9NYXAocnVsZU5hbWVzKTtcclxuXHRcdFx0UmVjb2duaXplci5ydWxlSW5kZXhNYXBDYWNoZS5zZXQocnVsZU5hbWVzLCByZXN1bHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0VG9rZW5UeXBlKHRva2VuTmFtZTogc3RyaW5nKTogbnVtYmVyIHtcclxuXHRcdGxldCB0dHlwZSA9IHRoaXMuZ2V0VG9rZW5UeXBlTWFwKCkuZ2V0KHRva2VuTmFtZSk7XHJcblx0XHRpZiAodHR5cGUgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdHR5cGU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gVG9rZW4uSU5WQUxJRF9UWVBFO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSWYgdGhpcyByZWNvZ25pemVyIHdhcyBnZW5lcmF0ZWQsIGl0IHdpbGwgaGF2ZSBhIHNlcmlhbGl6ZWQgQVROXHJcblx0ICogcmVwcmVzZW50YXRpb24gb2YgdGhlIGdyYW1tYXIuXHJcblx0ICpcclxuXHQgKiBGb3IgaW50ZXJwcmV0ZXJzLCB3ZSBkb24ndCBrbm93IHRoZWlyIHNlcmlhbGl6ZWQgQVROIGRlc3BpdGUgaGF2aW5nXHJcblx0ICogY3JlYXRlZCB0aGUgaW50ZXJwcmV0ZXIgZnJvbSBpdC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBzZXJpYWxpemVkQVROKCk6IHN0cmluZyB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0aGVyZSBpcyBubyBzZXJpYWxpemVkIEFUTlwiKTtcclxuXHR9XHJcblxyXG5cdC8qKiBGb3IgZGVidWdnaW5nIGFuZCBvdGhlciBwdXJwb3NlcywgbWlnaHQgd2FudCB0aGUgZ3JhbW1hciBuYW1lLlxyXG5cdCAqICBIYXZlIEFOVExSIGdlbmVyYXRlIGFuIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIG1ldGhvZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgZ3JhbW1hckZpbGVOYW1lOiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUge0BsaW5rIEFUTn0gdXNlZCBieSB0aGUgcmVjb2duaXplciBmb3IgcHJlZGljdGlvbi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSB7QGxpbmsgQVROfSB1c2VkIGJ5IHRoZSByZWNvZ25pemVyIGZvciBwcmVkaWN0aW9uLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGF0bigpOiBBVE4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ludGVycC5hdG47XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIEFUTiBpbnRlcnByZXRlciB1c2VkIGJ5IHRoZSByZWNvZ25pemVyIGZvciBwcmVkaWN0aW9uLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIEFUTiBpbnRlcnByZXRlciB1c2VkIGJ5IHRoZSByZWNvZ25pemVyIGZvciBwcmVkaWN0aW9uLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGludGVycHJldGVyKCk6IEFUTkludGVycHJldGVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbnRlcnA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIEFUTiBpbnRlcnByZXRlciB1c2VkIGJ5IHRoZSByZWNvZ25pemVyIGZvciBwcmVkaWN0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGludGVycHJldGVyIFRoZSBBVE4gaW50ZXJwcmV0ZXIgdXNlZCBieSB0aGUgcmVjb2duaXplciBmb3JcclxuXHQgKiBwcmVkaWN0aW9uLlxyXG5cdCAqL1xyXG5cdHNldCBpbnRlcnByZXRlcihATm90TnVsbCBpbnRlcnByZXRlcjogQVROSW50ZXJwcmV0ZXIpIHtcclxuXHRcdHRoaXMuX2ludGVycCA9IGludGVycHJldGVyO1xyXG5cdH1cclxuXHJcblx0LyoqIElmIHByb2ZpbGluZyBkdXJpbmcgdGhlIHBhcnNlL2xleCwgdGhpcyB3aWxsIHJldHVybiBEZWNpc2lvbkluZm8gcmVjb3Jkc1xyXG5cdCAqICBmb3IgZWFjaCBkZWNpc2lvbiBpbiByZWNvZ25pemVyIGluIGEgUGFyc2VJbmZvIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBzaW5jZSA0LjNcclxuXHQgKi9cclxuXHRnZXQgcGFyc2VJbmZvKCk6IFByb21pc2U8UGFyc2VJbmZvIHwgdW5kZWZpbmVkPiB7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XHJcblx0fVxyXG5cclxuXHQvKiogV2hhdCBpcyB0aGUgZXJyb3IgaGVhZGVyLCBub3JtYWxseSBsaW5lL2NoYXJhY3RlciBwb3NpdGlvbiBpbmZvcm1hdGlvbj8gKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRFcnJvckhlYWRlcihATm90TnVsbCBlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbik6IHN0cmluZyB7XHJcblx0XHRsZXQgdG9rZW4gPSBlLmdldE9mZmVuZGluZ1Rva2VuKCk7XHJcblx0XHRpZiAoIXRva2VuKSB7XHJcblx0XHRcdHJldHVybiBcIlwiO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGxpbmUgPSB0b2tlbi5saW5lO1xyXG5cdFx0bGV0IGNoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyID0gdG9rZW4uY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdFx0cmV0dXJuIFwibGluZSBcIiArIGxpbmUgKyBcIjpcIiArIGNoYXJQb3NpdGlvbkluTGluZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBleGNlcHRpb24gTnVsbFBvaW50ZXJFeGNlcHRpb24gaWYgYGxpc3RlbmVyYCBpcyBgdW5kZWZpbmVkYC5cclxuXHQgKi9cclxuXHRwdWJsaWMgYWRkRXJyb3JMaXN0ZW5lcihATm90TnVsbCBsaXN0ZW5lcjogQU5UTFJFcnJvckxpc3RlbmVyPFRTeW1ib2w+KTogdm9pZCB7XHJcblx0XHRpZiAoIWxpc3RlbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJsaXN0ZW5lciBtdXN0IG5vdCBiZSBudWxsXCIpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlbW92ZUVycm9yTGlzdGVuZXIoQE5vdE51bGwgbGlzdGVuZXI6IEFOVExSRXJyb3JMaXN0ZW5lcjxUU3ltYm9sPik6IHZvaWQge1xyXG5cdFx0bGV0IHBvc2l0aW9uID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAtMSkge1xyXG5cdFx0XHR0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyByZW1vdmVFcnJvckxpc3RlbmVycygpOiB2b2lkIHtcclxuXHRcdHRoaXMuX2xpc3RlbmVycy5sZW5ndGggPSAwO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0RXJyb3JMaXN0ZW5lcnMoKTogQXJyYXk8QU5UTFJFcnJvckxpc3RlbmVyPFRTeW1ib2w+PiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGlzdGVuZXJzLnNsaWNlKDApO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCgpOiBBTlRMUkVycm9yTGlzdGVuZXI8VFN5bWJvbD4ge1xyXG5cdFx0cmV0dXJuIG5ldyBQcm94eUVycm9yTGlzdGVuZXI8VFN5bWJvbCwgQU5UTFJFcnJvckxpc3RlbmVyPFRTeW1ib2w+Pih0aGlzLmdldEVycm9yTGlzdGVuZXJzKCkpO1xyXG5cdH1cclxuXHJcblx0Ly8gc3ViY2xhc3MgbmVlZHMgdG8gb3ZlcnJpZGUgdGhlc2UgaWYgdGhlcmUgYXJlIHNlbXByZWRzIG9yIGFjdGlvbnNcclxuXHQvLyB0aGF0IHRoZSBBVE4gaW50ZXJwIG5lZWRzIHRvIGV4ZWN1dGVcclxuXHRwdWJsaWMgc2VtcHJlZChcclxuXHRcdF9sb2NhbGN0eDogUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsXHJcblx0XHRydWxlSW5kZXg6IG51bWJlcixcclxuXHRcdGFjdGlvbkluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHByZWNwcmVkKFxyXG5cdFx0bG9jYWxjdHg6IFJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLFxyXG5cdFx0cHJlY2VkZW5jZTogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhY3Rpb24oXHJcblx0XHRfbG9jYWxjdHg6IFJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLFxyXG5cdFx0cnVsZUluZGV4OiBudW1iZXIsXHJcblx0XHRhY3Rpb25JbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcblx0fVxyXG5cclxuXHRnZXQgc3RhdGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9zdGF0ZU51bWJlcjtcclxuXHR9XHJcblxyXG5cdC8qKiBJbmRpY2F0ZSB0aGF0IHRoZSByZWNvZ25pemVyIGhhcyBjaGFuZ2VkIGludGVybmFsIHN0YXRlIHRoYXQgaXNcclxuXHQgKiAgY29uc2lzdGVudCB3aXRoIHRoZSBBVE4gc3RhdGUgcGFzc2VkIGluLiAgVGhpcyB3YXkgd2UgYWx3YXlzIGtub3dcclxuXHQgKiAgd2hlcmUgd2UgYXJlIGluIHRoZSBBVE4gYXMgdGhlIHBhcnNlciBnb2VzIGFsb25nLiBUaGUgcnVsZVxyXG5cdCAqICBjb250ZXh0IG9iamVjdHMgZm9ybSBhIHN0YWNrIHRoYXQgbGV0cyB1cyBzZWUgdGhlIHN0YWNrIG9mXHJcblx0ICogIGludm9raW5nIHJ1bGVzLiBDb21iaW5lIHRoaXMgYW5kIHdlIGhhdmUgY29tcGxldGUgQVROXHJcblx0ICogIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb24uXHJcblx0ICovXHJcblx0c2V0IHN0YXRlKGF0blN0YXRlOiBudW1iZXIpIHtcclxuLy9cdFx0U3lzdGVtLmVyci5wcmludGxuKFwic2V0U3RhdGUgXCIrYXRuU3RhdGUpO1xyXG5cdFx0dGhpcy5fc3RhdGVOdW1iZXIgPSBhdG5TdGF0ZTtcclxuLy9cdFx0aWYgKCB0cmFjZUFUTlN0YXRlcyApIF9jdHgudHJhY2UoYXRuU3RhdGUpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGlucHV0U3RyZWFtOiBJbnRTdHJlYW0gfCB1bmRlZmluZWQ7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU5LjU4Mjk2NTQtMDc6MDBcclxuXHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnkgfSBmcm9tIFwiLi9Wb2NhYnVsYXJ5XCI7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIHtAbGluayBWb2NhYnVsYXJ5fVxyXG4gKiBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBWb2NhYnVsYXJ5SW1wbCBpbXBsZW1lbnRzIFZvY2FidWxhcnkge1xyXG5cdC8qKlxyXG5cdCAqIEdldHMgYW4gZW1wdHkge0BsaW5rIFZvY2FidWxhcnl9IGluc3RhbmNlLlxyXG5cdCAqXHJcblx0ICogTm8gbGl0ZXJhbCBvciBzeW1ib2wgbmFtZXMgYXJlIGFzc2lnbmVkIHRvIHRva2VuIHR5cGVzLCBzb1xyXG5cdCAqIHtAbGluayAjZ2V0RGlzcGxheU5hbWUoaW50KX0gcmV0dXJucyB0aGUgbnVtZXJpYyB2YWx1ZSBmb3IgYWxsIHRva2Vuc1xyXG5cdCAqIGV4Y2VwdCB7QGxpbmsgVG9rZW4jRU9GfS5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRU1QVFlfVk9DQUJVTEFSWTogVm9jYWJ1bGFyeUltcGwgPSBuZXcgVm9jYWJ1bGFyeUltcGwoW10sIFtdLCBbXSk7XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSByZWFkb25seSBsaXRlcmFsTmFtZXM6IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZD47XHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIHJlYWRvbmx5IHN5bWJvbGljTmFtZXM6IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZD47XHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIHJlYWRvbmx5IGRpc3BsYXlOYW1lczogQXJyYXk8c3RyaW5nIHwgdW5kZWZpbmVkPjtcclxuXHJcblx0cHJpdmF0ZSBfbWF4VG9rZW5UeXBlOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFZvY2FidWxhcnlJbXBsfSBmcm9tIHRoZSBzcGVjaWZpZWRcclxuXHQgKiBsaXRlcmFsLCBzeW1ib2xpYywgYW5kIGRpc3BsYXkgdG9rZW4gbmFtZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gbGl0ZXJhbE5hbWVzIFRoZSBsaXRlcmFsIG5hbWVzIGFzc2lnbmVkIHRvIHRva2Vucywgb3IgYW4gZW1wdHkgYXJyYXlcclxuXHQgKiBpZiBubyBsaXRlcmFsIG5hbWVzIGFyZSBhc3NpZ25lZC5cclxuXHQgKiBAcGFyYW0gc3ltYm9saWNOYW1lcyBUaGUgc3ltYm9saWMgbmFtZXMgYXNzaWduZWQgdG8gdG9rZW5zLCBvclxyXG5cdCAqIGFuIGVtcHR5IGFycmF5IGlmIG5vIHN5bWJvbGljIG5hbWVzIGFyZSBhc3NpZ25lZC5cclxuXHQgKiBAcGFyYW0gZGlzcGxheU5hbWVzIFRoZSBkaXNwbGF5IG5hbWVzIGFzc2lnbmVkIHRvIHRva2Vucywgb3IgYW4gZW1wdHkgYXJyYXlcclxuXHQgKiB0byB1c2UgdGhlIHZhbHVlcyBpbiBgbGl0ZXJhbE5hbWVzYCBhbmQgYHN5bWJvbGljTmFtZXNgIGFzXHJcblx0ICogdGhlIHNvdXJjZSBvZiBkaXNwbGF5IG5hbWVzLCBhcyBkZXNjcmliZWQgaW5cclxuXHQgKiB7QGxpbmsgI2dldERpc3BsYXlOYW1lKGludCl9LlxyXG5cdCAqXHJcblx0ICogQHNlZSAjZ2V0TGl0ZXJhbE5hbWUoaW50KVxyXG5cdCAqIEBzZWUgI2dldFN5bWJvbGljTmFtZShpbnQpXHJcblx0ICogQHNlZSAjZ2V0RGlzcGxheU5hbWUoaW50KVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGxpdGVyYWxOYW1lczogQXJyYXk8c3RyaW5nIHwgdW5kZWZpbmVkPiwgc3ltYm9saWNOYW1lczogQXJyYXk8c3RyaW5nIHwgdW5kZWZpbmVkPiwgZGlzcGxheU5hbWVzOiBBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+KSB7XHJcblx0XHR0aGlzLmxpdGVyYWxOYW1lcyA9IGxpdGVyYWxOYW1lcztcclxuXHRcdHRoaXMuc3ltYm9saWNOYW1lcyA9IHN5bWJvbGljTmFtZXM7XHJcblx0XHR0aGlzLmRpc3BsYXlOYW1lcyA9IGRpc3BsYXlOYW1lcztcclxuXHRcdC8vIFNlZSBub3RlIGhlcmUgb24gLTEgcGFydDogaHR0cHM6Ly9naXRodWIuY29tL2FudGxyL2FudGxyNC9wdWxsLzExNDZcclxuXHRcdHRoaXMuX21heFRva2VuVHlwZSA9XHJcblx0XHRcdE1hdGgubWF4KHRoaXMuZGlzcGxheU5hbWVzLmxlbmd0aCxcclxuXHRcdFx0XHRNYXRoLm1heCh0aGlzLmxpdGVyYWxOYW1lcy5sZW5ndGgsIHRoaXMuc3ltYm9saWNOYW1lcy5sZW5ndGgpKSAtIDE7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgbWF4VG9rZW5UeXBlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbWF4VG9rZW5UeXBlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGdldExpdGVyYWxOYW1lKHRva2VuVHlwZTogbnVtYmVyKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICh0b2tlblR5cGUgPj0gMCAmJiB0b2tlblR5cGUgPCB0aGlzLmxpdGVyYWxOYW1lcy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMubGl0ZXJhbE5hbWVzW3Rva2VuVHlwZV07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXRTeW1ib2xpY05hbWUodG9rZW5UeXBlOiBudW1iZXIpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKHRva2VuVHlwZSA+PSAwICYmIHRva2VuVHlwZSA8IHRoaXMuc3ltYm9saWNOYW1lcy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ltYm9saWNOYW1lc1t0b2tlblR5cGVdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0b2tlblR5cGUgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHRyZXR1cm4gXCJFT0ZcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0RGlzcGxheU5hbWUodG9rZW5UeXBlOiBudW1iZXIpOiBzdHJpbmcge1xyXG5cdFx0aWYgKHRva2VuVHlwZSA+PSAwICYmIHRva2VuVHlwZSA8IHRoaXMuZGlzcGxheU5hbWVzLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgZGlzcGxheU5hbWUgPSB0aGlzLmRpc3BsYXlOYW1lc1t0b2tlblR5cGVdO1xyXG5cdFx0XHRpZiAoZGlzcGxheU5hbWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZGlzcGxheU5hbWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbGl0ZXJhbE5hbWUgPSB0aGlzLmdldExpdGVyYWxOYW1lKHRva2VuVHlwZSk7XHJcblx0XHRpZiAobGl0ZXJhbE5hbWUpIHtcclxuXHRcdFx0cmV0dXJuIGxpdGVyYWxOYW1lO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBzeW1ib2xpY05hbWUgPSB0aGlzLmdldFN5bWJvbGljTmFtZSh0b2tlblR5cGUpO1xyXG5cdFx0aWYgKHN5bWJvbGljTmFtZSkge1xyXG5cdFx0XHRyZXR1cm4gc3ltYm9saWNOYW1lO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBTdHJpbmcodG9rZW5UeXBlKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM4LjUwOTc5MjUtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuLi9hdG4vQVROXCI7XHJcbmltcG9ydCB7IEFUTlNpbXVsYXRvciB9IGZyb20gXCIuLi9hdG4vQVROU2ltdWxhdG9yXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4uL2F0bi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBERkEgfSBmcm9tIFwiLi9ERkFcIjtcclxuaW1wb3J0IHsgREZBU3RhdGUgfSBmcm9tIFwiLi9ERkFTdGF0ZVwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFByZWRpY3Rpb25Db250ZXh0IH0gZnJvbSBcIi4uL2F0bi9QcmVkaWN0aW9uQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pemVyIH0gZnJvbSBcIi4uL1JlY29nbml6ZXJcIjtcclxuaW1wb3J0IHsgVm9jYWJ1bGFyeSB9IGZyb20gXCIuLi9Wb2NhYnVsYXJ5XCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnlJbXBsIH0gZnJvbSBcIi4uL1ZvY2FidWxhcnlJbXBsXCI7XHJcblxyXG4vKiogQSBERkEgd2Fsa2VyIHRoYXQga25vd3MgaG93IHRvIGR1bXAgdGhlbSB0byBzZXJpYWxpemVkIHN0cmluZ3MuICovXHJcbmV4cG9ydCBjbGFzcyBERkFTZXJpYWxpemVyIHtcclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgZGZhOiBERkE7XHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIHZvY2FidWxhcnk6IFZvY2FidWxhcnk7XHJcblxyXG5cdHB1YmxpYyBydWxlTmFtZXM/OiBzdHJpbmdbXTtcclxuXHJcblx0cHVibGljIGF0bj86IEFUTjtcclxuXHJcblx0Y29uc3RydWN0b3IoLypATm90TnVsbCovIGRmYTogREZBLCAvKkBOb3ROdWxsKi8gdm9jYWJ1bGFyeTogVm9jYWJ1bGFyeSk7XHJcblx0Y29uc3RydWN0b3IoLypATm90TnVsbCovIGRmYTogREZBLCAvKkBOdWxsYWJsZSovIHBhcnNlcjogUmVjb2duaXplcjxhbnksIGFueT4gfCB1bmRlZmluZWQpO1xyXG5cdGNvbnN0cnVjdG9yKC8qQE5vdE51bGwqLyBkZmE6IERGQSwgLypATm90TnVsbCovIHZvY2FidWxhcnk6IFZvY2FidWxhcnksIC8qQE51bGxhYmxlKi8gcnVsZU5hbWVzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCwgLypATnVsbGFibGUqLyBhdG46IEFUTiB8IHVuZGVmaW5lZCk7XHJcblx0Y29uc3RydWN0b3IoZGZhOiBERkEsIHZvY2FidWxhcnk6IFZvY2FidWxhcnkgfCBSZWNvZ25pemVyPGFueSwgYW55PiB8IHVuZGVmaW5lZCwgcnVsZU5hbWVzPzogc3RyaW5nW10sIGF0bj86IEFUTikge1xyXG5cdFx0aWYgKHZvY2FidWxhcnkgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XHJcblx0XHRcdHJ1bGVOYW1lcyA9IHZvY2FidWxhcnkucnVsZU5hbWVzO1xyXG5cdFx0XHRhdG4gPSB2b2NhYnVsYXJ5LmF0bjtcclxuXHRcdFx0dm9jYWJ1bGFyeSA9IHZvY2FidWxhcnkudm9jYWJ1bGFyeTtcclxuXHRcdH0gZWxzZSBpZiAoIXZvY2FidWxhcnkpIHtcclxuXHRcdFx0dm9jYWJ1bGFyeSA9IFZvY2FidWxhcnlJbXBsLkVNUFRZX1ZPQ0FCVUxBUlk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5kZmEgPSBkZmE7XHJcblx0XHR0aGlzLnZvY2FidWxhcnkgPSB2b2NhYnVsYXJ5O1xyXG5cdFx0dGhpcy5ydWxlTmFtZXMgPSBydWxlTmFtZXM7XHJcblx0XHR0aGlzLmF0biA9IGF0bjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0aWYgKCF0aGlzLmRmYS5zMCkge1xyXG5cdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYnVmID0gXCJcIjtcclxuXHJcblx0XHRpZiAodGhpcy5kZmEuc3RhdGVzKSB7XHJcblx0XHRcdGxldCBzdGF0ZXM6IERGQVN0YXRlW10gPSBuZXcgQXJyYXk8REZBU3RhdGU+KC4uLnRoaXMuZGZhLnN0YXRlcy50b0FycmF5KCkpO1xyXG5cdFx0XHRzdGF0ZXMuc29ydCgobzEsIG8yKSA9PiBvMS5zdGF0ZU51bWJlciAtIG8yLnN0YXRlTnVtYmVyKTtcclxuXHJcblx0XHRcdGZvciAobGV0IHMgb2Ygc3RhdGVzKSB7XHJcblx0XHRcdFx0bGV0IGVkZ2VzOiBNYXA8bnVtYmVyLCBERkFTdGF0ZT4gPSBzLmdldEVkZ2VNYXAoKTtcclxuXHRcdFx0XHRsZXQgZWRnZUtleXMgPSBbLi4uZWRnZXMua2V5cygpXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcblx0XHRcdFx0bGV0IGNvbnRleHRFZGdlczogTWFwPG51bWJlciwgREZBU3RhdGU+ID0gcy5nZXRDb250ZXh0RWRnZU1hcCgpO1xyXG5cdFx0XHRcdGxldCBjb250ZXh0RWRnZUtleXMgPSBbLi4uY29udGV4dEVkZ2VzLmtleXMoKV0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG5cdFx0XHRcdGZvciAobGV0IGVudHJ5IG9mIGVkZ2VLZXlzKSB7XHJcblx0XHRcdFx0XHRsZXQgdmFsdWUgPSBlZGdlcy5nZXQoZW50cnkpO1xyXG5cdFx0XHRcdFx0aWYgKCh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBBVE5TaW11bGF0b3IuRVJST1IpICYmICFzLmlzQ29udGV4dFN5bWJvbChlbnRyeSkpIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0IGNvbnRleHRTeW1ib2w6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdFx0XHRcdGJ1ZiArPSAodGhpcy5nZXRTdGF0ZVN0cmluZyhzKSkgKyAoXCItXCIpICsgKHRoaXMuZ2V0RWRnZUxhYmVsKGVudHJ5KSkgKyAoXCItPlwiKTtcclxuXHRcdFx0XHRcdGlmIChzLmlzQ29udGV4dFN5bWJvbChlbnRyeSkpIHtcclxuXHRcdFx0XHRcdFx0YnVmICs9IChcIiFcIik7XHJcblx0XHRcdFx0XHRcdGNvbnRleHRTeW1ib2wgPSB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCB0OiBERkFTdGF0ZSB8IHVuZGVmaW5lZCA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0aWYgKHQgJiYgdC5zdGF0ZU51bWJlciAhPT0gQVROU2ltdWxhdG9yLkVSUk9SLnN0YXRlTnVtYmVyKSB7XHJcblx0XHRcdFx0XHRcdGJ1ZiArPSAodGhpcy5nZXRTdGF0ZVN0cmluZyh0KSkgKyAoXCJcXG5cIik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmIChjb250ZXh0U3ltYm9sKSB7XHJcblx0XHRcdFx0XHRcdGJ1ZiArPSAoXCJjdHhcXG5cIik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAocy5pc0NvbnRleHRTZW5zaXRpdmUpIHtcclxuXHRcdFx0XHRcdGZvciAobGV0IGVudHJ5IG9mIGNvbnRleHRFZGdlS2V5cykge1xyXG5cdFx0XHRcdFx0XHRidWYgKz0gKHRoaXMuZ2V0U3RhdGVTdHJpbmcocykpXHJcblx0XHRcdFx0XHRcdFx0KyAoXCItXCIpXHJcblx0XHRcdFx0XHRcdFx0KyAodGhpcy5nZXRDb250ZXh0TGFiZWwoZW50cnkpKVxyXG5cdFx0XHRcdFx0XHRcdCsgKFwiLT5cIilcclxuXHRcdFx0XHRcdFx0XHQrICh0aGlzLmdldFN0YXRlU3RyaW5nKGNvbnRleHRFZGdlcy5nZXQoZW50cnkpISkpXHJcblx0XHRcdFx0XHRcdFx0KyAoXCJcXG5cIik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRsZXQgb3V0cHV0OiBzdHJpbmcgPSBidWY7XHJcblx0XHRpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdH1cclxuXHRcdC8vcmV0dXJuIFV0aWxzLnNvcnRMaW5lc0luU3RyaW5nKG91dHB1dCk7XHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldENvbnRleHRMYWJlbChpOiBudW1iZXIpOiBzdHJpbmcge1xyXG5cdFx0aWYgKGkgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XHJcblx0XHRcdHJldHVybiBcImN0eDpFTVBUWV9GVUxMXCI7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChpID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9MT0NBTF9TVEFURV9LRVkpIHtcclxuXHRcdFx0cmV0dXJuIFwiY3R4OkVNUFRZX0xPQ0FMXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuYXRuICYmIGkgPiAwICYmIGkgPD0gdGhpcy5hdG4uc3RhdGVzLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgc3RhdGU6IEFUTlN0YXRlID0gdGhpcy5hdG4uc3RhdGVzW2ldO1xyXG5cdFx0XHRsZXQgcnVsZUluZGV4OiBudW1iZXIgPSBzdGF0ZS5ydWxlSW5kZXg7XHJcblx0XHRcdGlmICh0aGlzLnJ1bGVOYW1lcyAmJiBydWxlSW5kZXggPj0gMCAmJiBydWxlSW5kZXggPCB0aGlzLnJ1bGVOYW1lcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXR1cm4gXCJjdHg6XCIgKyBTdHJpbmcoaSkgKyBcIihcIiArIHRoaXMucnVsZU5hbWVzW3J1bGVJbmRleF0gKyBcIilcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBcImN0eDpcIiArIFN0cmluZyhpKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRFZGdlTGFiZWwoaTogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLnZvY2FidWxhcnkuZ2V0RGlzcGxheU5hbWUoaSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0U3RhdGVTdHJpbmcoczogREZBU3RhdGUpOiBzdHJpbmcge1xyXG5cdFx0aWYgKHMgPT09IEFUTlNpbXVsYXRvci5FUlJPUikge1xyXG5cdFx0XHRyZXR1cm4gXCJFUlJPUlwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBuOiBudW1iZXIgPSBzLnN0YXRlTnVtYmVyO1xyXG5cdFx0bGV0IHN0YXRlU3RyOiBzdHJpbmcgPSBcInNcIiArIG47XHJcblx0XHRpZiAocy5pc0FjY2VwdFN0YXRlKSB7XHJcblx0XHRcdGlmIChzLnByZWRpY2F0ZXMpIHtcclxuXHRcdFx0XHRzdGF0ZVN0ciA9IFwiOnNcIiArIG4gKyBcIj0+XCIgKyBzLnByZWRpY2F0ZXM7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0c3RhdGVTdHIgPSBcIjpzXCIgKyBuICsgXCI9PlwiICsgcy5wcmVkaWN0aW9uO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHMuaXNDb250ZXh0U2Vuc2l0aXZlKSB7XHJcblx0XHRcdHN0YXRlU3RyICs9IFwiKlwiO1xyXG5cdFx0XHRmb3IgKGxldCBjb25maWcgb2Ygcy5jb25maWdzKSB7XHJcblx0XHRcdFx0aWYgKGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dCkge1xyXG5cdFx0XHRcdFx0c3RhdGVTdHIgKz0gXCIqXCI7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBzdGF0ZVN0cjtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM5LjIxNjcyMzgtMDc6MDBcclxuXHJcbmltcG9ydCB7IERGQSB9IGZyb20gXCIuL0RGQVwiO1xyXG5pbXBvcnQgeyBERkFTZXJpYWxpemVyIH0gZnJvbSBcIi4vREZBU2VyaWFsaXplclwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnlJbXBsIH0gZnJvbSBcIi4uL1ZvY2FidWxhcnlJbXBsXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgTGV4ZXJERkFTZXJpYWxpemVyIGV4dGVuZHMgREZBU2VyaWFsaXplciB7XHJcblx0Y29uc3RydWN0b3IoIEBOb3ROdWxsIGRmYTogREZBKSB7XHJcblx0XHRzdXBlcihkZmEsIFZvY2FidWxhcnlJbXBsLkVNUFRZX1ZPQ0FCVUxBUlkpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgZ2V0RWRnZUxhYmVsKGk6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCInXCIgKyBTdHJpbmcuZnJvbUNvZGVQb2ludChpKSArIFwiJ1wiO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzcuNzA5OTIwMS0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IEJpdFNldCB9IGZyb20gXCIuLi9taXNjL0JpdFNldFwiO1xyXG5pbXBvcnQgeyBEZWNpc2lvblN0YXRlIH0gZnJvbSBcIi4vRGVjaXNpb25TdGF0ZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFN0YXJMb29wYmFja1N0YXRlIH0gZnJvbSBcIi4vU3Rhckxvb3BiYWNrU3RhdGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTdGFyTG9vcEVudHJ5U3RhdGUgZXh0ZW5kcyBEZWNpc2lvblN0YXRlIHtcclxuXHQvLyBUaGlzIGlzIGFsd2F5cyBzZXQgZHVyaW5nIEFUTiBkZXNlcmlhbGl6YXRpb25cclxuXHRwdWJsaWMgbG9vcEJhY2tTdGF0ZSE6IFN0YXJMb29wYmFja1N0YXRlO1xyXG5cclxuXHQvKipcclxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBiZW5lZml0IGZyb20gYSBwcmVjZWRlbmNlIERGQSBkdXJpbmcgU0xMXHJcblx0ICogZGVjaXNpb24gbWFraW5nLlxyXG5cdCAqXHJcblx0ICogVGhpcyBpcyBhIGNvbXB1dGVkIHByb3BlcnR5IHRoYXQgaXMgY2FsY3VsYXRlZCBkdXJpbmcgQVROIGRlc2VyaWFsaXphdGlvblxyXG5cdCAqIGFuZCBzdG9yZWQgZm9yIHVzZSBpbiB7QGxpbmsgUGFyc2VyQVROU2ltdWxhdG9yfSBhbmRcclxuXHQgKiB7QGxpbmsgUGFyc2VySW50ZXJwcmV0ZXJ9LlxyXG5cdCAqXHJcblx0ICogQHNlZSBgREZBLmlzUHJlY2VkZW5jZURmYWBcclxuXHQgKi9cclxuXHRwdWJsaWMgcHJlY2VkZW5jZVJ1bGVEZWNpc2lvbjogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHQvKipcclxuXHQgKiBGb3IgcHJlY2VkZW5jZSBkZWNpc2lvbnMsIHRoaXMgc2V0IG1hcmtzIHN0YXRlcyAqUyogd2hpY2ggaGF2ZSBhbGxcclxuXHQgKiBvZiB0aGUgZm9sbG93aW5nIGNoYXJhY3RlcmlzdGljczpcclxuXHQgKlxyXG5cdCAqICogT25lIG9yIG1vcmUgaW52b2NhdGlvbiBzaXRlcyBvZiB0aGUgY3VycmVudCBydWxlIHJldHVybnMgdG9cclxuXHQgKiAgICpTKi5cclxuXHQgKiAqIFRoZSBjbG9zdXJlIGZyb20gKlMqIGluY2x1ZGVzIHRoZSBjdXJyZW50IGRlY2lzaW9uIHdpdGhvdXRcclxuXHQgKiAgIHBhc3NpbmcgdGhyb3VnaCBhbnkgcnVsZSBpbnZvY2F0aW9ucyBvciBzdGVwcGluZyBvdXQgb2YgdGhlIGN1cnJlbnRcclxuXHQgKiAgIHJ1bGUuXHJcblx0ICpcclxuXHQgKiBUaGlzIGZpZWxkIGlzIG5vdCB1c2VkIHdoZW4ge0BsaW5rICNwcmVjZWRlbmNlUnVsZURlY2lzaW9ufSBpc1xyXG5cdCAqIGBmYWxzZWAuXHJcblx0ICovXHJcblx0cHVibGljIHByZWNlZGVuY2VMb29wYmFja1N0YXRlczogQml0U2V0ID0gbmV3IEJpdFNldCgpO1xyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhdGVUeXBlKCk6IEFUTlN0YXRlVHlwZSB7XHJcblx0XHRyZXR1cm4gQVROU3RhdGVUeXBlLlNUQVJfTE9PUF9FTlRSWTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM4LjM1NjcwOTQtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFycmF5MkRIYXNoU2V0IH0gZnJvbSBcIi4uL21pc2MvQXJyYXkyREhhc2hTZXRcIjtcclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4uL2F0bi9BVE5cIjtcclxuaW1wb3J0IHsgQVROQ29uZmlnU2V0IH0gZnJvbSBcIi4uL2F0bi9BVE5Db25maWdTZXRcIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi4vYXRuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEFUTlR5cGUgfSBmcm9tIFwiLi4vYXRuL0FUTlR5cGVcIjtcclxuaW1wb3J0IHsgRGVjaXNpb25TdGF0ZSB9IGZyb20gXCIuLi9hdG4vRGVjaXNpb25TdGF0ZVwiO1xyXG5pbXBvcnQgeyBERkFTZXJpYWxpemVyIH0gZnJvbSBcIi4vREZBU2VyaWFsaXplclwiO1xyXG5pbXBvcnQgeyBERkFTdGF0ZSB9IGZyb20gXCIuL0RGQVN0YXRlXCI7XHJcbmltcG9ydCB7IExleGVyQVROU2ltdWxhdG9yIH0gZnJvbSBcIi4uL2F0bi9MZXhlckFUTlNpbXVsYXRvclwiO1xyXG5pbXBvcnQgeyBMZXhlckRGQVNlcmlhbGl6ZXIgfSBmcm9tIFwiLi9MZXhlckRGQVNlcmlhbGl6ZXJcIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuLi9taXNjL09iamVjdEVxdWFsaXR5Q29tcGFyYXRvclwiO1xyXG5pbXBvcnQgeyBTdGFyTG9vcEVudHJ5U3RhdGUgfSBmcm9tIFwiLi4vYXRuL1N0YXJMb29wRW50cnlTdGF0ZVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBUb2tlbnNTdGFydFN0YXRlIH0gZnJvbSBcIi4uL2F0bi9Ub2tlbnNTdGFydFN0YXRlXCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnkgfSBmcm9tIFwiLi4vVm9jYWJ1bGFyeVwiO1xyXG5pbXBvcnQgeyBWb2NhYnVsYXJ5SW1wbCB9IGZyb20gXCIuLi9Wb2NhYnVsYXJ5SW1wbFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIERGQSB7XHJcblx0LyoqXHJcblx0ICogQSBzZXQgb2YgYWxsIHN0YXRlcyBpbiB0aGUgYERGQWAuXHJcblx0ICpcclxuXHQgKiBOb3RlIHRoYXQgdGhpcyBjb2xsZWN0aW9uIG9mIHN0YXRlcyBob2xkcyB0aGUgREZBIHN0YXRlcyBmb3IgYm90aCBTTEwgYW5kIExMIHByZWRpY3Rpb24uIE9ubHkgdGhlIHN0YXJ0IHN0YXRlXHJcblx0ICogbmVlZHMgdG8gYmUgZGlmZmVyZW50aWF0ZWQgZm9yIHRoZXNlIGNhc2VzLCB3aGljaCBpcyB0cmFja2VkIGJ5IHRoZSBgczBgIGFuZCBgczBmdWxsYCBmaWVsZHMuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgcmVhZG9ubHkgc3RhdGVzOiBBcnJheTJESGFzaFNldDxERkFTdGF0ZT4gPSBuZXcgQXJyYXkyREhhc2hTZXQ8REZBU3RhdGU+KE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSk7XHJcblxyXG5cdHB1YmxpYyBzMDogREZBU3RhdGUgfCB1bmRlZmluZWQ7XHJcblxyXG5cdHB1YmxpYyBzMGZ1bGw6IERGQVN0YXRlIHwgdW5kZWZpbmVkO1xyXG5cclxuXHRwdWJsaWMgcmVhZG9ubHkgZGVjaXNpb246IG51bWJlcjtcclxuXHJcblx0LyoqIEZyb20gd2hpY2ggQVROIHN0YXRlIGRpZCB3ZSBjcmVhdGUgdGhpcyBERkE/ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgYXRuU3RhcnRTdGF0ZTogQVROU3RhdGU7XHJcblx0LyoqXHJcblx0ICogTm90ZTogdGhpcyBmaWVsZCBpcyBhY2Nlc3NlZCBhcyBgYXRuU3RhcnRTdGF0ZS5hdG5gIGluIG90aGVyIHRhcmdldHMuIFRoZSBUeXBlU2NyaXB0IHRhcmdldCBrZWVwcyBhIHNlcGFyYXRlIGNvcHlcclxuXHQgKiB0byBhdm9pZCBhIG51bWJlciBvZiBhZGRpdGlvbmFsIG51bGwvdW5kZWZpbmVkIGNoZWNrcyBlYWNoIHRpbWUgdGhlIEFUTiBpcyBhY2Nlc3NlZC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBhdG46IEFUTjtcclxuXHJcblx0cHJpdmF0ZSBuZXh0U3RhdGVOdW1iZXI6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIGB0cnVlYCBpZiB0aGlzIERGQSBpcyBmb3IgYSBwcmVjZWRlbmNlIGRlY2lzaW9uOyBvdGhlcndpc2UsXHJcblx0ICogYGZhbHNlYC4gVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3Ige0BsaW5rICNpc1ByZWNlZGVuY2VEZmF9LlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgcHJlY2VkZW5jZURmYTogYm9vbGVhbjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIGBERkFgIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCBhIGxleGVyIG1vZGUuXHJcblx0ICpcclxuXHQgKiBUaGUgc3RhcnQgc3RhdGUgZm9yIGEgYERGQWAgY29uc3RydWN0ZWQgd2l0aCB0aGlzIGNvbnN0cnVjdG9yIHNob3VsZCBiZSBhIGBUb2tlbnNTdGFydFN0YXRlYCwgd2hpY2ggaXMgdGhlIHN0YXJ0XHJcblx0ICogc3RhdGUgZm9yIGEgbGV4ZXIgbW9kZS4gVGhlIHByZWRpY3Rpb24gbWFkZSBieSB0aGlzIERGQSBkZXRlcm1pbmVzIHRoZSBsZXhlciBydWxlIHdoaWNoIG1hdGNoZXMgdGhlIGN1cnJlbnRcclxuXHQgKiBpbnB1dC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBhdG5TdGFydFN0YXRlIFRoZSBzdGFydCBzdGF0ZSBmb3IgdGhlIG1vZGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoYXRuU3RhcnRTdGF0ZTogVG9rZW5zU3RhcnRTdGF0ZSk7XHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIGBERkFgIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCBhIGRlY2lzaW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGF0blN0YXJ0U3RhdGUgVGhlIGRlY2lzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIERGQS5cclxuXHQgKiBAcGFyYW0gZGVjaXNpb24gVGhlIGRlY2lzaW9uIG51bWJlci5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihhdG5TdGFydFN0YXRlOiBEZWNpc2lvblN0YXRlLCBkZWNpc2lvbjogbnVtYmVyKTtcclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCBhdG5TdGFydFN0YXRlOiBBVE5TdGF0ZSwgZGVjaXNpb246IG51bWJlciA9IDApIHtcclxuXHRcdGlmICghYXRuU3RhcnRTdGF0ZS5hdG4pIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIEFUTlN0YXRlIG11c3QgYmUgYXNzb2NpYXRlZCB3aXRoIGFuIEFUTlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmF0blN0YXJ0U3RhdGUgPSBhdG5TdGFydFN0YXRlO1xyXG5cdFx0dGhpcy5hdG4gPSBhdG5TdGFydFN0YXRlLmF0bjtcclxuXHRcdHRoaXMuZGVjaXNpb24gPSBkZWNpc2lvbjtcclxuXHJcblx0XHQvLyBQcmVjZWRlbmNlIERGQXMgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lhbCBwcmVjZWRlbmNlIGRlY2lzaW9uIGNyZWF0ZWQgZm9yIGxlZnQtcmVjdXJzaXZlIHJ1bGVzIHdoaWNoXHJcblx0XHQvLyBldmFsdWF0ZSB0aGVpciBhbHRlcm5hdGl2ZXMgdXNpbmcgYSBwcmVjZWRlbmNlIGhpZXJhcmNoeS4gV2hlbiBzdWNoIGEgZGVjaXNpb24gaXMgZW5jb3VudGVyZWQsIHdlIG1hcmsgdGhpc1xyXG5cdFx0Ly8gREZBIGluc3RhbmNlIGFzIGEgcHJlY2VkZW5jZSBERkEgYW5kIGluaXRpYWxpemUgdGhlIGluaXRpYWwgc3RhdGVzIHMwIGFuZCBzMGZ1bGwgdG8gc3BlY2lhbCBERkFTdGF0ZVxyXG5cdFx0Ly8gaW5zdGFuY2VzIHdoaWNoIHVzZSBvdXRnb2luZyBlZGdlcyB0byBsaW5rIHRvIHRoZSBhY3R1YWwgc3RhcnQgc3RhdGUgdXNlZCBmb3IgZWFjaCBwcmVjZWRlbmNlIGxldmVsLlxyXG5cdFx0bGV0IGlzUHJlY2VkZW5jZURmYTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdFx0aWYgKGF0blN0YXJ0U3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGUpIHtcclxuXHRcdFx0aWYgKGF0blN0YXJ0U3RhdGUucHJlY2VkZW5jZVJ1bGVEZWNpc2lvbikge1xyXG5cdFx0XHRcdGlzUHJlY2VkZW5jZURmYSA9IHRydWU7XHJcblx0XHRcdFx0dGhpcy5zMCA9IG5ldyBERkFTdGF0ZShuZXcgQVROQ29uZmlnU2V0KCkpO1xyXG5cdFx0XHRcdHRoaXMuczBmdWxsID0gbmV3IERGQVN0YXRlKG5ldyBBVE5Db25maWdTZXQoKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnByZWNlZGVuY2VEZmEgPSBpc1ByZWNlZGVuY2VEZmE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHdoZXRoZXIgdGhpcyBERkEgaXMgYSBwcmVjZWRlbmNlIERGQS4gUHJlY2VkZW5jZSBERkFzIHVzZSBhIHNwZWNpYWxcclxuXHQgKiBzdGFydCBzdGF0ZSB7QGxpbmsgI3MwfSB3aGljaCBpcyBub3Qgc3RvcmVkIGluIHtAbGluayAjc3RhdGVzfS4gVGhlXHJcblx0ICoge0BsaW5rIERGQVN0YXRlI2VkZ2VzfSBhcnJheSBmb3IgdGhpcyBzdGFydCBzdGF0ZSBjb250YWlucyBvdXRnb2luZyBlZGdlc1xyXG5cdCAqIHN1cHBseWluZyBpbmRpdmlkdWFsIHN0YXJ0IHN0YXRlcyBjb3JyZXNwb25kaW5nIHRvIHNwZWNpZmljIHByZWNlZGVuY2VcclxuXHQgKiB2YWx1ZXMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBpcyBhIHByZWNlZGVuY2UgREZBOyBvdGhlcndpc2UsXHJcblx0ICogYGZhbHNlYC5cclxuXHQgKiBAc2VlIFBhcnNlci5wcmVjZWRlbmNlXHJcblx0ICovXHJcblx0Z2V0IGlzUHJlY2VkZW5jZURmYSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnByZWNlZGVuY2VEZmE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHN0YXJ0IHN0YXRlIGZvciBhIHNwZWNpZmljIHByZWNlZGVuY2UgdmFsdWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcHJlY2VkZW5jZSBUaGUgY3VycmVudCBwcmVjZWRlbmNlLlxyXG5cdCAqIEByZXR1cm5zIFRoZSBzdGFydCBzdGF0ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzcGVjaWZpZWQgcHJlY2VkZW5jZSwgb3JcclxuXHQgKiBgdW5kZWZpbmVkYCBpZiBubyBzdGFydCBzdGF0ZSBleGlzdHMgZm9yIHRoZSBzcGVjaWZpZWQgcHJlY2VkZW5jZS5cclxuXHQgKlxyXG5cdCAqIEAgaWYgdGhpcyBpcyBub3QgYSBwcmVjZWRlbmNlIERGQS5cclxuXHQgKiBAc2VlIGBpc1ByZWNlZGVuY2VEZmFgXHJcblx0ICovXHJcblx0cHVibGljIGdldFByZWNlZGVuY2VTdGFydFN0YXRlKHByZWNlZGVuY2U6IG51bWJlciwgZnVsbENvbnRleHQ6IGJvb2xlYW4pOiBERkFTdGF0ZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAoIXRoaXMuaXNQcmVjZWRlbmNlRGZhKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk9ubHkgcHJlY2VkZW5jZSBERkFzIG1heSBjb250YWluIGEgcHJlY2VkZW5jZSBzdGFydCBzdGF0ZS5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gczAgYW5kIHMwZnVsbCBhcmUgbmV2ZXIgbnVsbCBmb3IgYSBwcmVjZWRlbmNlIERGQVxyXG5cdFx0aWYgKGZ1bGxDb250ZXh0KSB7XHJcblx0XHRcdHJldHVybiAodGhpcy5zMGZ1bGwgYXMgREZBU3RhdGUpLmdldFRhcmdldChwcmVjZWRlbmNlKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gKHRoaXMuczAgYXMgREZBU3RhdGUpLmdldFRhcmdldChwcmVjZWRlbmNlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgc3RhcnQgc3RhdGUgZm9yIGEgc3BlY2lmaWMgcHJlY2VkZW5jZSB2YWx1ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBwcmVjZWRlbmNlIFRoZSBjdXJyZW50IHByZWNlZGVuY2UuXHJcblx0ICogQHBhcmFtIHN0YXJ0U3RhdGUgVGhlIHN0YXJ0IHN0YXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZFxyXG5cdCAqIHByZWNlZGVuY2UuXHJcblx0ICpcclxuXHQgKiBAIGlmIHRoaXMgaXMgbm90IGEgcHJlY2VkZW5jZSBERkEuXHJcblx0ICogQHNlZSBgaXNQcmVjZWRlbmNlRGZhYFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzZXRQcmVjZWRlbmNlU3RhcnRTdGF0ZShwcmVjZWRlbmNlOiBudW1iZXIsIGZ1bGxDb250ZXh0OiBib29sZWFuLCBzdGFydFN0YXRlOiBERkFTdGF0ZSk6IHZvaWQge1xyXG5cdFx0aWYgKCF0aGlzLmlzUHJlY2VkZW5jZURmYSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHByZWNlZGVuY2UgREZBcyBtYXkgY29udGFpbiBhIHByZWNlZGVuY2Ugc3RhcnQgc3RhdGUuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcmVjZWRlbmNlIDwgMCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGZ1bGxDb250ZXh0KSB7XHJcblx0XHRcdC8vIHMwZnVsbCBpcyBuZXZlciBudWxsIGZvciBhIHByZWNlZGVuY2UgREZBXHJcblx0XHRcdCh0aGlzLnMwZnVsbCBhcyBERkFTdGF0ZSkuc2V0VGFyZ2V0KHByZWNlZGVuY2UsIHN0YXJ0U3RhdGUpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdC8vIHMwIGlzIG5ldmVyIG51bGwgZm9yIGEgcHJlY2VkZW5jZSBERkFcclxuXHRcdFx0KHRoaXMuczAgYXMgREZBU3RhdGUpLnNldFRhcmdldChwcmVjZWRlbmNlLCBzdGFydFN0YXRlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGdldCBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKHRoaXMuaXNQcmVjZWRlbmNlRGZhKSB7XHJcblx0XHRcdC8vIHMwIGFuZCBzMGZ1bGwgYXJlIG5ldmVyIG51bGwgZm9yIGEgcHJlY2VkZW5jZSBERkFcclxuXHRcdFx0cmV0dXJuIHRoaXMuczAhLmdldEVkZ2VNYXAoKS5zaXplID09PSAwICYmIHRoaXMuczBmdWxsIS5nZXRFZGdlTWFwKCkuc2l6ZSA9PT0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zMCA9PSBudWxsICYmIHRoaXMuczBmdWxsID09IG51bGw7XHJcblx0fVxyXG5cclxuXHRnZXQgaXNDb250ZXh0U2Vuc2l0aXZlKCk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKHRoaXMuaXNQcmVjZWRlbmNlRGZhKSB7XHJcblx0XHRcdC8vIHMwZnVsbCBpcyBuZXZlciBudWxsIGZvciBhIHByZWNlZGVuY2UgREZBXHJcblx0XHRcdHJldHVybiAodGhpcy5zMGZ1bGwgYXMgREZBU3RhdGUpLmdldEVkZ2VNYXAoKS5zaXplID4gMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zMGZ1bGwgIT0gbnVsbDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhZGRTdGF0ZShzdGF0ZTogREZBU3RhdGUpOiBERkFTdGF0ZSB7XHJcblx0XHRzdGF0ZS5zdGF0ZU51bWJlciA9IHRoaXMubmV4dFN0YXRlTnVtYmVyKys7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZXMuZ2V0T3JBZGQoc3RhdGUpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZztcclxuXHRwdWJsaWMgdG9TdHJpbmcoLypATm90TnVsbCovIHZvY2FidWxhcnk6IFZvY2FidWxhcnkpOiBzdHJpbmc7XHJcblx0cHVibGljIHRvU3RyaW5nKC8qQE5vdE51bGwqLyB2b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5LCBydWxlTmFtZXM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkKTogc3RyaW5nO1xyXG5cdHB1YmxpYyB0b1N0cmluZyh2b2NhYnVsYXJ5PzogVm9jYWJ1bGFyeSwgcnVsZU5hbWVzPzogc3RyaW5nW10pOiBzdHJpbmcge1xyXG5cdFx0aWYgKCF2b2NhYnVsYXJ5KSB7XHJcblx0XHRcdHZvY2FidWxhcnkgPSBWb2NhYnVsYXJ5SW1wbC5FTVBUWV9WT0NBQlVMQVJZO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5zMCkge1xyXG5cdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgc2VyaWFsaXplcjogREZBU2VyaWFsaXplcjtcclxuXHRcdGlmIChydWxlTmFtZXMpIHtcclxuXHRcdFx0c2VyaWFsaXplciA9IG5ldyBERkFTZXJpYWxpemVyKHRoaXMsIHZvY2FidWxhcnksIHJ1bGVOYW1lcywgdGhpcy5hdG5TdGFydFN0YXRlLmF0bik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzZXJpYWxpemVyID0gbmV3IERGQVNlcmlhbGl6ZXIodGhpcywgdm9jYWJ1bGFyeSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNlcmlhbGl6ZXIudG9TdHJpbmcoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b0xleGVyU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRpZiAoIXRoaXMuczApIHtcclxuXHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHNlcmlhbGl6ZXI6IERGQVNlcmlhbGl6ZXIgPSBuZXcgTGV4ZXJERkFTZXJpYWxpemVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHNlcmlhbGl6ZXIudG9TdHJpbmcoKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI3LjgzODk5MzAtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmFzaWNTdGF0ZSBleHRlbmRzIEFUTlN0YXRlIHtcclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHN0YXRlVHlwZSgpOiBBVE5TdGF0ZVR5cGUge1xyXG5cdFx0cmV0dXJuIEFUTlN0YXRlVHlwZS5CQVNJQztcclxuXHR9XHJcblxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IEJhc2ljU3RhdGUgfSBmcm9tIFwiLi9CYXNpY1N0YXRlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW52YWxpZFN0YXRlIGV4dGVuZHMgQmFzaWNTdGF0ZSB7XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdGF0ZVR5cGUoKTogQVROU3RhdGVUeXBlIHtcclxuXHRcdHJldHVybiBBVE5TdGF0ZVR5cGUuSU5WQUxJRF9UWVBFO1xyXG5cdH1cclxuXHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM3LjMwNjAxMzUtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWxTZXQgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFNldFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSwgTm90TnVsbCwgTnVsbGFibGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcblxyXG4vKiogQSB0cmFuc2l0aW9uIGNvbnRhaW5pbmcgYSBzZXQgb2YgdmFsdWVzLiAqL1xyXG5leHBvcnQgY2xhc3MgU2V0VHJhbnNpdGlvbiBleHRlbmRzIFRyYW5zaXRpb24ge1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHNldDogSW50ZXJ2YWxTZXQ7XHJcblxyXG5cdC8vIFRPRE8gKHNhbSk6IHNob3VsZCB3ZSByZWFsbHkgYWxsb3cgdW5kZWZpbmVkIGhlcmU/XHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgdGFyZ2V0OiBBVE5TdGF0ZSwgQE51bGxhYmxlIHNldDogSW50ZXJ2YWxTZXQpIHtcclxuXHRcdHN1cGVyKHRhcmdldCk7XHJcblx0XHRpZiAoc2V0ID09IG51bGwpIHtcclxuXHRcdFx0c2V0ID0gSW50ZXJ2YWxTZXQub2YoVG9rZW4uSU5WQUxJRF9UWVBFKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldCA9IHNldDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzZXJpYWxpemF0aW9uVHlwZSgpOiBUcmFuc2l0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gVHJhbnNpdGlvblR5cGUuU0VUO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0QE5vdE51bGxcclxuXHRnZXQgbGFiZWwoKTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG1hdGNoZXMoc3ltYm9sOiBudW1iZXIsIG1pblZvY2FiU3ltYm9sOiBudW1iZXIsIG1heFZvY2FiU3ltYm9sOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnNldC5jb250YWlucyhzeW1ib2wpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLnNldC50b1N0cmluZygpO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzAuODQ4MzYxNy0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbFNldCB9IGZyb20gXCIuLi9taXNjL0ludGVydmFsU2V0XCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlLCBOb3ROdWxsLCBOdWxsYWJsZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFNldFRyYW5zaXRpb24gfSBmcm9tIFwiLi9TZXRUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tIFwiLi9UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25UeXBlIH0gZnJvbSBcIi4vVHJhbnNpdGlvblR5cGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBOb3RTZXRUcmFuc2l0aW9uIGV4dGVuZHMgU2V0VHJhbnNpdGlvbiB7XHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgdGFyZ2V0OiBBVE5TdGF0ZSwgQE51bGxhYmxlIHNldDogSW50ZXJ2YWxTZXQpIHtcclxuXHRcdHN1cGVyKHRhcmdldCwgc2V0KTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzZXJpYWxpemF0aW9uVHlwZSgpOiBUcmFuc2l0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gVHJhbnNpdGlvblR5cGUuTk9UX1NFVDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBtYXRjaGVzKHN5bWJvbDogbnVtYmVyLCBtaW5Wb2NhYlN5bWJvbDogbnVtYmVyLCBtYXhWb2NhYlN5bWJvbDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gc3ltYm9sID49IG1pblZvY2FiU3ltYm9sXHJcblx0XHRcdCYmIHN5bWJvbCA8PSBtYXhWb2NhYlN5bWJvbFxyXG5cdFx0XHQmJiAhc3VwZXIubWF0Y2hlcyhzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCBtYXhWb2NhYlN5bWJvbCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIn5cIiArIHN1cGVyLnRvU3RyaW5nKCk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNi43NTEzODU2LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlVHlwZSB9IGZyb20gXCIuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKiogVGhlIGxhc3Qgbm9kZSBpbiB0aGUgQVROIGZvciBhIHJ1bGUsIHVubGVzcyB0aGF0IHJ1bGUgaXMgdGhlIHN0YXJ0IHN5bWJvbC5cclxuICogIEluIHRoYXQgY2FzZSwgdGhlcmUgaXMgb25lIHRyYW5zaXRpb24gdG8gRU9GLiBMYXRlciwgd2UgbWlnaHQgZW5jb2RlXHJcbiAqICByZWZlcmVuY2VzIHRvIGFsbCBjYWxscyB0byB0aGlzIHJ1bGUgdG8gY29tcHV0ZSBGT0xMT1cgc2V0cyBmb3JcclxuICogIGVycm9yIGhhbmRsaW5nLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVTdG9wU3RhdGUgZXh0ZW5kcyBBVE5TdGF0ZSB7XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBub25TdG9wU3RhdGVOdW1iZXIoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdGF0ZVR5cGUoKTogQVROU3RhdGVUeXBlIHtcclxuXHRcdHJldHVybiBBVE5TdGF0ZVR5cGUuUlVMRV9TVE9QO1xyXG5cdH1cclxuXHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM2LjgyOTQ0NTMtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUsIE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBSdWxlU3RhcnRTdGF0ZSB9IGZyb20gXCIuL1J1bGVTdGFydFN0YXRlXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tIFwiLi9UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25UeXBlIH0gZnJvbSBcIi4vVHJhbnNpdGlvblR5cGVcIjtcclxuXHJcbi8qKiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVRyYW5zaXRpb24gZXh0ZW5kcyBUcmFuc2l0aW9uIHtcclxuXHQvKiogUHRyIHRvIHRoZSBydWxlIGRlZmluaXRpb24gb2JqZWN0IGZvciB0aGlzIHJ1bGUgcmVmICovXHJcblx0cHVibGljIHJ1bGVJbmRleDogbnVtYmVyOyAgICAgIC8vIG5vIFJ1bGUgb2JqZWN0IGF0IHJ1bnRpbWVcclxuXHJcblx0cHVibGljIHByZWNlZGVuY2U6IG51bWJlcjtcclxuXHJcblx0LyoqIFdoYXQgbm9kZSB0byBiZWdpbiBjb21wdXRhdGlvbnMgZm9sbG93aW5nIHJlZiB0byBydWxlICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZm9sbG93U3RhdGU6IEFUTlN0YXRlO1xyXG5cclxuXHRwdWJsaWMgdGFpbENhbGw6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwdWJsaWMgb3B0aW1pemVkVGFpbENhbGw6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgcnVsZVN0YXJ0OiBSdWxlU3RhcnRTdGF0ZSwgcnVsZUluZGV4OiBudW1iZXIsIHByZWNlZGVuY2U6IG51bWJlciwgQE5vdE51bGwgZm9sbG93U3RhdGU6IEFUTlN0YXRlKSB7XHJcblx0XHRzdXBlcihydWxlU3RhcnQpO1xyXG5cdFx0dGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XHJcblx0XHR0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlO1xyXG5cdFx0dGhpcy5mb2xsb3dTdGF0ZSA9IGZvbGxvd1N0YXRlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNlcmlhbGl6YXRpb25UeXBlKCk6IFRyYW5zaXRpb25UeXBlIHtcclxuXHRcdHJldHVybiBUcmFuc2l0aW9uVHlwZS5SVUxFO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzRXBzaWxvbigpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG1hdGNoZXMoc3ltYm9sOiBudW1iZXIsIG1pblZvY2FiU3ltYm9sOiBudW1iZXIsIG1heFZvY2FiU3ltYm9sOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM3Ljk0NTY4MzktMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUsIE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgV2lsZGNhcmRUcmFuc2l0aW9uIGV4dGVuZHMgVHJhbnNpdGlvbiB7XHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgdGFyZ2V0OiBBVE5TdGF0ZSkge1xyXG5cdFx0c3VwZXIodGFyZ2V0KTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzZXJpYWxpemF0aW9uVHlwZSgpOiBUcmFuc2l0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gVHJhbnNpdGlvblR5cGUuV0lMRENBUkQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgbWF0Y2hlcyhzeW1ib2w6IG51bWJlciwgbWluVm9jYWJTeW1ib2w6IG51bWJlciwgbWF4Vm9jYWJTeW1ib2w6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHN5bWJvbCA+PSBtaW5Wb2NhYlN5bWJvbCAmJiBzeW1ib2wgPD0gbWF4Vm9jYWJTeW1ib2w7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiLlwiO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzAuNDQ0NTM2MC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IEFycmF5MkRIYXNoU2V0IH0gZnJvbSBcIi4uL21pc2MvQXJyYXkyREhhc2hTZXRcIjtcclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vQVROXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZyB9IGZyb20gXCIuL0FUTkNvbmZpZ1wiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEJpdFNldCB9IGZyb20gXCIuLi9taXNjL0JpdFNldFwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbFNldCB9IGZyb20gXCIuLi9taXNjL0ludGVydmFsU2V0XCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBOb3RTZXRUcmFuc2l0aW9uIH0gZnJvbSBcIi4vTm90U2V0VHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi4vbWlzYy9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbkNvbnRleHQgfSBmcm9tIFwiLi9QcmVkaWN0aW9uQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBSdWxlU3RvcFN0YXRlIH0gZnJvbSBcIi4vUnVsZVN0b3BTdGF0ZVwiO1xyXG5pbXBvcnQgeyBSdWxlVHJhbnNpdGlvbiB9IGZyb20gXCIuL1J1bGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFNldFRyYW5zaXRpb24gfSBmcm9tIFwiLi9TZXRUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4uL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tIFwiLi9UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFdpbGRjYXJkVHJhbnNpdGlvbiB9IGZyb20gXCIuL1dpbGRjYXJkVHJhbnNpdGlvblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIExMMUFuYWx5emVyIHtcclxuXHQvKiogU3BlY2lhbCB2YWx1ZSBhZGRlZCB0byB0aGUgbG9va2FoZWFkIHNldHMgdG8gaW5kaWNhdGUgdGhhdCB3ZSBoaXRcclxuXHQgKiAgYSBwcmVkaWNhdGUgZHVyaW5nIGFuYWx5c2lzIGlmIGBzZWVUaHJ1UHJlZHM9PWZhbHNlYC5cclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEhJVF9QUkVEOiBudW1iZXIgPSBUb2tlbi5JTlZBTElEX1RZUEU7XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGF0bjogQVROO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCBhdG46IEFUTikgeyB0aGlzLmF0biA9IGF0bjsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxjdWxhdGVzIHRoZSBTTEwoMSkgZXhwZWN0ZWQgbG9va2FoZWFkIHNldCBmb3IgZWFjaCBvdXRnb2luZyB0cmFuc2l0aW9uXHJcblx0ICogb2YgYW4ge0BsaW5rIEFUTlN0YXRlfS4gVGhlIHJldHVybmVkIGFycmF5IGhhcyBvbmUgZWxlbWVudCBmb3IgZWFjaFxyXG5cdCAqIG91dGdvaW5nIHRyYW5zaXRpb24gaW4gYHNgLiBJZiB0aGUgY2xvc3VyZSBmcm9tIHRyYW5zaXRpb25cclxuXHQgKiAqaSogbGVhZHMgdG8gYSBzZW1hbnRpYyBwcmVkaWNhdGUgYmVmb3JlIG1hdGNoaW5nIGEgc3ltYm9sLCB0aGVcclxuXHQgKiBlbGVtZW50IGF0IGluZGV4ICppKiBvZiB0aGUgcmVzdWx0IHdpbGwgYmUgYHVuZGVmaW5lZGAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcyB0aGUgQVROIHN0YXRlXHJcblx0ICogQHJldHVybnMgdGhlIGV4cGVjdGVkIHN5bWJvbHMgZm9yIGVhY2ggb3V0Z29pbmcgdHJhbnNpdGlvbiBvZiBgc2AuXHJcblx0ICovXHJcblx0cHVibGljIGdldERlY2lzaW9uTG9va2FoZWFkKHM6IEFUTlN0YXRlIHwgdW5kZWZpbmVkKTogQXJyYXk8SW50ZXJ2YWxTZXQgfCB1bmRlZmluZWQ+IHwgdW5kZWZpbmVkIHtcclxuLy9cdFx0U3lzdGVtLm91dC5wcmludGxuKFwiTE9PSyhcIitzLnN0YXRlTnVtYmVyK1wiKVwiKTtcclxuXHRcdGlmIChzID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbG9vazogQXJyYXk8SW50ZXJ2YWxTZXQgfCB1bmRlZmluZWQ+ID0gbmV3IEFycmF5PEludGVydmFsU2V0PihzLm51bWJlck9mVHJhbnNpdGlvbnMpO1xyXG5cdFx0Zm9yIChsZXQgYWx0ID0gMDsgYWx0IDwgcy5udW1iZXJPZlRyYW5zaXRpb25zOyBhbHQrKykge1xyXG5cdFx0XHRsZXQgY3VycmVudDogSW50ZXJ2YWxTZXQgfCB1bmRlZmluZWQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdFx0bG9va1thbHRdID0gY3VycmVudDtcclxuXHRcdFx0bGV0IGxvb2tCdXN5OiBBcnJheTJESGFzaFNldDxBVE5Db25maWc+ID0gbmV3IEFycmF5MkRIYXNoU2V0PEFUTkNvbmZpZz4oT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcclxuXHRcdFx0bGV0IHNlZVRocnVQcmVkczogYm9vbGVhbiA9IGZhbHNlOyAvLyBmYWlsIHRvIGdldCBsb29rYWhlYWQgdXBvbiBwcmVkXHJcblx0XHRcdHRoaXMuX0xPT0socy50cmFuc2l0aW9uKGFsdCkudGFyZ2V0LCB1bmRlZmluZWQsIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMLFxyXG5cdFx0XHRcdGN1cnJlbnQsIGxvb2tCdXN5LCBuZXcgQml0U2V0KCksIHNlZVRocnVQcmVkcywgZmFsc2UpO1xyXG5cdFx0XHQvLyBXaXBlIG91dCBsb29rYWhlYWQgZm9yIHRoaXMgYWx0ZXJuYXRpdmUgaWYgd2UgZm91bmQgbm90aGluZ1xyXG5cdFx0XHQvLyBvciB3ZSBoYWQgYSBwcmVkaWNhdGUgd2hlbiB3ZSAhc2VlVGhydVByZWRzXHJcblx0XHRcdGlmIChjdXJyZW50LnNpemUgPT09IDAgfHwgY3VycmVudC5jb250YWlucyhMTDFBbmFseXplci5ISVRfUFJFRCkpIHtcclxuXHRcdFx0XHRjdXJyZW50ID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdGxvb2tbYWx0XSA9IGN1cnJlbnQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBsb29rO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29tcHV0ZSBzZXQgb2YgdG9rZW5zIHRoYXQgY2FuIGZvbGxvdyBgc2AgaW4gdGhlIEFUTiBpbiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgYGN0eGAuXHJcblx0ICpcclxuXHQgKiBJZiBgY3R4YCBpcyBgdW5kZWZpbmVkYCBhbmQgdGhlIGVuZCBvZiB0aGUgcnVsZSBjb250YWluaW5nXHJcblx0ICogYHNgIGlzIHJlYWNoZWQsIHtAbGluayBUb2tlbiNFUFNJTE9OfSBpcyBhZGRlZCB0byB0aGUgcmVzdWx0IHNldC5cclxuXHQgKiBJZiBgY3R4YCBpcyBub3QgYHVuZGVmaW5lZGAgYW5kIHRoZSBlbmQgb2YgdGhlIG91dGVybW9zdCBydWxlIGlzXHJcblx0ICogcmVhY2hlZCwge0BsaW5rIFRva2VuI0VPRn0gaXMgYWRkZWQgdG8gdGhlIHJlc3VsdCBzZXQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcyB0aGUgQVROIHN0YXRlXHJcblx0ICogQHBhcmFtIGN0eCB0aGUgY29tcGxldGUgcGFyc2VyIGNvbnRleHQsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBjb250ZXh0XHJcblx0ICogc2hvdWxkIGJlIGlnbm9yZWRcclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBzZXQgb2YgdG9rZW5zIHRoYXQgY2FuIGZvbGxvdyBgc2AgaW4gdGhlIEFUTiBpbiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgYGN0eGAuXHJcblx0ICovXHJcblx0Ly8gQE5vdE51bGxcclxuXHRwdWJsaWMgTE9PSygvKkBOb3ROdWxsKi8gczogQVROU3RhdGUsIC8qQE5vdE51bGwqLyBjdHg6IFByZWRpY3Rpb25Db250ZXh0KTogSW50ZXJ2YWxTZXQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGUgc2V0IG9mIHRva2VucyB0aGF0IGNhbiBmb2xsb3cgYHNgIGluIHRoZSBBVE4gaW4gdGhlXHJcblx0ICogc3BlY2lmaWVkIGBjdHhgLlxyXG5cdCAqXHJcblx0ICogSWYgYGN0eGAgaXMgYHVuZGVmaW5lZGAgYW5kIHRoZSBlbmQgb2YgdGhlIHJ1bGUgY29udGFpbmluZ1xyXG5cdCAqIGBzYCBpcyByZWFjaGVkLCB7QGxpbmsgVG9rZW4jRVBTSUxPTn0gaXMgYWRkZWQgdG8gdGhlIHJlc3VsdCBzZXQuXHJcblx0ICogSWYgYGN0eGAgaXMgbm90IGBQcmVkaWN0aW9uQ29udGV4dCNFTVBUWV9MT0NBTGAgYW5kIHRoZSBlbmQgb2YgdGhlIG91dGVybW9zdCBydWxlIGlzXHJcblx0ICogcmVhY2hlZCwge0BsaW5rIFRva2VuI0VPRn0gaXMgYWRkZWQgdG8gdGhlIHJlc3VsdCBzZXQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcyB0aGUgQVROIHN0YXRlXHJcblx0ICogQHBhcmFtIHN0b3BTdGF0ZSB0aGUgQVROIHN0YXRlIHRvIHN0b3AgYXQuIFRoaXMgY2FuIGJlIGFcclxuXHQgKiB7QGxpbmsgQmxvY2tFbmRTdGF0ZX0gdG8gZGV0ZWN0IGVwc2lsb24gcGF0aHMgdGhyb3VnaCBhIGNsb3N1cmUuXHJcblx0ICogQHBhcmFtIGN0eCB0aGUgY29tcGxldGUgcGFyc2VyIGNvbnRleHQsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBjb250ZXh0XHJcblx0ICogc2hvdWxkIGJlIGlnbm9yZWRcclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBzZXQgb2YgdG9rZW5zIHRoYXQgY2FuIGZvbGxvdyBgc2AgaW4gdGhlIEFUTiBpbiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgYGN0eGAuXHJcblx0ICovXHJcblx0Ly8gQE5vdE51bGxcclxuXHRwdWJsaWMgTE9PSygvKkBOb3ROdWxsKi8gczogQVROU3RhdGUsIC8qQE5vdE51bGwqLyBjdHg6IFByZWRpY3Rpb25Db250ZXh0LCBzdG9wU3RhdGU6IEFUTlN0YXRlIHwgbnVsbCk6IEludGVydmFsU2V0O1xyXG5cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBMT09LKEBOb3ROdWxsIHM6IEFUTlN0YXRlLCBATm90TnVsbCBjdHg6IFByZWRpY3Rpb25Db250ZXh0LCBzdG9wU3RhdGU/OiBBVE5TdGF0ZSB8IG51bGwpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRpZiAoc3RvcFN0YXRlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aWYgKHMuYXRuID09IG51bGwpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlXCIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdG9wU3RhdGUgPSBzLmF0bi5ydWxlVG9TdG9wU3RhdGVbcy5ydWxlSW5kZXhdO1xyXG5cdFx0fSBlbHNlIGlmIChzdG9wU3RhdGUgPT09IG51bGwpIHtcclxuXHRcdFx0Ly8gVGhpcyBpcyBhbiBleHBsaWNpdCByZXF1ZXN0IHRvIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBzdG9wU3RhdGUgdG8gX0xPT0suIFVzZWQgdG8gZGlzdGluZ3Vpc2ggYW4gb3ZlcmxvYWRcclxuXHRcdFx0Ly8gZnJvbSB0aGUgbWV0aG9kIHdoaWNoIHNpbXBseSBvbWl0cyB0aGUgc3RvcFN0YXRlIHBhcmFtZXRlci5cclxuXHRcdFx0c3RvcFN0YXRlID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByOiBJbnRlcnZhbFNldCA9IG5ldyBJbnRlcnZhbFNldCgpO1xyXG5cdFx0bGV0IHNlZVRocnVQcmVkczogYm9vbGVhbiA9IHRydWU7IC8vIGlnbm9yZSBwcmVkczsgZ2V0IGFsbCBsb29rYWhlYWRcclxuXHRcdGxldCBhZGRFT0Y6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdFx0dGhpcy5fTE9PSyhzLCBzdG9wU3RhdGUsIGN0eCwgciwgbmV3IEFycmF5MkRIYXNoU2V0PEFUTkNvbmZpZz4oKSwgbmV3IEJpdFNldCgpLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XHJcblx0XHRyZXR1cm4gcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGUgc2V0IG9mIHRva2VucyB0aGF0IGNhbiBmb2xsb3cgYHNgIGluIHRoZSBBVE4gaW4gdGhlXHJcblx0ICogc3BlY2lmaWVkIGBjdHhgLlxyXG5cdCAqIDxwLz5cclxuXHQgKiBJZiBgY3R4YCBpcyB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHQjRU1QVFlfTE9DQUx9IGFuZFxyXG5cdCAqIGBzdG9wU3RhdGVgIG9yIHRoZSBlbmQgb2YgdGhlIHJ1bGUgY29udGFpbmluZyBgc2AgaXMgcmVhY2hlZCxcclxuXHQgKiB7QGxpbmsgVG9rZW4jRVBTSUxPTn0gaXMgYWRkZWQgdG8gdGhlIHJlc3VsdCBzZXQuIElmIGBjdHhgIGlzIG5vdFxyXG5cdCAqIHtAbGluayBQcmVkaWN0aW9uQ29udGV4dCNFTVBUWV9MT0NBTH0gYW5kIGBhZGRFT0ZgIGlzIGB0cnVlYFxyXG5cdCAqIGFuZCBgc3RvcFN0YXRlYCBvciB0aGUgZW5kIG9mIHRoZSBvdXRlcm1vc3QgcnVsZSBpcyByZWFjaGVkLFxyXG5cdCAqIHtAbGluayBUb2tlbiNFT0Z9IGlzIGFkZGVkIHRvIHRoZSByZXN1bHQgc2V0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHMgdGhlIEFUTiBzdGF0ZS5cclxuXHQgKiBAcGFyYW0gc3RvcFN0YXRlIHRoZSBBVE4gc3RhdGUgdG8gc3RvcCBhdC4gVGhpcyBjYW4gYmUgYVxyXG5cdCAqIHtAbGluayBCbG9ja0VuZFN0YXRlfSB0byBkZXRlY3QgZXBzaWxvbiBwYXRocyB0aHJvdWdoIGEgY2xvc3VyZS5cclxuXHQgKiBAcGFyYW0gY3R4IFRoZSBvdXRlciBjb250ZXh0LCBvciB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHQjRU1QVFlfTE9DQUx9IGlmXHJcblx0ICogdGhlIG91dGVyIGNvbnRleHQgc2hvdWxkIG5vdCBiZSB1c2VkLlxyXG5cdCAqIEBwYXJhbSBsb29rIFRoZSByZXN1bHQgbG9va2FoZWFkIHNldC5cclxuXHQgKiBAcGFyYW0gbG9va0J1c3kgQSBzZXQgdXNlZCBmb3IgcHJldmVudGluZyBlcHNpbG9uIGNsb3N1cmVzIGluIHRoZSBBVE5cclxuXHQgKiBmcm9tIGNhdXNpbmcgYSBzdGFjayBvdmVyZmxvdy4gT3V0c2lkZSBjb2RlIHNob3VsZCBwYXNzXHJcblx0ICogYG5ldyBIYXNoU2V0PEFUTkNvbmZpZz5gIGZvciB0aGlzIGFyZ3VtZW50LlxyXG5cdCAqIEBwYXJhbSBjYWxsZWRSdWxlU3RhY2sgQSBzZXQgdXNlZCBmb3IgcHJldmVudGluZyBsZWZ0IHJlY3Vyc2lvbiBpbiB0aGVcclxuXHQgKiBBVE4gZnJvbSBjYXVzaW5nIGEgc3RhY2sgb3ZlcmZsb3cuIE91dHNpZGUgY29kZSBzaG91bGQgcGFzc1xyXG5cdCAqIGBuZXcgQml0U2V0KClgIGZvciB0aGlzIGFyZ3VtZW50LlxyXG5cdCAqIEBwYXJhbSBzZWVUaHJ1UHJlZHMgYHRydWVgIHRvIHRydWUgc2VtYW50aWMgcHJlZGljYXRlcyBhc1xyXG5cdCAqIGltcGxpY2l0bHkgYHRydWVgIGFuZCBcInNlZSB0aHJvdWdoIHRoZW1cIiwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuXHQgKiB0byB0cmVhdCBzZW1hbnRpYyBwcmVkaWNhdGVzIGFzIG9wYXF1ZSBhbmQgYWRkIHtAbGluayAjSElUX1BSRUR9IHRvIHRoZVxyXG5cdCAqIHJlc3VsdCBpZiBvbmUgaXMgZW5jb3VudGVyZWQuXHJcblx0ICogQHBhcmFtIGFkZEVPRiBBZGQge0BsaW5rIFRva2VuI0VPRn0gdG8gdGhlIHJlc3VsdCBpZiB0aGUgZW5kIG9mIHRoZVxyXG5cdCAqIG91dGVybW9zdCBjb250ZXh0IGlzIHJlYWNoZWQuIFRoaXMgcGFyYW1ldGVyIGhhcyBubyBlZmZlY3QgaWYgYGN0eGBcclxuXHQgKiBpcyB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHQjRU1QVFlfTE9DQUx9LlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBfTE9PSyhcclxuXHRcdEBOb3ROdWxsIHM6IEFUTlN0YXRlLFxyXG5cdFx0c3RvcFN0YXRlOiBBVE5TdGF0ZSB8IHVuZGVmaW5lZCxcclxuXHRcdEBOb3ROdWxsIGN0eDogUHJlZGljdGlvbkNvbnRleHQsXHJcblx0XHRATm90TnVsbCBsb29rOiBJbnRlcnZhbFNldCxcclxuXHRcdEBOb3ROdWxsIGxvb2tCdXN5OiBBcnJheTJESGFzaFNldDxBVE5Db25maWc+LFxyXG5cdFx0QE5vdE51bGwgY2FsbGVkUnVsZVN0YWNrOiBCaXRTZXQsXHJcblx0XHRzZWVUaHJ1UHJlZHM6IGJvb2xlYW4sXHJcblx0XHRhZGRFT0Y6IGJvb2xlYW4pOiB2b2lkIHtcclxuLy9cdFx0U3lzdGVtLm91dC5wcmludGxuKFwiX0xPT0soXCIrcy5zdGF0ZU51bWJlcitcIiwgY3R4PVwiK2N0eCk7XHJcblx0XHRsZXQgYzogQVROQ29uZmlnID0gQVROQ29uZmlnLmNyZWF0ZShzLCAwLCBjdHgpO1xyXG5cdFx0aWYgKCFsb29rQnVzeS5hZGQoYykpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzID09PSBzdG9wU3RhdGUpIHtcclxuXHRcdFx0aWYgKFByZWRpY3Rpb25Db250ZXh0LmlzRW1wdHlMb2NhbChjdHgpKSB7XHJcblx0XHRcdFx0bG9vay5hZGQoVG9rZW4uRVBTSUxPTik7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGN0eC5pc0VtcHR5KSB7XHJcblx0XHRcdFx0aWYgKGFkZEVPRikge1xyXG5cdFx0XHRcdFx0bG9vay5hZGQoVG9rZW4uRU9GKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xyXG5cdFx0XHRpZiAoY3R4LmlzRW1wdHkgJiYgIVByZWRpY3Rpb25Db250ZXh0LmlzRW1wdHlMb2NhbChjdHgpKSB7XHJcblx0XHRcdFx0aWYgKGFkZEVPRikge1xyXG5cdFx0XHRcdFx0bG9vay5hZGQoVG9rZW4uRU9GKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHJlbW92ZWQ6IGJvb2xlYW4gPSBjYWxsZWRSdWxlU3RhY2suZ2V0KHMucnVsZUluZGV4KTtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRjYWxsZWRSdWxlU3RhY2suY2xlYXIocy5ydWxlSW5kZXgpO1xyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY3R4LnNpemU7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKGN0eC5nZXRSZXR1cm5TdGF0ZShpKSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVkpIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0IHJldHVyblN0YXRlOiBBVE5TdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tjdHguZ2V0UmV0dXJuU3RhdGUoaSldO1xyXG4vL1x0XHRcdFx0XHRTeXN0ZW0ub3V0LnByaW50bG4oXCJwb3BwaW5nIGJhY2sgdG8gXCIrcmV0U3RhdGUpO1xyXG5cdFx0XHRcdFx0dGhpcy5fTE9PSyhyZXR1cm5TdGF0ZSwgc3RvcFN0YXRlLCBjdHguZ2V0UGFyZW50KGkpLCBsb29rLCBsb29rQnVzeSwgY2FsbGVkUnVsZVN0YWNrLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGZpbmFsbHkge1xyXG5cdFx0XHRcdGlmIChyZW1vdmVkKSB7XHJcblx0XHRcdFx0XHRjYWxsZWRSdWxlU3RhY2suc2V0KHMucnVsZUluZGV4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbjogbnVtYmVyID0gcy5udW1iZXJPZlRyYW5zaXRpb25zO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0bGV0IHQ6IFRyYW5zaXRpb24gPSBzLnRyYW5zaXRpb24oaSk7XHJcblx0XHRcdGlmICh0IGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRpZiAoY2FsbGVkUnVsZVN0YWNrLmdldCh0LnJ1bGVJbmRleCkpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IG5ld0NvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0ID0gY3R4LmdldENoaWxkKHQuZm9sbG93U3RhdGUuc3RhdGVOdW1iZXIpO1xyXG5cclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0Y2FsbGVkUnVsZVN0YWNrLnNldCh0LnJ1bGVJbmRleCk7XHJcblx0XHRcdFx0XHR0aGlzLl9MT09LKHQudGFyZ2V0LCBzdG9wU3RhdGUsIG5ld0NvbnRleHQsIGxvb2ssIGxvb2tCdXN5LCBjYWxsZWRSdWxlU3RhY2ssIHNlZVRocnVQcmVkcywgYWRkRU9GKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZmluYWxseSB7XHJcblx0XHRcdFx0XHRjYWxsZWRSdWxlU3RhY2suY2xlYXIodC5ydWxlSW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh0IGluc3RhbmNlb2YgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0aWYgKHNlZVRocnVQcmVkcykge1xyXG5cdFx0XHRcdFx0dGhpcy5fTE9PSyh0LnRhcmdldCwgc3RvcFN0YXRlLCBjdHgsIGxvb2ssIGxvb2tCdXN5LCBjYWxsZWRSdWxlU3RhY2ssIHNlZVRocnVQcmVkcywgYWRkRU9GKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRsb29rLmFkZChMTDFBbmFseXplci5ISVRfUFJFRCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHQuaXNFcHNpbG9uKSB7XHJcblx0XHRcdFx0dGhpcy5fTE9PSyh0LnRhcmdldCwgc3RvcFN0YXRlLCBjdHgsIGxvb2ssIGxvb2tCdXN5LCBjYWxsZWRSdWxlU3RhY2ssIHNlZVRocnVQcmVkcywgYWRkRU9GKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh0IGluc3RhbmNlb2YgV2lsZGNhcmRUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0bG9vay5hZGRBbGwoSW50ZXJ2YWxTZXQub2YoVG9rZW4uTUlOX1VTRVJfVE9LRU5fVFlQRSwgdGhpcy5hdG4ubWF4VG9rZW5UeXBlKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcbi8vXHRcdFx0XHRTeXN0ZW0ub3V0LnByaW50bG4oXCJhZGRpbmcgXCIrIHQpO1xyXG5cdFx0XHRcdGxldCBzZXQ6IEludGVydmFsU2V0IHwgdW5kZWZpbmVkID0gdC5sYWJlbDtcclxuXHRcdFx0XHRpZiAoc2V0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGlmICh0IGluc3RhbmNlb2YgTm90U2V0VHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdFx0XHRzZXQgPSBzZXQuY29tcGxlbWVudChJbnRlcnZhbFNldC5vZihUb2tlbi5NSU5fVVNFUl9UT0tFTl9UWVBFLCB0aGlzLmF0bi5tYXhUb2tlblR5cGUpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxvb2suYWRkQWxsKHNldCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyNS4xMDYzNTEwLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBcnJheTJESGFzaE1hcCB9IGZyb20gXCIuLi9taXNjL0FycmF5MkRIYXNoTWFwXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQVROVHlwZSB9IGZyb20gXCIuL0FUTlR5cGVcIjtcclxuaW1wb3J0IHsgRGVjaXNpb25TdGF0ZSB9IGZyb20gXCIuL0RlY2lzaW9uU3RhdGVcIjtcclxuaW1wb3J0IHsgREZBIH0gZnJvbSBcIi4uL2RmYS9ERkFcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWxTZXQgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFNldFwiO1xyXG5pbXBvcnQgeyBJbnZhbGlkU3RhdGUgfSBmcm9tIFwiLi9JbnZhbGlkU3RhdGVcIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb24gfSBmcm9tIFwiLi9MZXhlckFjdGlvblwiO1xyXG5pbXBvcnQgeyBMTDFBbmFseXplciB9IGZyb20gXCIuL0xMMUFuYWx5emVyXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi4vbWlzYy9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbkNvbnRleHQgfSBmcm9tIFwiLi9QcmVkaWN0aW9uQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCIuLi9SdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBSdWxlU3RhcnRTdGF0ZSB9IGZyb20gXCIuL1J1bGVTdGFydFN0YXRlXCI7XHJcbmltcG9ydCB7IFJ1bGVTdG9wU3RhdGUgfSBmcm9tIFwiLi9SdWxlU3RvcFN0YXRlXCI7XHJcbmltcG9ydCB7IFJ1bGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vUnVsZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5zU3RhcnRTdGF0ZSB9IGZyb20gXCIuL1Rva2Vuc1N0YXJ0U3RhdGVcIjtcclxuXHJcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XHJcblxyXG4vKiogKi9cclxuZXhwb3J0IGNsYXNzIEFUTiB7XHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgcmVhZG9ubHkgc3RhdGVzOiBBVE5TdGF0ZVtdID0gW107XHJcblxyXG5cdC8qKiBFYWNoIHN1YnJ1bGUvcnVsZSBpcyBhIGRlY2lzaW9uIHBvaW50IGFuZCB3ZSBtdXN0IHRyYWNrIHRoZW0gc28gd2VcclxuXHQgKiAgY2FuIGdvIGJhY2sgbGF0ZXIgYW5kIGJ1aWxkIERGQSBwcmVkaWN0b3JzIGZvciB0aGVtLiAgVGhpcyBpbmNsdWRlc1xyXG5cdCAqICBhbGwgdGhlIHJ1bGVzLCBzdWJydWxlcywgb3B0aW9uYWwgYmxvY2tzLCAoKSssICgpKiBldGMuLi5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBkZWNpc2lvblRvU3RhdGU6IERlY2lzaW9uU3RhdGVbXSA9IFtdO1xyXG5cclxuXHQvKipcclxuXHQgKiBNYXBzIGZyb20gcnVsZSBpbmRleCB0byBzdGFydGluZyBzdGF0ZSBudW1iZXIuXHJcblx0ICovXHJcblx0cHVibGljIHJ1bGVUb1N0YXJ0U3RhdGUhOiBSdWxlU3RhcnRTdGF0ZVtdO1xyXG5cclxuXHQvKipcclxuXHQgKiBNYXBzIGZyb20gcnVsZSBpbmRleCB0byBzdG9wIHN0YXRlIG51bWJlci5cclxuXHQgKi9cclxuXHRwdWJsaWMgcnVsZVRvU3RvcFN0YXRlITogUnVsZVN0b3BTdGF0ZVtdO1xyXG5cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBtb2RlTmFtZVRvU3RhcnRTdGF0ZTogTWFwPHN0cmluZywgVG9rZW5zU3RhcnRTdGF0ZT4gPVxyXG5cdFx0bmV3IE1hcDxzdHJpbmcsIFRva2Vuc1N0YXJ0U3RhdGU+KCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSB0eXBlIG9mIHRoZSBBVE4uXHJcblx0ICovXHJcblx0cHVibGljIGdyYW1tYXJUeXBlOiBBVE5UeXBlO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgYW55IHN5bWJvbCByZWNvZ25pemVkIGJ5IGEgdHJhbnNpdGlvbiBpbiB0aGUgQVROLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBtYXhUb2tlblR5cGU6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogRm9yIGxleGVyIEFUTnMsIHRoaXMgbWFwcyB0aGUgcnVsZSBpbmRleCB0byB0aGUgcmVzdWx0aW5nIHRva2VuIHR5cGUuXHJcblx0ICogRm9yIHBhcnNlciBBVE5zLCB0aGlzIG1hcHMgdGhlIHJ1bGUgaW5kZXggdG8gdGhlIGdlbmVyYXRlZCBieXBhc3MgdG9rZW5cclxuXHQgKiB0eXBlIGlmIHRoZVxyXG5cdCAqIHtAbGluayBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zI2lzR2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnN9XHJcblx0ICogZGVzZXJpYWxpemF0aW9uIG9wdGlvbiB3YXMgc3BlY2lmaWVkOyBvdGhlcndpc2UsIHRoaXMgaXMgYHVuZGVmaW5lZGAuXHJcblx0ICovXHJcblx0cHVibGljIHJ1bGVUb1Rva2VuVHlwZSE6IEludDMyQXJyYXk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEZvciBsZXhlciBBVE5zLCB0aGlzIGlzIGFuIGFycmF5IG9mIHtAbGluayBMZXhlckFjdGlvbn0gb2JqZWN0cyB3aGljaCBtYXlcclxuXHQgKiBiZSByZWZlcmVuY2VkIGJ5IGFjdGlvbiB0cmFuc2l0aW9ucyBpbiB0aGUgQVROLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBsZXhlckFjdGlvbnMhOiBMZXhlckFjdGlvbltdO1xyXG5cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBtb2RlVG9TdGFydFN0YXRlOiBUb2tlbnNTdGFydFN0YXRlW10gPSBbXTtcclxuXHJcblx0cHJpdmF0ZSBjb250ZXh0Q2FjaGU6IEFycmF5MkRIYXNoTWFwPFByZWRpY3Rpb25Db250ZXh0LCBQcmVkaWN0aW9uQ29udGV4dD4gPVxyXG5cdFx0bmV3IEFycmF5MkRIYXNoTWFwPFByZWRpY3Rpb25Db250ZXh0LCBQcmVkaWN0aW9uQ29udGV4dD4oT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZGVjaXNpb25Ub0RGQTogREZBW10gPSBbXTtcclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBtb2RlVG9ERkE6IERGQVtdID0gW107XHJcblxyXG5cdHB1YmxpYyBMTDFUYWJsZTogTWFwPG51bWJlciwgbnVtYmVyPiA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCk7XHJcblxyXG5cdC8qKiBVc2VkIGZvciBydW50aW1lIGRlc2VyaWFsaXphdGlvbiBvZiBBVE5zIGZyb20gc3RyaW5ncyAqL1xyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIGdyYW1tYXJUeXBlOiBBVE5UeXBlLCBtYXhUb2tlblR5cGU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5ncmFtbWFyVHlwZSA9IGdyYW1tYXJUeXBlO1xyXG5cdFx0dGhpcy5tYXhUb2tlblR5cGUgPSBtYXhUb2tlblR5cGU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY2xlYXJERkEoKTogdm9pZCB7XHJcblx0XHR0aGlzLmRlY2lzaW9uVG9ERkEgPSBuZXcgQXJyYXk8REZBPih0aGlzLmRlY2lzaW9uVG9TdGF0ZS5sZW5ndGgpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlY2lzaW9uVG9ERkEubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5kZWNpc2lvblRvREZBW2ldID0gbmV3IERGQSh0aGlzLmRlY2lzaW9uVG9TdGF0ZVtpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tb2RlVG9ERkEgPSBuZXcgQXJyYXk8REZBPih0aGlzLm1vZGVUb1N0YXJ0U3RhdGUubGVuZ3RoKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tb2RlVG9ERkEubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5tb2RlVG9ERkFbaV0gPSBuZXcgREZBKHRoaXMubW9kZVRvU3RhcnRTdGF0ZVtpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb250ZXh0Q2FjaGUuY2xlYXIoKTtcclxuXHRcdHRoaXMuTEwxVGFibGUuY2xlYXIoKTtcclxuXHR9XHJcblxyXG5cdGdldCBjb250ZXh0Q2FjaGVTaXplKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Q2FjaGUuc2l6ZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRDYWNoZWRDb250ZXh0KGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0KTogUHJlZGljdGlvbkNvbnRleHQge1xyXG5cdFx0cmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LmdldENhY2hlZENvbnRleHQoY29udGV4dCwgdGhpcy5jb250ZXh0Q2FjaGUsIG5ldyBQcmVkaWN0aW9uQ29udGV4dC5JZGVudGl0eUhhc2hNYXAoKSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0RGVjaXNpb25Ub0RGQSgpOiBERkFbXSB7XHJcblx0XHRhc3NlcnQodGhpcy5kZWNpc2lvblRvREZBICE9IG51bGwgJiYgdGhpcy5kZWNpc2lvblRvREZBLmxlbmd0aCA9PT0gdGhpcy5kZWNpc2lvblRvU3RhdGUubGVuZ3RoKTtcclxuXHRcdHJldHVybiB0aGlzLmRlY2lzaW9uVG9ERkE7XHJcblx0fVxyXG5cclxuXHQvKiogQ29tcHV0ZSB0aGUgc2V0IG9mIHZhbGlkIHRva2VucyB0aGF0IGNhbiBvY2N1ciBzdGFydGluZyBpbiBzdGF0ZSBgc2AuXHJcblx0ICogIElmIGBjdHhgIGlzIHtAbGluayBQcmVkaWN0aW9uQ29udGV4dCNFTVBUWV9MT0NBTH0sIHRoZSBzZXQgb2YgdG9rZW5zIHdpbGwgbm90IGluY2x1ZGUgd2hhdCBjYW4gZm9sbG93XHJcblx0ICogIHRoZSBydWxlIHN1cnJvdW5kaW5nIGBzYC4gSW4gb3RoZXIgd29yZHMsIHRoZSBzZXQgd2lsbCBiZVxyXG5cdCAqICByZXN0cmljdGVkIHRvIHRva2VucyByZWFjaGFibGUgc3RheWluZyB3aXRoaW4gYHNgJ3MgcnVsZS5cclxuXHQgKi9cclxuXHQvLyBATm90TnVsbFxyXG5cdHB1YmxpYyBuZXh0VG9rZW5zKHM6IEFUTlN0YXRlLCAvKkBOb3ROdWxsKi8gY3R4OiBQcmVkaWN0aW9uQ29udGV4dCk6IEludGVydmFsU2V0O1xyXG5cclxuXHQvKipcclxuXHQgKiBDb21wdXRlIHRoZSBzZXQgb2YgdmFsaWQgdG9rZW5zIHRoYXQgY2FuIG9jY3VyIHN0YXJ0aW5nIGluIGBzYCBhbmRcclxuXHQgKiBzdGF5aW5nIGluIHNhbWUgcnVsZS4ge0BsaW5rIFRva2VuI0VQU0lMT059IGlzIGluIHNldCBpZiB3ZSByZWFjaCBlbmQgb2ZcclxuXHQgKiBydWxlLlxyXG5cdCAqL1xyXG5cdC8vIEBOb3ROdWxsXHJcblx0cHVibGljIG5leHRUb2tlbnMoLypATm90TnVsbCovIHM6IEFUTlN0YXRlKTogSW50ZXJ2YWxTZXQ7XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIG5leHRUb2tlbnMoczogQVROU3RhdGUsIGN0eD86IFByZWRpY3Rpb25Db250ZXh0KTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0aWYgKGN0eCkge1xyXG5cdFx0XHRsZXQgYW5hbDogTEwxQW5hbHl6ZXIgPSBuZXcgTEwxQW5hbHl6ZXIodGhpcyk7XHJcblx0XHRcdGxldCBuZXh0OiBJbnRlcnZhbFNldCA9IGFuYWwuTE9PSyhzLCBjdHgpO1xyXG5cdFx0XHRyZXR1cm4gbmV4dDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChzLm5leHRUb2tlbldpdGhpblJ1bGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gcy5uZXh0VG9rZW5XaXRoaW5SdWxlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzLm5leHRUb2tlbldpdGhpblJ1bGUgPSB0aGlzLm5leHRUb2tlbnMocywgUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfTE9DQUwpO1xyXG5cdFx0XHRzLm5leHRUb2tlbldpdGhpblJ1bGUuc2V0UmVhZG9ubHkodHJ1ZSk7XHJcblx0XHRcdHJldHVybiBzLm5leHRUb2tlbldpdGhpblJ1bGU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWRkU3RhdGUoc3RhdGU6IEFUTlN0YXRlKTogdm9pZCB7XHJcblx0XHRzdGF0ZS5hdG4gPSB0aGlzO1xyXG5cdFx0c3RhdGUuc3RhdGVOdW1iZXIgPSB0aGlzLnN0YXRlcy5sZW5ndGg7XHJcblx0XHR0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyByZW1vdmVTdGF0ZShATm90TnVsbCBzdGF0ZTogQVROU3RhdGUpOiB2b2lkIHtcclxuXHRcdC8vIGp1c3QgcmVwbGFjZSB0aGUgc3RhdGUsIGRvbid0IHNoaWZ0IHN0YXRlcyBpbiBsaXN0XHJcblx0XHRsZXQgaW52YWxpZFN0YXRlID0gbmV3IEludmFsaWRTdGF0ZSgpO1xyXG5cdFx0aW52YWxpZFN0YXRlLmF0biA9IHRoaXM7XHJcblx0XHRpbnZhbGlkU3RhdGUuc3RhdGVOdW1iZXIgPSBzdGF0ZS5zdGF0ZU51bWJlcjtcclxuXHRcdHRoaXMuc3RhdGVzW3N0YXRlLnN0YXRlTnVtYmVyXSA9IGludmFsaWRTdGF0ZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBkZWZpbmVNb2RlKEBOb3ROdWxsIG5hbWU6IHN0cmluZywgQE5vdE51bGwgczogVG9rZW5zU3RhcnRTdGF0ZSk6IHZvaWQge1xyXG5cdFx0dGhpcy5tb2RlTmFtZVRvU3RhcnRTdGF0ZS5zZXQobmFtZSwgcyk7XHJcblx0XHR0aGlzLm1vZGVUb1N0YXJ0U3RhdGUucHVzaChzKTtcclxuXHRcdHRoaXMubW9kZVRvREZBLnB1c2gobmV3IERGQShzKSk7XHJcblx0XHR0aGlzLmRlZmluZURlY2lzaW9uU3RhdGUocyk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZGVmaW5lRGVjaXNpb25TdGF0ZShATm90TnVsbCBzOiBEZWNpc2lvblN0YXRlKTogbnVtYmVyIHtcclxuXHRcdHRoaXMuZGVjaXNpb25Ub1N0YXRlLnB1c2gocyk7XHJcblx0XHRzLmRlY2lzaW9uID0gdGhpcy5kZWNpc2lvblRvU3RhdGUubGVuZ3RoIC0gMTtcclxuXHRcdHRoaXMuZGVjaXNpb25Ub0RGQS5wdXNoKG5ldyBERkEocywgcy5kZWNpc2lvbikpO1xyXG5cdFx0cmV0dXJuIHMuZGVjaXNpb247XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0RGVjaXNpb25TdGF0ZShkZWNpc2lvbjogbnVtYmVyKTogRGVjaXNpb25TdGF0ZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAodGhpcy5kZWNpc2lvblRvU3RhdGUubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5kZWNpc2lvblRvU3RhdGVbZGVjaXNpb25dO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdGdldCBudW1iZXJPZkRlY2lzaW9ucygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZGVjaXNpb25Ub1N0YXRlLmxlbmd0aDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGVzIHRoZSBzZXQgb2YgaW5wdXQgc3ltYm9scyB3aGljaCBjb3VsZCBmb2xsb3cgQVROIHN0YXRlIG51bWJlclxyXG5cdCAqIGBzdGF0ZU51bWJlcmAgaW4gdGhlIHNwZWNpZmllZCBmdWxsIGBjb250ZXh0YC4gVGhpcyBtZXRob2RcclxuXHQgKiBjb25zaWRlcnMgdGhlIGNvbXBsZXRlIHBhcnNlciBjb250ZXh0LCBidXQgZG9lcyBub3QgZXZhbHVhdGUgc2VtYW50aWNcclxuXHQgKiBwcmVkaWNhdGVzIChpLmUuIGFsbCBwcmVkaWNhdGVzIGVuY291bnRlcmVkIGR1cmluZyB0aGUgY2FsY3VsYXRpb24gYXJlXHJcblx0ICogYXNzdW1lZCB0cnVlKS4gSWYgYSBwYXRoIGluIHRoZSBBVE4gZXhpc3RzIGZyb20gdGhlIHN0YXJ0aW5nIHN0YXRlIHRvIHRoZVxyXG5cdCAqIHtAbGluayBSdWxlU3RvcFN0YXRlfSBvZiB0aGUgb3V0ZXJtb3N0IGNvbnRleHQgd2l0aG91dCBtYXRjaGluZyBhbnlcclxuXHQgKiBzeW1ib2xzLCB7QGxpbmsgVG9rZW4jRU9GfSBpcyBhZGRlZCB0byB0aGUgcmV0dXJuZWQgc2V0LlxyXG5cdCAqXHJcblx0ICogSWYgYGNvbnRleHRgIGlzIGB1bmRlZmluZWRgLCBpdCBpcyB0cmVhdGVkIGFzXHJcblx0ICoge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0I0VNUFRZfS5cclxuXHQgKlxyXG5cdCAqIE5vdGUgdGhhdCB0aGlzIGRvZXMgTk9UIGdpdmUgeW91IHRoZSBzZXQgb2YgYWxsIHRva2VucyB0aGF0IGNvdWxkXHJcblx0ICogYXBwZWFyIGF0IGEgZ2l2ZW4gdG9rZW4gcG9zaXRpb24gaW4gdGhlIGlucHV0IHBocmFzZS4gIEluIG90aGVyIHdvcmRzLCBpdFxyXG5cdCAqIGRvZXMgbm90IGFuc3dlcjpcclxuXHQgKlxyXG5cdCAqID4gR2l2ZW4gYSBzcGVjaWZpYyBwYXJ0aWFsIGlucHV0IHBocmFzZSwgcmV0dXJuIHRoZSBzZXQgb2YgYWxsXHJcblx0ICogPiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IHRoZSBsYXN0IHRva2VuIGluIHRoZSBpbnB1dCBwaHJhc2UuXHJcblx0ICpcclxuXHQgKiBUaGUgYmlnIGRpZmZlcmVuY2UgaXMgdGhhdCB3aXRoIGp1c3QgdGhlIGlucHV0LCB0aGUgcGFyc2VyIGNvdWxkIGxhbmRcclxuXHQgKiByaWdodCBpbiB0aGUgbWlkZGxlIG9mIGEgbG9va2FoZWFkIGRlY2lzaW9uLiBHZXR0aW5nIGFsbFxyXG5cdCAqICpwb3NzaWJsZSogdG9rZW5zIGdpdmVuIGEgcGFydGlhbCBpbnB1dCBzdHJlYW0gaXMgYSBzZXBhcmF0ZVxyXG5cdCAqIGNvbXB1dGF0aW9uLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FudGxyL2FudGxyNC9pc3N1ZXMvMTQyOFxyXG5cdCAqXHJcblx0ICogRm9yIHRoaXMgZnVuY3Rpb24sIHdlIGFyZSBzcGVjaWZ5aW5nIGFuIEFUTiBzdGF0ZSBhbmQgY2FsbCBzdGFjayB0b1xyXG5cdCAqIGNvbXB1dGUgd2hhdCB0b2tlbihzKSBjYW4gY29tZSBuZXh0IGFuZCBzcGVjaWZpY2FsbHk6IG91dHNpZGUgb2YgYVxyXG5cdCAqIGxvb2thaGVhZCBkZWNpc2lvbi4gVGhhdCBpcyB3aGF0IHlvdSB3YW50IGZvciBlcnJvciByZXBvcnRpbmcgYW5kXHJcblx0ICogcmVjb3ZlcnkgdXBvbiBwYXJzZSBlcnJvci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBzdGF0ZU51bWJlciB0aGUgQVROIHN0YXRlIG51bWJlclxyXG5cdCAqIEBwYXJhbSBjb250ZXh0IHRoZSBmdWxsIHBhcnNlIGNvbnRleHRcclxuXHQgKiBAcmV0dXJucyBUaGUgc2V0IG9mIHBvdGVudGlhbGx5IHZhbGlkIGlucHV0IHN5bWJvbHMgd2hpY2ggY291bGQgZm9sbG93IHRoZVxyXG5cdCAqIHNwZWNpZmllZCBzdGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXHJcblx0ICogQCBpZiB0aGUgQVROIGRvZXMgbm90IGNvbnRhaW4gYSBzdGF0ZSB3aXRoXHJcblx0ICogbnVtYmVyIGBzdGF0ZU51bWJlcmBcclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRFeHBlY3RlZFRva2VucyhzdGF0ZU51bWJlcjogbnVtYmVyLCBjb250ZXh0OiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCk6IEludGVydmFsU2V0IHtcclxuXHRcdGlmIChzdGF0ZU51bWJlciA8IDAgfHwgc3RhdGVOdW1iZXIgPj0gdGhpcy5zdGF0ZXMubGVuZ3RoKSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBzdGF0ZSBudW1iZXIuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjdHg6IFJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkID0gY29udGV4dDtcclxuXHRcdGxldCBzOiBBVE5TdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlTnVtYmVyXTtcclxuXHRcdGxldCBmb2xsb3dpbmc6IEludGVydmFsU2V0ID0gdGhpcy5uZXh0VG9rZW5zKHMpO1xyXG5cdFx0aWYgKCFmb2xsb3dpbmcuY29udGFpbnMoVG9rZW4uRVBTSUxPTikpIHtcclxuXHRcdFx0cmV0dXJuIGZvbGxvd2luZztcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZXhwZWN0ZWQ6IEludGVydmFsU2V0ID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHRleHBlY3RlZC5hZGRBbGwoZm9sbG93aW5nKTtcclxuXHRcdGV4cGVjdGVkLnJlbW92ZShUb2tlbi5FUFNJTE9OKTtcclxuXHRcdHdoaWxlIChjdHggIT0gbnVsbCAmJiBjdHguaW52b2tpbmdTdGF0ZSA+PSAwICYmIGZvbGxvd2luZy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSkge1xyXG5cdFx0XHRsZXQgaW52b2tpbmdTdGF0ZTogQVROU3RhdGUgPSB0aGlzLnN0YXRlc1tjdHguaW52b2tpbmdTdGF0ZV07XHJcblx0XHRcdGxldCBydDogUnVsZVRyYW5zaXRpb24gPSBpbnZva2luZ1N0YXRlLnRyYW5zaXRpb24oMCkgYXMgUnVsZVRyYW5zaXRpb247XHJcblx0XHRcdGZvbGxvd2luZyA9IHRoaXMubmV4dFRva2VucyhydC5mb2xsb3dTdGF0ZSk7XHJcblx0XHRcdGV4cGVjdGVkLmFkZEFsbChmb2xsb3dpbmcpO1xyXG5cdFx0XHRleHBlY3RlZC5yZW1vdmUoVG9rZW4uRVBTSUxPTik7XHJcblx0XHRcdGN0eCA9IGN0eC5fcGFyZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChmb2xsb3dpbmcuY29udGFpbnMoVG9rZW4uRVBTSUxPTikpIHtcclxuXHRcdFx0ZXhwZWN0ZWQuYWRkKFRva2VuLkVPRik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV4cGVjdGVkO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IG5hbWVzcGFjZSBBVE4ge1xyXG5cdGV4cG9ydCBjb25zdCBJTlZBTElEX0FMVF9OVU1CRVI6IG51bWJlciA9IDA7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI5Ljc2MTMwMzgtMDc6MDBcclxuXHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL0xleGVyXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb25UeXBlIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25UeXBlXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBMZXhlckFjdGlvbn0gaXMgdXNlZCBmb3IgdHJhY2tpbmcgaW5wdXQgb2Zmc2V0c1xyXG4gKiBmb3IgcG9zaXRpb24tZGVwZW5kZW50IGFjdGlvbnMgd2l0aGluIGEge0BsaW5rIExleGVyQWN0aW9uRXhlY3V0b3J9LlxyXG4gKlxyXG4gKiBUaGlzIGFjdGlvbiBpcyBub3Qgc2VyaWFsaXplZCBhcyBwYXJ0IG9mIHRoZSBBVE4sIGFuZCBpcyBvbmx5IHJlcXVpcmVkIGZvclxyXG4gKiBwb3NpdGlvbi1kZXBlbmRlbnQgbGV4ZXIgYWN0aW9ucyB3aGljaCBhcHBlYXIgYXQgYSBsb2NhdGlvbiBvdGhlciB0aGFuIHRoZVxyXG4gKiBlbmQgb2YgYSBydWxlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBERkEgb3B0aW1pemF0aW9ucyBlbXBsb3llZCBmb3JcclxuICogbGV4ZXIgYWN0aW9ucywgc2VlIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yI2FwcGVuZH0gYW5kXHJcbiAqIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yI2ZpeE9mZnNldEJlZm9yZU1hdGNofS5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKiBAc2luY2UgNC4yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uIGltcGxlbWVudHMgTGV4ZXJBY3Rpb24ge1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgX29mZnNldDogbnVtYmVyO1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgX2FjdGlvbjogTGV4ZXJBY3Rpb247XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW5kZXhlZCBjdXN0b20gYWN0aW9uIGJ5IGFzc29jaWF0aW5nIGEgY2hhcmFjdGVyIG9mZnNldFxyXG5cdCAqIHdpdGggYSB7QGxpbmsgTGV4ZXJBY3Rpb259LlxyXG5cdCAqXHJcblx0ICogTm90ZTogVGhpcyBjbGFzcyBpcyBvbmx5IHJlcXVpcmVkIGZvciBsZXhlciBhY3Rpb25zIGZvciB3aGljaFxyXG5cdCAqIHtAbGluayBMZXhlckFjdGlvbiNpc1Bvc2l0aW9uRGVwZW5kZW50fSByZXR1cm5zIGB0cnVlYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBpbnRvIHRoZSBpbnB1dCB7QGxpbmsgQ2hhclN0cmVhbX0sIHJlbGF0aXZlIHRvXHJcblx0ICogdGhlIHRva2VuIHN0YXJ0IGluZGV4LCBhdCB3aGljaCB0aGUgc3BlY2lmaWVkIGxleGVyIGFjdGlvbiBzaG91bGQgYmVcclxuXHQgKiBleGVjdXRlZC5cclxuXHQgKiBAcGFyYW0gYWN0aW9uIFRoZSBsZXhlciBhY3Rpb24gdG8gZXhlY3V0ZSBhdCBhIHBhcnRpY3VsYXIgb2Zmc2V0IGluIHRoZVxyXG5cdCAqIGlucHV0IHtAbGluayBDaGFyU3RyZWFtfS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihvZmZzZXQ6IG51bWJlciwgQE5vdE51bGwgYWN0aW9uOiBMZXhlckFjdGlvbikge1xyXG5cdFx0dGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0dGhpcy5fYWN0aW9uID0gYWN0aW9uO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgbG9jYXRpb24gaW4gdGhlIGlucHV0IHtAbGluayBDaGFyU3RyZWFtfSBhdCB3aGljaCB0aGUgbGV4ZXJcclxuXHQgKiBhY3Rpb24gc2hvdWxkIGJlIGV4ZWN1dGVkLiBUaGUgdmFsdWUgaXMgaW50ZXJwcmV0ZWQgYXMgYW4gb2Zmc2V0IHJlbGF0aXZlXHJcblx0ICogdG8gdGhlIHRva2VuIHN0YXJ0IGluZGV4LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIGxvY2F0aW9uIGluIHRoZSBpbnB1dCB7QGxpbmsgQ2hhclN0cmVhbX0gYXQgd2hpY2ggdGhlIGxleGVyXHJcblx0ICogYWN0aW9uIHNob3VsZCBiZSBleGVjdXRlZC5cclxuXHQgKi9cclxuXHRnZXQgb2Zmc2V0KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fb2Zmc2V0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgbGV4ZXIgYWN0aW9uIHRvIGV4ZWN1dGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBBIHtAbGluayBMZXhlckFjdGlvbn0gb2JqZWN0IHdoaWNoIGV4ZWN1dGVzIHRoZSBsZXhlciBhY3Rpb24uXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRnZXQgYWN0aW9uKCk6IExleGVyQWN0aW9uIHtcclxuXHRcdHJldHVybiB0aGlzLl9hY3Rpb247XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgY2FsbGluZyB7QGxpbmsgI2dldEFjdGlvblR5cGV9XHJcblx0ICogb24gdGhlIHtAbGluayBMZXhlckFjdGlvbn0gcmV0dXJuZWQgYnkge0BsaW5rICNnZXRBY3Rpb259LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBhY3Rpb25UeXBlKCk6IExleGVyQWN0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYWN0aW9uLmFjdGlvblR5cGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGNhbGxzIHtAbGluayAjZXhlY3V0ZX0gb24gdGhlIHJlc3VsdCBvZiB7QGxpbmsgI2dldEFjdGlvbn1cclxuXHQgKiB1c2luZyB0aGUgcHJvdmlkZWQgYGxleGVyYC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXhlY3V0ZShsZXhlcjogTGV4ZXIpOiB2b2lkIHtcclxuXHRcdC8vIGFzc3VtZSB0aGUgaW5wdXQgc3RyZWFtIHBvc2l0aW9uIHdhcyBwcm9wZXJseSBzZXQgYnkgdGhlIGNhbGxpbmcgY29kZVxyXG5cdFx0dGhpcy5fYWN0aW9uLmV4ZWN1dGUobGV4ZXIpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKCk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5fb2Zmc2V0KTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLl9hY3Rpb24pO1xyXG5cdFx0cmV0dXJuIE11cm11ckhhc2guZmluaXNoKGhhc2gsIDIpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG9iaiA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAoIShvYmogaW5zdGFuY2VvZiBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb24pKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fb2Zmc2V0ID09PSBvYmouX29mZnNldFxyXG5cdFx0XHQmJiB0aGlzLl9hY3Rpb24uZXF1YWxzKG9iai5fYWN0aW9uKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI4Ljg4MTA0NTMtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFycmF5RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgQ2hhclN0cmVhbSB9IGZyb20gXCIuLi9DaGFyU3RyZWFtXCI7XHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL0xleGVyXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGV4ZWN1dG9yIGZvciBhIHNlcXVlbmNlIG9mIGxleGVyIGFjdGlvbnMgd2hpY2ggdHJhdmVyc2VkIGR1cmluZ1xyXG4gKiB0aGUgbWF0Y2hpbmcgb3BlcmF0aW9uIG9mIGEgbGV4ZXIgcnVsZSAodG9rZW4pLlxyXG4gKlxyXG4gKiBUaGUgZXhlY3V0b3IgdHJhY2tzIHBvc2l0aW9uIGluZm9ybWF0aW9uIGZvciBwb3NpdGlvbi1kZXBlbmRlbnQgbGV4ZXIgYWN0aW9uc1xyXG4gKiBlZmZpY2llbnRseSwgZW5zdXJpbmcgdGhhdCBhY3Rpb25zIGFwcGVhcmluZyBvbmx5IGF0IHRoZSBlbmQgb2YgdGhlIHJ1bGUgZG9cclxuICogbm90IGNhdXNlIGJsb2F0aW5nIG9mIHRoZSB7QGxpbmsgREZBfSBjcmVhdGVkIGZvciB0aGUgbGV4ZXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICogQHNpbmNlIDQuMlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExleGVyQWN0aW9uRXhlY3V0b3Ige1xyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSBfbGV4ZXJBY3Rpb25zOiBMZXhlckFjdGlvbltdO1xyXG5cclxuXHQvKipcclxuXHQgKiBDYWNoZXMgdGhlIHJlc3VsdCBvZiB7QGxpbmsgI2hhc2hDb2RlfSBzaW5jZSB0aGUgaGFzaCBjb2RlIGlzIGFuIGVsZW1lbnRcclxuXHQgKiBvZiB0aGUgcGVyZm9ybWFuY2UtY3JpdGljYWwge0BsaW5rIExleGVyQVROQ29uZmlnI2hhc2hDb2RlfSBvcGVyYXRpb24uXHJcblx0ICovXHJcblx0cHJpdmF0ZSBjYWNoZWRIYXNoQ29kZTogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGFuIGV4ZWN1dG9yIGZvciBhIHNlcXVlbmNlIG9mIHtAbGluayBMZXhlckFjdGlvbn0gYWN0aW9ucy5cclxuXHQgKiBAcGFyYW0gbGV4ZXJBY3Rpb25zIFRoZSBsZXhlciBhY3Rpb25zIHRvIGV4ZWN1dGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgbGV4ZXJBY3Rpb25zOiBMZXhlckFjdGlvbltdKSB7XHJcblx0XHR0aGlzLl9sZXhlckFjdGlvbnMgPSBsZXhlckFjdGlvbnM7XHJcblxyXG5cdFx0bGV0IGhhc2g6IG51bWJlciA9IE11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xyXG5cdFx0Zm9yIChsZXQgbGV4ZXJBY3Rpb24gb2YgbGV4ZXJBY3Rpb25zKSB7XHJcblx0XHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCBsZXhlckFjdGlvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYWNoZWRIYXNoQ29kZSA9IE11cm11ckhhc2guZmluaXNoKGhhc2gsIGxleGVyQWN0aW9ucy5sZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yfSB3aGljaCBleGVjdXRlcyB0aGUgYWN0aW9ucyBmb3JcclxuXHQgKiB0aGUgaW5wdXQgYGxleGVyQWN0aW9uRXhlY3V0b3JgIGZvbGxvd2VkIGJ5IGEgc3BlY2lmaWVkXHJcblx0ICogYGxleGVyQWN0aW9uYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBsZXhlckFjdGlvbkV4ZWN1dG9yIFRoZSBleGVjdXRvciBmb3IgYWN0aW9ucyBhbHJlYWR5IHRyYXZlcnNlZCBieVxyXG5cdCAqIHRoZSBsZXhlciB3aGlsZSBtYXRjaGluZyBhIHRva2VuIHdpdGhpbiBhIHBhcnRpY3VsYXJcclxuXHQgKiB7QGxpbmsgQVROQ29uZmlnfS4gSWYgdGhpcyBpcyBgdW5kZWZpbmVkYCwgdGhlIG1ldGhvZCBiZWhhdmVzIGFzIHRob3VnaFxyXG5cdCAqIGl0IHdlcmUgYW4gZW1wdHkgZXhlY3V0b3IuXHJcblx0ICogQHBhcmFtIGxleGVyQWN0aW9uIFRoZSBsZXhlciBhY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgYWN0aW9uc1xyXG5cdCAqIHNwZWNpZmllZCBpbiBgbGV4ZXJBY3Rpb25FeGVjdXRvcmAuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBBIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yfSBmb3IgZXhlY3V0aW5nIHRoZSBjb21iaW5lIGFjdGlvbnNcclxuXHQgKiBvZiBgbGV4ZXJBY3Rpb25FeGVjdXRvcmAgYW5kIGBsZXhlckFjdGlvbmAuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgc3RhdGljIGFwcGVuZChsZXhlckFjdGlvbkV4ZWN1dG9yOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHwgdW5kZWZpbmVkLCBATm90TnVsbCBsZXhlckFjdGlvbjogTGV4ZXJBY3Rpb24pOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHtcclxuXHRcdGlmICghbGV4ZXJBY3Rpb25FeGVjdXRvcikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExleGVyQWN0aW9uRXhlY3V0b3IoW2xleGVyQWN0aW9uXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGxleGVyQWN0aW9ucyA9IGxleGVyQWN0aW9uRXhlY3V0b3IuX2xleGVyQWN0aW9ucy5zbGljZSgwKTtcclxuXHRcdGxleGVyQWN0aW9ucy5wdXNoKGxleGVyQWN0aW9uKTtcclxuXHRcdHJldHVybiBuZXcgTGV4ZXJBY3Rpb25FeGVjdXRvcihsZXhlckFjdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yfSB3aGljaCBlbmNvZGVzIHRoZSBjdXJyZW50IG9mZnNldFxyXG5cdCAqIGZvciBwb3NpdGlvbi1kZXBlbmRlbnQgbGV4ZXIgYWN0aW9ucy5cclxuXHQgKlxyXG5cdCAqIE5vcm1hbGx5LCB3aGVuIHRoZSBleGVjdXRvciBlbmNvdW50ZXJzIGxleGVyIGFjdGlvbnMgd2hlcmVcclxuXHQgKiB7QGxpbmsgTGV4ZXJBY3Rpb24jaXNQb3NpdGlvbkRlcGVuZGVudH0gcmV0dXJucyBgdHJ1ZWAsIGl0IGNhbGxzXHJcblx0ICoge0BsaW5rIEludFN0cmVhbSNzZWVrfSBvbiB0aGUgaW5wdXQge0BsaW5rIENoYXJTdHJlYW19IHRvIHNldCB0aGUgaW5wdXRcclxuXHQgKiBwb3NpdGlvbiB0byB0aGUgKmVuZCogb2YgdGhlIGN1cnJlbnQgdG9rZW4uIFRoaXMgYmVoYXZpb3IgcHJvdmlkZXNcclxuXHQgKiBmb3IgZWZmaWNpZW50IERGQSByZXByZXNlbnRhdGlvbiBvZiBsZXhlciBhY3Rpb25zIHdoaWNoIGFwcGVhciBhdCB0aGUgZW5kXHJcblx0ICogb2YgYSBsZXhlciBydWxlLCBldmVuIHdoZW4gdGhlIGxleGVyIHJ1bGUgbWF0Y2hlcyBhIHZhcmlhYmxlIG51bWJlciBvZlxyXG5cdCAqIGNoYXJhY3RlcnMuXHJcblx0ICpcclxuXHQgKiBQcmlvciB0byB0cmF2ZXJzaW5nIGEgbWF0Y2ggdHJhbnNpdGlvbiBpbiB0aGUgQVROLCB0aGUgY3VycmVudCBvZmZzZXRcclxuXHQgKiBmcm9tIHRoZSB0b2tlbiBzdGFydCBpbmRleCBpcyBhc3NpZ25lZCB0byBhbGwgcG9zaXRpb24tZGVwZW5kZW50IGxleGVyXHJcblx0ICogYWN0aW9ucyB3aGljaCBoYXZlIG5vdCBhbHJlYWR5IGJlZW4gYXNzaWduZWQgYSBmaXhlZCBvZmZzZXQuIEJ5IHN0b3JpbmdcclxuXHQgKiB0aGUgb2Zmc2V0cyByZWxhdGl2ZSB0byB0aGUgdG9rZW4gc3RhcnQgaW5kZXgsIHRoZSBERkEgcmVwcmVzZW50YXRpb24gb2ZcclxuXHQgKiBsZXhlciBhY3Rpb25zIHdoaWNoIGFwcGVhciBpbiB0aGUgbWlkZGxlIG9mIHRva2VucyByZW1haW5zIGVmZmljaWVudCBkdWVcclxuXHQgKiB0byBzaGFyaW5nIGFtb25nIHRva2VucyBvZiB0aGUgc2FtZSBsZW5ndGgsIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgYWJzb2x1dGVcclxuXHQgKiBwb3NpdGlvbiBpbiB0aGUgaW5wdXQgc3RyZWFtLlxyXG5cdCAqXHJcblx0ICogSWYgdGhlIGN1cnJlbnQgZXhlY3V0b3IgYWxyZWFkeSBoYXMgb2Zmc2V0cyBhc3NpZ25lZCB0byBhbGxcclxuXHQgKiBwb3NpdGlvbi1kZXBlbmRlbnQgbGV4ZXIgYWN0aW9ucywgdGhlIG1ldGhvZCByZXR1cm5zIGB0aGlzYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBvZmZzZXQgVGhlIGN1cnJlbnQgb2Zmc2V0IHRvIGFzc2lnbiB0byBhbGwgcG9zaXRpb24tZGVwZW5kZW50XHJcblx0ICogbGV4ZXIgYWN0aW9ucyB3aGljaCBkbyBub3QgYWxyZWFkeSBoYXZlIG9mZnNldHMgYXNzaWduZWQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBBIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yfSB3aGljaCBzdG9yZXMgaW5wdXQgc3RyZWFtIG9mZnNldHNcclxuXHQgKiBmb3IgYWxsIHBvc2l0aW9uLWRlcGVuZGVudCBsZXhlciBhY3Rpb25zLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBmaXhPZmZzZXRCZWZvcmVNYXRjaChvZmZzZXQ6IG51bWJlcik6IExleGVyQWN0aW9uRXhlY3V0b3Ige1xyXG5cdFx0bGV0IHVwZGF0ZWRMZXhlckFjdGlvbnM6IExleGVyQWN0aW9uW10gfCB1bmRlZmluZWQ7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xleGVyQWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fbGV4ZXJBY3Rpb25zW2ldLmlzUG9zaXRpb25EZXBlbmRlbnQgJiYgISh0aGlzLl9sZXhlckFjdGlvbnNbaV0gaW5zdGFuY2VvZiBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb24pKSB7XHJcblx0XHRcdFx0aWYgKCF1cGRhdGVkTGV4ZXJBY3Rpb25zKSB7XHJcblx0XHRcdFx0XHR1cGRhdGVkTGV4ZXJBY3Rpb25zID0gdGhpcy5fbGV4ZXJBY3Rpb25zLnNsaWNlKDApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dXBkYXRlZExleGVyQWN0aW9uc1tpXSA9IG5ldyBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb24ob2Zmc2V0LCB0aGlzLl9sZXhlckFjdGlvbnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF1cGRhdGVkTGV4ZXJBY3Rpb25zKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTGV4ZXJBY3Rpb25FeGVjdXRvcih1cGRhdGVkTGV4ZXJBY3Rpb25zKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGxleGVyIGFjdGlvbnMgdG8gYmUgZXhlY3V0ZWQgYnkgdGhpcyBleGVjdXRvci5cclxuXHQgKiBAcmV0dXJucyBUaGUgbGV4ZXIgYWN0aW9ucyB0byBiZSBleGVjdXRlZCBieSB0aGlzIGV4ZWN1dG9yLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGxleGVyQWN0aW9ucygpOiBMZXhlckFjdGlvbltdIHtcclxuXHRcdHJldHVybiB0aGlzLl9sZXhlckFjdGlvbnM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlIHRoZSBhY3Rpb25zIGVuY2Fwc3VsYXRlZCBieSB0aGlzIGV4ZWN1dG9yIHdpdGhpbiB0aGUgY29udGV4dCBvZiBhXHJcblx0ICogcGFydGljdWxhciB7QGxpbmsgTGV4ZXJ9LlxyXG5cdCAqXHJcblx0ICogVGhpcyBtZXRob2QgY2FsbHMge0BsaW5rIEludFN0cmVhbSNzZWVrfSB0byBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZVxyXG5cdCAqIGBpbnB1dGAge0BsaW5rIENoYXJTdHJlYW19IHByaW9yIHRvIGNhbGxpbmdcclxuXHQgKiB7QGxpbmsgTGV4ZXJBY3Rpb24jZXhlY3V0ZX0gb24gYSBwb3NpdGlvbi1kZXBlbmRlbnQgYWN0aW9uLiBCZWZvcmUgdGhlXHJcblx0ICogbWV0aG9kIHJldHVybnMsIHRoZSBpbnB1dCBwb3NpdGlvbiB3aWxsIGJlIHJlc3RvcmVkIHRvIHRoZSBzYW1lIHBvc2l0aW9uXHJcblx0ICogaXQgd2FzIGluIHdoZW4gdGhlIG1ldGhvZCB3YXMgaW52b2tlZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBsZXhlciBUaGUgbGV4ZXIgaW5zdGFuY2UuXHJcblx0ICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBzdHJlYW0gd2hpY2ggaXMgdGhlIHNvdXJjZSBmb3IgdGhlIGN1cnJlbnQgdG9rZW4uXHJcblx0ICogV2hlbiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBjdXJyZW50IHtAbGluayBJbnRTdHJlYW0jaW5kZXh9IGZvclxyXG5cdCAqIGBpbnB1dGAgc2hvdWxkIGJlIHRoZSBzdGFydCBvZiB0aGUgZm9sbG93aW5nIHRva2VuLCBpLmUuIDFcclxuXHQgKiBjaGFyYWN0ZXIgcGFzdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHRva2VuLlxyXG5cdCAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSB0b2tlbiBzdGFydCBpbmRleC4gVGhpcyB2YWx1ZSBtYXkgYmUgcGFzc2VkIHRvXHJcblx0ICoge0BsaW5rIEludFN0cmVhbSNzZWVrfSB0byBzZXQgdGhlIGBpbnB1dGAgcG9zaXRpb24gdG8gdGhlIGJlZ2lubmluZ1xyXG5cdCAqIG9mIHRoZSB0b2tlbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgZXhlY3V0ZShATm90TnVsbCBsZXhlcjogTGV4ZXIsIGlucHV0OiBDaGFyU3RyZWFtLCBzdGFydEluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGxldCByZXF1aXJlc1NlZWs6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdGxldCBzdG9wSW5kZXg6IG51bWJlciA9IGlucHV0LmluZGV4O1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Zm9yIChsZXQgbGV4ZXJBY3Rpb24gb2YgdGhpcy5fbGV4ZXJBY3Rpb25zKSB7XHJcblx0XHRcdFx0aWYgKGxleGVyQWN0aW9uIGluc3RhbmNlb2YgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uKSB7XHJcblx0XHRcdFx0XHRsZXQgb2Zmc2V0OiBudW1iZXIgPSBsZXhlckFjdGlvbi5vZmZzZXQ7XHJcblx0XHRcdFx0XHRpbnB1dC5zZWVrKHN0YXJ0SW5kZXggKyBvZmZzZXQpO1xyXG5cdFx0XHRcdFx0bGV4ZXJBY3Rpb24gPSBsZXhlckFjdGlvbi5hY3Rpb247XHJcblx0XHRcdFx0XHRyZXF1aXJlc1NlZWsgPSAoc3RhcnRJbmRleCArIG9mZnNldCkgIT09IHN0b3BJbmRleDtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGxleGVyQWN0aW9uLmlzUG9zaXRpb25EZXBlbmRlbnQpIHtcclxuXHRcdFx0XHRcdGlucHV0LnNlZWsoc3RvcEluZGV4KTtcclxuXHRcdFx0XHRcdHJlcXVpcmVzU2VlayA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV4ZXJBY3Rpb24uZXhlY3V0ZShsZXhlcik7XHJcblx0XHRcdH1cclxuXHRcdH0gZmluYWxseSB7XHJcblx0XHRcdGlmIChyZXF1aXJlc1NlZWspIHtcclxuXHRcdFx0XHRpbnB1dC5zZWVrKHN0b3BJbmRleCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVkSGFzaENvZGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbiB7XHJcblx0XHRpZiAob2JqID09PSB0aGlzKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIGlmICghKG9iaiBpbnN0YW5jZW9mIExleGVyQWN0aW9uRXhlY3V0b3IpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jYWNoZWRIYXNoQ29kZSA9PT0gb2JqLmNhY2hlZEhhc2hDb2RlXHJcblx0XHRcdCYmIEFycmF5RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFLmVxdWFscyh0aGlzLl9sZXhlckFjdGlvbnMsIG9iai5fbGV4ZXJBY3Rpb25zKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUyLjA5NjExMzYtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuL2F0bi9BVE5Db25maWdTZXRcIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBDaGFyU3RyZWFtIH0gZnJvbSBcIi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxcIjtcclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4vbWlzYy9VdGlsc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24gZXh0ZW5kcyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB7XHJcblx0Ly9wcml2YXRlIHN0YXRpYyBzZXJpYWxWZXJzaW9uVUlEOiBudW1iZXIgPSAgLTczMDk5OTIwMzkxMzAwMTcyNkw7XHJcblxyXG5cdC8qKiBNYXRjaGluZyBhdHRlbXB0ZWQgYXQgd2hhdCBpbnB1dCBpbmRleD8gKi9cclxuXHRwcml2YXRlIF9zdGFydEluZGV4OiBudW1iZXI7XHJcblxyXG5cdC8qKiBXaGljaCBjb25maWd1cmF0aW9ucyBkaWQgd2UgdHJ5IGF0IGlucHV0LmluZGV4IHRoYXQgY291bGRuJ3QgbWF0Y2ggaW5wdXQuTEEoMSk/ICovXHJcblx0cHJpdmF0ZSBfZGVhZEVuZENvbmZpZ3M/OiBBVE5Db25maWdTZXQ7XHJcblxyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0bGV4ZXI6IExleGVyIHwgdW5kZWZpbmVkLFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IENoYXJTdHJlYW0sXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRkZWFkRW5kQ29uZmlnczogQVROQ29uZmlnU2V0IHwgdW5kZWZpbmVkKSB7XHJcblx0XHRzdXBlcihsZXhlciwgaW5wdXQpO1xyXG5cdFx0dGhpcy5fc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XHJcblx0XHR0aGlzLl9kZWFkRW5kQ29uZmlncyA9IGRlYWRFbmRDb25maWdzO1xyXG5cdH1cclxuXHJcblx0Z2V0IHN0YXJ0SW5kZXgoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9zdGFydEluZGV4O1xyXG5cdH1cclxuXHJcblx0Z2V0IGRlYWRFbmRDb25maWdzKCk6IEFUTkNvbmZpZ1NldCB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZGVhZEVuZENvbmZpZ3M7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaW5wdXRTdHJlYW0oKTogQ2hhclN0cmVhbSB7XHJcblx0XHRyZXR1cm4gc3VwZXIuaW5wdXRTdHJlYW0gYXMgQ2hhclN0cmVhbTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0bGV0IHN5bWJvbCA9IFwiXCI7XHJcblx0XHRpZiAodGhpcy5fc3RhcnRJbmRleCA+PSAwICYmIHRoaXMuX3N0YXJ0SW5kZXggPCB0aGlzLmlucHV0U3RyZWFtLnNpemUpIHtcclxuXHRcdFx0c3ltYm9sID0gdGhpcy5pbnB1dFN0cmVhbS5nZXRUZXh0KEludGVydmFsLm9mKHRoaXMuX3N0YXJ0SW5kZXgsIHRoaXMuX3N0YXJ0SW5kZXgpKTtcclxuXHRcdFx0c3ltYm9sID0gVXRpbHMuZXNjYXBlV2hpdGVzcGFjZShzeW1ib2wsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXR1cm4gU3RyaW5nLmZvcm1hdChMb2NhbGUuZ2V0RGVmYXVsdCgpLCBcIiVzKCclcycpXCIsIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24uY2xhc3MuZ2V0U2ltcGxlTmFtZSgpLCBzeW1ib2wpO1xyXG5cdFx0cmV0dXJuIGBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKCcke3N5bWJvbH0nKWA7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozMC45NDQ0NTU2LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5Db25maWcgfSBmcm9tIFwiLi9BVE5Db25maWdcIjtcclxuaW1wb3J0IHsgQVROQ29uZmlnU2V0IH0gZnJvbSBcIi4vQVROQ29uZmlnU2V0XCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgT3JkZXJlZEFUTkNvbmZpZ1NldCBleHRlbmRzIEFUTkNvbmZpZ1NldCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCk7XHJcblx0Y29uc3RydWN0b3Ioc2V0OiBBVE5Db25maWdTZXQsIHJlYWRvbmx5OiBib29sZWFuKTtcclxuXHRjb25zdHJ1Y3RvcihzZXQ/OiBBVE5Db25maWdTZXQsIHJlYWRvbmx5PzogYm9vbGVhbikge1xyXG5cdFx0aWYgKHNldCAhPSBudWxsICYmIHJlYWRvbmx5ICE9IG51bGwpIHtcclxuXHRcdFx0c3VwZXIoc2V0LCByZWFkb25seSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdXBlcigpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGNsb25lKHJlYWRvbmx5OiBib29sZWFuKTogQVROQ29uZmlnU2V0IHtcclxuXHRcdGxldCBjb3B5OiBPcmRlcmVkQVROQ29uZmlnU2V0ID0gbmV3IE9yZGVyZWRBVE5Db25maWdTZXQodGhpcywgcmVhZG9ubHkpO1xyXG5cdFx0aWYgKCFyZWFkb25seSAmJiB0aGlzLmlzUmVhZE9ubHkpIHtcclxuXHRcdFx0Y29weS5hZGRBbGwodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvcHk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgZ2V0S2V5KGU6IEFUTkNvbmZpZyk6IHsgc3RhdGU6IG51bWJlciwgYWx0OiBudW1iZXIgfSB7XHJcblx0XHQvLyBUaGlzIGlzIGEgc3BlY2lhbGx5IGNyYWZ0ZWQga2V5IHRvIGVuc3VyZSBjb25maWd1cmF0aW9ucyBhcmUgb25seSBtZXJnZWQgaWYgdGhleSBhcmUgZXF1YWxcclxuXHRcdHJldHVybiB7IHN0YXRlOiAwLCBhbHQ6IGUuaGFzaENvZGUoKSB9O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIGNhbk1lcmdlKGxlZnQ6IEFUTkNvbmZpZywgbGVmdEtleTogeyBzdGF0ZTogbnVtYmVyLCBhbHQ6IG51bWJlciB9LCByaWdodDogQVROQ29uZmlnKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gbGVmdC5lcXVhbHMocmlnaHQpO1xyXG5cdH1cclxuXHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI5LjEwODMwNjYtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFjY2VwdFN0YXRlSW5mbyB9IGZyb20gXCIuLi9kZmEvQWNjZXB0U3RhdGVJbmZvXCI7XHJcbmltcG9ydCB7IEFjdGlvblRyYW5zaXRpb24gfSBmcm9tIFwiLi9BY3Rpb25UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5Db25maWcgfSBmcm9tIFwiLi9BVE5Db25maWdcIjtcclxuaW1wb3J0IHsgQVROQ29uZmlnU2V0IH0gZnJvbSBcIi4vQVROQ29uZmlnU2V0XCI7XHJcbmltcG9ydCB7IEFUTlNpbXVsYXRvciB9IGZyb20gXCIuL0FUTlNpbXVsYXRvclwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiLi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBERkEgfSBmcm9tIFwiLi4vZGZhL0RGQVwiO1xyXG5pbXBvcnQgeyBERkFTdGF0ZSB9IGZyb20gXCIuLi9kZmEvREZBU3RhdGVcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5pbXBvcnQgeyBJbnRTdHJlYW0gfSBmcm9tIFwiLi4vSW50U3RyZWFtXCI7XHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL0xleGVyXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uRXhlY3V0b3IgfSBmcm9tIFwiLi9MZXhlckFjdGlvbkV4ZWN1dG9yXCI7XHJcbmltcG9ydCB7IExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24gfSBmcm9tIFwiLi4vTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IE9yZGVyZWRBVE5Db25maWdTZXQgfSBmcm9tIFwiLi9PcmRlcmVkQVROQ29uZmlnU2V0XCI7XHJcbmltcG9ydCB7IFByZWRpY3Rpb25Db250ZXh0IH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRcIjtcclxuaW1wb3J0IHsgUHJlZGljYXRlVHJhbnNpdGlvbiB9IGZyb20gXCIuL1ByZWRpY2F0ZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgUnVsZVN0b3BTdGF0ZSB9IGZyb20gXCIuL1J1bGVTdG9wU3RhdGVcIjtcclxuaW1wb3J0IHsgUnVsZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9SdWxlVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XHJcblxyXG4vKiogXCJkdXBcIiBvZiBQYXJzZXJJbnRlcnByZXRlciAqL1xyXG5leHBvcnQgY2xhc3MgTGV4ZXJBVE5TaW11bGF0b3IgZXh0ZW5kcyBBVE5TaW11bGF0b3Ige1xyXG5cdHB1YmxpYyBvcHRpbWl6ZV90YWlsX2NhbGxzOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcblx0cHJvdGVjdGVkIHJlY29nOiBMZXhlciB8IHVuZGVmaW5lZDtcclxuXHJcblx0LyoqIFRoZSBjdXJyZW50IHRva2VuJ3Mgc3RhcnRpbmcgaW5kZXggaW50byB0aGUgY2hhcmFjdGVyIHN0cmVhbS5cclxuXHQgKiAgU2hhcmVkIGFjcm9zcyBERkEgdG8gQVROIHNpbXVsYXRpb24gaW4gY2FzZSB0aGUgQVROIGZhaWxzIGFuZCB0aGVcclxuXHQgKiAgREZBIGRpZCBub3QgaGF2ZSBhIHByZXZpb3VzIGFjY2VwdCBzdGF0ZS4gSW4gdGhpcyBjYXNlLCB3ZSB1c2UgdGhlXHJcblx0ICogIEFUTi1nZW5lcmF0ZWQgZXhjZXB0aW9uIG9iamVjdC5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgc3RhcnRJbmRleDogbnVtYmVyID0gLTE7XHJcblxyXG5cdC8qKiBsaW5lIG51bWJlciAxLi5uIHdpdGhpbiB0aGUgaW5wdXQgKi9cclxuXHRwcml2YXRlIF9saW5lOiBudW1iZXIgPSAxO1xyXG5cclxuXHQvKiogVGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZSAwLi5uLTEgKi9cclxuXHRwcml2YXRlIF9jaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlciA9IDA7XHJcblxyXG5cdHByb3RlY3RlZCBtb2RlOiBudW1iZXIgPSBMZXhlci5ERUZBVUxUX01PREU7XHJcblxyXG5cdC8qKiBVc2VkIGR1cmluZyBERkEvQVROIGV4ZWMgdG8gcmVjb3JkIHRoZSBtb3N0IHJlY2VudCBhY2NlcHQgY29uZmlndXJhdGlvbiBpbmZvICovXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgcHJldkFjY2VwdDogTGV4ZXJBVE5TaW11bGF0b3IuU2ltU3RhdGUgPSBuZXcgTGV4ZXJBVE5TaW11bGF0b3IuU2ltU3RhdGUoKTtcclxuXHJcblx0Y29uc3RydWN0b3IoLypATm90TnVsbCovIGF0bjogQVROKTtcclxuXHRjb25zdHJ1Y3RvcigvKkBOb3ROdWxsKi8gYXRuOiBBVE4sIHJlY29nOiBMZXhlciB8IHVuZGVmaW5lZCk7XHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgYXRuOiBBVE4sIHJlY29nPzogTGV4ZXIpIHtcclxuXHRcdHN1cGVyKGF0bik7XHJcblx0XHR0aGlzLnJlY29nID0gcmVjb2c7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY29weVN0YXRlKEBOb3ROdWxsIHNpbXVsYXRvcjogTGV4ZXJBVE5TaW11bGF0b3IpOiB2b2lkIHtcclxuXHRcdHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSA9IHNpbXVsYXRvci5jaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0XHR0aGlzLl9saW5lID0gc2ltdWxhdG9yLl9saW5lO1xyXG5cdFx0dGhpcy5tb2RlID0gc2ltdWxhdG9yLm1vZGU7XHJcblx0XHR0aGlzLnN0YXJ0SW5kZXggPSBzaW11bGF0b3Iuc3RhcnRJbmRleDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBtYXRjaChATm90TnVsbCBpbnB1dDogQ2hhclN0cmVhbSwgbW9kZTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHRoaXMubW9kZSA9IG1vZGU7XHJcblx0XHRsZXQgbWFyazogbnVtYmVyID0gaW5wdXQubWFyaygpO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0dGhpcy5zdGFydEluZGV4ID0gaW5wdXQuaW5kZXg7XHJcblx0XHRcdHRoaXMucHJldkFjY2VwdC5yZXNldCgpO1xyXG5cdFx0XHRsZXQgczA6IERGQVN0YXRlIHwgdW5kZWZpbmVkID0gdGhpcy5hdG4ubW9kZVRvREZBW21vZGVdLnMwO1xyXG5cdFx0XHRpZiAoczAgPT0gbnVsbCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm1hdGNoQVROKGlucHV0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5leGVjQVROKGlucHV0LCBzMCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZpbmFsbHkge1xyXG5cdFx0XHRpbnB1dC5yZWxlYXNlKG1hcmspO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG5cdFx0dGhpcy5wcmV2QWNjZXB0LnJlc2V0KCk7XHJcblx0XHR0aGlzLnN0YXJ0SW5kZXggPSAtMTtcclxuXHRcdHRoaXMuX2xpbmUgPSAxO1xyXG5cdFx0dGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lID0gMDtcclxuXHRcdHRoaXMubW9kZSA9IExleGVyLkRFRkFVTFRfTU9ERTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBtYXRjaEFUTihATm90TnVsbCBpbnB1dDogQ2hhclN0cmVhbSk6IG51bWJlciB7XHJcblx0XHRsZXQgc3RhcnRTdGF0ZTogQVROU3RhdGUgPSB0aGlzLmF0bi5tb2RlVG9TdGFydFN0YXRlW3RoaXMubW9kZV07XHJcblxyXG5cdFx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKGBtYXRjaEFUTiBtb2RlICR7dGhpcy5tb2RlfSBzdGFydDogJHtzdGFydFN0YXRlfWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBvbGRfbW9kZTogbnVtYmVyID0gdGhpcy5tb2RlO1xyXG5cclxuXHRcdGxldCBzMF9jbG9zdXJlOiBBVE5Db25maWdTZXQgPSB0aGlzLmNvbXB1dGVTdGFydFN0YXRlKGlucHV0LCBzdGFydFN0YXRlKTtcclxuXHRcdGxldCBzdXBwcmVzc0VkZ2U6IGJvb2xlYW4gPSBzMF9jbG9zdXJlLmhhc1NlbWFudGljQ29udGV4dDtcclxuXHRcdGlmIChzdXBwcmVzc0VkZ2UpIHtcclxuXHRcdFx0czBfY2xvc3VyZS5oYXNTZW1hbnRpY0NvbnRleHQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbmV4dDogREZBU3RhdGUgPSB0aGlzLmFkZERGQVN0YXRlKHMwX2Nsb3N1cmUpO1xyXG5cdFx0aWYgKCFzdXBwcmVzc0VkZ2UpIHtcclxuXHRcdFx0bGV0IGRmYSA9IHRoaXMuYXRuLm1vZGVUb0RGQVt0aGlzLm1vZGVdO1xyXG5cdFx0XHRpZiAoIWRmYS5zMCkge1xyXG5cdFx0XHRcdGRmYS5zMCA9IG5leHQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bmV4dCA9IGRmYS5zMDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBwcmVkaWN0OiBudW1iZXIgPSB0aGlzLmV4ZWNBVE4oaW5wdXQsIG5leHQpO1xyXG5cclxuXHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhgREZBIGFmdGVyIG1hdGNoQVROOiAke3RoaXMuYXRuLm1vZGVUb0RGQVtvbGRfbW9kZV0udG9MZXhlclN0cmluZygpfWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwcmVkaWN0O1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGV4ZWNBVE4oQE5vdE51bGwgaW5wdXQ6IENoYXJTdHJlYW0sIEBOb3ROdWxsIGRzMDogREZBU3RhdGUpOiBudW1iZXIge1xyXG5cdFx0Ly8gY29uc29sZS5sb2coXCJlbnRlciBleGVjIGluZGV4IFwiK2lucHV0LmluZGV4K1wiIGZyb20gXCIrZHMwLmNvbmZpZ3MpO1xyXG5cdFx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKGBzdGFydCBzdGF0ZSBjbG9zdXJlPSR7ZHMwLmNvbmZpZ3N9YCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGRzMC5pc0FjY2VwdFN0YXRlKSB7XHJcblx0XHRcdC8vIGFsbG93IHplcm8tbGVuZ3RoIHRva2Vuc1xyXG5cdFx0XHR0aGlzLmNhcHR1cmVTaW1TdGF0ZSh0aGlzLnByZXZBY2NlcHQsIGlucHV0LCBkczApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0OiBudW1iZXIgPSBpbnB1dC5MQSgxKTtcclxuXHRcdC8vIEBOb3ROdWxsXHJcblx0XHRsZXQgczogREZBU3RhdGUgPSBkczA7IC8vIHMgaXMgY3VycmVudC9mcm9tIERGQSBzdGF0ZVxyXG5cclxuXHRcdHdoaWxlICh0cnVlKSB7IC8vIHdoaWxlIG1vcmUgd29ya1xyXG5cdFx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhgZXhlY0FUTiBsb29wIHN0YXJ0aW5nIGNsb3N1cmU6ICR7cy5jb25maWdzfWApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBcyB3ZSBtb3ZlIHNyYy0+dHJnLCBzcmMtPnRyZywgd2Uga2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgdHJnIHRvXHJcblx0XHRcdC8vIGF2b2lkIGxvb2tpbmcgdXAgdGhlIERGQSBzdGF0ZSBhZ2Fpbiwgd2hpY2ggaXMgZXhwZW5zaXZlLlxyXG5cdFx0XHQvLyBJZiB0aGUgcHJldmlvdXMgdGFyZ2V0IHdhcyBhbHJlYWR5IHBhcnQgb2YgdGhlIERGQSwgd2UgbWlnaHRcclxuXHRcdFx0Ly8gYmUgYWJsZSB0byBhdm9pZCBkb2luZyBhIHJlYWNoIG9wZXJhdGlvbiB1cG9uIHQuIElmIHMhPW51bGwsXHJcblx0XHRcdC8vIGl0IG1lYW5zIHRoYXQgc2VtYW50aWMgcHJlZGljYXRlcyBkaWRuJ3QgcHJldmVudCB1cyBmcm9tXHJcblx0XHRcdC8vIGNyZWF0aW5nIGEgREZBIHN0YXRlLiBPbmNlIHdlIGtub3cgcyE9bnVsbCwgd2UgY2hlY2sgdG8gc2VlIGlmXHJcblx0XHRcdC8vIHRoZSBERkEgc3RhdGUgaGFzIGFuIGVkZ2UgYWxyZWFkeSBmb3IgdC4gSWYgc28sIHdlIGNhbiBqdXN0IHJldXNlXHJcblx0XHRcdC8vIGl0J3MgY29uZmlndXJhdGlvbiBzZXQ7IHRoZXJlJ3Mgbm8gcG9pbnQgaW4gcmUtY29tcHV0aW5nIGl0LlxyXG5cdFx0XHQvLyBUaGlzIGlzIGtpbmQgb2YgbGlrZSBkb2luZyBERkEgc2ltdWxhdGlvbiB3aXRoaW4gdGhlIEFUTlxyXG5cdFx0XHQvLyBzaW11bGF0aW9uIGJlY2F1c2UgREZBIHNpbXVsYXRpb24gaXMgcmVhbGx5IGp1c3QgYSB3YXkgdG8gYXZvaWRcclxuXHRcdFx0Ly8gY29tcHV0aW5nIHJlYWNoL2Nsb3N1cmUgc2V0cy4gVGVjaG5pY2FsbHksIG9uY2Ugd2Uga25vdyB0aGF0XHJcblx0XHRcdC8vIHdlIGhhdmUgYSBwcmV2aW91c2x5IGFkZGVkIERGQSBzdGF0ZSwgd2UgY291bGQganVtcCBvdmVyIHRvXHJcblx0XHRcdC8vIHRoZSBERkEgc2ltdWxhdG9yLiBCdXQsIHRoYXQgd291bGQgbWVhbiBwb3BwaW5nIGJhY2sgYW5kIGZvcnRoXHJcblx0XHRcdC8vIGEgbG90IGFuZCBtYWtpbmcgdGhpbmdzIG1vcmUgY29tcGxpY2F0ZWQgYWxnb3JpdGhtaWNhbGx5LlxyXG5cdFx0XHQvLyBUaGlzIG9wdGltaXphdGlvbiBtYWtlcyBhIGxvdCBvZiBzZW5zZSBmb3IgbG9vcHMgd2l0aGluIERGQS5cclxuXHRcdFx0Ly8gQSBjaGFyYWN0ZXIgd2lsbCB0YWtlIHVzIGJhY2sgdG8gYW4gZXhpc3RpbmcgREZBIHN0YXRlXHJcblx0XHRcdC8vIHRoYXQgYWxyZWFkeSBoYXMgbG90cyBvZiBlZGdlcyBvdXQgb2YgaXQuIGUuZy4sIC4qIGluIGNvbW1lbnRzLlxyXG5cdFx0XHRsZXQgdGFyZ2V0OiBERkFTdGF0ZSB8IHVuZGVmaW5lZCA9IHRoaXMuZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZShzLCB0KTtcclxuXHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XHJcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcy5jb21wdXRlVGFyZ2V0U3RhdGUoaW5wdXQsIHMsIHQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGFyZ2V0ID09PSBBVE5TaW11bGF0b3IuRVJST1IpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIGNvbnN1bWFibGUgaW5wdXQgZWxlbWVudCwgbWFrZSBzdXJlIHRvIGNvbnN1bWUgYmVmb3JlXHJcblx0XHRcdC8vIGNhcHR1cmluZyB0aGUgYWNjZXB0IHN0YXRlIHNvIHRoZSBpbnB1dCBpbmRleCwgbGluZSwgYW5kIGNoYXJcclxuXHRcdFx0Ly8gcG9zaXRpb24gYWNjdXJhdGVseSByZWZsZWN0IHRoZSBzdGF0ZSBvZiB0aGUgaW50ZXJwcmV0ZXIgYXQgdGhlXHJcblx0XHRcdC8vIGVuZCBvZiB0aGUgdG9rZW4uXHJcblx0XHRcdGlmICh0ICE9PSBJbnRTdHJlYW0uRU9GKSB7XHJcblx0XHRcdFx0dGhpcy5jb25zdW1lKGlucHV0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRhcmdldC5pc0FjY2VwdFN0YXRlKSB7XHJcblx0XHRcdFx0dGhpcy5jYXB0dXJlU2ltU3RhdGUodGhpcy5wcmV2QWNjZXB0LCBpbnB1dCwgdGFyZ2V0KTtcclxuXHRcdFx0XHRpZiAodCA9PT0gSW50U3RyZWFtLkVPRikge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0ID0gaW5wdXQuTEEoMSk7XHJcblx0XHRcdHMgPSB0YXJnZXQ7IC8vIGZsaXA7IGN1cnJlbnQgREZBIHRhcmdldCBiZWNvbWVzIG5ldyBzcmMvZnJvbSBzdGF0ZVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmZhaWxPckFjY2VwdCh0aGlzLnByZXZBY2NlcHQsIGlucHV0LCBzLmNvbmZpZ3MsIHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuIGV4aXN0aW5nIHRhcmdldCBzdGF0ZSBmb3IgYW4gZWRnZSBpbiB0aGUgREZBLiBJZiB0aGUgdGFyZ2V0IHN0YXRlXHJcblx0ICogZm9yIHRoZSBlZGdlIGhhcyBub3QgeWV0IGJlZW4gY29tcHV0ZWQgb3IgaXMgb3RoZXJ3aXNlIG5vdCBhdmFpbGFibGUsXHJcblx0ICogdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBzIFRoZSBjdXJyZW50IERGQSBzdGF0ZVxyXG5cdCAqIEBwYXJhbSB0IFRoZSBuZXh0IGlucHV0IHN5bWJvbFxyXG5cdCAqIEByZXR1cm5zIFRoZSBleGlzdGluZyB0YXJnZXQgREZBIHN0YXRlIGZvciB0aGUgZ2l2ZW4gaW5wdXQgc3ltYm9sXHJcblx0ICogYHRgLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgdGFyZ2V0IHN0YXRlIGZvciB0aGlzIGVkZ2UgaXMgbm90XHJcblx0ICogYWxyZWFkeSBjYWNoZWRcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZShATm90TnVsbCBzOiBERkFTdGF0ZSwgdDogbnVtYmVyKTogREZBU3RhdGUgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IHRhcmdldDogREZBU3RhdGUgfCB1bmRlZmluZWQgPSBzLmdldFRhcmdldCh0KTtcclxuXHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1ZyAmJiB0YXJnZXQgIT0gbnVsbCkge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcInJldXNlIHN0YXRlIFwiICsgcy5zdGF0ZU51bWJlciArXHJcblx0XHRcdFx0XCIgZWRnZSB0byBcIiArIHRhcmdldC5zdGF0ZU51bWJlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGUgYSB0YXJnZXQgc3RhdGUgZm9yIGFuIGVkZ2UgaW4gdGhlIERGQSwgYW5kIGF0dGVtcHQgdG8gYWRkIHRoZVxyXG5cdCAqIGNvbXB1dGVkIHN0YXRlIGFuZCBjb3JyZXNwb25kaW5nIGVkZ2UgdG8gdGhlIERGQS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgc3RyZWFtXHJcblx0ICogQHBhcmFtIHMgVGhlIGN1cnJlbnQgREZBIHN0YXRlXHJcblx0ICogQHBhcmFtIHQgVGhlIG5leHQgaW5wdXQgc3ltYm9sXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgdGFyZ2V0IERGQSBzdGF0ZSBmb3IgdGhlIGdpdmVuIGlucHV0IHN5bWJvbFxyXG5cdCAqIGB0YC4gSWYgYHRgIGRvZXMgbm90IGxlYWQgdG8gYSB2YWxpZCBERkEgc3RhdGUsIHRoaXMgbWV0aG9kXHJcblx0ICogcmV0dXJucyB7QGxpbmsgI0VSUk9SfS5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBjb21wdXRlVGFyZ2V0U3RhdGUoQE5vdE51bGwgaW5wdXQ6IENoYXJTdHJlYW0sIEBOb3ROdWxsIHM6IERGQVN0YXRlLCB0OiBudW1iZXIpOiBERkFTdGF0ZSB7XHJcblx0XHRsZXQgcmVhY2g6IEFUTkNvbmZpZ1NldCA9IG5ldyBPcmRlcmVkQVROQ29uZmlnU2V0KCk7XHJcblxyXG5cdFx0Ly8gaWYgd2UgZG9uJ3QgZmluZCBhbiBleGlzdGluZyBERkEgc3RhdGVcclxuXHRcdC8vIEZpbGwgcmVhY2ggc3RhcnRpbmcgZnJvbSBjbG9zdXJlLCBmb2xsb3dpbmcgdCB0cmFuc2l0aW9uc1xyXG5cdFx0dGhpcy5nZXRSZWFjaGFibGVDb25maWdTZXQoaW5wdXQsIHMuY29uZmlncywgcmVhY2gsIHQpO1xyXG5cclxuXHRcdGlmIChyZWFjaC5pc0VtcHR5KSB7IC8vIHdlIGdvdCBub3doZXJlIG9uIHQgZnJvbSBzXHJcblx0XHRcdGlmICghcmVhY2guaGFzU2VtYW50aWNDb250ZXh0KSB7XHJcblx0XHRcdFx0Ly8gd2UgZ290IG5vd2hlcmUgb24gdCwgZG9uJ3QgdGhyb3cgb3V0IHRoaXMga25vd2xlZGdlOyBpdCdkXHJcblx0XHRcdFx0Ly8gY2F1c2UgYSBmYWlsb3ZlciBmcm9tIERGQSBsYXRlci5cclxuXHRcdFx0XHR0aGlzLmFkZERGQUVkZ2UocywgdCwgQVROU2ltdWxhdG9yLkVSUk9SKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc3RvcCB3aGVuIHdlIGNhbid0IG1hdGNoIGFueSBtb3JlIGNoYXJcclxuXHRcdFx0cmV0dXJuIEFUTlNpbXVsYXRvci5FUlJPUjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBBZGQgYW4gZWRnZSBmcm9tIHMgdG8gdGFyZ2V0IERGQSBmb3VuZC9jcmVhdGVkIGZvciByZWFjaFxyXG5cdFx0cmV0dXJuIHRoaXMuYWRkREZBRWRnZShzLCB0LCByZWFjaCk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZmFpbE9yQWNjZXB0KFxyXG5cdFx0cHJldkFjY2VwdDogTGV4ZXJBVE5TaW11bGF0b3IuU2ltU3RhdGUsIGlucHV0OiBDaGFyU3RyZWFtLFxyXG5cdFx0cmVhY2g6IEFUTkNvbmZpZ1NldCwgdDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGlmIChwcmV2QWNjZXB0LmRmYVN0YXRlICE9IG51bGwpIHtcclxuXHRcdFx0bGV0IGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgfCB1bmRlZmluZWQgPSBwcmV2QWNjZXB0LmRmYVN0YXRlLmxleGVyQWN0aW9uRXhlY3V0b3I7XHJcblx0XHRcdHRoaXMuYWNjZXB0KGlucHV0LCBsZXhlckFjdGlvbkV4ZWN1dG9yLCB0aGlzLnN0YXJ0SW5kZXgsXHJcblx0XHRcdFx0cHJldkFjY2VwdC5pbmRleCwgcHJldkFjY2VwdC5saW5lLCBwcmV2QWNjZXB0LmNoYXJQb3MpO1xyXG5cdFx0XHRyZXR1cm4gcHJldkFjY2VwdC5kZmFTdGF0ZS5wcmVkaWN0aW9uO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdC8vIGlmIG5vIGFjY2VwdCBhbmQgRU9GIGlzIGZpcnN0IGNoYXIsIHJldHVybiBFT0ZcclxuXHRcdFx0aWYgKHQgPT09IEludFN0cmVhbS5FT0YgJiYgaW5wdXQuaW5kZXggPT09IHRoaXMuc3RhcnRJbmRleCkge1xyXG5cdFx0XHRcdHJldHVybiBUb2tlbi5FT0Y7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRocm93IG5ldyBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMucmVjb2csIGlucHV0LCB0aGlzLnN0YXJ0SW5kZXgsIHJlYWNoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBHaXZlbiBhIHN0YXJ0aW5nIGNvbmZpZ3VyYXRpb24gc2V0LCBmaWd1cmUgb3V0IGFsbCBBVE4gY29uZmlndXJhdGlvbnNcclxuXHQgKiAgd2UgY2FuIHJlYWNoIHVwb24gaW5wdXQgYHRgLiBQYXJhbWV0ZXIgYHJlYWNoYCBpcyBhIHJldHVyblxyXG5cdCAqICBwYXJhbWV0ZXIuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGdldFJlYWNoYWJsZUNvbmZpZ1NldChATm90TnVsbCBpbnB1dDogQ2hhclN0cmVhbSwgQE5vdE51bGwgY2xvc3VyZTogQVROQ29uZmlnU2V0LCBATm90TnVsbCByZWFjaDogQVROQ29uZmlnU2V0LCB0OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdC8vIHRoaXMgaXMgdXNlZCB0byBza2lwIHByb2Nlc3NpbmcgZm9yIGNvbmZpZ3Mgd2hpY2ggaGF2ZSBhIGxvd2VyIHByaW9yaXR5XHJcblx0XHQvLyB0aGFuIGEgY29uZmlnIHRoYXQgYWxyZWFkeSByZWFjaGVkIGFuIGFjY2VwdCBzdGF0ZSBmb3IgdGhlIHNhbWUgcnVsZVxyXG5cdFx0bGV0IHNraXBBbHQ6IG51bWJlciA9IEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XHJcblx0XHRmb3IgKGxldCBjIG9mIGNsb3N1cmUpIHtcclxuXHRcdFx0bGV0IGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGU6IGJvb2xlYW4gPSBjLmFsdCA9PT0gc2tpcEFsdDtcclxuXHRcdFx0aWYgKGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgJiYgYy5oYXNQYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24pIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coYHRlc3RpbmcgJHt0aGlzLmdldFRva2VuTmFtZSh0KX0gYXQgJHtjLnRvU3RyaW5nKHRoaXMucmVjb2csIHRydWUpfWApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgbjogbnVtYmVyID0gYy5zdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zO1xyXG5cdFx0XHRmb3IgKGxldCB0aSA9IDA7IHRpIDwgbjsgdGkrKykgeyAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIG9wdGltaXplZCB0cmFuc2l0aW9uXHJcblx0XHRcdFx0bGV0IHRyYW5zOiBUcmFuc2l0aW9uID0gYy5zdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKHRpKTtcclxuXHRcdFx0XHRsZXQgdGFyZ2V0OiBBVE5TdGF0ZSB8IHVuZGVmaW5lZCA9IHRoaXMuZ2V0UmVhY2hhYmxlVGFyZ2V0KHRyYW5zLCB0KTtcclxuXHRcdFx0XHRpZiAodGFyZ2V0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGxldCBsZXhlckFjdGlvbkV4ZWN1dG9yOiBMZXhlckFjdGlvbkV4ZWN1dG9yIHwgdW5kZWZpbmVkID0gYy5sZXhlckFjdGlvbkV4ZWN1dG9yO1xyXG5cdFx0XHRcdFx0bGV0IGNvbmZpZzogQVROQ29uZmlnO1xyXG5cdFx0XHRcdFx0aWYgKGxleGVyQWN0aW9uRXhlY3V0b3IgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRsZXhlckFjdGlvbkV4ZWN1dG9yID0gbGV4ZXJBY3Rpb25FeGVjdXRvci5maXhPZmZzZXRCZWZvcmVNYXRjaChpbnB1dC5pbmRleCAtIHRoaXMuc3RhcnRJbmRleCk7XHJcblx0XHRcdFx0XHRcdGNvbmZpZyA9IGMudHJhbnNmb3JtKHRhcmdldCwgdHJ1ZSwgbGV4ZXJBY3Rpb25FeGVjdXRvcik7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhc3NlcnQoYy5sZXhlckFjdGlvbkV4ZWN1dG9yID09IG51bGwpO1xyXG5cdFx0XHRcdFx0XHRjb25maWcgPSBjLnRyYW5zZm9ybSh0YXJnZXQsIHRydWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCB0cmVhdEVvZkFzRXBzaWxvbjogYm9vbGVhbiA9IHQgPT09IEludFN0cmVhbS5FT0Y7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5jbG9zdXJlKGlucHV0LCBjb25maWcsIHJlYWNoLCBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlLCB0cnVlLCB0cmVhdEVvZkFzRXBzaWxvbikpIHtcclxuXHRcdFx0XHRcdFx0Ly8gYW55IHJlbWFpbmluZyBjb25maWdzIGZvciB0aGlzIGFsdCBoYXZlIGEgbG93ZXIgcHJpb3JpdHkgdGhhblxyXG5cdFx0XHRcdFx0XHQvLyB0aGUgb25lIHRoYXQganVzdCByZWFjaGVkIGFuIGFjY2VwdCBzdGF0ZS5cclxuXHRcdFx0XHRcdFx0c2tpcEFsdCA9IGMuYWx0O1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBhY2NlcHQoXHJcblx0XHRATm90TnVsbCBpbnB1dDogQ2hhclN0cmVhbSwgbGV4ZXJBY3Rpb25FeGVjdXRvcjogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlciwgbGluZTogbnVtYmVyLCBjaGFyUG9zOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhgQUNUSU9OICR7bGV4ZXJBY3Rpb25FeGVjdXRvcn1gKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWVrIHRvIGFmdGVyIGxhc3QgY2hhciBpbiB0b2tlblxyXG5cdFx0aW5wdXQuc2VlayhpbmRleCk7XHJcblx0XHR0aGlzLl9saW5lID0gbGluZTtcclxuXHRcdHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSA9IGNoYXJQb3M7XHJcblxyXG5cdFx0aWYgKGxleGVyQWN0aW9uRXhlY3V0b3IgIT0gbnVsbCAmJiB0aGlzLnJlY29nICE9IG51bGwpIHtcclxuXHRcdFx0bGV4ZXJBY3Rpb25FeGVjdXRvci5leGVjdXRlKHRoaXMucmVjb2csIGlucHV0LCBzdGFydEluZGV4KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRSZWFjaGFibGVUYXJnZXQodHJhbnM6IFRyYW5zaXRpb24sIHQ6IG51bWJlcik6IEFUTlN0YXRlIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICh0cmFucy5tYXRjaGVzKHQsIExleGVyLk1JTl9DSEFSX1ZBTFVFLCBMZXhlci5NQVhfQ0hBUl9WQUxVRSkpIHtcclxuXHRcdFx0cmV0dXJuIHRyYW5zLnRhcmdldDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgY29tcHV0ZVN0YXJ0U3RhdGUoXHJcblx0XHRATm90TnVsbCBpbnB1dDogQ2hhclN0cmVhbSxcclxuXHRcdEBOb3ROdWxsIHA6IEFUTlN0YXRlKTogQVROQ29uZmlnU2V0IHtcclxuXHRcdGxldCBpbml0aWFsQ29udGV4dDogUHJlZGljdGlvbkNvbnRleHQgPSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMO1xyXG5cdFx0bGV0IGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCA9IG5ldyBPcmRlcmVkQVROQ29uZmlnU2V0KCk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHAubnVtYmVyT2ZUcmFuc2l0aW9uczsgaSsrKSB7XHJcblx0XHRcdGxldCB0YXJnZXQ6IEFUTlN0YXRlID0gcC50cmFuc2l0aW9uKGkpLnRhcmdldDtcclxuXHRcdFx0bGV0IGM6IEFUTkNvbmZpZyA9IEFUTkNvbmZpZy5jcmVhdGUodGFyZ2V0LCBpICsgMSwgaW5pdGlhbENvbnRleHQpO1xyXG5cdFx0XHR0aGlzLmNsb3N1cmUoaW5wdXQsIGMsIGNvbmZpZ3MsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNvbmZpZ3M7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTaW5jZSB0aGUgYWx0ZXJuYXRpdmVzIHdpdGhpbiBhbnkgbGV4ZXIgZGVjaXNpb24gYXJlIG9yZGVyZWQgYnlcclxuXHQgKiBwcmVmZXJlbmNlLCB0aGlzIG1ldGhvZCBzdG9wcyBwdXJzdWluZyB0aGUgY2xvc3VyZSBhcyBzb29uIGFzIGFuIGFjY2VwdFxyXG5cdCAqIHN0YXRlIGlzIHJlYWNoZWQuIEFmdGVyIHRoZSBmaXJzdCBhY2NlcHQgc3RhdGUgaXMgcmVhY2hlZCBieSBkZXB0aC1maXJzdFxyXG5cdCAqIHNlYXJjaCBmcm9tIGBjb25maWdgLCBhbGwgb3RoZXIgKHBvdGVudGlhbGx5IHJlYWNoYWJsZSkgc3RhdGVzIGZvclxyXG5cdCAqIHRoaXMgcnVsZSB3b3VsZCBoYXZlIGEgbG93ZXIgcHJpb3JpdHkuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYW4gYWNjZXB0IHN0YXRlIGlzIHJlYWNoZWQsIG90aGVyd2lzZVxyXG5cdCAqIGBmYWxzZWAuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGNsb3N1cmUoQE5vdE51bGwgaW5wdXQ6IENoYXJTdHJlYW0sIEBOb3ROdWxsIGNvbmZpZzogQVROQ29uZmlnLCBATm90TnVsbCBjb25maWdzOiBBVE5Db25maWdTZXQsIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGU6IGJvb2xlYW4sIHNwZWN1bGF0aXZlOiBib29sZWFuLCB0cmVhdEVvZkFzRXBzaWxvbjogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiY2xvc3VyZShcIiArIGNvbmZpZy50b1N0cmluZyh0aGlzLnJlY29nLCB0cnVlKSArIFwiKVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xyXG5cdFx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5yZWNvZyAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgY2xvc3VyZSBhdCAke3RoaXMucmVjb2cucnVsZU5hbWVzW2NvbmZpZy5zdGF0ZS5ydWxlSW5kZXhdfSBydWxlIHN0b3AgJHtjb25maWd9YCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYGNsb3N1cmUgYXQgcnVsZSBzdG9wICR7Y29uZmlnfWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0ID0gY29uZmlnLmNvbnRleHQ7XHJcblx0XHRcdGlmIChjb250ZXh0LmlzRW1wdHkpIHtcclxuXHRcdFx0XHRjb25maWdzLmFkZChjb25maWcpO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKGNvbnRleHQuaGFzRW1wdHkpIHtcclxuXHRcdFx0XHRjb25maWdzLmFkZChjb25maWcudHJhbnNmb3JtKGNvbmZpZy5zdGF0ZSwgdHJ1ZSwgUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTCkpO1xyXG5cdFx0XHRcdGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRleHQuc2l6ZTsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IHJldHVyblN0YXRlTnVtYmVyOiBudW1iZXIgPSBjb250ZXh0LmdldFJldHVyblN0YXRlKGkpO1xyXG5cdFx0XHRcdGlmIChyZXR1cm5TdGF0ZU51bWJlciA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVkpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IG5ld0NvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0ID0gY29udGV4dC5nZXRQYXJlbnQoaSk7IC8vIFwicG9wXCIgcmV0dXJuIHN0YXRlXHJcblx0XHRcdFx0bGV0IHJldHVyblN0YXRlOiBBVE5TdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tyZXR1cm5TdGF0ZU51bWJlcl07XHJcblx0XHRcdFx0bGV0IGM6IEFUTkNvbmZpZyA9IGNvbmZpZy50cmFuc2Zvcm0ocmV0dXJuU3RhdGUsIGZhbHNlLCBuZXdDb250ZXh0KTtcclxuXHRcdFx0XHRjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlID0gdGhpcy5jbG9zdXJlKGlucHV0LCBjLCBjb25maWdzLCBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlLCBzcGVjdWxhdGl2ZSwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvcHRpbWl6YXRpb25cclxuXHRcdGlmICghY29uZmlnLnN0YXRlLm9ubHlIYXNFcHNpbG9uVHJhbnNpdGlvbnMpIHtcclxuXHRcdFx0aWYgKCFjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlIHx8ICFjb25maWcuaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uKSB7XHJcblx0XHRcdFx0Y29uZmlncy5hZGQoY29uZmlnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBwOiBBVE5TdGF0ZSA9IGNvbmZpZy5zdGF0ZTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcC5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zOyBpKyspIHtcclxuXHRcdFx0bGV0IHQ6IFRyYW5zaXRpb24gPSBwLmdldE9wdGltaXplZFRyYW5zaXRpb24oaSk7XHJcblx0XHRcdGxldCBjOiBBVE5Db25maWcgfCB1bmRlZmluZWQgPSB0aGlzLmdldEVwc2lsb25UYXJnZXQoaW5wdXQsIGNvbmZpZywgdCwgY29uZmlncywgc3BlY3VsYXRpdmUsIHRyZWF0RW9mQXNFcHNpbG9uKTtcclxuXHRcdFx0aWYgKGMgIT0gbnVsbCkge1xyXG5cdFx0XHRcdGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgPSB0aGlzLmNsb3N1cmUoaW5wdXQsIGMsIGNvbmZpZ3MsIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUsIHNwZWN1bGF0aXZlLCB0cmVhdEVvZkFzRXBzaWxvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZTtcclxuXHR9XHJcblxyXG5cdC8vIHNpZGUtZWZmZWN0OiBjYW4gYWx0ZXIgY29uZmlncy5oYXNTZW1hbnRpY0NvbnRleHRcclxuXHRwcm90ZWN0ZWQgZ2V0RXBzaWxvblRhcmdldChcclxuXHRcdEBOb3ROdWxsIGlucHV0OiBDaGFyU3RyZWFtLFxyXG5cdFx0QE5vdE51bGwgY29uZmlnOiBBVE5Db25maWcsXHJcblx0XHRATm90TnVsbCB0OiBUcmFuc2l0aW9uLFxyXG5cdFx0QE5vdE51bGwgY29uZmlnczogQVROQ29uZmlnU2V0LFxyXG5cdFx0c3BlY3VsYXRpdmU6IGJvb2xlYW4sXHJcblx0XHR0cmVhdEVvZkFzRXBzaWxvbjogYm9vbGVhbik6IEFUTkNvbmZpZyB8IHVuZGVmaW5lZCB7XHJcblx0XHRsZXQgYzogQVROQ29uZmlnIHwgdW5kZWZpbmVkO1xyXG5cclxuXHRcdHN3aXRjaCAodC5zZXJpYWxpemF0aW9uVHlwZSkge1xyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5SVUxFOlxyXG5cdFx0XHRsZXQgcnVsZVRyYW5zaXRpb246IFJ1bGVUcmFuc2l0aW9uID0gdCBhcyBSdWxlVHJhbnNpdGlvbjtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW1pemVfdGFpbF9jYWxscyAmJiBydWxlVHJhbnNpdGlvbi5vcHRpbWl6ZWRUYWlsQ2FsbCAmJiAhY29uZmlnLmNvbnRleHQuaGFzRW1wdHkpIHtcclxuXHRcdFx0XHRjID0gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0bGV0IG5ld0NvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0ID0gY29uZmlnLmNvbnRleHQuZ2V0Q2hpbGQocnVsZVRyYW5zaXRpb24uZm9sbG93U3RhdGUuc3RhdGVOdW1iZXIpO1xyXG5cdFx0XHRcdGMgPSBjb25maWcudHJhbnNmb3JtKHQudGFyZ2V0LCB0cnVlLCBuZXdDb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5QUkVDRURFTkNFOlxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQcmVjZWRlbmNlIHByZWRpY2F0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbGV4ZXJzLlwiKTtcclxuXHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlBSRURJQ0FURTpcclxuXHRcdFx0LyogIFRyYWNrIHRyYXZlcnNpbmcgc2VtYW50aWMgcHJlZGljYXRlcy4gSWYgd2UgdHJhdmVyc2UsXHJcblx0XHRcdFx0d2UgY2Fubm90IGFkZCBhIERGQSBzdGF0ZSBmb3IgdGhpcyBcInJlYWNoXCIgY29tcHV0YXRpb25cclxuXHRcdFx0XHRiZWNhdXNlIHRoZSBERkEgd291bGQgbm90IHRlc3QgdGhlIHByZWRpY2F0ZSBhZ2FpbiBpbiB0aGVcclxuXHRcdFx0XHRmdXR1cmUuIFJhdGhlciB0aGFuIGNyZWF0aW5nIGNvbGxlY3Rpb25zIG9mIHNlbWFudGljIHByZWRpY2F0ZXNcclxuXHRcdFx0XHRsaWtlIHYzIGFuZCB0ZXN0aW5nIHRoZW0gb24gcHJlZGljdGlvbiwgdjQgd2lsbCB0ZXN0IHRoZW0gb24gdGhlXHJcblx0XHRcdFx0Zmx5IGFsbCB0aGUgdGltZSB1c2luZyB0aGUgQVROIG5vdCB0aGUgREZBLiBUaGlzIGlzIHNsb3dlciBidXRcclxuXHRcdFx0XHRzZW1hbnRpY2FsbHkgaXQncyBub3QgdXNlZCB0aGF0IG9mdGVuLiBPbmUgb2YgdGhlIGtleSBlbGVtZW50cyB0b1xyXG5cdFx0XHRcdHRoaXMgcHJlZGljYXRlIG1lY2hhbmlzbSBpcyBub3QgYWRkaW5nIERGQSBzdGF0ZXMgdGhhdCBzZWVcclxuXHRcdFx0XHRwcmVkaWNhdGVzIGltbWVkaWF0ZWx5IGFmdGVyd2FyZHMgaW4gdGhlIEFUTi4gRm9yIGV4YW1wbGUsXHJcblxyXG5cdFx0XHRcdGEgOiBJRCB7cDF9PyB8IElEIHtwMn0/IDtcclxuXHJcblx0XHRcdFx0c2hvdWxkIGNyZWF0ZSB0aGUgc3RhcnQgc3RhdGUgZm9yIHJ1bGUgJ2EnICh0byBzYXZlIHN0YXJ0IHN0YXRlXHJcblx0XHRcdFx0Y29tcGV0aXRpb24pLCBidXQgc2hvdWxkIG5vdCBjcmVhdGUgdGFyZ2V0IG9mIElEIHN0YXRlLiBUaGVcclxuXHRcdFx0XHRjb2xsZWN0aW9uIG9mIEFUTiBzdGF0ZXMgdGhlIGZvbGxvd2luZyBJRCByZWZlcmVuY2VzIGluY2x1ZGVzXHJcblx0XHRcdFx0c3RhdGVzIHJlYWNoZWQgYnkgdHJhdmVyc2luZyBwcmVkaWNhdGVzLiBTaW5jZSB0aGlzIGlzIHdoZW4gd2VcclxuXHRcdFx0XHR0ZXN0IHRoZW0sIHdlIGNhbm5vdCBjYXNoIHRoZSBERkEgc3RhdGUgdGFyZ2V0IG9mIElELlxyXG5cdFx0XHQqL1xyXG5cdFx0XHRsZXQgcHQ6IFByZWRpY2F0ZVRyYW5zaXRpb24gPSB0IGFzIFByZWRpY2F0ZVRyYW5zaXRpb247XHJcblx0XHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiRVZBTCBydWxlIFwiICsgcHQucnVsZUluZGV4ICsgXCI6XCIgKyBwdC5wcmVkSW5kZXgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNvbmZpZ3MuaGFzU2VtYW50aWNDb250ZXh0ID0gdHJ1ZTtcclxuXHRcdFx0aWYgKHRoaXMuZXZhbHVhdGVQcmVkaWNhdGUoaW5wdXQsIHB0LnJ1bGVJbmRleCwgcHQucHJlZEluZGV4LCBzcGVjdWxhdGl2ZSkpIHtcclxuXHRcdFx0XHRjID0gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0YyA9IHVuZGVmaW5lZDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5BQ1RJT046XHJcblx0XHRcdGlmIChjb25maWcuY29udGV4dC5oYXNFbXB0eSkge1xyXG5cdFx0XHRcdC8vIGV4ZWN1dGUgYWN0aW9ucyBhbnl3aGVyZSBpbiB0aGUgc3RhcnQgcnVsZSBmb3IgYSB0b2tlbi5cclxuXHRcdFx0XHQvL1xyXG5cdFx0XHRcdC8vIFRPRE86IGlmIHRoZSBlbnRyeSBydWxlIGlzIGludm9rZWQgcmVjdXJzaXZlbHksIHNvbWVcclxuXHRcdFx0XHQvLyBhY3Rpb25zIG1heSBiZSBleGVjdXRlZCBkdXJpbmcgdGhlIHJlY3Vyc2l2ZSBjYWxsLiBUaGVcclxuXHRcdFx0XHQvLyBwcm9ibGVtIGNhbiBhcHBlYXIgd2hlbiBoYXNFbXB0eSBpcyB0cnVlIGJ1dFxyXG5cdFx0XHRcdC8vIGlzRW1wdHkgaXMgZmFsc2UuIEluIHRoaXMgY2FzZSwgdGhlIGNvbmZpZyBuZWVkcyB0byBiZVxyXG5cdFx0XHRcdC8vIHNwbGl0IGludG8gdHdvIGNvbnRleHRzIC0gb25lIHdpdGgganVzdCB0aGUgZW1wdHkgcGF0aFxyXG5cdFx0XHRcdC8vIGFuZCBhbm90aGVyIHdpdGggZXZlcnl0aGluZyBidXQgdGhlIGVtcHR5IHBhdGguXHJcblx0XHRcdFx0Ly8gVW5mb3J0dW5hdGVseSwgdGhlIGN1cnJlbnQgYWxnb3JpdGhtIGRvZXMgbm90IGFsbG93XHJcblx0XHRcdFx0Ly8gZ2V0RXBzaWxvblRhcmdldCB0byByZXR1cm4gdHdvIGNvbmZpZ3VyYXRpb25zLCBzb1xyXG5cdFx0XHRcdC8vIGFkZGl0aW9uYWwgbW9kaWZpY2F0aW9ucyBhcmUgbmVlZGVkIGJlZm9yZSB3ZSBjYW4gc3VwcG9ydFxyXG5cdFx0XHRcdC8vIHRoZSBzcGxpdCBvcGVyYXRpb24uXHJcblx0XHRcdFx0bGV0IGxleGVyQWN0aW9uRXhlY3V0b3I6IExleGVyQWN0aW9uRXhlY3V0b3IgPSBMZXhlckFjdGlvbkV4ZWN1dG9yLmFwcGVuZChjb25maWcubGV4ZXJBY3Rpb25FeGVjdXRvciwgdGhpcy5hdG4ubGV4ZXJBY3Rpb25zWyh0IGFzIEFjdGlvblRyYW5zaXRpb24pLmFjdGlvbkluZGV4XSk7XHJcblx0XHRcdFx0YyA9IGNvbmZpZy50cmFuc2Zvcm0odC50YXJnZXQsIHRydWUsIGxleGVyQWN0aW9uRXhlY3V0b3IpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdC8vIGlnbm9yZSBhY3Rpb25zIGluIHJlZmVyZW5jZWQgcnVsZXNcclxuXHRcdFx0XHRjID0gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgdHJ1ZSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLkVQU0lMT046XHJcblx0XHRcdGMgPSBjb25maWcudHJhbnNmb3JtKHQudGFyZ2V0LCB0cnVlKTtcclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5BVE9NOlxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5SQU5HRTpcclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuU0VUOlxyXG5cdFx0XHRpZiAodHJlYXRFb2ZBc0Vwc2lsb24pIHtcclxuXHRcdFx0XHRpZiAodC5tYXRjaGVzKEludFN0cmVhbS5FT0YsIExleGVyLk1JTl9DSEFSX1ZBTFVFLCBMZXhlci5NQVhfQ0hBUl9WQUxVRSkpIHtcclxuXHRcdFx0XHRcdGMgPSBjb25maWcudHJhbnNmb3JtKHQudGFyZ2V0LCBmYWxzZSk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGMgPSB1bmRlZmluZWQ7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdGMgPSB1bmRlZmluZWQ7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXZhbHVhdGUgYSBwcmVkaWNhdGUgc3BlY2lmaWVkIGluIHRoZSBsZXhlci5cclxuXHQgKlxyXG5cdCAqIElmIGBzcGVjdWxhdGl2ZWAgaXMgYHRydWVgLCB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIGJlZm9yZVxyXG5cdCAqIHtAbGluayAjY29uc3VtZX0gZm9yIHRoZSBtYXRjaGVkIGNoYXJhY3Rlci4gVGhpcyBtZXRob2Qgc2hvdWxkIGNhbGxcclxuXHQgKiB7QGxpbmsgI2NvbnN1bWV9IGJlZm9yZSBldmFsdWF0aW5nIHRoZSBwcmVkaWNhdGUgdG8gZW5zdXJlIHBvc2l0aW9uXHJcblx0ICogc2Vuc2l0aXZlIHZhbHVlcywgaW5jbHVkaW5nIHtAbGluayBMZXhlciNnZXRUZXh0fSwge0BsaW5rIExleGVyI2dldExpbmV9LFxyXG5cdCAqIGFuZCB7QGxpbmsgTGV4ZXIjZ2V0Q2hhclBvc2l0aW9uSW5MaW5lfSwgcHJvcGVybHkgcmVmbGVjdCB0aGUgY3VycmVudFxyXG5cdCAqIGxleGVyIHN0YXRlLiBUaGlzIG1ldGhvZCBzaG91bGQgcmVzdG9yZSBgaW5wdXRgIGFuZCB0aGUgc2ltdWxhdG9yXHJcblx0ICogdG8gdGhlIG9yaWdpbmFsIHN0YXRlIGJlZm9yZSByZXR1cm5pbmcgKGkuZS4gdW5kbyB0aGUgYWN0aW9ucyBtYWRlIGJ5IHRoZVxyXG5cdCAqIGNhbGwgdG8ge0BsaW5rICNjb25zdW1lfS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgc3RyZWFtLlxyXG5cdCAqIEBwYXJhbSBydWxlSW5kZXggVGhlIHJ1bGUgY29udGFpbmluZyB0aGUgcHJlZGljYXRlLlxyXG5cdCAqIEBwYXJhbSBwcmVkSW5kZXggVGhlIGluZGV4IG9mIHRoZSBwcmVkaWNhdGUgd2l0aGluIHRoZSBydWxlLlxyXG5cdCAqIEBwYXJhbSBzcGVjdWxhdGl2ZSBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgaW5kZXggaW4gYGlucHV0YCBpc1xyXG5cdCAqIG9uZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBwcmVkaWNhdGUncyBsb2NhdGlvbi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZSBldmFsdWF0ZXMgdG9cclxuXHQgKiBgdHJ1ZWAuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGV2YWx1YXRlUHJlZGljYXRlKEBOb3ROdWxsIGlucHV0OiBDaGFyU3RyZWFtLCBydWxlSW5kZXg6IG51bWJlciwgcHJlZEluZGV4OiBudW1iZXIsIHNwZWN1bGF0aXZlOiBib29sZWFuKTogYm9vbGVhbiB7XHJcblx0XHQvLyBhc3N1bWUgdHJ1ZSBpZiBubyByZWNvZ25pemVyIHdhcyBwcm92aWRlZFxyXG5cdFx0aWYgKHRoaXMucmVjb2cgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXNwZWN1bGF0aXZlKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnJlY29nLnNlbXByZWQodW5kZWZpbmVkLCBydWxlSW5kZXgsIHByZWRJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHNhdmVkQ2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXIgPSB0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0XHRsZXQgc2F2ZWRMaW5lOiBudW1iZXIgPSB0aGlzLl9saW5lO1xyXG5cdFx0bGV0IGluZGV4OiBudW1iZXIgPSBpbnB1dC5pbmRleDtcclxuXHRcdGxldCBtYXJrZXI6IG51bWJlciA9IGlucHV0Lm1hcmsoKTtcclxuXHRcdHRyeSB7XHJcblx0XHRcdHRoaXMuY29uc3VtZShpbnB1dCk7XHJcblx0XHRcdHJldHVybiB0aGlzLnJlY29nLnNlbXByZWQodW5kZWZpbmVkLCBydWxlSW5kZXgsIHByZWRJbmRleCk7XHJcblx0XHR9XHJcblx0XHRmaW5hbGx5IHtcclxuXHRcdFx0dGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lID0gc2F2ZWRDaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0XHRcdHRoaXMuX2xpbmUgPSBzYXZlZExpbmU7XHJcblx0XHRcdGlucHV0LnNlZWsoaW5kZXgpO1xyXG5cdFx0XHRpbnB1dC5yZWxlYXNlKG1hcmtlcik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgY2FwdHVyZVNpbVN0YXRlKFxyXG5cdFx0QE5vdE51bGwgc2V0dGluZ3M6IExleGVyQVROU2ltdWxhdG9yLlNpbVN0YXRlLFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IENoYXJTdHJlYW0sXHJcblx0XHRATm90TnVsbCBkZmFTdGF0ZTogREZBU3RhdGUpOiB2b2lkIHtcclxuXHRcdHNldHRpbmdzLmluZGV4ID0gaW5wdXQuaW5kZXg7XHJcblx0XHRzZXR0aW5ncy5saW5lID0gdGhpcy5fbGluZTtcclxuXHRcdHNldHRpbmdzLmNoYXJQb3MgPSB0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0XHRzZXR0aW5ncy5kZmFTdGF0ZSA9IGRmYVN0YXRlO1xyXG5cdH1cclxuXHJcblx0Ly8gQE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgYWRkREZBRWRnZSgvKkBOb3ROdWxsKi8gcDogREZBU3RhdGUsIHQ6IG51bWJlciwgLypATm90TnVsbCovIHE6IEFUTkNvbmZpZ1NldCk6IERGQVN0YXRlO1xyXG5cdHByb3RlY3RlZCBhZGRERkFFZGdlKC8qQE5vdE51bGwqLyBwOiBERkFTdGF0ZSwgdDogbnVtYmVyLCAvKkBOb3ROdWxsKi8gcTogREZBU3RhdGUpOiB2b2lkO1xyXG5cdHByb3RlY3RlZCBhZGRERkFFZGdlKHA6IERGQVN0YXRlLCB0OiBudW1iZXIsIHE6IEFUTkNvbmZpZ1NldCB8IERGQVN0YXRlKTogREZBU3RhdGUgfCB2b2lkIHtcclxuXHRcdGlmIChxIGluc3RhbmNlb2YgQVROQ29uZmlnU2V0KSB7XHJcblx0XHRcdC8qIGxlYWRpbmcgdG8gdGhpcyBjYWxsLCBBVE5Db25maWdTZXQuaGFzU2VtYW50aWNDb250ZXh0IGlzIHVzZWQgYXMgYVxyXG5cdFx0XHQqIG1hcmtlciBpbmRpY2F0aW5nIGR5bmFtaWMgcHJlZGljYXRlIGV2YWx1YXRpb24gbWFrZXMgdGhpcyBlZGdlXHJcblx0XHRcdCogZGVwZW5kZW50IG9uIHRoZSBzcGVjaWZpYyBpbnB1dCBzZXF1ZW5jZSwgc28gdGhlIHN0YXRpYyBlZGdlIGluIHRoZVxyXG5cdFx0XHQqIERGQSBzaG91bGQgYmUgb21pdHRlZC4gVGhlIHRhcmdldCBERkFTdGF0ZSBpcyBzdGlsbCBjcmVhdGVkIHNpbmNlXHJcblx0XHRcdCogZXhlY0FUTiBoYXMgdGhlIGFiaWxpdHkgdG8gcmVzeW5jaHJvbml6ZSB3aXRoIHRoZSBERkEgc3RhdGUgY2FjaGVcclxuXHRcdFx0KiBmb2xsb3dpbmcgdGhlIHByZWRpY2F0ZSBldmFsdWF0aW9uIHN0ZXAuXHJcblx0XHRcdCpcclxuXHRcdFx0KiBUSlAgbm90ZXM6IG5leHQgdGltZSB0aHJvdWdoIHRoZSBERkEsIHdlIHNlZSBhIHByZWQgYWdhaW4gYW5kIGV2YWwuXHJcblx0XHRcdCogSWYgdGhhdCBnZXRzIHVzIHRvIGEgcHJldmlvdXNseSBjcmVhdGVkIChidXQgZGFuZ2xpbmcpIERGQVxyXG5cdFx0XHQqIHN0YXRlLCB3ZSBjYW4gY29udGludWUgaW4gcHVyZSBERkEgbW9kZSBmcm9tIHRoZXJlLlxyXG5cdFx0XHQqL1xyXG5cdFx0XHRsZXQgc3VwcHJlc3NFZGdlOiBib29sZWFuID0gcS5oYXNTZW1hbnRpY0NvbnRleHQ7XHJcblx0XHRcdGlmIChzdXBwcmVzc0VkZ2UpIHtcclxuXHRcdFx0XHRxLmhhc1NlbWFudGljQ29udGV4dCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBATm90TnVsbFxyXG5cdFx0XHRsZXQgdG86IERGQVN0YXRlID0gdGhpcy5hZGRERkFTdGF0ZShxKTtcclxuXHJcblx0XHRcdGlmIChzdXBwcmVzc0VkZ2UpIHtcclxuXHRcdFx0XHRyZXR1cm4gdG87XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYWRkREZBRWRnZShwLCB0LCB0byk7XHJcblx0XHRcdHJldHVybiB0bztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiRURHRSBcIiArIHAgKyBcIiAtPiBcIiArIHEgKyBcIiB1cG9uIFwiICsgU3RyaW5nLmZyb21DaGFyQ29kZSh0KSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChwICE9IG51bGwpIHtcclxuXHRcdFx0XHRwLnNldFRhcmdldCh0LCBxKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqIEFkZCBhIG5ldyBERkEgc3RhdGUgaWYgdGhlcmUgaXNuJ3Qgb25lIHdpdGggdGhpcyBzZXQgb2ZcclxuXHQgKiBcdGNvbmZpZ3VyYXRpb25zIGFscmVhZHkuIFRoaXMgbWV0aG9kIGFsc28gZGV0ZWN0cyB0aGUgZmlyc3RcclxuXHQgKiBcdGNvbmZpZ3VyYXRpb24gY29udGFpbmluZyBhbiBBVE4gcnVsZSBzdG9wIHN0YXRlLiBMYXRlciwgd2hlblxyXG5cdCAqIFx0dHJhdmVyc2luZyB0aGUgREZBLCB3ZSB3aWxsIGtub3cgd2hpY2ggcnVsZSB0byBhY2NlcHQuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgYWRkREZBU3RhdGUoQE5vdE51bGwgY29uZmlnczogQVROQ29uZmlnU2V0KTogREZBU3RhdGUge1xyXG5cdFx0LyogdGhlIGxleGVyIGV2YWx1YXRlcyBwcmVkaWNhdGVzIG9uLXRoZS1mbHk7IGJ5IHRoaXMgcG9pbnQgY29uZmlnc1xyXG5cdFx0ICogc2hvdWxkIG5vdCBjb250YWluIGFueSBjb25maWd1cmF0aW9ucyB3aXRoIHVuZXZhbHVhdGVkIHByZWRpY2F0ZXMuXHJcblx0XHQgKi9cclxuXHRcdGFzc2VydCghY29uZmlncy5oYXNTZW1hbnRpY0NvbnRleHQpO1xyXG5cclxuXHRcdGxldCBwcm9wb3NlZDogREZBU3RhdGUgPSBuZXcgREZBU3RhdGUoY29uZmlncyk7XHJcblx0XHRsZXQgZXhpc3Rpbmc6IERGQVN0YXRlIHwgdW5kZWZpbmVkID0gdGhpcy5hdG4ubW9kZVRvREZBW3RoaXMubW9kZV0uc3RhdGVzLmdldChwcm9wb3NlZCk7XHJcblx0XHRpZiAoZXhpc3RpbmcgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gZXhpc3Rpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlncy5vcHRpbWl6ZUNvbmZpZ3ModGhpcyk7XHJcblx0XHRsZXQgbmV3U3RhdGU6IERGQVN0YXRlID0gbmV3IERGQVN0YXRlKGNvbmZpZ3MuY2xvbmUodHJ1ZSkpO1xyXG5cclxuXHRcdGxldCBmaXJzdENvbmZpZ1dpdGhSdWxlU3RvcFN0YXRlOiBBVE5Db25maWcgfCB1bmRlZmluZWQ7XHJcblx0XHRmb3IgKGxldCBjIG9mIGNvbmZpZ3MpIHtcclxuXHRcdFx0aWYgKGMuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XHJcblx0XHRcdFx0Zmlyc3RDb25maWdXaXRoUnVsZVN0b3BTdGF0ZSA9IGM7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZmlyc3RDb25maWdXaXRoUnVsZVN0b3BTdGF0ZSAhPSBudWxsKSB7XHJcblx0XHRcdGxldCBwcmVkaWN0aW9uOiBudW1iZXIgPSB0aGlzLmF0bi5ydWxlVG9Ub2tlblR5cGVbZmlyc3RDb25maWdXaXRoUnVsZVN0b3BTdGF0ZS5zdGF0ZS5ydWxlSW5kZXhdO1xyXG5cdFx0XHRsZXQgbGV4ZXJBY3Rpb25FeGVjdXRvcjogTGV4ZXJBY3Rpb25FeGVjdXRvciB8IHVuZGVmaW5lZCA9IGZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGUubGV4ZXJBY3Rpb25FeGVjdXRvcjtcclxuXHRcdFx0bmV3U3RhdGUuYWNjZXB0U3RhdGVJbmZvID0gbmV3IEFjY2VwdFN0YXRlSW5mbyhwcmVkaWN0aW9uLCBsZXhlckFjdGlvbkV4ZWN1dG9yKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdG4ubW9kZVRvREZBW3RoaXMubW9kZV0uYWRkU3RhdGUobmV3U3RhdGUpO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0REZBKG1vZGU6IG51bWJlcik6IERGQSB7XHJcblx0XHRyZXR1cm4gdGhpcy5hdG4ubW9kZVRvREZBW21vZGVdO1xyXG5cdH1cclxuXHJcblx0LyoqIEdldCB0aGUgdGV4dCBtYXRjaGVkIHNvIGZhciBmb3IgdGhlIGN1cnJlbnQgdG9rZW4uXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0VGV4dChATm90TnVsbCBpbnB1dDogQ2hhclN0cmVhbSk6IHN0cmluZyB7XHJcblx0XHQvLyBpbmRleCBpcyBmaXJzdCBsb29rYWhlYWQgY2hhciwgZG9uJ3QgaW5jbHVkZS5cclxuXHRcdHJldHVybiBpbnB1dC5nZXRUZXh0KEludGVydmFsLm9mKHRoaXMuc3RhcnRJbmRleCwgaW5wdXQuaW5kZXggLSAxKSk7XHJcblx0fVxyXG5cclxuXHRnZXQgbGluZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xpbmU7XHJcblx0fVxyXG5cclxuXHRzZXQgbGluZShsaW5lOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuX2xpbmUgPSBsaW5lO1xyXG5cdH1cclxuXHJcblx0Z2V0IGNoYXJQb3NpdGlvbkluTGluZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZTtcclxuXHR9XHJcblxyXG5cdHNldCBjaGFyUG9zaXRpb25JbkxpbmUoY2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSA9IGNoYXJQb3NpdGlvbkluTGluZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBjb25zdW1lKEBOb3ROdWxsIGlucHV0OiBDaGFyU3RyZWFtKTogdm9pZCB7XHJcblx0XHRsZXQgY3VyQ2hhcjogbnVtYmVyID0gaW5wdXQuTEEoMSk7XHJcblx0XHRpZiAoY3VyQ2hhciA9PT0gXCJcXG5cIi5jaGFyQ29kZUF0KDApKSB7XHJcblx0XHRcdHRoaXMuX2xpbmUrKztcclxuXHRcdFx0dGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lID0gMDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSsrO1xyXG5cdFx0fVxyXG5cdFx0aW5wdXQuY29uc3VtZSgpO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0VG9rZW5OYW1lKHQ6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRpZiAodCA9PT0gLTEpIHtcclxuXHRcdFx0cmV0dXJuIFwiRU9GXCI7XHJcblx0XHR9XHJcblx0XHQvL2lmICggYXRuLmchPW51bGwgKSByZXR1cm4gYXRuLmcuZ2V0VG9rZW5EaXNwbGF5TmFtZSh0KTtcclxuXHRcdHJldHVybiBcIidcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodCkgKyBcIidcIjtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgTGV4ZXJBVE5TaW11bGF0b3Ige1xyXG5cdGV4cG9ydCBjb25zdCBkZWJ1ZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdGV4cG9ydCBjb25zdCBkZmFfZGVidWc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0LyoqIFdoZW4gd2UgaGl0IGFuIGFjY2VwdCBzdGF0ZSBpbiBlaXRoZXIgdGhlIERGQSBvciB0aGUgQVROLCB3ZVxyXG5cdCAqICBoYXZlIHRvIG5vdGlmeSB0aGUgY2hhcmFjdGVyIHN0cmVhbSB0byBzdGFydCBidWZmZXJpbmcgY2hhcmFjdGVyc1xyXG5cdCAqICB2aWEge0BsaW5rIEludFN0cmVhbSNtYXJrfSBhbmQgcmVjb3JkIHRoZSBjdXJyZW50IHN0YXRlLiBUaGUgY3VycmVudCBzaW0gc3RhdGVcclxuXHQgKiAgaW5jbHVkZXMgdGhlIGN1cnJlbnQgaW5kZXggaW50byB0aGUgaW5wdXQsIHRoZSBjdXJyZW50IGxpbmUsXHJcblx0ICogIGFuZCBjdXJyZW50IGNoYXJhY3RlciBwb3NpdGlvbiBpbiB0aGF0IGxpbmUuIE5vdGUgdGhhdCB0aGUgTGV4ZXIgaXNcclxuXHQgKiAgdHJhY2tpbmcgdGhlIHN0YXJ0aW5nIGxpbmUgYW5kIGNoYXJhY3Rlcml6YXRpb24gb2YgdGhlIHRva2VuLiBUaGVzZVxyXG5cdCAqICB2YXJpYWJsZXMgdHJhY2sgdGhlIFwic3RhdGVcIiBvZiB0aGUgc2ltdWxhdG9yIHdoZW4gaXQgaGl0cyBhbiBhY2NlcHQgc3RhdGUuXHJcblx0ICpcclxuXHQgKiAgV2UgdHJhY2sgdGhlc2UgdmFyaWFibGVzIHNlcGFyYXRlbHkgZm9yIHRoZSBERkEgYW5kIEFUTiBzaW11bGF0aW9uXHJcblx0ICogIGJlY2F1c2UgdGhlIERGQSBzaW11bGF0aW9uIG9mdGVuIGhhcyB0byBmYWlsIG92ZXIgdG8gdGhlIEFUTlxyXG5cdCAqICBzaW11bGF0aW9uLiBJZiB0aGUgQVROIHNpbXVsYXRpb24gZmFpbHMsIHdlIG5lZWQgdGhlIERGQSB0byBmYWxsXHJcblx0ICogIGJhY2sgdG8gaXRzIHByZXZpb3VzbHkgYWNjZXB0ZWQgc3RhdGUsIGlmIGFueS4gSWYgdGhlIEFUTiBzdWNjZWVkcyxcclxuXHQgKiAgdGhlbiB0aGUgQVROIGRvZXMgdGhlIGFjY2VwdCBhbmQgdGhlIERGQSBzaW11bGF0b3IgdGhhdCBpbnZva2VkIGl0XHJcblx0ICogIGNhbiBzaW1wbHkgcmV0dXJuIHRoZSBwcmVkaWN0ZWQgdG9rZW4gdHlwZS5cclxuXHQgKi9cclxuXHRleHBvcnQgY2xhc3MgU2ltU3RhdGUge1xyXG5cdFx0cHVibGljIGluZGV4OiBudW1iZXIgPSAtMTtcclxuXHRcdHB1YmxpYyBsaW5lOiBudW1iZXIgPSAwO1xyXG5cdFx0cHVibGljIGNoYXJQb3M6IG51bWJlciA9IC0xO1xyXG5cdFx0cHVibGljIGRmYVN0YXRlPzogREZBU3RhdGU7XHJcblxyXG5cdFx0cHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG5cdFx0XHR0aGlzLmluZGV4ID0gLTE7XHJcblx0XHRcdHRoaXMubGluZSA9IDA7XHJcblx0XHRcdHRoaXMuY2hhclBvcyA9IC0xO1xyXG5cdFx0XHR0aGlzLmRmYVN0YXRlID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTEuNzkxMzMxOC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQU5UTFJFcnJvckxpc3RlbmVyIH0gZnJvbSBcIi4vQU5UTFJFcnJvckxpc3RlbmVyXCI7XHJcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiLi9DaGFyU3RyZWFtXCI7XHJcbmltcG9ydCB7IENvbW1vblRva2VuRmFjdG9yeSB9IGZyb20gXCIuL0NvbW1vblRva2VuRmFjdG9yeVwiO1xyXG5pbXBvcnQgeyBJbnRlZ2VyU3RhY2sgfSBmcm9tIFwiLi9taXNjL0ludGVnZXJTdGFja1wiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgSW50U3RyZWFtIH0gZnJvbSBcIi4vSW50U3RyZWFtXCI7XHJcbmltcG9ydCB7IExleGVyQVROU2ltdWxhdG9yIH0gZnJvbSBcIi4vYXRuL0xleGVyQVROU2ltdWxhdG9yXCI7XHJcbmltcG9ydCB7IExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24gfSBmcm9tIFwiLi9MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5GYWN0b3J5IH0gZnJvbSBcIi4vVG9rZW5GYWN0b3J5XCI7XHJcbmltcG9ydCB7IFRva2VuU291cmNlIH0gZnJvbSBcIi4vVG9rZW5Tb3VyY2VcIjtcclxuXHJcbi8qKiBBIGxleGVyIGlzIHJlY29nbml6ZXIgdGhhdCBkcmF3cyBpbnB1dCBzeW1ib2xzIGZyb20gYSBjaGFyYWN0ZXIgc3RyZWFtLlxyXG4gKiAgbGV4ZXIgZ3JhbW1hcnMgcmVzdWx0IGluIGEgc3ViY2xhc3Mgb2YgdGhpcyBvYmplY3QuIEEgTGV4ZXIgb2JqZWN0XHJcbiAqICB1c2VzIHNpbXBsaWZpZWQgbWF0Y2goKSBhbmQgZXJyb3IgcmVjb3ZlcnkgbWVjaGFuaXNtcyBpbiB0aGUgaW50ZXJlc3RcclxuICogIG9mIHNwZWVkLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExleGVyIGV4dGVuZHMgUmVjb2duaXplcjxudW1iZXIsIExleGVyQVROU2ltdWxhdG9yPlxyXG5cdGltcGxlbWVudHMgVG9rZW5Tb3VyY2Uge1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9NT0RFOiBudW1iZXIgPSAwO1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTU9SRTogbnVtYmVyID0gLTI7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBTS0lQOiBudW1iZXIgPSAtMztcclxuXHJcblx0c3RhdGljIGdldCBERUZBVUxUX1RPS0VOX0NIQU5ORUwoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBUb2tlbi5ERUZBVUxUX0NIQU5ORUw7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0IEhJRERFTigpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIFRva2VuLkhJRERFTl9DSEFOTkVMO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBNSU5fQ0hBUl9WQUxVRTogbnVtYmVyID0gMHgwMDAwO1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTUFYX0NIQVJfVkFMVUU6IG51bWJlciA9IDB4MTBGRkZGO1xyXG5cclxuXHRwdWJsaWMgX2lucHV0OiBDaGFyU3RyZWFtO1xyXG5cclxuXHRwcm90ZWN0ZWQgX3Rva2VuRmFjdG9yeVNvdXJjZVBhaXI6IHsgc291cmNlOiBUb2tlblNvdXJjZSwgc3RyZWFtOiBDaGFyU3RyZWFtIH07XHJcblxyXG5cdC8qKiBIb3cgdG8gY3JlYXRlIHRva2VuIG9iamVjdHMgKi9cclxuXHRwcm90ZWN0ZWQgX2ZhY3Rvcnk6IFRva2VuRmFjdG9yeSA9IENvbW1vblRva2VuRmFjdG9yeS5ERUZBVUxUO1xyXG5cclxuXHQvKiogVGhlIGdvYWwgb2YgYWxsIGxleGVyIHJ1bGVzL21ldGhvZHMgaXMgdG8gY3JlYXRlIGEgdG9rZW4gb2JqZWN0LlxyXG5cdCAqICBUaGlzIGlzIGFuIGluc3RhbmNlIHZhcmlhYmxlIGFzIG11bHRpcGxlIHJ1bGVzIG1heSBjb2xsYWJvcmF0ZSB0b1xyXG5cdCAqICBjcmVhdGUgYSBzaW5nbGUgdG9rZW4uICBuZXh0VG9rZW4gd2lsbCByZXR1cm4gdGhpcyBvYmplY3QgYWZ0ZXJcclxuXHQgKiAgbWF0Y2hpbmcgbGV4ZXIgcnVsZShzKS4gIElmIHlvdSBzdWJjbGFzcyB0byBhbGxvdyBtdWx0aXBsZSB0b2tlblxyXG5cdCAqICBlbWlzc2lvbnMsIHRoZW4gc2V0IHRoaXMgdG8gdGhlIGxhc3QgdG9rZW4gdG8gYmUgbWF0Y2hlZCBvclxyXG5cdCAqICBzb21ldGhpbmcgbm9uLXVuZGVmaW5lZCBzbyB0aGF0IHRoZSBhdXRvIHRva2VuIGVtaXQgbWVjaGFuaXNtIHdpbGwgbm90XHJcblx0ICogIGVtaXQgYW5vdGhlciB0b2tlbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgX3Rva2VuOiBUb2tlbiB8IHVuZGVmaW5lZDtcclxuXHJcblx0LyoqIFdoYXQgY2hhcmFjdGVyIGluZGV4IGluIHRoZSBzdHJlYW0gZGlkIHRoZSBjdXJyZW50IHRva2VuIHN0YXJ0IGF0P1xyXG5cdCAqICBOZWVkZWQsIGZvciBleGFtcGxlLCB0byBnZXQgdGhlIHRleHQgZm9yIGN1cnJlbnQgdG9rZW4uICBTZXQgYXRcclxuXHQgKiAgdGhlIHN0YXJ0IG9mIG5leHRUb2tlbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgX3Rva2VuU3RhcnRDaGFySW5kZXg6IG51bWJlciA9IC0xO1xyXG5cclxuXHQvKiogVGhlIGxpbmUgb24gd2hpY2ggdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgdG9rZW4gcmVzaWRlcyAqL1xyXG5cdHB1YmxpYyBfdG9rZW5TdGFydExpbmU6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKiBUaGUgY2hhcmFjdGVyIHBvc2l0aW9uIG9mIGZpcnN0IGNoYXJhY3RlciB3aXRoaW4gdGhlIGxpbmUgKi9cclxuXHRwdWJsaWMgX3Rva2VuU3RhcnRDaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKiBPbmNlIHdlIHNlZSBFT0Ygb24gY2hhciBzdHJlYW0sIG5leHQgdG9rZW4gd2lsbCBiZSBFT0YuXHJcblx0ICogIElmIHlvdSBoYXZlIERPTkUgOiBFT0YgOyB0aGVuIHlvdSBzZWUgRE9ORSBFT0YuXHJcblx0ICovXHJcblx0cHVibGljIF9oaXRFT0Y6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0LyoqIFRoZSBjaGFubmVsIG51bWJlciBmb3IgdGhlIGN1cnJlbnQgdG9rZW4gKi9cclxuXHRwdWJsaWMgX2NoYW5uZWw6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKiBUaGUgdG9rZW4gdHlwZSBmb3IgdGhlIGN1cnJlbnQgdG9rZW4gKi9cclxuXHRwdWJsaWMgX3R5cGU6IG51bWJlciA9IDA7XHJcblxyXG5cdHB1YmxpYyByZWFkb25seSBfbW9kZVN0YWNrOiBJbnRlZ2VyU3RhY2sgPSBuZXcgSW50ZWdlclN0YWNrKCk7XHJcblx0cHVibGljIF9tb2RlOiBudW1iZXIgPSBMZXhlci5ERUZBVUxUX01PREU7XHJcblxyXG5cdC8qKiBZb3UgY2FuIHNldCB0aGUgdGV4dCBmb3IgdGhlIGN1cnJlbnQgdG9rZW4gdG8gb3ZlcnJpZGUgd2hhdCBpcyBpblxyXG5cdCAqICB0aGUgaW5wdXQgY2hhciBidWZmZXIuICBTZXQgYHRleHRgIG9yIGNhbiBzZXQgdGhpcyBpbnN0YW5jZSB2YXIuXHJcblx0ICovXHJcblx0cHVibGljIF90ZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGlucHV0OiBDaGFyU3RyZWFtKSB7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5faW5wdXQgPSBpbnB1dDtcclxuXHRcdHRoaXMuX3Rva2VuRmFjdG9yeVNvdXJjZVBhaXIgPSB7IHNvdXJjZTogdGhpcywgc3RyZWFtOiBpbnB1dCB9O1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlc2V0KCk6IHZvaWQ7XHJcblx0cHVibGljIHJlc2V0KHJlc2V0SW5wdXQ6IGJvb2xlYW4pOiB2b2lkO1xyXG5cdHB1YmxpYyByZXNldChyZXNldElucHV0PzogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Ly8gd2FjayBMZXhlciBzdGF0ZSB2YXJpYWJsZXNcclxuXHRcdGlmIChyZXNldElucHV0ID09PSB1bmRlZmluZWQgfHwgcmVzZXRJbnB1dCkge1xyXG5cdFx0XHR0aGlzLl9pbnB1dC5zZWVrKDApOyAvLyByZXdpbmQgdGhlIGlucHV0XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdG9rZW4gPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLl90eXBlID0gVG9rZW4uSU5WQUxJRF9UWVBFO1xyXG5cdFx0dGhpcy5fY2hhbm5lbCA9IFRva2VuLkRFRkFVTFRfQ0hBTk5FTDtcclxuXHRcdHRoaXMuX3Rva2VuU3RhcnRDaGFySW5kZXggPSAtMTtcclxuXHRcdHRoaXMuX3Rva2VuU3RhcnRDaGFyUG9zaXRpb25JbkxpbmUgPSAtMTtcclxuXHRcdHRoaXMuX3Rva2VuU3RhcnRMaW5lID0gLTE7XHJcblx0XHR0aGlzLl90ZXh0ID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdHRoaXMuX2hpdEVPRiA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fbW9kZSA9IExleGVyLkRFRkFVTFRfTU9ERTtcclxuXHRcdHRoaXMuX21vZGVTdGFjay5jbGVhcigpO1xyXG5cclxuXHRcdHRoaXMuaW50ZXJwcmV0ZXIucmVzZXQoKTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZXR1cm4gYSB0b2tlbiBmcm9tIHRoaXMgc291cmNlOyBpLmUuLCBtYXRjaCBhIHRva2VuIG9uIHRoZSBjaGFyXHJcblx0ICogIHN0cmVhbS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgbmV4dFRva2VuKCk6IFRva2VuIHtcclxuXHRcdGlmICh0aGlzLl9pbnB1dCA9PSBudWxsKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5leHRUb2tlbiByZXF1aXJlcyBhIG5vbi1udWxsIGlucHV0IHN0cmVhbS5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTWFyayBzdGFydCBsb2NhdGlvbiBpbiBjaGFyIHN0cmVhbSBzbyB1bmJ1ZmZlcmVkIHN0cmVhbXMgYXJlXHJcblx0XHQvLyBndWFyYW50ZWVkIGF0IGxlYXN0IGhhdmUgdGV4dCBvZiBjdXJyZW50IHRva2VuXHJcblx0XHRsZXQgdG9rZW5TdGFydE1hcmtlcjogbnVtYmVyID0gdGhpcy5faW5wdXQubWFyaygpO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0b3V0ZXI6XHJcblx0XHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuX2hpdEVPRikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZW1pdEVPRigpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fdG9rZW4gPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0dGhpcy5fY2hhbm5lbCA9IFRva2VuLkRFRkFVTFRfQ0hBTk5FTDtcclxuXHRcdFx0XHR0aGlzLl90b2tlblN0YXJ0Q2hhckluZGV4ID0gdGhpcy5faW5wdXQuaW5kZXg7XHJcblx0XHRcdFx0dGhpcy5fdG9rZW5TdGFydENoYXJQb3NpdGlvbkluTGluZSA9IHRoaXMuaW50ZXJwcmV0ZXIuY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdFx0XHRcdHRoaXMuX3Rva2VuU3RhcnRMaW5lID0gdGhpcy5pbnRlcnByZXRlci5saW5lO1xyXG5cdFx0XHRcdHRoaXMuX3RleHQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0ZG8ge1xyXG5cdFx0XHRcdFx0dGhpcy5fdHlwZSA9IFRva2VuLklOVkFMSURfVFlQRTtcclxuLy9cdFx0XHRcdFN5c3RlbS5vdXQucHJpbnRsbihcIm5leHRUb2tlbiBsaW5lIFwiK3Rva2VuU3RhcnRMaW5lK1wiIGF0IFwiKygoY2hhcilpbnB1dC5MQSgxKSkrXHJcbi8vXHRcdFx0XHRcdFx0XHRcdCAgIFwiIGluIG1vZGUgXCIrbW9kZStcclxuLy9cdFx0XHRcdFx0XHRcdFx0ICAgXCIgYXQgaW5kZXggXCIraW5wdXQuaW5kZXgpO1xyXG5cdFx0XHRcdFx0bGV0IHR0eXBlOiBudW1iZXI7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHR0dHlwZSA9IHRoaXMuaW50ZXJwcmV0ZXIubWF0Y2godGhpcy5faW5wdXQsIHRoaXMuX21vZGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5ub3RpZnlMaXN0ZW5lcnMoZSk7XHRcdC8vIHJlcG9ydCBlcnJvclxyXG5cdFx0XHRcdFx0XHRcdHRoaXMucmVjb3ZlcihlKTtcclxuXHRcdFx0XHRcdFx0XHR0dHlwZSA9IExleGVyLlNLSVA7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBJbnRTdHJlYW0uRU9GKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2hpdEVPRiA9IHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gVG9rZW4uSU5WQUxJRF9UWVBFKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX3R5cGUgPSB0dHlwZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICh0aGlzLl90eXBlID09PSBMZXhlci5TS0lQKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlIG91dGVyO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gd2hpbGUgKHRoaXMuX3R5cGUgPT09IExleGVyLk1PUkUpO1xyXG5cdFx0XHRcdGlmICh0aGlzLl90b2tlbiA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5lbWl0KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0aGlzLl90b2tlbjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZmluYWxseSB7XHJcblx0XHRcdC8vIG1ha2Ugc3VyZSB3ZSByZWxlYXNlIG1hcmtlciBhZnRlciBtYXRjaCBvclxyXG5cdFx0XHQvLyB1bmJ1ZmZlcmVkIGNoYXIgc3RyZWFtIHdpbGwga2VlcCBidWZmZXJpbmdcclxuXHRcdFx0dGhpcy5faW5wdXQucmVsZWFzZSh0b2tlblN0YXJ0TWFya2VyKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBJbnN0cnVjdCB0aGUgbGV4ZXIgdG8gc2tpcCBjcmVhdGluZyBhIHRva2VuIGZvciBjdXJyZW50IGxleGVyIHJ1bGVcclxuXHQgKiAgYW5kIGxvb2sgZm9yIGFub3RoZXIgdG9rZW4uICBuZXh0VG9rZW4oKSBrbm93cyB0byBrZWVwIGxvb2tpbmcgd2hlblxyXG5cdCAqICBhIGxleGVyIHJ1bGUgZmluaXNoZXMgd2l0aCB0b2tlbiBzZXQgdG8gU0tJUF9UT0tFTi4gIFJlY2FsbCB0aGF0XHJcblx0ICogIGlmIHRva2VuPT11bmRlZmluZWQgYXQgZW5kIG9mIGFueSB0b2tlbiBydWxlLCBpdCBjcmVhdGVzIG9uZSBmb3IgeW91XHJcblx0ICogIGFuZCBlbWl0cyBpdC5cclxuXHQgKi9cclxuXHRwdWJsaWMgc2tpcCgpOiB2b2lkIHtcclxuXHRcdHRoaXMuX3R5cGUgPSBMZXhlci5TS0lQO1xyXG5cdH1cclxuXHJcblx0cHVibGljIG1vcmUoKTogdm9pZCB7XHJcblx0XHR0aGlzLl90eXBlID0gTGV4ZXIuTU9SRTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBtb2RlKG06IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5fbW9kZSA9IG07XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcHVzaE1vZGUobTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJwdXNoTW9kZSBcIiArIG0pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fbW9kZVN0YWNrLnB1c2godGhpcy5fbW9kZSk7XHJcblx0XHR0aGlzLm1vZGUobSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcG9wTW9kZSgpOiBudW1iZXIge1xyXG5cdFx0aWYgKHRoaXMuX21vZGVTdGFjay5pc0VtcHR5KSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkVtcHR5U3RhY2tFeGNlcHRpb25cIik7XHJcblx0XHR9XHJcblx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJwb3BNb2RlIGJhY2sgdG8gXCIgKyB0aGlzLl9tb2RlU3RhY2sucGVlaygpKTtcclxuXHRcdH1cclxuXHRcdHRoaXMubW9kZSh0aGlzLl9tb2RlU3RhY2sucG9wKCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX21vZGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgdG9rZW5GYWN0b3J5KCk6IFRva2VuRmFjdG9yeSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZmFjdG9yeTtcclxuXHR9XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHNldCB0b2tlbkZhY3RvcnkoZmFjdG9yeTogVG9rZW5GYWN0b3J5KSB7XHJcblx0XHR0aGlzLl9mYWN0b3J5ID0gZmFjdG9yeTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpbnB1dFN0cmVhbSgpOiBDaGFyU3RyZWFtIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbnB1dDtcclxuXHR9XHJcblxyXG5cdC8qKiBTZXQgdGhlIGNoYXIgc3RyZWFtIGFuZCByZXNldCB0aGUgbGV4ZXIgKi9cclxuXHRzZXQgaW5wdXRTdHJlYW0oaW5wdXQ6IENoYXJTdHJlYW0pIHtcclxuXHRcdHRoaXMucmVzZXQoZmFsc2UpO1xyXG5cdFx0dGhpcy5faW5wdXQgPSBpbnB1dDtcclxuXHRcdHRoaXMuX3Rva2VuRmFjdG9yeVNvdXJjZVBhaXIgPSB7IHNvdXJjZTogdGhpcywgc3RyZWFtOiB0aGlzLl9pbnB1dCB9O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNvdXJjZU5hbWUoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbnB1dC5zb3VyY2VOYW1lO1xyXG5cdH1cclxuXHJcblxyXG5cdC8qKiBUaGUgc3RhbmRhcmQgbWV0aG9kIGNhbGxlZCB0byBhdXRvbWF0aWNhbGx5IGVtaXQgYSB0b2tlbiBhdCB0aGVcclxuXHQgKiAgb3V0ZXJtb3N0IGxleGljYWwgcnVsZS4gIFRoZSB0b2tlbiBvYmplY3Qgc2hvdWxkIHBvaW50IGludG8gdGhlXHJcblx0ICogIGNoYXIgYnVmZmVyIHN0YXJ0Li5zdG9wLiAgSWYgdGhlcmUgaXMgYSB0ZXh0IG92ZXJyaWRlIGluICd0ZXh0JyxcclxuXHQgKiAgdXNlIHRoYXQgdG8gc2V0IHRoZSB0b2tlbidzIHRleHQuICBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBlbWl0XHJcblx0ICogIGN1c3RvbSBUb2tlbiBvYmplY3RzIG9yIHByb3ZpZGUgYSBuZXcgZmFjdG9yeS5cclxuXHQgKi9cclxuXHRwdWJsaWMgZW1pdCh0b2tlbjogVG9rZW4pOiBUb2tlbjtcclxuXHJcblx0LyoqIEJ5IGRlZmF1bHQgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aXBsZSBlbWl0cyBwZXIgbmV4dFRva2VuIGludm9jYXRpb25cclxuXHQgKiAgZm9yIGVmZmljaWVuY3kgcmVhc29ucy4gIFN1YmNsYXNzIGFuZCBvdmVycmlkZSB0aGlzIG1ldGhvZCwgbmV4dFRva2VuLFxyXG5cdCAqICBhbmQgZ2V0VG9rZW4gKHRvIHB1c2ggdG9rZW5zIGludG8gYSBsaXN0IGFuZCBwdWxsIGZyb20gdGhhdCBsaXN0XHJcblx0ICogIHJhdGhlciB0aGFuIGEgc2luZ2xlIHZhcmlhYmxlIGFzIHRoaXMgaW1wbGVtZW50YXRpb24gZG9lcykuXHJcblx0ICovXHJcblx0cHVibGljIGVtaXQoKTogVG9rZW47XHJcblxyXG5cdHB1YmxpYyBlbWl0KHRva2VuPzogVG9rZW4pOiBUb2tlbiB7XHJcblx0XHRpZiAoIXRva2VuKSB7XHJcblx0XHRcdHRva2VuID0gdGhpcy5fZmFjdG9yeS5jcmVhdGUoXHJcblx0XHRcdFx0dGhpcy5fdG9rZW5GYWN0b3J5U291cmNlUGFpciwgdGhpcy5fdHlwZSwgdGhpcy5fdGV4dCwgdGhpcy5fY2hhbm5lbCxcclxuXHRcdFx0XHR0aGlzLl90b2tlblN0YXJ0Q2hhckluZGV4LCB0aGlzLmNoYXJJbmRleCAtIDEsIHRoaXMuX3Rva2VuU3RhcnRMaW5lLFxyXG5cdFx0XHRcdHRoaXMuX3Rva2VuU3RhcnRDaGFyUG9zaXRpb25JbkxpbmUpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fdG9rZW4gPSB0b2tlbjtcclxuXHRcdHJldHVybiB0b2tlbjtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBlbWl0RU9GKCk6IFRva2VuIHtcclxuXHRcdGxldCBjcG9zOiBudW1iZXIgPSB0aGlzLmNoYXJQb3NpdGlvbkluTGluZTtcclxuXHRcdGxldCBsaW5lOiBudW1iZXIgPSB0aGlzLmxpbmU7XHJcblx0XHRsZXQgZW9mOiBUb2tlbiA9IHRoaXMuX2ZhY3RvcnkuY3JlYXRlKFxyXG5cdFx0XHR0aGlzLl90b2tlbkZhY3RvcnlTb3VyY2VQYWlyLCBUb2tlbi5FT0YsIHVuZGVmaW5lZCxcclxuXHRcdFx0VG9rZW4uREVGQVVMVF9DSEFOTkVMLCB0aGlzLl9pbnB1dC5pbmRleCwgdGhpcy5faW5wdXQuaW5kZXggLSAxLFxyXG5cdFx0XHRsaW5lLCBjcG9zKTtcclxuXHRcdHRoaXMuZW1pdChlb2YpO1xyXG5cdFx0cmV0dXJuIGVvZjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBsaW5lKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnByZXRlci5saW5lO1xyXG5cdH1cclxuXHJcblx0c2V0IGxpbmUobGluZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLmludGVycHJldGVyLmxpbmUgPSBsaW5lO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGNoYXJQb3NpdGlvbkluTGluZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJwcmV0ZXIuY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdH1cclxuXHJcblx0c2V0IGNoYXJQb3NpdGlvbkluTGluZShjaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5pbnRlcnByZXRlci5jaGFyUG9zaXRpb25JbkxpbmUgPSBjaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0fVxyXG5cclxuXHQvKiogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIG9mIGxvb2thaGVhZD8gKi9cclxuXHRnZXQgY2hhckluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW5wdXQuaW5kZXg7XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIHRoZSB0ZXh0IG1hdGNoZWQgc28gZmFyIGZvciB0aGUgY3VycmVudCB0b2tlbiBvciBhbnlcclxuXHQgKiAgdGV4dCBvdmVycmlkZS5cclxuXHQgKi9cclxuXHRnZXQgdGV4dCgpOiBzdHJpbmcge1xyXG5cdFx0aWYgKHRoaXMuX3RleHQgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fdGV4dDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmludGVycHJldGVyLmdldFRleHQodGhpcy5faW5wdXQpO1xyXG5cdH1cclxuXHJcblx0LyoqIFNldCB0aGUgY29tcGxldGUgdGV4dCBvZiB0aGlzIHRva2VuOyBpdCB3aXBlcyBhbnkgcHJldmlvdXNcclxuXHQgKiAgY2hhbmdlcyB0byB0aGUgdGV4dC5cclxuXHQgKi9cclxuXHRzZXQgdGV4dCh0ZXh0OiBzdHJpbmcpIHtcclxuXHRcdHRoaXMuX3RleHQgPSB0ZXh0O1xyXG5cdH1cclxuXHJcblx0LyoqIE92ZXJyaWRlIGlmIGVtaXR0aW5nIG11bHRpcGxlIHRva2Vucy4gKi9cclxuXHRnZXQgdG9rZW4oKTogVG9rZW4gfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy5fdG9rZW47IH1cclxuXHJcblx0c2V0IHRva2VuKF90b2tlbjogVG9rZW4gfCB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuX3Rva2VuID0gX3Rva2VuO1xyXG5cdH1cclxuXHJcblx0c2V0IHR5cGUodHR5cGU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5fdHlwZSA9IHR0eXBlO1xyXG5cdH1cclxuXHJcblx0Z2V0IHR5cGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl90eXBlO1xyXG5cdH1cclxuXHJcblx0c2V0IGNoYW5uZWwoY2hhbm5lbDogbnVtYmVyKSB7XHJcblx0XHR0aGlzLl9jaGFubmVsID0gY2hhbm5lbDtcclxuXHR9XHJcblxyXG5cdGdldCBjaGFubmVsKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hhbm5lbDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBjaGFubmVsTmFtZXM6IHN0cmluZ1tdO1xyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgbW9kZU5hbWVzOiBzdHJpbmdbXTtcclxuXHJcblx0LyoqIFJldHVybiBhIGxpc3Qgb2YgYWxsIFRva2VuIG9iamVjdHMgaW4gaW5wdXQgY2hhciBzdHJlYW0uXHJcblx0ICogIEZvcmNlcyBsb2FkIG9mIGFsbCB0b2tlbnMuIERvZXMgbm90IGluY2x1ZGUgRU9GIHRva2VuLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRBbGxUb2tlbnMoKTogVG9rZW5bXSB7XHJcblx0XHRsZXQgdG9rZW5zOiBUb2tlbltdID0gW107XHJcblx0XHRsZXQgdDogVG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdFx0d2hpbGUgKHQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdHRva2Vucy5wdXNoKHQpO1xyXG5cdFx0XHR0ID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0b2tlbnM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgbm90aWZ5TGlzdGVuZXJzKGU6IExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24pOiB2b2lkIHtcclxuXHRcdGxldCB0ZXh0OiBzdHJpbmcgPSB0aGlzLl9pbnB1dC5nZXRUZXh0KFxyXG5cdFx0XHRJbnRlcnZhbC5vZih0aGlzLl90b2tlblN0YXJ0Q2hhckluZGV4LCB0aGlzLl9pbnB1dC5pbmRleCkpO1xyXG5cdFx0bGV0IG1zZzogc3RyaW5nID0gXCJ0b2tlbiByZWNvZ25pdGlvbiBlcnJvciBhdDogJ1wiICtcclxuXHRcdFx0dGhpcy5nZXRFcnJvckRpc3BsYXkodGV4dCkgKyBcIidcIjtcclxuXHJcblx0XHRsZXQgbGlzdGVuZXI6IEFOVExSRXJyb3JMaXN0ZW5lcjxudW1iZXI+ID0gdGhpcy5nZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKTtcclxuXHRcdGlmIChsaXN0ZW5lci5zeW50YXhFcnJvcikge1xyXG5cdFx0XHRsaXN0ZW5lci5zeW50YXhFcnJvcih0aGlzLCB1bmRlZmluZWQsIHRoaXMuX3Rva2VuU3RhcnRMaW5lLCB0aGlzLl90b2tlblN0YXJ0Q2hhclBvc2l0aW9uSW5MaW5lLCBtc2csIGUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGdldEVycm9yRGlzcGxheShzOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xyXG5cdFx0aWYgKHR5cGVvZiBzID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHN3aXRjaCAocykge1xyXG5cdFx0XHRjYXNlIFRva2VuLkVPRjpcclxuXHRcdFx0XHRyZXR1cm4gXCI8RU9GPlwiO1xyXG5cdFx0XHRjYXNlIDB4MGE6XHJcblx0XHRcdFx0cmV0dXJuIFwiXFxcXG5cIjtcclxuXHRcdFx0Y2FzZSAweDA5OlxyXG5cdFx0XHRcdHJldHVybiBcIlxcXFx0XCI7XHJcblx0XHRcdGNhc2UgMHgwZDpcclxuXHRcdFx0XHRyZXR1cm4gXCJcXFxcclwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHMucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIilcclxuXHRcdFx0LnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpXHJcblx0XHRcdC5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRDaGFyRXJyb3JEaXNwbGF5KGM6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRsZXQgczogc3RyaW5nID0gdGhpcy5nZXRFcnJvckRpc3BsYXkoYyk7XHJcblx0XHRyZXR1cm4gXCInXCIgKyBzICsgXCInXCI7XHJcblx0fVxyXG5cclxuXHQvKiogTGV4ZXJzIGNhbiBub3JtYWxseSBtYXRjaCBhbnkgY2hhciBpbiBpdCdzIHZvY2FidWxhcnkgYWZ0ZXIgbWF0Y2hpbmdcclxuXHQgKiAgYSB0b2tlbiwgc28gZG8gdGhlIGVhc3kgdGhpbmcgYW5kIGp1c3Qga2lsbCBhIGNoYXJhY3RlciBhbmQgaG9wZVxyXG5cdCAqICBpdCBhbGwgd29ya3Mgb3V0LiAgWW91IGNhbiBpbnN0ZWFkIHVzZSB0aGUgcnVsZSBpbnZvY2F0aW9uIHN0YWNrXHJcblx0ICogIHRvIGRvIHNvcGhpc3RpY2F0ZWQgZXJyb3IgcmVjb3ZlcnkgaWYgeW91IGFyZSBpbiBhIGZyYWdtZW50IHJ1bGUuXHJcblx0ICovXHJcblx0cHVibGljIHJlY292ZXIocmU6IFJlY29nbml0aW9uRXhjZXB0aW9uKTogdm9pZDtcclxuXHRwdWJsaWMgcmVjb3ZlcihyZTogTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbik6IHZvaWQ7XHJcblx0cHVibGljIHJlY292ZXIocmU6IFJlY29nbml0aW9uRXhjZXB0aW9uKTogdm9pZCB7XHJcblx0XHRpZiAocmUgaW5zdGFuY2VvZiBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKSB7XHJcblx0XHRcdGlmICh0aGlzLl9pbnB1dC5MQSgxKSAhPT0gSW50U3RyZWFtLkVPRikge1xyXG5cdFx0XHRcdC8vIHNraXAgYSBjaGFyIGFuZCB0cnkgYWdhaW5cclxuXHRcdFx0XHR0aGlzLmludGVycHJldGVyLmNvbnN1bWUodGhpcy5faW5wdXQpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvL1N5c3RlbS5vdXQucHJpbnRsbihcImNvbnN1bWluZyBjaGFyIFwiKyhjaGFyKWlucHV0LkxBKDEpK1wiIGR1cmluZyByZWNvdmVyeVwiKTtcclxuXHRcdFx0Ly9yZS5wcmludFN0YWNrVHJhY2UoKTtcclxuXHRcdFx0Ly8gVE9ETzogRG8gd2UgbG9zZSBjaGFyYWN0ZXIgb3IgbGluZSBwb3NpdGlvbiBpbmZvcm1hdGlvbj9cclxuXHRcdFx0dGhpcy5faW5wdXQuY29uc3VtZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDAuODY4MzQ4MC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi9BcnJheUVxdWFsaXR5Q29tcGFyYXRvclwiO1xyXG5pbXBvcnQgeyBJbnRlZ2VyTGlzdCB9IGZyb20gXCIuL0ludGVnZXJMaXN0XCI7XHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4vSW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgSW50U2V0IH0gZnJvbSBcIi4vSW50U2V0XCI7XHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL0xleGVyXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlLCBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVm9jYWJ1bGFyeSB9IGZyb20gXCIuLi9Wb2NhYnVsYXJ5XCI7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSB7QGxpbmsgSW50U2V0fSBiYWNrZWQgYnkgYSBzb3J0ZWQgYXJyYXkgb2ZcclxuICogbm9uLW92ZXJsYXBwaW5nIGludGVydmFscy4gSXQgaXMgcGFydGljdWxhcmx5IGVmZmljaWVudCBmb3IgcmVwcmVzZW50aW5nXHJcbiAqIGxhcmdlIGNvbGxlY3Rpb25zIG9mIG51bWJlcnMsIHdoZXJlIHRoZSBtYWpvcml0eSBvZiBlbGVtZW50cyBhcHBlYXIgYXMgcGFydFxyXG4gKiBvZiBhIHNlcXVlbnRpYWwgcmFuZ2Ugb2YgbnVtYmVycyB0aGF0IGFyZSBhbGwgcGFydCBvZiB0aGUgc2V0LiBGb3IgZXhhbXBsZSxcclxuICogdGhlIHNldCB7IDEsIDIsIDMsIDQsIDcsIDggfSBtYXkgYmUgcmVwcmVzZW50ZWQgYXMgeyBbMSwgNF0sIFs3LCA4XSB9LlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIGlzIGFibGUgdG8gcmVwcmVzZW50IHNldHMgY29udGFpbmluZyBhbnkgY29tYmluYXRpb24gb2YgdmFsdWVzIGluXHJcbiAqIHRoZSByYW5nZSB7QGxpbmsgSW50ZWdlciNNSU5fVkFMVUV9IHRvIHtAbGluayBJbnRlZ2VyI01BWF9WQUxVRX1cclxuICogKGluY2x1c2l2ZSkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW50ZXJ2YWxTZXQgaW1wbGVtZW50cyBJbnRTZXQge1xyXG5cdHByaXZhdGUgc3RhdGljIF9DT01QTEVURV9DSEFSX1NFVDogSW50ZXJ2YWxTZXQ7XHJcblx0c3RhdGljIGdldCBDT01QTEVURV9DSEFSX1NFVCgpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRpZiAoSW50ZXJ2YWxTZXQuX0NPTVBMRVRFX0NIQVJfU0VUID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0SW50ZXJ2YWxTZXQuX0NPTVBMRVRFX0NIQVJfU0VUID0gSW50ZXJ2YWxTZXQub2YoTGV4ZXIuTUlOX0NIQVJfVkFMVUUsIExleGVyLk1BWF9DSEFSX1ZBTFVFKTtcclxuXHRcdFx0SW50ZXJ2YWxTZXQuX0NPTVBMRVRFX0NIQVJfU0VULnNldFJlYWRvbmx5KHRydWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBJbnRlcnZhbFNldC5fQ09NUExFVEVfQ0hBUl9TRVQ7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBfRU1QVFlfU0VUOiBJbnRlcnZhbFNldDtcclxuXHRzdGF0aWMgZ2V0IEVNUFRZX1NFVCgpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRpZiAoSW50ZXJ2YWxTZXQuX0VNUFRZX1NFVCA9PSBudWxsKSB7XHJcblx0XHRcdEludGVydmFsU2V0Ll9FTVBUWV9TRVQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdFx0SW50ZXJ2YWxTZXQuX0VNUFRZX1NFVC5zZXRSZWFkb25seSh0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gSW50ZXJ2YWxTZXQuX0VNUFRZX1NFVDtcclxuXHR9XHJcblxyXG5cdC8qKiBUaGUgbGlzdCBvZiBzb3J0ZWQsIGRpc2pvaW50IGludGVydmFscy4gKi9cclxuXHRwcml2YXRlIF9pbnRlcnZhbHM6IEludGVydmFsW107XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHk6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0Y29uc3RydWN0b3IoaW50ZXJ2YWxzPzogSW50ZXJ2YWxbXSkge1xyXG5cdFx0aWYgKGludGVydmFscyAhPSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ludGVydmFscyA9IGludGVydmFscy5zbGljZSgwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2ludGVydmFscyA9IFtdO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlIGEgc2V0IHdpdGggYWxsIGludHMgd2l0aGluIHJhbmdlIFthLi5iXSAoaW5jbHVzaXZlKS4gSWYgYiBpcyBvbWl0dGVkLCB0aGUgc2V0IGNvbnRhaW5zIHRoZSBzaW5nbGUgZWxlbWVudFxyXG5cdCAqIGEuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgc3RhdGljIG9mKGE6IG51bWJlciwgYjogbnVtYmVyID0gYSk6IEludGVydmFsU2V0IHtcclxuXHRcdGxldCBzOiBJbnRlcnZhbFNldCA9IG5ldyBJbnRlcnZhbFNldCgpO1xyXG5cdFx0cy5hZGQoYSwgYik7XHJcblx0XHRyZXR1cm4gcztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLnJlYWRvbmx5KSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImNhbid0IGFsdGVyIHJlYWRvbmx5IEludGVydmFsU2V0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ludGVydmFscy5sZW5ndGggPSAwO1xyXG5cdH1cclxuXHJcblx0LyoqIEFkZCBpbnRlcnZhbDsgaS5lLiwgYWRkIGFsbCBpbnRlZ2VycyBmcm9tIGEgdG8gYiB0byBzZXQuXHJcblx0ICogIElmIGImbHQ7YSwgZG8gbm90aGluZy5cclxuXHQgKiAgS2VlcCBsaXN0IGluIHNvcnRlZCBvcmRlciAoYnkgbGVmdCByYW5nZSB2YWx1ZSkuXHJcblx0ICogIElmIG92ZXJsYXAsIGNvbWJpbmUgcmFuZ2VzLiAgRm9yIGV4YW1wbGUsXHJcblx0ICogIElmIHRoaXMgaXMgezEuLjUsIDEwLi4yMH0sIGFkZGluZyA2Li43IHlpZWxkc1xyXG5cdCAqICB7MS4uNSwgNi4uNywgMTAuLjIwfS4gIEFkZGluZyA0Li44IHlpZWxkcyB7MS4uOCwgMTAuLjIwfS5cclxuXHQgKi9cclxuXHRwdWJsaWMgYWRkKGE6IG51bWJlciwgYjogbnVtYmVyID0gYSk6IHZvaWQge1xyXG5cdFx0dGhpcy5hZGRSYW5nZShJbnRlcnZhbC5vZihhLCBiKSk7XHJcblx0fVxyXG5cclxuXHQvLyBjb3B5IG9uIHdyaXRlIHNvIHdlIGNhbiBjYWNoZSBhLi5hIGludGVydmFscyBhbmQgc2V0cyBvZiB0aGF0XHJcblx0cHJvdGVjdGVkIGFkZFJhbmdlKGFkZGl0aW9uOiBJbnRlcnZhbCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMucmVhZG9ubHkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgYWx0ZXIgcmVhZG9ubHkgSW50ZXJ2YWxTZXRcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9TeXN0ZW0ub3V0LnByaW50bG4oXCJhZGQgXCIrYWRkaXRpb24rXCIgdG8gXCIraW50ZXJ2YWxzLnRvU3RyaW5nKCkpO1xyXG5cdFx0aWYgKGFkZGl0aW9uLmIgPCBhZGRpdGlvbi5hKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaW5kIHBvc2l0aW9uIGluIGxpc3RcclxuXHRcdC8vIFVzZSBpdGVyYXRvcnMgYXMgd2UgbW9kaWZ5IGxpc3QgaW4gcGxhY2VcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IHI6IEludGVydmFsID0gdGhpcy5faW50ZXJ2YWxzW2ldO1xyXG5cdFx0XHRpZiAoYWRkaXRpb24uZXF1YWxzKHIpKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoYWRkaXRpb24uYWRqYWNlbnQocikgfHwgIWFkZGl0aW9uLmRpc2pvaW50KHIpKSB7XHJcblx0XHRcdFx0Ly8gbmV4dCB0byBlYWNoIG90aGVyLCBtYWtlIGEgc2luZ2xlIGxhcmdlciBpbnRlcnZhbFxyXG5cdFx0XHRcdGxldCBiaWdnZXI6IEludGVydmFsID0gYWRkaXRpb24udW5pb24ocik7XHJcblx0XHRcdFx0dGhpcy5faW50ZXJ2YWxzW2ldID0gYmlnZ2VyO1xyXG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB3ZSBkaWRuJ3QganVzdCBjcmVhdGUgYW4gaW50ZXJ2YWwgdGhhdFxyXG5cdFx0XHRcdC8vIHNob3VsZCBiZSBtZXJnZWQgd2l0aCBuZXh0IGludGVydmFsIGluIGxpc3RcclxuXHRcdFx0XHR3aGlsZSAoaSA8IHRoaXMuX2ludGVydmFscy5sZW5ndGggLSAxKSB7XHJcblx0XHRcdFx0XHRpKys7XHJcblx0XHRcdFx0XHRsZXQgbmV4dDogSW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbHNbaV07XHJcblx0XHRcdFx0XHRpZiAoIWJpZ2dlci5hZGphY2VudChuZXh0KSAmJiBiaWdnZXIuZGlzam9pbnQobmV4dCkpIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gaWYgd2UgYnVtcCB1cCBhZ2FpbnN0IG9yIG92ZXJsYXAgbmV4dCwgbWVyZ2VcclxuXHRcdFx0XHRcdC8vIHJlbW92ZSB0aGlzIG9uZVxyXG5cdFx0XHRcdFx0dGhpcy5faW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdGktLTtcclxuXHRcdFx0XHRcdC8vIG1vdmUgYmFja3dhcmRzIHRvIHdoYXQgd2UganVzdCBzZXRcclxuXHRcdFx0XHRcdHRoaXMuX2ludGVydmFsc1tpXSA9IGJpZ2dlci51bmlvbihuZXh0KTtcclxuXHRcdFx0XHRcdC8vIHNldCB0byAzIG1lcmdlZCBvbmVzXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBmaXJzdCBjYWxsIHRvIG5leHQgYWZ0ZXIgcHJldmlvdXMgZHVwbGljYXRlcyB0aGUgcmVzdWx0XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoYWRkaXRpb24uc3RhcnRzQmVmb3JlRGlzam9pbnQocikpIHtcclxuXHRcdFx0XHQvLyBpbnNlcnQgYmVmb3JlIHJcclxuXHRcdFx0XHR0aGlzLl9pbnRlcnZhbHMuc3BsaWNlKGksIDAsIGFkZGl0aW9uKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGlmIGRpc2pvaW50IGFuZCBhZnRlciByLCBhIGZ1dHVyZSBpdGVyYXRpb24gd2lsbCBoYW5kbGUgaXRcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvaywgbXVzdCBiZSBhZnRlciBsYXN0IGludGVydmFsIChhbmQgZGlzam9pbnQgZnJvbSBsYXN0IGludGVydmFsKVxyXG5cdFx0Ly8ganVzdCBhZGQgaXRcclxuXHRcdHRoaXMuX2ludGVydmFscy5wdXNoKGFkZGl0aW9uKTtcclxuXHR9XHJcblxyXG5cdC8qKiBjb21iaW5lIGFsbCBzZXRzIGluIHRoZSBhcnJheSByZXR1cm5lZCB0aGUgb3InZCB2YWx1ZSAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgb3Ioc2V0czogSW50ZXJ2YWxTZXRbXSk6IEludGVydmFsU2V0IHtcclxuXHRcdGxldCByOiBJbnRlcnZhbFNldCA9IG5ldyBJbnRlcnZhbFNldCgpO1xyXG5cdFx0Zm9yIChsZXQgcyBvZiBzZXRzKSB7XHJcblx0XHRcdHIuYWRkQWxsKHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGFkZEFsbChzZXQ6IEludFNldCk6IEludGVydmFsU2V0IHtcclxuXHRcdGlmIChzZXQgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2V0IGluc3RhbmNlb2YgSW50ZXJ2YWxTZXQpIHtcclxuXHRcdFx0bGV0IG90aGVyOiBJbnRlcnZhbFNldCA9IHNldDtcclxuXHRcdFx0Ly8gd2FsayBzZXQgYW5kIGFkZCBlYWNoIGludGVydmFsXHJcblx0XHRcdGxldCBuOiBudW1iZXIgPSBvdGhlci5faW50ZXJ2YWxzLmxlbmd0aDtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0XHRsZXQgSTogSW50ZXJ2YWwgPSBvdGhlci5faW50ZXJ2YWxzW2ldO1xyXG5cdFx0XHRcdHRoaXMuYWRkKEkuYSwgSS5iKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGZvciAobGV0IHZhbHVlIG9mIHNldC50b0FycmF5KCkpIHtcclxuXHRcdFx0XHR0aGlzLmFkZCh2YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBjb21wbGVtZW50UmFuZ2UobWluRWxlbWVudDogbnVtYmVyLCBtYXhFbGVtZW50OiBudW1iZXIpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wbGVtZW50KEludGVydmFsU2V0Lm9mKG1pbkVsZW1lbnQsIG1heEVsZW1lbnQpKTtcclxuXHR9XHJcblxyXG5cdC8qKiB7QGluaGVyaXREb2N9ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGNvbXBsZW1lbnQodm9jYWJ1bGFyeTogSW50U2V0KTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0aWYgKHZvY2FidWxhcnkuaXNOaWwpIHtcclxuXHRcdFx0Ly8gbm90aGluZyBpbiBjb21tb24gd2l0aCBudWxsIHNldFxyXG5cdFx0XHRyZXR1cm4gSW50ZXJ2YWxTZXQuRU1QVFlfU0VUO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB2b2NhYnVsYXJ5SVM6IEludGVydmFsU2V0O1xyXG5cdFx0aWYgKHZvY2FidWxhcnkgaW5zdGFuY2VvZiBJbnRlcnZhbFNldCkge1xyXG5cdFx0XHR2b2NhYnVsYXJ5SVMgPSB2b2NhYnVsYXJ5O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dm9jYWJ1bGFyeUlTID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHRcdHZvY2FidWxhcnlJUy5hZGRBbGwodm9jYWJ1bGFyeSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZvY2FidWxhcnlJUy5zdWJ0cmFjdCh0aGlzKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBzdWJ0cmFjdChhOiBJbnRTZXQpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRpZiAoYSA9PSBudWxsIHx8IGEuaXNOaWwpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBJbnRlcnZhbFNldCh0aGlzLl9pbnRlcnZhbHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChhIGluc3RhbmNlb2YgSW50ZXJ2YWxTZXQpIHtcclxuXHRcdFx0cmV0dXJuIEludGVydmFsU2V0LnN1YnRyYWN0KHRoaXMsIGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBvdGhlcjogSW50ZXJ2YWxTZXQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdG90aGVyLmFkZEFsbChhKTtcclxuXHRcdHJldHVybiBJbnRlcnZhbFNldC5zdWJ0cmFjdCh0aGlzLCBvdGhlcik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wdXRlIHRoZSBzZXQgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBpbnRlcnZhbCBzZXRzLiBUaGUgc3BlY2lmaWNcclxuXHQgKiBvcGVyYXRpb24gaXMgYGxlZnQgLSByaWdodGAuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgc3RhdGljIHN1YnRyYWN0KGxlZnQ6IEludGVydmFsU2V0LCByaWdodDogSW50ZXJ2YWxTZXQpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRpZiAobGVmdC5pc05pbCkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJlc3VsdDogSW50ZXJ2YWxTZXQgPSBuZXcgSW50ZXJ2YWxTZXQobGVmdC5faW50ZXJ2YWxzKTtcclxuXHRcdGlmIChyaWdodC5pc05pbCkge1xyXG5cdFx0XHQvLyByaWdodCBzZXQgaGFzIG5vIGVsZW1lbnRzOyBqdXN0IHJldHVybiB0aGUgY29weSBvZiB0aGUgY3VycmVudCBzZXRcclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVzdWx0STogbnVtYmVyID0gMDtcclxuXHRcdGxldCByaWdodEk6IG51bWJlciA9IDA7XHJcblx0XHR3aGlsZSAocmVzdWx0SSA8IHJlc3VsdC5faW50ZXJ2YWxzLmxlbmd0aCAmJiByaWdodEkgPCByaWdodC5faW50ZXJ2YWxzLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgcmVzdWx0SW50ZXJ2YWw6IEludGVydmFsID0gcmVzdWx0Ll9pbnRlcnZhbHNbcmVzdWx0SV07XHJcblx0XHRcdGxldCByaWdodEludGVydmFsOiBJbnRlcnZhbCA9IHJpZ2h0Ll9pbnRlcnZhbHNbcmlnaHRJXTtcclxuXHJcblx0XHRcdC8vIG9wZXJhdGlvbjogKHJlc3VsdEludGVydmFsIC0gcmlnaHRJbnRlcnZhbCkgYW5kIHVwZGF0ZSBpbmRleGVzXHJcblxyXG5cdFx0XHRpZiAocmlnaHRJbnRlcnZhbC5iIDwgcmVzdWx0SW50ZXJ2YWwuYSkge1xyXG5cdFx0XHRcdHJpZ2h0SSsrO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAocmlnaHRJbnRlcnZhbC5hID4gcmVzdWx0SW50ZXJ2YWwuYikge1xyXG5cdFx0XHRcdHJlc3VsdEkrKztcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGJlZm9yZUN1cnJlbnQ6IEludGVydmFsIHwgdW5kZWZpbmVkO1xyXG5cdFx0XHRsZXQgYWZ0ZXJDdXJyZW50OiBJbnRlcnZhbCB8IHVuZGVmaW5lZDtcclxuXHRcdFx0aWYgKHJpZ2h0SW50ZXJ2YWwuYSA+IHJlc3VsdEludGVydmFsLmEpIHtcclxuXHRcdFx0XHRiZWZvcmVDdXJyZW50ID0gbmV3IEludGVydmFsKHJlc3VsdEludGVydmFsLmEsIHJpZ2h0SW50ZXJ2YWwuYSAtIDEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAocmlnaHRJbnRlcnZhbC5iIDwgcmVzdWx0SW50ZXJ2YWwuYikge1xyXG5cdFx0XHRcdGFmdGVyQ3VycmVudCA9IG5ldyBJbnRlcnZhbChyaWdodEludGVydmFsLmIgKyAxLCByZXN1bHRJbnRlcnZhbC5iKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGJlZm9yZUN1cnJlbnQpIHtcclxuXHRcdFx0XHRpZiAoYWZ0ZXJDdXJyZW50KSB7XHJcblx0XHRcdFx0XHQvLyBzcGxpdCB0aGUgY3VycmVudCBpbnRlcnZhbCBpbnRvIHR3b1xyXG5cdFx0XHRcdFx0cmVzdWx0Ll9pbnRlcnZhbHNbcmVzdWx0SV0gPSBiZWZvcmVDdXJyZW50O1xyXG5cdFx0XHRcdFx0cmVzdWx0Ll9pbnRlcnZhbHMuc3BsaWNlKHJlc3VsdEkgKyAxLCAwLCBhZnRlckN1cnJlbnQpO1xyXG5cdFx0XHRcdFx0cmVzdWx0SSsrO1xyXG5cdFx0XHRcdFx0cmlnaHRJKys7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHQvLyByZXBsYWNlIHRoZSBjdXJyZW50IGludGVydmFsXHJcblx0XHRcdFx0XHRyZXN1bHQuX2ludGVydmFsc1tyZXN1bHRJXSA9IGJlZm9yZUN1cnJlbnQ7XHJcblx0XHRcdFx0XHRyZXN1bHRJKys7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0aWYgKGFmdGVyQ3VycmVudCkge1xyXG5cdFx0XHRcdFx0Ly8gcmVwbGFjZSB0aGUgY3VycmVudCBpbnRlcnZhbFxyXG5cdFx0XHRcdFx0cmVzdWx0Ll9pbnRlcnZhbHNbcmVzdWx0SV0gPSBhZnRlckN1cnJlbnQ7XHJcblx0XHRcdFx0XHRyaWdodEkrKztcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdC8vIHJlbW92ZSB0aGUgY3VycmVudCBpbnRlcnZhbCAodGh1cyBubyBuZWVkIHRvIGluY3JlbWVudCByZXN1bHRJKVxyXG5cdFx0XHRcdFx0cmVzdWx0Ll9pbnRlcnZhbHMuc3BsaWNlKHJlc3VsdEksIDEpO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgcmlnaHRJIHJlYWNoZWQgcmlnaHQuaW50ZXJ2YWxzLnNpemUsIG5vIG1vcmUgaW50ZXJ2YWxzIHRvIHN1YnRyYWN0IGZyb20gcmVzdWx0LlxyXG5cdFx0Ly8gSWYgcmVzdWx0SSByZWFjaGVkIHJlc3VsdC5pbnRlcnZhbHMuc2l6ZSwgd2Ugd291bGQgYmUgc3VidHJhY3RpbmcgZnJvbSBhbiBlbXB0eSBzZXQuXHJcblx0XHQvLyBFaXRoZXIgd2F5LCB3ZSBhcmUgZG9uZS5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgb3IoYTogSW50U2V0KTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0bGV0IG86IEludGVydmFsU2V0ID0gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHRvLmFkZEFsbCh0aGlzKTtcclxuXHRcdG8uYWRkQWxsKGEpO1xyXG5cdFx0cmV0dXJuIG87XHJcblx0fVxyXG5cclxuXHQvKioge0Bpbmhlcml0RG9jfSAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBhbmQob3RoZXI6IEludFNldCk6IEludGVydmFsU2V0IHtcclxuXHRcdGlmIChvdGhlci5pc05pbCkgeyAvL3x8ICEob3RoZXIgaW5zdGFuY2VvZiBJbnRlcnZhbFNldCkgKSB7XHJcblx0XHRcdC8vIG5vdGhpbmcgaW4gY29tbW9uIHdpdGggbnVsbCBzZXRcclxuXHRcdFx0cmV0dXJuIG5ldyBJbnRlcnZhbFNldCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBteUludGVydmFsczogSW50ZXJ2YWxbXSA9IHRoaXMuX2ludGVydmFscztcclxuXHRcdGxldCB0aGVpckludGVydmFsczogSW50ZXJ2YWxbXSA9IChvdGhlciBhcyBJbnRlcnZhbFNldCkuX2ludGVydmFscztcclxuXHRcdGxldCBpbnRlcnNlY3Rpb246IEludGVydmFsU2V0IHwgdW5kZWZpbmVkO1xyXG5cdFx0bGV0IG15U2l6ZTogbnVtYmVyID0gbXlJbnRlcnZhbHMubGVuZ3RoO1xyXG5cdFx0bGV0IHRoZWlyU2l6ZTogbnVtYmVyID0gdGhlaXJJbnRlcnZhbHMubGVuZ3RoO1xyXG5cdFx0bGV0IGk6IG51bWJlciA9IDA7XHJcblx0XHRsZXQgajogbnVtYmVyID0gMDtcclxuXHRcdC8vIGl0ZXJhdGUgZG93biBib3RoIGludGVydmFsIGxpc3RzIGxvb2tpbmcgZm9yIG5vbmRpc2pvaW50IGludGVydmFsc1xyXG5cdFx0d2hpbGUgKGkgPCBteVNpemUgJiYgaiA8IHRoZWlyU2l6ZSkge1xyXG5cdFx0XHRsZXQgbWluZTogSW50ZXJ2YWwgPSBteUludGVydmFsc1tpXTtcclxuXHRcdFx0bGV0IHRoZWlyczogSW50ZXJ2YWwgPSB0aGVpckludGVydmFsc1tqXTtcclxuXHRcdFx0Ly9TeXN0ZW0ub3V0LnByaW50bG4oXCJtaW5lPVwiK21pbmUrXCIgYW5kIHRoZWlycz1cIit0aGVpcnMpO1xyXG5cdFx0XHRpZiAobWluZS5zdGFydHNCZWZvcmVEaXNqb2ludCh0aGVpcnMpKSB7XHJcblx0XHRcdFx0Ly8gbW92ZSB0aGlzIGl0ZXJhdG9yIGxvb2tpbmcgZm9yIGludGVydmFsIHRoYXQgbWlnaHQgb3ZlcmxhcFxyXG5cdFx0XHRcdGkrKztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh0aGVpcnMuc3RhcnRzQmVmb3JlRGlzam9pbnQobWluZSkpIHtcclxuXHRcdFx0XHQvLyBtb3ZlIG90aGVyIGl0ZXJhdG9yIGxvb2tpbmcgZm9yIGludGVydmFsIHRoYXQgbWlnaHQgb3ZlcmxhcFxyXG5cdFx0XHRcdGorKztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChtaW5lLnByb3Blcmx5Q29udGFpbnModGhlaXJzKSkge1xyXG5cdFx0XHRcdC8vIG92ZXJsYXAsIGFkZCBpbnRlcnNlY3Rpb24sIGdldCBuZXh0IHRoZWlyc1xyXG5cdFx0XHRcdGlmICghaW50ZXJzZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdGlvbi5hZGRSYW5nZShtaW5lLmludGVyc2VjdGlvbih0aGVpcnMpKTtcclxuXHRcdFx0XHRqKys7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAodGhlaXJzLnByb3Blcmx5Q29udGFpbnMobWluZSkpIHtcclxuXHRcdFx0XHQvLyBvdmVybGFwLCBhZGQgaW50ZXJzZWN0aW9uLCBnZXQgbmV4dCBtaW5lXHJcblx0XHRcdFx0aWYgKCFpbnRlcnNlY3Rpb24pIHtcclxuXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IG5ldyBJbnRlcnZhbFNldCgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aW50ZXJzZWN0aW9uLmFkZFJhbmdlKG1pbmUuaW50ZXJzZWN0aW9uKHRoZWlycykpO1xyXG5cdFx0XHRcdGkrKztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICghbWluZS5kaXNqb2ludCh0aGVpcnMpKSB7XHJcblx0XHRcdFx0Ly8gb3ZlcmxhcCwgYWRkIGludGVyc2VjdGlvblxyXG5cdFx0XHRcdGlmICghaW50ZXJzZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdGlvbi5hZGRSYW5nZShtaW5lLmludGVyc2VjdGlvbih0aGVpcnMpKTtcclxuXHRcdFx0XHQvLyBNb3ZlIHRoZSBpdGVyYXRvciBvZiBsb3dlciByYW5nZSBbYS4uYl0sIGJ1dCBub3RcclxuXHRcdFx0XHQvLyB0aGUgdXBwZXIgcmFuZ2UgYXMgaXQgbWF5IGNvbnRhaW4gZWxlbWVudHMgdGhhdCB3aWxsIGNvbGxpZGVcclxuXHRcdFx0XHQvLyB3aXRoIHRoZSBuZXh0IGl0ZXJhdG9yLiBTbywgaWYgbWluZT1bMC4uMTE1XSBhbmRcclxuXHRcdFx0XHQvLyB0aGVpcnM9WzExNS4uMjAwXSwgdGhlbiBpbnRlcnNlY3Rpb24gaXMgMTE1IGFuZCBtb3ZlIG1pbmVcclxuXHRcdFx0XHQvLyBidXQgbm90IHRoZWlycyBhcyB0aGVpcnMgbWF5IGNvbGxpZGUgd2l0aCB0aGUgbmV4dCByYW5nZVxyXG5cdFx0XHRcdC8vIGluIHRoaXNJdGVyLlxyXG5cdFx0XHRcdC8vIG1vdmUgYm90aCBpdGVyYXRvcnMgdG8gbmV4dCByYW5nZXNcclxuXHRcdFx0XHRpZiAobWluZS5zdGFydHNBZnRlck5vbkRpc2pvaW50KHRoZWlycykpIHtcclxuXHRcdFx0XHRcdGorKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAodGhlaXJzLnN0YXJ0c0FmdGVyTm9uRGlzam9pbnQobWluZSkpIHtcclxuXHRcdFx0XHRcdGkrKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWludGVyc2VjdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEludGVydmFsU2V0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcclxuXHR9XHJcblxyXG5cdC8qKiB7QGluaGVyaXREb2N9ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGNvbnRhaW5zKGVsOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGxldCBuOiBudW1iZXIgPSB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoO1xyXG5cdFx0bGV0IGw6IG51bWJlciA9IDA7XHJcblx0XHRsZXQgcjogbnVtYmVyID0gbiAtIDE7XHJcblx0XHQvLyBCaW5hcnkgc2VhcmNoIGZvciB0aGUgZWxlbWVudCBpbiB0aGUgKHNvcnRlZCwgZGlzam9pbnQpIGFycmF5IG9mIGludGVydmFscy5cclxuXHRcdHdoaWxlIChsIDw9IHIpIHtcclxuXHRcdFx0bGV0IG06IG51bWJlciA9IChsICsgcikgPj4gMTtcclxuXHRcdFx0bGV0IEk6IEludGVydmFsID0gdGhpcy5faW50ZXJ2YWxzW21dO1xyXG5cdFx0XHRsZXQgYTogbnVtYmVyID0gSS5hO1xyXG5cdFx0XHRsZXQgYjogbnVtYmVyID0gSS5iO1xyXG5cdFx0XHRpZiAoYiA8IGVsKSB7XHJcblx0XHRcdFx0bCA9IG0gKyAxO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGEgPiBlbCkge1xyXG5cdFx0XHRcdHIgPSBtIC0gMTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBlbCA+PSBhICYmIGVsIDw9IGJcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdC8qKiB7QGluaGVyaXREb2N9ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzTmlsKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ludGVydmFscyA9PSBudWxsIHx8IHRoaXMuX2ludGVydmFscy5sZW5ndGggPT09IDA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IGlmIG5vdCBpc05pbC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4gdGhlIG1heGltdW0gdmFsdWUgY29udGFpbmVkIGluIHRoZSBzZXQuXHJcblx0ICogQHRocm93cyBSYW5nZUVycm9yIGlmIHNldCBpcyBlbXB0eVxyXG5cdCAqL1xyXG5cdGdldCBtYXhFbGVtZW50KCk6IG51bWJlciB7XHJcblx0XHRpZiAodGhpcy5pc05pbCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNldCBpcyBlbXB0eVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbGFzdDogSW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbHNbdGhpcy5faW50ZXJ2YWxzLmxlbmd0aCAtIDFdO1xyXG5cdFx0cmV0dXJuIGxhc3QuYjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUgY29udGFpbmVkIGluIHRoZSBzZXQgaWYgbm90IGlzTmlsLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB0aGUgbWluaW11bSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIHNldC5cclxuXHQgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgc2V0IGlzIGVtcHR5XHJcblx0ICovXHJcblx0Z2V0IG1pbkVsZW1lbnQoKTogbnVtYmVyIHtcclxuXHRcdGlmICh0aGlzLmlzTmlsKSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwic2V0IGlzIGVtcHR5XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9pbnRlcnZhbHNbMF0uYTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZXR1cm4gYSBsaXN0IG9mIEludGVydmFsIG9iamVjdHMuICovXHJcblx0Z2V0IGludGVydmFscygpOiBJbnRlcnZhbFtdIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbnRlcnZhbHM7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoKTtcclxuXHRcdGZvciAobGV0IEkgb2YgdGhpcy5faW50ZXJ2YWxzKSB7XHJcblx0XHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCBJLmEpO1xyXG5cdFx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgSS5iKTtcclxuXHRcdH1cclxuXHJcblx0XHRoYXNoID0gTXVybXVySGFzaC5maW5pc2goaGFzaCwgdGhpcy5faW50ZXJ2YWxzLmxlbmd0aCAqIDIpO1xyXG5cdFx0cmV0dXJuIGhhc2g7XHJcblx0fVxyXG5cclxuXHQvKiogQXJlIHR3byBJbnRlcnZhbFNldHMgZXF1YWw/ICBCZWNhdXNlIGFsbCBpbnRlcnZhbHMgYXJlIHNvcnRlZFxyXG5cdCAqICBhbmQgZGlzam9pbnQsIGVxdWFscyBpcyBhIHNpbXBsZSBsaW5lYXIgd2FsayBvdmVyIGJvdGggbGlzdHNcclxuXHQgKiAgdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHRoZSBzYW1lLiAgSW50ZXJ2YWwuZXF1YWxzKCkgaXMgdXNlZFxyXG5cdCAqICBieSB0aGUgTGlzdC5lcXVhbHMoKSBtZXRob2QgdG8gY2hlY2sgdGhlIHJhbmdlcy5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG86IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG8gPT0gbnVsbCB8fCAhKG8gaW5zdGFuY2VvZiBJbnRlcnZhbFNldCkpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBBcnJheUVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRS5lcXVhbHModGhpcy5faW50ZXJ2YWxzLCBvLl9pbnRlcnZhbHMpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvU3RyaW5nKGVsZW1BcmVDaGFyOiBib29sZWFuID0gZmFsc2UpOiBzdHJpbmcge1xyXG5cdFx0bGV0IGJ1Zjogc3RyaW5nID0gXCJcIjtcclxuXHRcdGlmICh0aGlzLl9pbnRlcnZhbHMgPT0gbnVsbCB8fCB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBcInt9XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuc2l6ZSA+IDEpIHtcclxuXHRcdFx0YnVmICs9IFwie1wiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBmaXJzdDogYm9vbGVhbiA9IHRydWU7XHJcblx0XHRmb3IgKGxldCBJIG9mIHRoaXMuX2ludGVydmFscykge1xyXG5cdFx0XHRpZiAoZmlyc3QpIHtcclxuXHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGJ1ZiArPSBcIiwgXCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBhOiBudW1iZXIgPSBJLmE7XHJcblx0XHRcdGxldCBiOiBudW1iZXIgPSBJLmI7XHJcblx0XHRcdGlmIChhID09PSBiKSB7XHJcblx0XHRcdFx0aWYgKGEgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHRcdFx0YnVmICs9IFwiPEVPRj5cIjtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGVsZW1BcmVDaGFyKSB7XHJcblx0XHRcdFx0XHRidWYgKz0gXCInXCIgKyBTdHJpbmcuZnJvbUNvZGVQb2ludChhKSArIFwiJ1wiO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRidWYgKz0gYTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGVsZW1BcmVDaGFyKSB7XHJcblx0XHRcdFx0XHRidWYgKz0gXCInXCIgKyBTdHJpbmcuZnJvbUNvZGVQb2ludChhKSArIFwiJy4uJ1wiICsgU3RyaW5nLmZyb21Db2RlUG9pbnQoYikgKyBcIidcIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YnVmICs9IGEgKyBcIi4uXCIgKyBiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLnNpemUgPiAxKSB7XHJcblx0XHRcdGJ1ZiArPSBcIn1cIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYnVmO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvU3RyaW5nVm9jYWJ1bGFyeSggQE5vdE51bGwgdm9jYWJ1bGFyeTogVm9jYWJ1bGFyeSk6IHN0cmluZyB7XHJcblx0XHRpZiAodGhpcy5faW50ZXJ2YWxzID09IG51bGwgfHwgdGhpcy5faW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gXCJ7fVwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBidWY6IHN0cmluZyA9IFwiXCI7XHJcblx0XHRpZiAodGhpcy5zaXplID4gMSkge1xyXG5cdFx0XHRidWYgKz0gXCJ7XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGZpcnN0OiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdGZvciAobGV0IEkgb2YgdGhpcy5faW50ZXJ2YWxzKSB7XHJcblx0XHRcdGlmIChmaXJzdCkge1xyXG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0YnVmICs9IFwiLCBcIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGE6IG51bWJlciA9IEkuYTtcclxuXHRcdFx0bGV0IGI6IG51bWJlciA9IEkuYjtcclxuXHRcdFx0aWYgKGEgPT09IGIpIHtcclxuXHRcdFx0XHRidWYgKz0gdGhpcy5lbGVtZW50TmFtZSh2b2NhYnVsYXJ5LCBhKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gYTsgaSA8PSBiOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChpID4gYSkge1xyXG5cdFx0XHRcdFx0XHRidWYgKz0gXCIsIFwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJ1ZiArPSB0aGlzLmVsZW1lbnROYW1lKHZvY2FidWxhcnksIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLnNpemUgPiAxKSB7XHJcblx0XHRcdGJ1ZiArPSBcIn1cIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYnVmO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgZWxlbWVudE5hbWUoIEBOb3ROdWxsIHZvY2FidWxhcnk6IFZvY2FidWxhcnksIGE6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRpZiAoYSA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdHJldHVybiBcIjxFT0Y+XCI7XHJcblx0XHR9IGVsc2UgaWYgKGEgPT09IFRva2VuLkVQU0lMT04pIHtcclxuXHRcdFx0cmV0dXJuIFwiPEVQU0lMT04+XCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gdm9jYWJ1bGFyeS5nZXREaXNwbGF5TmFtZShhKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzaXplKCk6IG51bWJlciB7XHJcblx0XHRsZXQgbjogbnVtYmVyID0gMDtcclxuXHRcdGxldCBudW1JbnRlcnZhbHM6IG51bWJlciA9IHRoaXMuX2ludGVydmFscy5sZW5ndGg7XHJcblx0XHRpZiAobnVtSW50ZXJ2YWxzID09PSAxKSB7XHJcblx0XHRcdGxldCBmaXJzdEludGVydmFsOiBJbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsc1swXTtcclxuXHRcdFx0cmV0dXJuIGZpcnN0SW50ZXJ2YWwuYiAtIGZpcnN0SW50ZXJ2YWwuYSArIDE7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudW1JbnRlcnZhbHM7IGkrKykge1xyXG5cdFx0XHRsZXQgSTogSW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbHNbaV07XHJcblx0XHRcdG4gKz0gKEkuYiAtIEkuYSArIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvSW50ZWdlckxpc3QoKTogSW50ZWdlckxpc3Qge1xyXG5cdFx0bGV0IHZhbHVlczogSW50ZWdlckxpc3QgPSBuZXcgSW50ZWdlckxpc3QodGhpcy5zaXplKTtcclxuXHRcdGxldCBuOiBudW1iZXIgPSB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0bGV0IEk6IEludGVydmFsID0gdGhpcy5faW50ZXJ2YWxzW2ldO1xyXG5cdFx0XHRsZXQgYTogbnVtYmVyID0gSS5hO1xyXG5cdFx0XHRsZXQgYjogbnVtYmVyID0gSS5iO1xyXG5cdFx0XHRmb3IgKGxldCB2ID0gYTsgdiA8PSBiOyB2KyspIHtcclxuXHRcdFx0XHR2YWx1ZXMuYWRkKHYpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b1NldCgpOiBTZXQ8bnVtYmVyPiB7XHJcblx0XHRsZXQgczogU2V0PG51bWJlcj4gPSBuZXcgU2V0PG51bWJlcj4oKTtcclxuXHRcdGZvciAobGV0IEkgb2YgdGhpcy5faW50ZXJ2YWxzKSB7XHJcblx0XHRcdGxldCBhOiBudW1iZXIgPSBJLmE7XHJcblx0XHRcdGxldCBiOiBudW1iZXIgPSBJLmI7XHJcblx0XHRcdGZvciAobGV0IHYgPSBhOyB2IDw9IGI7IHYrKykge1xyXG5cdFx0XHRcdHMuYWRkKHYpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdG9BcnJheSgpOiBudW1iZXJbXSB7XHJcblx0XHRsZXQgdmFsdWVzOiBudW1iZXJbXSA9IG5ldyBBcnJheTxudW1iZXI+KCk7XHJcblx0XHRsZXQgbjogbnVtYmVyID0gdGhpcy5faW50ZXJ2YWxzLmxlbmd0aDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdGxldCBJOiBJbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsc1tpXTtcclxuXHRcdFx0bGV0IGE6IG51bWJlciA9IEkuYTtcclxuXHRcdFx0bGV0IGI6IG51bWJlciA9IEkuYjtcclxuXHRcdFx0Zm9yIChsZXQgdiA9IGE7IHYgPD0gYjsgdisrKSB7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2godik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlbW92ZShlbDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5yZWFkb25seSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBhbHRlciByZWFkb25seSBJbnRlcnZhbFNldFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbjogbnVtYmVyID0gdGhpcy5faW50ZXJ2YWxzLmxlbmd0aDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdGxldCBJOiBJbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsc1tpXTtcclxuXHRcdFx0bGV0IGE6IG51bWJlciA9IEkuYTtcclxuXHRcdFx0bGV0IGI6IG51bWJlciA9IEkuYjtcclxuXHRcdFx0aWYgKGVsIDwgYSkge1xyXG5cdFx0XHRcdGJyZWFrOyAvLyBsaXN0IGlzIHNvcnRlZCBhbmQgZWwgaXMgYmVmb3JlIHRoaXMgaW50ZXJ2YWw7IG5vdCBoZXJlXHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gaWYgd2hvbGUgaW50ZXJ2YWwgeC4ueCwgcm1cclxuXHRcdFx0aWYgKGVsID09PSBhICYmIGVsID09PSBiKSB7XHJcblx0XHRcdFx0dGhpcy5faW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBpZiBvbiBsZWZ0IGVkZ2UgeC4uYiwgYWRqdXN0IGxlZnRcclxuXHRcdFx0aWYgKGVsID09PSBhKSB7XHJcblx0XHRcdFx0dGhpcy5faW50ZXJ2YWxzW2ldID0gSW50ZXJ2YWwub2YoSS5hICsgMSwgSS5iKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBpZiBvbiByaWdodCBlZGdlIGEuLngsIGFkanVzdCByaWdodFxyXG5cdFx0XHRpZiAoZWwgPT09IGIpIHtcclxuXHRcdFx0XHR0aGlzLl9pbnRlcnZhbHNbaV0gPSBJbnRlcnZhbC5vZihJLmEsIEkuYiAtIDEpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGlmIGluIG1pZGRsZSBhLi54Li5iLCBzcGxpdCBpbnRlcnZhbFxyXG5cdFx0XHRpZiAoZWwgPiBhICYmIGVsIDwgYikgeyAvLyBmb3VuZCBpbiB0aGlzIGludGVydmFsXHJcblx0XHRcdFx0bGV0IG9sZGI6IG51bWJlciA9IEkuYjtcclxuXHRcdFx0XHR0aGlzLl9pbnRlcnZhbHNbaV0gPSBJbnRlcnZhbC5vZihJLmEsIGVsIC0gMSk7IC8vIFthLi54LTFdXHJcblx0XHRcdFx0dGhpcy5hZGQoZWwgKyAxLCBvbGRiKTsgLy8gYWRkIFt4KzEuLmJdXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGdldCBpc1JlYWRvbmx5KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMucmVhZG9ubHk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0UmVhZG9ubHkocmVhZG9ubHk6IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLnJlYWRvbmx5ICYmICFyZWFkb25seSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBhbHRlciByZWFkb25seSBJbnRlcnZhbFNldFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnJlYWRvbmx5ID0gcmVhZG9ubHk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyNS44MTg3OTEyLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyB7XHJcblx0cHJpdmF0ZSBzdGF0aWMgX2RlZmF1bHRPcHRpb25zPzogQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucztcclxuXHJcblx0cHJpdmF0ZSByZWFkT25seTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHByaXZhdGUgdmVyaWZ5QVROOiBib29sZWFuO1xyXG5cdHByaXZhdGUgZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnM6IGJvb2xlYW47XHJcblx0cHJpdmF0ZSBvcHRpbWl6ZTogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucz86IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMpIHtcclxuXHRcdGlmIChvcHRpb25zKSB7XHJcblx0XHRcdHRoaXMudmVyaWZ5QVROID0gb3B0aW9ucy52ZXJpZnlBVE47XHJcblx0XHRcdHRoaXMuZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMgPSBvcHRpb25zLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zO1xyXG5cdFx0XHR0aGlzLm9wdGltaXplID0gb3B0aW9ucy5vcHRpbWl6ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMudmVyaWZ5QVROID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLm9wdGltaXplID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0c3RhdGljIGdldCBkZWZhdWx0T3B0aW9ucygpOiBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zIHtcclxuXHRcdGlmIChBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zLl9kZWZhdWx0T3B0aW9ucyA9PSBudWxsKSB7XHJcblx0XHRcdEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMuX2RlZmF1bHRPcHRpb25zID0gbmV3IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMoKTtcclxuXHRcdFx0QVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5fZGVmYXVsdE9wdGlvbnMubWFrZVJlYWRPbmx5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMuX2RlZmF1bHRPcHRpb25zO1xyXG5cdH1cclxuXHJcblx0Z2V0IGlzUmVhZE9ubHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5yZWFkT25seTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBtYWtlUmVhZE9ubHkoKTogdm9pZCB7XHJcblx0XHR0aGlzLnJlYWRPbmx5ID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdGdldCBpc1ZlcmlmeUFUTigpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnZlcmlmeUFUTjtcclxuXHR9XHJcblxyXG5cdHNldCBpc1ZlcmlmeUFUTih2ZXJpZnlBVE46IGJvb2xlYW4pIHtcclxuXHRcdHRoaXMudGhyb3dJZlJlYWRPbmx5KCk7XHJcblx0XHR0aGlzLnZlcmlmeUFUTiA9IHZlcmlmeUFUTjtcclxuXHR9XHJcblxyXG5cdGdldCBpc0dlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnM7XHJcblx0fVxyXG5cclxuXHRzZXQgaXNHZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyhnZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9uczogYm9vbGVhbikge1xyXG5cdFx0dGhpcy50aHJvd0lmUmVhZE9ubHkoKTtcclxuXHRcdHRoaXMuZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMgPSBnZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucztcclxuXHR9XHJcblxyXG5cdGdldCBpc09wdGltaXplKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW1pemU7XHJcblx0fVxyXG5cclxuXHRzZXQgaXNPcHRpbWl6ZShvcHRpbWl6ZTogYm9vbGVhbikge1xyXG5cdFx0dGhpcy50aHJvd0lmUmVhZE9ubHkoKTtcclxuXHRcdHRoaXMub3B0aW1pemUgPSBvcHRpbWl6ZTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCB0aHJvd0lmUmVhZE9ubHkoKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5pc1JlYWRPbmx5KSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSBvYmplY3QgaXMgcmVhZCBvbmx5LlwiKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI0LjczNjM0NDgtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUsIE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQWN0aW9uVHJhbnNpdGlvbiBleHRlbmRzIFRyYW5zaXRpb24ge1xyXG5cdHB1YmxpYyBydWxlSW5kZXg6IG51bWJlcjtcclxuXHRwdWJsaWMgYWN0aW9uSW5kZXg6IG51bWJlcjtcclxuXHRwdWJsaWMgaXNDdHhEZXBlbmRlbnQ6IGJvb2xlYW47ICAvLyBlLmcuLCAkaSByZWYgaW4gYWN0aW9uXHJcblxyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHRhcmdldDogQVROU3RhdGUsIHJ1bGVJbmRleDogbnVtYmVyLCBhY3Rpb25JbmRleDogbnVtYmVyID0gLTEsIGlzQ3R4RGVwZW5kZW50OiBib29sZWFuID0gZmFsc2UpIHtcclxuXHRcdHN1cGVyKHRhcmdldCk7XHJcblx0XHR0aGlzLnJ1bGVJbmRleCA9IHJ1bGVJbmRleDtcclxuXHRcdHRoaXMuYWN0aW9uSW5kZXggPSBhY3Rpb25JbmRleDtcclxuXHRcdHRoaXMuaXNDdHhEZXBlbmRlbnQgPSBpc0N0eERlcGVuZGVudDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzZXJpYWxpemF0aW9uVHlwZSgpOiBUcmFuc2l0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gVHJhbnNpdGlvblR5cGUuQUNUSU9OO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzRXBzaWxvbigpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0cnVlOyAvLyB3ZSBhcmUgdG8gYmUgaWdub3JlZCBieSBhbmFseXNpcyAnY2VwdCBmb3IgcHJlZGljYXRlc1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG1hdGNoZXMoc3ltYm9sOiBudW1iZXIsIG1pblZvY2FiU3ltYm9sOiBudW1iZXIsIG1heFZvY2FiU3ltYm9sOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiYWN0aW9uX1wiICsgdGhpcy5ydWxlSW5kZXggKyBcIjpcIiArIHRoaXMuYWN0aW9uSW5kZXg7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyNy42NzY5MTIyLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEludGVydmFsU2V0IH0gZnJvbSBcIi4uL21pc2MvSW50ZXJ2YWxTZXRcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUsIE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcblxyXG4vKiogVE9ETzogbWFrZSBhbGwgdHJhbnNpdGlvbnMgc2V0cz8gbm8sIHNob3VsZCByZW1vdmUgc2V0IGVkZ2VzICovXHJcbmV4cG9ydCBjbGFzcyBBdG9tVHJhbnNpdGlvbiBleHRlbmRzIFRyYW5zaXRpb24ge1xyXG5cdC8qKiBUaGUgdG9rZW4gdHlwZSBvciBjaGFyYWN0ZXIgdmFsdWU7IG9yLCBzaWduaWZpZXMgc3BlY2lhbCBsYWJlbC4gKi9cclxuXHRwdWJsaWMgX2xhYmVsOiBudW1iZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHRhcmdldDogQVROU3RhdGUsIGxhYmVsOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKHRhcmdldCk7XHJcblx0XHR0aGlzLl9sYWJlbCA9IGxhYmVsO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNlcmlhbGl6YXRpb25UeXBlKCk6IFRyYW5zaXRpb25UeXBlIHtcclxuXHRcdHJldHVybiBUcmFuc2l0aW9uVHlwZS5BVE9NO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0QE5vdE51bGxcclxuXHRnZXQgbGFiZWwoKTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0cmV0dXJuIEludGVydmFsU2V0Lm9mKHRoaXMuX2xhYmVsKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBtYXRjaGVzKHN5bWJvbDogbnVtYmVyLCBtaW5Wb2NhYlN5bWJvbDogbnVtYmVyLCBtYXhWb2NhYlN5bWJvbDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGFiZWwgPT09IHN5bWJvbDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gU3RyaW5nKHRoaXMubGFiZWwpO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjcuOTkzMDM5NC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQmxvY2tFbmRTdGF0ZSB9IGZyb20gXCIuL0Jsb2NrRW5kU3RhdGVcIjtcclxuaW1wb3J0IHsgRGVjaXNpb25TdGF0ZSB9IGZyb20gXCIuL0RlY2lzaW9uU3RhdGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqICBUaGUgc3RhcnQgb2YgYSByZWd1bGFyIGAoLi4uKWAgYmxvY2suICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCbG9ja1N0YXJ0U3RhdGUgZXh0ZW5kcyBEZWNpc2lvblN0YXRlIHtcclxuXHQvLyBUaGlzIGlzIGFsd2F5cyBzZXQgZHVyaW5nIEFUTiBkZXNlcmlhbGl6YXRpb25cclxuXHRwdWJsaWMgZW5kU3RhdGUhOiBCbG9ja0VuZFN0YXRlO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyNy43NjY5ODAxLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZVR5cGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVR5cGVcIjtcclxuaW1wb3J0IHsgQmxvY2tTdGFydFN0YXRlIH0gZnJvbSBcIi4vQmxvY2tTdGFydFN0YXRlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmFzaWNCbG9ja1N0YXJ0U3RhdGUgZXh0ZW5kcyBCbG9ja1N0YXJ0U3RhdGUge1xyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhdGVUeXBlKCk6IEFUTlN0YXRlVHlwZSB7XHJcblx0XHRyZXR1cm4gQVROU3RhdGVUeXBlLkJMT0NLX1NUQVJUO1xyXG5cdH1cclxuXHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI3LjkxMjUzMDQtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IEJsb2NrU3RhcnRTdGF0ZSB9IGZyb20gXCIuL0Jsb2NrU3RhcnRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKiogVGVybWluYWwgbm9kZSBvZiBhIHNpbXBsZSBgKGF8YnxjKWAgYmxvY2suICovXHJcbmV4cG9ydCBjbGFzcyBCbG9ja0VuZFN0YXRlIGV4dGVuZHMgQVROU3RhdGUge1xyXG5cdC8vIFRoaXMgaXMgYWx3YXlzIHNldCBkdXJpbmcgQVROIGRlc2VyaWFsaXphdGlvblxyXG5cdHB1YmxpYyBzdGFydFN0YXRlITogQmxvY2tTdGFydFN0YXRlO1xyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhdGVUeXBlKCk6IEFUTlN0YXRlVHlwZSB7XHJcblx0XHRyZXR1cm4gQVROU3RhdGVUeXBlLkJMT0NLX0VORDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI4LjYyODMyMTMtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUsIE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uVHlwZSB9IGZyb20gXCIuL1RyYW5zaXRpb25UeXBlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgRXBzaWxvblRyYW5zaXRpb24gZXh0ZW5kcyBUcmFuc2l0aW9uIHtcclxuXHJcblx0cHJpdmF0ZSBfb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybjogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCB0YXJnZXQ6IEFUTlN0YXRlLCBvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuOiBudW1iZXIgPSAtMSkge1xyXG5cdFx0c3VwZXIodGFyZ2V0KTtcclxuXHRcdHRoaXMuX291dGVybW9zdFByZWNlZGVuY2VSZXR1cm4gPSBvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQHJldHVybnMgdGhlIHJ1bGUgaW5kZXggb2YgYSBwcmVjZWRlbmNlIHJ1bGUgZm9yIHdoaWNoIHRoaXMgdHJhbnNpdGlvbiBpc1xyXG5cdCAqIHJldHVybmluZyBmcm9tLCB3aGVyZSB0aGUgcHJlY2VkZW5jZSB2YWx1ZSBpcyAwOyBvdGhlcndpc2UsIC0xLlxyXG5cdCAqXHJcblx0ICogQHNlZSBBVE5Db25maWcuaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZFxyXG5cdCAqIEBzZWUgUGFyc2VyQVROU2ltdWxhdG9yI2FwcGx5UHJlY2VkZW5jZUZpbHRlcihBVE5Db25maWdTZXQsIFBhcnNlclJ1bGVDb250ZXh0LCBQcmVkaWN0aW9uQ29udGV4dENhY2hlKVxyXG5cdCAqIEBzaW5jZSA0LjQuMVxyXG5cdCAqL1xyXG5cdGdldCBvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzZXJpYWxpemF0aW9uVHlwZSgpOiBUcmFuc2l0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gVHJhbnNpdGlvblR5cGUuRVBTSUxPTjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc0Vwc2lsb24oKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBtYXRjaGVzKHN5bWJvbDogbnVtYmVyLCBtaW5Wb2NhYlN5bWJvbDogbnVtYmVyLCBtYXhWb2NhYlN5bWJvbDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiZXBzaWxvblwiO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjkuNTYzNDM4OC0wNzowMFxyXG5cclxuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi4vTGV4ZXJcIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb24gfSBmcm9tIFwiLi9MZXhlckFjdGlvblwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvblR5cGUgfSBmcm9tIFwiLi9MZXhlckFjdGlvblR5cGVcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuLi9taXNjL011cm11ckhhc2hcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIGBjaGFubmVsYCBsZXhlciBhY3Rpb24gYnkgY2FsbGluZ1xyXG4gKiB7QGxpbmsgTGV4ZXIjc2V0Q2hhbm5lbH0gd2l0aCB0aGUgYXNzaWduZWQgY2hhbm5lbC5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKiBAc2luY2UgNC4yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGV4ZXJDaGFubmVsQWN0aW9uIGltcGxlbWVudHMgTGV4ZXJBY3Rpb24ge1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgX2NoYW5uZWw6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBgY2hhbm5lbGAgYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBjaGFubmVsIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHZhbHVlIHRvIHBhc3MgdG8ge0BsaW5rIExleGVyI3NldENoYW5uZWx9LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGNoYW5uZWw6IG51bWJlcikge1xyXG5cdFx0dGhpcy5fY2hhbm5lbCA9IGNoYW5uZWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBjaGFubmVsIHRvIHVzZSBmb3IgdGhlIHtAbGluayBUb2tlbn0gY3JlYXRlZCBieSB0aGUgbGV4ZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgY2hhbm5lbCB0byB1c2UgZm9yIHRoZSB7QGxpbmsgVG9rZW59IGNyZWF0ZWQgYnkgdGhlIGxleGVyLlxyXG5cdCAqL1xyXG5cdGdldCBjaGFubmVsKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hhbm5lbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIHtAbGluayBMZXhlckFjdGlvblR5cGUjQ0hBTk5FTH0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGFjdGlvblR5cGUoKTogTGV4ZXJBY3Rpb25UeXBlIHtcclxuXHRcdHJldHVybiBMZXhlckFjdGlvblR5cGUuQ0hBTk5FTDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGFjdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBjYWxsaW5nIHtAbGluayBMZXhlciNzZXRDaGFubmVsfSB3aXRoIHRoZVxyXG5cdCAqIHZhbHVlIHByb3ZpZGVkIGJ5IHtAbGluayAjZ2V0Q2hhbm5lbH0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGV4ZWN1dGUoQE5vdE51bGwgbGV4ZXI6IExleGVyKTogdm9pZCB7XHJcblx0XHRsZXhlci5jaGFubmVsID0gdGhpcy5fY2hhbm5lbDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IGhhc2g6IG51bWJlciA9IE11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuYWN0aW9uVHlwZSk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5fY2hhbm5lbCk7XHJcblx0XHRyZXR1cm4gTXVybXVySGFzaC5maW5pc2goaGFzaCwgMik7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbiB7XHJcblx0XHRpZiAob2JqID09PSB0aGlzKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIGlmICghKG9iaiBpbnN0YW5jZW9mIExleGVyQ2hhbm5lbEFjdGlvbikpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jaGFubmVsID09PSBvYmouX2NoYW5uZWw7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgY2hhbm5lbCgke3RoaXMuX2NoYW5uZWx9KWA7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOS42NTY3OTkyLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvbiB9IGZyb20gXCIuL0xleGVyQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uVHlwZSB9IGZyb20gXCIuL0xleGVyQWN0aW9uVHlwZVwiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4uL21pc2MvTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICogRXhlY3V0ZXMgYSBjdXN0b20gbGV4ZXIgYWN0aW9uIGJ5IGNhbGxpbmcge0BsaW5rIFJlY29nbml6ZXIjYWN0aW9ufSB3aXRoIHRoZVxyXG4gKiBydWxlIGFuZCBhY3Rpb24gaW5kZXhlcyBhc3NpZ25lZCB0byB0aGUgY3VzdG9tIGFjdGlvbi4gVGhlIGltcGxlbWVudGF0aW9uIG9mXHJcbiAqIGEgY3VzdG9tIGFjdGlvbiBpcyBhZGRlZCB0byB0aGUgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBsZXhlciBpbiBhbiBvdmVycmlkZVxyXG4gKiBvZiB7QGxpbmsgUmVjb2duaXplciNhY3Rpb259IHdoZW4gdGhlIGdyYW1tYXIgaXMgY29tcGlsZWQuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgbWF5IHJlcHJlc2VudCBlbWJlZGRlZCBhY3Rpb25zIGNyZWF0ZWQgd2l0aCB0aGUgYHsuLi59YFxyXG4gKiBzeW50YXggaW4gQU5UTFIgNCwgYXMgd2VsbCBhcyBhY3Rpb25zIGNyZWF0ZWQgZm9yIGxleGVyIGNvbW1hbmRzIHdoZXJlIHRoZVxyXG4gKiBjb21tYW5kIGFyZ3VtZW50IGNvdWxkIG5vdCBiZSBldmFsdWF0ZWQgd2hlbiB0aGUgZ3JhbW1hciB3YXMgY29tcGlsZWQuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICogQHNpbmNlIDQuMlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExleGVyQ3VzdG9tQWN0aW9uIGltcGxlbWVudHMgTGV4ZXJBY3Rpb24ge1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgX3J1bGVJbmRleDogbnVtYmVyO1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgX2FjdGlvbkluZGV4OiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBjdXN0b20gbGV4ZXIgYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBydWxlIGFuZCBhY3Rpb25cclxuXHQgKiBpbmRleGVzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJ1bGVJbmRleCBUaGUgcnVsZSBpbmRleCB0byB1c2UgZm9yIGNhbGxzIHRvXHJcblx0ICoge0BsaW5rIFJlY29nbml6ZXIjYWN0aW9ufS5cclxuXHQgKiBAcGFyYW0gYWN0aW9uSW5kZXggVGhlIGFjdGlvbiBpbmRleCB0byB1c2UgZm9yIGNhbGxzIHRvXHJcblx0ICoge0BsaW5rIFJlY29nbml6ZXIjYWN0aW9ufS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihydWxlSW5kZXg6IG51bWJlciwgYWN0aW9uSW5kZXg6IG51bWJlcikge1xyXG5cdFx0dGhpcy5fcnVsZUluZGV4ID0gcnVsZUluZGV4O1xyXG5cdFx0dGhpcy5fYWN0aW9uSW5kZXggPSBhY3Rpb25JbmRleDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHJ1bGUgaW5kZXggdG8gdXNlIGZvciBjYWxscyB0byB7QGxpbmsgUmVjb2duaXplciNhY3Rpb259LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIHJ1bGUgaW5kZXggZm9yIHRoZSBjdXN0b20gYWN0aW9uLlxyXG5cdCAqL1xyXG5cdGdldCBydWxlSW5kZXgoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9ydWxlSW5kZXg7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBhY3Rpb24gaW5kZXggdG8gdXNlIGZvciBjYWxscyB0byB7QGxpbmsgUmVjb2duaXplciNhY3Rpb259LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIGFjdGlvbiBpbmRleCBmb3IgdGhlIGN1c3RvbSBhY3Rpb24uXHJcblx0ICovXHJcblx0Z2V0IGFjdGlvbkluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYWN0aW9uSW5kZXg7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIHtAbGluayBMZXhlckFjdGlvblR5cGUjQ1VTVE9NfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgYWN0aW9uVHlwZSgpOiBMZXhlckFjdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIExleGVyQWN0aW9uVHlwZS5DVVNUT007XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHdoZXRoZXIgdGhlIGxleGVyIGFjdGlvbiBpcyBwb3NpdGlvbi1kZXBlbmRlbnQuIFBvc2l0aW9uLWRlcGVuZGVudFxyXG5cdCAqIGFjdGlvbnMgbWF5IGhhdmUgZGlmZmVyZW50IHNlbWFudGljcyBkZXBlbmRpbmcgb24gdGhlIHtAbGluayBDaGFyU3RyZWFtfVxyXG5cdCAqIGluZGV4IGF0IHRoZSB0aW1lIHRoZSBhY3Rpb24gaXMgZXhlY3V0ZWQuXHJcblx0ICpcclxuXHQgKiBDdXN0b20gYWN0aW9ucyBhcmUgcG9zaXRpb24tZGVwZW5kZW50IHNpbmNlIHRoZXkgbWF5IHJlcHJlc2VudCBhXHJcblx0ICogdXNlci1kZWZpbmVkIGVtYmVkZGVkIGFjdGlvbiB3aGljaCBtYWtlcyBjYWxscyB0byBtZXRob2RzIGxpa2VcclxuXHQgKiB7QGxpbmsgTGV4ZXIjZ2V0VGV4dH0uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaXNQb3NpdGlvbkRlcGVuZGVudCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogQ3VzdG9tIGFjdGlvbnMgYXJlIGltcGxlbWVudGVkIGJ5IGNhbGxpbmcge0BsaW5rIExleGVyI2FjdGlvbn0gd2l0aCB0aGVcclxuXHQgKiBhcHByb3ByaWF0ZSBydWxlIGFuZCBhY3Rpb24gaW5kZXhlcy5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXhlY3V0ZShATm90TnVsbCBsZXhlcjogTGV4ZXIpOiB2b2lkIHtcclxuXHRcdGxleGVyLmFjdGlvbih1bmRlZmluZWQsIHRoaXMuX3J1bGVJbmRleCwgdGhpcy5fYWN0aW9uSW5kZXgpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKCk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5hY3Rpb25UeXBlKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLl9ydWxlSW5kZXgpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuX2FjdGlvbkluZGV4KTtcclxuXHRcdHJldHVybiBNdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAzKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChvYmogPT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgTGV4ZXJDdXN0b21BY3Rpb24pKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fcnVsZUluZGV4ID09PSBvYmouX3J1bGVJbmRleFxyXG5cdFx0XHQmJiB0aGlzLl9hY3Rpb25JbmRleCA9PT0gb2JqLl9hY3Rpb25JbmRleDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI5Ljg2NTM0MjctMDc6MDBcclxuXHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL0xleGVyXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb25UeXBlIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25UeXBlXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIHRoZSBgbW9kZWAgbGV4ZXIgYWN0aW9uIGJ5IGNhbGxpbmcge0BsaW5rIExleGVyI21vZGV9IHdpdGhcclxuICogdGhlIGFzc2lnbmVkIG1vZGUuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICogQHNpbmNlIDQuMlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExleGVyTW9kZUFjdGlvbiBpbXBsZW1lbnRzIExleGVyQWN0aW9uIHtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9tb2RlOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYG1vZGVgIGFjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbW9kZSB2YWx1ZS5cclxuXHQgKiBAcGFyYW0gbW9kZSBUaGUgbW9kZSB2YWx1ZSB0byBwYXNzIHRvIHtAbGluayBMZXhlciNtb2RlfS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcihtb2RlOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuX21vZGUgPSBtb2RlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBsZXhlciBtb2RlIHRoaXMgYWN0aW9uIHNob3VsZCB0cmFuc2l0aW9uIHRoZSBsZXhlciB0by5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBsZXhlciBtb2RlIGZvciB0aGlzIGBtb2RlYCBjb21tYW5kLlxyXG5cdCAqL1xyXG5cdGdldCBtb2RlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbW9kZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIHtAbGluayBMZXhlckFjdGlvblR5cGUjTU9ERX0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGFjdGlvblR5cGUoKTogTGV4ZXJBY3Rpb25UeXBlIHtcclxuXHRcdHJldHVybiBMZXhlckFjdGlvblR5cGUuTU9ERTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGFjdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBjYWxsaW5nIHtAbGluayBMZXhlciNtb2RlfSB3aXRoIHRoZVxyXG5cdCAqIHZhbHVlIHByb3ZpZGVkIGJ5IHtAbGluayAjZ2V0TW9kZX0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGV4ZWN1dGUoQE5vdE51bGwgbGV4ZXI6IExleGVyKTogdm9pZCB7XHJcblx0XHRsZXhlci5tb2RlKHRoaXMuX21vZGUpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKCk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5hY3Rpb25UeXBlKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLl9tb2RlKTtcclxuXHRcdHJldHVybiBNdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAyKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdGlmIChvYmogPT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgTGV4ZXJNb2RlQWN0aW9uKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX21vZGUgPT09IG9iai5fbW9kZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGBtb2RlKCR7dGhpcy5fbW9kZX0pYDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI5Ljk2MTMyMjEtMDc6MDBcclxuXHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL0xleGVyXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb25UeXBlIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25UeXBlXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIHRoZSBgbW9yZWAgbGV4ZXIgYWN0aW9uIGJ5IGNhbGxpbmcge0BsaW5rIExleGVyI21vcmV9LlxyXG4gKlxyXG4gKiBUaGUgYG1vcmVgIGNvbW1hbmQgZG9lcyBub3QgaGF2ZSBhbnkgcGFyYW1ldGVycywgc28gdGhpcyBhY3Rpb24gaXNcclxuICogaW1wbGVtZW50ZWQgYXMgYSBzaW5nbGV0b24gaW5zdGFuY2UgZXhwb3NlZCBieSB7QGxpbmsgI0lOU1RBTkNFfS5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKiBAc2luY2UgNC4yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGV4ZXJNb3JlQWN0aW9uIGltcGxlbWVudHMgTGV4ZXJBY3Rpb24ge1xyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgbGV4ZXIgYG1vcmVgIGNvbW1hbmQuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyB7QGxpbmsgTGV4ZXJBY3Rpb25UeXBlI01PUkV9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBhY3Rpb25UeXBlKCk6IExleGVyQWN0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gTGV4ZXJBY3Rpb25UeXBlLk1PUkU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpc1Bvc2l0aW9uRGVwZW5kZW50KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhpcyBhY3Rpb24gaXMgaW1wbGVtZW50ZWQgYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIjbW9yZX0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGV4ZWN1dGUoQE5vdE51bGwgbGV4ZXI6IExleGVyKTogdm9pZCB7XHJcblx0XHRsZXhlci5tb3JlKCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmFjdGlvblR5cGUpO1xyXG5cdFx0cmV0dXJuIE11cm11ckhhc2guZmluaXNoKGhhc2gsIDEpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIG9iaiA9PT0gdGhpcztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwibW9yZVwiO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IG5hbWVzcGFjZSBMZXhlck1vcmVBY3Rpb24ge1xyXG5cdC8qKlxyXG5cdCAqIFByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoaXMgcGFyYW1ldGVybGVzcyBsZXhlciBhY3Rpb24uXHJcblx0ICovXHJcblx0ZXhwb3J0IGNvbnN0IElOU1RBTkNFOiBMZXhlck1vcmVBY3Rpb24gPSBuZXcgTGV4ZXJNb3JlQWN0aW9uKCk7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjMwLjA0NDkyMjAtMDc6MDBcclxuXHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL0xleGVyXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb25UeXBlIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25UeXBlXCI7XHJcbmltcG9ydCB7IE11cm11ckhhc2ggfSBmcm9tIFwiLi4vbWlzYy9NdXJtdXJIYXNoXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIHRoZSBgcG9wTW9kZWAgbGV4ZXIgYWN0aW9uIGJ5IGNhbGxpbmcge0BsaW5rIExleGVyI3BvcE1vZGV9LlxyXG4gKlxyXG4gKiBUaGUgYHBvcE1vZGVgIGNvbW1hbmQgZG9lcyBub3QgaGF2ZSBhbnkgcGFyYW1ldGVycywgc28gdGhpcyBhY3Rpb24gaXNcclxuICogaW1wbGVtZW50ZWQgYXMgYSBzaW5nbGV0b24gaW5zdGFuY2UgZXhwb3NlZCBieSB7QGxpbmsgI0lOU1RBTkNFfS5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKiBAc2luY2UgNC4yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGV4ZXJQb3BNb2RlQWN0aW9uIGltcGxlbWVudHMgTGV4ZXJBY3Rpb24ge1xyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgbGV4ZXIgYHBvcE1vZGVgIGNvbW1hbmQuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICogQHJldHVybnMgVGhpcyBtZXRob2QgcmV0dXJucyB7QGxpbmsgTGV4ZXJBY3Rpb25UeXBlI1BPUF9NT0RFfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgYWN0aW9uVHlwZSgpOiBMZXhlckFjdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIExleGVyQWN0aW9uVHlwZS5QT1BfTU9ERTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGFjdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBjYWxsaW5nIHtAbGluayBMZXhlciNwb3BNb2RlfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXhlY3V0ZShATm90TnVsbCBsZXhlcjogTGV4ZXIpOiB2b2lkIHtcclxuXHRcdGxleGVyLnBvcE1vZGUoKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0bGV0IGhhc2g6IG51bWJlciA9IE11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuYWN0aW9uVHlwZSk7XHJcblx0XHRyZXR1cm4gTXVybXVySGFzaC5maW5pc2goaGFzaCwgMSk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXF1YWxzKG9iajogYW55KTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gb2JqID09PSB0aGlzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCJwb3BNb2RlXCI7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIExleGVyUG9wTW9kZUFjdGlvbiB7XHJcblx0LyoqXHJcblx0ICogUHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhpcyBwYXJhbWV0ZXJsZXNzIGxleGVyIGFjdGlvbi5cclxuXHQgKi9cclxuXHRleHBvcnQgY29uc3QgSU5TVEFOQ0U6IExleGVyUG9wTW9kZUFjdGlvbiA9IG5ldyBMZXhlclBvcE1vZGVBY3Rpb24oKTtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzAuMTM3ODgwMS0wNzowMFxyXG5cclxuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi4vTGV4ZXJcIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb24gfSBmcm9tIFwiLi9MZXhlckFjdGlvblwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvblR5cGUgfSBmcm9tIFwiLi9MZXhlckFjdGlvblR5cGVcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuLi9taXNjL011cm11ckhhc2hcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIGBwdXNoTW9kZWAgbGV4ZXIgYWN0aW9uIGJ5IGNhbGxpbmdcclxuICoge0BsaW5rIExleGVyI3B1c2hNb2RlfSB3aXRoIHRoZSBhc3NpZ25lZCBtb2RlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqIEBzaW5jZSA0LjJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMZXhlclB1c2hNb2RlQWN0aW9uIGltcGxlbWVudHMgTGV4ZXJBY3Rpb24ge1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgX21vZGU6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBgcHVzaE1vZGVgIGFjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbW9kZSB2YWx1ZS5cclxuXHQgKiBAcGFyYW0gbW9kZSBUaGUgbW9kZSB2YWx1ZSB0byBwYXNzIHRvIHtAbGluayBMZXhlciNwdXNoTW9kZX0uXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IobW9kZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLl9tb2RlID0gbW9kZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbGV4ZXIgbW9kZSB0aGlzIGFjdGlvbiBzaG91bGQgdHJhbnNpdGlvbiB0aGUgbGV4ZXIgdG8uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgbGV4ZXIgbW9kZSBmb3IgdGhpcyBgcHVzaE1vZGVgIGNvbW1hbmQuXHJcblx0ICovXHJcblx0Z2V0IG1vZGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9tb2RlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIHJldHVybnMge0BsaW5rIExleGVyQWN0aW9uVHlwZSNQVVNIX01PREV9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBhY3Rpb25UeXBlKCk6IExleGVyQWN0aW9uVHlwZSB7XHJcblx0XHRyZXR1cm4gTGV4ZXJBY3Rpb25UeXBlLlBVU0hfTU9ERTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKiBAcmV0dXJucyBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGlzIGFjdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBjYWxsaW5nIHtAbGluayBMZXhlciNwdXNoTW9kZX0gd2l0aCB0aGVcclxuXHQgKiB2YWx1ZSBwcm92aWRlZCBieSB7QGxpbmsgI2dldE1vZGV9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBleGVjdXRlKEBOb3ROdWxsIGxleGVyOiBMZXhlcik6IHZvaWQge1xyXG5cdFx0bGV4ZXIucHVzaE1vZGUodGhpcy5fbW9kZSk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmFjdGlvblR5cGUpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuX21vZGUpO1xyXG5cdFx0cmV0dXJuIE11cm11ckhhc2guZmluaXNoKGhhc2gsIDIpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG9iaiA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAoIShvYmogaW5zdGFuY2VvZiBMZXhlclB1c2hNb2RlQWN0aW9uKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX21vZGUgPT09IG9iai5fbW9kZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGBwdXNoTW9kZSgke3RoaXMuX21vZGV9KWA7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozMC4yMzI0NDYwLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvbiB9IGZyb20gXCIuL0xleGVyQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uVHlwZSB9IGZyb20gXCIuL0xleGVyQWN0aW9uVHlwZVwiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4uL21pc2MvTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyB0aGUgYHNraXBgIGxleGVyIGFjdGlvbiBieSBjYWxsaW5nIHtAbGluayBMZXhlciNza2lwfS5cclxuICpcclxuICogVGhlIGBza2lwYCBjb21tYW5kIGRvZXMgbm90IGhhdmUgYW55IHBhcmFtZXRlcnMsIHNvIHRoaXMgYWN0aW9uIGlzXHJcbiAqIGltcGxlbWVudGVkIGFzIGEgc2luZ2xldG9uIGluc3RhbmNlIGV4cG9zZWQgYnkge0BsaW5rICNJTlNUQU5DRX0uXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICogQHNpbmNlIDQuMlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExleGVyU2tpcEFjdGlvbiBpbXBsZW1lbnRzIExleGVyQWN0aW9uIHtcclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGxleGVyIGBza2lwYCBjb21tYW5kLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIHJldHVybnMge0BsaW5rIExleGVyQWN0aW9uVHlwZSNTS0lQfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgYWN0aW9uVHlwZSgpOiBMZXhlckFjdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIExleGVyQWN0aW9uVHlwZS5TS0lQO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaXNQb3NpdGlvbkRlcGVuZGVudCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoaXMgYWN0aW9uIGlzIGltcGxlbWVudGVkIGJ5IGNhbGxpbmcge0BsaW5rIExleGVyI3NraXB9LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBleGVjdXRlKEBOb3ROdWxsIGxleGVyOiBMZXhlcik6IHZvaWQge1xyXG5cdFx0bGV4ZXIuc2tpcCgpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGhhc2hDb2RlKCk6IG51bWJlciB7XHJcblx0XHRsZXQgaGFzaDogbnVtYmVyID0gTXVybXVySGFzaC5pbml0aWFsaXplKCk7XHJcblx0XHRoYXNoID0gTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5hY3Rpb25UeXBlKTtcclxuXHRcdHJldHVybiBNdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAxKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlcXVhbHMob2JqOiBhbnkpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBvYmogPT09IHRoaXM7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcInNraXBcIjtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgTGV4ZXJTa2lwQWN0aW9uIHtcclxuXHQvKipcclxuXHQgKiBQcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGlzIHBhcmFtZXRlcmxlc3MgbGV4ZXIgYWN0aW9uLlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBjb25zdCBJTlNUQU5DRTogTGV4ZXJTa2lwQWN0aW9uID0gbmV3IExleGVyU2tpcEFjdGlvbigpO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozMC4zMjA0ODM5LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMZXhlckFjdGlvbiB9IGZyb20gXCIuL0xleGVyQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uVHlwZSB9IGZyb20gXCIuL0xleGVyQWN0aW9uVHlwZVwiO1xyXG5pbXBvcnQgeyBNdXJtdXJIYXNoIH0gZnJvbSBcIi4uL21pc2MvTXVybXVySGFzaFwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyB0aGUgYHR5cGVgIGxleGVyIGFjdGlvbiBieSBzZXR0aW5nIGBMZXhlci50eXBlYFxyXG4gKiB3aXRoIHRoZSBhc3NpZ25lZCB0eXBlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqIEBzaW5jZSA0LjJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMZXhlclR5cGVBY3Rpb24gaW1wbGVtZW50cyBMZXhlckFjdGlvbiB7XHJcblx0cHJpdmF0ZSByZWFkb25seSBfdHlwZTogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGB0eXBlYCBhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHRva2VuIHR5cGUgdmFsdWUuXHJcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gYXNzaWduIHRvIHRoZSB0b2tlbiB1c2luZyBgTGV4ZXIudHlwZWAuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IodHlwZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHR5cGUgdG8gYXNzaWduIHRvIGEgdG9rZW4gY3JlYXRlZCBieSB0aGUgbGV4ZXIuXHJcblx0ICogQHJldHVybnMgVGhlIHR5cGUgdG8gYXNzaWduIHRvIGEgdG9rZW4gY3JlYXRlZCBieSB0aGUgbGV4ZXIuXHJcblx0ICovXHJcblx0Z2V0IHR5cGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl90eXBlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIHJldHVybnMge0BsaW5rIExleGVyQWN0aW9uVHlwZSNUWVBFfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgYWN0aW9uVHlwZSgpOiBMZXhlckFjdGlvblR5cGUge1xyXG5cdFx0cmV0dXJuIExleGVyQWN0aW9uVHlwZS5UWVBFO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaXNQb3NpdGlvbkRlcGVuZGVudCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoaXMgYWN0aW9uIGlzIGltcGxlbWVudGVkIGJ5IHNldHRpbmcgYExleGVyLnR5cGVgIHdpdGggdGhlXHJcblx0ICogdmFsdWUgcHJvdmlkZWQgYnkgYHR5cGVgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBleGVjdXRlKEBOb3ROdWxsIGxleGVyOiBMZXhlcik6IHZvaWQge1xyXG5cdFx0bGV4ZXIudHlwZSA9IHRoaXMuX3R5cGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaGFzaENvZGUoKTogbnVtYmVyIHtcclxuXHRcdGxldCBoYXNoOiBudW1iZXIgPSBNdXJtdXJIYXNoLmluaXRpYWxpemUoKTtcclxuXHRcdGhhc2ggPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmFjdGlvblR5cGUpO1xyXG5cdFx0aGFzaCA9IE11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuX3R5cGUpO1xyXG5cdFx0cmV0dXJuIE11cm11ckhhc2guZmluaXNoKGhhc2gsIDIpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG9iaiA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAoIShvYmogaW5zdGFuY2VvZiBMZXhlclR5cGVBY3Rpb24pKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gb2JqLl90eXBlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gYHR5cGUoJHt0aGlzLl90eXBlfSlgO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzAuNzczNzk3OC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZVR5cGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVR5cGVcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqIE1hcmsgdGhlIGVuZCBvZiBhICogb3IgKyBsb29wLiAqL1xyXG5leHBvcnQgY2xhc3MgTG9vcEVuZFN0YXRlIGV4dGVuZHMgQVROU3RhdGUge1xyXG5cdC8vIFRoaXMgaXMgYWx3YXlzIHNldCBkdXJpbmcgQVROIGRlc2VyaWFsaXphdGlvblxyXG5cdHB1YmxpYyBsb29wQmFja1N0YXRlITogQVROU3RhdGU7XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdGF0ZVR5cGUoKTogQVROU3RhdGVUeXBlIHtcclxuXHRcdHJldHVybiBBVE5TdGF0ZVR5cGUuTE9PUF9FTkQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOC4wNzEwMTMxLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBCaXRTZXQgfSBmcm9tIFwiLi4vbWlzYy9CaXRTZXRcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiLi4vbWlzYy9VdGlsc1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IGEgY29uZmlndXJhdGlvbiBjb25mbGljdC5cclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbmZsaWN0SW5mbyB7XHJcblx0cHJpdmF0ZSBfY29uZmxpY3RlZEFsdHM6IEJpdFNldDtcclxuXHJcblx0cHJpdmF0ZSBleGFjdDogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IoY29uZmxpY3RlZEFsdHM6IEJpdFNldCwgZXhhY3Q6IGJvb2xlYW4pIHtcclxuXHRcdHRoaXMuX2NvbmZsaWN0ZWRBbHRzID0gY29uZmxpY3RlZEFsdHM7XHJcblx0XHR0aGlzLmV4YWN0ID0gZXhhY3Q7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBzZXQgb2YgY29uZmxpY3RpbmcgYWx0ZXJuYXRpdmVzIGZvciB0aGUgY29uZmlndXJhdGlvbiBzZXQuXHJcblx0ICovXHJcblx0Z2V0IGNvbmZsaWN0ZWRBbHRzKCk6IEJpdFNldCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29uZmxpY3RlZEFsdHM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBjb25maWd1cmF0aW9uIGNvbmZsaWN0IGlzIGFuIGV4YWN0IGNvbmZsaWN0LlxyXG5cdCAqIEFuIGV4YWN0IGNvbmZsaWN0IG9jY3VycyB3aGVuIHRoZSBwcmVkaWN0aW9uIGFsZ29yaXRobSBkZXRlcm1pbmVzIHRoYXRcclxuXHQgKiB0aGUgcmVwcmVzZW50ZWQgYWx0ZXJuYXRpdmVzIGZvciBhIHBhcnRpY3VsYXIgY29uZmlndXJhdGlvbiBzZXQgY2Fubm90IGJlXHJcblx0ICogZnVydGhlciByZWR1Y2VkIGJ5IGNvbnN1bWluZyBhZGRpdGlvbmFsIGlucHV0LiBBZnRlciByZWFjaGluZyBhbiBleGFjdFxyXG5cdCAqIGNvbmZsaWN0IGR1cmluZyBhbiBTTEwgcHJlZGljdGlvbiwgb25seSBzd2l0Y2ggdG8gZnVsbC1jb250ZXh0IHByZWRpY3Rpb25cclxuXHQgKiBjb3VsZCByZWR1Y2UgdGhlIHNldCBvZiB2aWFibGUgYWx0ZXJuYXRpdmVzLiBJbiBMTCBwcmVkaWN0aW9uLCBhbiBleGFjdFxyXG5cdCAqIGNvbmZsaWN0IGluZGljYXRlcyBhIHRydWUgYW1iaWd1aXR5IGluIHRoZSBpbnB1dC5cclxuXHQgKlxyXG5cdCAqIEZvciB0aGUge0BsaW5rIFByZWRpY3Rpb25Nb2RlI0xMX0VYQUNUX0FNQklHX0RFVEVDVElPTn0gcHJlZGljdGlvbiBtb2RlLFxyXG5cdCAqIGFjY2VwdCBzdGF0ZXMgYXJlIGNvbmZsaWN0aW5nIGJ1dCBub3QgZXhhY3QgYXJlIHRyZWF0ZWQgYXMgbm9uLWFjY2VwdFxyXG5cdCAqIHN0YXRlcy5cclxuXHQgKi9cclxuXHRnZXQgaXNFeGFjdCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmV4YWN0O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG9iaiA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAoIShvYmogaW5zdGFuY2VvZiBDb25mbGljdEluZm8pKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5pc0V4YWN0ID09PSBvYmouaXNFeGFjdFxyXG5cdFx0XHQmJiBVdGlscy5lcXVhbHModGhpcy5jb25mbGljdGVkQWx0cywgb2JqLmNvbmZsaWN0ZWRBbHRzKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmxpY3RlZEFsdHMuaGFzaENvZGUoKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ4LjE0MzM2ODYtMDc6MDBcclxuXHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4uL21pc2MvSW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWVWaXNpdG9yIH0gZnJvbSBcIi4vUGFyc2VUcmVlVmlzaXRvclwiO1xyXG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCIuLi9SdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBSdWxlTm9kZSB9IGZyb20gXCIuL1J1bGVOb2RlXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4uL1Rva2VuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVGVybWluYWxOb2RlIGltcGxlbWVudHMgUGFyc2VUcmVlIHtcclxuXHRwdWJsaWMgX3N5bWJvbDogVG9rZW47XHJcblx0cHVibGljIF9wYXJlbnQ6IFJ1bGVOb2RlIHwgdW5kZWZpbmVkO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihzeW1ib2w6IFRva2VuKSB7XHJcblx0XHR0aGlzLl9zeW1ib2wgPSBzeW1ib2w7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0Q2hpbGQoaTogbnVtYmVyKTogbmV2ZXIge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXJtaW5hbCBOb2RlIGhhcyBubyBjaGlsZHJlbi5cIik7XHJcblx0fVxyXG5cclxuXHRnZXQgc3ltYm9sKCk6IFRva2VuIHtcclxuXHRcdHJldHVybiB0aGlzLl9zeW1ib2w7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgcGFyZW50KCk6IFJ1bGVOb2RlIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgc2V0UGFyZW50KHBhcmVudDogUnVsZUNvbnRleHQpOiB2b2lkIHtcclxuXHRcdHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBwYXlsb2FkKCk6IFRva2VuIHtcclxuXHRcdHJldHVybiB0aGlzLl9zeW1ib2w7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc291cmNlSW50ZXJ2YWwoKTogSW50ZXJ2YWwge1xyXG5cdFx0bGV0IHRva2VuSW5kZXg6IG51bWJlciA9IHRoaXMuX3N5bWJvbC50b2tlbkluZGV4O1xyXG5cdFx0cmV0dXJuIG5ldyBJbnRlcnZhbCh0b2tlbkluZGV4LCB0b2tlbkluZGV4KTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBjaGlsZENvdW50KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBhY2NlcHQ8VD4odmlzaXRvcjogUGFyc2VUcmVlVmlzaXRvcjxUPik6IFQge1xyXG5cdFx0cmV0dXJuIHZpc2l0b3IudmlzaXRUZXJtaW5hbCh0aGlzKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCB0ZXh0KCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc3ltYm9sLnRleHQgfHwgXCJcIjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZ1RyZWUocGFyc2VyPzogUGFyc2VyKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGlmICh0aGlzLl9zeW1ib2wudHlwZSA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdHJldHVybiBcIjxFT0Y+XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbC50ZXh0IHx8IFwiXCI7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0Ny40NjQ2MzU1LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZVZpc2l0b3IgfSBmcm9tIFwiLi9QYXJzZVRyZWVWaXNpdG9yXCI7XHJcbmltcG9ydCB7IFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuL1Rlcm1pbmFsTm9kZVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuLi9Ub2tlblwiO1xyXG5cclxuLyoqIFJlcHJlc2VudHMgYSB0b2tlbiB0aGF0IHdhcyBjb25zdW1lZCBkdXJpbmcgcmVzeW5jaHJvbml6YXRpb25cclxuICogIHJhdGhlciB0aGFuIGR1cmluZyBhIHZhbGlkIG1hdGNoIG9wZXJhdGlvbi4gRm9yIGV4YW1wbGUsXHJcbiAqICB3ZSB3aWxsIGNyZWF0ZSB0aGlzIGtpbmQgb2YgYSBub2RlIGR1cmluZyBzaW5nbGUgdG9rZW4gaW5zZXJ0aW9uXHJcbiAqICBhbmQgZGVsZXRpb24gYXMgd2VsbCBhcyBkdXJpbmcgXCJjb25zdW1lIHVudGlsIGVycm9yIHJlY292ZXJ5IHNldFwiXHJcbiAqICB1cG9uIG5vIHZpYWJsZSBhbHRlcm5hdGl2ZSBleGNlcHRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVycm9yTm9kZSBleHRlbmRzIFRlcm1pbmFsTm9kZSB7XHJcblx0Y29uc3RydWN0b3IodG9rZW46IFRva2VuKSB7XHJcblx0XHRzdXBlcih0b2tlbik7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgYWNjZXB0PFQ+KHZpc2l0b3I6IFBhcnNlVHJlZVZpc2l0b3I8VD4pOiBUIHtcclxuXHRcdHJldHVybiB2aXNpdG9yLnZpc2l0RXJyb3JOb2RlKHRoaXMpO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDcuOTIzMjc1Ni0wNzowMFxyXG5cclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlIH0gZnJvbSBcIi4vUGFyc2VUcmVlXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZVZpc2l0b3IgfSBmcm9tIFwiLi9QYXJzZVRyZWVWaXNpdG9yXCI7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuLi9QYXJzZXJcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJ1bGVOb2RlIGltcGxlbWVudHMgUGFyc2VUcmVlIHtcclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgcnVsZUNvbnRleHQ6IFJ1bGVDb250ZXh0O1xyXG5cclxuXHQvL0BPdmVycmlkZVxyXG5cdHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBwYXJlbnQ6IFJ1bGVOb2RlIHwgdW5kZWZpbmVkO1xyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3Qgc2V0UGFyZW50KHBhcmVudDogUnVsZUNvbnRleHQpOiB2b2lkO1xyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgZ2V0Q2hpbGQoaTogbnVtYmVyKTogUGFyc2VUcmVlO1xyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgYWNjZXB0PFQ+KHZpc2l0b3I6IFBhcnNlVHJlZVZpc2l0b3I8VD4pOiBUO1xyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgdGV4dDogc3RyaW5nO1xyXG5cclxuXHRwdWJsaWMgYWJzdHJhY3QgdG9TdHJpbmdUcmVlKHBhcnNlcj86IFBhcnNlciB8IHVuZGVmaW5lZCk6IHN0cmluZztcclxuXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHNvdXJjZUludGVydmFsOiBJbnRlcnZhbDtcclxuXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHBheWxvYWQ6IGFueTtcclxuXHJcblx0cHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGNoaWxkQ291bnQ6IG51bWJlcjtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDguMzE4Nzg2NS0wNzowMFxyXG5cclxuaW1wb3J0IHsgQXJyYXlzIH0gZnJvbSBcIi4uL21pc2MvQXJyYXlzXCI7XHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuLi9hdG4vQVROXCI7XHJcbmltcG9ydCB7IENvbW1vblRva2VuIH0gZnJvbSBcIi4uL0NvbW1vblRva2VuXCI7XHJcbmltcG9ydCB7IEVycm9yTm9kZSB9IGZyb20gXCIuL0Vycm9yTm9kZVwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4uL1BhcnNlclJ1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCIuLi9SdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBSdWxlTm9kZSB9IGZyb20gXCIuL1J1bGVOb2RlXCI7XHJcbmltcG9ydCB7IFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuL1Rlcm1pbmFsTm9kZVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBUcmVlIH0gZnJvbSBcIi4vVHJlZVwiO1xyXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiLi4vbWlzYy9VdGlsc1wiO1xyXG5cclxuLyoqIEEgc2V0IG9mIHV0aWxpdHkgcm91dGluZXMgdXNlZnVsIGZvciBhbGwga2luZHMgb2YgQU5UTFIgdHJlZXMuICovXHJcbmV4cG9ydCBjbGFzcyBUcmVlcyB7XHJcblx0LyoqIFByaW50IG91dCBhIHdob2xlIHRyZWUgaW4gTElTUCBmb3JtLiB7QGxpbmsgI2dldE5vZGVUZXh0fSBpcyB1c2VkIG9uIHRoZVxyXG5cdCAqICBub2RlIHBheWxvYWRzIHRvIGdldCB0aGUgdGV4dCBmb3IgdGhlIG5vZGVzLiAgRGV0ZWN0XHJcblx0ICogIHBhcnNlIHRyZWVzIGFuZCBleHRyYWN0IGRhdGEgYXBwcm9wcmlhdGVseS5cclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIHRvU3RyaW5nVHJlZSgvKkBOb3ROdWxsKi8gdDogVHJlZSk6IHN0cmluZztcclxuXHJcblx0LyoqIFByaW50IG91dCBhIHdob2xlIHRyZWUgaW4gTElTUCBmb3JtLiB7QGxpbmsgI2dldE5vZGVUZXh0fSBpcyB1c2VkIG9uIHRoZVxyXG5cdCAqICBub2RlIHBheWxvYWRzIHRvIGdldCB0aGUgdGV4dCBmb3IgdGhlIG5vZGVzLiAgRGV0ZWN0XHJcblx0ICogIHBhcnNlIHRyZWVzIGFuZCBleHRyYWN0IGRhdGEgYXBwcm9wcmlhdGVseS5cclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIHRvU3RyaW5nVHJlZSgvKkBOb3ROdWxsKi8gdDogVHJlZSwgcmVjb2c6IFBhcnNlciB8IHVuZGVmaW5lZCk6IHN0cmluZztcclxuXHJcblx0LyoqIFByaW50IG91dCBhIHdob2xlIHRyZWUgaW4gTElTUCBmb3JtLiB7QGxpbmsgI2dldE5vZGVUZXh0fSBpcyB1c2VkIG9uIHRoZVxyXG5cdCAqICBub2RlIHBheWxvYWRzIHRvIGdldCB0aGUgdGV4dCBmb3IgdGhlIG5vZGVzLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgdG9TdHJpbmdUcmVlKC8qQE5vdE51bGwqLyB0OiBUcmVlLCAvKkBOdWxsYWJsZSovIHJ1bGVOYW1lczogc3RyaW5nW10gfCB1bmRlZmluZWQpOiBzdHJpbmc7XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgdG9TdHJpbmdUcmVlKC8qQE5vdE51bGwqLyB0OiBUcmVlLCBhcmcyPzogUGFyc2VyIHwgc3RyaW5nW10pOiBzdHJpbmc7XHJcblx0cHVibGljIHN0YXRpYyB0b1N0cmluZ1RyZWUoQE5vdE51bGwgdDogVHJlZSwgYXJnMj86IFBhcnNlciB8IHN0cmluZ1tdKTogc3RyaW5nIHtcclxuXHRcdGxldCBydWxlTmFtZXM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xyXG5cdFx0aWYgKGFyZzIgaW5zdGFuY2VvZiBQYXJzZXIpIHtcclxuXHRcdFx0cnVsZU5hbWVzID0gYXJnMi5ydWxlTmFtZXM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRydWxlTmFtZXMgPSBhcmcyO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBzOiBzdHJpbmcgPSBVdGlscy5lc2NhcGVXaGl0ZXNwYWNlKHRoaXMuZ2V0Tm9kZVRleHQodCwgcnVsZU5hbWVzKSwgZmFsc2UpO1xyXG5cdFx0aWYgKHQuY2hpbGRDb3VudCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gcztcclxuXHRcdH1cclxuXHRcdGxldCBidWYgPSBcIlwiO1xyXG5cdFx0YnVmICs9IChcIihcIik7XHJcblx0XHRzID0gVXRpbHMuZXNjYXBlV2hpdGVzcGFjZSh0aGlzLmdldE5vZGVUZXh0KHQsIHJ1bGVOYW1lcyksIGZhbHNlKTtcclxuXHRcdGJ1ZiArPSAocyk7XHJcblx0XHRidWYgKz0gKFwiIFwiKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdC5jaGlsZENvdW50OyBpKyspIHtcclxuXHRcdFx0aWYgKGkgPiAwKSB7XHJcblx0XHRcdFx0YnVmICs9IChcIiBcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0YnVmICs9ICh0aGlzLnRvU3RyaW5nVHJlZSh0LmdldENoaWxkKGkpLCBydWxlTmFtZXMpKTtcclxuXHRcdH1cclxuXHRcdGJ1ZiArPSAoXCIpXCIpO1xyXG5cdFx0cmV0dXJuIGJ1ZjtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZ2V0Tm9kZVRleHQoLypATm90TnVsbCovIHQ6IFRyZWUsIHJlY29nOiBQYXJzZXIgfCB1bmRlZmluZWQpOiBzdHJpbmc7XHJcblx0cHVibGljIHN0YXRpYyBnZXROb2RlVGV4dCgvKkBOb3ROdWxsKi8gdDogVHJlZSwgcnVsZU5hbWVzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCk6IHN0cmluZztcclxuXHRwdWJsaWMgc3RhdGljIGdldE5vZGVUZXh0KHQ6IFRyZWUsIGFyZzI6IFBhcnNlciB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcclxuXHRcdGxldCBydWxlTmFtZXM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xyXG5cdFx0aWYgKGFyZzIgaW5zdGFuY2VvZiBQYXJzZXIpIHtcclxuXHRcdFx0cnVsZU5hbWVzID0gYXJnMi5ydWxlTmFtZXM7XHJcblx0XHR9IGVsc2UgaWYgKGFyZzIpIHtcclxuXHRcdFx0cnVsZU5hbWVzID0gYXJnMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIG5vIHJlY29nIG9yIHJ1bGUgbmFtZXNcclxuXHRcdFx0bGV0IHBheWxvYWQgPSB0LnBheWxvYWQ7XHJcblx0XHRcdGlmICh0eXBlb2YgcGF5bG9hZC50ZXh0ID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBheWxvYWQudGV4dDtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdC5wYXlsb2FkLnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHQgaW5zdGFuY2VvZiBSdWxlTm9kZSkge1xyXG5cdFx0XHRsZXQgcnVsZUNvbnRleHQ6IFJ1bGVDb250ZXh0ID0gdC5ydWxlQ29udGV4dDtcclxuXHRcdFx0bGV0IHJ1bGVJbmRleDogbnVtYmVyID0gcnVsZUNvbnRleHQucnVsZUluZGV4O1xyXG5cdFx0XHRsZXQgcnVsZU5hbWU6IHN0cmluZyA9IHJ1bGVOYW1lc1tydWxlSW5kZXhdO1xyXG5cdFx0XHRsZXQgYWx0TnVtYmVyOiBudW1iZXIgPSBydWxlQ29udGV4dC5hbHROdW1iZXI7XHJcblx0XHRcdGlmIChhbHROdW1iZXIgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuXHRcdFx0XHRyZXR1cm4gcnVsZU5hbWUgKyBcIjpcIiArIGFsdE51bWJlcjtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcnVsZU5hbWU7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmICh0IGluc3RhbmNlb2YgRXJyb3JOb2RlKSB7XHJcblx0XHRcdHJldHVybiB0LnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmICh0IGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XHJcblx0XHRcdGxldCBzeW1ib2wgPSB0LnN5bWJvbDtcclxuXHRcdFx0cmV0dXJuIHN5bWJvbC50ZXh0IHx8IFwiXCI7XHJcblx0XHR9XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBub2RlIHR5cGVcIik7XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIG9yZGVyZWQgbGlzdCBvZiBhbGwgY2hpbGRyZW4gb2YgdGhpcyBub2RlICovXHJcblx0cHVibGljIHN0YXRpYyBnZXRDaGlsZHJlbih0OiBQYXJzZVRyZWUpOiBQYXJzZVRyZWVbXTtcclxuXHRwdWJsaWMgc3RhdGljIGdldENoaWxkcmVuKHQ6IFRyZWUpOiBUcmVlW107XHJcblx0cHVibGljIHN0YXRpYyBnZXRDaGlsZHJlbih0OiBUcmVlKTogVHJlZVtdIHtcclxuXHRcdGxldCBraWRzOiBUcmVlW10gPSBbXTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdC5jaGlsZENvdW50OyBpKyspIHtcclxuXHRcdFx0a2lkcy5wdXNoKHQuZ2V0Q2hpbGQoaSkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGtpZHM7XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIGEgbGlzdCBvZiBhbGwgYW5jZXN0b3JzIG9mIHRoaXMgbm9kZS4gIFRoZSBmaXJzdCBub2RlIG9mXHJcblx0ICogIGxpc3QgaXMgdGhlIHJvb3QgYW5kIHRoZSBsYXN0IGlzIHRoZSBwYXJlbnQgb2YgdGhpcyBub2RlLlxyXG5cdCAqXHJcblx0ICogIEBzaW5jZSA0LjUuMVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgZ2V0QW5jZXN0b3JzKHQ6IFBhcnNlVHJlZSk6IFBhcnNlVHJlZVtdO1xyXG5cdHB1YmxpYyBzdGF0aWMgZ2V0QW5jZXN0b3JzKHQ6IFRyZWUpOiBUcmVlW107XHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgc3RhdGljIGdldEFuY2VzdG9ycyhATm90TnVsbCB0OiBUcmVlKTogVHJlZVtdIHtcclxuXHRcdGxldCBhbmNlc3RvcnM6IFRyZWVbXSA9IFtdO1xyXG5cdFx0bGV0IHAgPSB0LnBhcmVudDtcclxuXHRcdHdoaWxlIChwKSB7XHJcblx0XHRcdGFuY2VzdG9ycy51bnNoaWZ0KHApOyAvLyBpbnNlcnQgYXQgc3RhcnRcclxuXHRcdFx0cCA9IHAucGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFuY2VzdG9ycztcclxuXHR9XHJcblxyXG5cdC8qKiBSZXR1cm4gdHJ1ZSBpZiB0IGlzIHUncyBwYXJlbnQgb3IgYSBub2RlIG9uIHBhdGggdG8gcm9vdCBmcm9tIHUuXHJcblx0ICogIFVzZSA9PT0gbm90IGVxdWFscygpLlxyXG5cdCAqXHJcblx0ICogIEBzaW5jZSA0LjUuMVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGF0aWMgaXNBbmNlc3Rvck9mKHQ6IFRyZWUsIHU6IFRyZWUpOiBib29sZWFuIHtcclxuXHRcdGlmICghdCB8fCAhdSB8fCAhdC5wYXJlbnQpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0bGV0IHAgPSB1LnBhcmVudDtcclxuXHRcdHdoaWxlIChwKSB7XHJcblx0XHRcdGlmICh0ID09PSBwKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0cCA9IHAucGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHN0YXRpYyBmaW5kQWxsVG9rZW5Ob2Rlcyh0OiBQYXJzZVRyZWUsIHR0eXBlOiBudW1iZXIpOiBQYXJzZVRyZWVbXSB7XHJcblx0XHRyZXR1cm4gVHJlZXMuZmluZEFsbE5vZGVzKHQsIHR0eXBlLCB0cnVlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZmluZEFsbFJ1bGVOb2Rlcyh0OiBQYXJzZVRyZWUsIHJ1bGVJbmRleDogbnVtYmVyKTogUGFyc2VUcmVlW10ge1xyXG5cdFx0cmV0dXJuIFRyZWVzLmZpbmRBbGxOb2Rlcyh0LCBydWxlSW5kZXgsIGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZmluZEFsbE5vZGVzKHQ6IFBhcnNlVHJlZSwgaW5kZXg6IG51bWJlciwgZmluZFRva2VuczogYm9vbGVhbik6IFBhcnNlVHJlZVtdIHtcclxuXHRcdGxldCBub2RlczogUGFyc2VUcmVlW10gPSBbXTtcclxuXHRcdFRyZWVzLl9maW5kQWxsTm9kZXModCwgaW5kZXgsIGZpbmRUb2tlbnMsIG5vZGVzKTtcclxuXHRcdHJldHVybiBub2RlcztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgX2ZpbmRBbGxOb2Rlcyh0OiBQYXJzZVRyZWUsIGluZGV4OiBudW1iZXIsIGZpbmRUb2tlbnM6IGJvb2xlYW4sIG5vZGVzOiBQYXJzZVRyZWVbXSk6IHZvaWQge1xyXG5cdFx0Ly8gY2hlY2sgdGhpcyBub2RlICh0aGUgcm9vdCkgZmlyc3RcclxuXHRcdGlmIChmaW5kVG9rZW5zICYmIHQgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcclxuXHRcdFx0aWYgKHQuc3ltYm9sLnR5cGUgPT09IGluZGV4KSB7XHJcblx0XHRcdFx0bm9kZXMucHVzaCh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoIWZpbmRUb2tlbnMgJiYgdCBpbnN0YW5jZW9mIFBhcnNlclJ1bGVDb250ZXh0KSB7XHJcblx0XHRcdGlmICh0LnJ1bGVJbmRleCA9PT0gaW5kZXgpIHtcclxuXHRcdFx0XHRub2Rlcy5wdXNoKHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyBjaGVjayBjaGlsZHJlblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0LmNoaWxkQ291bnQ7IGkrKykge1xyXG5cdFx0XHRUcmVlcy5fZmluZEFsbE5vZGVzKHQuZ2V0Q2hpbGQoaSksIGluZGV4LCBmaW5kVG9rZW5zLCBub2Rlcyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogR2V0IGFsbCBkZXNjZW5kZW50czsgaW5jbHVkZXMgdCBpdHNlbGYuXHJcblx0ICpcclxuXHQgKiBAc2luY2UgNC41LjFcclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIGdldERlc2NlbmRhbnRzKHQ6IFBhcnNlVHJlZSk6IFBhcnNlVHJlZVtdIHtcclxuXHRcdGxldCBub2RlczogUGFyc2VUcmVlW10gPSBbXTtcclxuXHJcblx0XHRmdW5jdGlvbiByZWN1cnNlKGU6IFBhcnNlVHJlZSk6IHZvaWQge1xyXG5cdFx0XHRub2Rlcy5wdXNoKGUpO1xyXG5cdFx0XHRjb25zdCBuID0gZS5jaGlsZENvdW50O1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRcdHJlY3Vyc2UoZS5nZXRDaGlsZChpKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZWN1cnNlKHQpO1xyXG5cdFx0cmV0dXJuIG5vZGVzO1xyXG5cdH1cclxuXHJcblx0LyoqIEZpbmQgc21hbGxlc3Qgc3VidHJlZSBvZiB0IGVuY2xvc2luZyByYW5nZSBzdGFydFRva2VuSW5kZXguLnN0b3BUb2tlbkluZGV4XHJcblx0ICogIGluY2x1c2l2ZWx5IHVzaW5nIHBvc3RvcmRlciB0cmF2ZXJzYWwuICBSZWN1cnNpdmUgZGVwdGgtZmlyc3Qtc2VhcmNoLlxyXG5cdCAqXHJcblx0ICogIEBzaW5jZSA0LjVcclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIGdldFJvb3RPZlN1YnRyZWVFbmNsb3NpbmdSZWdpb24oXHJcblx0XHRATm90TnVsbCB0OiBQYXJzZVRyZWUsXHJcblx0XHRzdGFydFRva2VuSW5kZXg6IG51bWJlciwgLy8gaW5jbHVzaXZlXHJcblx0XHRzdG9wVG9rZW5JbmRleDogbnVtYmVyLCAvLyBpbmNsdXNpdmVcclxuXHQpOiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCB7XHJcblx0XHRsZXQgbjogbnVtYmVyID0gdC5jaGlsZENvdW50O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0bGV0IGNoaWxkOiBQYXJzZVRyZWUgPSB0LmdldENoaWxkKGkpO1xyXG5cdFx0XHRsZXQgciA9IFRyZWVzLmdldFJvb3RPZlN1YnRyZWVFbmNsb3NpbmdSZWdpb24oY2hpbGQsIHN0YXJ0VG9rZW5JbmRleCwgc3RvcFRva2VuSW5kZXgpO1xyXG5cdFx0XHRpZiAocikge1xyXG5cdFx0XHRcdHJldHVybiByO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAodCBpbnN0YW5jZW9mIFBhcnNlclJ1bGVDb250ZXh0KSB7XHJcblx0XHRcdGxldCBzdG9wVG9rZW4gPSB0LnN0b3A7XHJcblx0XHRcdGlmIChzdGFydFRva2VuSW5kZXggPj0gdC5zdGFydC50b2tlbkluZGV4ICYmIC8vIGlzIHJhbmdlIGZ1bGx5IGNvbnRhaW5lZCBpbiB0P1xyXG5cdFx0XHRcdChzdG9wVG9rZW4gPT0gbnVsbCB8fCBzdG9wVG9rZW5JbmRleCA8PSBzdG9wVG9rZW4udG9rZW5JbmRleCkpIHtcclxuXHRcdFx0XHQvLyBub3RlOiByLnN0b3A9PW51bGwgbGlrZWx5IGltcGxpZXMgdGhhdCB3ZSBiYWlsZWQgb3V0IG9mIHBhcnNlciBhbmQgdGhlcmUncyBub3RoaW5nIHRvIHRoZSByaWdodFxyXG5cdFx0XHRcdHJldHVybiB0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlcGxhY2UgYW55IHN1YnRyZWUgc2libGluZ3Mgb2Ygcm9vdCB0aGF0IGFyZSBjb21wbGV0ZWx5IHRvIGxlZnRcclxuXHQgKiAgb3IgcmlnaHQgb2YgbG9va2FoZWFkIHJhbmdlIHdpdGggYSBDb21tb25Ub2tlbihUb2tlbi5JTlZBTElEX1RZUEUsXCIuLi5cIilcclxuXHQgKiAgbm9kZS4gVGhlIHNvdXJjZSBpbnRlcnZhbCBmb3IgdCBpcyBub3QgYWx0ZXJlZCB0byBzdWl0IHNtYWxsZXIgcmFuZ2UhXHJcblx0ICpcclxuXHQgKiAgV0FSTklORzogZGVzdHJ1Y3RpdmUgdG8gdC5cclxuXHQgKlxyXG5cdCAqICBAc2luY2UgNC41LjFcclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIHN0cmlwQ2hpbGRyZW5PdXRPZlJhbmdlKFxyXG5cdFx0dDogUGFyc2VyUnVsZUNvbnRleHQsXHJcblx0XHRyb290OiBQYXJzZXJSdWxlQ29udGV4dCxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAoIXQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGNvdW50ID0gdC5jaGlsZENvdW50O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcblx0XHRcdGxldCBjaGlsZCA9IHQuZ2V0Q2hpbGQoaSk7XHJcblx0XHRcdGxldCByYW5nZTogSW50ZXJ2YWwgPSBjaGlsZC5zb3VyY2VJbnRlcnZhbDtcclxuXHRcdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgUGFyc2VyUnVsZUNvbnRleHQgJiYgKHJhbmdlLmIgPCBzdGFydEluZGV4IHx8IHJhbmdlLmEgPiBzdG9wSW5kZXgpKSB7XHJcblx0XHRcdFx0aWYgKFRyZWVzLmlzQW5jZXN0b3JPZihjaGlsZCwgcm9vdCkpIHsgLy8gcmVwbGFjZSBvbmx5IGlmIHN1YnRyZWUgZG9lc24ndCBoYXZlIGRpc3BsYXllZCByb290XHJcblx0XHRcdFx0XHRsZXQgYWJicmV2OiBDb21tb25Ub2tlbiA9IG5ldyBDb21tb25Ub2tlbihUb2tlbi5JTlZBTElEX1RZUEUsIFwiLi4uXCIpO1xyXG5cdFx0XHRcdFx0dC5jaGlsZHJlbiFbaV0gPSBuZXcgVGVybWluYWxOb2RlKGFiYnJldik7IC8vIEhBQ0sgYWNjZXNzIHRvIHByaXZhdGVcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBSZXR1cm4gZmlyc3Qgbm9kZSBzYXRpc2Z5aW5nIHRoZSBwcmVkXHJcblx0ICpcclxuXHQgKiAgQHNpbmNlIDQuNS4xXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyBmaW5kTm9kZVN1Y2hUaGF0KHQ6IFBhcnNlVHJlZSwgcHJlZDogKHRyZWU6IFBhcnNlVHJlZSkgPT4gYm9vbGVhbik6IFBhcnNlVHJlZSB8IHVuZGVmaW5lZDtcclxuXHRwdWJsaWMgc3RhdGljIGZpbmROb2RlU3VjaFRoYXQodDogVHJlZSwgcHJlZDogKHRyZWU6IFRyZWUpID0+IGJvb2xlYW4pOiBUcmVlIHwgdW5kZWZpbmVkO1xyXG5cdHB1YmxpYyBzdGF0aWMgZmluZE5vZGVTdWNoVGhhdCh0OiBUcmVlLCBwcmVkOiAodHJlZTogUGFyc2VUcmVlKSA9PiBib29sZWFuKTogVHJlZSB8IHVuZGVmaW5lZCB7XHJcblx0XHQvLyBObyB0eXBlIGNoZWNrIG5lZWRlZCBhcyBsb25nIGFzIHVzZXJzIG9ubHkgdXNlIG9uZSBvZiB0aGUgYXZhaWxhYmxlIG92ZXJsb2Fkc1xyXG5cdFx0aWYgKHByZWQodCBhcyBQYXJzZVRyZWUpKSB7XHJcblx0XHRcdHJldHVybiB0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBuOiBudW1iZXIgPSAgdC5jaGlsZENvdW50O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDAgOyBpIDwgbiA7IGkrKyl7XHJcblx0XHRcdGxldCB1ID0gVHJlZXMuZmluZE5vZGVTdWNoVGhhdCh0LmdldENoaWxkKGkpLCBwcmVkIGFzICh0cmVlOiBUcmVlKSA9PiBib29sZWFuKTtcclxuXHRcdFx0aWYgKHUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHJldHVybiB1O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU3LjM0OTA4MzctMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuL2F0bi9BVE5cIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFJ1bGVOb2RlIH0gZnJvbSBcIi4vdHJlZS9SdWxlTm9kZVwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWUgfSBmcm9tIFwiLi90cmVlL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFRyZWVzIH0gZnJvbSBcIi4vdHJlZS9UcmVlc1wiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWVWaXNpdG9yIH0gZnJvbSBcIi4vdHJlZS9QYXJzZVRyZWVWaXNpdG9yXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuXHJcbi8qKiBBIHJ1bGUgY29udGV4dCBpcyBhIHJlY29yZCBvZiBhIHNpbmdsZSBydWxlIGludm9jYXRpb24uXHJcbiAqXHJcbiAqICBXZSBmb3JtIGEgc3RhY2sgb2YgdGhlc2UgY29udGV4dCBvYmplY3RzIHVzaW5nIHRoZSBwYXJlbnRcclxuICogIHBvaW50ZXIuIEEgcGFyZW50IHBvaW50ZXIgb2YgYHVuZGVmaW5lZGAgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnRcclxuICogIGNvbnRleHQgaXMgdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2suIFRoZSBQYXJzZXJSdWxlQ29udGV4dCBzdWJjbGFzc1xyXG4gKiAgYXMgYSBjaGlsZHJlbiBsaXN0IHNvIHRoYXQgd2UgY2FuIHR1cm4gdGhpcyBkYXRhIHN0cnVjdHVyZSBpbnRvIGFcclxuICogIHRyZWUuXHJcbiAqXHJcbiAqICBUaGUgcm9vdCBub2RlIGFsd2F5cyBoYXMgYSBgdW5kZWZpbmVkYCBwb2ludGVyIGFuZCBpbnZva2luZ1N0YXRlIG9mIC0xLlxyXG4gKlxyXG4gKiAgVXBvbiBlbnRyeSB0byBwYXJzaW5nLCB0aGUgZmlyc3QgaW52b2tlZCBydWxlIGZ1bmN0aW9uIGNyZWF0ZXMgYVxyXG4gKiAgY29udGV4dCBvYmplY3QgKGEgc3ViY2xhc3Mgc3BlY2lhbGl6ZWQgZm9yIHRoYXQgcnVsZSBzdWNoIGFzXHJcbiAqICBTQ29udGV4dCkgYW5kIG1ha2VzIGl0IHRoZSByb290IG9mIGEgcGFyc2UgdHJlZSwgcmVjb3JkZWQgYnkgZmllbGRcclxuICogIFBhcnNlci5fY3R4LlxyXG4gKlxyXG4gKiAgcHVibGljIGZpbmFsIFNDb250ZXh0IHMoKSB0aHJvd3MgUmVjb2duaXRpb25FeGNlcHRpb24ge1xyXG4gKiAgICAgIFNDb250ZXh0IF9sb2NhbGN0eCA9IG5ldyBTQ29udGV4dChfY3R4LCBzdGF0ZSk7IDwtLSBjcmVhdGUgbmV3IG5vZGVcclxuICogICAgICBlbnRlclJ1bGUoX2xvY2FsY3R4LCAwLCBSVUxFX3MpOyAgICAgICAgICAgICAgICAgICAgIDwtLSBwdXNoIGl0XHJcbiAqICAgICAgLi4uXHJcbiAqICAgICAgZXhpdFJ1bGUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0gcG9wIGJhY2sgdG8gX2xvY2FsY3R4XHJcbiAqICAgICAgcmV0dXJuIF9sb2NhbGN0eDtcclxuICogIH1cclxuICpcclxuICogIEEgc3Vic2VxdWVudCBydWxlIGludm9jYXRpb24gb2YgciBmcm9tIHRoZSBzdGFydCBydWxlIHMgcHVzaGVzIGFcclxuICogIG5ldyBjb250ZXh0IG9iamVjdCBmb3IgciB3aG9zZSBwYXJlbnQgcG9pbnRzIGF0IHMgYW5kIHVzZSBpbnZva2luZ1xyXG4gKiAgc3RhdGUgaXMgdGhlIHN0YXRlIHdpdGggciBlbWFuYXRpbmcgYXMgZWRnZSBsYWJlbC5cclxuICpcclxuICogIFRoZSBpbnZva2luZ1N0YXRlIGZpZWxkcyBmcm9tIGEgY29udGV4dCBvYmplY3QgdG8gdGhlIHJvb3RcclxuICogIHRvZ2V0aGVyIGZvcm0gYSBzdGFjayBvZiBydWxlIGluZGljYXRpb24gc3RhdGVzIHdoZXJlIHRoZSByb290XHJcbiAqICAoYm90dG9tIG9mIHRoZSBzdGFjaykgaGFzIGEgLTEgc2VudGluZWwgdmFsdWUuIElmIHdlIGludm9rZSBzdGFydFxyXG4gKiAgc3ltYm9sIHMgdGhlbiBjYWxsIHIxLCB3aGljaCBjYWxscyByMiwgdGhlICB3b3VsZCBsb29rIGxpa2VcclxuICogIHRoaXM6XHJcbiAqXHJcbiAqICAgICBTQ29udGV4dFstMV0gICA8LSByb290IG5vZGUgKGJvdHRvbSBvZiB0aGUgc3RhY2spXHJcbiAqICAgICBSMUNvbnRleHRbcF0gICA8LSBwIGluIHJ1bGUgcyBjYWxsZWQgcjFcclxuICogICAgIFIyQ29udGV4dFtxXSAgIDwtIHEgaW4gcnVsZSByMSBjYWxsZWQgcjJcclxuICpcclxuICogIFNvIHRoZSB0b3Agb2YgdGhlIHN0YWNrLCBfY3R4LCByZXByZXNlbnRzIGEgY2FsbCB0byB0aGUgY3VycmVudFxyXG4gKiAgcnVsZSBhbmQgaXQgaG9sZHMgdGhlIHJldHVybiBhZGRyZXNzIGZyb20gYW5vdGhlciBydWxlIHRoYXQgaW52b2tlXHJcbiAqICB0byB0aGlzIHJ1bGUuIFRvIGludm9rZSBhIHJ1bGUsIHdlIG11c3QgYWx3YXlzIGhhdmUgYSBjdXJyZW50IGNvbnRleHQuXHJcbiAqXHJcbiAqICBUaGUgcGFyZW50IGNvbnRleHRzIGFyZSB1c2VmdWwgZm9yIGNvbXB1dGluZyBsb29rYWhlYWQgc2V0cyBhbmRcclxuICogIGdldHRpbmcgZXJyb3IgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqICBUaGVzZSBvYmplY3RzIGFyZSB1c2VkIGR1cmluZyBwYXJzaW5nIGFuZCBwcmVkaWN0aW9uLlxyXG4gKiAgRm9yIHRoZSBzcGVjaWFsIGNhc2Ugb2YgcGFyc2Vycywgd2UgdXNlIHRoZSBzdWJjbGFzc1xyXG4gKiAgUGFyc2VyUnVsZUNvbnRleHQuXHJcbiAqXHJcbiAqICBAc2VlIFBhcnNlclJ1bGVDb250ZXh0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUNvbnRleHQgZXh0ZW5kcyBSdWxlTm9kZSB7XHJcblx0cHVibGljIF9wYXJlbnQ6IFJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkO1xyXG5cdHB1YmxpYyBpbnZva2luZ1N0YXRlOiBudW1iZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCk7XHJcblx0Y29uc3RydWN0b3IocGFyZW50OiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgaW52b2tpbmdTdGF0ZTogbnVtYmVyKTtcclxuXHRjb25zdHJ1Y3RvcihwYXJlbnQ/OiBSdWxlQ29udGV4dCwgaW52b2tpbmdTdGF0ZT86IG51bWJlcikge1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuXHRcdHRoaXMuaW52b2tpbmdTdGF0ZSA9IGludm9raW5nU3RhdGUgIT0gbnVsbCA/IGludm9raW5nU3RhdGUgOiAtMTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZ2V0Q2hpbGRDb250ZXh0KHBhcmVudDogUnVsZUNvbnRleHQsIGludm9raW5nU3RhdGU6IG51bWJlcik6IFJ1bGVDb250ZXh0IHtcclxuXHRcdHJldHVybiBuZXcgUnVsZUNvbnRleHQocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBkZXB0aCgpOiBudW1iZXIge1xyXG5cdFx0bGV0IG4gPSAwO1xyXG5cdFx0bGV0IHA6IFJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkID0gdGhpcztcclxuXHRcdHdoaWxlIChwKSB7XHJcblx0XHRcdHAgPSBwLl9wYXJlbnQ7XHJcblx0XHRcdG4rKztcclxuXHRcdH1cclxuXHRcdHJldHVybiBuO1xyXG5cdH1cclxuXHJcblx0LyoqIEEgY29udGV4dCBpcyBlbXB0eSBpZiB0aGVyZSBpcyBubyBpbnZva2luZyBzdGF0ZTsgbWVhbmluZyBub2JvZHkgY2FsbGVkXHJcblx0ICogIGN1cnJlbnQgY29udGV4dC5cclxuXHQgKi9cclxuXHRnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9raW5nU3RhdGUgPT09IC0xO1xyXG5cdH1cclxuXHJcblx0Ly8gc2F0aXNmeSB0aGUgUGFyc2VUcmVlIC8gU3ludGF4VHJlZSBpbnRlcmZhY2VcclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNvdXJjZUludGVydmFsKCk6IEludGVydmFsIHtcclxuXHRcdHJldHVybiBJbnRlcnZhbC5JTlZBTElEO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHJ1bGVDb250ZXh0KCk6IFJ1bGVDb250ZXh0IHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHBhcmVudCgpOiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCB7IHJldHVybiB0aGlzLl9wYXJlbnQ7IH1cclxuXHJcblx0LyoqIEBzaW5jZSA0LjcuIHtAc2VlIFBhcnNlVHJlZSNzZXRQYXJlbnR9IGNvbW1lbnQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgc2V0UGFyZW50KHBhcmVudDogUnVsZUNvbnRleHQpOiB2b2lkIHtcclxuXHRcdHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBwYXlsb2FkKCk6IFJ1bGVDb250ZXh0IHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0LyoqIFJldHVybiB0aGUgY29tYmluZWQgdGV4dCBvZiBhbGwgY2hpbGQgbm9kZXMuIFRoaXMgbWV0aG9kIG9ubHkgY29uc2lkZXJzXHJcblx0ICogIHRva2VucyB3aGljaCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIHBhcnNlIHRyZWUuXHJcblx0ICpcclxuXHQgKiAgU2luY2UgdG9rZW5zIG9uIGhpZGRlbiBjaGFubmVscyAoZS5nLiB3aGl0ZXNwYWNlIG9yIGNvbW1lbnRzKSBhcmUgbm90XHJcblx0ICogIGFkZGVkIHRvIHRoZSBwYXJzZSB0cmVlcywgdGhleSB3aWxsIG5vdCBhcHBlYXIgaW4gdGhlIG91dHB1dCBvZiB0aGlzXHJcblx0ICogIG1ldGhvZC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgdGV4dCgpOiBzdHJpbmcge1xyXG5cdFx0aWYgKHRoaXMuY2hpbGRDb3VudCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYnVpbGRlciA9IFwiXCI7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRDb3VudDsgaSsrKSB7XHJcblx0XHRcdGJ1aWxkZXIgKz0gdGhpcy5nZXRDaGlsZChpKS50ZXh0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBidWlsZGVyLnRvU3RyaW5nKCk7XHJcblx0fVxyXG5cclxuXHRnZXQgcnVsZUluZGV4KCk6IG51bWJlciB7IHJldHVybiAtMTsgfVxyXG5cclxuXHQvKiogRm9yIHJ1bGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcGFyc2UgdHJlZSBpbnRlcm5hbCBub2RlLCByZXR1cm5cclxuXHQgKiAgdGhlIG91dGVyIGFsdGVybmF0aXZlIG51bWJlciB1c2VkIHRvIG1hdGNoIHRoZSBpbnB1dC4gRGVmYXVsdFxyXG5cdCAqICBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBjb21wdXRlIG5vciBzdG9yZSB0aGlzIGFsdCBudW0uIENyZWF0ZVxyXG5cdCAqICBhIHN1YmNsYXNzIG9mIFBhcnNlclJ1bGVDb250ZXh0IHdpdGggYmFja2luZyBmaWVsZCBhbmQgc2V0XHJcblx0ICogIG9wdGlvbiBjb250ZXh0U3VwZXJDbGFzcy5cclxuXHQgKiAgdG8gc2V0IGl0LlxyXG5cdCAqXHJcblx0ICogIEBzaW5jZSA0LjUuM1xyXG5cdCAqL1xyXG5cdGdldCBhbHROdW1iZXIoKTogbnVtYmVyIHsgcmV0dXJuIEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7IH1cclxuXHJcblx0LyoqIFNldCB0aGUgb3V0ZXIgYWx0ZXJuYXRpdmUgbnVtYmVyIGZvciB0aGlzIGNvbnRleHQgbm9kZS4gRGVmYXVsdFxyXG5cdCAqICBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdGhpbmcgdG8gYXZvaWQgYmFja2luZyBmaWVsZCBvdmVyaGVhZCBmb3JcclxuXHQgKiAgdHJlZXMgdGhhdCBkb24ndCBuZWVkIGl0LiAgQ3JlYXRlXHJcblx0ICogIGEgc3ViY2xhc3Mgb2YgUGFyc2VyUnVsZUNvbnRleHQgd2l0aCBiYWNraW5nIGZpZWxkIGFuZCBzZXRcclxuXHQgKiAgb3B0aW9uIGNvbnRleHRTdXBlckNsYXNzLlxyXG5cdCAqXHJcblx0ICogIEBzaW5jZSA0LjUuM1xyXG5cdCAqL1xyXG5cdHNldCBhbHROdW1iZXIoYWx0TnVtYmVyOiBudW1iZXIpIHtcclxuXHRcdC8vIGludGVudGlvbmFsbHkgaWdub3JlZCBieSB0aGUgYmFzZSBpbXBsZW1lbnRhdGlvblxyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGdldENoaWxkKGk6IG51bWJlcik6IFBhcnNlVHJlZSB7XHJcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImkgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBhbmQgbGVzcyB0aGFuIGNoaWxkQ291bnRcIik7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgY2hpbGRDb3VudCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgYWNjZXB0PFQ+KHZpc2l0b3I6IFBhcnNlVHJlZVZpc2l0b3I8VD4pOiBUIHtcclxuXHRcdHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcblx0fVxyXG5cclxuXHQvKiogUHJpbnQgb3V0IGEgd2hvbGUgdHJlZSwgbm90IGp1c3QgYSBub2RlLCBpbiBMSVNQIGZvcm1hdFxyXG5cdCAqICAocm9vdCBjaGlsZDEgLi4gY2hpbGROKS4gUHJpbnQganVzdCBhIG5vZGUgaWYgdGhpcyBpcyBhIGxlYWYuXHJcblx0ICogIFdlIGhhdmUgdG8ga25vdyB0aGUgcmVjb2duaXplciBzbyB3ZSBjYW4gZ2V0IHJ1bGUgbmFtZXMuXHJcblx0ICovXHJcblx0cHVibGljIHRvU3RyaW5nVHJlZShyZWNvZzogUGFyc2VyKTogc3RyaW5nO1xyXG5cclxuXHQvKiogUHJpbnQgb3V0IGEgd2hvbGUgdHJlZSwgbm90IGp1c3QgYSBub2RlLCBpbiBMSVNQIGZvcm1hdFxyXG5cdCAqICAocm9vdCBjaGlsZDEgLi4gY2hpbGROKS4gUHJpbnQganVzdCBhIG5vZGUgaWYgdGhpcyBpcyBhIGxlYWYuXHJcblx0ICovXHJcblx0cHVibGljIHRvU3RyaW5nVHJlZShydWxlTmFtZXM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkKTogc3RyaW5nO1xyXG5cclxuXHRwdWJsaWMgdG9TdHJpbmdUcmVlKCk6IHN0cmluZztcclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nVHJlZShyZWNvZz86IFBhcnNlciB8IHN0cmluZ1tdKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBUcmVlcy50b1N0cmluZ1RyZWUodGhpcywgcmVjb2cpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZztcclxuXHRwdWJsaWMgdG9TdHJpbmcocmVjb2c6IFJlY29nbml6ZXI8YW55LCBhbnk+IHwgdW5kZWZpbmVkKTogc3RyaW5nO1xyXG5cdHB1YmxpYyB0b1N0cmluZyhydWxlTmFtZXM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkKTogc3RyaW5nO1xyXG5cclxuXHQvLyAvLyByZWNvZyB1bmRlZmluZWQgdW5sZXNzIFBhcnNlclJ1bGVDb250ZXh0LCBpbiB3aGljaCBjYXNlIHdlIHVzZSBzdWJjbGFzcyB0b1N0cmluZyguLi4pXHJcblx0cHVibGljIHRvU3RyaW5nKHJlY29nOiBSZWNvZ25pemVyPGFueSwgYW55PiB8IHVuZGVmaW5lZCwgc3RvcDogUnVsZUNvbnRleHQgfCB1bmRlZmluZWQpOiBzdHJpbmc7XHJcblxyXG5cdHB1YmxpYyB0b1N0cmluZyhydWxlTmFtZXM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkLCBzdG9wOiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCk6IHN0cmluZztcclxuXHJcblx0cHVibGljIHRvU3RyaW5nKFxyXG5cdFx0YXJnMT86IFJlY29nbml6ZXI8YW55LCBhbnk+IHwgc3RyaW5nW10sXHJcblx0XHRzdG9wPzogUnVsZUNvbnRleHQpXHJcblx0XHQ6IHN0cmluZyB7XHJcblx0XHRjb25zdCBydWxlTmFtZXMgPSAoYXJnMSBpbnN0YW5jZW9mIFJlY29nbml6ZXIpID8gYXJnMS5ydWxlTmFtZXMgOiBhcmcxO1xyXG5cdFx0c3RvcCA9IHN0b3AgfHwgUGFyc2VyUnVsZUNvbnRleHQuZW1wdHlDb250ZXh0KCk7XHJcblxyXG5cdFx0bGV0IGJ1ZiA9IFwiXCI7XHJcblx0XHRsZXQgcDogUnVsZUNvbnRleHQgfCB1bmRlZmluZWQgPSB0aGlzO1xyXG5cdFx0YnVmICs9IChcIltcIik7XHJcblx0XHR3aGlsZSAocCAmJiBwICE9PSBzdG9wKSB7XHJcblx0XHRcdGlmICghcnVsZU5hbWVzKSB7XHJcblx0XHRcdFx0aWYgKCFwLmlzRW1wdHkpIHtcclxuXHRcdFx0XHRcdGJ1ZiArPSAocC5pbnZva2luZ1N0YXRlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IHJ1bGVJbmRleDogbnVtYmVyID0gcC5ydWxlSW5kZXg7XHJcblx0XHRcdFx0bGV0IHJ1bGVOYW1lOiBzdHJpbmcgPSAocnVsZUluZGV4ID49IDAgJiYgcnVsZUluZGV4IDwgcnVsZU5hbWVzLmxlbmd0aClcclxuXHRcdFx0XHRcdD8gcnVsZU5hbWVzW3J1bGVJbmRleF0gOiBydWxlSW5kZXgudG9TdHJpbmcoKTtcclxuXHRcdFx0XHRidWYgKz0gKHJ1bGVOYW1lKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHAuX3BhcmVudCAmJiAocnVsZU5hbWVzIHx8ICFwLl9wYXJlbnQuaXNFbXB0eSkpIHtcclxuXHRcdFx0XHRidWYgKz0gKFwiIFwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cCA9IHAuX3BhcmVudDtcclxuXHRcdH1cclxuXHJcblx0XHRidWYgKz0gKFwiXVwiKTtcclxuXHRcdHJldHVybiBidWYudG9TdHJpbmcoKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU2LjYyODU0OTQtMDc6MDBcclxuaW1wb3J0IHsgRXJyb3JOb2RlIH0gZnJvbSBcIi4vdHJlZS9FcnJvck5vZGVcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi9QYXJzZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlIH0gZnJvbSBcIi4vdHJlZS9QYXJzZVRyZWVcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlTGlzdGVuZXIgfSBmcm9tIFwiLi90cmVlL1BhcnNlVHJlZUxpc3RlbmVyXCI7XHJcbmltcG9ydCB7IFJlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4vUmVjb2duaXRpb25FeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9SdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBUZXJtaW5hbE5vZGUgfSBmcm9tIFwiLi90cmVlL1Rlcm1pbmFsTm9kZVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcblxyXG4vKiogQSBydWxlIGludm9jYXRpb24gcmVjb3JkIGZvciBwYXJzaW5nLlxyXG4gKlxyXG4gKiAgQ29udGFpbnMgYWxsIG9mIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBydWxlIG5vdCBzdG9yZWQgaW4gdGhlXHJcbiAqICBSdWxlQ29udGV4dC4gSXQgaGFuZGxlcyBwYXJzZSB0cmVlIGNoaWxkcmVuIGxpc3QsIEFueSBBVE4gc3RhdGVcclxuICogIHRyYWNpbmcsIGFuZCB0aGUgZGVmYXVsdCB2YWx1ZXMgYXZhaWxhYmxlIGZvciBydWxlIGludm9jYXRpb25zOlxyXG4gKiAgc3RhcnQsIHN0b3AsIHJ1bGUgaW5kZXgsIGN1cnJlbnQgYWx0IG51bWJlci5cclxuICpcclxuICogIFN1YmNsYXNzZXMgbWFkZSBmb3IgZWFjaCBydWxlIGFuZCBncmFtbWFyIHRyYWNrIHRoZSBwYXJhbWV0ZXJzLFxyXG4gKiAgcmV0dXJuIHZhbHVlcywgbG9jYWxzLCBhbmQgbGFiZWxzIHNwZWNpZmljIHRvIHRoYXQgcnVsZS4gVGhlc2VcclxuICogIGFyZSB0aGUgb2JqZWN0cyB0aGF0IGFyZSByZXR1cm5lZCBmcm9tIHJ1bGVzLlxyXG4gKlxyXG4gKiAgTm90ZSB0ZXh0IGlzIG5vdCBhbiBhY3R1YWwgZmllbGQgb2YgYSBydWxlIHJldHVybiB2YWx1ZTsgaXQgaXMgY29tcHV0ZWRcclxuICogIGZyb20gc3RhcnQgYW5kIHN0b3AgdXNpbmcgdGhlIGlucHV0IHN0cmVhbSdzIHRvU3RyaW5nKCkgbWV0aG9kLiAgSVxyXG4gKiAgY291bGQgYWRkIGEgY3RvciB0byB0aGlzIHNvIHRoYXQgd2UgY2FuIHBhc3MgaW4gYW5kIHN0b3JlIHRoZSBpbnB1dFxyXG4gKiAgc3RyZWFtLCBidXQgSSdtIG5vdCBzdXJlIHdlIHdhbnQgdG8gZG8gdGhhdC4gIEl0IHdvdWxkIHNlZW0gdG8gYmUgdW5kZWZpbmVkXHJcbiAqICB0byBnZXQgdGhlIC50ZXh0IHByb3BlcnR5IGFueXdheSBpZiB0aGUgcnVsZSBtYXRjaGVzIHRva2VucyBmcm9tIG11bHRpcGxlXHJcbiAqICBpbnB1dCBzdHJlYW1zLlxyXG4gKlxyXG4gKiAgSSBkbyBub3QgdXNlIGdldHRlcnMgZm9yIGZpZWxkcyBvZiBvYmplY3RzIHRoYXQgYXJlIHVzZWQgc2ltcGx5IHRvXHJcbiAqICBncm91cCB2YWx1ZXMgc3VjaCBhcyB0aGlzIGFnZ3JlZ2F0ZS4gIFRoZSBnZXR0ZXJzL3NldHRlcnMgYXJlIHRoZXJlIHRvXHJcbiAqICBzYXRpc2Z5IHRoZSBzdXBlcmNsYXNzIGludGVyZmFjZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQYXJzZXJSdWxlQ29udGV4dCBleHRlbmRzIFJ1bGVDb250ZXh0IHtcclxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBFTVBUWTogUGFyc2VyUnVsZUNvbnRleHQgPSBuZXcgUGFyc2VyUnVsZUNvbnRleHQoKTtcclxuXHJcblx0LyoqIElmIHdlIGFyZSBkZWJ1Z2dpbmcgb3IgYnVpbGRpbmcgYSBwYXJzZSB0cmVlIGZvciBhIHZpc2l0b3IsXHJcblx0ICogIHdlIG5lZWQgdG8gdHJhY2sgYWxsIG9mIHRoZSB0b2tlbnMgYW5kIHJ1bGUgaW52b2NhdGlvbnMgYXNzb2NpYXRlZFxyXG5cdCAqICB3aXRoIHRoaXMgcnVsZSdzIGNvbnRleHQuIFRoaXMgaXMgZW1wdHkgZm9yIHBhcnNpbmcgdy9vIHRyZWUgY29uc3RyLlxyXG5cdCAqICBvcGVyYXRpb24gYmVjYXVzZSB3ZSBkb24ndCB0aGUgbmVlZCB0byB0cmFjayB0aGUgZGV0YWlscyBhYm91dFxyXG5cdCAqICBob3cgd2UgcGFyc2UgdGhpcyBydWxlLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjaGlsZHJlbj86IFBhcnNlVHJlZVtdO1xyXG5cclxuXHQvKiogRm9yIGRlYnVnZ2luZy90cmFjaW5nIHB1cnBvc2VzLCB3ZSB3YW50IHRvIHRyYWNrIGFsbCBvZiB0aGUgbm9kZXMgaW5cclxuXHQgKiAgdGhlIEFUTiB0cmF2ZXJzZWQgYnkgdGhlIHBhcnNlciBmb3IgYSBwYXJ0aWN1bGFyIHJ1bGUuXHJcblx0ICogIFRoaXMgbGlzdCBpbmRpY2F0ZXMgdGhlIHNlcXVlbmNlIG9mIEFUTiBub2RlcyB1c2VkIHRvIG1hdGNoXHJcblx0ICogIHRoZSBlbGVtZW50cyBvZiB0aGUgY2hpbGRyZW4gbGlzdC4gVGhpcyBsaXN0IGRvZXMgbm90IGluY2x1ZGVcclxuXHQgKiAgQVROIG5vZGVzIGFuZCBvdGhlciBydWxlcyB1c2VkIHRvIG1hdGNoIHJ1bGUgaW52b2NhdGlvbnMuIEl0XHJcblx0ICogIHRyYWNlcyB0aGUgcnVsZSBpbnZvY2F0aW9uIG5vZGUgaXRzZWxmIGJ1dCBub3RoaW5nIGluc2lkZSB0aGF0XHJcblx0ICogIG90aGVyIHJ1bGUncyBBVE4gc3VibWFjaGluZS5cclxuXHQgKlxyXG5cdCAqICBUaGVyZSBpcyBOT1QgYSBvbmUtdG8tb25lIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gdGhlIGNoaWxkcmVuIGFuZFxyXG5cdCAqICBzdGF0ZXMgbGlzdC4gVGhlcmUgYXJlIHR5cGljYWxseSBtYW55IG5vZGVzIGluIHRoZSBBVE4gdHJhdmVyc2VkXHJcblx0ICogIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGNoaWxkcmVuIGxpc3QuIEZvciBleGFtcGxlLCBmb3IgYSBydWxlXHJcblx0ICogIGludm9jYXRpb24gdGhlcmUgaXMgdGhlIGludm9raW5nIHN0YXRlIGFuZCB0aGUgZm9sbG93aW5nIHN0YXRlLlxyXG5cdCAqXHJcblx0ICogIFRoZSBwYXJzZXIgc3RhdGUgcHJvcGVydHkgdXBkYXRlcyBmaWVsZCBzIGFuZCBhZGRzIGl0IHRvIHRoaXMgbGlzdFxyXG5cdCAqICBpZiB3ZSBhcmUgZGVidWdnaW5nL3RyYWNpbmcuXHJcblx0ICpcclxuXHQgKiAgVGhpcyBkb2VzIG5vdCB0cmFjZSBzdGF0ZXMgdmlzaXRlZCBkdXJpbmcgcHJlZGljdGlvbi5cclxuXHQgKi9cclxuLy9cdHB1YmxpYyBBcnJheTxudW1iZXI+IHN0YXRlcztcclxuXHJcblx0cHVibGljIF9zdGFydCE6IFRva2VuO1xyXG5cdHB1YmxpYyBfc3RvcDogVG9rZW4gfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBleGNlcHRpb24gdGhhdCBmb3JjZWQgdGhpcyBydWxlIHRvIHJldHVybi4gSWYgdGhlIHJ1bGUgc3VjY2Vzc2Z1bGx5XHJcblx0ICogY29tcGxldGVkLCB0aGlzIGlzIGB1bmRlZmluZWRgLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBleGNlcHRpb24/OiBSZWNvZ25pdGlvbkV4Y2VwdGlvbjtcclxuXHJcblx0Y29uc3RydWN0b3IoKTtcclxuXHRjb25zdHJ1Y3RvcihwYXJlbnQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLCBpbnZva2luZ1N0YXRlTnVtYmVyOiBudW1iZXIpO1xyXG5cdGNvbnN0cnVjdG9yKHBhcmVudD86IFBhcnNlclJ1bGVDb250ZXh0LCBpbnZva2luZ1N0YXRlTnVtYmVyPzogbnVtYmVyKSB7XHJcblx0XHRpZiAoaW52b2tpbmdTdGF0ZU51bWJlciA9PSBudWxsKSB7XHJcblx0XHRcdHN1cGVyKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGVOdW1iZXIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIHN0YXRpYyBlbXB0eUNvbnRleHQoKTogUGFyc2VyUnVsZUNvbnRleHQge1xyXG5cdFx0cmV0dXJuIFBhcnNlclJ1bGVDb250ZXh0LkVNUFRZO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ09QWSBhIGN0eCAoSSdtIGRlbGliZXJhdGVseSBub3QgdXNpbmcgY29weSBjb25zdHJ1Y3RvcikgdG8gYXZvaWRcclxuXHQgKiBjb25mdXNpb24gd2l0aCBjcmVhdGluZyBub2RlIHdpdGggcGFyZW50LiBEb2VzIG5vdCBjb3B5IGNoaWxkcmVuXHJcblx0ICogKGV4Y2VwdCBlcnJvciBsZWF2ZXMpLlxyXG5cdCAqXHJcblx0ICogVGhpcyBpcyB1c2VkIGluIHRoZSBnZW5lcmF0ZWQgcGFyc2VyIGNvZGUgdG8gZmxpcCBhIGdlbmVyaWMgWENvbnRleHRcclxuXHQgKiBub2RlIGZvciBydWxlIFggdG8gYSBZQ29udGV4dCBmb3IgYWx0IGxhYmVsIFkuIEluIHRoYXQgc2Vuc2UsIGl0IGlzIG5vdFxyXG5cdCAqIHJlYWxseSBhIGdlbmVyaWMgY29weSBmdW5jdGlvbi5cclxuXHQgKlxyXG5cdCAqIElmIHdlIGRvIGFuIGVycm9yIHN5bmMoKSBhdCBzdGFydCBvZiBhIHJ1bGUsIHdlIG1pZ2h0IGFkZCBlcnJvciBub2Rlc1xyXG5cdCAqIHRvIHRoZSBnZW5lcmljIFhDb250ZXh0IHNvIHRoaXMgZnVuY3Rpb24gbXVzdCBjb3B5IHRob3NlIG5vZGVzIHRvIHRoZVxyXG5cdCAqIFlDb250ZXh0IGFzIHdlbGwgZWxzZSB0aGV5IGFyZSBsb3N0IVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjb3B5RnJvbShjdHg6IFBhcnNlclJ1bGVDb250ZXh0KTogdm9pZCB7XHJcblx0XHR0aGlzLl9wYXJlbnQgPSBjdHguX3BhcmVudDtcclxuXHRcdHRoaXMuaW52b2tpbmdTdGF0ZSA9IGN0eC5pbnZva2luZ1N0YXRlO1xyXG5cclxuXHRcdHRoaXMuX3N0YXJ0ID0gY3R4Ll9zdGFydDtcclxuXHRcdHRoaXMuX3N0b3AgPSBjdHguX3N0b3A7XHJcblxyXG5cdFx0Ly8gY29weSBhbnkgZXJyb3Igbm9kZXMgdG8gYWx0IGxhYmVsIG5vZGVcclxuXHRcdGlmIChjdHguY2hpbGRyZW4pIHtcclxuXHRcdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0XHQvLyByZXNldCBwYXJlbnQgcG9pbnRlciBmb3IgYW55IGVycm9yIG5vZGVzXHJcblx0XHRcdGZvciAobGV0IGNoaWxkIG9mIGN0eC5jaGlsZHJlbikge1xyXG5cdFx0XHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIEVycm9yTm9kZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5hZGRDaGlsZChjaGlsZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBEb3VibGUgZGlzcGF0Y2ggbWV0aG9kcyBmb3IgbGlzdGVuZXJzXHJcblxyXG5cdHB1YmxpYyBlbnRlclJ1bGUobGlzdGVuZXI6IFBhcnNlVHJlZUxpc3RlbmVyKTogdm9pZCB7XHJcblx0XHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcblx0fVxyXG5cdHB1YmxpYyBleGl0UnVsZShsaXN0ZW5lcjogUGFyc2VUcmVlTGlzdGVuZXIpOiB2b2lkIHtcclxuXHRcdC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuXHR9XHJcblxyXG5cdC8qKiBBZGQgYSBwYXJzZSB0cmVlIG5vZGUgdG8gdGhpcyBhcyBhIGNoaWxkLiAgV29ya3MgZm9yXHJcblx0ICogIGludGVybmFsIGFuZCBsZWFmIG5vZGVzLiBEb2VzIG5vdCBzZXQgcGFyZW50IGxpbms7XHJcblx0ICogIG90aGVyIGFkZCBtZXRob2RzIG11c3QgZG8gdGhhdC4gT3RoZXIgYWRkQ2hpbGQgbWV0aG9kc1xyXG5cdCAqICBjYWxsIHRoaXMuXHJcblx0ICpcclxuXHQgKiAgV2UgY2Fubm90IHNldCB0aGUgcGFyZW50IHBvaW50ZXIgb2YgdGhlIGluY29taW5nIG5vZGVcclxuXHQgKiAgYmVjYXVzZSB0aGUgZXhpc3RpbmcgaW50ZXJmYWNlcyBkbyBub3QgaGF2ZSBhIHNldFBhcmVudCgpXHJcblx0ICogIG1ldGhvZCBhbmQgSSBkb24ndCB3YW50IHRvIGJyZWFrIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIHRoaXMuXHJcblx0ICpcclxuXHQgKiAgQHNpbmNlIDQuN1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBhZGRBbnlDaGlsZDxUIGV4dGVuZHMgUGFyc2VUcmVlPih0OiBUKTogVCB7XHJcblx0XHRpZiAoIXRoaXMuY2hpbGRyZW4pIHtcclxuXHRcdFx0dGhpcy5jaGlsZHJlbiA9IFt0XTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCh0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdDtcclxuXHR9XHJcblxyXG5cdC8qKiBBZGQgYSB0b2tlbiBsZWFmIG5vZGUgY2hpbGQgYW5kIGZvcmNlIGl0cyBwYXJlbnQgdG8gYmUgdGhpcyBub2RlLiAqL1xyXG5cdHB1YmxpYyBhZGRDaGlsZCh0OiBUZXJtaW5hbE5vZGUpOiB2b2lkO1xyXG5cdHB1YmxpYyBhZGRDaGlsZChydWxlSW52b2NhdGlvbjogUnVsZUNvbnRleHQpOiB2b2lkO1xyXG5cdC8qKlxyXG5cdCAqIEFkZCBhIGNoaWxkIHRvIHRoaXMgbm9kZSBiYXNlZCB1cG9uIG1hdGNoZWRUb2tlbi4gSXRcclxuXHQgKiBjcmVhdGVzIGEgVGVybWluYWxOb2RlSW1wbCByYXRoZXIgdGhhbiB1c2luZ1xyXG5cdCAqIHtAbGluayBQYXJzZXIjY3JlYXRlVGVybWluYWxOb2RlKFBhcnNlclJ1bGVDb250ZXh0LCBUb2tlbil9LiBJJ20gbGVhdmluZyB0aGlzXHJcblx0ICogaW4gZm9yIGNvbXBhdGliaWxpdHkgYnV0IHRoZSBwYXJzZXIgZG9lc24ndCB1c2UgdGhpcyBhbnltb3JlLlxyXG5cdCAqXHJcblx0ICogQGRlcHJlY2F0ZWQgVXNlIGFub3RoZXIgb3ZlcmxvYWQgaW5zdGVhZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgYWRkQ2hpbGQobWF0Y2hlZFRva2VuOiBUb2tlbik6IFRlcm1pbmFsTm9kZTtcclxuXHRwdWJsaWMgYWRkQ2hpbGQodDogVGVybWluYWxOb2RlIHwgUnVsZUNvbnRleHQgfCBUb2tlbik6IFRlcm1pbmFsTm9kZSB8IHZvaWQge1xyXG5cdFx0bGV0IHJlc3VsdDogVGVybWluYWxOb2RlIHwgdm9pZDtcclxuXHRcdGlmICh0IGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XHJcblx0XHRcdHQuc2V0UGFyZW50KHRoaXMpO1xyXG5cdFx0XHR0aGlzLmFkZEFueUNoaWxkKHQpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9IGVsc2UgaWYgKHQgaW5zdGFuY2VvZiBSdWxlQ29udGV4dCkge1xyXG5cdFx0XHQvLyBEb2VzIG5vdCBzZXQgcGFyZW50IGxpbmtcclxuXHRcdFx0dGhpcy5hZGRBbnlDaGlsZCh0KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gRGVwcmVjYXRlZCBjb2RlIHBhdGhcclxuXHRcdFx0dCA9IG5ldyBUZXJtaW5hbE5vZGUodCk7XHJcblx0XHRcdHRoaXMuYWRkQW55Q2hpbGQodCk7XHJcblx0XHRcdHQuc2V0UGFyZW50KHRoaXMpO1xyXG5cdFx0XHRyZXR1cm4gdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBBZGQgYW4gZXJyb3Igbm9kZSBjaGlsZCBhbmQgZm9yY2UgaXRzIHBhcmVudCB0byBiZSB0aGlzIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAc2luY2UgNC43XHJcblx0ICovXHJcblx0cHVibGljIGFkZEVycm9yTm9kZShlcnJvck5vZGU6IEVycm9yTm9kZSk6IEVycm9yTm9kZTtcclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGEgY2hpbGQgdG8gdGhpcyBub2RlIGJhc2VkIHVwb24gYmFkVG9rZW4uIEl0XHJcblx0ICogY3JlYXRlcyBhIEVycm9yTm9kZSByYXRoZXIgdGhhbiB1c2luZ1xyXG5cdCAqIHtAbGluayBQYXJzZXIjY3JlYXRlRXJyb3JOb2RlKFBhcnNlclJ1bGVDb250ZXh0LCBUb2tlbil9LiBJJ20gbGVhdmluZyB0aGlzXHJcblx0ICogaW4gZm9yIGNvbXBhdGliaWxpdHkgYnV0IHRoZSBwYXJzZXIgZG9lc24ndCB1c2UgdGhpcyBhbnltb3JlLlxyXG5cdCAqXHJcblx0ICogQGRlcHJlY2F0ZWQgVXNlIGFub3RoZXIgb3ZlcmxvYWQgaW5zdGVhZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgYWRkRXJyb3JOb2RlKGJhZFRva2VuOiBUb2tlbik6IEVycm9yTm9kZTtcclxuXHRwdWJsaWMgYWRkRXJyb3JOb2RlKG5vZGU6IEVycm9yTm9kZSB8IFRva2VuKTogRXJyb3JOb2RlIHtcclxuXHRcdGlmIChub2RlIGluc3RhbmNlb2YgRXJyb3JOb2RlKSB7XHJcblx0XHRcdGNvbnN0IGVycm9yTm9kZTogRXJyb3JOb2RlID0gbm9kZTtcclxuXHRcdFx0ZXJyb3JOb2RlLnNldFBhcmVudCh0aGlzKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQW55Q2hpbGQoZXJyb3JOb2RlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGRlcHJlY2F0ZWQgcGF0aFxyXG5cdFx0XHRjb25zdCBiYWRUb2tlbjogVG9rZW4gPSBub2RlO1xyXG5cdFx0XHRsZXQgdCA9IG5ldyBFcnJvck5vZGUoYmFkVG9rZW4pO1xyXG5cdFx0XHR0aGlzLmFkZEFueUNoaWxkKHQpO1xyXG5cdFx0XHR0LnNldFBhcmVudCh0aGlzKTtcclxuXHRcdFx0cmV0dXJuIHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuLy9cdHB1YmxpYyB2b2lkIHRyYWNlKGludCBzKSB7XHJcbi8vXHRcdGlmICggc3RhdGVzPT1udWxsICkgc3RhdGVzID0gbmV3IEFycmF5TGlzdDxJbnRlZ2VyPigpO1xyXG4vL1x0XHRzdGF0ZXMuYWRkKHMpO1xyXG4vL1x0fVxyXG5cclxuXHQvKiogVXNlZCBieSBlbnRlck91dGVyQWx0IHRvIHRvc3Mgb3V0IGEgUnVsZUNvbnRleHQgcHJldmlvdXNseSBhZGRlZCBhc1xyXG5cdCAqICB3ZSBlbnRlcmVkIGEgcnVsZS4gSWYgd2UgaGF2ZSAjIGxhYmVsLCB3ZSB3aWxsIG5lZWQgdG8gcmVtb3ZlXHJcblx0ICogIGdlbmVyaWMgcnVsZUNvbnRleHQgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyByZW1vdmVMYXN0Q2hpbGQoKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5jaGlsZHJlbikge1xyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnBvcCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0LyoqIE92ZXJyaWRlIHRvIG1ha2UgdHlwZSBtb3JlIHNwZWNpZmljICovXHJcblx0Z2V0IHBhcmVudCgpOiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCB7XHJcblx0XHRsZXQgcGFyZW50ID0gc3VwZXIucGFyZW50O1xyXG5cdFx0aWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IHBhcmVudCBpbnN0YW5jZW9mIFBhcnNlclJ1bGVDb250ZXh0KSB7XHJcblx0XHRcdHJldHVybiBwYXJlbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgcGFyZW50IHR5cGUgZm9yIFBhcnNlclJ1bGVDb250ZXh0XCIpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldENoaWxkKGk6IG51bWJlcik6IFBhcnNlVHJlZTtcclxuXHRwdWJsaWMgZ2V0Q2hpbGQ8VCBleHRlbmRzIFBhcnNlVHJlZT4oaTogbnVtYmVyLCBjdHhUeXBlOiB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUOyB9KTogVDtcclxuXHQvLyBOb3RlOiBpbiBUeXBlU2NyaXB0LCBvcmRlciBvciBhcmd1bWVudHMgcmV2ZXJzZWRcclxuXHRwdWJsaWMgZ2V0Q2hpbGQ8VCBleHRlbmRzIFBhcnNlVHJlZT4oaTogbnVtYmVyLCBjdHhUeXBlPzogeyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVDsgfSk6IFBhcnNlVHJlZSB7XHJcblx0XHRpZiAoIXRoaXMuY2hpbGRyZW4gfHwgaSA8IDAgfHwgaSA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluZGV4IHBhcmFtZXRlciBtdXN0IGJlIGJldHdlZW4gPj0gMCBhbmQgPD0gbnVtYmVyIG9mIGNoaWxkcmVuLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY3R4VHlwZSA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZXN1bHQgPSB0aGlzLnRyeUdldENoaWxkKGksIGN0eFR5cGUpO1xyXG5cdFx0aWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSBzcGVjaWZpZWQgbm9kZSBkb2VzIG5vdCBleGlzdFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRyeUdldENoaWxkPFQgZXh0ZW5kcyBQYXJzZVRyZWU+KGk6IG51bWJlciwgY3R4VHlwZTogeyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVDsgfSk6IFQgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKCF0aGlzLmNoaWxkcmVuIHx8IGkgPCAwIHx8IGkgPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgajogbnVtYmVyID0gLTE7IC8vIHdoYXQgbm9kZSB3aXRoIGN0eFR5cGUgaGF2ZSB3ZSBmb3VuZD9cclxuXHRcdGZvciAobGV0IG8gb2YgdGhpcy5jaGlsZHJlbikge1xyXG5cdFx0XHRpZiAobyBpbnN0YW5jZW9mIGN0eFR5cGUpIHtcclxuXHRcdFx0XHRqKys7XHJcblx0XHRcdFx0aWYgKGogPT09IGkpIHtcclxuXHRcdFx0XHRcdHJldHVybiBvO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0VG9rZW4odHR5cGU6IG51bWJlciwgaTogbnVtYmVyKTogVGVybWluYWxOb2RlIHtcclxuXHRcdGxldCByZXN1bHQgPSB0aGlzLnRyeUdldFRva2VuKHR0eXBlLCBpKTtcclxuXHRcdGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3BlY2lmaWVkIHRva2VuIGRvZXMgbm90IGV4aXN0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdHJ5R2V0VG9rZW4odHR5cGU6IG51bWJlciwgaTogbnVtYmVyKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICghdGhpcy5jaGlsZHJlbiB8fCBpIDwgMCB8fCBpID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGo6IG51bWJlciA9IC0xOyAvLyB3aGF0IHRva2VuIHdpdGggdHR5cGUgaGF2ZSB3ZSBmb3VuZD9cclxuXHRcdGZvciAobGV0IG8gb2YgdGhpcy5jaGlsZHJlbikge1xyXG5cdFx0XHRpZiAobyBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZSkge1xyXG5cdFx0XHRcdGxldCBzeW1ib2w6IFRva2VuID0gby5zeW1ib2w7XHJcblx0XHRcdFx0aWYgKHN5bWJvbC50eXBlID09PSB0dHlwZSkge1xyXG5cdFx0XHRcdFx0aisrO1xyXG5cdFx0XHRcdFx0aWYgKGogPT09IGkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG87XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRUb2tlbnModHR5cGU6IG51bWJlcik6IFRlcm1pbmFsTm9kZVtdIHtcclxuXHRcdGxldCB0b2tlbnM6IFRlcm1pbmFsTm9kZVtdID0gW107XHJcblxyXG5cdFx0aWYgKCF0aGlzLmNoaWxkcmVuKSB7XHJcblx0XHRcdHJldHVybiB0b2tlbnM7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgbyBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcblx0XHRcdGlmIChvIGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XHJcblx0XHRcdFx0bGV0IHN5bWJvbCA9IG8uc3ltYm9sO1xyXG5cdFx0XHRcdGlmIChzeW1ib2wudHlwZSA9PT0gdHR5cGUpIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKG8pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0b2tlbnM7XHJcblx0fVxyXG5cclxuXHRnZXQgcnVsZUNvbnRleHQoKTogdGhpcyB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8vIE5PVEU6IGFyZ3VtZW50IG9yZGVyIGNoYW5nZSBmcm9tIEphdmEgdmVyc2lvblxyXG5cdHB1YmxpYyBnZXRSdWxlQ29udGV4dDxUIGV4dGVuZHMgUGFyc2VyUnVsZUNvbnRleHQ+KGk6IG51bWJlciwgY3R4VHlwZTogeyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVDsgfSk6IFQge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2hpbGQoaSwgY3R4VHlwZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdHJ5R2V0UnVsZUNvbnRleHQ8VCBleHRlbmRzIFBhcnNlclJ1bGVDb250ZXh0PihpOiBudW1iZXIsIGN0eFR5cGU6IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQ7IH0pOiBUIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLnRyeUdldENoaWxkKGksIGN0eFR5cGUpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldFJ1bGVDb250ZXh0czxUIGV4dGVuZHMgUGFyc2VyUnVsZUNvbnRleHQ+KGN0eFR5cGU6IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQ7IH0pOiBUW10ge1xyXG5cdFx0bGV0IGNvbnRleHRzOiBUW10gPSBbXTtcclxuXHRcdGlmICghdGhpcy5jaGlsZHJlbikge1xyXG5cdFx0XHRyZXR1cm4gY29udGV4dHM7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgbyBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcblx0XHRcdGlmIChvIGluc3RhbmNlb2YgY3R4VHlwZSkge1xyXG5cdFx0XHRcdGNvbnRleHRzLnB1c2gobyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29udGV4dHM7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgY2hpbGRDb3VudCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoaWxkcmVuID8gdGhpcy5jaGlsZHJlbi5sZW5ndGggOiAwO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNvdXJjZUludGVydmFsKCk6IEludGVydmFsIHtcclxuXHRcdGlmICghdGhpcy5fc3RhcnQpIHtcclxuXHRcdFx0cmV0dXJuIEludGVydmFsLklOVkFMSUQ7XHJcblx0XHR9XHJcblx0XHRpZiAoIXRoaXMuX3N0b3AgfHwgdGhpcy5fc3RvcC50b2tlbkluZGV4IDwgdGhpcy5fc3RhcnQudG9rZW5JbmRleCkge1xyXG5cdFx0XHRyZXR1cm4gSW50ZXJ2YWwub2YodGhpcy5fc3RhcnQudG9rZW5JbmRleCwgdGhpcy5fc3RhcnQudG9rZW5JbmRleCAtIDEpOyAvLyBlbXB0eVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIEludGVydmFsLm9mKHRoaXMuX3N0YXJ0LnRva2VuSW5kZXgsIHRoaXMuX3N0b3AudG9rZW5JbmRleCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGluaXRpYWwgdG9rZW4gaW4gdGhpcyBjb250ZXh0LlxyXG5cdCAqIE5vdGUgdGhhdCB0aGUgcmFuZ2UgZnJvbSBzdGFydCB0byBzdG9wIGlzIGluY2x1c2l2ZSwgc28gZm9yIHJ1bGVzIHRoYXQgZG8gbm90IGNvbnN1bWUgYW55dGhpbmdcclxuXHQgKiAoZm9yIGV4YW1wbGUsIHplcm8gbGVuZ3RoIG9yIGVycm9yIHByb2R1Y3Rpb25zKSB0aGlzIHRva2VuIG1heSBleGNlZWQgc3RvcC5cclxuXHQgKi9cclxuXHRnZXQgc3RhcnQoKTogVG9rZW4geyByZXR1cm4gdGhpcy5fc3RhcnQ7IH1cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGZpbmFsIHRva2VuIGluIHRoaXMgY29udGV4dC5cclxuXHQgKiBOb3RlIHRoYXQgdGhlIHJhbmdlIGZyb20gc3RhcnQgdG8gc3RvcCBpcyBpbmNsdXNpdmUsIHNvIGZvciBydWxlcyB0aGF0IGRvIG5vdCBjb25zdW1lIGFueXRoaW5nXHJcblx0ICogKGZvciBleGFtcGxlLCB6ZXJvIGxlbmd0aCBvciBlcnJvciBwcm9kdWN0aW9ucykgdGhpcyB0b2tlbiBtYXkgcHJlY2VkZSBzdGFydC5cclxuXHQgKi9cclxuXHRnZXQgc3RvcCgpOiBUb2tlbiB8IHVuZGVmaW5lZCB7IHJldHVybiB0aGlzLl9zdG9wOyB9XHJcblxyXG5cdC8qKiBVc2VkIGZvciBydWxlIGNvbnRleHQgaW5mbyBkZWJ1Z2dpbmcgZHVyaW5nIHBhcnNlLXRpbWUsIG5vdCBzbyBtdWNoIGZvciBBVE4gZGVidWdnaW5nICovXHJcblx0cHVibGljIHRvSW5mb1N0cmluZyhyZWNvZ25pemVyOiBQYXJzZXIpOiBzdHJpbmcge1xyXG5cdFx0bGV0IHJ1bGVzOiBzdHJpbmdbXSA9XHJcblx0XHRcdHJlY29nbml6ZXIuZ2V0UnVsZUludm9jYXRpb25TdGFjayh0aGlzKS5yZXZlcnNlKCk7XHJcblx0XHRyZXR1cm4gXCJQYXJzZXJSdWxlQ29udGV4dFwiICsgcnVsZXMgKyBcIntcIiArXHJcblx0XHRcdFwic3RhcnQ9XCIgKyB0aGlzLl9zdGFydCArXHJcblx0XHRcdFwiLCBzdG9wPVwiICsgdGhpcy5fc3RvcCArXHJcblx0XHRcdFwifVwiO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzYuMjY3Mzg5My0wNzowMFxyXG5cclxuaW1wb3J0IHsgQXJyYXkyREhhc2hNYXAgfSBmcm9tIFwiLi4vbWlzYy9BcnJheTJESGFzaE1hcFwiO1xyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9BVE5cIjtcclxuaW1wb3J0IHsgQVROQ29uZmlnIH0gZnJvbSBcIi4vQVROQ29uZmlnXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuL0FUTkNvbmZpZ1NldFwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEJpdFNldCB9IGZyb20gXCIuLi9taXNjL0JpdFNldFwiO1xyXG5pbXBvcnQgeyBFcXVhbGl0eUNvbXBhcmF0b3IgfSBmcm9tIFwiLi4vbWlzYy9FcXVhbGl0eUNvbXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuLi9taXNjL011cm11ckhhc2hcIjtcclxuaW1wb3J0IHsgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yIH0gZnJvbSBcIi4uL21pc2MvT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUnVsZVN0b3BTdGF0ZSB9IGZyb20gXCIuL1J1bGVTdG9wU3RhdGVcIjtcclxuaW1wb3J0IHsgU2VtYW50aWNDb250ZXh0IH0gZnJvbSBcIi4vU2VtYW50aWNDb250ZXh0XCI7XHJcblxyXG4vKipcclxuICogVGhpcyBlbnVtZXJhdGlvbiBkZWZpbmVzIHRoZSBwcmVkaWN0aW9uIG1vZGVzIGF2YWlsYWJsZSBpbiBBTlRMUiA0IGFsb25nIHdpdGhcclxuICogdXRpbGl0eSBtZXRob2RzIGZvciBhbmFseXppbmcgY29uZmlndXJhdGlvbiBzZXRzIGZvciBjb25mbGljdHMgYW5kL29yXHJcbiAqIGFtYmlndWl0aWVzLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gUHJlZGljdGlvbk1vZGUge1xyXG5cdC8qKlxyXG5cdCAqIFRoZSBTTEwoKikgcHJlZGljdGlvbiBtb2RlLiBUaGlzIHByZWRpY3Rpb24gbW9kZSBpZ25vcmVzIHRoZSBjdXJyZW50XHJcblx0ICogcGFyc2VyIGNvbnRleHQgd2hlbiBtYWtpbmcgcHJlZGljdGlvbnMuIFRoaXMgaXMgdGhlIGZhc3Rlc3QgcHJlZGljdGlvblxyXG5cdCAqIG1vZGUsIGFuZCBwcm92aWRlcyBjb3JyZWN0IHJlc3VsdHMgZm9yIG1hbnkgZ3JhbW1hcnMuIFRoaXMgcHJlZGljdGlvblxyXG5cdCAqIG1vZGUgaXMgbW9yZSBwb3dlcmZ1bCB0aGFuIHRoZSBwcmVkaWN0aW9uIG1vZGUgcHJvdmlkZWQgYnkgQU5UTFIgMywgYnV0XHJcblx0ICogbWF5IHJlc3VsdCBpbiBzeW50YXggZXJyb3JzIGZvciBncmFtbWFyIGFuZCBpbnB1dCBjb21iaW5hdGlvbnMgd2hpY2ggYXJlXHJcblx0ICogbm90IFNMTC5cclxuXHQgKlxyXG5cdCAqIFdoZW4gdXNpbmcgdGhpcyBwcmVkaWN0aW9uIG1vZGUsIHRoZSBwYXJzZXIgd2lsbCBlaXRoZXIgcmV0dXJuIGEgY29ycmVjdFxyXG5cdCAqIHBhcnNlIHRyZWUgKGkuZS4gdGhlIHNhbWUgcGFyc2UgdHJlZSB0aGF0IHdvdWxkIGJlIHJldHVybmVkIHdpdGggdGhlXHJcblx0ICoge0BsaW5rICNMTH0gcHJlZGljdGlvbiBtb2RlKSwgb3IgaXQgd2lsbCByZXBvcnQgYSBzeW50YXggZXJyb3IuIElmIGFcclxuXHQgKiBzeW50YXggZXJyb3IgaXMgZW5jb3VudGVyZWQgd2hlbiB1c2luZyB0aGUge0BsaW5rICNTTEx9IHByZWRpY3Rpb24gbW9kZSxcclxuXHQgKiBpdCBtYXkgYmUgZHVlIHRvIGVpdGhlciBhbiBhY3R1YWwgc3ludGF4IGVycm9yIGluIHRoZSBpbnB1dCBvciBpbmRpY2F0ZVxyXG5cdCAqIHRoYXQgdGhlIHBhcnRpY3VsYXIgY29tYmluYXRpb24gb2YgZ3JhbW1hciBhbmQgaW5wdXQgcmVxdWlyZXMgdGhlIG1vcmVcclxuXHQgKiBwb3dlcmZ1bCB7QGxpbmsgI0xMfSBwcmVkaWN0aW9uIGFiaWxpdGllcyB0byBjb21wbGV0ZSBzdWNjZXNzZnVsbHkuXHJcblx0ICpcclxuXHQgKiBUaGlzIHByZWRpY3Rpb24gbW9kZSBkb2VzIG5vdCBwcm92aWRlIGFueSBndWFyYW50ZWVzIGZvciBwcmVkaWN0aW9uXHJcblx0ICogYmVoYXZpb3IgZm9yIHN5bnRhY3RpY2FsbHktaW5jb3JyZWN0IGlucHV0cy5cclxuXHQgKi9cclxuXHRTTEwsXHJcblx0LyoqXHJcblx0ICogVGhlIExMKCopIHByZWRpY3Rpb24gbW9kZS4gVGhpcyBwcmVkaWN0aW9uIG1vZGUgYWxsb3dzIHRoZSBjdXJyZW50IHBhcnNlclxyXG5cdCAqIGNvbnRleHQgdG8gYmUgdXNlZCBmb3IgcmVzb2x2aW5nIFNMTCBjb25mbGljdHMgdGhhdCBvY2N1ciBkdXJpbmdcclxuXHQgKiBwcmVkaWN0aW9uLiBUaGlzIGlzIHRoZSBmYXN0ZXN0IHByZWRpY3Rpb24gbW9kZSB0aGF0IGd1YXJhbnRlZXMgY29ycmVjdFxyXG5cdCAqIHBhcnNlIHJlc3VsdHMgZm9yIGFsbCBjb21iaW5hdGlvbnMgb2YgZ3JhbW1hcnMgd2l0aCBzeW50YWN0aWNhbGx5IGNvcnJlY3RcclxuXHQgKiBpbnB1dHMuXHJcblx0ICpcclxuXHQgKiBXaGVuIHVzaW5nIHRoaXMgcHJlZGljdGlvbiBtb2RlLCB0aGUgcGFyc2VyIHdpbGwgbWFrZSBjb3JyZWN0IGRlY2lzaW9uc1xyXG5cdCAqIGZvciBhbGwgc3ludGFjdGljYWxseS1jb3JyZWN0IGdyYW1tYXIgYW5kIGlucHV0IGNvbWJpbmF0aW9ucy4gSG93ZXZlciwgaW5cclxuXHQgKiBjYXNlcyB3aGVyZSB0aGUgZ3JhbW1hciBpcyB0cnVseSBhbWJpZ3VvdXMgdGhpcyBwcmVkaWN0aW9uIG1vZGUgbWlnaHQgbm90XHJcblx0ICogcmVwb3J0IGEgcHJlY2lzZSBhbnN3ZXIgZm9yICpleGFjdGx5IHdoaWNoKiBhbHRlcm5hdGl2ZXMgYXJlXHJcblx0ICogYW1iaWd1b3VzLlxyXG5cdCAqXHJcblx0ICogVGhpcyBwcmVkaWN0aW9uIG1vZGUgZG9lcyBub3QgcHJvdmlkZSBhbnkgZ3VhcmFudGVlcyBmb3IgcHJlZGljdGlvblxyXG5cdCAqIGJlaGF2aW9yIGZvciBzeW50YWN0aWNhbGx5LWluY29ycmVjdCBpbnB1dHMuXHJcblx0ICovXHJcblx0TEwsXHJcblx0LyoqXHJcblx0ICogVGhlIExMKCopIHByZWRpY3Rpb24gbW9kZSB3aXRoIGV4YWN0IGFtYmlndWl0eSBkZXRlY3Rpb24uIEluIGFkZGl0aW9uIHRvXHJcblx0ICogdGhlIGNvcnJlY3RuZXNzIGd1YXJhbnRlZXMgcHJvdmlkZWQgYnkgdGhlIHtAbGluayAjTEx9IHByZWRpY3Rpb24gbW9kZSxcclxuXHQgKiB0aGlzIHByZWRpY3Rpb24gbW9kZSBpbnN0cnVjdHMgdGhlIHByZWRpY3Rpb24gYWxnb3JpdGhtIHRvIGRldGVybWluZSB0aGVcclxuXHQgKiBjb21wbGV0ZSBhbmQgZXhhY3Qgc2V0IG9mIGFtYmlndW91cyBhbHRlcm5hdGl2ZXMgZm9yIGV2ZXJ5IGFtYmlndW91c1xyXG5cdCAqIGRlY2lzaW9uIGVuY291bnRlcmVkIHdoaWxlIHBhcnNpbmcuXHJcblx0ICpcclxuXHQgKiBUaGlzIHByZWRpY3Rpb24gbW9kZSBtYXkgYmUgdXNlZCBmb3IgZGlhZ25vc2luZyBhbWJpZ3VpdGllcyBkdXJpbmdcclxuXHQgKiBncmFtbWFyIGRldmVsb3BtZW50LiBEdWUgdG8gdGhlIHBlcmZvcm1hbmNlIG92ZXJoZWFkIG9mIGNhbGN1bGF0aW5nIHNldHNcclxuXHQgKiBvZiBhbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzLCB0aGlzIHByZWRpY3Rpb24gbW9kZSBzaG91bGQgYmUgYXZvaWRlZCB3aGVuXHJcblx0ICogdGhlIGV4YWN0IHJlc3VsdHMgYXJlIG5vdCBuZWNlc3NhcnkuXHJcblx0ICpcclxuXHQgKiBUaGlzIHByZWRpY3Rpb24gbW9kZSBkb2VzIG5vdCBwcm92aWRlIGFueSBndWFyYW50ZWVzIGZvciBwcmVkaWN0aW9uXHJcblx0ICogYmVoYXZpb3IgZm9yIHN5bnRhY3RpY2FsbHktaW5jb3JyZWN0IGlucHV0cy5cclxuXHQgKi9cclxuXHRMTF9FWEFDVF9BTUJJR19ERVRFQ1RJT04sXHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgUHJlZGljdGlvbk1vZGUge1xyXG5cdC8qKiBBIE1hcCB0aGF0IHVzZXMganVzdCB0aGUgc3RhdGUgYW5kIHRoZSBzdGFjayBjb250ZXh0IGFzIHRoZSBrZXkuICovXHJcblx0Ly8gTk9URTogQmFzZSB0eXBlIHVzZWQgdG8gYmUgRmxleGlibGVIYXNoTWFwPEFUTkNvbmZpZywgQml0U2V0PlxyXG5cdGNsYXNzIEFsdEFuZENvbnRleHRNYXAgZXh0ZW5kcyBBcnJheTJESGFzaE1hcDxBVE5Db25maWcsIEJpdFNldD4ge1xyXG5cdFx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRcdHN1cGVyKEFsdEFuZENvbnRleHRDb25maWdFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Y2xhc3MgQWx0QW5kQ29udGV4dENvbmZpZ0VxdWFsaXR5Q29tcGFyYXRvciBpbXBsZW1lbnRzIEVxdWFsaXR5Q29tcGFyYXRvcjxBVE5Db25maWc+IHtcclxuXHRcdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSU5TVEFOQ0U6IEFsdEFuZENvbnRleHRDb25maWdFcXVhbGl0eUNvbXBhcmF0b3IgPSBuZXcgQWx0QW5kQ29udGV4dENvbmZpZ0VxdWFsaXR5Q29tcGFyYXRvcigpO1xyXG5cclxuXHRcdHByaXZhdGUgQWx0QW5kQ29udGV4dENvbmZpZ0VxdWFsaXR5Q29tcGFyYXRvcigpIHtcclxuXHRcdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdFx0fVxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGhhc2ggY29kZSBpcyBvbmx5IGEgZnVuY3Rpb24gb2YgdGhlIHtAbGluayBBVE5TdGF0ZSNzdGF0ZU51bWJlcn1cclxuXHRcdCAqIGFuZCB7QGxpbmsgQVROQ29uZmlnI2NvbnRleHR9LlxyXG5cdFx0ICovXHJcblx0XHRAT3ZlcnJpZGVcclxuXHRcdHB1YmxpYyBoYXNoQ29kZShvOiBBVE5Db25maWcpOiBudW1iZXIge1xyXG5cdFx0XHRsZXQgaGFzaENvZGU6IG51bWJlciA9IE11cm11ckhhc2guaW5pdGlhbGl6ZSg3KTtcclxuXHRcdFx0aGFzaENvZGUgPSBNdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgby5zdGF0ZS5zdGF0ZU51bWJlcik7XHJcblx0XHRcdGhhc2hDb2RlID0gTXVybXVySGFzaC51cGRhdGUoaGFzaENvZGUsIG8uY29udGV4dCk7XHJcblx0XHRcdGhhc2hDb2RlID0gTXVybXVySGFzaC5maW5pc2goaGFzaENvZGUsIDIpO1xyXG5cdFx0XHRyZXR1cm4gaGFzaENvZGU7XHJcblx0XHR9XHJcblxyXG5cdFx0QE92ZXJyaWRlXHJcblx0XHRwdWJsaWMgZXF1YWxzKGE6IEFUTkNvbmZpZywgYjogQVROQ29uZmlnKTogYm9vbGVhbiB7XHJcblx0XHRcdGlmIChhID09PSBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGEuc3RhdGUuc3RhdGVOdW1iZXIgPT09IGIuc3RhdGUuc3RhdGVOdW1iZXJcclxuXHRcdFx0XHQmJiBhLmNvbnRleHQuZXF1YWxzKGIuY29udGV4dCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVja3MgaWYgYW55IGNvbmZpZ3VyYXRpb24gaW4gYGNvbmZpZ3NgIGlzIGluIGFcclxuXHQgKiB7QGxpbmsgUnVsZVN0b3BTdGF0ZX0uIENvbmZpZ3VyYXRpb25zIG1lZXRpbmcgdGhpcyBjb25kaXRpb24gaGF2ZSByZWFjaGVkXHJcblx0ICogdGhlIGVuZCBvZiB0aGUgZGVjaXNpb24gcnVsZSAobG9jYWwgY29udGV4dCkgb3IgZW5kIG9mIHN0YXJ0IHJ1bGUgKGZ1bGxcclxuXHQgKiBjb250ZXh0KS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBjb25maWdzIHRoZSBjb25maWd1cmF0aW9uIHNldCB0byB0ZXN0XHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIGFueSBjb25maWd1cmF0aW9uIGluIGBjb25maWdzYCBpcyBpbiBhXHJcblx0ICoge0BsaW5rIFJ1bGVTdG9wU3RhdGV9LCBvdGhlcndpc2UgYGZhbHNlYFxyXG5cdCAqL1xyXG5cdGV4cG9ydCBmdW5jdGlvbiBoYXNDb25maWdJblJ1bGVTdG9wU3RhdGUoY29uZmlnczogQVROQ29uZmlnU2V0KTogYm9vbGVhbiB7XHJcblx0XHRmb3IgKGxldCBjIG9mIGNvbmZpZ3MpIHtcclxuXHRcdFx0aWYgKGMuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVja3MgaWYgYWxsIGNvbmZpZ3VyYXRpb25zIGluIGBjb25maWdzYCBhcmUgaW4gYVxyXG5cdCAqIHtAbGluayBSdWxlU3RvcFN0YXRlfS4gQ29uZmlndXJhdGlvbnMgbWVldGluZyB0aGlzIGNvbmRpdGlvbiBoYXZlIHJlYWNoZWRcclxuXHQgKiB0aGUgZW5kIG9mIHRoZSBkZWNpc2lvbiBydWxlIChsb2NhbCBjb250ZXh0KSBvciBlbmQgb2Ygc3RhcnQgcnVsZSAoZnVsbFxyXG5cdCAqIGNvbnRleHQpLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGNvbmZpZ3MgdGhlIGNvbmZpZ3VyYXRpb24gc2V0IHRvIHRlc3RcclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGNvbmZpZ3VyYXRpb25zIGluIGBjb25maWdzYCBhcmUgaW4gYVxyXG5cdCAqIHtAbGluayBSdWxlU3RvcFN0YXRlfSwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuXHQgKi9cclxuXHRleHBvcnQgZnVuY3Rpb24gYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXMoLypATm90TnVsbCovIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCk6IGJvb2xlYW4ge1xyXG5cdFx0Zm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpIHtcclxuXHRcdFx0aWYgKCEoY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM3LjM4NzE5ODQtMDc6MDBcclxuXHJcbmltcG9ydCB7IERGQVN0YXRlIH0gZnJvbSBcIi4uL2RmYS9ERkFTdGF0ZVwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2ltdWxhdG9yU3RhdGUge1xyXG5cdHB1YmxpYyBvdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0O1xyXG5cclxuXHRwdWJsaWMgczA6IERGQVN0YXRlO1xyXG5cclxuXHRwdWJsaWMgdXNlQ29udGV4dDogYm9vbGVhbjtcclxuXHRwdWJsaWMgcmVtYWluaW5nT3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZDtcclxuXHJcblx0Y29uc3RydWN0b3Iob3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCwgQE5vdE51bGwgczA6IERGQVN0YXRlLCB1c2VDb250ZXh0OiBib29sZWFuLCByZW1haW5pbmdPdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkKSB7XHJcblx0XHR0aGlzLm91dGVyQ29udGV4dCA9IG91dGVyQ29udGV4dCAhPSBudWxsID8gb3V0ZXJDb250ZXh0IDogUGFyc2VyUnVsZUNvbnRleHQuZW1wdHlDb250ZXh0KCk7XHJcblx0XHR0aGlzLnMwID0gczA7XHJcblx0XHR0aGlzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xyXG5cdFx0dGhpcy5yZW1haW5pbmdPdXRlckNvbnRleHQgPSByZW1haW5pbmdPdXRlckNvbnRleHQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozMS4xOTg5ODM1LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBY2NlcHRTdGF0ZUluZm8gfSBmcm9tIFwiLi4vZGZhL0FjY2VwdFN0YXRlSW5mb1wiO1xyXG5pbXBvcnQgeyBBY3Rpb25UcmFuc2l0aW9uIH0gZnJvbSBcIi4vQWN0aW9uVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBBcnJheTJESGFzaFNldCB9IGZyb20gXCIuLi9taXNjL0FycmF5MkRIYXNoU2V0XCI7XHJcbmltcG9ydCB7IEFycmF5cyB9IGZyb20gXCIuLi9taXNjL0FycmF5c1wiO1xyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9BVE5cIjtcclxuaW1wb3J0IHsgQVROQ29uZmlnIH0gZnJvbSBcIi4vQVROQ29uZmlnXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuL0FUTkNvbmZpZ1NldFwiO1xyXG5pbXBvcnQgeyBBVE5TaW11bGF0b3IgfSBmcm9tIFwiLi9BVE5TaW11bGF0b3JcIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZVR5cGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVR5cGVcIjtcclxuaW1wb3J0IHsgQXRvbVRyYW5zaXRpb24gfSBmcm9tIFwiLi9BdG9tVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBCaXRTZXQgfSBmcm9tIFwiLi4vbWlzYy9CaXRTZXRcIjtcclxuaW1wb3J0IHsgQ29uZmxpY3RJbmZvIH0gZnJvbSBcIi4vQ29uZmxpY3RJbmZvXCI7XHJcbmltcG9ydCB7IERlY2lzaW9uU3RhdGUgfSBmcm9tIFwiLi9EZWNpc2lvblN0YXRlXCI7XHJcbmltcG9ydCB7IERGQSB9IGZyb20gXCIuLi9kZmEvREZBXCI7XHJcbmltcG9ydCB7IERGQVN0YXRlIH0gZnJvbSBcIi4uL2RmYS9ERkFTdGF0ZVwiO1xyXG5pbXBvcnQgeyBFcHNpbG9uVHJhbnNpdGlvbiB9IGZyb20gXCIuL0Vwc2lsb25UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IEludGVnZXJMaXN0IH0gZnJvbSBcIi4uL21pc2MvSW50ZWdlckxpc3RcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5pbXBvcnQgeyBJbnRTdHJlYW0gfSBmcm9tIFwiLi4vSW50U3RyZWFtXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE51bGxhYmxlLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IE5vdFNldFRyYW5zaXRpb24gfSBmcm9tIFwiLi9Ob3RTZXRUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IE5vVmlhYmxlQWx0RXhjZXB0aW9uIH0gZnJvbSBcIi4uL05vVmlhYmxlQWx0RXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvciB9IGZyb20gXCIuLi9taXNjL09iamVjdEVxdWFsaXR5Q29tcGFyYXRvclwiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4uL1BhcnNlclJ1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgUHJlZGljYXRlVHJhbnNpdGlvbiB9IGZyb20gXCIuL1ByZWRpY2F0ZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgUHJlZGljdGlvbkNvbnRleHQgfSBmcm9tIFwiLi9QcmVkaWN0aW9uQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uQ29udGV4dENhY2hlIH0gZnJvbSBcIi4vUHJlZGljdGlvbkNvbnRleHRDYWNoZVwiO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uTW9kZSB9IGZyb20gXCIuL1ByZWRpY3Rpb25Nb2RlXCI7XHJcbmltcG9ydCB7IFJ1bGVDb250ZXh0IH0gZnJvbSBcIi4uL1J1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IFJ1bGVTdG9wU3RhdGUgfSBmcm9tIFwiLi9SdWxlU3RvcFN0YXRlXCI7XHJcbmltcG9ydCB7IFJ1bGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vUnVsZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgU2VtYW50aWNDb250ZXh0IH0gZnJvbSBcIi4vU2VtYW50aWNDb250ZXh0XCI7XHJcbmltcG9ydCB7IFNldFRyYW5zaXRpb24gfSBmcm9tIFwiLi9TZXRUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFNpbXVsYXRvclN0YXRlIH0gZnJvbSBcIi4vU2ltdWxhdG9yU3RhdGVcIjtcclxuaW1wb3J0IHsgU3Rhckxvb3BFbnRyeVN0YXRlIH0gZnJvbSBcIi4vU3Rhckxvb3BFbnRyeVN0YXRlXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4uL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4uL1Rva2VuU3RyZWFtXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tIFwiLi9UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25UeXBlIH0gZnJvbSBcIi4vVHJhbnNpdGlvblR5cGVcIjtcclxuaW1wb3J0IHsgVm9jYWJ1bGFyeSB9IGZyb20gXCIuLi9Wb2NhYnVsYXJ5XCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnlJbXBsIH0gZnJvbSBcIi4uL1ZvY2FidWxhcnlJbXBsXCI7XHJcblxyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5cclxuY29uc3QgTUFYX1NIT1JUX1ZBTFVFID0gMHhGRkZGO1xyXG5jb25zdCBNSU5fSU5URUdFUl9WQUxVRSA9IC0oKDEgPDwgMzEpID4+PiAwKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZW1ib2RpbWVudCBvZiB0aGUgYWRhcHRpdmUgTEwoKiksIEFMTCgqKSwgcGFyc2luZyBzdHJhdGVneS5cclxuICpcclxuICogVGhlIGJhc2ljIGNvbXBsZXhpdHkgb2YgdGhlIGFkYXB0aXZlIHN0cmF0ZWd5IG1ha2VzIGl0IGhhcmRlciB0byB1bmRlcnN0YW5kLlxyXG4gKiBXZSBiZWdpbiB3aXRoIEFUTiBzaW11bGF0aW9uIHRvIGJ1aWxkIHBhdGhzIGluIGEgREZBLiBTdWJzZXF1ZW50IHByZWRpY3Rpb25cclxuICogcmVxdWVzdHMgZ28gdGhyb3VnaCB0aGUgREZBIGZpcnN0LiBJZiB0aGV5IHJlYWNoIGEgc3RhdGUgd2l0aG91dCBhbiBlZGdlIGZvclxyXG4gKiB0aGUgY3VycmVudCBzeW1ib2wsIHRoZSBhbGdvcml0aG0gZmFpbHMgb3ZlciB0byB0aGUgQVROIHNpbXVsYXRpb24gdG9cclxuICogY29tcGxldGUgdGhlIERGQSBwYXRoIGZvciB0aGUgY3VycmVudCBpbnB1dCAodW50aWwgaXQgZmluZHMgYSBjb25mbGljdCBzdGF0ZVxyXG4gKiBvciB1bmlxdWVseSBwcmVkaWN0aW5nIHN0YXRlKS5cclxuICpcclxuICogQWxsIG9mIHRoYXQgaXMgZG9uZSB3aXRob3V0IHVzaW5nIHRoZSBvdXRlciBjb250ZXh0IGJlY2F1c2Ugd2Ugd2FudCB0byBjcmVhdGVcclxuICogYSBERkEgdGhhdCBpcyBub3QgZGVwZW5kZW50IHVwb24gdGhlIHJ1bGUgaW52b2NhdGlvbiBzdGFjayB3aGVuIHdlIGRvIGFcclxuICogcHJlZGljdGlvbi4gT25lIERGQSB3b3JrcyBpbiBhbGwgY29udGV4dHMuIFdlIGF2b2lkIHVzaW5nIGNvbnRleHQgbm90XHJcbiAqIG5lY2Vzc2FyaWx5IGJlY2F1c2UgaXQncyBzbG93ZXIsIGFsdGhvdWdoIGl0IGNhbiBiZSwgYnV0IGJlY2F1c2Ugb2YgdGhlIERGQVxyXG4gKiBjYWNoaW5nIHByb2JsZW0uIFRoZSBjbG9zdXJlIHJvdXRpbmUgb25seSBjb25zaWRlcnMgdGhlIHJ1bGUgaW52b2NhdGlvbiBzdGFja1xyXG4gKiBjcmVhdGVkIGR1cmluZyBwcmVkaWN0aW9uIGJlZ2lubmluZyBpbiB0aGUgZGVjaXNpb24gcnVsZS4gRm9yIGV4YW1wbGUsIGlmXHJcbiAqIHByZWRpY3Rpb24gb2NjdXJzIHdpdGhvdXQgaW52b2tpbmcgYW5vdGhlciBydWxlJ3MgQVROLCB0aGVyZSBhcmUgbm8gY29udGV4dFxyXG4gKiBzdGFja3MgaW4gdGhlIGNvbmZpZ3VyYXRpb25zLiBXaGVuIGxhY2sgb2YgY29udGV4dCBsZWFkcyB0byBhIGNvbmZsaWN0LCB3ZVxyXG4gKiBkb24ndCBrbm93IGlmIGl0J3MgYW4gYW1iaWd1aXR5IG9yIGEgd2Vha25lc3MgaW4gdGhlIHN0cm9uZyBMTCgqKSBwYXJzaW5nXHJcbiAqIHN0cmF0ZWd5ICh2ZXJzdXMgZnVsbCBMTCgqKSkuXHJcbiAqXHJcbiAqIFdoZW4gU0xMIHlpZWxkcyBhIGNvbmZpZ3VyYXRpb24gc2V0IHdpdGggY29uZmxpY3QsIHdlIHJld2luZCB0aGUgaW5wdXQgYW5kXHJcbiAqIHJldHJ5IHRoZSBBVE4gc2ltdWxhdGlvbiwgdGhpcyB0aW1lIHVzaW5nIGZ1bGwgb3V0ZXIgY29udGV4dCB3aXRob3V0IGFkZGluZ1xyXG4gKiB0byB0aGUgREZBLiBDb25maWd1cmF0aW9uIGNvbnRleHQgc3RhY2tzIHdpbGwgYmUgdGhlIGZ1bGwgaW52b2NhdGlvbiBzdGFja3NcclxuICogZnJvbSB0aGUgc3RhcnQgcnVsZS4gSWYgd2UgZ2V0IGEgY29uZmxpY3QgdXNpbmcgZnVsbCBjb250ZXh0LCB0aGVuIHdlIGNhblxyXG4gKiBkZWZpbml0aXZlbHkgc2F5IHdlIGhhdmUgYSB0cnVlIGFtYmlndWl0eSBmb3IgdGhhdCBpbnB1dCBzZXF1ZW5jZS4gSWYgd2VcclxuICogZG9uJ3QgZ2V0IGEgY29uZmxpY3QsIGl0IGltcGxpZXMgdGhhdCB0aGUgZGVjaXNpb24gaXMgc2Vuc2l0aXZlIHRvIHRoZSBvdXRlclxyXG4gKiBjb250ZXh0LiAoSXQgaXMgbm90IGNvbnRleHQtc2Vuc2l0aXZlIGluIHRoZSBzZW5zZSBvZiBjb250ZXh0LXNlbnNpdGl2ZVxyXG4gKiBncmFtbWFycy4pXHJcbiAqXHJcbiAqIFRoZSBuZXh0IHRpbWUgd2UgcmVhY2ggdGhpcyBERkEgc3RhdGUgd2l0aCBhbiBTTEwgY29uZmxpY3QsIHRocm91Z2ggREZBXHJcbiAqIHNpbXVsYXRpb24sIHdlIHdpbGwgYWdhaW4gcmV0cnkgdGhlIEFUTiBzaW11bGF0aW9uIHVzaW5nIGZ1bGwgY29udGV4dCBtb2RlLlxyXG4gKiBUaGlzIGlzIHNsb3cgYmVjYXVzZSB3ZSBjYW4ndCBzYXZlIHRoZSByZXN1bHRzIGFuZCBoYXZlIHRvIFwiaW50ZXJwcmV0XCIgdGhlXHJcbiAqIEFUTiBlYWNoIHRpbWUgd2UgZ2V0IHRoYXQgaW5wdXQuXHJcbiAqXHJcbiAqICoqQ0FDSElORyBGVUxMIENPTlRFWFQgUFJFRElDVElPTlMqKlxyXG4gKlxyXG4gKiBXZSBjb3VsZCBjYWNoZSByZXN1bHRzIGZyb20gZnVsbCBjb250ZXh0IHRvIHByZWRpY3RlZCBhbHRlcm5hdGl2ZSBlYXNpbHkgYW5kXHJcbiAqIHRoYXQgc2F2ZXMgYSBsb3Qgb2YgdGltZSBidXQgZG9lc24ndCB3b3JrIGluIHByZXNlbmNlIG9mIHByZWRpY2F0ZXMuIFRoZSBzZXRcclxuICogb2YgdmlzaWJsZSBwcmVkaWNhdGVzIGZyb20gdGhlIEFUTiBzdGFydCBzdGF0ZSBjaGFuZ2VzIGRlcGVuZGluZyBvbiB0aGVcclxuICogY29udGV4dCwgYmVjYXVzZSBjbG9zdXJlIGNhbiBmYWxsIG9mZiB0aGUgZW5kIG9mIGEgcnVsZS4gSSB0cmllZCB0byBjYWNoZVxyXG4gKiB0dXBsZXMgKHN0YWNrIGNvbnRleHQsIHNlbWFudGljIGNvbnRleHQsIHByZWRpY3RlZCBhbHQpIGJ1dCBpdCB3YXMgc2xvd2VyXHJcbiAqIHRoYW4gaW50ZXJwcmV0aW5nIGFuZCBtdWNoIG1vcmUgY29tcGxpY2F0ZWQuIEFsc28gcmVxdWlyZWQgYSBodWdlIGFtb3VudCBvZlxyXG4gKiBtZW1vcnkuIFRoZSBnb2FsIGlzIG5vdCB0byBjcmVhdGUgdGhlIHdvcmxkJ3MgZmFzdGVzdCBwYXJzZXIgYW55d2F5LiBJJ2QgbGlrZVxyXG4gKiB0byBrZWVwIHRoaXMgYWxnb3JpdGhtIHNpbXBsZS4gQnkgbGF1bmNoaW5nIG11bHRpcGxlIHRocmVhZHMsIHdlIGNhbiBpbXByb3ZlXHJcbiAqIHRoZSBzcGVlZCBvZiBwYXJzaW5nIGFjcm9zcyBhIGxhcmdlIG51bWJlciBvZiBmaWxlcy5cclxuICpcclxuICogVGhlcmUgaXMgbm8gc3RyaWN0IG9yZGVyaW5nIGJldHdlZW4gdGhlIGFtb3VudCBvZiBpbnB1dCB1c2VkIGJ5IFNMTCB2cyBMTCxcclxuICogd2hpY2ggbWFrZXMgaXQgcmVhbGx5IGhhcmQgdG8gYnVpbGQgYSBjYWNoZSBmb3IgZnVsbCBjb250ZXh0LiBMZXQncyBzYXkgdGhhdFxyXG4gKiB3ZSBoYXZlIGlucHV0IEEgQiBDIHRoYXQgbGVhZHMgdG8gYW4gU0xMIGNvbmZsaWN0IHdpdGggZnVsbCBjb250ZXh0IFguIFRoYXRcclxuICogaW1wbGllcyB0aGF0IHVzaW5nIFggd2UgbWlnaHQgb25seSB1c2UgQSBCIGJ1dCB3ZSBjb3VsZCBhbHNvIHVzZSBBIEIgQyBEIHRvXHJcbiAqIHJlc29sdmUgY29uZmxpY3QuIElucHV0IEEgQiBDIEQgY291bGQgcHJlZGljdCBhbHRlcm5hdGl2ZSAxIGluIG9uZSBwb3NpdGlvblxyXG4gKiBpbiB0aGUgaW5wdXQgYW5kIEEgQiBDIEUgY291bGQgcHJlZGljdCBhbHRlcm5hdGl2ZSAyIGluIGFub3RoZXIgcG9zaXRpb24gaW5cclxuICogaW5wdXQuIFRoZSBjb25mbGljdGluZyBTTEwgY29uZmlndXJhdGlvbnMgY291bGQgc3RpbGwgYmUgbm9uLXVuaXF1ZSBpbiB0aGVcclxuICogZnVsbCBjb250ZXh0IHByZWRpY3Rpb24sIHdoaWNoIHdvdWxkIGxlYWQgdXMgdG8gcmVxdWlyaW5nIG1vcmUgaW5wdXQgdGhhbiB0aGVcclxuICogb3JpZ2luYWwgQSBCIEMuXHRUbyBtYWtlIGFcdHByZWRpY3Rpb24gY2FjaGUgd29yaywgd2UgaGF2ZSB0byB0cmFja1x0dGhlIGV4YWN0XHJcbiAqIGlucHV0XHR1c2VkIGR1cmluZyB0aGUgcHJldmlvdXMgcHJlZGljdGlvbi4gVGhhdCBhbW91bnRzIHRvIGEgY2FjaGUgdGhhdCBtYXBzXHJcbiAqIFggdG8gYSBzcGVjaWZpYyBERkEgZm9yIHRoYXQgY29udGV4dC5cclxuICpcclxuICogU29tZXRoaW5nIHNob3VsZCBiZSBkb25lIGZvciBsZWZ0LXJlY3Vyc2l2ZSBleHByZXNzaW9uIHByZWRpY3Rpb25zLiBUaGV5IGFyZVxyXG4gKiBsaWtlbHkgTEwoMSkgKyBwcmVkIGV2YWwuIEVhc2llciB0byBkbyB0aGUgd2hvbGUgU0xMIHVubGVzcyBlcnJvciBhbmQgcmV0cnlcclxuICogd2l0aCBmdWxsIExMIHRoaW5nIFNhbSBkb2VzLlxyXG4gKlxyXG4gKiAqKkFWT0lESU5HIEZVTEwgQ09OVEVYVCBQUkVESUNUSU9OKipcclxuICpcclxuICogV2UgYXZvaWQgZG9pbmcgZnVsbCBjb250ZXh0IHJldHJ5IHdoZW4gdGhlIG91dGVyIGNvbnRleHQgaXMgZW1wdHksIHdlIGRpZCBub3RcclxuICogZGlwIGludG8gdGhlIG91dGVyIGNvbnRleHQgYnkgZmFsbGluZyBvZmYgdGhlIGVuZCBvZiB0aGUgZGVjaXNpb24gc3RhdGUgcnVsZSxcclxuICogb3Igd2hlbiB3ZSBmb3JjZSBTTEwgbW9kZS5cclxuICpcclxuICogQXMgYW4gZXhhbXBsZSBvZiB0aGUgbm90IGRpcCBpbnRvIG91dGVyIGNvbnRleHQgY2FzZSwgY29uc2lkZXIgYXMgc3VwZXJcclxuICogY29uc3RydWN0b3IgY2FsbHMgdmVyc3VzIGZ1bmN0aW9uIGNhbGxzLiBPbmUgZ3JhbW1hciBtaWdodCBsb29rIGxpa2VcclxuICogdGhpczpcclxuICpcclxuICogYGBgYW50bHJcclxuICogY3RvckJvZHlcclxuICogICA6ICd7JyBzdXBlckNhbGw/IHN0YXQqICd9J1xyXG4gKiAgIDtcclxuICogYGBgXHJcbiAqXHJcbiAqIE9yLCB5b3UgbWlnaHQgc2VlIHNvbWV0aGluZyBsaWtlXHJcbiAqXHJcbiAqIGBgYGFudGxyXHJcbiAqIHN0YXRcclxuICogICA6IHN1cGVyQ2FsbCAnOydcclxuICogICB8IGV4cHJlc3Npb24gJzsnXHJcbiAqICAgfCAuLi5cclxuICogICA7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBJbiBib3RoIGNhc2VzIEkgYmVsaWV2ZSB0aGF0IG5vIGNsb3N1cmUgb3BlcmF0aW9ucyB3aWxsIGRpcCBpbnRvIHRoZSBvdXRlclxyXG4gKiBjb250ZXh0LiBJbiB0aGUgZmlyc3QgY2FzZSBjdG9yQm9keSBpbiB0aGUgd29yc3QgY2FzZSB3aWxsIHN0b3AgYXQgdGhlICd9Jy5cclxuICogSW4gdGhlIDJuZCBjYXNlIGl0IHNob3VsZCBzdG9wIGF0IHRoZSAnOycuIEJvdGggY2FzZXMgc2hvdWxkIHN0YXkgd2l0aGluIHRoZVxyXG4gKiBlbnRyeSBydWxlIGFuZCBub3QgZGlwIGludG8gdGhlIG91dGVyIGNvbnRleHQuXHJcbiAqXHJcbiAqICoqUFJFRElDQVRFUyoqXHJcbiAqXHJcbiAqIFByZWRpY2F0ZXMgYXJlIGFsd2F5cyBldmFsdWF0ZWQgaWYgcHJlc2VudCBpbiBlaXRoZXIgU0xMIG9yIExMIGJvdGguIFNMTCBhbmRcclxuICogTEwgc2ltdWxhdGlvbiBkZWFscyB3aXRoIHByZWRpY2F0ZXMgZGlmZmVyZW50bHkuIFNMTCBjb2xsZWN0cyBwcmVkaWNhdGVzIGFzXHJcbiAqIGl0IHBlcmZvcm1zIGNsb3N1cmUgb3BlcmF0aW9ucyBsaWtlIEFOVExSIHYzIGRpZC4gSXQgZGVsYXlzIHByZWRpY2F0ZVxyXG4gKiBldmFsdWF0aW9uIHVudGlsIGl0IHJlYWNoZXMgYW5kIGFjY2VwdCBzdGF0ZS4gVGhpcyBhbGxvd3MgdXMgdG8gY2FjaGUgdGhlIFNMTFxyXG4gKiBBVE4gc2ltdWxhdGlvbiB3aGVyZWFzLCBpZiB3ZSBoYWQgZXZhbHVhdGVkIHByZWRpY2F0ZXMgb24tdGhlLWZseSBkdXJpbmdcclxuICogY2xvc3VyZSwgdGhlIERGQSBzdGF0ZSBjb25maWd1cmF0aW9uIHNldHMgd291bGQgYmUgZGlmZmVyZW50IGFuZCB3ZSBjb3VsZG4ndFxyXG4gKiBidWlsZCB1cCBhIHN1aXRhYmxlIERGQS5cclxuICpcclxuICogV2hlbiBidWlsZGluZyBhIERGQSBhY2NlcHQgc3RhdGUgZHVyaW5nIEFUTiBzaW11bGF0aW9uLCB3ZSBldmFsdWF0ZSBhbnlcclxuICogcHJlZGljYXRlcyBhbmQgcmV0dXJuIHRoZSBzb2xlIHNlbWFudGljYWxseSB2YWxpZCBhbHRlcm5hdGl2ZS4gSWYgdGhlcmUgaXNcclxuICogbW9yZSB0aGFuIDEgYWx0ZXJuYXRpdmUsIHdlIHJlcG9ydCBhbiBhbWJpZ3VpdHkuIElmIHRoZXJlIGFyZSAwIGFsdGVybmF0aXZlcyxcclxuICogd2UgdGhyb3cgYW4gZXhjZXB0aW9uLiBBbHRlcm5hdGl2ZXMgd2l0aG91dCBwcmVkaWNhdGVzIGFjdCBsaWtlIHRoZXkgaGF2ZVxyXG4gKiB0cnVlIHByZWRpY2F0ZXMuIFRoZSBzaW1wbGUgd2F5IHRvIHRoaW5rIGFib3V0IGl0IGlzIHRvIHN0cmlwIGF3YXkgYWxsXHJcbiAqIGFsdGVybmF0aXZlcyB3aXRoIGZhbHNlIHByZWRpY2F0ZXMgYW5kIGNob29zZSB0aGUgbWluaW11bSBhbHRlcm5hdGl2ZSB0aGF0XHJcbiAqIHJlbWFpbnMuXHJcbiAqXHJcbiAqIFdoZW4gd2Ugc3RhcnQgaW4gdGhlIERGQSBhbmQgcmVhY2ggYW4gYWNjZXB0IHN0YXRlIHRoYXQncyBwcmVkaWNhdGVkLCB3ZSB0ZXN0XHJcbiAqIHRob3NlIGFuZCByZXR1cm4gdGhlIG1pbmltdW0gc2VtYW50aWNhbGx5IHZpYWJsZSBhbHRlcm5hdGl2ZS4gSWYgbm9cclxuICogYWx0ZXJuYXRpdmVzIGFyZSB2aWFibGUsIHdlIHRocm93IGFuIGV4Y2VwdGlvbi5cclxuICpcclxuICogRHVyaW5nIGZ1bGwgTEwgQVROIHNpbXVsYXRpb24sIGNsb3N1cmUgYWx3YXlzIGV2YWx1YXRlcyBwcmVkaWNhdGVzIGFuZFxyXG4gKiBvbi10aGUtZmx5LiBUaGlzIGlzIGNydWNpYWwgdG8gcmVkdWNpbmcgdGhlIGNvbmZpZ3VyYXRpb24gc2V0IHNpemUgZHVyaW5nXHJcbiAqIGNsb3N1cmUuIEl0IGhpdHMgYSBsYW5kbWluZSB3aGVuIHBhcnNpbmcgd2l0aCB0aGUgSmF2YSBncmFtbWFyLCBmb3IgZXhhbXBsZSxcclxuICogd2l0aG91dCB0aGlzIG9uLXRoZS1mbHkgZXZhbHVhdGlvbi5cclxuICpcclxuICogKipTSEFSSU5HIERGQSoqXHJcbiAqXHJcbiAqIEFsbCBpbnN0YW5jZXMgb2YgdGhlIHNhbWUgcGFyc2VyIHNoYXJlIHRoZSBzYW1lIGRlY2lzaW9uIERGQXMgdGhyb3VnaCBhXHJcbiAqIHN0YXRpYyBmaWVsZC4gRWFjaCBpbnN0YW5jZSBnZXRzIGl0cyBvd24gQVROIHNpbXVsYXRvciBidXQgdGhleSBzaGFyZSB0aGVcclxuICogc2FtZSB7QGxpbmsgQVROI2RlY2lzaW9uVG9ERkF9IGZpZWxkLiBUaGV5IGFsc28gc2hhcmUgYVxyXG4gKiB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHRDYWNoZX0gb2JqZWN0IHRoYXQgbWFrZXMgc3VyZSB0aGF0IGFsbFxyXG4gKiB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHR9IG9iamVjdHMgYXJlIHNoYXJlZCBhbW9uZyB0aGUgREZBIHN0YXRlcy4gVGhpcyBtYWtlc1xyXG4gKiBhIGJpZyBzaXplIGRpZmZlcmVuY2UuXHJcbiAqXHJcbiAqICoqVEhSRUFEIFNBRkVUWSoqXHJcbiAqXHJcbiAqIFRoZSB7QGxpbmsgUGFyc2VyQVROU2ltdWxhdG9yfSBsb2NrcyBvbiB0aGUge0BsaW5rIEFUTiNkZWNpc2lvblRvREZBfSBmaWVsZCB3aGVuXHJcbiAqIGl0IGFkZHMgYSBuZXcgREZBIG9iamVjdCB0byB0aGF0IGFycmF5LiB7QGxpbmsgI2FkZERGQUVkZ2V9XHJcbiAqIGxvY2tzIG9uIHRoZSBERkEgZm9yIHRoZSBjdXJyZW50IGRlY2lzaW9uIHdoZW4gc2V0dGluZyB0aGVcclxuICoge0BsaW5rIERGQVN0YXRlI2VkZ2VzfSBmaWVsZC4ge0BsaW5rICNhZGRERkFTdGF0ZX0gbG9ja3Mgb25cclxuICogdGhlIERGQSBmb3IgdGhlIGN1cnJlbnQgZGVjaXNpb24gd2hlbiBsb29raW5nIHVwIGEgREZBIHN0YXRlIHRvIHNlZSBpZiBpdFxyXG4gKiBhbHJlYWR5IGV4aXN0cy4gV2UgbXVzdCBtYWtlIHN1cmUgdGhhdCBhbGwgcmVxdWVzdHMgdG8gYWRkIERGQSBzdGF0ZXMgdGhhdFxyXG4gKiBhcmUgZXF1aXZhbGVudCByZXN1bHQgaW4gdGhlIHNhbWUgc2hhcmVkIERGQSBvYmplY3QuIFRoaXMgaXMgYmVjYXVzZSBsb3RzIG9mXHJcbiAqIHRocmVhZHMgd2lsbCBiZSB0cnlpbmcgdG8gdXBkYXRlIHRoZSBERkEgYXQgb25jZS4gVGhlXHJcbiAqIHtAbGluayAjYWRkREZBU3RhdGV9IG1ldGhvZCBhbHNvIGxvY2tzIGluc2lkZSB0aGUgREZBIGxvY2tcclxuICogYnV0IHRoaXMgdGltZSBvbiB0aGUgc2hhcmVkIGNvbnRleHQgY2FjaGUgd2hlbiBpdCByZWJ1aWxkcyB0aGVcclxuICogY29uZmlndXJhdGlvbnMnIHtAbGluayBQcmVkaWN0aW9uQ29udGV4dH0gb2JqZWN0cyB1c2luZyBjYWNoZWRcclxuICogc3ViZ3JhcGhzL25vZGVzLiBObyBvdGhlciBsb2NraW5nIG9jY3VycywgZXZlbiBkdXJpbmcgREZBIHNpbXVsYXRpb24uIFRoaXMgaXNcclxuICogc2FmZSBhcyBsb25nIGFzIHdlIGNhbiBndWFyYW50ZWUgdGhhdCBhbGwgdGhyZWFkcyByZWZlcmVuY2luZ1xyXG4gKiBgcy5lZGdlW3RdYCBnZXQgdGhlIHNhbWUgcGh5c2ljYWwgdGFyZ2V0IHtAbGluayBERkFTdGF0ZX0sIG9yXHJcbiAqIGB1bmRlZmluZWRgLiBPbmNlIGludG8gdGhlIERGQSwgdGhlIERGQSBzaW11bGF0aW9uIGRvZXMgbm90IHJlZmVyZW5jZSB0aGVcclxuICoge0BsaW5rIERGQSNzdGF0ZXN9IG1hcC4gSXQgZm9sbG93cyB0aGUge0BsaW5rIERGQVN0YXRlI2VkZ2VzfSBmaWVsZCB0byBuZXdcclxuICogdGFyZ2V0cy4gVGhlIERGQSBzaW11bGF0b3Igd2lsbCBlaXRoZXIgZmluZCB7QGxpbmsgREZBU3RhdGUjZWRnZXN9IHRvIGJlXHJcbiAqIGB1bmRlZmluZWRgLCB0byBiZSBub24tYHVuZGVmaW5lZGAgYW5kIGBkZmEuZWRnZXNbdF1gIHVuZGVmaW5lZCwgb3JcclxuICogYGRmYS5lZGdlc1t0XWAgdG8gYmUgbm9uLXVuZGVmaW5lZC4gVGhlXHJcbiAqIHtAbGluayAjYWRkREZBRWRnZX0gbWV0aG9kIGNvdWxkIGJlIHJhY2luZyB0byBzZXQgdGhlIGZpZWxkXHJcbiAqIGJ1dCBpbiBlaXRoZXIgY2FzZSB0aGUgREZBIHNpbXVsYXRvciB3b3JrczsgaWYgYHVuZGVmaW5lZGAsIGFuZCByZXF1ZXN0cyBBVE5cclxuICogc2ltdWxhdGlvbi4gSXQgY291bGQgYWxzbyByYWNlIHRyeWluZyB0byBnZXQgYGRmYS5lZGdlc1t0XWAsIGJ1dCBlaXRoZXJcclxuICogd2F5IGl0IHdpbGwgd29yayBiZWNhdXNlIGl0J3Mgbm90IGRvaW5nIGEgdGVzdCBhbmQgc2V0IG9wZXJhdGlvbi5cclxuICpcclxuICogKipTdGFydGluZyB3aXRoIFNMTCB0aGVuIGZhaWxpbmcgdG8gY29tYmluZWQgU0xML0xMIChUd28tU3RhZ2VcclxuICogUGFyc2luZykqKlxyXG4gKlxyXG4gKiBTYW0gcG9pbnRlZCBvdXQgdGhhdCBpZiBTTEwgZG9lcyBub3QgZ2l2ZSBhIHN5bnRheCBlcnJvciwgdGhlbiB0aGVyZSBpcyBub1xyXG4gKiBwb2ludCBpbiBkb2luZyBmdWxsIExMLCB3aGljaCBpcyBzbG93ZXIuIFdlIG9ubHkgaGF2ZSB0byB0cnkgTEwgaWYgd2UgZ2V0IGFcclxuICogc3ludGF4IGVycm9yLiBGb3IgbWF4aW11bSBzcGVlZCwgU2FtIHN0YXJ0cyB0aGUgcGFyc2VyIHNldCB0byBwdXJlIFNMTFxyXG4gKiBtb2RlIHdpdGggdGhlIHtAbGluayBCYWlsRXJyb3JTdHJhdGVneX06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBwYXJzZXIuaW50ZXJwcmV0ZXIue0BsaW5rICNzZXRQcmVkaWN0aW9uTW9kZSBzZXRQcmVkaWN0aW9uTW9kZX1gKGB7QGxpbmsgUHJlZGljdGlvbk1vZGUjU0xMfWApYDtcclxuICogcGFyc2VyLntAbGluayBQYXJzZXIjc2V0RXJyb3JIYW5kbGVyIHNldEVycm9ySGFuZGxlcn0obmV3IHtAbGluayBCYWlsRXJyb3JTdHJhdGVneX0oKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBJZiBpdCBkb2VzIG5vdCBnZXQgYSBzeW50YXggZXJyb3IsIHRoZW4gd2UncmUgZG9uZS4gSWYgaXQgZG9lcyBnZXQgYSBzeW50YXhcclxuICogZXJyb3IsIHdlIG5lZWQgdG8gcmV0cnkgd2l0aCB0aGUgY29tYmluZWQgU0xML0xMIHN0cmF0ZWd5LlxyXG4gKlxyXG4gKiBUaGUgcmVhc29uIHRoaXMgd29ya3MgaXMgYXMgZm9sbG93cy4gSWYgdGhlcmUgYXJlIG5vIFNMTCBjb25mbGljdHMsIHRoZW4gdGhlXHJcbiAqIGdyYW1tYXIgaXMgU0xMIChhdCBsZWFzdCBmb3IgdGhhdCBpbnB1dCBzZXQpLiBJZiB0aGVyZSBpcyBhbiBTTEwgY29uZmxpY3QsXHJcbiAqIHRoZSBmdWxsIExMIGFuYWx5c2lzIG11c3QgeWllbGQgYSBzZXQgb2YgdmlhYmxlIGFsdGVybmF0aXZlcyB3aGljaCBpcyBhXHJcbiAqIHN1YnNldCBvZiB0aGUgYWx0ZXJuYXRpdmVzIHJlcG9ydGVkIGJ5IFNMTC4gSWYgdGhlIExMIHNldCBpcyBhIHNpbmdsZXRvbixcclxuICogdGhlbiB0aGUgZ3JhbW1hciBpcyBMTCBidXQgbm90IFNMTC4gSWYgdGhlIExMIHNldCBpcyB0aGUgc2FtZSBzaXplIGFzIHRoZSBTTExcclxuICogc2V0LCB0aGUgZGVjaXNpb24gaXMgU0xMLiBJZiB0aGUgTEwgc2V0IGhhcyBzaXplICZndDsgMSwgdGhlbiB0aGF0IGRlY2lzaW9uXHJcbiAqIGlzIHRydWx5IGFtYmlndW91cyBvbiB0aGUgY3VycmVudCBpbnB1dC4gSWYgdGhlIExMIHNldCBpcyBzbWFsbGVyLCB0aGVuIHRoZVxyXG4gKiBTTEwgY29uZmxpY3QgcmVzb2x1dGlvbiBtaWdodCBjaG9vc2UgYW4gYWx0ZXJuYXRpdmUgdGhhdCB0aGUgZnVsbCBMTCB3b3VsZFxyXG4gKiBydWxlIG91dCBhcyBhIHBvc3NpYmlsaXR5IGJhc2VkIHVwb24gYmV0dGVyIGNvbnRleHQgaW5mb3JtYXRpb24uIElmIHRoYXQnc1xyXG4gKiB0aGUgY2FzZSwgdGhlbiB0aGUgU0xMIHBhcnNlIHdpbGwgZGVmaW5pdGVseSBnZXQgYW4gZXJyb3IgYmVjYXVzZSB0aGUgZnVsbCBMTFxyXG4gKiBhbmFseXNpcyBzYXlzIGl0J3Mgbm90IHZpYWJsZS4gSWYgU0xMIGNvbmZsaWN0IHJlc29sdXRpb24gY2hvb3NlcyBhblxyXG4gKiBhbHRlcm5hdGl2ZSB3aXRoaW4gdGhlIExMIHNldCwgdGhlbSBib3RoIFNMTCBhbmQgTEwgd291bGQgY2hvb3NlIHRoZSBzYW1lXHJcbiAqIGFsdGVybmF0aXZlIGJlY2F1c2UgdGhleSBib3RoIGNob29zZSB0aGUgbWluaW11bSBvZiBtdWx0aXBsZSBjb25mbGljdGluZ1xyXG4gKiBhbHRlcm5hdGl2ZXMuXHJcbiAqXHJcbiAqIExldCdzIHNheSB3ZSBoYXZlIGEgc2V0IG9mIFNMTCBjb25mbGljdGluZyBhbHRlcm5hdGl2ZXMgYHsxLCAyLCAzfWAgYW5kXHJcbiAqIGEgc21hbGxlciBMTCBzZXQgY2FsbGVkICpzKi4gSWYgKnMqIGlzIGB7MiwgM31gLCB0aGVuIFNMTFxyXG4gKiBwYXJzaW5nIHdpbGwgZ2V0IGFuIGVycm9yIGJlY2F1c2UgU0xMIHdpbGwgcHVyc3VlIGFsdGVybmF0aXZlIDEuIElmXHJcbiAqICpzKiBpcyBgezEsIDJ9YCBvciBgezEsIDN9YCB0aGVuIGJvdGggU0xMIGFuZCBMTCB3aWxsXHJcbiAqIGNob29zZSB0aGUgc2FtZSBhbHRlcm5hdGl2ZSBiZWNhdXNlIGFsdGVybmF0aXZlIG9uZSBpcyB0aGUgbWluaW11bSBvZiBlaXRoZXJcclxuICogc2V0LiBJZiAqcyogaXMgYHsyfWAgb3IgYHszfWAgdGhlbiBTTEwgd2lsbCBnZXQgYSBzeW50YXhcclxuICogZXJyb3IuIElmICpzKiBpcyBgezF9YCB0aGVuIFNMTCB3aWxsIHN1Y2NlZWQuXHJcbiAqXHJcbiAqIE9mIGNvdXJzZSwgaWYgdGhlIGlucHV0IGlzIGludmFsaWQsIHRoZW4gd2Ugd2lsbCBnZXQgYW4gZXJyb3IgZm9yIHN1cmUgaW5cclxuICogYm90aCBTTEwgYW5kIExMIHBhcnNpbmcuIEVycm9uZW91cyBpbnB1dCB3aWxsIHRoZXJlZm9yZSByZXF1aXJlIDIgcGFzc2VzIG92ZXJcclxuICogdGhlIGlucHV0LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBhcnNlckFUTlNpbXVsYXRvciBleHRlbmRzIEFUTlNpbXVsYXRvciB7XHJcblx0cHVibGljIHN0YXRpYyBkZWJ1ZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHB1YmxpYyBzdGF0aWMgZGZhX2RlYnVnOiBib29sZWFuID0gZmFsc2U7XHJcblx0cHVibGljIHN0YXRpYyByZXRyeV9kZWJ1ZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgcHJlZGljdGlvbk1vZGU6IFByZWRpY3Rpb25Nb2RlID0gUHJlZGljdGlvbk1vZGUuTEw7XHJcblx0cHVibGljIGZvcmNlX2dsb2JhbF9jb250ZXh0OiBib29sZWFuID0gZmFsc2U7XHJcblx0cHVibGljIGFsd2F5c190cnlfbG9jYWxfY29udGV4dDogYm9vbGVhbiA9IHRydWU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZXMgd2hldGhlciB0aGUgREZBIGlzIHVzZWQgZm9yIGZ1bGwtY29udGV4dCBwcmVkaWN0aW9ucy4gV2hlblxyXG5cdCAqIGB0cnVlYCwgdGhlIERGQSBzdG9yZXMgdHJhbnNpdGlvbiBpbmZvcm1hdGlvbiBmb3IgYm90aCBmdWxsLWNvbnRleHRcclxuXHQgKiBhbmQgU0xMIHBhcnNpbmc7IG90aGVyd2lzZSwgdGhlIERGQSBvbmx5IHN0b3JlcyBTTEwgdHJhbnNpdGlvblxyXG5cdCAqIGluZm9ybWF0aW9uLlxyXG5cdCAqXHJcblx0ICogRm9yIHNvbWUgZ3JhbW1hcnMsIGVuYWJsaW5nIHRoZSBmdWxsLWNvbnRleHQgREZBIGNhbiByZXN1bHQgaW4gYVxyXG5cdCAqIHN1YnN0YW50aWFsIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LiBIb3dldmVyLCB0aGlzIGltcHJvdmVtZW50IHR5cGljYWxseVxyXG5cdCAqIGNvbWVzIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2VkIGZvciBzdG9yaW5nIHRoZSBjYWNoZWQgREZBIHN0YXRlcyxcclxuXHQgKiBjb25maWd1cmF0aW9uIHNldHMsIGFuZCBwcmVkaWN0aW9uIGNvbnRleHRzLlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cclxuXHQgKi9cclxuXHRwdWJsaWMgZW5hYmxlX2dsb2JhbF9jb250ZXh0X2RmYTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHB1YmxpYyBvcHRpbWl6ZV91bmlxdWVfY2xvc3VyZTogYm9vbGVhbiA9IHRydWU7XHJcblx0cHVibGljIG9wdGltaXplX2xsMTogYm9vbGVhbiA9IHRydWU7XHJcblx0cHVibGljIG9wdGltaXplX3RhaWxfY2FsbHM6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdHB1YmxpYyB0YWlsX2NhbGxfcHJlc2VydmVzX3NsbDogYm9vbGVhbiA9IHRydWU7XHJcblx0cHVibGljIHRyZWF0X3NsbGsxX2NvbmZsaWN0X2FzX2FtYmlndWl0eTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHRwcm90ZWN0ZWQgX3BhcnNlcjogUGFyc2VyO1xyXG5cclxuXHQvKipcclxuXHQgKiBXaGVuIGB0cnVlYCwgYW1iaWd1b3VzIGFsdGVybmF0aXZlcyBhcmUgcmVwb3J0ZWQgd2hlbiB0aGV5IGFyZVxyXG5cdCAqIGVuY291bnRlcmVkIHdpdGhpbiB7QGxpbmsgI2V4ZWNBVE59LiBXaGVuIGBmYWxzZWAsIHRoZXNlIG1lc3NhZ2VzXHJcblx0ICogYXJlIHN1cHByZXNzZWQuIFRoZSBkZWZhdWx0IGlzIGBmYWxzZWAuXHJcblx0ICpcclxuXHQgKiBXaGVuIG1lc3NhZ2VzIGFib3V0IGFtYmlndW91cyBhbHRlcm5hdGl2ZXMgYXJlIG5vdCByZXF1aXJlZCwgc2V0dGluZyB0aGlzXHJcblx0ICogdG8gYGZhbHNlYCBlbmFibGVzIGFkZGl0aW9uYWwgaW50ZXJuYWwgb3B0aW1pemF0aW9ucyB3aGljaCBtYXkgbG9zZVxyXG5cdCAqIHRoaXMgaW5mb3JtYXRpb24uXHJcblx0ICovXHJcblx0cHVibGljIHJlcG9ydEFtYmlndWl0aWVzOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdC8qKiBCeSBkZWZhdWx0IHdlIGRvIGZ1bGwgY29udGV4dC1zZW5zaXRpdmUgTEwoKikgcGFyc2luZyBub3RcclxuXHQgKiAgU3Ryb25nIExMKCopIHBhcnNpbmcuIElmIHdlIGZhaWwgd2l0aCBTdHJvbmcgTEwoKikgd2VcclxuXHQgKiAgdHJ5IGZ1bGwgTEwoKikuIFRoYXQgbWVhbnMgd2UgcmV3aW5kIGFuZCB1c2UgY29udGV4dCBpbmZvcm1hdGlvblxyXG5cdCAqICB3aGVuIGNsb3N1cmUgb3BlcmF0aW9ucyBmYWxsIG9mZiB0aGUgZW5kIG9mIHRoZSBydWxlIHRoYXRcclxuXHQgKiAgaG9sZHMgdGhlIGRlY2lzaW9uIHdlcmUgZXZhbHVhdGluZy5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgdXNlcldhbnRzQ3R4U2Vuc2l0aXZlOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcblx0cHJpdmF0ZSBkZmE/OiBERkE7XHJcblxyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIGF0bjogQVROLCBwYXJzZXI6IFBhcnNlcikge1xyXG5cdFx0c3VwZXIoYXRuKTtcclxuXHRcdHRoaXMuX3BhcnNlciA9IHBhcnNlcjtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGdldFByZWRpY3Rpb25Nb2RlKCk6IFByZWRpY3Rpb25Nb2RlIHtcclxuXHRcdHJldHVybiB0aGlzLnByZWRpY3Rpb25Nb2RlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldFByZWRpY3Rpb25Nb2RlKEBOb3ROdWxsIHByZWRpY3Rpb25Nb2RlOiBQcmVkaWN0aW9uTW9kZSk6IHZvaWQge1xyXG5cdFx0dGhpcy5wcmVkaWN0aW9uTW9kZSA9IHByZWRpY3Rpb25Nb2RlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH1cclxuXHJcblx0cHVibGljIGFkYXB0aXZlUHJlZGljdCgvKkBOb3ROdWxsKi8gaW5wdXQ6IFRva2VuU3RyZWFtLCBkZWNpc2lvbjogbnVtYmVyLCBvdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkKTogbnVtYmVyO1xyXG5cdHB1YmxpYyBhZGFwdGl2ZVByZWRpY3QoLypATm90TnVsbCovIGlucHV0OiBUb2tlblN0cmVhbSwgZGVjaXNpb246IG51bWJlciwgb3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgdXNlQ29udGV4dDogYm9vbGVhbik6IG51bWJlcjtcclxuXHRwdWJsaWMgYWRhcHRpdmVQcmVkaWN0KFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IFRva2VuU3RyZWFtLFxyXG5cdFx0ZGVjaXNpb246IG51bWJlcixcclxuXHRcdG91dGVyQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsXHJcblx0XHR1c2VDb250ZXh0PzogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRpZiAodXNlQ29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHVzZUNvbnRleHQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZGZhOiBERkEgPSB0aGlzLmF0bi5kZWNpc2lvblRvREZBW2RlY2lzaW9uXTtcclxuXHRcdGFzc2VydChkZmEgIT0gbnVsbCk7XHJcblx0XHRpZiAodGhpcy5vcHRpbWl6ZV9sbDEgJiYgIWRmYS5pc1ByZWNlZGVuY2VEZmEgJiYgIWRmYS5pc0VtcHR5KSB7XHJcblx0XHRcdGxldCBsbF8xOiBudW1iZXIgPSBpbnB1dC5MQSgxKTtcclxuXHRcdFx0aWYgKGxsXzEgPj0gMCAmJiBsbF8xIDw9IDB4RkZGRikge1xyXG5cdFx0XHRcdGxldCBrZXk6IG51bWJlciA9ICgoZGVjaXNpb24gPDwgMTYpID4+PiAwKSArIGxsXzE7XHJcblx0XHRcdFx0bGV0IGFsdDogbnVtYmVyIHwgdW5kZWZpbmVkID0gdGhpcy5hdG4uTEwxVGFibGUuZ2V0KGtleSk7XHJcblx0XHRcdFx0aWYgKGFsdCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gYWx0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGZhID0gZGZhO1xyXG5cclxuXHRcdGlmICh0aGlzLmZvcmNlX2dsb2JhbF9jb250ZXh0KSB7XHJcblx0XHRcdHVzZUNvbnRleHQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoIXRoaXMuYWx3YXlzX3RyeV9sb2NhbF9jb250ZXh0KSB7XHJcblx0XHRcdHVzZUNvbnRleHQgPSB1c2VDb250ZXh0IHx8IGRmYS5pc0NvbnRleHRTZW5zaXRpdmU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy51c2VyV2FudHNDdHhTZW5zaXRpdmUgPSB1c2VDb250ZXh0IHx8ICh0aGlzLnByZWRpY3Rpb25Nb2RlICE9PSBQcmVkaWN0aW9uTW9kZS5TTEwgJiYgb3V0ZXJDb250ZXh0ICE9IG51bGwgJiYgIXRoaXMuYXRuLmRlY2lzaW9uVG9TdGF0ZVtkZWNpc2lvbl0uc2xsKTtcclxuXHRcdGlmIChvdXRlckNvbnRleHQgPT0gbnVsbCkge1xyXG5cdFx0XHRvdXRlckNvbnRleHQgPSBQYXJzZXJSdWxlQ29udGV4dC5lbXB0eUNvbnRleHQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgc3RhdGU6IFNpbXVsYXRvclN0YXRlIHwgdW5kZWZpbmVkO1xyXG5cdFx0aWYgKCFkZmEuaXNFbXB0eSkge1xyXG5cdFx0XHRzdGF0ZSA9IHRoaXMuZ2V0U3RhcnRTdGF0ZShkZmEsIGlucHV0LCBvdXRlckNvbnRleHQsIHVzZUNvbnRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZSA9PSBudWxsKSB7XHJcblx0XHRcdGlmIChvdXRlckNvbnRleHQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdG91dGVyQ29udGV4dCA9IFBhcnNlclJ1bGVDb250ZXh0LmVtcHR5Q29udGV4dCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkFUTiBkZWNpc2lvbiBcIiArIGRmYS5kZWNpc2lvbiArXHJcblx0XHRcdFx0XHRcIiBleGVjIExBKDEpPT1cIiArIHRoaXMuZ2V0TG9va2FoZWFkTmFtZShpbnB1dCkgK1xyXG5cdFx0XHRcdFx0XCIsIG91dGVyQ29udGV4dD1cIiArIG91dGVyQ29udGV4dC50b1N0cmluZyh0aGlzLl9wYXJzZXIpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3RhdGUgPSB0aGlzLmNvbXB1dGVTdGFydFN0YXRlKGRmYSwgb3V0ZXJDb250ZXh0LCB1c2VDb250ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbTogbnVtYmVyID0gaW5wdXQubWFyaygpO1xyXG5cdFx0bGV0IGluZGV4OiBudW1iZXIgPSBpbnB1dC5pbmRleDtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGxldCBhbHQ6IG51bWJlciA9IHRoaXMuZXhlY0RGQShkZmEsIGlucHV0LCBpbmRleCwgc3RhdGUpO1xyXG5cdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJERkEgYWZ0ZXIgcHJlZGljdEFUTjogXCIgKyBkZmEudG9TdHJpbmcodGhpcy5fcGFyc2VyLnZvY2FidWxhcnksIHRoaXMuX3BhcnNlci5ydWxlTmFtZXMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gYWx0O1xyXG5cdFx0fVxyXG5cdFx0ZmluYWxseSB7XHJcblx0XHRcdHRoaXMuZGZhID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRpbnB1dC5zZWVrKGluZGV4KTtcclxuXHRcdFx0aW5wdXQucmVsZWFzZShtKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRTdGFydFN0YXRlKFxyXG5cdFx0QE5vdE51bGwgZGZhOiBERkEsXHJcblx0XHRATm90TnVsbCBpbnB1dDogVG9rZW5TdHJlYW0sXHJcblx0XHRATm90TnVsbCBvdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0LFxyXG5cdFx0dXNlQ29udGV4dDogYm9vbGVhbik6IFNpbXVsYXRvclN0YXRlIHwgdW5kZWZpbmVkIHtcclxuXHJcblx0XHRpZiAoIXVzZUNvbnRleHQpIHtcclxuXHRcdFx0aWYgKGRmYS5pc1ByZWNlZGVuY2VEZmEpIHtcclxuXHRcdFx0XHQvLyB0aGUgc3RhcnQgc3RhdGUgZm9yIGEgcHJlY2VkZW5jZSBERkEgZGVwZW5kcyBvbiB0aGUgY3VycmVudFxyXG5cdFx0XHRcdC8vIHBhcnNlciBwcmVjZWRlbmNlLCBhbmQgaXMgcHJvdmlkZWQgYnkgYSBERkEgbWV0aG9kLlxyXG5cdFx0XHRcdGxldCBzdGF0ZTogREZBU3RhdGUgfCB1bmRlZmluZWQgPSBkZmEuZ2V0UHJlY2VkZW5jZVN0YXJ0U3RhdGUodGhpcy5fcGFyc2VyLnByZWNlZGVuY2UsIGZhbHNlKTtcclxuXHRcdFx0XHRpZiAoc3RhdGUgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBuZXcgU2ltdWxhdG9yU3RhdGUob3V0ZXJDb250ZXh0LCBzdGF0ZSwgZmFsc2UsIG91dGVyQ29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0aWYgKGRmYS5zMCA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIG5ldyBTaW11bGF0b3JTdGF0ZShvdXRlckNvbnRleHQsIGRmYS5zMCwgZmFsc2UsIG91dGVyQ29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuZW5hYmxlX2dsb2JhbF9jb250ZXh0X2RmYSkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZW1haW5pbmdDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCA9IG91dGVyQ29udGV4dDtcclxuXHRcdGFzc2VydChvdXRlckNvbnRleHQgIT0gbnVsbCk7XHJcblx0XHRsZXQgczA6IERGQVN0YXRlIHwgdW5kZWZpbmVkO1xyXG5cdFx0aWYgKGRmYS5pc1ByZWNlZGVuY2VEZmEpIHtcclxuXHRcdFx0czAgPSBkZmEuZ2V0UHJlY2VkZW5jZVN0YXJ0U3RhdGUodGhpcy5fcGFyc2VyLnByZWNlZGVuY2UsIHRydWUpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHMwID0gZGZhLnMwZnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR3aGlsZSAocmVtYWluaW5nQ29udGV4dCAhPSBudWxsICYmIHMwICE9IG51bGwgJiYgczAuaXNDb250ZXh0U2Vuc2l0aXZlKSB7XHJcblx0XHRcdHJlbWFpbmluZ0NvbnRleHQgPSB0aGlzLnNraXBUYWlsQ2FsbHMocmVtYWluaW5nQ29udGV4dCk7XHJcblx0XHRcdHMwID0gczAuZ2V0Q29udGV4dFRhcmdldCh0aGlzLmdldFJldHVyblN0YXRlKHJlbWFpbmluZ0NvbnRleHQpKTtcclxuXHRcdFx0aWYgKHJlbWFpbmluZ0NvbnRleHQuaXNFbXB0eSkge1xyXG5cdFx0XHRcdGFzc2VydChzMCA9PSBudWxsIHx8ICFzMC5pc0NvbnRleHRTZW5zaXRpdmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHJlbWFpbmluZ0NvbnRleHQgPSByZW1haW5pbmdDb250ZXh0LnBhcmVudDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzMCA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBTaW11bGF0b3JTdGF0ZShvdXRlckNvbnRleHQsIHMwLCB1c2VDb250ZXh0LCByZW1haW5pbmdDb250ZXh0KTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBleGVjREZBKFxyXG5cdFx0QE5vdE51bGwgZGZhOiBERkEsXHJcblx0XHRATm90TnVsbCBpbnB1dDogVG9rZW5TdHJlYW0sIHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdEBOb3ROdWxsIHN0YXRlOiBTaW11bGF0b3JTdGF0ZSk6IG51bWJlciB7XHJcblx0XHRsZXQgb3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCA9IHN0YXRlLm91dGVyQ29udGV4dDtcclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGZhX2RlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiREZBIGRlY2lzaW9uIFwiICsgZGZhLmRlY2lzaW9uICtcclxuXHRcdFx0XHRcIiBleGVjIExBKDEpPT1cIiArIHRoaXMuZ2V0TG9va2FoZWFkTmFtZShpbnB1dCkgK1xyXG5cdFx0XHRcdFwiLCBvdXRlckNvbnRleHQ9XCIgKyBvdXRlckNvbnRleHQudG9TdHJpbmcodGhpcy5fcGFyc2VyKSk7XHJcblx0XHR9XHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRmYV9kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhkZmEudG9TdHJpbmcodGhpcy5fcGFyc2VyLnZvY2FidWxhcnksIHRoaXMuX3BhcnNlci5ydWxlTmFtZXMpKTtcclxuXHRcdH1cclxuXHRcdGxldCBzOiBERkFTdGF0ZSA9IHN0YXRlLnMwO1xyXG5cclxuXHRcdGxldCB0OiBudW1iZXIgPSBpbnB1dC5MQSgxKTtcclxuXHRcdGxldCByZW1haW5pbmdPdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkID0gc3RhdGUucmVtYWluaW5nT3V0ZXJDb250ZXh0O1xyXG5cclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGZhX2RlYnVnKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJERkEgc3RhdGUgXCIgKyBzLnN0YXRlTnVtYmVyICsgXCIgTEEoMSk9PVwiICsgdGhpcy5nZXRMb29rYWhlYWROYW1lKGlucHV0KSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHN0YXRlLnVzZUNvbnRleHQpIHtcclxuXHRcdFx0XHR3aGlsZSAocy5pc0NvbnRleHRTeW1ib2wodCkpIHtcclxuXHRcdFx0XHRcdGxldCBuZXh0OiBERkFTdGF0ZSB8IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdGlmIChyZW1haW5pbmdPdXRlckNvbnRleHQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRyZW1haW5pbmdPdXRlckNvbnRleHQgPSB0aGlzLnNraXBUYWlsQ2FsbHMocmVtYWluaW5nT3V0ZXJDb250ZXh0KTtcclxuXHRcdFx0XHRcdFx0bmV4dCA9IHMuZ2V0Q29udGV4dFRhcmdldCh0aGlzLmdldFJldHVyblN0YXRlKHJlbWFpbmluZ091dGVyQ29udGV4dCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChuZXh0ID09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0Ly8gZmFpbCBvdmVyIHRvIEFUTlxyXG5cdFx0XHRcdFx0XHRsZXQgaW5pdGlhbFN0YXRlOiBTaW11bGF0b3JTdGF0ZSA9IG5ldyBTaW11bGF0b3JTdGF0ZShzdGF0ZS5vdXRlckNvbnRleHQsIHMsIHN0YXRlLnVzZUNvbnRleHQsIHJlbWFpbmluZ091dGVyQ29udGV4dCk7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmV4ZWNBVE4oZGZhLCBpbnB1dCwgc3RhcnRJbmRleCwgaW5pdGlhbFN0YXRlKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRhc3NlcnQocmVtYWluaW5nT3V0ZXJDb250ZXh0ICE9IG51bGwpO1xyXG5cdFx0XHRcdFx0cmVtYWluaW5nT3V0ZXJDb250ZXh0ID0gcmVtYWluaW5nT3V0ZXJDb250ZXh0LnBhcmVudDtcclxuXHRcdFx0XHRcdHMgPSBuZXh0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXMuaXNBY2NlcHRTdGF0ZShzLCBzdGF0ZS51c2VDb250ZXh0KSkge1xyXG5cdFx0XHRcdGlmIChzLnByZWRpY2F0ZXMgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZmFfZGVidWcpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJhY2NlcHQgXCIgKyBzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRmYV9kZWJ1Zykge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImFjY2VwdDsgcHJlZGljdCBcIiArIHMucHJlZGljdGlvbiArIFwiIGluIHN0YXRlIFwiICsgcy5zdGF0ZU51bWJlcik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBrZWVwIGdvaW5nIHVubGVzcyB3ZSdyZSBhdCBFT0Ygb3Igc3RhdGUgb25seSBoYXMgb25lIGFsdCBudW1iZXJcclxuXHRcdFx0XHQvLyBtZW50aW9uZWQgaW4gY29uZmlnczsgY2hlY2sgaWYgc29tZXRoaW5nIGVsc2UgY291bGQgbWF0Y2hcclxuXHRcdFx0XHQvLyBUT0RPOiBkb24ndCB3ZSBhbHdheXMgc3RvcD8gb25seSBsZXhlciB3b3VsZCBrZWVwIGdvaW5nXHJcblx0XHRcdFx0Ly8gVE9ETzogdjMgZGZhIGRvbid0IGRvIHRoaXMuXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHQgaXMgbm90IHVwZGF0ZWQgaWYgb25lIG9mIHRoZXNlIHN0YXRlcyBpcyByZWFjaGVkXHJcblx0XHRcdGFzc2VydCghdGhpcy5pc0FjY2VwdFN0YXRlKHMsIHN0YXRlLnVzZUNvbnRleHQpKTtcclxuXHJcblx0XHRcdC8vIGlmIG5vIGVkZ2UsIHBvcCBvdmVyIHRvIEFUTiBpbnRlcnByZXRlciwgdXBkYXRlIERGQSBhbmQgcmV0dXJuXHJcblx0XHRcdGxldCB0YXJnZXQ6IERGQVN0YXRlIHwgdW5kZWZpbmVkID0gdGhpcy5nZXRFeGlzdGluZ1RhcmdldFN0YXRlKHMsIHQpO1xyXG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcclxuXHRcdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRmYV9kZWJ1ZyAmJiB0ID49IDApIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwibm8gZWRnZSBmb3IgXCIgKyB0aGlzLl9wYXJzZXIudm9jYWJ1bGFyeS5nZXREaXNwbGF5TmFtZSh0KSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxldCBhbHQ6IG51bWJlcjtcclxuXHRcdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRmYV9kZWJ1Zykge1xyXG5cdFx0XHRcdFx0bGV0IGludGVydmFsOiBJbnRlcnZhbCA9IEludGVydmFsLm9mKHN0YXJ0SW5kZXgsIHRoaXMuX3BhcnNlci5pbnB1dFN0cmVhbS5pbmRleCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkFUTiBleGVjIHVwb24gXCIgK1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9wYXJzZXIuaW5wdXRTdHJlYW0uZ2V0VGV4dChpbnRlcnZhbCkgK1xyXG5cdFx0XHRcdFx0XHRcIiBhdCBERkEgc3RhdGUgXCIgKyBzLnN0YXRlTnVtYmVyKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBpbml0aWFsU3RhdGU6IFNpbXVsYXRvclN0YXRlID0gbmV3IFNpbXVsYXRvclN0YXRlKG91dGVyQ29udGV4dCwgcywgc3RhdGUudXNlQ29udGV4dCwgcmVtYWluaW5nT3V0ZXJDb250ZXh0KTtcclxuXHRcdFx0XHRhbHQgPSB0aGlzLmV4ZWNBVE4oZGZhLCBpbnB1dCwgc3RhcnRJbmRleCwgaW5pdGlhbFN0YXRlKTtcclxuXHRcdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRmYV9kZWJ1Zykge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJiYWNrIGZyb20gREZBIHVwZGF0ZSwgYWx0PVwiICsgYWx0ICsgXCIsIGRmYT1cXG5cIiArIGRmYS50b1N0cmluZyh0aGlzLl9wYXJzZXIudm9jYWJ1bGFyeSwgdGhpcy5fcGFyc2VyLnJ1bGVOYW1lcykpO1xyXG5cdFx0XHRcdFx0Ly9kdW1wKGRmYSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIGFjdGlvbiBhbHJlYWR5IGV4ZWN1dGVkXHJcblx0XHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZmFfZGVidWcpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiREZBIGRlY2lzaW9uIFwiICsgZGZhLmRlY2lzaW9uICtcclxuXHRcdFx0XHRcdFx0XCIgcHJlZGljdHMgXCIgKyBhbHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gYWx0OyAvLyB3ZSd2ZSB1cGRhdGVkIERGQSwgZXhlYydkIGFjdGlvbiwgYW5kIGhhdmUgb3VyIGRlZXBlc3QgYW5zd2VyXHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAodGFyZ2V0ID09PSBBVE5TaW11bGF0b3IuRVJST1IpIHtcclxuXHRcdFx0XHRsZXQgZXJyb3JTdGF0ZTogU2ltdWxhdG9yU3RhdGUgPSBuZXcgU2ltdWxhdG9yU3RhdGUob3V0ZXJDb250ZXh0LCBzLCBzdGF0ZS51c2VDb250ZXh0LCByZW1haW5pbmdPdXRlckNvbnRleHQpO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmhhbmRsZU5vVmlhYmxlQWx0KGlucHV0LCBzdGFydEluZGV4LCBlcnJvclN0YXRlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzID0gdGFyZ2V0O1xyXG5cdFx0XHRpZiAoIXRoaXMuaXNBY2NlcHRTdGF0ZShzLCBzdGF0ZS51c2VDb250ZXh0KSAmJiB0ICE9PSBJbnRTdHJlYW0uRU9GKSB7XHJcblx0XHRcdFx0aW5wdXQuY29uc3VtZSgpO1xyXG5cdFx0XHRcdHQgPSBpbnB1dC5MQSgxKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG4vL1x0XHRpZiAoIGFjY2VwdFN0YXRlPT1udWxsICkge1xyXG4vL1x0XHRcdGlmICggZGVidWcgKSBTeXN0ZW0ub3V0LnByaW50bG4oXCIhISEgbm8gdmlhYmxlIGFsdCBpbiBkZmFcIik7XHJcbi8vXHRcdFx0cmV0dXJuIC0xO1xyXG4vL1x0XHR9XHJcblxyXG5cdFx0aWYgKCFzdGF0ZS51c2VDb250ZXh0ICYmIHMuY29uZmlncy5jb25mbGljdEluZm8gIT0gbnVsbCkge1xyXG5cdFx0XHRpZiAoZGZhLmF0blN0YXJ0U3RhdGUgaW5zdGFuY2VvZiBEZWNpc2lvblN0YXRlKSB7XHJcblx0XHRcdFx0aWYgKCF0aGlzLnVzZXJXYW50c0N0eFNlbnNpdGl2ZSB8fFxyXG5cdFx0XHRcdFx0KCFzLmNvbmZpZ3MuZGlwc0ludG9PdXRlckNvbnRleHQgJiYgcy5jb25maWdzLmlzRXhhY3RDb25mbGljdCkgfHxcclxuXHRcdFx0XHRcdCh0aGlzLnRyZWF0X3NsbGsxX2NvbmZsaWN0X2FzX2FtYmlndWl0eSAmJiBpbnB1dC5pbmRleCA9PT0gc3RhcnRJbmRleCkpIHtcclxuXHRcdFx0XHRcdC8vIHdlIGRvbid0IHJlcG9ydCB0aGUgYW1iaWd1aXR5IGFnYWluXHJcblx0XHRcdFx0XHQvL2lmICggIXRoaXMuYWNjZXB0U3RhdGUuY29uZmlnc2V0Lmhhc1NlbWFudGljQ29udGV4dCApIHtcclxuXHRcdFx0XHRcdC8vIFx0dGhpcy5yZXBvcnRBbWJpZ3VpdHkoZGZhLCBhY2NlcHRTdGF0ZSwgc3RhcnRJbmRleCwgaW5wdXQuaW5kZXgsIGFjY2VwdFN0YXRlLmNvbmZpZ3NldC5jb25mbGljdGluZ0FsdHMsIGFjY2VwdFN0YXRlLmNvbmZpZ3NldCk7XHJcblx0XHRcdFx0XHQvL31cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRhc3NlcnQoIXN0YXRlLnVzZUNvbnRleHQpO1xyXG5cclxuXHRcdFx0XHRcdC8vIEJlZm9yZSBhdHRlbXB0aW5nIGZ1bGwgY29udGV4dCBwcmVkaWN0aW9uLCBjaGVjayB0byBzZWUgaWYgdGhlcmUgYXJlXHJcblx0XHRcdFx0XHQvLyBkaXNhbWJpZ3VhdGluZyBvciB2YWxpZGF0aW5nIHByZWRpY2F0ZXMgdG8gZXZhbHVhdGUgd2hpY2ggYWxsb3cgYW5cclxuXHRcdFx0XHRcdC8vIGltbWVkaWF0ZSBkZWNpc2lvblxyXG5cdFx0XHRcdFx0bGV0IGNvbmZsaWN0aW5nQWx0czogQml0U2V0IHwgdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0bGV0IHByZWRpY2F0ZXM6IERGQVN0YXRlLlByZWRQcmVkaWN0aW9uW10gfCB1bmRlZmluZWQgPSBzLnByZWRpY2F0ZXM7XHJcblx0XHRcdFx0XHRpZiAocHJlZGljYXRlcyAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdGxldCBjb25mbGljdEluZGV4OiBudW1iZXIgPSBpbnB1dC5pbmRleDtcclxuXHRcdFx0XHRcdFx0aWYgKGNvbmZsaWN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHRpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRjb25mbGljdGluZ0FsdHMgPSB0aGlzLmV2YWxTZW1hbnRpY0NvbnRleHQocHJlZGljYXRlcywgb3V0ZXJDb250ZXh0LCB0cnVlKTtcclxuXHRcdFx0XHRcdFx0aWYgKGNvbmZsaWN0aW5nQWx0cy5jYXJkaW5hbGl0eSgpID09PSAxKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbmZsaWN0aW5nQWx0cy5uZXh0U2V0Qml0KDApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoY29uZmxpY3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIHJlc3RvcmUgdGhlIGluZGV4IHNvIHJlcG9ydGluZyB0aGUgZmFsbGJhY2sgdG8gZnVsbFxyXG5cdFx0XHRcdFx0XHRcdC8vIGNvbnRleHQgb2NjdXJzIHdpdGggdGhlIGluZGV4IGF0IHRoZSBjb3JyZWN0IHNwb3RcclxuXHRcdFx0XHRcdFx0XHRpbnB1dC5zZWVrKGNvbmZsaWN0SW5kZXgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMucmVwb3J0QW1iaWd1aXRpZXMpIHtcclxuXHRcdFx0XHRcdFx0bGV0IGNvbmZsaWN0U3RhdGU6IFNpbXVsYXRvclN0YXRlID0gbmV3IFNpbXVsYXRvclN0YXRlKG91dGVyQ29udGV4dCwgcywgc3RhdGUudXNlQ29udGV4dCwgcmVtYWluaW5nT3V0ZXJDb250ZXh0KTtcclxuXHRcdFx0XHRcdFx0dGhpcy5yZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQoZGZhLCBjb25mbGljdGluZ0FsdHMsIGNvbmZsaWN0U3RhdGUsIHN0YXJ0SW5kZXgsIGlucHV0LmluZGV4KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWRhcHRpdmVQcmVkaWN0KGlucHV0LCBkZmEuZGVjaXNpb24sIG91dGVyQ29udGV4dCwgdHJ1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQmVmb3JlIGp1bXBpbmcgdG8gcHJlZGljdGlvbiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGFyZVxyXG5cdFx0Ly8gZGlzYW1iaWd1YXRpbmcgb3IgdmFsaWRhdGluZyBwcmVkaWNhdGVzIHRvIGV2YWx1YXRlXHJcblx0XHRsZXQgcHJlZGljYXRlczogREZBU3RhdGUuUHJlZFByZWRpY3Rpb25bXSB8IHVuZGVmaW5lZCA9IHMucHJlZGljYXRlcztcclxuXHRcdGlmIChwcmVkaWNhdGVzICE9IG51bGwpIHtcclxuXHRcdFx0bGV0IHN0b3BJbmRleDogbnVtYmVyID0gaW5wdXQuaW5kZXg7XHJcblx0XHRcdGlmIChzdGFydEluZGV4ICE9PSBzdG9wSW5kZXgpIHtcclxuXHRcdFx0XHRpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgYWx0czogQml0U2V0ID0gdGhpcy5ldmFsU2VtYW50aWNDb250ZXh0KHByZWRpY2F0ZXMsIG91dGVyQ29udGV4dCwgdGhpcy5yZXBvcnRBbWJpZ3VpdGllcyAmJiB0aGlzLnByZWRpY3Rpb25Nb2RlID09PSBQcmVkaWN0aW9uTW9kZS5MTF9FWEFDVF9BTUJJR19ERVRFQ1RJT04pO1xyXG5cdFx0XHRzd2l0Y2ggKGFsdHMuY2FyZGluYWxpdHkoKSkge1xyXG5cdFx0XHRjYXNlIDA6XHJcblx0XHRcdFx0dGhyb3cgdGhpcy5ub1ZpYWJsZUFsdChpbnB1dCwgb3V0ZXJDb250ZXh0LCBzLmNvbmZpZ3MsIHN0YXJ0SW5kZXgpO1xyXG5cclxuXHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdHJldHVybiBhbHRzLm5leHRTZXRCaXQoMCk7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdC8vIHJlcG9ydCBhbWJpZ3VpdHkgYWZ0ZXIgcHJlZGljYXRlIGV2YWx1YXRpb24gdG8gbWFrZSBzdXJlIHRoZSBjb3JyZWN0XHJcblx0XHRcdFx0Ly8gc2V0IG9mIGFtYmlnIGFsdHMgaXMgcmVwb3J0ZWQuXHJcblx0XHRcdFx0aWYgKHN0YXJ0SW5kZXggIT09IHN0b3BJbmRleCkge1xyXG5cdFx0XHRcdFx0aW5wdXQuc2VlayhzdG9wSW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5yZXBvcnRBbWJpZ3VpdHkoZGZhLCBzLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHMuY29uZmlncy5pc0V4YWN0Q29uZmxpY3QsIGFsdHMsIHMuY29uZmlncyk7XHJcblx0XHRcdFx0cmV0dXJuIGFsdHMubmV4dFNldEJpdCgwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGZhX2RlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiREZBIGRlY2lzaW9uIFwiICsgZGZhLmRlY2lzaW9uICtcclxuXHRcdFx0XHRcIiBwcmVkaWN0cyBcIiArIHMucHJlZGljdGlvbik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcy5wcmVkaWN0aW9uO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lcyBpZiBhIHBhcnRpY3VsYXIgREZBIHN0YXRlIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFuIGFjY2VwdCBzdGF0ZVxyXG5cdCAqIGZvciB0aGUgY3VycmVudCBwcmVkaWN0aW9uIG1vZGUuIEluIGFkZGl0aW9uIHRvIHRoZSBgdXNlQ29udGV4dGBcclxuXHQgKiBwYXJhbWV0ZXIsIHRoZSB7QGxpbmsgI2dldFByZWRpY3Rpb25Nb2RlKCl9IG1ldGhvZCBwcm92aWRlcyB0aGVcclxuXHQgKiBwcmVkaWN0aW9uIG1vZGUgY29udHJvbGxpbmcgdGhlIHByZWRpY3Rpb24gYWxnb3JpdGhtIGFzIGEgd2hvbGUuXHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW1wbHkgcmV0dXJucyB0aGUgdmFsdWUgb2ZcclxuXHQgKiBgREZBU3RhdGUuaXNBY2NlcHRTdGF0ZWAgZXhjZXB0IGZvciBjb25mbGljdCBzdGF0ZXMgd2hlblxyXG5cdCAqIGB1c2VDb250ZXh0YCBpcyBgdHJ1ZWAgYW5kIHtAbGluayAjZ2V0UHJlZGljdGlvbk1vZGUoKX0gaXNcclxuXHQgKiB7QGxpbmsgUHJlZGljdGlvbk1vZGUjTExfRVhBQ1RfQU1CSUdfREVURUNUSU9OfS4gSW4gdGhhdCBjYXNlLCBvbmx5XHJcblx0ICogY29uZmxpY3Qgc3RhdGVzIHdoZXJlIHtAbGluayBBVE5Db25maWdTZXQjaXNFeGFjdENvbmZsaWN0fSBpc1xyXG5cdCAqIGB0cnVlYCBhcmUgY29uc2lkZXJlZCBhY2NlcHQgc3RhdGVzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHN0YXRlIFRoZSBERkEgc3RhdGUgdG8gY2hlY2suXHJcblx0ICogQHBhcmFtIHVzZUNvbnRleHQgYHRydWVgIGlmIHRoZSBwcmVkaWN0aW9uIGFsZ29yaXRobSBpcyBjdXJyZW50bHlcclxuXHQgKiBjb25zaWRlcmluZyB0aGUgZnVsbCBwYXJzZXIgY29udGV4dDsgb3RoZXJ3aXNlLCBgZmFsc2VgIGlmIHRoZVxyXG5cdCAqIGFsZ29yaXRobSBpcyBjdXJyZW50bHkgcGVyZm9ybWluZyBhIGxvY2FsIGNvbnRleHQgcHJlZGljdGlvbi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIGBzdGF0ZWAgaXMgYW4gYWNjZXB0IHN0YXRlO1xyXG5cdCAqIG90aGVyd2lzZSwgYGZhbHNlYC5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgaXNBY2NlcHRTdGF0ZShzdGF0ZTogREZBU3RhdGUsIHVzZUNvbnRleHQ6IGJvb2xlYW4pOiBib29sZWFuIHtcclxuXHRcdGlmICghc3RhdGUuaXNBY2NlcHRTdGF0ZSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0YXRlLmNvbmZpZ3MuY29uZmxpY3RpbmdBbHRzID09IG51bGwpIHtcclxuXHRcdFx0Ly8gdW5hbWJpZ3VvdXNcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTW9yZSBwaWNreSB3aGVuIHdlIG5lZWQgZXhhY3QgY29uZmxpY3RzXHJcblx0XHRpZiAodXNlQ29udGV4dCAmJiB0aGlzLnByZWRpY3Rpb25Nb2RlID09PSBQcmVkaWN0aW9uTW9kZS5MTF9FWEFDVF9BTUJJR19ERVRFQ1RJT04pIHtcclxuXHRcdFx0cmV0dXJuIHN0YXRlLmNvbmZpZ3MuaXNFeGFjdENvbmZsaWN0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqIFBlcmZvcm1zIEFUTiBzaW11bGF0aW9uIHRvIGNvbXB1dGUgYSBwcmVkaWN0ZWQgYWx0ZXJuYXRpdmUgYmFzZWRcclxuXHQgKiAgdXBvbiB0aGUgcmVtYWluaW5nIGlucHV0LCBidXQgYWxzbyB1cGRhdGVzIHRoZSBERkEgY2FjaGUgdG8gYXZvaWRcclxuXHQgKiAgaGF2aW5nIHRvIHRyYXZlcnNlIHRoZSBBVE4gYWdhaW4gZm9yIHRoZSBzYW1lIGlucHV0IHNlcXVlbmNlLlxyXG5cdCAqXHJcblx0ICogVGhlcmUgYXJlIHNvbWUga2V5IGNvbmRpdGlvbnMgd2UncmUgbG9va2luZyBmb3IgYWZ0ZXIgY29tcHV0aW5nIGEgbmV3XHJcblx0ICogc2V0IG9mIEFUTiBjb25maWdzIChwcm9wb3NlZCBERkEgc3RhdGUpOlxyXG5cdCAqXHJcblx0ICogKiBpZiB0aGUgc2V0IGlzIGVtcHR5LCB0aGVyZSBpcyBubyB2aWFibGUgYWx0ZXJuYXRpdmUgZm9yIGN1cnJlbnQgc3ltYm9sXHJcblx0ICogKiBkb2VzIHRoZSBzdGF0ZSB1bmlxdWVseSBwcmVkaWN0IGFuIGFsdGVybmF0aXZlP1xyXG5cdCAqICogZG9lcyB0aGUgc3RhdGUgaGF2ZSBhIGNvbmZsaWN0IHRoYXQgd291bGQgcHJldmVudCB1cyBmcm9tXHJcblx0ICogICBwdXR0aW5nIGl0IG9uIHRoZSB3b3JrIGxpc3Q/XHJcblx0ICogKiBpZiBpbiBub24tZ3JlZWR5IGRlY2lzaW9uIGlzIHRoZXJlIGEgY29uZmlnIGF0IGEgcnVsZSBzdG9wIHN0YXRlP1xyXG5cdCAqXHJcblx0ICogV2UgYWxzbyBoYXZlIHNvbWUga2V5IG9wZXJhdGlvbnMgdG8gZG86XHJcblx0ICpcclxuXHQgKiAqIGFkZCBhbiBlZGdlIGZyb20gcHJldmlvdXMgREZBIHN0YXRlIHRvIHBvdGVudGlhbGx5IG5ldyBERkEgc3RhdGUsIEQsXHJcblx0ICogICB1cG9uIGN1cnJlbnQgc3ltYm9sIGJ1dCBvbmx5IGlmIGFkZGluZyB0byB3b3JrIGxpc3QsIHdoaWNoIG1lYW5zIGluIGFsbFxyXG5cdCAqICAgY2FzZXMgZXhjZXB0IG5vIHZpYWJsZSBhbHRlcm5hdGl2ZSAoYW5kIHBvc3NpYmx5IG5vbi1ncmVlZHkgZGVjaXNpb25zPylcclxuXHQgKiAqIGNvbGxlY3RpbmcgcHJlZGljYXRlcyBhbmQgYWRkaW5nIHNlbWFudGljIGNvbnRleHQgdG8gREZBIGFjY2VwdCBzdGF0ZXNcclxuXHQgKiAqIGFkZGluZyBydWxlIGNvbnRleHQgdG8gY29udGV4dC1zZW5zaXRpdmUgREZBIGFjY2VwdCBzdGF0ZXNcclxuXHQgKiAqIGNvbnN1bWluZyBhbiBpbnB1dCBzeW1ib2xcclxuXHQgKiAqIHJlcG9ydGluZyBhIGNvbmZsaWN0XHJcblx0ICogKiByZXBvcnRpbmcgYW4gYW1iaWd1aXR5XHJcblx0ICogKiByZXBvcnRpbmcgYSBjb250ZXh0IHNlbnNpdGl2aXR5XHJcblx0ICogKiByZXBvcnRpbmcgaW5zdWZmaWNpZW50IHByZWRpY2F0ZXNcclxuXHQgKlxyXG5cdCAqIFdlIHNob3VsZCBpc29sYXRlIHRob3NlIG9wZXJhdGlvbnMsIHdoaWNoIGFyZSBzaWRlLWVmZmVjdGluZywgdG8gdGhlXHJcblx0ICogbWFpbiB3b3JrIGxvb3AuIFdlIGNhbiBpc29sYXRlIGxvdHMgb2YgY29kZSBpbnRvIG90aGVyIGZ1bmN0aW9ucywgYnV0XHJcblx0ICogdGhleSBzaG91bGQgYmUgc2lkZSBlZmZlY3QgZnJlZS4gVGhleSBjYW4gcmV0dXJuIHBhY2thZ2UgdGhhdFxyXG5cdCAqIGluZGljYXRlcyB3aGV0aGVyIHdlIHNob3VsZCByZXBvcnQgc29tZXRoaW5nLCB3aGV0aGVyIHdlIG5lZWQgdG8gYWRkIGFcclxuXHQgKiBERkEgZWRnZSwgd2hldGhlciB3ZSBuZWVkIHRvIGF1Z21lbnQgYWNjZXB0IHN0YXRlIHdpdGggc2VtYW50aWNcclxuXHQgKiBjb250ZXh0IG9yIHJ1bGUgaW52b2NhdGlvbiBjb250ZXh0LiBBY3R1YWxseSwgaXQgc2VlbXMgbGlrZSB3ZSBhbHdheXNcclxuXHQgKiBhZGQgcHJlZGljYXRlcyBpZiB0aGV5IGV4aXN0LCBzbyB0aGF0IGNhbiBzaW1wbHkgYmUgZG9uZSBpbiB0aGUgbWFpblxyXG5cdCAqIGxvb3AgZm9yIGFueSBhY2NlcHQgc3RhdGUgY3JlYXRpb24gb3IgbW9kaWZpY2F0aW9uIHJlcXVlc3QuXHJcblx0ICpcclxuXHQgKiBjb3ZlciB0aGVzZSBjYXNlczpcclxuXHQgKiAgIGRlYWQgZW5kXHJcblx0ICogICBzaW5nbGUgYWx0XHJcblx0ICogICBzaW5nbGUgYWx0ICsgcHJlZHNcclxuXHQgKiAgIGNvbmZsaWN0XHJcblx0ICogICBjb25mbGljdCArIHByZWRzXHJcblx0ICpcclxuXHQgKiBUT0RPOiBncmVlZHkgKyB0aG9zZVxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBleGVjQVROKFxyXG5cdFx0QE5vdE51bGwgZGZhOiBERkEsXHJcblx0XHRATm90TnVsbCBpbnB1dDogVG9rZW5TdHJlYW0sIHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdEBOb3ROdWxsIGluaXRpYWxTdGF0ZTogU2ltdWxhdG9yU3RhdGUpOiBudW1iZXIge1xyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcImV4ZWNBVE4gZGVjaXNpb24gXCIgKyBkZmEuZGVjaXNpb24gKyBcIiBleGVjIExBKDEpPT1cIiArIHRoaXMuZ2V0TG9va2FoZWFkTmFtZShpbnB1dCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBvdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0ID0gaW5pdGlhbFN0YXRlLm91dGVyQ29udGV4dDtcclxuXHRcdGxldCB1c2VDb250ZXh0OiBib29sZWFuID0gaW5pdGlhbFN0YXRlLnVzZUNvbnRleHQ7XHJcblxyXG5cdFx0bGV0IHQ6IG51bWJlciA9IGlucHV0LkxBKDEpO1xyXG5cclxuXHRcdGxldCBwcmV2aW91czogU2ltdWxhdG9yU3RhdGUgPSBpbml0aWFsU3RhdGU7XHJcblxyXG5cdFx0bGV0IGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSA9IG5ldyBQcmVkaWN0aW9uQ29udGV4dENhY2hlKCk7XHJcblx0XHR3aGlsZSAodHJ1ZSkgeyAvLyB3aGlsZSBtb3JlIHdvcmtcclxuXHRcdFx0bGV0IG5leHRTdGF0ZTogU2ltdWxhdG9yU3RhdGUgfCB1bmRlZmluZWQgPSB0aGlzLmNvbXB1dGVSZWFjaFNldChkZmEsIHByZXZpb3VzLCB0LCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRpZiAobmV4dFN0YXRlID09IG51bGwpIHtcclxuXHRcdFx0XHR0aGlzLnNldERGQUVkZ2UocHJldmlvdXMuczAsIGlucHV0LkxBKDEpLCBBVE5TaW11bGF0b3IuRVJST1IpO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmhhbmRsZU5vVmlhYmxlQWx0KGlucHV0LCBzdGFydEluZGV4LCBwcmV2aW91cyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBEOiBERkFTdGF0ZSA9IG5leHRTdGF0ZS5zMDtcclxuXHJcblx0XHRcdC8vIHByZWRpY3RlZCBhbHQgPT4gYWNjZXB0IHN0YXRlXHJcblx0XHRcdGFzc2VydChELmlzQWNjZXB0U3RhdGUgfHwgRC5wcmVkaWN0aW9uID09PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSKTtcclxuXHRcdFx0Ly8gY29uZmxpY3RlZCA9PiBhY2NlcHQgc3RhdGVcclxuXHRcdFx0YXNzZXJ0KEQuaXNBY2NlcHRTdGF0ZSB8fCBELmNvbmZpZ3MuY29uZmxpY3RJbmZvID09IG51bGwpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuaXNBY2NlcHRTdGF0ZShELCB1c2VDb250ZXh0KSkge1xyXG5cdFx0XHRcdGxldCBjb25mbGljdGluZ0FsdHM6IEJpdFNldCB8IHVuZGVmaW5lZCA9IEQuY29uZmlncy5jb25mbGljdGluZ0FsdHM7XHJcblx0XHRcdFx0bGV0IHByZWRpY3RlZEFsdDogbnVtYmVyID0gY29uZmxpY3RpbmdBbHRzID09IG51bGwgPyBELnByZWRpY3Rpb24gOiBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xyXG5cdFx0XHRcdGlmIChwcmVkaWN0ZWRBbHQgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLm9wdGltaXplX2xsMVxyXG5cdFx0XHRcdFx0XHQmJiBpbnB1dC5pbmRleCA9PT0gc3RhcnRJbmRleFxyXG5cdFx0XHRcdFx0XHQmJiAhZGZhLmlzUHJlY2VkZW5jZURmYVxyXG5cdFx0XHRcdFx0XHQmJiBuZXh0U3RhdGUub3V0ZXJDb250ZXh0ID09PSBuZXh0U3RhdGUucmVtYWluaW5nT3V0ZXJDb250ZXh0XHJcblx0XHRcdFx0XHRcdCYmIGRmYS5kZWNpc2lvbiA+PSAwXHJcblx0XHRcdFx0XHRcdCYmICFELmNvbmZpZ3MuaGFzU2VtYW50aWNDb250ZXh0KSB7XHJcblx0XHRcdFx0XHRcdGlmICh0ID49IDAgJiYgdCA8PSBNQVhfU0hPUlRfVkFMVUUpIHtcclxuXHRcdFx0XHRcdFx0XHRsZXQga2V5OiBudW1iZXIgPSAoKGRmYS5kZWNpc2lvbiA8PCAxNikgPj4+IDApICsgdDtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmF0bi5MTDFUYWJsZS5zZXQoa2V5LCBwcmVkaWN0ZWRBbHQpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHVzZUNvbnRleHQgJiYgdGhpcy5hbHdheXNfdHJ5X2xvY2FsX2NvbnRleHQpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5yZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkoZGZhLCBwcmVkaWN0ZWRBbHQsIG5leHRTdGF0ZSwgc3RhcnRJbmRleCwgaW5wdXQuaW5kZXgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cHJlZGljdGVkQWx0ID0gRC5wcmVkaWN0aW9uO1xyXG4vL1x0XHRcdFx0aW50IGsgPSBpbnB1dC5pbmRleCAtIHN0YXJ0SW5kZXggKyAxOyAvLyBob3cgbXVjaCBpbnB1dCB3ZSB1c2VkXHJcbi8vXHRcdFx0XHRTeXN0ZW0ub3V0LnByaW50bG4oXCJ1c2VkIGs9XCIrayk7XHJcblx0XHRcdFx0bGV0IGF0dGVtcHRGdWxsQ29udGV4dDogYm9vbGVhbiA9IGNvbmZsaWN0aW5nQWx0cyAhPSBudWxsICYmIHRoaXMudXNlcldhbnRzQ3R4U2Vuc2l0aXZlO1xyXG5cdFx0XHRcdGlmIChhdHRlbXB0RnVsbENvbnRleHQpIHtcclxuXHRcdFx0XHRcdC8vIE9ubHkgZXhhY3QgY29uZmxpY3RzIGFyZSBrbm93biB0byBiZSBhbWJpZ3VvdXMgd2hlbiBsb2NhbFxyXG5cdFx0XHRcdFx0Ly8gcHJlZGljdGlvbiBkb2VzIG5vdCBzdGVwIG91dCBvZiB0aGUgZGVjaXNpb24gcnVsZS5cclxuXHRcdFx0XHRcdGF0dGVtcHRGdWxsQ29udGV4dCA9ICF1c2VDb250ZXh0XHJcblx0XHRcdFx0XHRcdCYmIChELmNvbmZpZ3MuZGlwc0ludG9PdXRlckNvbnRleHQgfHwgIUQuY29uZmlncy5pc0V4YWN0Q29uZmxpY3QpXHJcblx0XHRcdFx0XHRcdCYmICghdGhpcy50cmVhdF9zbGxrMV9jb25mbGljdF9hc19hbWJpZ3VpdHkgfHwgaW5wdXQuaW5kZXggIT09IHN0YXJ0SW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKEQuY29uZmlncy5oYXNTZW1hbnRpY0NvbnRleHQpIHtcclxuXHRcdFx0XHRcdGxldCBwcmVkUHJlZGljdGlvbnM6IERGQVN0YXRlLlByZWRQcmVkaWN0aW9uW10gfCB1bmRlZmluZWQgPSBELnByZWRpY2F0ZXM7XHJcblx0XHRcdFx0XHRpZiAocHJlZFByZWRpY3Rpb25zICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0bGV0IGNvbmZsaWN0SW5kZXg6IG51bWJlciA9IGlucHV0LmluZGV4O1xyXG5cdFx0XHRcdFx0XHRpZiAoY29uZmxpY3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xyXG5cdFx0XHRcdFx0XHRcdGlucHV0LnNlZWsoc3RhcnRJbmRleCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIHVzZSBjb21wbGV0ZSBldmFsdWF0aW9uIGhlcmUgaWYgd2UnbGwgd2FudCB0byByZXRyeSB3aXRoIGZ1bGwgY29udGV4dCBpZiBzdGlsbCBhbWJpZ3VvdXNcclxuXHRcdFx0XHRcdFx0Y29uZmxpY3RpbmdBbHRzID0gdGhpcy5ldmFsU2VtYW50aWNDb250ZXh0KHByZWRQcmVkaWN0aW9ucywgb3V0ZXJDb250ZXh0LCBhdHRlbXB0RnVsbENvbnRleHQgfHwgdGhpcy5yZXBvcnRBbWJpZ3VpdGllcyk7XHJcblx0XHRcdFx0XHRcdHN3aXRjaCAoY29uZmxpY3RpbmdBbHRzLmNhcmRpbmFsaXR5KCkpIHtcclxuXHRcdFx0XHRcdFx0Y2FzZSAwOlxyXG5cdFx0XHRcdFx0XHRcdHRocm93IHRoaXMubm9WaWFibGVBbHQoaW5wdXQsIG91dGVyQ29udGV4dCwgRC5jb25maWdzLCBzdGFydEluZGV4KTtcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgMTpcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY29uZmxpY3RpbmdBbHRzLm5leHRTZXRCaXQoMCk7XHJcblxyXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoY29uZmxpY3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIHJlc3RvcmUgdGhlIGluZGV4IHNvIHJlcG9ydGluZyB0aGUgZmFsbGJhY2sgdG8gZnVsbFxyXG5cdFx0XHRcdFx0XHRcdC8vIGNvbnRleHQgb2NjdXJzIHdpdGggdGhlIGluZGV4IGF0IHRoZSBjb3JyZWN0IHNwb3RcclxuXHRcdFx0XHRcdFx0XHRpbnB1dC5zZWVrKGNvbmZsaWN0SW5kZXgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIWF0dGVtcHRGdWxsQ29udGV4dCkge1xyXG5cdFx0XHRcdFx0aWYgKGNvbmZsaWN0aW5nQWx0cyAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLnJlcG9ydEFtYmlndWl0aWVzICYmIGNvbmZsaWN0aW5nQWx0cy5jYXJkaW5hbGl0eSgpID4gMSkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMucmVwb3J0QW1iaWd1aXR5KGRmYSwgRCwgc3RhcnRJbmRleCwgaW5wdXQuaW5kZXgsIEQuY29uZmlncy5pc0V4YWN0Q29uZmxpY3QsIGNvbmZsaWN0aW5nQWx0cywgRC5jb25maWdzKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cHJlZGljdGVkQWx0ID0gY29uZmxpY3RpbmdBbHRzLm5leHRTZXRCaXQoMCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHByZWRpY3RlZEFsdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRhc3NlcnQoIXVzZUNvbnRleHQpO1xyXG5cdFx0XHRcdFx0YXNzZXJ0KHRoaXMuaXNBY2NlcHRTdGF0ZShELCBmYWxzZSkpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJSRVRSWSB3aXRoIG91dGVyQ29udGV4dD1cIiArIG91dGVyQ29udGV4dCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsZXQgZnVsbENvbnRleHRTdGF0ZTogU2ltdWxhdG9yU3RhdGUgPSB0aGlzLmNvbXB1dGVTdGFydFN0YXRlKGRmYSwgb3V0ZXJDb250ZXh0LCB0cnVlKTtcclxuXHRcdFx0XHRcdGlmICh0aGlzLnJlcG9ydEFtYmlndWl0aWVzKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KGRmYSwgY29uZmxpY3RpbmdBbHRzLCBuZXh0U3RhdGUsIHN0YXJ0SW5kZXgsIGlucHV0LmluZGV4KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZXhlY0FUTihkZmEsIGlucHV0LCBzdGFydEluZGV4LCBmdWxsQ29udGV4dFN0YXRlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHByZXZpb3VzID0gbmV4dFN0YXRlO1xyXG5cclxuXHRcdFx0aWYgKHQgIT09IEludFN0cmVhbS5FT0YpIHtcclxuXHRcdFx0XHRpbnB1dC5jb25zdW1lKCk7XHJcblx0XHRcdFx0dCA9IGlucHV0LkxBKDEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGltcHJvdmUgdGhlIGxvY2FsaXphdGlvbiBvZiBlcnJvciBtZXNzYWdlcyBieVxyXG5cdCAqIGNob29zaW5nIGFuIGFsdGVybmF0aXZlIHJhdGhlciB0aGFuIHRocm93aW5nIGFcclxuXHQgKiB7QGxpbmsgTm9WaWFibGVBbHRFeGNlcHRpb259IGluIHBhcnRpY3VsYXIgcHJlZGljdGlvbiBzY2VuYXJpb3Mgd2hlcmUgdGhlXHJcblx0ICoge0BsaW5rICNFUlJPUn0gc3RhdGUgd2FzIHJlYWNoZWQgZHVyaW5nIEFUTiBzaW11bGF0aW9uLlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgdXNlcyB0aGUgZm9sbG93aW5nXHJcblx0ICogYWxnb3JpdGhtIHRvIGlkZW50aWZ5IGFuIEFUTiBjb25maWd1cmF0aW9uIHdoaWNoIHN1Y2Nlc3NmdWxseSBwYXJzZWQgdGhlXHJcblx0ICogZGVjaXNpb24gZW50cnkgcnVsZS4gQ2hvb3Npbmcgc3VjaCBhbiBhbHRlcm5hdGl2ZSBlbnN1cmVzIHRoYXQgdGhlXHJcblx0ICoge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0fSByZXR1cm5lZCBieSB0aGUgY2FsbGluZyBydWxlIHdpbGwgYmUgY29tcGxldGVcclxuXHQgKiBhbmQgdmFsaWQsIGFuZCB0aGUgc3ludGF4IGVycm9yIHdpbGwgYmUgcmVwb3J0ZWQgbGF0ZXIgYXQgYSBtb3JlXHJcblx0ICogbG9jYWxpemVkIGxvY2F0aW9uLlxyXG5cdCAqXHJcblx0ICogKiBJZiBubyBjb25maWd1cmF0aW9uIGluIGBjb25maWdzYCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlXHJcblx0ICogICBkZWNpc2lvbiBydWxlLCByZXR1cm4ge0BsaW5rIEFUTiNJTlZBTElEX0FMVF9OVU1CRVJ9LlxyXG5cdCAqICogSWYgYWxsIGNvbmZpZ3VyYXRpb25zIGluIGBjb25maWdzYCB3aGljaCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlXHJcblx0ICogICBkZWNpc2lvbiBydWxlIHByZWRpY3QgdGhlIHNhbWUgYWx0ZXJuYXRpdmUsIHJldHVybiB0aGF0IGFsdGVybmF0aXZlLlxyXG5cdCAqICogSWYgdGhlIGNvbmZpZ3VyYXRpb25zIGluIGBjb25maWdzYCB3aGljaCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlXHJcblx0ICogICBkZWNpc2lvbiBydWxlIHByZWRpY3QgbXVsdGlwbGUgYWx0ZXJuYXRpdmVzIChjYWxsIHRoaXMgKlMqKSxcclxuXHQgKiAgIGNob29zZSBhbiBhbHRlcm5hdGl2ZSBpbiB0aGUgZm9sbG93aW5nIG9yZGVyLlxyXG5cdCAqXHJcblx0ICogICAgIDEuIEZpbHRlciB0aGUgY29uZmlndXJhdGlvbnMgaW4gYGNvbmZpZ3NgIHRvIG9ubHkgdGhvc2VcclxuXHQgKiAgICAgICAgY29uZmlndXJhdGlvbnMgd2hpY2ggcmVtYWluIHZpYWJsZSBhZnRlciBldmFsdWF0aW5nIHNlbWFudGljIHByZWRpY2F0ZXMuXHJcblx0ICogICAgICAgIElmIHRoZSBzZXQgb2YgdGhlc2UgZmlsdGVyZWQgY29uZmlndXJhdGlvbnMgd2hpY2ggYWxzbyByZWFjaGVkIHRoZSBlbmQgb2ZcclxuXHQgKiAgICAgICAgdGhlIGRlY2lzaW9uIHJ1bGUgaXMgbm90IGVtcHR5LCByZXR1cm4gdGhlIG1pbmltdW0gYWx0ZXJuYXRpdmVcclxuXHQgKiAgICAgICAgcmVwcmVzZW50ZWQgaW4gdGhpcyBzZXQuXHJcblx0ICogICAgIDEuIE90aGVyd2lzZSwgY2hvb3NlIHRoZSBtaW5pbXVtIGFsdGVybmF0aXZlIGluICpTKi5cclxuXHQgKlxyXG5cdCAqIEluIHNvbWUgc2NlbmFyaW9zLCB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBhYm92ZSBjb3VsZCBwcmVkaWN0IGFuXHJcblx0ICogYWx0ZXJuYXRpdmUgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSB7QGxpbmsgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9ufSBpblxyXG5cdCAqIHBhcnNlci4gU3BlY2lmaWNhbGx5LCB0aGlzIGNvdWxkIG9jY3VyIGlmIHRoZSAqb25seSogY29uZmlndXJhdGlvblxyXG5cdCAqIGNhcGFibGUgb2Ygc3VjY2Vzc2Z1bGx5IHBhcnNpbmcgdG8gdGhlIGVuZCBvZiB0aGUgZGVjaXNpb24gcnVsZSBpc1xyXG5cdCAqIGJsb2NrZWQgYnkgYSBzZW1hbnRpYyBwcmVkaWNhdGUuIEJ5IGNob29zaW5nIHRoaXMgYWx0ZXJuYXRpdmUgd2l0aGluXHJcblx0ICoge0BsaW5rICNhZGFwdGl2ZVByZWRpY3R9IGluc3RlYWQgb2YgdGhyb3dpbmcgYVxyXG5cdCAqIHtAbGluayBOb1ZpYWJsZUFsdEV4Y2VwdGlvbn0sIHRoZSByZXN1bHRpbmdcclxuXHQgKiB7QGxpbmsgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9ufSBpbiB0aGUgcGFyc2VyIHdpbGwgaWRlbnRpZnkgdGhlIHNwZWNpZmljXHJcblx0ICogcHJlZGljYXRlIHdoaWNoIGlzIHByZXZlbnRpbmcgdGhlIHBhcnNlciBmcm9tIHN1Y2Nlc3NmdWxseSBwYXJzaW5nIHRoZVxyXG5cdCAqIGRlY2lzaW9uIHJ1bGUsIHdoaWNoIGhlbHBzIGRldmVsb3BlcnMgaWRlbnRpZnkgYW5kIGNvcnJlY3QgbG9naWMgZXJyb3JzXHJcblx0ICogaW4gc2VtYW50aWMgcHJlZGljYXRlcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQge0BsaW5rIFRva2VuU3RyZWFtfVxyXG5cdCAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCBmb3IgdGhlIGN1cnJlbnQgcHJlZGljdGlvbiwgd2hpY2ggaXNcclxuXHQgKiB0aGUgaW5wdXQgaW5kZXggd2hlcmUgYW55IHNlbWFudGljIGNvbnRleHQgaW4gYGNvbmZpZ3NgIHNob3VsZCBiZVxyXG5cdCAqIGV2YWx1YXRlZFxyXG5cdCAqIEBwYXJhbSBwcmV2aW91cyBUaGUgQVROIHNpbXVsYXRpb24gc3RhdGUgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZVxyXG5cdCAqIHtAbGluayAjRVJST1J9IHN0YXRlIHdhcyByZWFjaGVkXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20ge0BsaW5rICNhZGFwdGl2ZVByZWRpY3R9LCBvclxyXG5cdCAqIHtAbGluayBBVE4jSU5WQUxJRF9BTFRfTlVNQkVSfSBpZiBhIHN1aXRhYmxlIGFsdGVybmF0aXZlIHdhcyBub3RcclxuXHQgKiBpZGVudGlmaWVkIGFuZCB7QGxpbmsgI2FkYXB0aXZlUHJlZGljdH0gc2hvdWxkIHJlcG9ydCBhbiBlcnJvciBpbnN0ZWFkLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBoYW5kbGVOb1ZpYWJsZUFsdChATm90TnVsbCBpbnB1dDogVG9rZW5TdHJlYW0sIHN0YXJ0SW5kZXg6IG51bWJlciwgQE5vdE51bGwgcHJldmlvdXM6IFNpbXVsYXRvclN0YXRlKTogbnVtYmVyIHtcclxuXHRcdGlmIChwcmV2aW91cy5zMCAhPSBudWxsKSB7XHJcblx0XHRcdGxldCBhbHRzOiBCaXRTZXQgPSBuZXcgQml0U2V0KCk7XHJcblx0XHRcdGxldCBtYXhBbHQ6IG51bWJlciA9IDA7XHJcblx0XHRcdGZvciAobGV0IGNvbmZpZyBvZiBwcmV2aW91cy5zMC5jb25maWdzKSB7XHJcblx0XHRcdFx0aWYgKGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dCB8fCBjb25maWcuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XHJcblx0XHRcdFx0XHRhbHRzLnNldChjb25maWcuYWx0KTtcclxuXHRcdFx0XHRcdG1heEFsdCA9IE1hdGgubWF4KG1heEFsdCwgY29uZmlnLmFsdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzd2l0Y2ggKGFsdHMuY2FyZGluYWxpdHkoKSkge1xyXG5cdFx0XHRjYXNlIDA6XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIDE6XHJcblx0XHRcdFx0cmV0dXJuIGFsdHMubmV4dFNldEJpdCgwKTtcclxuXHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0aWYgKCFwcmV2aW91cy5zMC5jb25maWdzLmhhc1NlbWFudGljQ29udGV4dCkge1xyXG5cdFx0XHRcdFx0Ly8gY29uZmlncyBkb2Vzbid0IGNvbnRhaW4gYW55IHByZWRpY2F0ZXMsIHNvIHRoZSBwcmVkaWNhdGVcclxuXHRcdFx0XHRcdC8vIGZpbHRlcmluZyBjb2RlIGJlbG93IHdvdWxkIGJlIHBvaW50bGVzc1xyXG5cdFx0XHRcdFx0cmV0dXJuIGFsdHMubmV4dFNldEJpdCgwKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8qXHJcblx0XHRcdFx0ICogVHJ5IHRvIGZpbmQgYSBjb25maWd1cmF0aW9uIHNldCB0aGF0IG5vdCBvbmx5IGRpcHBlZCBpbnRvIHRoZSBvdXRlclxyXG5cdFx0XHRcdCAqIGNvbnRleHQsIGJ1dCBhbHNvIGlzbid0IGVsaW1pbmF0ZWQgYnkgYSBwcmVkaWNhdGUuXHJcblx0XHRcdFx0ICovXHJcblx0XHRcdFx0bGV0IGZpbHRlcmVkQ29uZmlnczogQVROQ29uZmlnU2V0ID0gbmV3IEFUTkNvbmZpZ1NldCgpO1xyXG5cdFx0XHRcdGZvciAobGV0IGNvbmZpZyBvZiBwcmV2aW91cy5zMC5jb25maWdzKSB7XHJcblx0XHRcdFx0XHRpZiAoY29uZmlnLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0IHx8IGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcclxuXHRcdFx0XHRcdFx0ZmlsdGVyZWRDb25maWdzLmFkZChjb25maWcpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0LyogVGhlIGZvbGxvd2luZyBjb2RlIGJsb2NrcyBhcmUgYWRhcHRlZCBmcm9tIHByZWRpY2F0ZURGQVN0YXRlIHdpdGhcclxuXHRcdFx0XHQgKiB0aGUgZm9sbG93aW5nIGtleSBjaGFuZ2VzLlxyXG5cdFx0XHRcdCAqXHJcblx0XHRcdFx0ICogIDEuIFRoZSBjb2RlIG9wZXJhdGVzIG9uIGFuIEFUTkNvbmZpZ1NldCByYXRoZXIgdGhhbiBhIERGQVN0YXRlLlxyXG5cdFx0XHRcdCAqICAyLiBQcmVkaWNhdGVzIGFyZSBjb2xsZWN0ZWQgZm9yIGFsbCBhbHRlcm5hdGl2ZXMgcmVwcmVzZW50ZWQgaW5cclxuXHRcdFx0XHQgKiAgICAgZmlsdGVyZWRDb25maWdzLCByYXRoZXIgdGhhbiByZXN0cmljdGluZyB0aGUgZXZhbHVhdGlvbiB0b1xyXG5cdFx0XHRcdCAqICAgICBjb25mbGljdGluZyBhbmQvb3IgdW5pcXVlIGNvbmZpZ3VyYXRpb25zLlxyXG5cdFx0XHRcdCAqL1xyXG5cdFx0XHRcdGxldCBhbHRUb1ByZWQ6IFNlbWFudGljQ29udGV4dFtdIHwgdW5kZWZpbmVkID0gdGhpcy5nZXRQcmVkc0ZvckFtYmlnQWx0cyhhbHRzLCBmaWx0ZXJlZENvbmZpZ3MsIG1heEFsdCk7XHJcblx0XHRcdFx0aWYgKGFsdFRvUHJlZCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRsZXQgcHJlZGljYXRlczogREZBU3RhdGUuUHJlZFByZWRpY3Rpb25bXSB8IHVuZGVmaW5lZCA9IHRoaXMuZ2V0UHJlZGljYXRlUHJlZGljdGlvbnMoYWx0cywgYWx0VG9QcmVkKTtcclxuXHRcdFx0XHRcdGlmIChwcmVkaWNhdGVzICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0bGV0IHN0b3BJbmRleDogbnVtYmVyID0gaW5wdXQuaW5kZXg7XHJcblx0XHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdFx0aW5wdXQuc2VlayhzdGFydEluZGV4KTtcclxuXHRcdFx0XHRcdFx0XHRsZXQgZmlsdGVyZWRBbHRzOiBCaXRTZXQgPSB0aGlzLmV2YWxTZW1hbnRpY0NvbnRleHQocHJlZGljYXRlcywgcHJldmlvdXMub3V0ZXJDb250ZXh0LCBmYWxzZSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFmaWx0ZXJlZEFsdHMuaXNFbXB0eSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZpbHRlcmVkQWx0cy5uZXh0U2V0Qml0KDApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRmaW5hbGx5IHtcclxuXHRcdFx0XHRcdFx0XHRpbnB1dC5zZWVrKHN0b3BJbmRleCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBhbHRzLm5leHRTZXRCaXQoMCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aHJvdyB0aGlzLm5vVmlhYmxlQWx0KGlucHV0LCBwcmV2aW91cy5vdXRlckNvbnRleHQsIHByZXZpb3VzLnMwLmNvbmZpZ3MsIHN0YXJ0SW5kZXgpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGNvbXB1dGVSZWFjaFNldChkZmE6IERGQSwgcHJldmlvdXM6IFNpbXVsYXRvclN0YXRlLCB0OiBudW1iZXIsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IFNpbXVsYXRvclN0YXRlIHwgdW5kZWZpbmVkIHtcclxuXHRcdGxldCB1c2VDb250ZXh0OiBib29sZWFuID0gcHJldmlvdXMudXNlQ29udGV4dDtcclxuXHRcdGxldCByZW1haW5pbmdHbG9iYWxDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCA9IHByZXZpb3VzLnJlbWFpbmluZ091dGVyQ29udGV4dDtcclxuXHJcblx0XHRsZXQgczogREZBU3RhdGUgPSBwcmV2aW91cy5zMDtcclxuXHRcdGlmICh1c2VDb250ZXh0KSB7XHJcblx0XHRcdHdoaWxlIChzLmlzQ29udGV4dFN5bWJvbCh0KSkge1xyXG5cdFx0XHRcdGxldCBuZXh0OiBERkFTdGF0ZSB8IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRpZiAocmVtYWluaW5nR2xvYmFsQ29udGV4dCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRyZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gdGhpcy5za2lwVGFpbENhbGxzKHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xyXG5cdFx0XHRcdFx0bmV4dCA9IHMuZ2V0Q29udGV4dFRhcmdldCh0aGlzLmdldFJldHVyblN0YXRlKHJlbWFpbmluZ0dsb2JhbENvbnRleHQpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChuZXh0ID09IG51bGwpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YXNzZXJ0KHJlbWFpbmluZ0dsb2JhbENvbnRleHQgIT0gbnVsbCk7XHJcblx0XHRcdFx0cmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHJlbWFpbmluZ0dsb2JhbENvbnRleHQucGFyZW50O1xyXG5cdFx0XHRcdHMgPSBuZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YXNzZXJ0KCF0aGlzLmlzQWNjZXB0U3RhdGUocywgdXNlQ29udGV4dCkpO1xyXG5cdFx0aWYgKHRoaXMuaXNBY2NlcHRTdGF0ZShzLCB1c2VDb250ZXh0KSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFNpbXVsYXRvclN0YXRlKHByZXZpb3VzLm91dGVyQ29udGV4dCwgcywgdXNlQ29udGV4dCwgcmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHMwOiBERkFTdGF0ZSA9IHM7XHJcblxyXG5cdFx0bGV0IHRhcmdldDogREZBU3RhdGUgfCB1bmRlZmluZWQgPSB0aGlzLmdldEV4aXN0aW5nVGFyZ2V0U3RhdGUoczAsIHQpO1xyXG5cdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XHJcblx0XHRcdGxldCByZXN1bHQ6IFtERkFTdGF0ZSwgUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWRdID0gdGhpcy5jb21wdXRlVGFyZ2V0U3RhdGUoZGZhLCBzMCwgcmVtYWluaW5nR2xvYmFsQ29udGV4dCwgdCwgdXNlQ29udGV4dCwgY29udGV4dENhY2hlKTtcclxuXHRcdFx0dGFyZ2V0ID0gcmVzdWx0WzBdO1xyXG5cdFx0XHRyZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gcmVzdWx0WzFdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0YXJnZXQgPT09IEFUTlNpbXVsYXRvci5FUlJPUikge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGFzc2VydCghdXNlQ29udGV4dCB8fCAhdGFyZ2V0LmNvbmZpZ3MuZGlwc0ludG9PdXRlckNvbnRleHQpO1xyXG5cdFx0cmV0dXJuIG5ldyBTaW11bGF0b3JTdGF0ZShwcmV2aW91cy5vdXRlckNvbnRleHQsIHRhcmdldCwgdXNlQ29udGV4dCwgcmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW4gZXhpc3RpbmcgdGFyZ2V0IHN0YXRlIGZvciBhbiBlZGdlIGluIHRoZSBERkEuIElmIHRoZSB0YXJnZXQgc3RhdGVcclxuXHQgKiBmb3IgdGhlIGVkZ2UgaGFzIG5vdCB5ZXQgYmVlbiBjb21wdXRlZCBvciBpcyBvdGhlcndpc2Ugbm90IGF2YWlsYWJsZSxcclxuXHQgKiB0aGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHMgVGhlIGN1cnJlbnQgREZBIHN0YXRlXHJcblx0ICogQHBhcmFtIHQgVGhlIG5leHQgaW5wdXQgc3ltYm9sXHJcblx0ICogQHJldHVybnMgVGhlIGV4aXN0aW5nIHRhcmdldCBERkEgc3RhdGUgZm9yIHRoZSBnaXZlbiBpbnB1dCBzeW1ib2xcclxuXHQgKiBgdGAsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSB0YXJnZXQgc3RhdGUgZm9yIHRoaXMgZWRnZSBpcyBub3RcclxuXHQgKiBhbHJlYWR5IGNhY2hlZFxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBnZXRFeGlzdGluZ1RhcmdldFN0YXRlKEBOb3ROdWxsIHM6IERGQVN0YXRlLCB0OiBudW1iZXIpOiBERkFTdGF0ZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gcy5nZXRUYXJnZXQodCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wdXRlIGEgdGFyZ2V0IHN0YXRlIGZvciBhbiBlZGdlIGluIHRoZSBERkEsIGFuZCBhdHRlbXB0IHRvIGFkZCB0aGVcclxuXHQgKiBjb21wdXRlZCBzdGF0ZSBhbmQgY29ycmVzcG9uZGluZyBlZGdlIHRvIHRoZSBERkEuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gZGZhXHJcblx0ICogQHBhcmFtIHMgVGhlIGN1cnJlbnQgREZBIHN0YXRlXHJcblx0ICogQHBhcmFtIHJlbWFpbmluZ0dsb2JhbENvbnRleHRcclxuXHQgKiBAcGFyYW0gdCBUaGUgbmV4dCBpbnB1dCBzeW1ib2xcclxuXHQgKiBAcGFyYW0gdXNlQ29udGV4dFxyXG5cdCAqIEBwYXJhbSBjb250ZXh0Q2FjaGVcclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBjb21wdXRlZCB0YXJnZXQgREZBIHN0YXRlIGZvciB0aGUgZ2l2ZW4gaW5wdXQgc3ltYm9sXHJcblx0ICogYHRgLiBJZiBgdGAgZG9lcyBub3QgbGVhZCB0byBhIHZhbGlkIERGQSBzdGF0ZSwgdGhpcyBtZXRob2RcclxuXHQgKiByZXR1cm5zIHtAbGluayAjRVJST1J9LlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGNvbXB1dGVUYXJnZXRTdGF0ZShATm90TnVsbCBkZmE6IERGQSwgQE5vdE51bGwgczogREZBU3RhdGUsIHJlbWFpbmluZ0dsb2JhbENvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLCB0OiBudW1iZXIsIHVzZUNvbnRleHQ6IGJvb2xlYW4sIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IFtERkFTdGF0ZSwgUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWRdIHtcclxuXHRcdGxldCBjbG9zdXJlQ29uZmlnczogQVROQ29uZmlnW10gPSBzLmNvbmZpZ3MudG9BcnJheSgpO1xyXG5cdFx0bGV0IGNvbnRleHRFbGVtZW50czogSW50ZWdlckxpc3QgfCB1bmRlZmluZWQ7XHJcblx0XHRsZXQgcmVhY2g6IEFUTkNvbmZpZ1NldCA9IG5ldyBBVE5Db25maWdTZXQoKTtcclxuXHRcdGxldCBzdGVwSW50b0dsb2JhbDogYm9vbGVhbjtcclxuXHRcdGRvIHtcclxuXHRcdFx0bGV0IGhhc01vcmVDb250ZXh0OiBib29sZWFuID0gIXVzZUNvbnRleHQgfHwgcmVtYWluaW5nR2xvYmFsQ29udGV4dCAhPSBudWxsO1xyXG5cdFx0XHRpZiAoIWhhc01vcmVDb250ZXh0KSB7XHJcblx0XHRcdFx0cmVhY2guaXNPdXRlcm1vc3RDb25maWdTZXQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgcmVhY2hJbnRlcm1lZGlhdGU6IEFUTkNvbmZpZ1NldCA9IG5ldyBBVE5Db25maWdTZXQoKTtcclxuXHJcblx0XHRcdC8qIENvbmZpZ3VyYXRpb25zIGFscmVhZHkgaW4gYSBydWxlIHN0b3Agc3RhdGUgaW5kaWNhdGUgcmVhY2hpbmcgdGhlIGVuZFxyXG5cdFx0XHQgKiBvZiB0aGUgZGVjaXNpb24gcnVsZSAobG9jYWwgY29udGV4dCkgb3IgZW5kIG9mIHRoZSBzdGFydCBydWxlIChmdWxsXHJcblx0XHRcdCAqIGNvbnRleHQpLiBPbmNlIHJlYWNoZWQsIHRoZXNlIGNvbmZpZ3VyYXRpb25zIGFyZSBuZXZlciB1cGRhdGVkIGJ5IGFcclxuXHRcdFx0ICogY2xvc3VyZSBvcGVyYXRpb24sIHNvIHRoZXkgYXJlIGhhbmRsZWQgc2VwYXJhdGVseSBmb3IgdGhlIHBlcmZvcm1hbmNlXHJcblx0XHRcdCAqIGFkdmFudGFnZSBvZiBoYXZpbmcgYSBzbWFsbGVyIGludGVybWVkaWF0ZSBzZXQgd2hlbiBjYWxsaW5nIGNsb3N1cmUuXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIEZvciBmdWxsLWNvbnRleHQgcmVhY2ggb3BlcmF0aW9ucywgc2VwYXJhdGUgaGFuZGxpbmcgaXMgcmVxdWlyZWQgdG9cclxuXHRcdFx0ICogZW5zdXJlIHRoYXQgdGhlIGFsdGVybmF0aXZlIG1hdGNoaW5nIHRoZSBsb25nZXN0IG92ZXJhbGwgc2VxdWVuY2UgaXNcclxuXHRcdFx0ICogY2hvc2VuIHdoZW4gbXVsdGlwbGUgc3VjaCBjb25maWd1cmF0aW9ucyBjYW4gbWF0Y2ggdGhlIGlucHV0LlxyXG5cdFx0XHQgKi9cclxuXHRcdFx0bGV0IHNraXBwZWRTdG9wU3RhdGVzOiBBVE5Db25maWdbXSB8IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdGZvciAobGV0IGMgb2YgY2xvc3VyZUNvbmZpZ3MpIHtcclxuXHRcdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInRlc3RpbmcgXCIgKyB0aGlzLmdldFRva2VuTmFtZSh0KSArIFwiIGF0IFwiICsgYy50b1N0cmluZygpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xyXG5cdFx0XHRcdFx0YXNzZXJ0KGMuY29udGV4dC5pc0VtcHR5KTtcclxuXHRcdFx0XHRcdGlmICh1c2VDb250ZXh0ICYmICFjLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0IHx8IHQgPT09IEludFN0cmVhbS5FT0YpIHtcclxuXHRcdFx0XHRcdFx0aWYgKHNraXBwZWRTdG9wU3RhdGVzID09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRza2lwcGVkU3RvcFN0YXRlcyA9IFtdO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRza2lwcGVkU3RvcFN0YXRlcy5wdXNoKGMpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IG46IG51bWJlciA9IGMuc3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucztcclxuXHRcdFx0XHRmb3IgKGxldCB0aSA9IDA7IHRpIDwgbjsgdGkrKykgeyAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIG9wdGltaXplZCB0cmFuc2l0aW9uXHJcblx0XHRcdFx0XHRsZXQgdHJhbnM6IFRyYW5zaXRpb24gPSBjLnN0YXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24odGkpO1xyXG5cdFx0XHRcdFx0bGV0IHRhcmdldDogQVROU3RhdGUgfCB1bmRlZmluZWQgPSB0aGlzLmdldFJlYWNoYWJsZVRhcmdldChjLCB0cmFucywgdCk7XHJcblx0XHRcdFx0XHRpZiAodGFyZ2V0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0cmVhY2hJbnRlcm1lZGlhdGUuYWRkKGMudHJhbnNmb3JtKHRhcmdldCwgZmFsc2UpLCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0LyogVGhpcyBibG9jayBvcHRpbWl6ZXMgdGhlIHJlYWNoIG9wZXJhdGlvbiBmb3IgaW50ZXJtZWRpYXRlIHNldHMgd2hpY2hcclxuXHRcdFx0ICogdHJpdmlhbGx5IGluZGljYXRlIGEgdGVybWluYXRpb24gc3RhdGUgZm9yIHRoZSBvdmVyYWxsXHJcblx0XHRcdCAqIGFkYXB0aXZlUHJlZGljdCBvcGVyYXRpb24uXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIFRoZSBjb25kaXRpb25zIGFzc3VtZSB0aGF0IGludGVybWVkaWF0ZVxyXG5cdFx0XHQgKiBjb250YWlucyBhbGwgY29uZmlndXJhdGlvbnMgcmVsZXZhbnQgdG8gdGhlIHJlYWNoIHNldCwgYnV0IHRoaXNcclxuXHRcdFx0ICogY29uZGl0aW9uIGlzIG5vdCB0cnVlIHdoZW4gb25lIG9yIG1vcmUgY29uZmlndXJhdGlvbnMgaGF2ZSBiZWVuXHJcblx0XHRcdCAqIHdpdGhoZWxkIGluIHNraXBwZWRTdG9wU3RhdGVzLCBvciB3aGVuIHRoZSBjdXJyZW50IHN5bWJvbCBpcyBFT0YuXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpbWl6ZV91bmlxdWVfY2xvc3VyZSAmJiBza2lwcGVkU3RvcFN0YXRlcyA9PSBudWxsICYmIHQgIT09IFRva2VuLkVPRiAmJiByZWFjaEludGVybWVkaWF0ZS51bmlxdWVBbHQgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuXHRcdFx0XHRyZWFjaEludGVybWVkaWF0ZS5pc091dGVybW9zdENvbmZpZ1NldCA9IHJlYWNoLmlzT3V0ZXJtb3N0Q29uZmlnU2V0O1xyXG5cdFx0XHRcdHJlYWNoID0gcmVhY2hJbnRlcm1lZGlhdGU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8qIElmIHRoZSByZWFjaCBzZXQgY291bGQgbm90IGJlIHRyaXZpYWxseSBkZXRlcm1pbmVkLCBwZXJmb3JtIGEgY2xvc3VyZVxyXG5cdFx0XHQgKiBvcGVyYXRpb24gb24gdGhlIGludGVybWVkaWF0ZSBzZXQgdG8gY29tcHV0ZSBpdHMgaW5pdGlhbCB2YWx1ZS5cclxuXHRcdFx0ICovXHJcblx0XHRcdGxldCBjb2xsZWN0UHJlZGljYXRlczogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdFx0XHRsZXQgdHJlYXRFb2ZBc0Vwc2lsb246IGJvb2xlYW4gPSB0ID09PSBUb2tlbi5FT0Y7XHJcblx0XHRcdHRoaXMuY2xvc3VyZShyZWFjaEludGVybWVkaWF0ZSwgcmVhY2gsIGNvbGxlY3RQcmVkaWNhdGVzLCBoYXNNb3JlQ29udGV4dCwgY29udGV4dENhY2hlLCB0cmVhdEVvZkFzRXBzaWxvbik7XHJcblx0XHRcdHN0ZXBJbnRvR2xvYmFsID0gcmVhY2guZGlwc0ludG9PdXRlckNvbnRleHQ7XHJcblxyXG5cdFx0XHRpZiAodCA9PT0gSW50U3RyZWFtLkVPRikge1xyXG5cdFx0XHRcdC8qIEFmdGVyIGNvbnN1bWluZyBFT0Ygbm8gYWRkaXRpb25hbCBpbnB1dCBpcyBwb3NzaWJsZSwgc28gd2UgYXJlXHJcblx0XHRcdFx0ICogb25seSBpbnRlcmVzdGVkIGluIGNvbmZpZ3VyYXRpb25zIHdoaWNoIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGVcclxuXHRcdFx0XHQgKiBkZWNpc2lvbiBydWxlIChsb2NhbCBjb250ZXh0KSBvciBlbmQgb2YgdGhlIHN0YXJ0IHJ1bGUgKGZ1bGxcclxuXHRcdFx0XHQgKiBjb250ZXh0KS4gVXBkYXRlIHJlYWNoIHRvIGNvbnRhaW4gb25seSB0aGVzZSBjb25maWd1cmF0aW9ucy4gVGhpc1xyXG5cdFx0XHRcdCAqIGhhbmRsZXMgYm90aCBleHBsaWNpdCBFT0YgdHJhbnNpdGlvbnMgaW4gdGhlIGdyYW1tYXIgYW5kIGltcGxpY2l0XHJcblx0XHRcdFx0ICogRU9GIHRyYW5zaXRpb25zIGZvbGxvd2luZyB0aGUgZW5kIG9mIHRoZSBkZWNpc2lvbiBvciBzdGFydCBydWxlLlxyXG5cdFx0XHRcdCAqXHJcblx0XHRcdFx0ICogVGhpcyBpcyBoYW5kbGVkIGJlZm9yZSB0aGUgY29uZmlndXJhdGlvbnMgaW4gc2tpcHBlZFN0b3BTdGF0ZXMsXHJcblx0XHRcdFx0ICogYmVjYXVzZSBhbnkgY29uZmlndXJhdGlvbnMgcG90ZW50aWFsbHkgYWRkZWQgZnJvbSB0aGF0IGxpc3QgYXJlXHJcblx0XHRcdFx0ICogYWxyZWFkeSBndWFyYW50ZWVkIHRvIG1lZXQgdGhpcyBjb25kaXRpb24gd2hldGhlciBvciBub3QgaXQnc1xyXG5cdFx0XHRcdCAqIHJlcXVpcmVkLlxyXG5cdFx0XHRcdCAqL1xyXG5cdFx0XHRcdHJlYWNoID0gdGhpcy5yZW1vdmVBbGxDb25maWdzTm90SW5SdWxlU3RvcFN0YXRlKHJlYWNoLCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKiBJZiBza2lwcGVkU3RvcFN0YXRlcyBpcyBub3QgdW5kZWZpbmVkLCB0aGVuIGl0IGNvbnRhaW5zIGF0IGxlYXN0IG9uZVxyXG5cdFx0XHQgKiBjb25maWd1cmF0aW9uLiBGb3IgZnVsbC1jb250ZXh0IHJlYWNoIG9wZXJhdGlvbnMsIHRoZXNlXHJcblx0XHRcdCAqIGNvbmZpZ3VyYXRpb25zIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc3RhcnQgcnVsZSwgaW4gd2hpY2ggY2FzZSB3ZVxyXG5cdFx0XHQgKiBvbmx5IGFkZCB0aGVtIGJhY2sgdG8gcmVhY2ggaWYgbm8gY29uZmlndXJhdGlvbiBkdXJpbmcgdGhlIGN1cnJlbnRcclxuXHRcdFx0ICogY2xvc3VyZSBvcGVyYXRpb24gcmVhY2hlZCBzdWNoIGEgc3RhdGUuIFRoaXMgZW5zdXJlcyBhZGFwdGl2ZVByZWRpY3RcclxuXHRcdFx0ICogY2hvb3NlcyBhbiBhbHRlcm5hdGl2ZSBtYXRjaGluZyB0aGUgbG9uZ2VzdCBvdmVyYWxsIHNlcXVlbmNlIHdoZW5cclxuXHRcdFx0ICogbXVsdGlwbGUgYWx0ZXJuYXRpdmVzIGFyZSB2aWFibGUuXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRpZiAoc2tpcHBlZFN0b3BTdGF0ZXMgIT0gbnVsbCAmJiAoIXVzZUNvbnRleHQgfHwgIVByZWRpY3Rpb25Nb2RlLmhhc0NvbmZpZ0luUnVsZVN0b3BTdGF0ZShyZWFjaCkpKSB7XHJcblx0XHRcdFx0YXNzZXJ0KHNraXBwZWRTdG9wU3RhdGVzLmxlbmd0aCA+IDApO1xyXG5cdFx0XHRcdGZvciAobGV0IGMgb2Ygc2tpcHBlZFN0b3BTdGF0ZXMpIHtcclxuXHRcdFx0XHRcdHJlYWNoLmFkZChjLCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHVzZUNvbnRleHQgJiYgc3RlcEludG9HbG9iYWwpIHtcclxuXHRcdFx0XHRyZWFjaC5jbGVhcigpO1xyXG5cclxuXHRcdFx0XHQvLyBXZSBrbm93IHJlbWFpbmluZ0dsb2JhbENvbnRleHQgaXMgbm90IHVuZGVmaW5lZCBhdCB0aGlzIHBvaW50ICh3aHk/KVxyXG5cdFx0XHRcdHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSByZW1haW5pbmdHbG9iYWxDb250ZXh0IGFzIFBhcnNlclJ1bGVDb250ZXh0O1xyXG5cclxuXHRcdFx0XHRyZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gdGhpcy5za2lwVGFpbENhbGxzKHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xyXG5cdFx0XHRcdGxldCBuZXh0Q29udGV4dEVsZW1lbnQ6IG51bWJlciA9IHRoaXMuZ2V0UmV0dXJuU3RhdGUocmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XHJcblx0XHRcdFx0aWYgKGNvbnRleHRFbGVtZW50cyA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRjb250ZXh0RWxlbWVudHMgPSBuZXcgSW50ZWdlckxpc3QoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChyZW1haW5pbmdHbG9iYWxDb250ZXh0LmlzRW1wdHkpIHtcclxuXHRcdFx0XHRcdHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSByZW1haW5pbmdHbG9iYWxDb250ZXh0LnBhcmVudDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnRleHRFbGVtZW50cy5hZGQobmV4dENvbnRleHRFbGVtZW50KTtcclxuXHRcdFx0XHRpZiAobmV4dENvbnRleHRFbGVtZW50ICE9PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSkge1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjbG9zdXJlQ29uZmlncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRjbG9zdXJlQ29uZmlnc1tpXSA9IGNsb3N1cmVDb25maWdzW2ldLmFwcGVuZENvbnRleHQobmV4dENvbnRleHRFbGVtZW50LCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSB3aGlsZSAodXNlQ29udGV4dCAmJiBzdGVwSW50b0dsb2JhbCk7XHJcblxyXG5cdFx0aWYgKHJlYWNoLmlzRW1wdHkpIHtcclxuXHRcdFx0dGhpcy5zZXRERkFFZGdlKHMsIHQsIEFUTlNpbXVsYXRvci5FUlJPUik7XHJcblx0XHRcdHJldHVybiBbQVROU2ltdWxhdG9yLkVSUk9SLCByZW1haW5pbmdHbG9iYWxDb250ZXh0XTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVzdWx0OiBERkFTdGF0ZSA9IHRoaXMuYWRkREZBRWRnZShkZmEsIHMsIHQsIGNvbnRleHRFbGVtZW50cywgcmVhY2gsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRyZXR1cm4gW3Jlc3VsdCwgcmVtYWluaW5nR2xvYmFsQ29udGV4dF07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gYSBjb25maWd1cmF0aW9uIHNldCBjb250YWluaW5nIG9ubHkgdGhlIGNvbmZpZ3VyYXRpb25zIGZyb21cclxuXHQgKiBgY29uZmlnc2Agd2hpY2ggYXJlIGluIGEge0BsaW5rIFJ1bGVTdG9wU3RhdGV9LiBJZiBhbGxcclxuXHQgKiBjb25maWd1cmF0aW9ucyBpbiBgY29uZmlnc2AgYXJlIGFscmVhZHkgaW4gYSBydWxlIHN0b3Agc3RhdGUsIHRoaXNcclxuXHQgKiBtZXRob2Qgc2ltcGx5IHJldHVybnMgYGNvbmZpZ3NgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGNvbmZpZ3MgdGhlIGNvbmZpZ3VyYXRpb24gc2V0IHRvIHVwZGF0ZVxyXG5cdCAqIEBwYXJhbSBjb250ZXh0Q2FjaGUgdGhlIHtAbGluayBQcmVkaWN0aW9uQ29udGV4dH0gY2FjaGVcclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIGBjb25maWdzYCBpZiBhbGwgY29uZmlndXJhdGlvbnMgaW4gYGNvbmZpZ3NgIGFyZSBpbiBhXHJcblx0ICogcnVsZSBzdG9wIHN0YXRlLCBvdGhlcndpc2UgcmV0dXJuIGEgbmV3IGNvbmZpZ3VyYXRpb24gc2V0IGNvbnRhaW5pbmcgb25seVxyXG5cdCAqIHRoZSBjb25maWd1cmF0aW9ucyBmcm9tIGBjb25maWdzYCB3aGljaCBhcmUgaW4gYSBydWxlIHN0b3Agc3RhdGVcclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCByZW1vdmVBbGxDb25maWdzTm90SW5SdWxlU3RvcFN0YXRlKEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogQVROQ29uZmlnU2V0IHtcclxuXHRcdGlmIChQcmVkaWN0aW9uTW9kZS5hbGxDb25maWdzSW5SdWxlU3RvcFN0YXRlcyhjb25maWdzKSkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlncztcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVzdWx0OiBBVE5Db25maWdTZXQgPSBuZXcgQVROQ29uZmlnU2V0KCk7XHJcblx0XHRmb3IgKGxldCBjb25maWcgb2YgY29uZmlncykge1xyXG5cdFx0XHRpZiAoIShjb25maWcuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXN1bHQuYWRkKGNvbmZpZywgY29udGV4dENhY2hlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgY29tcHV0ZVN0YXJ0U3RhdGUoXHJcblx0XHRkZmE6IERGQSxcclxuXHRcdGdsb2JhbENvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0LFxyXG5cdFx0dXNlQ29udGV4dDogYm9vbGVhbik6IFNpbXVsYXRvclN0YXRlIHtcclxuXHRcdGxldCBzMDogREZBU3RhdGUgfCB1bmRlZmluZWQgPVxyXG5cdFx0XHRkZmEuaXNQcmVjZWRlbmNlRGZhID8gZGZhLmdldFByZWNlZGVuY2VTdGFydFN0YXRlKHRoaXMuX3BhcnNlci5wcmVjZWRlbmNlLCB1c2VDb250ZXh0KSA6XHJcblx0XHRcdFx0dXNlQ29udGV4dCA/IGRmYS5zMGZ1bGwgOlxyXG5cdFx0XHRcdFx0ZGZhLnMwO1xyXG5cclxuXHRcdGlmIChzMCAhPSBudWxsKSB7XHJcblx0XHRcdGlmICghdXNlQ29udGV4dCkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgU2ltdWxhdG9yU3RhdGUoZ2xvYmFsQ29udGV4dCwgczAsIHVzZUNvbnRleHQsIGdsb2JhbENvbnRleHQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzMC5zZXRDb250ZXh0U2Vuc2l0aXZlKHRoaXMuYXRuKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZGVjaXNpb246IG51bWJlciA9IGRmYS5kZWNpc2lvbjtcclxuXHRcdC8vIEBOb3ROdWxsXHJcblx0XHRsZXQgcDogQVROU3RhdGUgPSBkZmEuYXRuU3RhcnRTdGF0ZTtcclxuXHJcblx0XHRsZXQgcHJldmlvdXNDb250ZXh0OiBudW1iZXIgPSAwO1xyXG5cdFx0bGV0IHJlbWFpbmluZ0dsb2JhbENvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkID0gZ2xvYmFsQ29udGV4dDtcclxuXHRcdGxldCBpbml0aWFsQ29udGV4dDogUHJlZGljdGlvbkNvbnRleHQgPSB1c2VDb250ZXh0ID8gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTCA6IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMOyAvLyBhbHdheXMgYXQgbGVhc3QgdGhlIGltcGxpY2l0IGNhbGwgdG8gc3RhcnQgcnVsZVxyXG5cdFx0bGV0IGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSA9IG5ldyBQcmVkaWN0aW9uQ29udGV4dENhY2hlKCk7XHJcblx0XHRpZiAodXNlQ29udGV4dCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuZW5hYmxlX2dsb2JhbF9jb250ZXh0X2RmYSkge1xyXG5cdFx0XHRcdHdoaWxlIChyZW1haW5pbmdHbG9iYWxDb250ZXh0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGlmIChyZW1haW5pbmdHbG9iYWxDb250ZXh0LmlzRW1wdHkpIHtcclxuXHRcdFx0XHRcdFx0cHJldmlvdXNDb250ZXh0ID0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVk7XHJcblx0XHRcdFx0XHRcdHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0cHJldmlvdXNDb250ZXh0ID0gdGhpcy5nZXRSZXR1cm5TdGF0ZShyZW1haW5pbmdHbG9iYWxDb250ZXh0KTtcclxuXHRcdFx0XHRcdFx0aW5pdGlhbENvbnRleHQgPSBpbml0aWFsQ29udGV4dC5hcHBlbmRTaW5nbGVDb250ZXh0KHByZXZpb3VzQ29udGV4dCwgY29udGV4dENhY2hlKTtcclxuXHRcdFx0XHRcdFx0cmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHJlbWFpbmluZ0dsb2JhbENvbnRleHQucGFyZW50O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2hpbGUgKHMwICE9IG51bGwgJiYgczAuaXNDb250ZXh0U2Vuc2l0aXZlICYmIHJlbWFpbmluZ0dsb2JhbENvbnRleHQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdGxldCBuZXh0OiBERkFTdGF0ZSB8IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRyZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gdGhpcy5za2lwVGFpbENhbGxzKHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xyXG5cdFx0XHRcdGlmIChyZW1haW5pbmdHbG9iYWxDb250ZXh0LmlzRW1wdHkpIHtcclxuXHRcdFx0XHRcdG5leHQgPSBzMC5nZXRDb250ZXh0VGFyZ2V0KFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKTtcclxuXHRcdFx0XHRcdHByZXZpb3VzQ29udGV4dCA9IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZO1xyXG5cdFx0XHRcdFx0cmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRwcmV2aW91c0NvbnRleHQgPSB0aGlzLmdldFJldHVyblN0YXRlKHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xyXG5cdFx0XHRcdFx0bmV4dCA9IHMwLmdldENvbnRleHRUYXJnZXQocHJldmlvdXNDb250ZXh0KTtcclxuXHRcdFx0XHRcdGluaXRpYWxDb250ZXh0ID0gaW5pdGlhbENvbnRleHQuYXBwZW5kU2luZ2xlQ29udGV4dChwcmV2aW91c0NvbnRleHQsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0XHRyZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gcmVtYWluaW5nR2xvYmFsQ29udGV4dC5wYXJlbnQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAobmV4dCA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHMwID0gbmV4dDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzMCAhPSBudWxsICYmICFzMC5pc0NvbnRleHRTZW5zaXRpdmUpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBTaW11bGF0b3JTdGF0ZShnbG9iYWxDb250ZXh0LCBzMCwgdXNlQ29udGV4dCwgcmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCA9IG5ldyBBVE5Db25maWdTZXQoKTtcclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGxldCByZWFjaEludGVybWVkaWF0ZTogQVROQ29uZmlnU2V0ID0gbmV3IEFUTkNvbmZpZ1NldCgpO1xyXG5cdFx0XHRsZXQgbjogbnVtYmVyID0gcC5udW1iZXJPZlRyYW5zaXRpb25zO1xyXG5cdFx0XHRmb3IgKGxldCB0aSA9IDA7IHRpIDwgbjsgdGkrKykge1xyXG5cdFx0XHRcdC8vIGZvciBlYWNoIHRyYW5zaXRpb25cclxuXHRcdFx0XHRsZXQgdGFyZ2V0OiBBVE5TdGF0ZSA9IHAudHJhbnNpdGlvbih0aSkudGFyZ2V0O1xyXG5cdFx0XHRcdHJlYWNoSW50ZXJtZWRpYXRlLmFkZChBVE5Db25maWcuY3JlYXRlKHRhcmdldCwgdGkgKyAxLCBpbml0aWFsQ29udGV4dCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgaGFzTW9yZUNvbnRleHQ6IGJvb2xlYW4gPSByZW1haW5pbmdHbG9iYWxDb250ZXh0ICE9IG51bGw7XHJcblx0XHRcdGlmICghaGFzTW9yZUNvbnRleHQpIHtcclxuXHRcdFx0XHRjb25maWdzLmlzT3V0ZXJtb3N0Q29uZmlnU2V0ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGNvbGxlY3RQcmVkaWNhdGVzOiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5jbG9zdXJlKHJlYWNoSW50ZXJtZWRpYXRlLCBjb25maWdzLCBjb2xsZWN0UHJlZGljYXRlcywgaGFzTW9yZUNvbnRleHQsIGNvbnRleHRDYWNoZSwgZmFsc2UpO1xyXG5cdFx0XHRsZXQgc3RlcEludG9HbG9iYWw6IGJvb2xlYW4gPSBjb25maWdzLmRpcHNJbnRvT3V0ZXJDb250ZXh0O1xyXG5cclxuXHRcdFx0bGV0IG5leHQ6IERGQVN0YXRlO1xyXG5cdFx0XHRpZiAodXNlQ29udGV4dCAmJiAhdGhpcy5lbmFibGVfZ2xvYmFsX2NvbnRleHRfZGZhKSB7XHJcblx0XHRcdFx0czAgPSB0aGlzLmFkZERGQVN0YXRlKGRmYSwgY29uZmlncywgY29udGV4dENhY2hlKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChzMCA9PSBudWxsKSB7XHJcblx0XHRcdFx0aWYgKCFkZmEuaXNQcmVjZWRlbmNlRGZhKSB7XHJcblx0XHRcdFx0XHRuZXh0ID0gdGhpcy5hZGRERkFTdGF0ZShkZmEsIGNvbmZpZ3MsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0XHRpZiAodXNlQ29udGV4dCkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIWRmYS5zMGZ1bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRkZmEuczBmdWxsID0gbmV4dDtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRuZXh0ID0gZGZhLnMwZnVsbDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0aWYgKCFkZmEuczApIHtcclxuXHRcdFx0XHRcdFx0XHRkZmEuczAgPSBuZXh0O1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdG5leHQgPSBkZmEuczA7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHQvKiBJZiB0aGlzIGlzIGEgcHJlY2VkZW5jZSBERkEsIHdlIHVzZSBhcHBseVByZWNlZGVuY2VGaWx0ZXJcclxuXHRcdFx0XHRcdCAqIHRvIGNvbnZlcnQgdGhlIGNvbXB1dGVkIHN0YXJ0IHN0YXRlIHRvIGEgcHJlY2VkZW5jZSBzdGFydFxyXG5cdFx0XHRcdFx0ICogc3RhdGUuIFdlIHRoZW4gdXNlIERGQS5zZXRQcmVjZWRlbmNlU3RhcnRTdGF0ZSB0byBzZXQgdGhlXHJcblx0XHRcdFx0XHQgKiBhcHByb3ByaWF0ZSBzdGFydCBzdGF0ZSBmb3IgdGhlIHByZWNlZGVuY2UgbGV2ZWwgcmF0aGVyXHJcblx0XHRcdFx0XHQgKiB0aGFuIHNpbXBseSBzZXR0aW5nIERGQS5zMC5cclxuXHRcdFx0XHRcdCAqL1xyXG5cdFx0XHRcdFx0Y29uZmlncyA9IHRoaXMuYXBwbHlQcmVjZWRlbmNlRmlsdGVyKGNvbmZpZ3MsIGdsb2JhbENvbnRleHQsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0XHRuZXh0ID0gdGhpcy5hZGRERkFTdGF0ZShkZmEsIGNvbmZpZ3MsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0XHRkZmEuc2V0UHJlY2VkZW5jZVN0YXJ0U3RhdGUodGhpcy5fcGFyc2VyLnByZWNlZGVuY2UsIHVzZUNvbnRleHQsIG5leHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRpZiAoZGZhLmlzUHJlY2VkZW5jZURmYSkge1xyXG5cdFx0XHRcdFx0Y29uZmlncyA9IHRoaXMuYXBwbHlQcmVjZWRlbmNlRmlsdGVyKGNvbmZpZ3MsIGdsb2JhbENvbnRleHQsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRuZXh0ID0gdGhpcy5hZGRERkFTdGF0ZShkZmEsIGNvbmZpZ3MsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0czAuc2V0Q29udGV4dFRhcmdldChwcmV2aW91c0NvbnRleHQsIG5leHQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzMCA9IG5leHQ7XHJcblxyXG5cdFx0XHRpZiAoIXVzZUNvbnRleHQgfHwgIXN0ZXBJbnRvR2xvYmFsKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFRPRE86IG1ha2Ugc3VyZSBpdCBkaXN0aW5ndWlzaGVzIGVtcHR5IHN0YWNrIHN0YXRlc1xyXG5cdFx0XHRuZXh0LnNldENvbnRleHRTZW5zaXRpdmUodGhpcy5hdG4pO1xyXG5cclxuXHRcdFx0Ly8gV2Uga25vdyByZW1haW5pbmdHbG9iYWxDb250ZXh0IGlzIG5vdCB1bmRlZmluZWQgYXQgdGhpcyBwb2ludCAod2h5PylcclxuXHRcdFx0cmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHJlbWFpbmluZ0dsb2JhbENvbnRleHQgYXMgUGFyc2VyUnVsZUNvbnRleHQ7XHJcblxyXG5cdFx0XHRjb25maWdzLmNsZWFyKCk7XHJcblx0XHRcdHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSB0aGlzLnNraXBUYWlsQ2FsbHMocmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XHJcblx0XHRcdGxldCBuZXh0Q29udGV4dEVsZW1lbnQ6IG51bWJlciA9IHRoaXMuZ2V0UmV0dXJuU3RhdGUocmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XHJcblxyXG5cdFx0XHRpZiAocmVtYWluaW5nR2xvYmFsQ29udGV4dC5pc0VtcHR5KSB7XHJcblx0XHRcdFx0cmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gcmVtYWluaW5nR2xvYmFsQ29udGV4dC5wYXJlbnQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChuZXh0Q29udGV4dEVsZW1lbnQgIT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XHJcblx0XHRcdFx0aW5pdGlhbENvbnRleHQgPSBpbml0aWFsQ29udGV4dC5hcHBlbmRTaW5nbGVDb250ZXh0KG5leHRDb250ZXh0RWxlbWVudCwgY29udGV4dENhY2hlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cHJldmlvdXNDb250ZXh0ID0gbmV4dENvbnRleHRFbGVtZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgU2ltdWxhdG9yU3RhdGUoZ2xvYmFsQ29udGV4dCwgczAsIHVzZUNvbnRleHQsIHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgdHJhbnNmb3JtcyB0aGUgc3RhcnQgc3RhdGUgY29tcHV0ZWQgYnlcclxuXHQgKiB7QGxpbmsgI2NvbXB1dGVTdGFydFN0YXRlfSB0byB0aGUgc3BlY2lhbCBzdGFydCBzdGF0ZSB1c2VkIGJ5IGFcclxuXHQgKiBwcmVjZWRlbmNlIERGQSBmb3IgYSBwYXJ0aWN1bGFyIHByZWNlZGVuY2UgdmFsdWUuIFRoZSB0cmFuc2Zvcm1hdGlvblxyXG5cdCAqIHByb2Nlc3MgYXBwbGllcyB0aGUgZm9sbG93aW5nIGNoYW5nZXMgdG8gdGhlIHN0YXJ0IHN0YXRlJ3MgY29uZmlndXJhdGlvblxyXG5cdCAqIHNldC5cclxuXHQgKlxyXG5cdCAqIDEuIEV2YWx1YXRlIHRoZSBwcmVjZWRlbmNlIHByZWRpY2F0ZXMgZm9yIGVhY2ggY29uZmlndXJhdGlvbiB1c2luZ1xyXG5cdCAqICAgIHtAbGluayBTZW1hbnRpY0NvbnRleHQjZXZhbFByZWNlZGVuY2V9LlxyXG5cdCAqIDEuIFdoZW4ge0BsaW5rIEFUTkNvbmZpZyNpc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkfSBpcyBgZmFsc2VgLFxyXG5cdCAqICAgIHJlbW92ZSBhbGwgY29uZmlndXJhdGlvbnMgd2hpY2ggcHJlZGljdCBhbiBhbHRlcm5hdGl2ZSBncmVhdGVyIHRoYW4gMSxcclxuXHQgKiAgICBmb3Igd2hpY2ggYW5vdGhlciBjb25maWd1cmF0aW9uIHRoYXQgcHJlZGljdHMgYWx0ZXJuYXRpdmUgMSBpcyBpbiB0aGVcclxuXHQgKiAgICBzYW1lIEFUTiBzdGF0ZSB3aXRoIHRoZSBzYW1lIHByZWRpY3Rpb24gY29udGV4dC4gVGhpcyB0cmFuc2Zvcm1hdGlvbiBpc1xyXG5cdCAqICAgIHZhbGlkIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XHJcblx0ICpcclxuXHQgKiAgICAgKiBUaGUgY2xvc3VyZSBibG9jayBjYW5ub3QgY29udGFpbiBhbnkgZXBzaWxvbiB0cmFuc2l0aW9ucyB3aGljaCBieXBhc3NcclxuXHQgKiAgICAgICB0aGUgYm9keSBvZiB0aGUgY2xvc3VyZSwgc28gYWxsIHN0YXRlcyByZWFjaGFibGUgdmlhIGFsdGVybmF0aXZlIDEgYXJlXHJcblx0ICogICAgICAgcGFydCBvZiB0aGUgcHJlY2VkZW5jZSBhbHRlcm5hdGl2ZXMgb2YgdGhlIHRyYW5zZm9ybWVkIGxlZnQtcmVjdXJzaXZlXHJcblx0ICogICAgICAgcnVsZS5cclxuXHQgKiAgICAgKiBUaGUgXCJwcmltYXJ5XCIgcG9ydGlvbiBvZiBhIGxlZnQgcmVjdXJzaXZlIHJ1bGUgY2Fubm90IGNvbnRhaW4gYW5cclxuXHQgKiAgICAgICBlcHNpbG9uIHRyYW5zaXRpb24sIHNvIHRoZSBvbmx5IHdheSBhbiBhbHRlcm5hdGl2ZSBvdGhlciB0aGFuIDEgY2FuIGV4aXN0XHJcblx0ICogICAgICAgaW4gYSBzdGF0ZSB0aGF0IGlzIGFsc28gcmVhY2hhYmxlIHZpYSBhbHRlcm5hdGl2ZSAxIGlzIGJ5IG5lc3RpbmcgY2FsbHNcclxuXHQgKiAgICAgICB0byB0aGUgbGVmdC1yZWN1cnNpdmUgcnVsZSwgd2l0aCB0aGUgb3V0ZXIgY2FsbHMgbm90IGJlaW5nIGF0IHRoZVxyXG5cdCAqICAgICAgIHByZWZlcnJlZCBwcmVjZWRlbmNlIGxldmVsLiBUaGVcclxuXHQgKiAgICAgICB7QGxpbmsgQVROQ29uZmlnI2lzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWR9IHByb3BlcnR5IG1hcmtzIEFUTlxyXG5cdCAqICAgICAgIGNvbmZpZ3VyYXRpb25zIHdoaWNoIGRvIG5vdCBtZWV0IHRoaXMgY29uZGl0aW9uLCBhbmQgdGhlcmVmb3JlIGFyZSBub3RcclxuXHQgKiAgICAgICBlbGlnaWJsZSBmb3IgZWxpbWluYXRpb24gZHVyaW5nIHRoZSBmaWx0ZXJpbmcgcHJvY2Vzcy5cclxuXHQgKlxyXG5cdCAqIFRoZSBwcmVkaWN0aW9uIGNvbnRleHQgbXVzdCBiZSBjb25zaWRlcmVkIGJ5IHRoaXMgZmlsdGVyIHRvIGFkZHJlc3NcclxuXHQgKiBzaXR1YXRpb25zIGxpa2UgdGhlIGZvbGxvd2luZy5cclxuXHQgKlxyXG5cdCAqIGBgYGFudGxyXHJcblx0ICogZ3JhbW1hciBUQTtcclxuXHQgKiBwcm9nOiBzdGF0ZW1lbnQqIEVPRjtcclxuXHQgKiBzdGF0ZW1lbnQ6IGxldHRlckEgfCBzdGF0ZW1lbnQgbGV0dGVyQSAnYicgO1xyXG5cdCAqIGxldHRlckE6ICdhJztcclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIElmIHRoZSBhYm92ZSBncmFtbWFyLCB0aGUgQVROIHN0YXRlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgdG9rZW5cclxuXHQgKiByZWZlcmVuY2UgYCdhJ2AgaW4gYGxldHRlckFgIGlzIHJlYWNoYWJsZSBmcm9tIHRoZSBsZWZ0IGVkZ2VcclxuXHQgKiBvZiBib3RoIHRoZSBwcmltYXJ5IGFuZCBjbG9zdXJlIGJsb2NrcyBvZiB0aGUgbGVmdC1yZWN1cnNpdmUgcnVsZVxyXG5cdCAqIGBzdGF0ZW1lbnRgLiBUaGUgcHJlZGljdGlvbiBjb250ZXh0IGFzc29jaWF0ZWQgd2l0aCBlYWNoIG9mIHRoZXNlXHJcblx0ICogY29uZmlndXJhdGlvbnMgZGlzdGluZ3Vpc2hlcyBiZXR3ZWVuIHRoZW0sIGFuZCBwcmV2ZW50cyB0aGUgYWx0ZXJuYXRpdmVcclxuXHQgKiB3aGljaCBzdGVwcGVkIG91dCB0byBgcHJvZ2AgKGFuZCB0aGVuIGJhY2sgaW4gdG8gYHN0YXRlbWVudGBcclxuXHQgKiBmcm9tIGJlaW5nIGVsaW1pbmF0ZWQgYnkgdGhlIGZpbHRlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBjb25maWdzIFRoZSBjb25maWd1cmF0aW9uIHNldCBjb21wdXRlZCBieVxyXG5cdCAqIHtAbGluayAjY29tcHV0ZVN0YXJ0U3RhdGV9IGFzIHRoZSBzdGFydCBzdGF0ZSBmb3IgdGhlIERGQS5cclxuXHQgKiBAcmV0dXJucyBUaGUgdHJhbnNmb3JtZWQgY29uZmlndXJhdGlvbiBzZXQgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBzdGF0ZVxyXG5cdCAqIGZvciBhIHByZWNlZGVuY2UgREZBIGF0IGEgcGFydGljdWxhciBwcmVjZWRlbmNlIGxldmVsIChkZXRlcm1pbmVkIGJ5XHJcblx0ICogY2FsbGluZyB7QGxpbmsgUGFyc2VyI2dldFByZWNlZGVuY2V9KS5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBhcHBseVByZWNlZGVuY2VGaWx0ZXIoQE5vdE51bGwgY29uZmlnczogQVROQ29uZmlnU2V0LCBnbG9iYWxDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogQVROQ29uZmlnU2V0IHtcclxuXHRcdGxldCBzdGF0ZXNGcm9tQWx0MTogTWFwPG51bWJlciwgUHJlZGljdGlvbkNvbnRleHQ+ID0gbmV3IE1hcDxudW1iZXIsIFByZWRpY3Rpb25Db250ZXh0PigpO1xyXG5cdFx0bGV0IGNvbmZpZ1NldDogQVROQ29uZmlnU2V0ID0gbmV3IEFUTkNvbmZpZ1NldCgpO1xyXG5cdFx0Zm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpIHtcclxuXHRcdFx0Ly8gaGFuZGxlIGFsdCAxIGZpcnN0XHJcblx0XHRcdGlmIChjb25maWcuYWx0ICE9PSAxKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCB1cGRhdGVkQ29udGV4dDogU2VtYW50aWNDb250ZXh0IHwgdW5kZWZpbmVkID0gY29uZmlnLnNlbWFudGljQ29udGV4dC5ldmFsUHJlY2VkZW5jZSh0aGlzLl9wYXJzZXIsIGdsb2JhbENvbnRleHQpO1xyXG5cdFx0XHRpZiAodXBkYXRlZENvbnRleHQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdC8vIHRoZSBjb25maWd1cmF0aW9uIHdhcyBlbGltaW5hdGVkXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN0YXRlc0Zyb21BbHQxLnNldChjb25maWcuc3RhdGUuc3RhdGVOdW1iZXIsIGNvbmZpZy5jb250ZXh0KTtcclxuXHRcdFx0aWYgKHVwZGF0ZWRDb250ZXh0ICE9PSBjb25maWcuc2VtYW50aWNDb250ZXh0KSB7XHJcblx0XHRcdFx0Y29uZmlnU2V0LmFkZChjb25maWcudHJhbnNmb3JtKGNvbmZpZy5zdGF0ZSwgZmFsc2UsIHVwZGF0ZWRDb250ZXh0KSwgY29udGV4dENhY2hlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRjb25maWdTZXQuYWRkKGNvbmZpZywgY29udGV4dENhY2hlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKSB7XHJcblx0XHRcdGlmIChjb25maWcuYWx0ID09PSAxKSB7XHJcblx0XHRcdFx0Ly8gYWxyZWFkeSBoYW5kbGVkXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghY29uZmlnLmlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQpIHtcclxuXHRcdFx0XHQvKiBJbiB0aGUgZnV0dXJlLCB0aGlzIGVsaW1pbmF0aW9uIHN0ZXAgY291bGQgYmUgdXBkYXRlZCB0byBhbHNvXHJcblx0XHRcdFx0ICogZmlsdGVyIHRoZSBwcmVkaWN0aW9uIGNvbnRleHQgZm9yIGFsdGVybmF0aXZlcyBwcmVkaWN0aW5nIGFsdD4xXHJcblx0XHRcdFx0ICogKGJhc2ljYWxseSBhIGdyYXBoIHN1YnRyYWN0aW9uIGFsZ29yaXRobSkuXHJcblx0XHRcdFx0ICovXHJcblx0XHRcdFx0bGV0IGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0IHwgdW5kZWZpbmVkID0gc3RhdGVzRnJvbUFsdDEuZ2V0KGNvbmZpZy5zdGF0ZS5zdGF0ZU51bWJlcik7XHJcblx0XHRcdFx0aWYgKGNvbnRleHQgIT0gbnVsbCAmJiBjb250ZXh0LmVxdWFscyhjb25maWcuY29udGV4dCkpIHtcclxuXHRcdFx0XHRcdC8vIGVsaW1pbmF0ZWRcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uZmlnU2V0LmFkZChjb25maWcsIGNvbnRleHRDYWNoZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZ1NldDtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRSZWFjaGFibGVUYXJnZXQoQE5vdE51bGwgc291cmNlOiBBVE5Db25maWcsIEBOb3ROdWxsIHRyYW5zOiBUcmFuc2l0aW9uLCB0dHlwZTogbnVtYmVyKTogQVROU3RhdGUgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKHRyYW5zLm1hdGNoZXModHR5cGUsIDAsIHRoaXMuYXRuLm1heFRva2VuVHlwZSkpIHtcclxuXHRcdFx0cmV0dXJuIHRyYW5zLnRhcmdldDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqIGNvbGxlY3QgYW5kIHNldCBEJ3Mgc2VtYW50aWMgY29udGV4dCAqL1xyXG5cdHByb3RlY3RlZCBwcmVkaWNhdGVERkFTdGF0ZShcclxuXHRcdEQ6IERGQVN0YXRlLFxyXG5cdFx0Y29uZmlnczogQVROQ29uZmlnU2V0LFxyXG5cdFx0bmFsdHM6IG51bWJlcik6IERGQVN0YXRlLlByZWRQcmVkaWN0aW9uW10gfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IGNvbmZsaWN0aW5nQWx0czogQml0U2V0IHwgdW5kZWZpbmVkID0gdGhpcy5nZXRDb25mbGljdGluZ0FsdHNGcm9tQ29uZmlnU2V0KGNvbmZpZ3MpO1xyXG5cdFx0aWYgKCFjb25mbGljdGluZ0FsdHMpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhpcyB1bmhhbmRsZWQgc2NlbmFyaW8gaXMgaW50ZW5kZWQgdG8gYmUgdW5yZWFjaGFibGUsIGJ1dCBJJ20gY3VycmVudGx5IG5vdCBzdXJlIG9mIHdoeSB3ZSBrbm93IHRoYXQncyB0aGUgY2FzZS5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcInByZWRpY2F0ZURGQVN0YXRlIFwiICsgRCk7XHJcblx0XHR9XHJcblx0XHRsZXQgYWx0VG9QcmVkOiBTZW1hbnRpY0NvbnRleHRbXSB8IHVuZGVmaW5lZCA9IHRoaXMuZ2V0UHJlZHNGb3JBbWJpZ0FsdHMoY29uZmxpY3RpbmdBbHRzLCBjb25maWdzLCBuYWx0cyk7XHJcblx0XHQvLyBhbHRUb1ByZWRbdW5pcXVlQWx0XSBpcyBub3cgb3VyIHZhbGlkYXRpbmcgcHJlZGljYXRlIChpZiBhbnkpXHJcblx0XHRsZXQgcHJlZFByZWRpY3Rpb25zOiBERkFTdGF0ZS5QcmVkUHJlZGljdGlvbltdIHwgdW5kZWZpbmVkO1xyXG5cdFx0aWYgKGFsdFRvUHJlZCAhPSBudWxsKSB7XHJcblx0XHRcdC8vIHdlIGhhdmUgYSB2YWxpZGF0aW5nIHByZWRpY2F0ZTsgdGVzdCBpdFxyXG5cdFx0XHQvLyBVcGRhdGUgREZBIHNvIHJlYWNoIGJlY29tZXMgYWNjZXB0IHN0YXRlIHdpdGggcHJlZGljYXRlXHJcblx0XHRcdHByZWRQcmVkaWN0aW9ucyA9IHRoaXMuZ2V0UHJlZGljYXRlUHJlZGljdGlvbnMoY29uZmxpY3RpbmdBbHRzLCBhbHRUb1ByZWQpO1xyXG5cdFx0XHRELnByZWRpY2F0ZXMgPSBwcmVkUHJlZGljdGlvbnM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcHJlZFByZWRpY3Rpb25zO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldFByZWRzRm9yQW1iaWdBbHRzKFxyXG5cdFx0QE5vdE51bGwgYW1iaWdBbHRzOiBCaXRTZXQsXHJcblx0XHRATm90TnVsbCBjb25maWdzOiBBVE5Db25maWdTZXQsXHJcblx0XHRuYWx0czogbnVtYmVyKTogU2VtYW50aWNDb250ZXh0W10gfCB1bmRlZmluZWQge1xyXG5cdFx0Ly8gUkVBQ0g9WzF8MXxbXXwwOjAsIDF8MnxbXXwwOjFdXHJcblxyXG5cdFx0LyogYWx0VG9QcmVkIHN0YXJ0cyBhcyBhbiBhcnJheSBvZiBhbGwgdW5kZWZpbmVkIGNvbnRleHRzLiBUaGUgZW50cnkgYXQgaW5kZXggaVxyXG5cdFx0ICogY29ycmVzcG9uZHMgdG8gYWx0ZXJuYXRpdmUgaS4gYWx0VG9QcmVkW2ldIG1heSBoYXZlIG9uZSBvZiB0aHJlZSB2YWx1ZXM6XHJcblx0XHQgKiAgIDEuIHVuZGVmaW5lZDogbm8gQVROQ29uZmlnIGMgaXMgZm91bmQgc3VjaCB0aGF0IGMuYWx0PT09aVxyXG5cdFx0ICogICAyLiBTZW1hbnRpY0NvbnRleHQuTk9ORTogQXQgbGVhc3Qgb25lIEFUTkNvbmZpZyBjIGV4aXN0cyBzdWNoIHRoYXRcclxuXHRcdCAqICAgICAgYy5hbHQ9PT1pIGFuZCBjLnNlbWFudGljQ29udGV4dD09PVNlbWFudGljQ29udGV4dC5OT05FLiBJbiBvdGhlciB3b3JkcyxcclxuXHRcdCAqICAgICAgYWx0IGkgaGFzIGF0IGxlYXN0IG9uZSB1bnByZWRpY2F0ZWQgY29uZmlnLlxyXG5cdFx0ICogICAzLiBOb24tTk9ORSBTZW1hbnRpYyBDb250ZXh0OiBUaGVyZSBleGlzdHMgYXQgbGVhc3Qgb25lLCBhbmQgZm9yIGFsbFxyXG5cdFx0ICogICAgICBBVE5Db25maWcgYyBzdWNoIHRoYXQgYy5hbHQ9PT1pLCBjLnNlbWFudGljQ29udGV4dCE9PVNlbWFudGljQ29udGV4dC5OT05FLlxyXG5cdFx0ICpcclxuXHRcdCAqIEZyb20gdGhpcywgaXQgaXMgY2xlYXIgdGhhdCBOT05FfHxhbnl0aGluZz09Tk9ORS5cclxuXHRcdCAqL1xyXG5cdFx0bGV0IGFsdFRvUHJlZDogQXJyYXk8U2VtYW50aWNDb250ZXh0IHwgdW5kZWZpbmVkPiB8IHVuZGVmaW5lZCA9IG5ldyBBcnJheTxTZW1hbnRpY0NvbnRleHQ+KG5hbHRzICsgMSk7XHJcblx0XHRsZXQgbjogbnVtYmVyID0gYWx0VG9QcmVkLmxlbmd0aDtcclxuXHRcdGZvciAobGV0IGMgb2YgY29uZmlncykge1xyXG5cdFx0XHRpZiAoYW1iaWdBbHRzLmdldChjLmFsdCkpIHtcclxuXHRcdFx0XHRhbHRUb1ByZWRbYy5hbHRdID0gU2VtYW50aWNDb250ZXh0Lm9yKGFsdFRvUHJlZFtjLmFsdF0sIGMuc2VtYW50aWNDb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBuUHJlZEFsdHM6IG51bWJlciA9IDA7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRpZiAoYWx0VG9QcmVkW2ldID09IG51bGwpIHtcclxuXHRcdFx0XHRhbHRUb1ByZWRbaV0gPSBTZW1hbnRpY0NvbnRleHQuTk9ORTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChhbHRUb1ByZWRbaV0gIT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XHJcblx0XHRcdFx0blByZWRBbHRzKys7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgYGFsdFRvUHJlZGAgZG9lc24ndCBjb250YWluIGFueSB1bmRlZmluZWQgZW50cmllc1xyXG5cdFx0bGV0IHJlc3VsdDogU2VtYW50aWNDb250ZXh0W10gfCB1bmRlZmluZWQgPSBhbHRUb1ByZWQgYXMgU2VtYW50aWNDb250ZXh0W107XHJcblxyXG5cdFx0Ly8gbm9uYW1iaWcgYWx0cyBhcmUgdW5kZWZpbmVkIGluIHJlc3VsdFxyXG5cdFx0aWYgKG5QcmVkQWx0cyA9PT0gMCkge1xyXG5cdFx0XHRyZXN1bHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiZ2V0UHJlZHNGb3JBbWJpZ0FsdHMgcmVzdWx0IFwiICsgKHJlc3VsdCA/IEFycmF5cy50b1N0cmluZyhyZXN1bHQpIDogXCJ1bmRlZmluZWRcIikpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRQcmVkaWNhdGVQcmVkaWN0aW9ucyhhbWJpZ0FsdHM6IEJpdFNldCB8IHVuZGVmaW5lZCwgYWx0VG9QcmVkOiBTZW1hbnRpY0NvbnRleHRbXSk6IERGQVN0YXRlLlByZWRQcmVkaWN0aW9uW10gfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IHBhaXJzOiBERkFTdGF0ZS5QcmVkUHJlZGljdGlvbltdID0gW107XHJcblx0XHRsZXQgY29udGFpbnNQcmVkaWNhdGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgYWx0VG9QcmVkLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBwcmVkOiBTZW1hbnRpY0NvbnRleHQgPSBhbHRUb1ByZWRbaV07XHJcblxyXG5cdFx0XHQvLyB1bnByZWRpY2F0ZWQgaXMgaW5kaWNhdGVkIGJ5IFNlbWFudGljQ29udGV4dC5OT05FXHJcblx0XHRcdGFzc2VydChwcmVkICE9IG51bGwpO1xyXG5cclxuXHRcdFx0Ly8gZmluZCBmaXJzdCB1bnByZWRpY2F0ZWQgYnV0IGFtYmlnIGFsdGVybmF0aXZlLCBpZiBhbnkuXHJcblx0XHRcdC8vIE9ubHkgYW1iaWd1b3VzIGFsdGVybmF0aXZlcyB3aWxsIGhhdmUgU2VtYW50aWNDb250ZXh0Lk5PTkUuXHJcblx0XHRcdC8vIEFueSB1bmFtYmlnIGFsdHMgb3IgYW1iaWcgbmFrZWQgYWx0cyBhZnRlciBmaXJzdCBhbWJpZyBuYWtlZCBhcmUgaWdub3JlZFxyXG5cdFx0XHQvLyAodW5kZWZpbmVkLCBpKSBtZWFucyBhbHQgaSBpcyB0aGUgZGVmYXVsdCBwcmVkaWN0aW9uXHJcblx0XHRcdC8vIGlmIG5vICh1bmRlZmluZWQsIGkpLCB0aGVuIG5vIGRlZmF1bHQgcHJlZGljdGlvbi5cclxuXHRcdFx0aWYgKGFtYmlnQWx0cyAhPSBudWxsICYmIGFtYmlnQWx0cy5nZXQoaSkgJiYgcHJlZCA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcclxuXHRcdFx0XHRwYWlycy5wdXNoKG5ldyBERkFTdGF0ZS5QcmVkUHJlZGljdGlvbihwcmVkLCBpKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAocHJlZCAhPT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcclxuXHRcdFx0XHRjb250YWluc1ByZWRpY2F0ZSA9IHRydWU7XHJcblx0XHRcdFx0cGFpcnMucHVzaChuZXcgREZBU3RhdGUuUHJlZFByZWRpY3Rpb24ocHJlZCwgaSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFjb250YWluc1ByZWRpY2F0ZSkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuLy9cdFx0U3lzdGVtLm91dC5wcmludGxuKEFycmF5cy50b1N0cmluZyhhbHRUb1ByZWQpK1wiLT5cIitwYWlycyk7XHJcblx0XHRyZXR1cm4gcGFpcnM7XHJcblx0fVxyXG5cclxuXHQvKiogTG9vayB0aHJvdWdoIGEgbGlzdCBvZiBwcmVkaWNhdGUvYWx0IHBhaXJzLCByZXR1cm5pbmcgYWx0cyBmb3IgdGhlXHJcblx0ICogIHBhaXJzIHRoYXQgd2luLiBBbiBgdW5kZWZpbmVkYCBwcmVkaWNhdGUgaW5kaWNhdGVzIGFuIGFsdCBjb250YWluaW5nIGFuXHJcblx0ICogIHVucHJlZGljYXRlZCBjb25maWcgd2hpY2ggYmVoYXZlcyBhcyBcImFsd2F5cyB0cnVlLlwiXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGV2YWxTZW1hbnRpY0NvbnRleHQoXHJcblx0XHRATm90TnVsbCBwcmVkUHJlZGljdGlvbnM6IERGQVN0YXRlLlByZWRQcmVkaWN0aW9uW10sXHJcblx0XHRvdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0LFxyXG5cdFx0Y29tcGxldGU6IGJvb2xlYW4pOiBCaXRTZXQge1xyXG5cdFx0bGV0IHByZWRpY3Rpb25zOiBCaXRTZXQgPSBuZXcgQml0U2V0KCk7XHJcblx0XHRmb3IgKGxldCBwYWlyIG9mIHByZWRQcmVkaWN0aW9ucykge1xyXG5cdFx0XHRpZiAocGFpci5wcmVkID09PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xyXG5cdFx0XHRcdHByZWRpY3Rpb25zLnNldChwYWlyLmFsdCk7XHJcblx0XHRcdFx0aWYgKCFjb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGV2YWx1YXRlZFJlc3VsdDogYm9vbGVhbiA9IHRoaXMuZXZhbFNlbWFudGljQ29udGV4dEltcGwocGFpci5wcmVkLCBvdXRlckNvbnRleHQsIHBhaXIuYWx0KTtcclxuXHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1ZyB8fCBQYXJzZXJBVE5TaW11bGF0b3IuZGZhX2RlYnVnKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJldmFsIHByZWQgXCIgKyBwYWlyICsgXCI9XCIgKyBldmFsdWF0ZWRSZXN1bHQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZXZhbHVhdGVkUmVzdWx0KSB7XHJcblx0XHRcdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1ZyB8fCBQYXJzZXJBVE5TaW11bGF0b3IuZGZhX2RlYnVnKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIlBSRURJQ1QgXCIgKyBwYWlyLmFsdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHByZWRpY3Rpb25zLnNldChwYWlyLmFsdCk7XHJcblx0XHRcdFx0aWYgKCFjb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByZWRpY3Rpb25zO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXZhbHVhdGUgYSBzZW1hbnRpYyBjb250ZXh0IHdpdGhpbiBhIHNwZWNpZmljIHBhcnNlciBjb250ZXh0LlxyXG5cdCAqXHJcblx0ICogVGhpcyBtZXRob2QgbWlnaHQgbm90IGJlIGNhbGxlZCBmb3IgZXZlcnkgc2VtYW50aWMgY29udGV4dCBldmFsdWF0ZWRcclxuXHQgKiBkdXJpbmcgdGhlIHByZWRpY3Rpb24gcHJvY2Vzcy4gSW4gcGFydGljdWxhciwgd2UgY3VycmVudGx5IGRvIG5vdFxyXG5cdCAqIGV2YWx1YXRlIHRoZSBmb2xsb3dpbmcgYnV0IGl0IG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZTpcclxuXHQgKlxyXG5cdCAqICogUHJlY2VkZW5jZSBwcmVkaWNhdGVzIChyZXByZXNlbnRlZCBieVxyXG5cdCAqICAge0BsaW5rIFNlbWFudGljQ29udGV4dC5QcmVjZWRlbmNlUHJlZGljYXRlfSkgYXJlIG5vdCBjdXJyZW50bHkgZXZhbHVhdGVkXHJcblx0ICogICB0aHJvdWdoIHRoaXMgbWV0aG9kLlxyXG5cdCAqICogT3BlcmF0b3IgcHJlZGljYXRlcyAocmVwcmVzZW50ZWQgYnkge0BsaW5rIFNlbWFudGljQ29udGV4dC5BTkR9IGFuZFxyXG5cdCAqICAge0BsaW5rIFNlbWFudGljQ29udGV4dC5PUn0pIGFyZSBldmFsdWF0ZWQgYXMgYSBzaW5nbGUgc2VtYW50aWNcclxuXHQgKiAgIGNvbnRleHQsIHJhdGhlciB0aGFuIGV2YWx1YXRpbmcgdGhlIG9wZXJhbmRzIGluZGl2aWR1YWxseS5cclxuXHQgKiAgIEltcGxlbWVudGF0aW9ucyB3aGljaCByZXF1aXJlIGV2YWx1YXRpb24gcmVzdWx0cyBmcm9tIGluZGl2aWR1YWxcclxuXHQgKiAgIHByZWRpY2F0ZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGV4cGxpY2l0bHkgaGFuZGxlIGV2YWx1YXRpb24gb2ZcclxuXHQgKiAgIHRoZSBvcGVyYW5kcyB3aXRoaW4gb3BlcmF0b3IgcHJlZGljYXRlcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBwcmVkIFRoZSBzZW1hbnRpYyBjb250ZXh0IHRvIGV2YWx1YXRlXHJcblx0ICogQHBhcmFtIHBhcnNlckNhbGxTdGFjayBUaGUgcGFyc2VyIGNvbnRleHQgaW4gd2hpY2ggdG8gZXZhbHVhdGUgdGhlXHJcblx0ICogc2VtYW50aWMgY29udGV4dFxyXG5cdCAqIEBwYXJhbSBhbHQgVGhlIGFsdGVybmF0aXZlIHdoaWNoIGlzIGd1YXJkZWQgYnkgYHByZWRgXHJcblx0ICpcclxuXHQgKiBAc2luY2UgNC4zXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGV2YWxTZW1hbnRpY0NvbnRleHRJbXBsKEBOb3ROdWxsIHByZWQ6IFNlbWFudGljQ29udGV4dCwgcGFyc2VyQ2FsbFN0YWNrOiBQYXJzZXJSdWxlQ29udGV4dCwgYWx0OiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBwcmVkLmV2YWwodGhpcy5fcGFyc2VyLCBwYXJzZXJDYWxsU3RhY2spO1xyXG5cdH1cclxuXHJcblx0LyogVE9ETzogSWYgd2UgYXJlIGRvaW5nIHByZWRpY2F0ZXMsIHRoZXJlIGlzIG5vIHBvaW50IGluIHB1cnN1aW5nXHJcblx0XHQgY2xvc3VyZSBvcGVyYXRpb25zIGlmIHdlIHJlYWNoIGEgREZBIHN0YXRlIHRoYXQgdW5pcXVlbHkgcHJlZGljdHNcclxuXHRcdCBhbHRlcm5hdGl2ZS4gV2Ugd2lsbCBub3QgYmUgY2FjaGluZyB0aGF0IERGQSBzdGF0ZSBhbmQgaXQgaXMgYVxyXG5cdFx0IHdhc3RlIHRvIHB1cnN1ZSB0aGUgY2xvc3VyZS4gTWlnaHQgaGF2ZSB0byBhZHZhbmNlIHdoZW4gd2UgZG9cclxuXHRcdCBhbWJpZyBkZXRlY3Rpb24gdGhvdWdodCA6KFxyXG5cdFx0ICAqL1xyXG5cclxuXHRwcm90ZWN0ZWQgY2xvc3VyZShcclxuXHRcdHNvdXJjZUNvbmZpZ3M6IEFUTkNvbmZpZ1NldCxcclxuXHRcdEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCxcclxuXHRcdGNvbGxlY3RQcmVkaWNhdGVzOiBib29sZWFuLFxyXG5cdFx0aGFzTW9yZUNvbnRleHQ6IGJvb2xlYW4sXHJcblx0XHRATnVsbGFibGUgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlLFxyXG5cdFx0dHJlYXRFb2ZBc0Vwc2lsb246IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGlmIChjb250ZXh0Q2FjaGUgPT0gbnVsbCkge1xyXG5cdFx0XHRjb250ZXh0Q2FjaGUgPSBQcmVkaWN0aW9uQ29udGV4dENhY2hlLlVOQ0FDSEVEO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjdXJyZW50Q29uZmlnczogQVROQ29uZmlnU2V0ID0gc291cmNlQ29uZmlncztcclxuXHRcdGxldCBjbG9zdXJlQnVzeTogQXJyYXkyREhhc2hTZXQ8QVROQ29uZmlnPiA9IG5ldyBBcnJheTJESGFzaFNldDxBVE5Db25maWc+KE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSk7XHJcblx0XHR3aGlsZSAoY3VycmVudENvbmZpZ3Muc2l6ZSA+IDApIHtcclxuXHRcdFx0bGV0IGludGVybWVkaWF0ZTogQVROQ29uZmlnU2V0ID0gbmV3IEFUTkNvbmZpZ1NldCgpO1xyXG5cdFx0XHRmb3IgKGxldCBjb25maWcgb2YgY3VycmVudENvbmZpZ3MpIHtcclxuXHRcdFx0XHR0aGlzLmNsb3N1cmVJbXBsKGNvbmZpZywgY29uZmlncywgaW50ZXJtZWRpYXRlLCBjbG9zdXJlQnVzeSwgY29sbGVjdFByZWRpY2F0ZXMsIGhhc01vcmVDb250ZXh0LCBjb250ZXh0Q2FjaGUsIDAsIHRyZWF0RW9mQXNFcHNpbG9uKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3VycmVudENvbmZpZ3MgPSBpbnRlcm1lZGlhdGU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgY2xvc3VyZUltcGwoXHJcblx0XHRATm90TnVsbCBjb25maWc6IEFUTkNvbmZpZyxcclxuXHRcdEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCxcclxuXHRcdEBOdWxsYWJsZSBpbnRlcm1lZGlhdGU6IEFUTkNvbmZpZ1NldCxcclxuXHRcdEBOb3ROdWxsIGNsb3N1cmVCdXN5OiBBcnJheTJESGFzaFNldDxBVE5Db25maWc+LFxyXG5cdFx0Y29sbGVjdFByZWRpY2F0ZXM6IGJvb2xlYW4sXHJcblx0XHRoYXNNb3JlQ29udGV4dHM6IGJvb2xlYW4sXHJcblx0XHRATm90TnVsbCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUsXHJcblx0XHRkZXB0aDogbnVtYmVyLFxyXG5cdFx0dHJlYXRFb2ZBc0Vwc2lsb246IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJjbG9zdXJlKFwiICsgY29uZmlnLnRvU3RyaW5nKHRoaXMuX3BhcnNlciwgdHJ1ZSkgKyBcIilcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcclxuXHRcdFx0Ly8gV2UgaGl0IHJ1bGUgZW5kLiBJZiB3ZSBoYXZlIGNvbnRleHQgaW5mbywgdXNlIGl0XHJcblx0XHRcdGlmICghY29uZmlnLmNvbnRleHQuaXNFbXB0eSkge1xyXG5cdFx0XHRcdGxldCBoYXNFbXB0eTogYm9vbGVhbiA9IGNvbmZpZy5jb250ZXh0Lmhhc0VtcHR5O1xyXG5cdFx0XHRcdGxldCBub25FbXB0eVNpemU6IG51bWJlciA9IGNvbmZpZy5jb250ZXh0LnNpemUgLSAoaGFzRW1wdHkgPyAxIDogMCk7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBub25FbXB0eVNpemU7IGkrKykge1xyXG5cdFx0XHRcdFx0bGV0IG5ld0NvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0ID0gY29uZmlnLmNvbnRleHQuZ2V0UGFyZW50KGkpOyAvLyBcInBvcFwiIHJldHVybiBzdGF0ZVxyXG5cdFx0XHRcdFx0bGV0IHJldHVyblN0YXRlOiBBVE5TdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tjb25maWcuY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKV07XHJcblx0XHRcdFx0XHRsZXQgYzogQVROQ29uZmlnID0gQVROQ29uZmlnLmNyZWF0ZShyZXR1cm5TdGF0ZSwgY29uZmlnLmFsdCwgbmV3Q29udGV4dCwgY29uZmlnLnNlbWFudGljQ29udGV4dCk7XHJcblx0XHRcdFx0XHQvLyBXaGlsZSB3ZSBoYXZlIGNvbnRleHQgdG8gcG9wIGJhY2sgZnJvbSwgd2UgbWF5IGhhdmVcclxuXHRcdFx0XHRcdC8vIGdvdHRlbiB0aGF0IGNvbnRleHQgQUZURVIgaGF2aW5nIGZhbGxlbiBvZmYgYSBydWxlLlxyXG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHRyYWNrIHRoYXQgd2UgYXJlIG5vdyBvdXQgb2YgY29udGV4dC5cclxuXHRcdFx0XHRcdGMub3V0ZXJDb250ZXh0RGVwdGggPSBjb25maWcub3V0ZXJDb250ZXh0RGVwdGg7XHJcblx0XHRcdFx0XHRjLmlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPSBjb25maWcuaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZDtcclxuXHRcdFx0XHRcdGFzc2VydChkZXB0aCA+IE1JTl9JTlRFR0VSX1ZBTFVFKTtcclxuXHRcdFx0XHRcdHRoaXMuY2xvc3VyZUltcGwoYywgY29uZmlncywgaW50ZXJtZWRpYXRlLCBjbG9zdXJlQnVzeSwgY29sbGVjdFByZWRpY2F0ZXMsIGhhc01vcmVDb250ZXh0cywgY29udGV4dENhY2hlLCBkZXB0aCAtIDEsIHRyZWF0RW9mQXNFcHNpbG9uKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICghaGFzRW1wdHkgfHwgIWhhc01vcmVDb250ZXh0cykge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uZmlnID0gY29uZmlnLnRyYW5zZm9ybShjb25maWcuc3RhdGUsIGZhbHNlLCBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9MT0NBTCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoIWhhc01vcmVDb250ZXh0cykge1xyXG5cdFx0XHRcdGNvbmZpZ3MuYWRkKGNvbmZpZywgY29udGV4dENhY2hlKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0Ly8gZWxzZSBpZiB3ZSBoYXZlIG5vIGNvbnRleHQgaW5mbywganVzdCBjaGFzZSBmb2xsb3cgbGlua3MgKGlmIGdyZWVkeSlcclxuXHRcdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkZBTExJTkcgb2ZmIHJ1bGUgXCIgK1xyXG5cdFx0XHRcdFx0XHR0aGlzLmdldFJ1bGVOYW1lKGNvbmZpZy5zdGF0ZS5ydWxlSW5kZXgpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjb25maWcuY29udGV4dCA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTCkge1xyXG5cdFx0XHRcdFx0Ly8gbm8gbmVlZCB0byBrZWVwIGZ1bGwgY29udGV4dCBvdmVyaGVhZCB3aGVuIHdlIHN0ZXAgb3V0XHJcblx0XHRcdFx0XHRjb25maWcgPSBjb25maWcudHJhbnNmb3JtKGNvbmZpZy5zdGF0ZSwgZmFsc2UsIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoIWNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dCAmJiBQcmVkaWN0aW9uQ29udGV4dC5pc0VtcHR5TG9jYWwoY29uZmlnLmNvbnRleHQpKSB7XHJcblx0XHRcdFx0XHQvLyBhZGQgc3RvcCBzdGF0ZSB3aGVuIGxlYXZpbmcgZGVjaXNpb24gcnVsZSBmb3IgdGhlIGZpcnN0IHRpbWVcclxuXHRcdFx0XHRcdGNvbmZpZ3MuYWRkKGNvbmZpZywgY29udGV4dENhY2hlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcDogQVROU3RhdGUgPSBjb25maWcuc3RhdGU7XHJcblx0XHQvLyBvcHRpbWl6YXRpb25cclxuXHRcdGlmICghcC5vbmx5SGFzRXBzaWxvblRyYW5zaXRpb25zKSB7XHJcblx0XHRcdGNvbmZpZ3MuYWRkKGNvbmZpZywgY29udGV4dENhY2hlKTtcclxuXHRcdFx0Ly8gbWFrZSBzdXJlIHRvIG5vdCByZXR1cm4gaGVyZSwgYmVjYXVzZSBFT0YgdHJhbnNpdGlvbnMgY2FuIGFjdCBhc1xyXG5cdFx0XHQvLyBib3RoIGVwc2lsb24gdHJhbnNpdGlvbnMgYW5kIG5vbi1lcHNpbG9uIHRyYW5zaXRpb25zLlxyXG5cdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJhZGRlZCBjb25maWcgXCIgKyBjb25maWdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcC5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zOyBpKyspIHtcclxuXHRcdFx0Ly8gVGhpcyBibG9jayBpbXBsZW1lbnRzIGZpcnN0LWVkZ2UgZWxpbWluYXRpb24gb2YgYW1iaWd1b3VzIExSXHJcblx0XHRcdC8vIGFsdGVybmF0aXZlcyBhcyBwYXJ0IG9mIGR5bmFtaWMgZGlzYW1iaWd1YXRpb24gZHVyaW5nIHByZWRpY3Rpb24uXHJcblx0XHRcdC8vIFNlZSBhbnRsci9hbnRscjQjMTM5OC5cclxuXHRcdFx0aWYgKGkgPT09IDBcclxuXHRcdFx0XHQmJiBwLnN0YXRlVHlwZSA9PT0gQVROU3RhdGVUeXBlLlNUQVJfTE9PUF9FTlRSWVxyXG5cdFx0XHRcdCYmIChwIGFzIFN0YXJMb29wRW50cnlTdGF0ZSkucHJlY2VkZW5jZVJ1bGVEZWNpc2lvblxyXG5cdFx0XHRcdCYmICFjb25maWcuY29udGV4dC5oYXNFbXB0eSkge1xyXG5cclxuXHRcdFx0XHRsZXQgcHJlY2VkZW5jZURlY2lzaW9uID0gcCBhcyBTdGFyTG9vcEVudHJ5U3RhdGU7XHJcblxyXG5cdFx0XHRcdC8vIFdoZW4gc3VwcHJlc3MgaXMgdHJ1ZSwgaXQgbWVhbnMgdGhlIG91dGdvaW5nIGVkZ2UgaT09MCBpc1xyXG5cdFx0XHRcdC8vIGFtYmlndW91cyB3aXRoIHRoZSBvdXRnb2luZyBlZGdlIGk9PTEsIGFuZCB0aHVzIHRoZSBjbG9zdXJlXHJcblx0XHRcdFx0Ly8gb3BlcmF0aW9uIGNhbiBkeW5hbWljYWxseSBkaXNhbWJpZ3VhdGUgYnkgc3VwcHJlc3NpbmcgdGhpc1xyXG5cdFx0XHRcdC8vIGVkZ2UgZHVyaW5nIHRoZSBjbG9zdXJlIG9wZXJhdGlvbi5cclxuXHRcdFx0XHRsZXQgc3VwcHJlc3M6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBjb25maWcuY29udGV4dC5zaXplOyBqKyspIHtcclxuXHRcdFx0XHRcdGlmICghcHJlY2VkZW5jZURlY2lzaW9uLnByZWNlZGVuY2VMb29wYmFja1N0YXRlcy5nZXQoY29uZmlnLmNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaikpKSB7XHJcblx0XHRcdFx0XHRcdHN1cHByZXNzID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHN1cHByZXNzKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCB0OiBUcmFuc2l0aW9uID0gcC5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKGkpO1xyXG5cdFx0XHRsZXQgY29udGludWVDb2xsZWN0aW5nOiBib29sZWFuID1cclxuXHRcdFx0XHQhKHQgaW5zdGFuY2VvZiBBY3Rpb25UcmFuc2l0aW9uKSAmJiBjb2xsZWN0UHJlZGljYXRlcztcclxuXHRcdFx0bGV0IGM6IEFUTkNvbmZpZyB8IHVuZGVmaW5lZCA9IHRoaXMuZ2V0RXBzaWxvblRhcmdldChjb25maWcsIHQsIGNvbnRpbnVlQ29sbGVjdGluZywgZGVwdGggPT09IDAsIGNvbnRleHRDYWNoZSwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xyXG5cdFx0XHRpZiAoYyAhPSBudWxsKSB7XHJcblx0XHRcdFx0aWYgKHQgaW5zdGFuY2VvZiBSdWxlVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdFx0aWYgKGludGVybWVkaWF0ZSAhPSBudWxsICYmICFjb2xsZWN0UHJlZGljYXRlcykge1xyXG5cdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGUuYWRkKGMsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IG5ld0RlcHRoOiBudW1iZXIgPSBkZXB0aDtcclxuXHRcdFx0XHRpZiAoY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xyXG5cdFx0XHRcdFx0Ly8gdGFyZ2V0IGZlbGwgb2ZmIGVuZCBvZiBydWxlOyBtYXJrIHJlc3VsdGluZyBjIGFzIGhhdmluZyBkaXBwZWQgaW50byBvdXRlciBjb250ZXh0XHJcblx0XHRcdFx0XHQvLyBXZSBjYW4ndCBnZXQgaGVyZSBpZiBpbmNvbWluZyBjb25maWcgd2FzIHJ1bGUgc3RvcCBhbmQgd2UgaGFkIGNvbnRleHRcclxuXHRcdFx0XHRcdC8vIHRyYWNrIGhvdyBmYXIgd2UgZGlwIGludG8gb3V0ZXIgY29udGV4dC4gIE1pZ2h0XHJcblx0XHRcdFx0XHQvLyBjb21lIGluIGhhbmR5IGFuZCB3ZSBhdm9pZCBldmFsdWF0aW5nIGNvbnRleHQgZGVwZW5kZW50XHJcblx0XHRcdFx0XHQvLyBwcmVkcyBpZiB0aGlzIGlzID4gMC5cclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5kZmEgIT0gbnVsbCAmJiB0aGlzLmRmYS5pc1ByZWNlZGVuY2VEZmEpIHtcclxuXHRcdFx0XHRcdFx0bGV0IG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm46IG51bWJlciA9ICh0IGFzIEVwc2lsb25UcmFuc2l0aW9uKS5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRpZiAob3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiA9PT0gdGhpcy5kZmEuYXRuU3RhcnRTdGF0ZS5ydWxlSW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHRjLmlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Yy5vdXRlckNvbnRleHREZXB0aCA9IGMub3V0ZXJDb250ZXh0RGVwdGggKyAxO1xyXG5cclxuXHRcdFx0XHRcdGlmICghY2xvc3VyZUJ1c3kuYWRkKGMpKSB7XHJcblx0XHRcdFx0XHRcdC8vIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvbiBmb3IgcmlnaHQtcmVjdXJzaXZlIHJ1bGVzXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGFzc2VydChuZXdEZXB0aCA+IE1JTl9JTlRFR0VSX1ZBTFVFKTtcclxuXHRcdFx0XHRcdG5ld0RlcHRoLS07XHJcblx0XHRcdFx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiZGlwcyBpbnRvIG91dGVyIGN0eDogXCIgKyBjKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAodCBpbnN0YW5jZW9mIFJ1bGVUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpbWl6ZV90YWlsX2NhbGxzICYmIHQub3B0aW1pemVkVGFpbENhbGwgJiYgKCF0aGlzLnRhaWxfY2FsbF9wcmVzZXJ2ZXNfc2xsIHx8ICFQcmVkaWN0aW9uQ29udGV4dC5pc0VtcHR5TG9jYWwoY29uZmlnLmNvbnRleHQpKSkge1xyXG5cdFx0XHRcdFx0XHRhc3NlcnQoYy5jb250ZXh0ID09PSBjb25maWcuY29udGV4dCk7XHJcblx0XHRcdFx0XHRcdGlmIChuZXdEZXB0aCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIHRoZSBwb3AvcHVzaCBvZiBhIHRhaWwgY2FsbCB3b3VsZCBrZWVwIHRoZSBkZXB0aFxyXG5cdFx0XHRcdFx0XHRcdC8vIGNvbnN0YW50LCBleGNlcHQgd2UgbGF0Y2ggaWYgaXQgZ29lcyBuZWdhdGl2ZVxyXG5cdFx0XHRcdFx0XHRcdG5ld0RlcHRoLS07XHJcblx0XHRcdFx0XHRcdFx0aWYgKCF0aGlzLnRhaWxfY2FsbF9wcmVzZXJ2ZXNfc2xsICYmIFByZWRpY3Rpb25Db250ZXh0LmlzRW1wdHlMb2NhbChjb25maWcuY29udGV4dCkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGUgU0xMIGNvbmZpZyBcImRpcHMgaW50byB0aGUgb3V0ZXIgY29udGV4dFwiIG9yIHByZWRpY3Rpb24gbWF5IG5vdCBmYWxsIGJhY2sgdG8gTEwgb24gY29uZmxpY3RcclxuXHRcdFx0XHRcdFx0XHRcdGMub3V0ZXJDb250ZXh0RGVwdGggPSBjLm91dGVyQ29udGV4dERlcHRoICsgMTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvLyBsYXRjaCB3aGVuIG5ld0RlcHRoIGdvZXMgbmVnYXRpdmUgLSBvbmNlIHdlIHN0ZXAgb3V0IG9mIHRoZSBlbnRyeSBjb250ZXh0IHdlIGNhbid0IHJldHVyblxyXG5cdFx0XHRcdFx0XHRpZiAobmV3RGVwdGggPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdG5ld0RlcHRoKys7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoIXQuaXNFcHNpbG9uICYmICFjbG9zdXJlQnVzeS5hZGQoYykpIHtcclxuXHRcdFx0XHRcdFx0Ly8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uIGZvciBFT0YqIGFuZCBFT0YrXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5jbG9zdXJlSW1wbChjLCBjb25maWdzLCBpbnRlcm1lZGlhdGUsIGNsb3N1cmVCdXN5LCBjb250aW51ZUNvbGxlY3RpbmcsIGhhc01vcmVDb250ZXh0cywgY29udGV4dENhY2hlLCBuZXdEZXB0aCwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRSdWxlTmFtZShpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdGlmICh0aGlzLl9wYXJzZXIgIT0gbnVsbCAmJiBpbmRleCA+PSAwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9wYXJzZXIucnVsZU5hbWVzW2luZGV4XTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBcIjxydWxlIFwiICsgaW5kZXggKyBcIj5cIjtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRFcHNpbG9uVGFyZ2V0KEBOb3ROdWxsIGNvbmZpZzogQVROQ29uZmlnLCBATm90TnVsbCB0OiBUcmFuc2l0aW9uLCBjb2xsZWN0UHJlZGljYXRlczogYm9vbGVhbiwgaW5Db250ZXh0OiBib29sZWFuLCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUsIHRyZWF0RW9mQXNFcHNpbG9uOiBib29sZWFuKTogQVROQ29uZmlnIHwgdW5kZWZpbmVkIHtcclxuXHRcdHN3aXRjaCAodC5zZXJpYWxpemF0aW9uVHlwZSkge1xyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5SVUxFOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5ydWxlVHJhbnNpdGlvbihjb25maWcsIHQgYXMgUnVsZVRyYW5zaXRpb24sIGNvbnRleHRDYWNoZSk7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5QUkVDRURFTkNFOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjZWRlbmNlVHJhbnNpdGlvbihjb25maWcsIHQgYXMgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24sIGNvbGxlY3RQcmVkaWNhdGVzLCBpbkNvbnRleHQpO1xyXG5cclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUFJFRElDQVRFOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVkVHJhbnNpdGlvbihjb25maWcsIHQgYXMgUHJlZGljYXRlVHJhbnNpdGlvbiwgY29sbGVjdFByZWRpY2F0ZXMsIGluQ29udGV4dCk7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5BQ1RJT046XHJcblx0XHRcdHJldHVybiB0aGlzLmFjdGlvblRyYW5zaXRpb24oY29uZmlnLCB0IGFzIEFjdGlvblRyYW5zaXRpb24pO1xyXG5cclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuRVBTSUxPTjpcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy50cmFuc2Zvcm0odC50YXJnZXQsIGZhbHNlKTtcclxuXHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLkFUT006XHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlJBTkdFOlxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5TRVQ6XHJcblx0XHRcdC8vIEVPRiB0cmFuc2l0aW9ucyBhY3QgbGlrZSBlcHNpbG9uIHRyYW5zaXRpb25zIGFmdGVyIHRoZSBmaXJzdCBFT0ZcclxuXHRcdFx0Ly8gdHJhbnNpdGlvbiBpcyB0cmF2ZXJzZWRcclxuXHRcdFx0aWYgKHRyZWF0RW9mQXNFcHNpbG9uKSB7XHJcblx0XHRcdFx0aWYgKHQubWF0Y2hlcyhUb2tlbi5FT0YsIDAsIDEpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgZmFsc2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgYWN0aW9uVHJhbnNpdGlvbihATm90TnVsbCBjb25maWc6IEFUTkNvbmZpZywgQE5vdE51bGwgdDogQWN0aW9uVHJhbnNpdGlvbik6IEFUTkNvbmZpZyB7XHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiQUNUSU9OIGVkZ2UgXCIgKyB0LnJ1bGVJbmRleCArIFwiOlwiICsgdC5hY3Rpb25JbmRleCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0QE51bGxhYmxlXHJcblx0cHJvdGVjdGVkIHByZWNlZGVuY2VUcmFuc2l0aW9uKFxyXG5cdFx0QE5vdE51bGwgY29uZmlnOiBBVE5Db25maWcsXHJcblx0XHRATm90TnVsbCBwdDogUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24sXHJcblx0XHRjb2xsZWN0UHJlZGljYXRlczogYm9vbGVhbixcclxuXHRcdGluQ29udGV4dDogYm9vbGVhbik6IEFUTkNvbmZpZyB7XHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiUFJFRCAoY29sbGVjdFByZWRpY2F0ZXM9XCIgKyBjb2xsZWN0UHJlZGljYXRlcyArIFwiKSBcIiArXHJcblx0XHRcdFx0cHQucHJlY2VkZW5jZSArIFwiPj1fcFwiICtcclxuXHRcdFx0XHRcIiwgY3R4IGRlcGVuZGVudD10cnVlXCIpO1xyXG5cdFx0XHRpZiAodGhpcy5fcGFyc2VyICE9IG51bGwpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcImNvbnRleHQgc3Vycm91bmRpbmcgcHJlZCBpcyBcIiArXHJcblx0XHRcdFx0XHR0aGlzLl9wYXJzZXIuZ2V0UnVsZUludm9jYXRpb25TdGFjaygpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjOiBBVE5Db25maWc7XHJcblx0XHRpZiAoY29sbGVjdFByZWRpY2F0ZXMgJiYgaW5Db250ZXh0KSB7XHJcblx0XHRcdGxldCBuZXdTZW1DdHg6IFNlbWFudGljQ29udGV4dCA9IFNlbWFudGljQ29udGV4dC5hbmQoY29uZmlnLnNlbWFudGljQ29udGV4dCwgcHQucHJlZGljYXRlKTtcclxuXHRcdFx0YyA9IGNvbmZpZy50cmFuc2Zvcm0ocHQudGFyZ2V0LCBmYWxzZSwgbmV3U2VtQ3R4KTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRjID0gY29uZmlnLnRyYW5zZm9ybShwdC50YXJnZXQsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiY29uZmlnIGZyb20gcHJlZCB0cmFuc2l0aW9uPVwiICsgYyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYztcclxuXHR9XHJcblxyXG5cdEBOdWxsYWJsZVxyXG5cdHByb3RlY3RlZCBwcmVkVHJhbnNpdGlvbihcclxuXHRcdEBOb3ROdWxsIGNvbmZpZzogQVROQ29uZmlnLFxyXG5cdFx0QE5vdE51bGwgcHQ6IFByZWRpY2F0ZVRyYW5zaXRpb24sXHJcblx0XHRjb2xsZWN0UHJlZGljYXRlczogYm9vbGVhbixcclxuXHRcdGluQ29udGV4dDogYm9vbGVhbik6IEFUTkNvbmZpZyB7XHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiUFJFRCAoY29sbGVjdFByZWRpY2F0ZXM9XCIgKyBjb2xsZWN0UHJlZGljYXRlcyArIFwiKSBcIiArXHJcblx0XHRcdFx0cHQucnVsZUluZGV4ICsgXCI6XCIgKyBwdC5wcmVkSW5kZXggK1xyXG5cdFx0XHRcdFwiLCBjdHggZGVwZW5kZW50PVwiICsgcHQuaXNDdHhEZXBlbmRlbnQpO1xyXG5cdFx0XHRpZiAodGhpcy5fcGFyc2VyICE9IG51bGwpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcImNvbnRleHQgc3Vycm91bmRpbmcgcHJlZCBpcyBcIiArXHJcblx0XHRcdFx0XHR0aGlzLl9wYXJzZXIuZ2V0UnVsZUludm9jYXRpb25TdGFjaygpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjOiBBVE5Db25maWc7XHJcblx0XHRpZiAoY29sbGVjdFByZWRpY2F0ZXMgJiZcclxuXHRcdFx0KCFwdC5pc0N0eERlcGVuZGVudCB8fCAocHQuaXNDdHhEZXBlbmRlbnQgJiYgaW5Db250ZXh0KSkpIHtcclxuXHRcdFx0bGV0IG5ld1NlbUN0eDogU2VtYW50aWNDb250ZXh0ID0gU2VtYW50aWNDb250ZXh0LmFuZChjb25maWcuc2VtYW50aWNDb250ZXh0LCBwdC5wcmVkaWNhdGUpO1xyXG5cdFx0XHRjID0gY29uZmlnLnRyYW5zZm9ybShwdC50YXJnZXQsIGZhbHNlLCBuZXdTZW1DdHgpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGMgPSBjb25maWcudHJhbnNmb3JtKHB0LnRhcmdldCwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJjb25maWcgZnJvbSBwcmVkIHRyYW5zaXRpb249XCIgKyBjKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgcnVsZVRyYW5zaXRpb24oQE5vdE51bGwgY29uZmlnOiBBVE5Db25maWcsIEBOb3ROdWxsIHQ6IFJ1bGVUcmFuc2l0aW9uLCBATnVsbGFibGUgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogQVROQ29uZmlnIHtcclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJDQUxMIHJ1bGUgXCIgKyB0aGlzLmdldFJ1bGVOYW1lKHQudGFyZ2V0LnJ1bGVJbmRleCkgK1xyXG5cdFx0XHRcdFwiLCBjdHg9XCIgKyBjb25maWcuY29udGV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJldHVyblN0YXRlOiBBVE5TdGF0ZSA9IHQuZm9sbG93U3RhdGU7XHJcblx0XHRsZXQgbmV3Q29udGV4dDogUHJlZGljdGlvbkNvbnRleHQ7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW1pemVfdGFpbF9jYWxscyAmJiB0Lm9wdGltaXplZFRhaWxDYWxsICYmICghdGhpcy50YWlsX2NhbGxfcHJlc2VydmVzX3NsbCB8fCAhUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKGNvbmZpZy5jb250ZXh0KSkpIHtcclxuXHRcdFx0bmV3Q29udGV4dCA9IGNvbmZpZy5jb250ZXh0O1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoY29udGV4dENhY2hlICE9IG51bGwpIHtcclxuXHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHRDYWNoZS5nZXRDaGlsZChjb25maWcuY29udGV4dCwgcmV0dXJuU3RhdGUuc3RhdGVOdW1iZXIpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdG5ld0NvbnRleHQgPSBjb25maWcuY29udGV4dC5nZXRDaGlsZChyZXR1cm5TdGF0ZS5zdGF0ZU51bWJlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy50cmFuc2Zvcm0odC50YXJnZXQsIGZhbHNlLCBuZXdDb250ZXh0KTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIFNUQVRFX0FMVF9TT1JUX0NPTVBBUkFUT1I6IChvMTogQVROQ29uZmlnLCBvMjogQVROQ29uZmlnKSA9PiBudW1iZXIgPVxyXG5cdFx0KG8xOiBBVE5Db25maWcsIG8yOiBBVE5Db25maWcpOiBudW1iZXIgPT4ge1xyXG5cdFx0XHRsZXQgZGlmZjogbnVtYmVyID0gbzEuc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyIC0gbzIuc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyO1xyXG5cdFx0XHRpZiAoZGlmZiAhPT0gMCkge1xyXG5cdFx0XHRcdHJldHVybiBkaWZmO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkaWZmID0gbzEuYWx0IC0gbzIuYWx0O1xyXG5cdFx0XHRpZiAoZGlmZiAhPT0gMCkge1xyXG5cdFx0XHRcdHJldHVybiBkaWZmO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHJcblx0cHJpdmF0ZSBpc0NvbmZsaWN0ZWQoQE5vdE51bGwgY29uZmlnc2V0OiBBVE5Db25maWdTZXQsIGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IENvbmZsaWN0SW5mbyB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAoY29uZmlnc2V0LnVuaXF1ZUFsdCAhPT0gQVROLklOVkFMSURfQUxUX05VTUJFUiB8fCBjb25maWdzZXQuc2l6ZSA8PSAxKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGNvbmZpZ3M6IEFUTkNvbmZpZ1tdID0gY29uZmlnc2V0LnRvQXJyYXkoKTtcclxuXHRcdGNvbmZpZ3Muc29ydChQYXJzZXJBVE5TaW11bGF0b3IuU1RBVEVfQUxUX1NPUlRfQ09NUEFSQVRPUik7XHJcblxyXG5cdFx0bGV0IGV4YWN0OiBib29sZWFuID0gIWNvbmZpZ3NldC5kaXBzSW50b091dGVyQ29udGV4dDtcclxuXHRcdGxldCBhbHRzOiBCaXRTZXQgPSBuZXcgQml0U2V0KCk7XHJcblx0XHRsZXQgbWluQWx0OiBudW1iZXIgPSBjb25maWdzWzBdLmFsdDtcclxuXHRcdGFsdHMuc2V0KG1pbkFsdCk7XHJcblxyXG5cdFx0LyogUXVpY2sgY2hlY2tzIGNvbWUgZmlyc3QgKHNpbmdsZSBwYXNzLCBubyBjb250ZXh0IGpvaW5pbmcpOlxyXG5cdFx0ICogIDEuIE1ha2Ugc3VyZSBmaXJzdCBjb25maWcgaW4gdGhlIHNvcnRlZCBsaXN0IHByZWRpY3RzIHRoZSBtaW5pbXVtXHJcblx0XHQgKiAgICAgcmVwcmVzZW50ZWQgYWx0ZXJuYXRpdmUuXHJcblx0XHQgKiAgMi4gTWFrZSBzdXJlIGV2ZXJ5IHJlcHJlc2VudGVkIHN0YXRlIGhhcyBhdCBsZWFzdCBvbmUgY29uZmlndXJhdGlvblxyXG5cdFx0ICogICAgIHdoaWNoIHByZWRpY3RzIHRoZSBtaW5pbXVtIHJlcHJlc2VudGVkIGFsdGVybmF0aXZlLlxyXG5cdFx0ICogIDMuIChleGFjdCBvbmx5KSBtYWtlIHN1cmUgZXZlcnkgcmVwcmVzZW50ZWQgc3RhdGUgaGFzIGF0IGxlYXN0IG9uZVxyXG5cdFx0ICogICAgIGNvbmZpZ3VyYXRpb24gd2hpY2ggcHJlZGljdHMgZWFjaCByZXByZXNlbnRlZCBhbHRlcm5hdGl2ZS5cclxuXHRcdCAqL1xyXG5cclxuXHRcdC8vIHF1aWNrIGNoZWNrIDEgJiAyID0+IGlmIHdlIGFzc3VtZSAjMSBob2xkcyBhbmQgY2hlY2sgIzIgYWdhaW5zdCB0aGVcclxuXHRcdC8vIG1pbkFsdCBmcm9tIHRoZSBmaXJzdCBzdGF0ZSwgIzIgd2lsbCBmYWlsIGlmIHRoZSBhc3N1bXB0aW9uIHdhc1xyXG5cdFx0Ly8gaW5jb3JyZWN0XHJcblx0XHRsZXQgY3VycmVudFN0YXRlOiBudW1iZXIgPSBjb25maWdzWzBdLnN0YXRlLm5vblN0b3BTdGF0ZU51bWJlcjtcclxuXHRcdGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKSB7XHJcblx0XHRcdGxldCBzdGF0ZU51bWJlcjogbnVtYmVyID0gY29uZmlnLnN0YXRlLm5vblN0b3BTdGF0ZU51bWJlcjtcclxuXHRcdFx0aWYgKHN0YXRlTnVtYmVyICE9PSBjdXJyZW50U3RhdGUpIHtcclxuXHRcdFx0XHRpZiAoY29uZmlnLmFsdCAhPT0gbWluQWx0KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y3VycmVudFN0YXRlID0gc3RhdGVOdW1iZXI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVwcmVzZW50ZWRBbHRzOiBCaXRTZXQ7XHJcblx0XHRpZiAoZXhhY3QpIHtcclxuXHRcdFx0Y3VycmVudFN0YXRlID0gY29uZmlnc1swXS5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXI7XHJcblxyXG5cdFx0XHQvLyBnZXQgdGhlIHJlcHJlc2VudGVkIGFsdGVybmF0aXZlcyBvZiB0aGUgZmlyc3Qgc3RhdGVcclxuXHRcdFx0cmVwcmVzZW50ZWRBbHRzID0gbmV3IEJpdFNldCgpO1xyXG5cdFx0XHRsZXQgbWF4QWx0OiBudW1iZXIgPSBtaW5BbHQ7XHJcblx0XHRcdGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKSB7XHJcblx0XHRcdFx0aWYgKGNvbmZpZy5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXIgIT09IGN1cnJlbnRTdGF0ZSkge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgYWx0OiBudW1iZXIgPSBjb25maWcuYWx0O1xyXG5cdFx0XHRcdHJlcHJlc2VudGVkQWx0cy5zZXQoYWx0KTtcclxuXHRcdFx0XHRtYXhBbHQgPSBhbHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHF1aWNrIGNoZWNrICMzOlxyXG5cdFx0XHRjdXJyZW50U3RhdGUgPSBjb25maWdzWzBdLnN0YXRlLm5vblN0b3BTdGF0ZU51bWJlcjtcclxuXHRcdFx0bGV0IGN1cnJlbnRBbHQ6IG51bWJlciA9IG1pbkFsdDtcclxuXHRcdFx0Zm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpIHtcclxuXHRcdFx0XHRsZXQgc3RhdGVOdW1iZXI6IG51bWJlciA9IGNvbmZpZy5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXI7XHJcblx0XHRcdFx0bGV0IGFsdDogbnVtYmVyID0gY29uZmlnLmFsdDtcclxuXHRcdFx0XHRpZiAoc3RhdGVOdW1iZXIgIT09IGN1cnJlbnRTdGF0ZSkge1xyXG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRBbHQgIT09IG1heEFsdCkge1xyXG5cdFx0XHRcdFx0XHRleGFjdCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjdXJyZW50U3RhdGUgPSBzdGF0ZU51bWJlcjtcclxuXHRcdFx0XHRcdGN1cnJlbnRBbHQgPSBtaW5BbHQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKGFsdCAhPT0gY3VycmVudEFsdCkge1xyXG5cdFx0XHRcdFx0aWYgKGFsdCAhPT0gcmVwcmVzZW50ZWRBbHRzLm5leHRTZXRCaXQoY3VycmVudEFsdCArIDEpKSB7XHJcblx0XHRcdFx0XHRcdGV4YWN0ID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGN1cnJlbnRBbHQgPSBhbHQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Y3VycmVudFN0YXRlID0gY29uZmlnc1swXS5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXI7XHJcblx0XHRsZXQgZmlyc3RJbmRleEN1cnJlbnRTdGF0ZTogbnVtYmVyID0gMDtcclxuXHRcdGxldCBsYXN0SW5kZXhDdXJyZW50U3RhdGVNaW5BbHQ6IG51bWJlciA9IDA7XHJcblx0XHRsZXQgam9pbmVkQ2hlY2tDb250ZXh0OiBQcmVkaWN0aW9uQ29udGV4dCA9IGNvbmZpZ3NbMF0uY29udGV4dDtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgY29uZmlncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgY29uZmlnOiBBVE5Db25maWcgPSBjb25maWdzW2ldO1xyXG5cdFx0XHRpZiAoY29uZmlnLmFsdCAhPT0gbWluQWx0KSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb25maWcuc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyICE9PSBjdXJyZW50U3RhdGUpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGFzdEluZGV4Q3VycmVudFN0YXRlTWluQWx0ID0gaTtcclxuXHRcdFx0am9pbmVkQ2hlY2tDb250ZXh0ID0gY29udGV4dENhY2hlLmpvaW4oam9pbmVkQ2hlY2tDb250ZXh0LCBjb25maWdzW2ldLmNvbnRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSBsYXN0SW5kZXhDdXJyZW50U3RhdGVNaW5BbHQgKyAxOyBpIDwgY29uZmlncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgY29uZmlnOiBBVE5Db25maWcgPSBjb25maWdzW2ldO1xyXG5cdFx0XHRsZXQgc3RhdGU6IEFUTlN0YXRlID0gY29uZmlnLnN0YXRlO1xyXG5cdFx0XHRhbHRzLnNldChjb25maWcuYWx0KTtcclxuXHRcdFx0aWYgKHN0YXRlLm5vblN0b3BTdGF0ZU51bWJlciAhPT0gY3VycmVudFN0YXRlKSB7XHJcblx0XHRcdFx0Y3VycmVudFN0YXRlID0gc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyO1xyXG5cdFx0XHRcdGZpcnN0SW5kZXhDdXJyZW50U3RhdGUgPSBpO1xyXG5cdFx0XHRcdGxhc3RJbmRleEN1cnJlbnRTdGF0ZU1pbkFsdCA9IGk7XHJcblx0XHRcdFx0am9pbmVkQ2hlY2tDb250ZXh0ID0gY29uZmlnLmNvbnRleHQ7XHJcblx0XHRcdFx0Zm9yIChsZXQgaiA9IGZpcnN0SW5kZXhDdXJyZW50U3RhdGUgKyAxOyBqIDwgY29uZmlncy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0bGV0IGNvbmZpZzI6IEFUTkNvbmZpZyA9IGNvbmZpZ3Nbal07XHJcblx0XHRcdFx0XHRpZiAoY29uZmlnMi5hbHQgIT09IG1pbkFsdCkge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoY29uZmlnMi5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXIgIT09IGN1cnJlbnRTdGF0ZSkge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsYXN0SW5kZXhDdXJyZW50U3RhdGVNaW5BbHQgPSBqO1xyXG5cdFx0XHRcdFx0am9pbmVkQ2hlY2tDb250ZXh0ID0gY29udGV4dENhY2hlLmpvaW4oam9pbmVkQ2hlY2tDb250ZXh0LCBjb25maWcyLmNvbnRleHQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aSA9IGxhc3RJbmRleEN1cnJlbnRTdGF0ZU1pbkFsdDtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGpvaW5lZENoZWNrQ29udGV4dDI6IFByZWRpY3Rpb25Db250ZXh0ID0gY29uZmlnLmNvbnRleHQ7XHJcblx0XHRcdGxldCBjdXJyZW50QWx0OiBudW1iZXIgPSBjb25maWcuYWx0O1xyXG5cdFx0XHRsZXQgbGFzdEluZGV4Q3VycmVudFN0YXRlQ3VycmVudEFsdDogbnVtYmVyID0gaTtcclxuXHRcdFx0Zm9yIChsZXQgaiA9IGxhc3RJbmRleEN1cnJlbnRTdGF0ZUN1cnJlbnRBbHQgKyAxOyBqIDwgY29uZmlncy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGxldCBjb25maWcyOiBBVE5Db25maWcgPSBjb25maWdzW2pdO1xyXG5cdFx0XHRcdGlmIChjb25maWcyLmFsdCAhPT0gY3VycmVudEFsdCkge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoY29uZmlnMi5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXIgIT09IGN1cnJlbnRTdGF0ZSkge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsYXN0SW5kZXhDdXJyZW50U3RhdGVDdXJyZW50QWx0ID0gajtcclxuXHRcdFx0XHRqb2luZWRDaGVja0NvbnRleHQyID0gY29udGV4dENhY2hlLmpvaW4oam9pbmVkQ2hlY2tDb250ZXh0MiwgY29uZmlnMi5jb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aSA9IGxhc3RJbmRleEN1cnJlbnRTdGF0ZUN1cnJlbnRBbHQ7XHJcblxyXG5cdFx0XHRsZXQgY2hlY2s6IFByZWRpY3Rpb25Db250ZXh0ID0gY29udGV4dENhY2hlLmpvaW4oam9pbmVkQ2hlY2tDb250ZXh0LCBqb2luZWRDaGVja0NvbnRleHQyKTtcclxuXHRcdFx0aWYgKCFqb2luZWRDaGVja0NvbnRleHQuZXF1YWxzKGNoZWNrKSkge1xyXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBleGFjdCBpZiBuZWNlc3NhcnlcclxuXHRcdFx0ZXhhY3QgPSBleGFjdCAmJiBqb2luZWRDaGVja0NvbnRleHQuZXF1YWxzKGpvaW5lZENoZWNrQ29udGV4dDIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgQ29uZmxpY3RJbmZvKGFsdHMsIGV4YWN0KTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRDb25mbGljdGluZ0FsdHNGcm9tQ29uZmlnU2V0KGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCk6IEJpdFNldCB8IHVuZGVmaW5lZCB7XHJcblx0XHRsZXQgY29uZmxpY3RpbmdBbHRzOiBCaXRTZXQgfCB1bmRlZmluZWQgPSBjb25maWdzLmNvbmZsaWN0aW5nQWx0cztcclxuXHRcdGlmIChjb25mbGljdGluZ0FsdHMgPT0gbnVsbCAmJiBjb25maWdzLnVuaXF1ZUFsdCAhPT0gQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG5cdFx0XHRjb25mbGljdGluZ0FsdHMgPSBuZXcgQml0U2V0KCk7XHJcblx0XHRcdGNvbmZsaWN0aW5nQWx0cy5zZXQoY29uZmlncy51bmlxdWVBbHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb25mbGljdGluZ0FsdHM7XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRUb2tlbk5hbWUodDogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdGlmICh0ID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0cmV0dXJuIFwiRU9GXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHZvY2FidWxhcnk6IFZvY2FidWxhcnkgPSB0aGlzLl9wYXJzZXIgIT0gbnVsbCA/IHRoaXMuX3BhcnNlci52b2NhYnVsYXJ5IDogVm9jYWJ1bGFyeUltcGwuRU1QVFlfVk9DQUJVTEFSWTtcclxuXHRcdGxldCBkaXNwbGF5TmFtZTogc3RyaW5nID0gdm9jYWJ1bGFyeS5nZXREaXNwbGF5TmFtZSh0KTtcclxuXHRcdGlmIChkaXNwbGF5TmFtZSA9PT0gU3RyaW5nKHQpKSB7XHJcblx0XHRcdHJldHVybiBkaXNwbGF5TmFtZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGlzcGxheU5hbWUgKyBcIjxcIiArIHQgKyBcIj5cIjtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRMb29rYWhlYWROYW1lKGlucHV0OiBUb2tlblN0cmVhbSk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRUb2tlbk5hbWUoaW5wdXQuTEEoMSkpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGR1bXBEZWFkRW5kQ29uZmlncyhATm90TnVsbCBudmFlOiBOb1ZpYWJsZUFsdEV4Y2VwdGlvbik6IHZvaWQge1xyXG5cdFx0Y29uc29sZS5sb2coXCJkZWFkIGVuZCBjb25maWdzOiBcIik7XHJcblx0XHRsZXQgZGVhZEVuZENvbmZpZ3MgPSBudmFlLmRlYWRFbmRDb25maWdzO1xyXG5cdFx0aWYgKCFkZWFkRW5kQ29uZmlncykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgYyBvZiBkZWFkRW5kQ29uZmlncykge1xyXG5cdFx0XHRsZXQgdHJhbnM6IHN0cmluZyA9IFwibm8gZWRnZXNcIjtcclxuXHRcdFx0aWYgKGMuc3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyA+IDApIHtcclxuXHRcdFx0XHRsZXQgdDogVHJhbnNpdGlvbiA9IGMuc3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbigwKTtcclxuXHRcdFx0XHRpZiAodCBpbnN0YW5jZW9mIEF0b21UcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0XHR0cmFucyA9IFwiQXRvbSBcIiArIHRoaXMuZ2V0VG9rZW5OYW1lKHQuX2xhYmVsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAodCBpbnN0YW5jZW9mIFNldFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRcdGxldCBub3Q6IGJvb2xlYW4gPSB0IGluc3RhbmNlb2YgTm90U2V0VHJhbnNpdGlvbjtcclxuXHRcdFx0XHRcdHRyYW5zID0gKG5vdCA/IFwiflwiIDogXCJcIikgKyBcIlNldCBcIiArIHQuc2V0LnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGNvbnNvbGUubG9nKGMudG9TdHJpbmcodGhpcy5fcGFyc2VyLCB0cnVlKSArIFwiOlwiICsgdHJhbnMpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgbm9WaWFibGVBbHQoXHJcblx0XHRATm90TnVsbCBpbnB1dDogVG9rZW5TdHJlYW0sXHJcblx0XHRATm90TnVsbCBvdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0LFxyXG5cdFx0QE5vdE51bGwgY29uZmlnczogQVROQ29uZmlnU2V0LFxyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyKTogTm9WaWFibGVBbHRFeGNlcHRpb24ge1xyXG5cdFx0cmV0dXJuIG5ldyBOb1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzLl9wYXJzZXIsIGlucHV0LFxyXG5cdFx0XHRpbnB1dC5nZXQoc3RhcnRJbmRleCksXHJcblx0XHRcdGlucHV0LkxUKDEpLFxyXG5cdFx0XHRjb25maWdzLCBvdXRlckNvbnRleHQpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldFVuaXF1ZUFsdChATm90TnVsbCBjb25maWdzOiBJdGVyYWJsZTxBVE5Db25maWc+KTogbnVtYmVyIHtcclxuXHRcdGxldCBhbHQ6IG51bWJlciA9IEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XHJcblx0XHRmb3IgKGxldCBjIG9mIGNvbmZpZ3MpIHtcclxuXHRcdFx0aWYgKGFsdCA9PT0gQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG5cdFx0XHRcdGFsdCA9IGMuYWx0OyAvLyBmb3VuZCBmaXJzdCBhbHRcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChjLmFsdCAhPT0gYWx0KSB7XHJcblx0XHRcdFx0cmV0dXJuIEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBhbHQ7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgY29uZmlnV2l0aEFsdEF0U3RvcFN0YXRlKEBOb3ROdWxsIGNvbmZpZ3M6IEl0ZXJhYmxlPEFUTkNvbmZpZz4sIGFsdDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRmb3IgKGxldCBjIG9mIGNvbmZpZ3MpIHtcclxuXHRcdFx0aWYgKGMuYWx0ID09PSBhbHQpIHtcclxuXHRcdFx0XHRpZiAoYy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgYWRkREZBRWRnZShcclxuXHRcdEBOb3ROdWxsIGRmYTogREZBLFxyXG5cdFx0QE5vdE51bGwgZnJvbVN0YXRlOiBERkFTdGF0ZSxcclxuXHRcdHQ6IG51bWJlcixcclxuXHRcdGNvbnRleHRUcmFuc2l0aW9uczogSW50ZWdlckxpc3QgfCB1bmRlZmluZWQsXHJcblx0XHRATm90TnVsbCB0b0NvbmZpZ3M6IEFUTkNvbmZpZ1NldCxcclxuXHRcdGNvbnRleHRDYWNoZTogUHJlZGljdGlvbkNvbnRleHRDYWNoZSk6IERGQVN0YXRlIHtcclxuXHRcdGFzc2VydChjb250ZXh0VHJhbnNpdGlvbnMgPT0gbnVsbCB8fCBjb250ZXh0VHJhbnNpdGlvbnMuaXNFbXB0eSB8fCBkZmEuaXNDb250ZXh0U2Vuc2l0aXZlKTtcclxuXHJcblx0XHRsZXQgZnJvbTogREZBU3RhdGUgPSBmcm9tU3RhdGU7XHJcblx0XHRsZXQgdG86IERGQVN0YXRlID0gdGhpcy5hZGRERkFTdGF0ZShkZmEsIHRvQ29uZmlncywgY29udGV4dENhY2hlKTtcclxuXHJcblx0XHRpZiAoY29udGV4dFRyYW5zaXRpb25zICE9IG51bGwpIHtcclxuXHRcdFx0Zm9yIChsZXQgY29udGV4dCBvZiBjb250ZXh0VHJhbnNpdGlvbnMudG9BcnJheSgpKSB7XHJcblx0XHRcdFx0aWYgKGNvbnRleHQgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XHJcblx0XHRcdFx0XHRpZiAoZnJvbS5jb25maWdzLmlzT3V0ZXJtb3N0Q29uZmlnU2V0KSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZnJvbS5zZXRDb250ZXh0U2Vuc2l0aXZlKHRoaXMuYXRuKTtcclxuXHRcdFx0XHRmcm9tLnNldENvbnRleHRTeW1ib2wodCk7XHJcblx0XHRcdFx0bGV0IG5leHQ6IERGQVN0YXRlIHwgdW5kZWZpbmVkID0gZnJvbS5nZXRDb250ZXh0VGFyZ2V0KGNvbnRleHQpO1xyXG5cdFx0XHRcdGlmIChuZXh0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGZyb20gPSBuZXh0O1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRuZXh0ID0gdGhpcy5hZGRERkFDb250ZXh0U3RhdGUoZGZhLCBmcm9tLmNvbmZpZ3MsIGNvbnRleHQsIGNvbnRleHRDYWNoZSk7XHJcblx0XHRcdFx0YXNzZXJ0KGNvbnRleHQgIT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZIHx8IG5leHQuY29uZmlncy5pc091dGVybW9zdENvbmZpZ1NldCk7XHJcblx0XHRcdFx0ZnJvbS5zZXRDb250ZXh0VGFyZ2V0KGNvbnRleHQsIG5leHQpO1xyXG5cdFx0XHRcdGZyb20gPSBuZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkVER0UgXCIgKyBmcm9tICsgXCIgLT4gXCIgKyB0byArIFwiIHVwb24gXCIgKyB0aGlzLmdldFRva2VuTmFtZSh0KSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLnNldERGQUVkZ2UoZnJvbSwgdCwgdG8pO1xyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkRGQT1cXG5cIiArIGRmYS50b1N0cmluZyh0aGlzLl9wYXJzZXIgIT0gbnVsbCA/IHRoaXMuX3BhcnNlci52b2NhYnVsYXJ5IDogVm9jYWJ1bGFyeUltcGwuRU1QVFlfVk9DQUJVTEFSWSwgdGhpcy5fcGFyc2VyICE9IG51bGwgPyB0aGlzLl9wYXJzZXIucnVsZU5hbWVzIDogdW5kZWZpbmVkKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdG87XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgc2V0REZBRWRnZShATnVsbGFibGUgcDogREZBU3RhdGUsIHQ6IG51bWJlciwgQE51bGxhYmxlIHE6IERGQVN0YXRlKTogdm9pZCB7XHJcblx0XHRpZiAocCAhPSBudWxsKSB7XHJcblx0XHRcdHAuc2V0VGFyZ2V0KHQsIHEpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqIFNlZSBjb21tZW50IG9uIExleGVySW50ZXJwcmV0ZXIuYWRkREZBU3RhdGUuICovXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgYWRkREZBQ29udGV4dFN0YXRlKEBOb3ROdWxsIGRmYTogREZBLCBATm90TnVsbCBjb25maWdzOiBBVE5Db25maWdTZXQsIHJldHVybkNvbnRleHQ6IG51bWJlciwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogREZBU3RhdGUge1xyXG5cdFx0aWYgKHJldHVybkNvbnRleHQgIT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XHJcblx0XHRcdGxldCBjb250ZXh0Q29uZmlnczogQVROQ29uZmlnU2V0ID0gbmV3IEFUTkNvbmZpZ1NldCgpO1xyXG5cdFx0XHRmb3IgKGxldCBjb25maWcgb2YgY29uZmlncykge1xyXG5cdFx0XHRcdGNvbnRleHRDb25maWdzLmFkZChjb25maWcuYXBwZW5kQ29udGV4dChyZXR1cm5Db250ZXh0LCBjb250ZXh0Q2FjaGUpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkREZBU3RhdGUoZGZhLCBjb250ZXh0Q29uZmlncywgY29udGV4dENhY2hlKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRhc3NlcnQoIWNvbmZpZ3MuaXNPdXRlcm1vc3RDb25maWdTZXQsIFwiU2hvdWxkbid0IGJlIGFkZGluZyBhIGR1cGxpY2F0ZSBlZGdlLlwiKTtcclxuXHRcdFx0Y29uZmlncyA9IGNvbmZpZ3MuY2xvbmUodHJ1ZSk7XHJcblx0XHRcdGNvbmZpZ3MuaXNPdXRlcm1vc3RDb25maWdTZXQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRERkFTdGF0ZShkZmEsIGNvbmZpZ3MsIGNvbnRleHRDYWNoZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogU2VlIGNvbW1lbnQgb24gTGV4ZXJJbnRlcnByZXRlci5hZGRERkFTdGF0ZS4gKi9cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBhZGRERkFTdGF0ZShATm90TnVsbCBkZmE6IERGQSwgQE5vdE51bGwgY29uZmlnczogQVROQ29uZmlnU2V0LCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBERkFTdGF0ZSB7XHJcblx0XHRsZXQgZW5hYmxlRGZhOiBib29sZWFuID0gdGhpcy5lbmFibGVfZ2xvYmFsX2NvbnRleHRfZGZhIHx8ICFjb25maWdzLmlzT3V0ZXJtb3N0Q29uZmlnU2V0O1xyXG5cdFx0aWYgKGVuYWJsZURmYSkge1xyXG5cdFx0XHRpZiAoIWNvbmZpZ3MuaXNSZWFkT25seSkge1xyXG5cdFx0XHRcdGNvbmZpZ3Mub3B0aW1pemVDb25maWdzKHRoaXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgcHJvcG9zZWQ6IERGQVN0YXRlID0gdGhpcy5jcmVhdGVERkFTdGF0ZShkZmEsIGNvbmZpZ3MpO1xyXG5cdFx0XHRsZXQgZXhpc3Rpbmc6IERGQVN0YXRlIHwgdW5kZWZpbmVkID0gZGZhLnN0YXRlcy5nZXQocHJvcG9zZWQpO1xyXG5cdFx0XHRpZiAoZXhpc3RpbmcgIT0gbnVsbCkge1xyXG5cdFx0XHRcdHJldHVybiBleGlzdGluZztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghY29uZmlncy5pc1JlYWRPbmx5KSB7XHJcblx0XHRcdGlmIChjb25maWdzLmNvbmZsaWN0SW5mbyA9PSBudWxsKSB7XHJcblx0XHRcdFx0Y29uZmlncy5jb25mbGljdEluZm8gPSB0aGlzLmlzQ29uZmxpY3RlZChjb25maWdzLCBjb250ZXh0Q2FjaGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG5ld1N0YXRlOiBERkFTdGF0ZSA9IHRoaXMuY3JlYXRlREZBU3RhdGUoZGZhLCBjb25maWdzLmNsb25lKHRydWUpKTtcclxuXHRcdC8vIGdldERlY2lzaW9uU3RhdGUgd29uJ3QgcmV0dXJuIHVuZGVmaW5lZCB3aGVuIHdlIHJlcXVlc3QgYSBrbm93biB2YWxpZCBkZWNpc2lvblxyXG5cdFx0bGV0IGRlY2lzaW9uU3RhdGU6IERlY2lzaW9uU3RhdGUgPSB0aGlzLmF0bi5nZXREZWNpc2lvblN0YXRlKGRmYS5kZWNpc2lvbikgYXMgRGVjaXNpb25TdGF0ZTtcclxuXHRcdGxldCBwcmVkaWN0ZWRBbHQ6IG51bWJlciA9IHRoaXMuZ2V0VW5pcXVlQWx0KGNvbmZpZ3MpO1xyXG5cdFx0aWYgKHByZWRpY3RlZEFsdCAhPT0gQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG5cdFx0XHRuZXdTdGF0ZS5hY2NlcHRTdGF0ZUluZm8gPSBuZXcgQWNjZXB0U3RhdGVJbmZvKHByZWRpY3RlZEFsdCk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbmZpZ3MuY29uZmxpY3RpbmdBbHRzICE9IG51bGwpIHtcclxuXHRcdFx0bGV0IGNvbmZsaWN0aW5nQWx0cyA9IGNvbmZpZ3MuY29uZmxpY3RpbmdBbHRzO1xyXG5cdFx0XHRpZiAoY29uZmxpY3RpbmdBbHRzKSB7XHJcblx0XHRcdFx0bmV3U3RhdGUuYWNjZXB0U3RhdGVJbmZvID0gbmV3IEFjY2VwdFN0YXRlSW5mbyhjb25mbGljdGluZ0FsdHMubmV4dFNldEJpdCgwKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV3U3RhdGUuaXNBY2NlcHRTdGF0ZSAmJiBjb25maWdzLmhhc1NlbWFudGljQ29udGV4dCkge1xyXG5cdFx0XHR0aGlzLnByZWRpY2F0ZURGQVN0YXRlKG5ld1N0YXRlLCBjb25maWdzLCBkZWNpc2lvblN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghZW5hYmxlRGZhKSB7XHJcblx0XHRcdHJldHVybiBuZXdTdGF0ZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYWRkZWQ6IERGQVN0YXRlID0gZGZhLmFkZFN0YXRlKG5ld1N0YXRlKTtcclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcgJiYgYWRkZWQgPT09IG5ld1N0YXRlKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiYWRkaW5nIG5ldyBERkEgc3RhdGU6IFwiICsgbmV3U3RhdGUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFkZGVkO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwcm90ZWN0ZWQgY3JlYXRlREZBU3RhdGUoQE5vdE51bGwgZGZhOiBERkEsIEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCk6IERGQVN0YXRlIHtcclxuXHRcdHJldHVybiBuZXcgREZBU3RhdGUoY29uZmlncyk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KEBOb3ROdWxsIGRmYTogREZBLCBjb25mbGljdGluZ0FsdHM6IEJpdFNldCB8IHVuZGVmaW5lZCwgQE5vdE51bGwgY29uZmxpY3RTdGF0ZTogU2ltdWxhdG9yU3RhdGUsIHN0YXJ0SW5kZXg6IG51bWJlciwgc3RvcEluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmIChQYXJzZXJBVE5TaW11bGF0b3IuZGVidWcgfHwgUGFyc2VyQVROU2ltdWxhdG9yLnJldHJ5X2RlYnVnKSB7XHJcblx0XHRcdGxldCBpbnRlcnZhbDogSW50ZXJ2YWwgPSBJbnRlcnZhbC5vZihzdGFydEluZGV4LCBzdG9wSW5kZXgpO1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcInJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCBkZWNpc2lvbj1cIiArIGRmYS5kZWNpc2lvbiArIFwiOlwiICsgY29uZmxpY3RTdGF0ZS5zMC5jb25maWdzICtcclxuXHRcdFx0XHRcIiwgaW5wdXQ9XCIgKyB0aGlzLl9wYXJzZXIuaW5wdXRTdHJlYW0uZ2V0VGV4dChpbnRlcnZhbCkpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3BhcnNlciAhPSBudWxsKSB7XHJcblx0XHRcdGxldCBsaXN0ZW5lciA9IHRoaXMuX3BhcnNlci5nZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKTtcclxuXHRcdFx0aWYgKGxpc3RlbmVyLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCkge1xyXG5cdFx0XHRcdGxpc3RlbmVyLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCh0aGlzLl9wYXJzZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBjb25mbGljdGluZ0FsdHMsIGNvbmZsaWN0U3RhdGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KEBOb3ROdWxsIGRmYTogREZBLCBwcmVkaWN0aW9uOiBudW1iZXIsIEBOb3ROdWxsIGFjY2VwdFN0YXRlOiBTaW11bGF0b3JTdGF0ZSwgc3RhcnRJbmRleDogbnVtYmVyLCBzdG9wSW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1ZyB8fCBQYXJzZXJBVE5TaW11bGF0b3IucmV0cnlfZGVidWcpIHtcclxuXHRcdFx0bGV0IGludGVydmFsOiBJbnRlcnZhbCA9IEludGVydmFsLm9mKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCk7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwicmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5IGRlY2lzaW9uPVwiICsgZGZhLmRlY2lzaW9uICsgXCI6XCIgKyBhY2NlcHRTdGF0ZS5zMC5jb25maWdzICtcclxuXHRcdFx0XHRcIiwgaW5wdXQ9XCIgKyB0aGlzLl9wYXJzZXIuaW5wdXRTdHJlYW0uZ2V0VGV4dChpbnRlcnZhbCkpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3BhcnNlciAhPSBudWxsKSB7XHJcblx0XHRcdGxldCBsaXN0ZW5lciA9IHRoaXMuX3BhcnNlci5nZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKTtcclxuXHRcdFx0aWYgKGxpc3RlbmVyLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eSkge1xyXG5cdFx0XHRcdGxpc3RlbmVyLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eSh0aGlzLl9wYXJzZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBwcmVkaWN0aW9uLCBhY2NlcHRTdGF0ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBJZiBjb250ZXh0IHNlbnNpdGl2ZSBwYXJzaW5nLCB3ZSBrbm93IGl0J3MgYW1iaWd1aXR5IG5vdCBjb25mbGljdCAqL1xyXG5cdHByb3RlY3RlZCByZXBvcnRBbWJpZ3VpdHkoXHJcblx0XHRATm90TnVsbCBkZmE6IERGQSxcclxuXHRcdEQ6IERGQVN0YXRlLCAgLy8gdGhlIERGQSBzdGF0ZSBmcm9tIGV4ZWNBVE4oKTogdm9pZCB0aGF0IGhhZCBTTEwgY29uZmxpY3RzXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcixcclxuXHRcdGV4YWN0OiBib29sZWFuLFxyXG5cdFx0QE5vdE51bGwgYW1iaWdBbHRzOiBCaXRTZXQsXHJcblx0XHRATm90TnVsbCBjb25maWdzOiBBVE5Db25maWdTZXQpIC8vIGNvbmZpZ3MgdGhhdCBMTCBub3QgU0xMIGNvbnNpZGVyZWQgY29uZmxpY3RpbmdcclxuXHR7XHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnIHx8IFBhcnNlckFUTlNpbXVsYXRvci5yZXRyeV9kZWJ1Zykge1xyXG5cdFx0XHRsZXQgaW50ZXJ2YWw6IEludGVydmFsID0gSW50ZXJ2YWwub2Yoc3RhcnRJbmRleCwgc3RvcEluZGV4KTtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJyZXBvcnRBbWJpZ3VpdHkgXCIgK1xyXG5cdFx0XHRcdGFtYmlnQWx0cyArIFwiOlwiICsgY29uZmlncyArXHJcblx0XHRcdFx0XCIsIGlucHV0PVwiICsgdGhpcy5fcGFyc2VyLmlucHV0U3RyZWFtLmdldFRleHQoaW50ZXJ2YWwpKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9wYXJzZXIgIT0gbnVsbCkge1xyXG5cdFx0XHRsZXQgbGlzdGVuZXIgPSB0aGlzLl9wYXJzZXIuZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCk7XHJcblx0XHRcdGlmIChsaXN0ZW5lci5yZXBvcnRBbWJpZ3VpdHkpIHtcclxuXHRcdFx0XHRsaXN0ZW5lci5yZXBvcnRBbWJpZ3VpdHkodGhpcy5fcGFyc2VyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBnZXRSZXR1cm5TdGF0ZShjb250ZXh0OiBSdWxlQ29udGV4dCk6IG51bWJlciB7XHJcblx0XHRpZiAoY29udGV4dC5pc0VtcHR5KSB7XHJcblx0XHRcdHJldHVybiBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgc3RhdGU6IEFUTlN0YXRlID0gdGhpcy5hdG4uc3RhdGVzW2NvbnRleHQuaW52b2tpbmdTdGF0ZV07XHJcblx0XHRsZXQgdHJhbnNpdGlvbjogUnVsZVRyYW5zaXRpb24gPSBzdGF0ZS50cmFuc2l0aW9uKDApIGFzIFJ1bGVUcmFuc2l0aW9uO1xyXG5cdFx0cmV0dXJuIHRyYW5zaXRpb24uZm9sbG93U3RhdGUuc3RhdGVOdW1iZXI7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgc2tpcFRhaWxDYWxscyhjb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCk6IFBhcnNlclJ1bGVDb250ZXh0IHtcclxuXHRcdGlmICghdGhpcy5vcHRpbWl6ZV90YWlsX2NhbGxzKSB7XHJcblx0XHRcdHJldHVybiBjb250ZXh0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHdoaWxlICghY29udGV4dC5pc0VtcHR5KSB7XHJcblx0XHRcdGxldCBzdGF0ZTogQVROU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbY29udGV4dC5pbnZva2luZ1N0YXRlXTtcclxuXHRcdFx0YXNzZXJ0KHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnMgPT09IDEgJiYgc3RhdGUudHJhbnNpdGlvbigwKS5zZXJpYWxpemF0aW9uVHlwZSA9PT0gVHJhbnNpdGlvblR5cGUuUlVMRSk7XHJcblx0XHRcdGxldCB0cmFuc2l0aW9uOiBSdWxlVHJhbnNpdGlvbiA9IHN0YXRlLnRyYW5zaXRpb24oMCkgYXMgUnVsZVRyYW5zaXRpb247XHJcblx0XHRcdGlmICghdHJhbnNpdGlvbi50YWlsQ2FsbCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBUaGlzIG1ldGhvZCByZXF1aXJlcyB0aGF0IHRoZSByb290IGFuY2VzdG9yIG9mIHRoZSBQYXJzZXJSdWxlQ29udGV4dCBiZSBlbXB0eS4gSWYgd2UgbWFrZSBpdCB0byB0aGlzXHJcblx0XHRcdC8vIGxpbmUsIHdlIGtub3cgdGhlIGN1cnJlbnQgbm9kZSBpcyBub3QgZW1wdHksIHdoaWNoIG1lYW5zIGl0IGRvZXMgaGF2ZSBhIHBhcmVudC5cclxuXHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50IGFzIFBhcnNlclJ1bGVDb250ZXh0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb250ZXh0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQHNpbmNlIDQuM1xyXG5cdCAqL1xyXG5cdGdldCBwYXJzZXIoKTogUGFyc2VyIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYXJzZXI7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNC45NTcyMTQyLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZVR5cGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVR5cGVcIjtcclxuaW1wb3J0IHsgQmxvY2tTdGFydFN0YXRlIH0gZnJvbSBcIi4vQmxvY2tTdGFydFN0YXRlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGx1c0xvb3BiYWNrU3RhdGUgfSBmcm9tIFwiLi9QbHVzTG9vcGJhY2tTdGF0ZVwiO1xyXG5cclxuLyoqIFN0YXJ0IG9mIGAoQXxCfC4uLikrYCBsb29wLiBUZWNobmljYWxseSBhIGRlY2lzaW9uIHN0YXRlLCBidXRcclxuICogIHdlIGRvbid0IHVzZSBmb3IgY29kZSBnZW5lcmF0aW9uOyBzb21lYm9keSBtaWdodCBuZWVkIGl0LCBzbyBJJ20gZGVmaW5pbmdcclxuICogIGl0IGZvciBjb21wbGV0ZW5lc3MuIEluIHJlYWxpdHksIHRoZSB7QGxpbmsgUGx1c0xvb3BiYWNrU3RhdGV9IG5vZGUgaXMgdGhlXHJcbiAqICByZWFsIGRlY2lzaW9uLW1ha2luZyBub3RlIGZvciBgQStgLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBsdXNCbG9ja1N0YXJ0U3RhdGUgZXh0ZW5kcyBCbG9ja1N0YXJ0U3RhdGUge1xyXG5cdC8vIFRoaXMgaXMgYWx3YXlzIHNldCBkdXJpbmcgQVROIGRlc2VyaWFsaXphdGlvblxyXG5cdHB1YmxpYyBsb29wQmFja1N0YXRlITogUGx1c0xvb3BiYWNrU3RhdGU7XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdGF0ZVR5cGUoKTogQVROU3RhdGVUeXBlIHtcclxuXHRcdHJldHVybiBBVE5TdGF0ZVR5cGUuUExVU19CTE9DS19TVEFSVDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM1LjAyNTc3MzAtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlVHlwZSB9IGZyb20gXCIuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBEZWNpc2lvblN0YXRlIH0gZnJvbSBcIi4vRGVjaXNpb25TdGF0ZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKiogRGVjaXNpb24gc3RhdGUgZm9yIGBBK2AgYW5kIGAoQXxCKStgLiAgSXQgaGFzIHR3byB0cmFuc2l0aW9uczpcclxuICogIG9uZSB0byB0aGUgbG9vcCBiYWNrIHRvIHN0YXJ0IG9mIHRoZSBibG9jayBhbmQgb25lIHRvIGV4aXQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGx1c0xvb3BiYWNrU3RhdGUgZXh0ZW5kcyBEZWNpc2lvblN0YXRlIHtcclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHN0YXRlVHlwZSgpOiBBVE5TdGF0ZVR5cGUge1xyXG5cdFx0cmV0dXJuIEFUTlN0YXRlVHlwZS5QTFVTX0xPT1BfQkFDSztcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM1LjA5OTQxOTEtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbiB9IGZyb20gXCIuL0Fic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgU2VtYW50aWNDb250ZXh0IH0gZnJvbSBcIi4vU2VtYW50aWNDb250ZXh0XCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25UeXBlIH0gZnJvbSBcIi4vVHJhbnNpdGlvblR5cGVcIjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24gZXh0ZW5kcyBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24ge1xyXG5cdHB1YmxpYyBwcmVjZWRlbmNlOiBudW1iZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBATm90TnVsbCB0YXJnZXQ6IEFUTlN0YXRlLCBwcmVjZWRlbmNlOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKHRhcmdldCk7XHJcblx0XHR0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNlcmlhbGl6YXRpb25UeXBlKCk6IFRyYW5zaXRpb25UeXBlIHtcclxuXHRcdHJldHVybiBUcmFuc2l0aW9uVHlwZS5QUkVDRURFTkNFO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlzRXBzaWxvbigpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG1hdGNoZXMoc3ltYm9sOiBudW1iZXIsIG1pblZvY2FiU3ltYm9sOiBudW1iZXIsIG1heFZvY2FiU3ltYm9sOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdGdldCBwcmVkaWNhdGUoKTogU2VtYW50aWNDb250ZXh0LlByZWNlZGVuY2VQcmVkaWNhdGUge1xyXG5cdFx0cmV0dXJuIG5ldyBTZW1hbnRpY0NvbnRleHQuUHJlY2VkZW5jZVByZWRpY2F0ZSh0aGlzLnByZWNlZGVuY2UpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcmVjZWRlbmNlICsgXCIgPj0gX3BcIjtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM2LjU5NTk5ODAtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgSW50ZXJ2YWxTZXQgfSBmcm9tIFwiLi4vbWlzYy9JbnRlcnZhbFNldFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSwgTm90TnVsbCB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tIFwiLi9UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25UeXBlIH0gZnJvbSBcIi4vVHJhbnNpdGlvblR5cGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBSYW5nZVRyYW5zaXRpb24gZXh0ZW5kcyBUcmFuc2l0aW9uIHtcclxuXHRwdWJsaWMgZnJvbTogbnVtYmVyO1xyXG5cdHB1YmxpYyB0bzogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCB0YXJnZXQ6IEFUTlN0YXRlLCBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKHRhcmdldCk7XHJcblx0XHR0aGlzLmZyb20gPSBmcm9tO1xyXG5cdFx0dGhpcy50byA9IHRvO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHNlcmlhbGl6YXRpb25UeXBlKCk6IFRyYW5zaXRpb25UeXBlIHtcclxuXHRcdHJldHVybiBUcmFuc2l0aW9uVHlwZS5SQU5HRTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGxhYmVsKCk6IEludGVydmFsU2V0IHtcclxuXHRcdHJldHVybiBJbnRlcnZhbFNldC5vZih0aGlzLmZyb20sIHRoaXMudG8pO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIG1hdGNoZXMoc3ltYm9sOiBudW1iZXIsIG1pblZvY2FiU3ltYm9sOiBudW1iZXIsIG1heFZvY2FiU3ltYm9sOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBzeW1ib2wgPj0gdGhpcy5mcm9tICYmIHN5bWJvbCA8PSB0aGlzLnRvO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIidcIiArIFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMuZnJvbSkgKyBcIicuLidcIiArIFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMudG8pICsgXCInXCI7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNi42ODA2ODUxLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlVHlwZSB9IGZyb20gXCIuL0FUTlN0YXRlVHlwZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFJ1bGVTdG9wU3RhdGUgfSBmcm9tIFwiLi9SdWxlU3RvcFN0YXRlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUnVsZVN0YXJ0U3RhdGUgZXh0ZW5kcyBBVE5TdGF0ZSB7XHJcblx0Ly8gVGhpcyBpcyBhbHdheXMgc2V0IGR1cmluZyBBVE4gZGVzZXJpYWxpemF0aW9uXHJcblx0cHVibGljIHN0b3BTdGF0ZSE6IFJ1bGVTdG9wU3RhdGU7XHJcblx0cHVibGljIGlzUHJlY2VkZW5jZVJ1bGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwdWJsaWMgbGVmdEZhY3RvcmVkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdGF0ZVR5cGUoKTogQVROU3RhdGVUeXBlIHtcclxuXHRcdHJldHVybiBBVE5TdGF0ZVR5cGUuUlVMRV9TVEFSVDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM3LjU2NTc0MDktMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IEJsb2NrU3RhcnRTdGF0ZSB9IGZyb20gXCIuL0Jsb2NrU3RhcnRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKiogVGhlIGJsb2NrIHRoYXQgYmVnaW5zIGEgY2xvc3VyZSBsb29wLiAqL1xyXG5leHBvcnQgY2xhc3MgU3RhckJsb2NrU3RhcnRTdGF0ZSBleHRlbmRzIEJsb2NrU3RhcnRTdGF0ZSB7XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdGF0ZVR5cGUoKTogQVROU3RhdGVUeXBlIHtcclxuXHRcdHJldHVybiBBVE5TdGF0ZVR5cGUuU1RBUl9CTE9DS19TVEFSVDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM3LjYzNjg3MjYtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vQVROU3RhdGVcIjtcclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgU3Rhckxvb3BFbnRyeVN0YXRlIH0gZnJvbSBcIi4vU3Rhckxvb3BFbnRyeVN0YXRlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU3Rhckxvb3BiYWNrU3RhdGUgZXh0ZW5kcyBBVE5TdGF0ZSB7XHJcblx0Z2V0IGxvb3BFbnRyeVN0YXRlKCk6IFN0YXJMb29wRW50cnlTdGF0ZSB7XHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2l0aW9uKDApLnRhcmdldCBhcyBTdGFyTG9vcEVudHJ5U3RhdGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgc3RhdGVUeXBlKCk6IEFUTlN0YXRlVHlwZSB7XHJcblx0XHRyZXR1cm4gQVROU3RhdGVUeXBlLlNUQVJfTE9PUF9CQUNLO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MzcuNzgxNDA0Ni0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROU3RhdGVUeXBlIH0gZnJvbSBcIi4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IERlY2lzaW9uU3RhdGUgfSBmcm9tIFwiLi9EZWNpc2lvblN0YXRlXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKiBUaGUgVG9rZW5zIHJ1bGUgc3RhcnQgc3RhdGUgbGlua2luZyB0byBlYWNoIGxleGVyIHJ1bGUgc3RhcnQgc3RhdGUgKi9cclxuZXhwb3J0IGNsYXNzIFRva2Vuc1N0YXJ0U3RhdGUgZXh0ZW5kcyBEZWNpc2lvblN0YXRlIHtcclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHN0YXRlVHlwZSgpOiBBVE5TdGF0ZVR5cGUge1xyXG5cdFx0cmV0dXJuIEFUTlN0YXRlVHlwZS5UT0tFTl9TVEFSVDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgRXF1YXRhYmxlIH0gZnJvbSBcIi4vU3R1YnNcIjtcclxuaW1wb3J0IHsgTXVybXVySGFzaCB9IGZyb20gXCIuL011cm11ckhhc2hcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBVVUlEIGltcGxlbWVudHMgRXF1YXRhYmxlIHtcclxuXHRwcml2YXRlIHJlYWRvbmx5IGRhdGE6IFVpbnQzMkFycmF5O1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihtb3N0U2lnQml0czogbnVtYmVyLCBtb3JlU2lnQml0czogbnVtYmVyLCBsZXNzU2lnQml0czogbnVtYmVyLCBsZWFzdFNpZ0JpdHM6IG51bWJlcikge1xyXG5cdFx0dGhpcy5kYXRhID0gbmV3IFVpbnQzMkFycmF5KDQpO1xyXG5cdFx0dGhpcy5kYXRhWzBdID0gbW9zdFNpZ0JpdHM7XHJcblx0XHR0aGlzLmRhdGFbMV0gPSBtb3JlU2lnQml0cztcclxuXHRcdHRoaXMuZGF0YVsyXSA9IGxlc3NTaWdCaXRzO1xyXG5cdFx0dGhpcy5kYXRhWzNdID0gbGVhc3RTaWdCaXRzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHN0YXRpYyBmcm9tU3RyaW5nKGRhdGE6IHN0cmluZyk6IFVVSUQge1xyXG5cdFx0aWYgKCEvXlthLWZBLUYwLTldezh9LVthLWZBLUYwLTldezR9LVthLWZBLUYwLTldezR9LVthLWZBLUYwLTldezR9LVthLWZBLUYwLTldezEyfSQvLnRlc3QoZGF0YSkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0bHkgZm9ybWF0dGVkIFVVSURcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHNlZ21lbnRzID0gZGF0YS5zcGxpdChcIi1cIik7XHJcblx0XHRsZXQgbW9zdFNpZ0JpdHMgPSBwYXJzZUludChzZWdtZW50c1swXSwgMTYpO1xyXG5cdFx0bGV0IG1vcmVTaWdCaXRzID0gKChwYXJzZUludChzZWdtZW50c1sxXSwgMTYpIDw8IDE2KSA+Pj4gMCkgKyBwYXJzZUludChzZWdtZW50c1syXSwgMTYpO1xyXG5cdFx0bGV0IGxlc3NTaWdCaXRzID0gKChwYXJzZUludChzZWdtZW50c1szXSwgMTYpIDw8IDE2KSA+Pj4gMCkgKyBwYXJzZUludChzZWdtZW50c1s0XS5zdWJzdHIoMCwgNCksIDE2KTtcclxuXHRcdGxldCBsZWFzdFNpZ0JpdHMgPSBwYXJzZUludChzZWdtZW50c1s0XS5zdWJzdHIoLTgpLCAxNik7XHJcblx0XHRyZXR1cm4gbmV3IFVVSUQobW9zdFNpZ0JpdHMsIG1vcmVTaWdCaXRzLCBsZXNzU2lnQml0cywgbGVhc3RTaWdCaXRzKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBoYXNoQ29kZSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIE11cm11ckhhc2guaGFzaENvZGUoW3RoaXMuZGF0YVswXSwgdGhpcy5kYXRhWzFdLCB0aGlzLmRhdGFbMl0sIHRoaXMuZGF0YVszXV0pO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGVxdWFscyhvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKG9iaiA9PT0gdGhpcykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAoIShvYmogaW5zdGFuY2VvZiBVVUlEKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YVswXSA9PT0gb2JqLmRhdGFbMF1cclxuXHRcdFx0JiYgdGhpcy5kYXRhWzFdID09PSBvYmouZGF0YVsxXVxyXG5cdFx0XHQmJiB0aGlzLmRhdGFbMl0gPT09IG9iai5kYXRhWzJdXHJcblx0XHRcdCYmIHRoaXMuZGF0YVszXSA9PT0gb2JqLmRhdGFbM107XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiAoXCIwMDAwMDAwMFwiICsgdGhpcy5kYXRhWzBdLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC04KVxyXG5cdFx0XHQrIFwiLVwiICsgKFwiMDAwMFwiICsgKHRoaXMuZGF0YVsxXSA+Pj4gMTYpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KVxyXG5cdFx0XHQrIFwiLVwiICsgKFwiMDAwMFwiICsgdGhpcy5kYXRhWzFdLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KVxyXG5cdFx0XHQrIFwiLVwiICsgKFwiMDAwMFwiICsgKHRoaXMuZGF0YVsyXSA+Pj4gMTYpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KVxyXG5cdFx0XHQrIFwiLVwiICsgKFwiMDAwMFwiICsgdGhpcy5kYXRhWzJdLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KVxyXG5cdFx0XHQrIChcIjAwMDAwMDAwXCIgKyB0aGlzLmRhdGFbM10udG9TdHJpbmcoMTYpKS5zdWJzdHIoLTgpO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6MjUuOTY4MzQ0Ny0wNzowMFxyXG5cclxuaW1wb3J0IHsgQWN0aW9uVHJhbnNpdGlvbiB9IGZyb20gXCIuL0FjdGlvblRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgQXJyYXkyREhhc2hTZXQgfSBmcm9tIFwiLi4vbWlzYy9BcnJheTJESGFzaFNldFwiO1xyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9BVE5cIjtcclxuaW1wb3J0IHsgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyB9IGZyb20gXCIuL0FUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnNcIjtcclxuaW1wb3J0IHsgQVROU3RhdGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZVR5cGUgfSBmcm9tIFwiLi9BVE5TdGF0ZVR5cGVcIjtcclxuaW1wb3J0IHsgQVROVHlwZSB9IGZyb20gXCIuL0FUTlR5cGVcIjtcclxuaW1wb3J0IHsgQXRvbVRyYW5zaXRpb24gfSBmcm9tIFwiLi9BdG9tVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBCYXNpY0Jsb2NrU3RhcnRTdGF0ZSB9IGZyb20gXCIuL0Jhc2ljQmxvY2tTdGFydFN0YXRlXCI7XHJcbmltcG9ydCB7IEJhc2ljU3RhdGUgfSBmcm9tIFwiLi9CYXNpY1N0YXRlXCI7XHJcbmltcG9ydCB7IEJpdFNldCB9IGZyb20gXCIuLi9taXNjL0JpdFNldFwiO1xyXG5pbXBvcnQgeyBCbG9ja0VuZFN0YXRlIH0gZnJvbSBcIi4vQmxvY2tFbmRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBCbG9ja1N0YXJ0U3RhdGUgfSBmcm9tIFwiLi9CbG9ja1N0YXJ0U3RhdGVcIjtcclxuaW1wb3J0IHsgRGVjaXNpb25TdGF0ZSB9IGZyb20gXCIuL0RlY2lzaW9uU3RhdGVcIjtcclxuaW1wb3J0IHsgREZBIH0gZnJvbSBcIi4uL2RmYS9ERkFcIjtcclxuaW1wb3J0IHsgRXBzaWxvblRyYW5zaXRpb24gfSBmcm9tIFwiLi9FcHNpbG9uVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IEludGVydmFsU2V0IH0gZnJvbSBcIi4uL21pc2MvSW50ZXJ2YWxTZXRcIjtcclxuaW1wb3J0IHsgSW52YWxpZFN0YXRlIH0gZnJvbSBcIi4vSW52YWxpZFN0YXRlXCI7XHJcbmltcG9ydCB7IExleGVyQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJBY3Rpb25UeXBlIH0gZnJvbSBcIi4vTGV4ZXJBY3Rpb25UeXBlXCI7XHJcbmltcG9ydCB7IExleGVyQ2hhbm5lbEFjdGlvbiB9IGZyb20gXCIuL0xleGVyQ2hhbm5lbEFjdGlvblwiO1xyXG5pbXBvcnQgeyBMZXhlckN1c3RvbUFjdGlvbiB9IGZyb20gXCIuL0xleGVyQ3VzdG9tQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyTW9kZUFjdGlvbiB9IGZyb20gXCIuL0xleGVyTW9kZUFjdGlvblwiO1xyXG5pbXBvcnQgeyBMZXhlck1vcmVBY3Rpb24gfSBmcm9tIFwiLi9MZXhlck1vcmVBY3Rpb25cIjtcclxuaW1wb3J0IHsgTGV4ZXJQb3BNb2RlQWN0aW9uIH0gZnJvbSBcIi4vTGV4ZXJQb3BNb2RlQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyUHVzaE1vZGVBY3Rpb24gfSBmcm9tIFwiLi9MZXhlclB1c2hNb2RlQWN0aW9uXCI7XHJcbmltcG9ydCB7IExleGVyU2tpcEFjdGlvbiB9IGZyb20gXCIuL0xleGVyU2tpcEFjdGlvblwiO1xyXG5pbXBvcnQgeyBMZXhlclR5cGVBY3Rpb24gfSBmcm9tIFwiLi9MZXhlclR5cGVBY3Rpb25cIjtcclxuaW1wb3J0IHsgTG9vcEVuZFN0YXRlIH0gZnJvbSBcIi4vTG9vcEVuZFN0YXRlXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBOb3RTZXRUcmFuc2l0aW9uIH0gZnJvbSBcIi4vTm90U2V0VHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBQYXJzZXJBVE5TaW11bGF0b3IgfSBmcm9tIFwiLi9QYXJzZXJBVE5TaW11bGF0b3JcIjtcclxuaW1wb3J0IHsgUGx1c0Jsb2NrU3RhcnRTdGF0ZSB9IGZyb20gXCIuL1BsdXNCbG9ja1N0YXJ0U3RhdGVcIjtcclxuaW1wb3J0IHsgUGx1c0xvb3BiYWNrU3RhdGUgfSBmcm9tIFwiLi9QbHVzTG9vcGJhY2tTdGF0ZVwiO1xyXG5pbXBvcnQgeyBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbiB9IGZyb20gXCIuL1ByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFByZWRpY2F0ZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9QcmVkaWNhdGVUcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IFJhbmdlVHJhbnNpdGlvbiB9IGZyb20gXCIuL1JhbmdlVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBSdWxlU3RhcnRTdGF0ZSB9IGZyb20gXCIuL1J1bGVTdGFydFN0YXRlXCI7XHJcbmltcG9ydCB7IFJ1bGVTdG9wU3RhdGUgfSBmcm9tIFwiLi9SdWxlU3RvcFN0YXRlXCI7XHJcbmltcG9ydCB7IFJ1bGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vUnVsZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgU2V0VHJhbnNpdGlvbiB9IGZyb20gXCIuL1NldFRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgU3RhckJsb2NrU3RhcnRTdGF0ZSB9IGZyb20gXCIuL1N0YXJCbG9ja1N0YXJ0U3RhdGVcIjtcclxuaW1wb3J0IHsgU3Rhckxvb3BiYWNrU3RhdGUgfSBmcm9tIFwiLi9TdGFyTG9vcGJhY2tTdGF0ZVwiO1xyXG5pbXBvcnQgeyBTdGFyTG9vcEVudHJ5U3RhdGUgfSBmcm9tIFwiLi9TdGFyTG9vcEVudHJ5U3RhdGVcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5zU3RhcnRTdGF0ZSB9IGZyb20gXCIuL1Rva2Vuc1N0YXJ0U3RhdGVcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCIuL1RyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvblR5cGUgfSBmcm9tIFwiLi9UcmFuc2l0aW9uVHlwZVwiO1xyXG5pbXBvcnQgeyBVVUlEIH0gZnJvbSBcIi4uL21pc2MvVVVJRFwiO1xyXG5pbXBvcnQgeyBXaWxkY2FyZFRyYW5zaXRpb24gfSBmcm9tIFwiLi9XaWxkY2FyZFRyYW5zaXRpb25cIjtcclxuXHJcbmludGVyZmFjZSBVbmljb2RlRGVzZXJpYWxpemVyIHtcclxuXHQvLyBXcmFwcGVyIGZvciByZWFkSW50KCkgb3IgcmVhZEludDMyKClcclxuXHRyZWFkVW5pY29kZShkYXRhOiBVaW50MTZBcnJheSwgcDogbnVtYmVyKTogbnVtYmVyO1xyXG5cclxuXHQvLyBXb3JrIGFyb3VuZCBKYXZhIG5vdCBhbGxvd2luZyBtdXRhdGlvbiBvZiBjYXB0dXJlZCB2YXJpYWJsZXNcclxuXHQvLyBieSByZXR1cm5pbmcgYW1vdW50IGJ5IHdoaWNoIHRvIGluY3JlbWVudCBwIGFmdGVyIGVhY2ggcmVhZFxyXG5cdHJlYWRvbmx5IHNpemU6IG51bWJlcjtcclxufVxyXG5cclxuY29uc3QgZW51bSBVbmljb2RlRGVzZXJpYWxpemluZ01vZGUge1xyXG5cdFVOSUNPREVfQk1QLFxyXG5cdFVOSUNPREVfU01QLFxyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFUTkRlc2VyaWFsaXplciB7XHJcblx0c3RhdGljIGdldCBTRVJJQUxJWkVEX1ZFUlNJT04oKTogbnVtYmVyIHtcclxuXHRcdC8qIFRoaXMgdmFsdWUgc2hvdWxkIG5ldmVyIGNoYW5nZS4gVXBkYXRlcyBmb2xsb3dpbmcgdGhpcyB2ZXJzaW9uIGFyZVxyXG5cdFx0ICogcmVmbGVjdGVkIGFzIGNoYW5nZSBpbiB0aGUgdW5pcXVlIElEIFNFUklBTElaRURfVVVJRC5cclxuXHRcdCAqL1xyXG5cdFx0cmV0dXJuIDM7XHJcblx0fVxyXG5cclxuXHQvKiBXQVJOSU5HOiBETyBOT1QgTUVSR0UgVEhFU0UgTElORVMuIElmIFVVSURzIGRpZmZlciBkdXJpbmcgYSBtZXJnZSxcclxuXHQgKiByZXNvbHZlIHRoZSBjb25mbGljdCBieSBnZW5lcmF0aW5nIGEgbmV3IElEIVxyXG5cdCAqL1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBlYXJsaWVzdCBzdXBwb3J0ZWQgc2VyaWFsaXplZCBVVUlELlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEJBU0VfU0VSSUFMSVpFRF9VVUlEOiBVVUlEID0gVVVJRC5mcm9tU3RyaW5nKFwiRTQxNzg0NjgtREY5NS00NEQwLUFEODctRjIyQTVENUZCNkQzXCIpO1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgVVVJRCBpbmRpY2F0ZXMgYW4gZXh0ZW5zaW9uIG9mIHtAbGluayAjQURERURfUFJFQ0VERU5DRV9UUkFOU0lUSU9OU31cclxuXHQgKiBmb3IgdGhlIGFkZGl0aW9uIG9mIGxleGVyIGFjdGlvbnMgZW5jb2RlZCBhcyBhIHNlcXVlbmNlIG9mXHJcblx0ICoge0BsaW5rIExleGVyQWN0aW9ufSBpbnN0YW5jZXMuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQURERURfTEVYRVJfQUNUSU9OUzogVVVJRCA9IFVVSUQuZnJvbVN0cmluZyhcIkFCMzUxOTFBLTE2MDMtNDg3RS1CNzVBLTQ3OUI4MzFFQUY2RFwiKTtcclxuXHQvKipcclxuXHQgKiBUaGlzIFVVSUQgaW5kaWNhdGVzIHRoZSBzZXJpYWxpemVkIEFUTiBjb250YWlucyB0d28gc2V0cyBvZlxyXG5cdCAqIEludGVydmFsU2V0cywgd2hlcmUgdGhlIHNlY29uZCBzZXQncyB2YWx1ZXMgYXJlIGVuY29kZWQgYXNcclxuXHQgKiAzMi1iaXQgaW50ZWdlcnMgdG8gc3VwcG9ydCB0aGUgZnVsbCBVbmljb2RlIFNNUCByYW5nZSB1cCB0byBVKzEwRkZGRi5cclxuXHQgKi9cclxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBBRERFRF9VTklDT0RFX1NNUDogVVVJRCA9IFVVSUQuZnJvbVN0cmluZyhcIkMyM0ZFQTg5LTA2MDUtNGY1MS1BRkI4LTA1OEJDQUI4QzkxQlwiKTtcclxuXHQvKipcclxuXHQgKiBUaGlzIGxpc3QgY29udGFpbnMgYWxsIG9mIHRoZSBjdXJyZW50bHkgc3VwcG9ydGVkIFVVSURzLCBvcmRlcmVkIGJ5IHdoZW5cclxuXHQgKiB0aGUgZmVhdHVyZSBmaXJzdCBhcHBlYXJlZCBpbiB0aGlzIGJyYW5jaC5cclxuXHQgKi9cclxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBTVVBQT1JURURfVVVJRFM6IFVVSURbXSA9IFtcclxuXHRcdEFUTkRlc2VyaWFsaXplci5CQVNFX1NFUklBTElaRURfVVVJRCxcclxuXHRcdEFUTkRlc2VyaWFsaXplci5BRERFRF9MRVhFUl9BQ1RJT05TLFxyXG5cdFx0QVRORGVzZXJpYWxpemVyLkFEREVEX1VOSUNPREVfU01QLFxyXG5cdF07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGN1cnJlbnQgc2VyaWFsaXplZCBVVUlELlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFNFUklBTElaRURfVVVJRDogVVVJRCA9IEFUTkRlc2VyaWFsaXplci5BRERFRF9VTklDT0RFX1NNUDtcclxuXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIHJlYWRvbmx5IGRlc2VyaWFsaXphdGlvbk9wdGlvbnM6IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnM7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGRlc2VyaWFsaXphdGlvbk9wdGlvbnM/OiBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zKSB7XHJcblx0XHRpZiAoZGVzZXJpYWxpemF0aW9uT3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGRlc2VyaWFsaXphdGlvbk9wdGlvbnMgPSBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zLmRlZmF1bHRPcHRpb25zO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGVzZXJpYWxpemF0aW9uT3B0aW9ucyA9IGRlc2VyaWFsaXphdGlvbk9wdGlvbnM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlcm1pbmVzIGlmIGEgcGFydGljdWxhciBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFUTiBzdXBwb3J0c1xyXG5cdCAqIGEgcGFydGljdWxhciBmZWF0dXJlLCBpZGVudGlmaWVkIGJ5IHRoZSB7QGxpbmsgVVVJRH0gdXNlZCBmb3Igc2VyaWFsaXppbmdcclxuXHQgKiB0aGUgQVROIGF0IHRoZSB0aW1lIHRoZSBmZWF0dXJlIHdhcyBmaXJzdCBpbnRyb2R1Y2VkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGZlYXR1cmUgVGhlIHtAbGluayBVVUlEfSBtYXJraW5nIHRoZSBmaXJzdCB0aW1lIHRoZSBmZWF0dXJlIHdhc1xyXG5cdCAqIHN1cHBvcnRlZCBpbiB0aGUgc2VyaWFsaXplZCBBVE4uXHJcblx0ICogQHBhcmFtIGFjdHVhbFV1aWQgVGhlIHtAbGluayBVVUlEfSBvZiB0aGUgYWN0dWFsIHNlcmlhbGl6ZWQgQVROIHdoaWNoIGlzXHJcblx0ICogY3VycmVudGx5IGJlaW5nIGRlc2VyaWFsaXplZC5cclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGBhY3R1YWxVdWlkYCB2YWx1ZSByZXByZXNlbnRzIGFcclxuXHQgKiBzZXJpYWxpemVkIEFUTiBhdCBvciBhZnRlciB0aGUgZmVhdHVyZSBpZGVudGlmaWVkIGJ5IGBmZWF0dXJlYCB3YXNcclxuXHQgKiBpbnRyb2R1Y2VkOyBvdGhlcndpc2UsIGBmYWxzZWAuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHN0YXRpYyBpc0ZlYXR1cmVTdXBwb3J0ZWQoZmVhdHVyZTogVVVJRCwgYWN0dWFsVXVpZDogVVVJRCk6IGJvb2xlYW4ge1xyXG5cdFx0bGV0IGZlYXR1cmVJbmRleDogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLlNVUFBPUlRFRF9VVUlEUy5maW5kSW5kZXgoKGUpID0+IGUuZXF1YWxzKGZlYXR1cmUpKTtcclxuXHRcdGlmIChmZWF0dXJlSW5kZXggPCAwKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gQVRORGVzZXJpYWxpemVyLlNVUFBPUlRFRF9VVUlEUy5maW5kSW5kZXgoKGUpID0+IGUuZXF1YWxzKGFjdHVhbFV1aWQpKSA+PSBmZWF0dXJlSW5kZXg7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBnZXRVbmljb2RlRGVzZXJpYWxpemVyKG1vZGU6IFVuaWNvZGVEZXNlcmlhbGl6aW5nTW9kZSk6IFVuaWNvZGVEZXNlcmlhbGl6ZXIge1xyXG5cdFx0aWYgKG1vZGUgPT09IFVuaWNvZGVEZXNlcmlhbGl6aW5nTW9kZS5VTklDT0RFX0JNUCkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHJlYWRVbmljb2RlOiAoZGF0YTogVWludDE2QXJyYXksIHA6IG51bWJlcik6IG51bWJlciA9PiB7XHJcblx0XHRcdFx0XHRyZXR1cm4gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcF0pO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0c2l6ZTogMSxcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0cmVhZFVuaWNvZGU6IChkYXRhOiBVaW50MTZBcnJheSwgcDogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuXHRcdFx0XHRcdHJldHVybiBBVE5EZXNlcmlhbGl6ZXIudG9JbnQzMihkYXRhLCBwKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHNpemU6IDIsXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZGVzZXJpYWxpemUoQE5vdE51bGwgZGF0YTogVWludDE2QXJyYXkpOiBBVE4ge1xyXG5cdFx0ZGF0YSA9IGRhdGEuc2xpY2UoMCk7XHJcblxyXG5cdFx0Ly8gRWFjaCBVaW50MTYgdmFsdWUgaW4gZGF0YSBpcyBzaGlmdGVkIGJ5ICsyIGF0IHRoZSBlbnRyeSB0byB0aGlzIG1ldGhvZC4gVGhpcyBpcyBhbiBlbmNvZGluZyBvcHRpbWl6YXRpb25cclxuXHRcdC8vIHRhcmdldGluZyB0aGUgc2VyaWFsaXplZCB2YWx1ZXMgMCBhbmQgLTEgKHNlcmlhbGl6ZWQgdG8gMHhGRkZGKSwgZWFjaCBvZiB3aGljaCBhcmUgdmVyeSBjb21tb24gaW4gdGhlXHJcblx0XHQvLyBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIEFUTi4gSW4gdGhlIG1vZGlmaWVkIFVURi04IHRoYXQgSmF2YSB1c2VzIGZvciBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMsIHRoZXNlIHR3b1xyXG5cdFx0Ly8gY2hhcmFjdGVyIHZhbHVlcyBoYXZlIG11bHRpLWJ5dGUgZm9ybXMuIEJ5IHNoaWZ0aW5nIGVhY2ggdmFsdWUgYnkgKzIsIHRoZXkgYmVjb21lIGNoYXJhY3RlcnMgMiBhbmQgMSBwcmlvciB0b1xyXG5cdFx0Ly8gd3JpdGluZyB0aGUgc3RyaW5nLCBlYWNoIG9mIHdoaWNoIGhhdmUgc2luZ2xlLWJ5dGUgcmVwcmVzZW50YXRpb25zLiBTaW5jZSB0aGUgc2hpZnQgb2NjdXJzIGluIHRoZSB0b29sIGR1cmluZ1xyXG5cdFx0Ly8gQVROIHNlcmlhbGl6YXRpb24sIGVhY2ggdGFyZ2V0IGlzIHJlc3BvbnNpYmxlIGZvciBhZGp1c3RpbmcgdGhlIHZhbHVlcyBkdXJpbmcgZGVzZXJpYWxpemF0aW9uLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEFzIGEgc3BlY2lhbCBjYXNlLCBub3RlIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgZGF0YSBpcyBub3QgYWRqdXN0ZWQgYmVjYXVzZSBpdCBjb250YWlucyB0aGUgbWFqb3IgdmVyc2lvblxyXG5cdFx0Ly8gbnVtYmVyIG9mIHRoZSBzZXJpYWxpemVkIEFUTiwgd2hpY2ggd2FzIGZpeGVkIGF0IDMgYXQgdGhlIHRpbWUgdGhlIHZhbHVlIHNoaWZ0aW5nIHdhcyBpbXBsZW1lbnRlZC5cclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRkYXRhW2ldID0gKGRhdGFbaV0gLSAyKSAmIDB4RkZGRjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcDogbnVtYmVyID0gMDtcclxuXHRcdGxldCB2ZXJzaW9uOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdGlmICh2ZXJzaW9uICE9PSBBVE5EZXNlcmlhbGl6ZXIuU0VSSUFMSVpFRF9WRVJTSU9OKSB7XHJcblx0XHRcdGxldCByZWFzb24gPSBgQ291bGQgbm90IGRlc2VyaWFsaXplIEFUTiB3aXRoIHZlcnNpb24gJHt2ZXJzaW9ufSAoZXhwZWN0ZWQgJHtBVE5EZXNlcmlhbGl6ZXIuU0VSSUFMSVpFRF9WRVJTSU9OfSkuYDtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHV1aWQ6IFVVSUQgPSBBVE5EZXNlcmlhbGl6ZXIudG9VVUlEKGRhdGEsIHApO1xyXG5cdFx0cCArPSA4O1xyXG5cdFx0aWYgKEFUTkRlc2VyaWFsaXplci5TVVBQT1JURURfVVVJRFMuZmluZEluZGV4KChlKSA9PiBlLmVxdWFscyh1dWlkKSkgPCAwKSB7XHJcblx0XHRcdGxldCByZWFzb24gPSBgQ291bGQgbm90IGRlc2VyaWFsaXplIEFUTiB3aXRoIFVVSUQgJHt1dWlkfSAoZXhwZWN0ZWQgJHtBVE5EZXNlcmlhbGl6ZXIuU0VSSUFMSVpFRF9VVUlEfSBvciBhIGxlZ2FjeSBVVUlEKS5gO1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgc3VwcG9ydHNMZXhlckFjdGlvbnM6IGJvb2xlYW4gPSBBVE5EZXNlcmlhbGl6ZXIuaXNGZWF0dXJlU3VwcG9ydGVkKEFUTkRlc2VyaWFsaXplci5BRERFRF9MRVhFUl9BQ1RJT05TLCB1dWlkKTtcclxuXHJcblx0XHRsZXQgZ3JhbW1hclR5cGU6IEFUTlR5cGUgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdGxldCBtYXhUb2tlblR5cGU6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0bGV0IGF0bjogQVROID0gbmV3IEFUTihncmFtbWFyVHlwZSwgbWF4VG9rZW5UeXBlKTtcclxuXHJcblx0XHQvL1xyXG5cdFx0Ly8gU1RBVEVTXHJcblx0XHQvL1xyXG5cdFx0bGV0IGxvb3BCYWNrU3RhdGVOdW1iZXJzOiBBcnJheTxbTG9vcEVuZFN0YXRlLCBudW1iZXJdPiA9IFtdO1xyXG5cdFx0bGV0IGVuZFN0YXRlTnVtYmVyczogQXJyYXk8W0Jsb2NrU3RhcnRTdGF0ZSwgbnVtYmVyXT4gPSBbXTtcclxuXHRcdGxldCBuc3RhdGVzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnN0YXRlczsgaSsrKSB7XHJcblx0XHRcdGxldCBzdHlwZTogQVROU3RhdGVUeXBlID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRcdC8vIGlnbm9yZSBiYWQgdHlwZSBvZiBzdGF0ZXNcclxuXHRcdFx0aWYgKHN0eXBlID09PSBBVE5TdGF0ZVR5cGUuSU5WQUxJRF9UWVBFKSB7XHJcblx0XHRcdFx0YXRuLmFkZFN0YXRlKG5ldyBJbnZhbGlkU3RhdGUoKSk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBydWxlSW5kZXg6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0XHRpZiAocnVsZUluZGV4ID09PSAweEZGRkYpIHtcclxuXHRcdFx0XHRydWxlSW5kZXggPSAtMTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHM6IEFUTlN0YXRlID0gdGhpcy5zdGF0ZUZhY3Rvcnkoc3R5cGUsIHJ1bGVJbmRleCk7XHJcblx0XHRcdGlmIChzdHlwZSA9PT0gQVROU3RhdGVUeXBlLkxPT1BfRU5EKSB7IC8vIHNwZWNpYWwgY2FzZVxyXG5cdFx0XHRcdGxldCBsb29wQmFja1N0YXRlTnVtYmVyOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0XHRsb29wQmFja1N0YXRlTnVtYmVycy5wdXNoKFtzIGFzIExvb3BFbmRTdGF0ZSwgbG9vcEJhY2tTdGF0ZU51bWJlcl0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHMgaW5zdGFuY2VvZiBCbG9ja1N0YXJ0U3RhdGUpIHtcclxuXHRcdFx0XHRsZXQgZW5kU3RhdGVOdW1iZXI6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0XHRcdGVuZFN0YXRlTnVtYmVycy5wdXNoKFtzLCBlbmRTdGF0ZU51bWJlcl0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGF0bi5hZGRTdGF0ZShzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkZWxheSB0aGUgYXNzaWdubWVudCBvZiBsb29wIGJhY2sgYW5kIGVuZCBzdGF0ZXMgdW50aWwgd2Uga25vdyBhbGwgdGhlIHN0YXRlIGluc3RhbmNlcyBoYXZlIGJlZW4gaW5pdGlhbGl6ZWRcclxuXHRcdGZvciAobGV0IHBhaXIgb2YgbG9vcEJhY2tTdGF0ZU51bWJlcnMpIHtcclxuXHRcdFx0cGFpclswXS5sb29wQmFja1N0YXRlID0gYXRuLnN0YXRlc1twYWlyWzFdXTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBwYWlyIG9mIGVuZFN0YXRlTnVtYmVycykge1xyXG5cdFx0XHRwYWlyWzBdLmVuZFN0YXRlID0gYXRuLnN0YXRlc1twYWlyWzFdXSBhcyBCbG9ja0VuZFN0YXRlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBudW1Ob25HcmVlZHlTdGF0ZXM6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudW1Ob25HcmVlZHlTdGF0ZXM7IGkrKykge1xyXG5cdFx0XHRsZXQgc3RhdGVOdW1iZXI6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0XHQoYXRuLnN0YXRlc1tzdGF0ZU51bWJlcl0gYXMgRGVjaXNpb25TdGF0ZSkubm9uR3JlZWR5ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbnVtU2xsRGVjaXNpb25zOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU2xsRGVjaXNpb25zOyBpKyspIHtcclxuXHRcdFx0bGV0IHN0YXRlTnVtYmVyOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0KGF0bi5zdGF0ZXNbc3RhdGVOdW1iZXJdIGFzIERlY2lzaW9uU3RhdGUpLnNsbCA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG51bVByZWNlZGVuY2VTdGF0ZXM6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudW1QcmVjZWRlbmNlU3RhdGVzOyBpKyspIHtcclxuXHRcdFx0bGV0IHN0YXRlTnVtYmVyOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0KGF0bi5zdGF0ZXNbc3RhdGVOdW1iZXJdIGFzIFJ1bGVTdGFydFN0YXRlKS5pc1ByZWNlZGVuY2VSdWxlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cdFx0Ly8gUlVMRVNcclxuXHRcdC8vXHJcblx0XHRsZXQgbnJ1bGVzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdGlmIChhdG4uZ3JhbW1hclR5cGUgPT09IEFUTlR5cGUuTEVYRVIpIHtcclxuXHRcdFx0YXRuLnJ1bGVUb1Rva2VuVHlwZSA9IG5ldyBJbnQzMkFycmF5KG5ydWxlcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0YXRuLnJ1bGVUb1N0YXJ0U3RhdGUgPSBuZXcgQXJyYXk8UnVsZVN0YXJ0U3RhdGU+KG5ydWxlcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5ydWxlczsgaSsrKSB7XHJcblx0XHRcdGxldCBzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0bGV0IHN0YXJ0U3RhdGU6IFJ1bGVTdGFydFN0YXRlID0gYXRuLnN0YXRlc1tzXSBhcyBSdWxlU3RhcnRTdGF0ZTtcclxuXHRcdFx0c3RhcnRTdGF0ZS5sZWZ0RmFjdG9yZWQgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKSAhPT0gMDtcclxuXHRcdFx0YXRuLnJ1bGVUb1N0YXJ0U3RhdGVbaV0gPSBzdGFydFN0YXRlO1xyXG5cdFx0XHRpZiAoYXRuLmdyYW1tYXJUeXBlID09PSBBVE5UeXBlLkxFWEVSKSB7XHJcblx0XHRcdFx0bGV0IHRva2VuVHlwZTogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRcdFx0aWYgKHRva2VuVHlwZSA9PT0gMHhGRkZGKSB7XHJcblx0XHRcdFx0XHR0b2tlblR5cGUgPSBUb2tlbi5FT0Y7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhdG4ucnVsZVRvVG9rZW5UeXBlW2ldID0gdG9rZW5UeXBlO1xyXG5cclxuXHRcdFx0XHRpZiAoIUFUTkRlc2VyaWFsaXplci5pc0ZlYXR1cmVTdXBwb3J0ZWQoQVRORGVzZXJpYWxpemVyLkFEREVEX0xFWEVSX0FDVElPTlMsIHV1aWQpKSB7XHJcblx0XHRcdFx0XHQvLyB0aGlzIHBpZWNlIG9mIHVudXNlZCBtZXRhZGF0YSB3YXMgc2VyaWFsaXplZCBwcmlvciB0byB0aGVcclxuXHRcdFx0XHRcdC8vIGFkZGl0aW9uIG9mIExleGVyQWN0aW9uXHJcblx0XHRcdFx0XHRsZXQgYWN0aW9uSW5kZXhJZ25vcmVkOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0XHRcdGlmIChhY3Rpb25JbmRleElnbm9yZWQgPT09IDB4RkZGRikge1xyXG5cdFx0XHRcdFx0XHRhY3Rpb25JbmRleElnbm9yZWQgPSAtMTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRhdG4ucnVsZVRvU3RvcFN0YXRlID0gbmV3IEFycmF5PFJ1bGVTdG9wU3RhdGU+KG5ydWxlcyk7XHJcblx0XHRmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XHJcblx0XHRcdGlmICghKHN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXRuLnJ1bGVUb1N0b3BTdGF0ZVtzdGF0ZS5ydWxlSW5kZXhdID0gc3RhdGU7XHJcblx0XHRcdGF0bi5ydWxlVG9TdGFydFN0YXRlW3N0YXRlLnJ1bGVJbmRleF0uc3RvcFN0YXRlID0gc3RhdGU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHRcdC8vIE1PREVTXHJcblx0XHQvL1xyXG5cdFx0bGV0IG5tb2RlczogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5tb2RlczsgaSsrKSB7XHJcblx0XHRcdGxldCBzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0YXRuLm1vZGVUb1N0YXJ0U3RhdGUucHVzaChhdG4uc3RhdGVzW3NdIGFzIFRva2Vuc1N0YXJ0U3RhdGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGF0bi5tb2RlVG9ERkEgPSBuZXcgQXJyYXk8REZBPihubW9kZXMpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBubW9kZXM7IGkrKykge1xyXG5cdFx0XHRhdG4ubW9kZVRvREZBW2ldID0gbmV3IERGQShhdG4ubW9kZVRvU3RhcnRTdGF0ZVtpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHRcdC8vIFNFVFNcclxuXHRcdC8vXHJcblx0XHRsZXQgc2V0czogSW50ZXJ2YWxTZXRbXSA9IFtdO1xyXG5cclxuXHRcdC8vIEZpcnN0LCByZWFkIGFsbCBzZXRzIHdpdGggMTYtYml0IFVuaWNvZGUgY29kZSBwb2ludHMgPD0gVStGRkZGLlxyXG5cdFx0cCA9IHRoaXMuZGVzZXJpYWxpemVTZXRzKGRhdGEsIHAsIHNldHMsIEFUTkRlc2VyaWFsaXplci5nZXRVbmljb2RlRGVzZXJpYWxpemVyKFVuaWNvZGVEZXNlcmlhbGl6aW5nTW9kZS5VTklDT0RFX0JNUCkpO1xyXG5cclxuXHRcdC8vIE5leHQsIGlmIHRoZSBBVE4gd2FzIHNlcmlhbGl6ZWQgd2l0aCB0aGUgVW5pY29kZSBTTVAgZmVhdHVyZSxcclxuXHRcdC8vIGRlc2VyaWFsaXplIHNldHMgd2l0aCAzMi1iaXQgYXJndW1lbnRzIDw9IFUrMTBGRkZGLlxyXG5cdFx0aWYgKEFUTkRlc2VyaWFsaXplci5pc0ZlYXR1cmVTdXBwb3J0ZWQoQVRORGVzZXJpYWxpemVyLkFEREVEX1VOSUNPREVfU01QLCB1dWlkKSkge1xyXG5cdFx0XHRwID0gdGhpcy5kZXNlcmlhbGl6ZVNldHMoZGF0YSwgcCwgc2V0cywgQVRORGVzZXJpYWxpemVyLmdldFVuaWNvZGVEZXNlcmlhbGl6ZXIoVW5pY29kZURlc2VyaWFsaXppbmdNb2RlLlVOSUNPREVfU01QKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHRcdC8vIEVER0VTXHJcblx0XHQvL1xyXG5cdFx0bGV0IG5lZGdlczogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5lZGdlczsgaSsrKSB7XHJcblx0XHRcdGxldCBzcmM6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3BdKTtcclxuXHRcdFx0bGV0IHRyZzogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCArIDFdKTtcclxuXHRcdFx0bGV0IHR0eXBlOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwICsgMl0pO1xyXG5cdFx0XHRsZXQgYXJnMTogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCArIDNdKTtcclxuXHRcdFx0bGV0IGFyZzI6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3AgKyA0XSk7XHJcblx0XHRcdGxldCBhcmczOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwICsgNV0pO1xyXG5cdFx0XHRsZXQgdHJhbnM6IFRyYW5zaXRpb24gPSB0aGlzLmVkZ2VGYWN0b3J5KGF0biwgdHR5cGUsIHNyYywgdHJnLCBhcmcxLCBhcmcyLCBhcmczLCBzZXRzKTtcclxuXHRcdFx0Ly8gY29uc29sZS5sb2coYEVER0UgJHt0cmFucy5jb25zdHJ1Y3Rvci5uYW1lfSAke3NyY30tPiR7dHJnfSAke1RyYW5zaXRpb24uc2VyaWFsaXphdGlvbk5hbWVzW3R0eXBlXX0gJHthcmcxfSwke2FyZzJ9LCR7YXJnM31gKTtcclxuXHRcdFx0bGV0IHNyY1N0YXRlOiBBVE5TdGF0ZSA9IGF0bi5zdGF0ZXNbc3JjXTtcclxuXHRcdFx0c3JjU3RhdGUuYWRkVHJhbnNpdGlvbih0cmFucyk7XHJcblx0XHRcdHAgKz0gNjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBlZGdlcyBmb3IgcnVsZSBzdG9wIHN0YXRlcyBjYW4gYmUgZGVyaXZlZCwgc28gdGhleSBhcmVuJ3Qgc2VyaWFsaXplZFxyXG5cdFx0aW50ZXJmYWNlIFQgeyBzdG9wU3RhdGU6IG51bWJlcjsgcmV0dXJuU3RhdGU6IG51bWJlcjsgb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybjogbnVtYmVyOyB9XHJcblx0XHRsZXQgcmV0dXJuVHJhbnNpdGlvbnNTZXQgPSBuZXcgQXJyYXkyREhhc2hTZXQ8VD4oe1xyXG5cdFx0XHRoYXNoQ29kZTogKG86IFQpID0+IG8uc3RvcFN0YXRlIF4gby5yZXR1cm5TdGF0ZSBeIG8ub3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybixcclxuXHJcblx0XHRcdGVxdWFsczogKGE6IFQsIGI6IFQpOiBib29sZWFuID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gYS5zdG9wU3RhdGUgPT09IGIuc3RvcFN0YXRlXHJcblx0XHRcdFx0XHQmJiBhLnJldHVyblN0YXRlID09PSBiLnJldHVyblN0YXRlXHJcblx0XHRcdFx0XHQmJiBhLm91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4gPT09IGIub3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybjtcclxuXHRcdFx0fSxcclxuXHRcdH0pO1xyXG5cdFx0bGV0IHJldHVyblRyYW5zaXRpb25zOiBUW10gPSBbXTtcclxuXHRcdGZvciAobGV0IHN0YXRlIG9mIGF0bi5zdGF0ZXMpIHtcclxuXHRcdFx0bGV0IHJldHVybmluZ1RvTGVmdEZhY3RvcmVkOiBib29sZWFuID0gc3RhdGUucnVsZUluZGV4ID49IDAgJiYgYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbc3RhdGUucnVsZUluZGV4XS5sZWZ0RmFjdG9yZWQ7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUubnVtYmVyT2ZUcmFuc2l0aW9uczsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IHQ6IFRyYW5zaXRpb24gPSBzdGF0ZS50cmFuc2l0aW9uKGkpO1xyXG5cdFx0XHRcdGlmICghKHQgaW5zdGFuY2VvZiBSdWxlVHJhbnNpdGlvbikpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IHJ1bGVUcmFuc2l0aW9uOiBSdWxlVHJhbnNpdGlvbiA9IHQ7XHJcblx0XHRcdFx0bGV0IHJldHVybmluZ0Zyb21MZWZ0RmFjdG9yZWQ6IGJvb2xlYW4gPSBhdG4ucnVsZVRvU3RhcnRTdGF0ZVtydWxlVHJhbnNpdGlvbi50YXJnZXQucnVsZUluZGV4XS5sZWZ0RmFjdG9yZWQ7XHJcblx0XHRcdFx0aWYgKCFyZXR1cm5pbmdGcm9tTGVmdEZhY3RvcmVkICYmIHJldHVybmluZ1RvTGVmdEZhY3RvcmVkKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuOiBudW1iZXIgPSAtMTtcclxuXHRcdFx0XHRpZiAoYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbcnVsZVRyYW5zaXRpb24udGFyZ2V0LnJ1bGVJbmRleF0uaXNQcmVjZWRlbmNlUnVsZSkge1xyXG5cdFx0XHRcdFx0aWYgKHJ1bGVUcmFuc2l0aW9uLnByZWNlZGVuY2UgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0b3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiA9IHJ1bGVUcmFuc2l0aW9uLnRhcmdldC5ydWxlSW5kZXg7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgY3VycmVudCA9IHsgc3RvcFN0YXRlOiBydWxlVHJhbnNpdGlvbi50YXJnZXQucnVsZUluZGV4LCByZXR1cm5TdGF0ZTogcnVsZVRyYW5zaXRpb24uZm9sbG93U3RhdGUuc3RhdGVOdW1iZXIsIG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4gfTtcclxuXHRcdFx0XHRpZiAocmV0dXJuVHJhbnNpdGlvbnNTZXQuYWRkKGN1cnJlbnQpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm5UcmFuc2l0aW9ucy5wdXNoKGN1cnJlbnQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCBhbGwgZWxlbWVudHMgZnJvbSByZXR1cm5UcmFuc2l0aW9ucyB0byB0aGUgQVROXHJcblx0XHRmb3IgKGxldCByZXR1cm5UcmFuc2l0aW9uIG9mIHJldHVyblRyYW5zaXRpb25zKSB7XHJcblx0XHRcdGxldCB0cmFuc2l0aW9uID0gbmV3IEVwc2lsb25UcmFuc2l0aW9uKGF0bi5zdGF0ZXNbcmV0dXJuVHJhbnNpdGlvbi5yZXR1cm5TdGF0ZV0sIHJldHVyblRyYW5zaXRpb24ub3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybik7XHJcblx0XHRcdGF0bi5ydWxlVG9TdG9wU3RhdGVbcmV0dXJuVHJhbnNpdGlvbi5zdG9wU3RhdGVdLmFkZFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xyXG5cdFx0XHRpZiAoc3RhdGUgaW5zdGFuY2VvZiBCbG9ja1N0YXJ0U3RhdGUpIHtcclxuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGtub3cgdGhlIGVuZCBzdGF0ZSB0byBzZXQgaXRzIHN0YXJ0IHN0YXRlXHJcblx0XHRcdFx0aWYgKHN0YXRlLmVuZFN0YXRlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIklsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGJsb2NrIGVuZCBzdGF0ZXMgY2FuIG9ubHkgYmUgYXNzb2NpYXRlZCB0byBhIHNpbmdsZSBibG9jayBzdGFydCBzdGF0ZVxyXG5cdFx0XHRcdGlmIChzdGF0ZS5lbmRTdGF0ZS5zdGFydFN0YXRlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIklsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN0YXRlLmVuZFN0YXRlLnN0YXJ0U3RhdGUgPSBzdGF0ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHN0YXRlIGluc3RhbmNlb2YgUGx1c0xvb3BiYWNrU3RhdGUpIHtcclxuXHRcdFx0XHRsZXQgbG9vcGJhY2tTdGF0ZTogUGx1c0xvb3BiYWNrU3RhdGUgPSBzdGF0ZTtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxvb3BiYWNrU3RhdGUubnVtYmVyT2ZUcmFuc2l0aW9uczsgaSsrKSB7XHJcblx0XHRcdFx0XHRsZXQgdGFyZ2V0OiBBVE5TdGF0ZSA9IGxvb3BiYWNrU3RhdGUudHJhbnNpdGlvbihpKS50YXJnZXQ7XHJcblx0XHRcdFx0XHRpZiAodGFyZ2V0IGluc3RhbmNlb2YgUGx1c0Jsb2NrU3RhcnRTdGF0ZSkge1xyXG5cdFx0XHRcdFx0XHR0YXJnZXQubG9vcEJhY2tTdGF0ZSA9IGxvb3BiYWNrU3RhdGU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BiYWNrU3RhdGUpIHtcclxuXHRcdFx0XHRsZXQgbG9vcGJhY2tTdGF0ZTogU3Rhckxvb3BiYWNrU3RhdGUgPSBzdGF0ZTtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxvb3BiYWNrU3RhdGUubnVtYmVyT2ZUcmFuc2l0aW9uczsgaSsrKSB7XHJcblx0XHRcdFx0XHRsZXQgdGFyZ2V0OiBBVE5TdGF0ZSA9IGxvb3BiYWNrU3RhdGUudHJhbnNpdGlvbihpKS50YXJnZXQ7XHJcblx0XHRcdFx0XHRpZiAodGFyZ2V0IGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKSB7XHJcblx0XHRcdFx0XHRcdHRhcmdldC5sb29wQmFja1N0YXRlID0gbG9vcGJhY2tTdGF0ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cdFx0Ly8gREVDSVNJT05TXHJcblx0XHQvL1xyXG5cdFx0bGV0IG5kZWNpc2lvbnM6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPD0gbmRlY2lzaW9uczsgaSsrKSB7XHJcblx0XHRcdGxldCBzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKTtcclxuXHRcdFx0bGV0IGRlY1N0YXRlOiBEZWNpc2lvblN0YXRlID0gYXRuLnN0YXRlc1tzXSBhcyBEZWNpc2lvblN0YXRlO1xyXG5cdFx0XHRhdG4uZGVjaXNpb25Ub1N0YXRlLnB1c2goZGVjU3RhdGUpO1xyXG5cdFx0XHRkZWNTdGF0ZS5kZWNpc2lvbiA9IGkgLSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblx0XHQvLyBMRVhFUiBBQ1RJT05TXHJcblx0XHQvL1xyXG5cdFx0aWYgKGF0bi5ncmFtbWFyVHlwZSA9PT0gQVROVHlwZS5MRVhFUikge1xyXG5cdFx0XHRpZiAoc3VwcG9ydHNMZXhlckFjdGlvbnMpIHtcclxuXHRcdFx0XHRhdG4ubGV4ZXJBY3Rpb25zID0gbmV3IEFycmF5PExleGVyQWN0aW9uPihBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKSk7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhdG4ubGV4ZXJBY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRsZXQgYWN0aW9uVHlwZTogTGV4ZXJBY3Rpb25UeXBlID0gQVRORGVzZXJpYWxpemVyLnRvSW50KGRhdGFbcCsrXSk7XHJcblx0XHRcdFx0XHRsZXQgZGF0YTE6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0XHRcdFx0aWYgKGRhdGExID09PSAweEZGRkYpIHtcclxuXHRcdFx0XHRcdFx0ZGF0YTEgPSAtMTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsZXQgZGF0YTI6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0XHRcdFx0aWYgKGRhdGEyID09PSAweEZGRkYpIHtcclxuXHRcdFx0XHRcdFx0ZGF0YTIgPSAtMTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsZXQgbGV4ZXJBY3Rpb246IExleGVyQWN0aW9uID0gdGhpcy5sZXhlckFjdGlvbkZhY3RvcnkoYWN0aW9uVHlwZSwgZGF0YTEsIGRhdGEyKTtcclxuXHJcblx0XHRcdFx0XHRhdG4ubGV4ZXJBY3Rpb25zW2ldID0gbGV4ZXJBY3Rpb247XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdC8vIGZvciBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgc2VyaWFsaXplZCBBVE5zLCBjb252ZXJ0IHRoZSBvbGRcclxuXHRcdFx0XHQvLyBzZXJpYWxpemVkIGFjdGlvbiBpbmRleCBmb3IgYWN0aW9uIHRyYW5zaXRpb25zIHRvIHRoZSBuZXdcclxuXHRcdFx0XHQvLyBmb3JtLCB3aGljaCBpcyB0aGUgaW5kZXggb2YgYSBMZXhlckN1c3RvbUFjdGlvblxyXG5cdFx0XHRcdGxldCBsZWdhY3lMZXhlckFjdGlvbnM6IExleGVyQWN0aW9uW10gPSBbXTtcclxuXHRcdFx0XHRmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRsZXQgdHJhbnNpdGlvbjogVHJhbnNpdGlvbiA9IHN0YXRlLnRyYW5zaXRpb24oaSk7XHJcblx0XHRcdFx0XHRcdGlmICghKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBBY3Rpb25UcmFuc2l0aW9uKSkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRsZXQgcnVsZUluZGV4OiBudW1iZXIgPSB0cmFuc2l0aW9uLnJ1bGVJbmRleDtcclxuXHRcdFx0XHRcdFx0bGV0IGFjdGlvbkluZGV4OiBudW1iZXIgPSB0cmFuc2l0aW9uLmFjdGlvbkluZGV4O1xyXG5cdFx0XHRcdFx0XHRsZXQgbGV4ZXJBY3Rpb246IExleGVyQ3VzdG9tQWN0aW9uID0gbmV3IExleGVyQ3VzdG9tQWN0aW9uKHJ1bGVJbmRleCwgYWN0aW9uSW5kZXgpO1xyXG5cdFx0XHRcdFx0XHRzdGF0ZS5zZXRUcmFuc2l0aW9uKGksIG5ldyBBY3Rpb25UcmFuc2l0aW9uKHRyYW5zaXRpb24udGFyZ2V0LCBydWxlSW5kZXgsIGxlZ2FjeUxleGVyQWN0aW9ucy5sZW5ndGgsIGZhbHNlKSk7XHJcblx0XHRcdFx0XHRcdGxlZ2FjeUxleGVyQWN0aW9ucy5wdXNoKGxleGVyQWN0aW9uKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGF0bi5sZXhlckFjdGlvbnMgPSBsZWdhY3lMZXhlckFjdGlvbnM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm1hcmtQcmVjZWRlbmNlRGVjaXNpb25zKGF0bik7XHJcblxyXG5cdFx0YXRuLmRlY2lzaW9uVG9ERkEgPSBuZXcgQXJyYXk8REZBPihuZGVjaXNpb25zKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmRlY2lzaW9uczsgaSsrKSB7XHJcblx0XHRcdGF0bi5kZWNpc2lvblRvREZBW2ldID0gbmV3IERGQShhdG4uZGVjaXNpb25Ub1N0YXRlW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5kZXNlcmlhbGl6YXRpb25PcHRpb25zLmlzVmVyaWZ5QVROKSB7XHJcblx0XHRcdHRoaXMudmVyaWZ5QVROKGF0bik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuZGVzZXJpYWxpemF0aW9uT3B0aW9ucy5pc0dlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zICYmIGF0bi5ncmFtbWFyVHlwZSA9PT0gQVROVHlwZS5QQVJTRVIpIHtcclxuXHRcdFx0YXRuLnJ1bGVUb1Rva2VuVHlwZSA9IG5ldyBJbnQzMkFycmF5KGF0bi5ydWxlVG9TdGFydFN0YXRlLmxlbmd0aCk7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXRuLnJ1bGVUb1N0YXJ0U3RhdGUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRhdG4ucnVsZVRvVG9rZW5UeXBlW2ldID0gYXRuLm1heFRva2VuVHlwZSArIGkgKyAxO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGF0bi5ydWxlVG9TdGFydFN0YXRlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IGJ5cGFzc1N0YXJ0OiBCYXNpY0Jsb2NrU3RhcnRTdGF0ZSA9IG5ldyBCYXNpY0Jsb2NrU3RhcnRTdGF0ZSgpO1xyXG5cdFx0XHRcdGJ5cGFzc1N0YXJ0LnJ1bGVJbmRleCA9IGk7XHJcblx0XHRcdFx0YXRuLmFkZFN0YXRlKGJ5cGFzc1N0YXJ0KTtcclxuXHJcblx0XHRcdFx0bGV0IGJ5cGFzc1N0b3A6IEJsb2NrRW5kU3RhdGUgPSBuZXcgQmxvY2tFbmRTdGF0ZSgpO1xyXG5cdFx0XHRcdGJ5cGFzc1N0b3AucnVsZUluZGV4ID0gaTtcclxuXHRcdFx0XHRhdG4uYWRkU3RhdGUoYnlwYXNzU3RvcCk7XHJcblxyXG5cdFx0XHRcdGJ5cGFzc1N0YXJ0LmVuZFN0YXRlID0gYnlwYXNzU3RvcDtcclxuXHRcdFx0XHRhdG4uZGVmaW5lRGVjaXNpb25TdGF0ZShieXBhc3NTdGFydCk7XHJcblxyXG5cdFx0XHRcdGJ5cGFzc1N0b3Auc3RhcnRTdGF0ZSA9IGJ5cGFzc1N0YXJ0O1xyXG5cclxuXHRcdFx0XHRsZXQgZW5kU3RhdGU6IEFUTlN0YXRlIHwgdW5kZWZpbmVkO1xyXG5cdFx0XHRcdGxldCBleGNsdWRlVHJhbnNpdGlvbjogVHJhbnNpdGlvbiB8IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRpZiAoYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbaV0uaXNQcmVjZWRlbmNlUnVsZSkge1xyXG5cdFx0XHRcdFx0Ly8gd3JhcCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJ1bGUgdG8gdGhlIFN0YXJMb29wRW50cnlTdGF0ZVxyXG5cdFx0XHRcdFx0ZW5kU3RhdGUgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XHJcblx0XHRcdFx0XHRcdGlmIChzdGF0ZS5ydWxlSW5kZXggIT09IGkpIHtcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCEoc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGxldCBtYXliZUxvb3BFbmRTdGF0ZTogQVROU3RhdGUgPSBzdGF0ZS50cmFuc2l0aW9uKHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnMgLSAxKS50YXJnZXQ7XHJcblx0XHRcdFx0XHRcdGlmICghKG1heWJlTG9vcEVuZFN0YXRlIGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKSkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAobWF5YmVMb29wRW5kU3RhdGUuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyAmJiBtYXliZUxvb3BFbmRTdGF0ZS50cmFuc2l0aW9uKDApLnRhcmdldCBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcclxuXHRcdFx0XHRcdFx0XHRlbmRTdGF0ZSA9IHN0YXRlO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCFlbmRTdGF0ZSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBpZGVudGlmeSBmaW5hbCBzdGF0ZSBvZiB0aGUgcHJlY2VkZW5jZSBydWxlIHByZWZpeCBzZWN0aW9uLlwiKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRleGNsdWRlVHJhbnNpdGlvbiA9IChlbmRTdGF0ZSBhcyBTdGFyTG9vcEVudHJ5U3RhdGUpLmxvb3BCYWNrU3RhdGUudHJhbnNpdGlvbigwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRlbmRTdGF0ZSA9IGF0bi5ydWxlVG9TdG9wU3RhdGVbaV07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBhbGwgbm9uLWV4Y2x1ZGVkIHRyYW5zaXRpb25zIHRoYXQgY3VycmVudGx5IHRhcmdldCBlbmQgc3RhdGUgbmVlZCB0byB0YXJnZXQgYmxvY2tFbmQgaW5zdGVhZFxyXG5cdFx0XHRcdGZvciAobGV0IHN0YXRlIG9mIGF0bi5zdGF0ZXMpIHtcclxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUubnVtYmVyT2ZUcmFuc2l0aW9uczsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdGxldCB0cmFuc2l0aW9uID0gc3RhdGUudHJhbnNpdGlvbihpKTtcclxuXHRcdFx0XHRcdFx0aWYgKHRyYW5zaXRpb24gPT09IGV4Y2x1ZGVUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICh0cmFuc2l0aW9uLnRhcmdldCA9PT0gZW5kU3RhdGUpIHtcclxuXHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uLnRhcmdldCA9IGJ5cGFzc1N0b3A7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGFsbCB0cmFuc2l0aW9ucyBsZWF2aW5nIHRoZSBydWxlIHN0YXJ0IHN0YXRlIG5lZWQgdG8gbGVhdmUgYmxvY2tTdGFydCBpbnN0ZWFkXHJcblx0XHRcdFx0d2hpbGUgKGF0bi5ydWxlVG9TdGFydFN0YXRlW2ldLm51bWJlck9mVHJhbnNpdGlvbnMgPiAwKSB7XHJcblx0XHRcdFx0XHRsZXQgdHJhbnNpdGlvbjogVHJhbnNpdGlvbiA9IGF0bi5ydWxlVG9TdGFydFN0YXRlW2ldLnJlbW92ZVRyYW5zaXRpb24oYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbaV0ubnVtYmVyT2ZUcmFuc2l0aW9ucyAtIDEpO1xyXG5cdFx0XHRcdFx0YnlwYXNzU3RhcnQuYWRkVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGxpbmsgdGhlIG5ldyBzdGF0ZXNcclxuXHRcdFx0XHRhdG4ucnVsZVRvU3RhcnRTdGF0ZVtpXS5hZGRUcmFuc2l0aW9uKG5ldyBFcHNpbG9uVHJhbnNpdGlvbihieXBhc3NTdGFydCkpO1xyXG5cdFx0XHRcdGJ5cGFzc1N0b3AuYWRkVHJhbnNpdGlvbihuZXcgRXBzaWxvblRyYW5zaXRpb24oZW5kU3RhdGUpKTtcclxuXHJcblx0XHRcdFx0bGV0IG1hdGNoU3RhdGU6IEFUTlN0YXRlID0gbmV3IEJhc2ljU3RhdGUoKTtcclxuXHRcdFx0XHRhdG4uYWRkU3RhdGUobWF0Y2hTdGF0ZSk7XHJcblx0XHRcdFx0bWF0Y2hTdGF0ZS5hZGRUcmFuc2l0aW9uKG5ldyBBdG9tVHJhbnNpdGlvbihieXBhc3NTdG9wLCBhdG4ucnVsZVRvVG9rZW5UeXBlW2ldKSk7XHJcblx0XHRcdFx0YnlwYXNzU3RhcnQuYWRkVHJhbnNpdGlvbihuZXcgRXBzaWxvblRyYW5zaXRpb24obWF0Y2hTdGF0ZSkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpcy5kZXNlcmlhbGl6YXRpb25PcHRpb25zLmlzVmVyaWZ5QVROKSB7XHJcblx0XHRcdFx0Ly8gcmV2ZXJpZnkgYWZ0ZXIgbW9kaWZpY2F0aW9uXHJcblx0XHRcdFx0dGhpcy52ZXJpZnlBVE4oYXRuKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmRlc2VyaWFsaXphdGlvbk9wdGlvbnMuaXNPcHRpbWl6ZSkge1xyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGxldCBvcHRpbWl6YXRpb25Db3VudDogbnVtYmVyID0gMDtcclxuXHRcdFx0XHRvcHRpbWl6YXRpb25Db3VudCArPSBBVE5EZXNlcmlhbGl6ZXIuaW5saW5lU2V0UnVsZXMoYXRuKTtcclxuXHRcdFx0XHRvcHRpbWl6YXRpb25Db3VudCArPSBBVE5EZXNlcmlhbGl6ZXIuY29tYmluZUNoYWluZWRFcHNpbG9ucyhhdG4pO1xyXG5cdFx0XHRcdGxldCBwcmVzZXJ2ZU9yZGVyOiBib29sZWFuID0gYXRuLmdyYW1tYXJUeXBlID09PSBBVE5UeXBlLkxFWEVSO1xyXG5cdFx0XHRcdG9wdGltaXphdGlvbkNvdW50ICs9IEFUTkRlc2VyaWFsaXplci5vcHRpbWl6ZVNldHMoYXRuLCBwcmVzZXJ2ZU9yZGVyKTtcclxuXHRcdFx0XHRpZiAob3B0aW1pemF0aW9uQ291bnQgPT09IDApIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXMuZGVzZXJpYWxpemF0aW9uT3B0aW9ucy5pc1ZlcmlmeUFUTikge1xyXG5cdFx0XHRcdC8vIHJldmVyaWZ5IGFmdGVyIG1vZGlmaWNhdGlvblxyXG5cdFx0XHRcdHRoaXMudmVyaWZ5QVROKGF0bik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRBVE5EZXNlcmlhbGl6ZXIuaWRlbnRpZnlUYWlsQ2FsbHMoYXRuKTtcclxuXHJcblx0XHRyZXR1cm4gYXRuO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBkZXNlcmlhbGl6ZVNldHMoZGF0YTogVWludDE2QXJyYXksIHA6IG51bWJlciwgc2V0czogSW50ZXJ2YWxTZXRbXSwgdW5pY29kZURlc2VyaWFsaXplcjogVW5pY29kZURlc2VyaWFsaXplcik6IG51bWJlciB7XHJcblx0XHRsZXQgbnNldHM6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludChkYXRhW3ArK10pO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuc2V0czsgaSsrKSB7XHJcblx0XHRcdGxldCBuaW50ZXJ2YWxzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwXSk7XHJcblx0XHRcdHArKztcclxuXHRcdFx0bGV0IHNldDogSW50ZXJ2YWxTZXQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdFx0c2V0cy5wdXNoKHNldCk7XHJcblxyXG5cdFx0XHRsZXQgY29udGFpbnNFb2Y6IGJvb2xlYW4gPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQoZGF0YVtwKytdKSAhPT0gMDtcclxuXHRcdFx0aWYgKGNvbnRhaW5zRW9mKSB7XHJcblx0XHRcdFx0c2V0LmFkZCgtMSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBuaW50ZXJ2YWxzOyBqKyspIHtcclxuXHRcdFx0XHRsZXQgYTogbnVtYmVyID0gdW5pY29kZURlc2VyaWFsaXplci5yZWFkVW5pY29kZShkYXRhLCBwKTtcclxuXHRcdFx0XHRwICs9IHVuaWNvZGVEZXNlcmlhbGl6ZXIuc2l6ZTtcclxuXHRcdFx0XHRsZXQgYjogbnVtYmVyID0gdW5pY29kZURlc2VyaWFsaXplci5yZWFkVW5pY29kZShkYXRhLCBwKTtcclxuXHRcdFx0XHRwICs9IHVuaWNvZGVEZXNlcmlhbGl6ZXIuc2l6ZTtcclxuXHRcdFx0XHRzZXQuYWRkKGEsIGIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBbmFseXplIHRoZSB7QGxpbmsgU3Rhckxvb3BFbnRyeVN0YXRlfSBzdGF0ZXMgaW4gdGhlIHNwZWNpZmllZCBBVE4gdG8gc2V0XHJcblx0ICogdGhlIHtAbGluayBTdGFyTG9vcEVudHJ5U3RhdGUjcHJlY2VkZW5jZVJ1bGVEZWNpc2lvbn0gZmllbGQgdG8gdGhlXHJcblx0ICogY29ycmVjdCB2YWx1ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBhdG4gVGhlIEFUTi5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgbWFya1ByZWNlZGVuY2VEZWNpc2lvbnMoQE5vdE51bGwgYXRuOiBBVE4pOiB2b2lkIHtcclxuXHRcdC8vIE1hcCBydWxlIGluZGV4IC0+IHByZWNlZGVuY2UgZGVjaXNpb24gZm9yIHRoYXQgcnVsZVxyXG5cdFx0bGV0IHJ1bGVQcmVjZWRlbmNlRGVjaXNpb25zID0gbmV3IE1hcDxudW1iZXIsIFN0YXJMb29wRW50cnlTdGF0ZT4oKTtcclxuXHJcblx0XHRmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XHJcblx0XHRcdGlmICghKHN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKiBXZSBhbmFseXplIHRoZSBBVE4gdG8gZGV0ZXJtaW5lIGlmIHRoaXMgQVROIGRlY2lzaW9uIHN0YXRlIGlzIHRoZVxyXG5cdFx0XHQgKiBkZWNpc2lvbiBmb3IgdGhlIGNsb3N1cmUgYmxvY2sgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgYVxyXG5cdFx0XHQgKiBwcmVjZWRlbmNlIHJ1bGUgc2hvdWxkIGNvbnRpbnVlIG9yIGNvbXBsZXRlLlxyXG5cdFx0XHQgKi9cclxuXHRcdFx0aWYgKGF0bi5ydWxlVG9TdGFydFN0YXRlW3N0YXRlLnJ1bGVJbmRleF0uaXNQcmVjZWRlbmNlUnVsZSkge1xyXG5cdFx0XHRcdGxldCBtYXliZUxvb3BFbmRTdGF0ZTogQVROU3RhdGUgPSBzdGF0ZS50cmFuc2l0aW9uKHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnMgLSAxKS50YXJnZXQ7XHJcblx0XHRcdFx0aWYgKG1heWJlTG9vcEVuZFN0YXRlIGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKSB7XHJcblx0XHRcdFx0XHRpZiAobWF5YmVMb29wRW5kU3RhdGUuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyAmJiBtYXliZUxvb3BFbmRTdGF0ZS50cmFuc2l0aW9uKDApLnRhcmdldCBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcclxuXHRcdFx0XHRcdFx0cnVsZVByZWNlZGVuY2VEZWNpc2lvbnMuc2V0KHN0YXRlLnJ1bGVJbmRleCwgc3RhdGUpO1xyXG5cdFx0XHRcdFx0XHRzdGF0ZS5wcmVjZWRlbmNlUnVsZURlY2lzaW9uID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0c3RhdGUucHJlY2VkZW5jZUxvb3BiYWNrU3RhdGVzID0gbmV3IEJpdFNldChhdG4uc3RhdGVzLmxlbmd0aCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWZ0ZXIgbWFya2luZyBwcmVjZWRlbmNlIGRlY2lzaW9ucywgd2UgZ28gYmFjayB0aHJvdWdoIGFuZCBmaWxsIGluXHJcblx0XHQvLyBTdGFyTG9vcEVudHJ5U3RhdGUucHJlY2VkZW5jZUxvb3BiYWNrU3RhdGVzLlxyXG5cdFx0Zm9yIChsZXQgcHJlY2VkZW5jZURlY2lzaW9uIG9mIHJ1bGVQcmVjZWRlbmNlRGVjaXNpb25zKSB7XHJcblx0XHRcdGZvciAobGV0IHRyYW5zaXRpb24gb2YgYXRuLnJ1bGVUb1N0b3BTdGF0ZVtwcmVjZWRlbmNlRGVjaXNpb25bMF1dLmdldFRyYW5zaXRpb25zKCkpIHtcclxuXHRcdFx0XHRpZiAodHJhbnNpdGlvbi5zZXJpYWxpemF0aW9uVHlwZSAhPT0gVHJhbnNpdGlvblR5cGUuRVBTSUxPTikge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgZXBzaWxvblRyYW5zaXRpb24gPSB0cmFuc2l0aW9uIGFzIEVwc2lsb25UcmFuc2l0aW9uO1xyXG5cdFx0XHRcdGlmIChlcHNpbG9uVHJhbnNpdGlvbi5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwcmVjZWRlbmNlRGVjaXNpb25bMV0ucHJlY2VkZW5jZUxvb3BiYWNrU3RhdGVzLnNldCh0cmFuc2l0aW9uLnRhcmdldC5zdGF0ZU51bWJlcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCB2ZXJpZnlBVE4oYXRuOiBBVE4pOiB2b2lkIHtcclxuXHRcdC8vIHZlcmlmeSBhc3N1bXB0aW9uc1xyXG5cdFx0Zm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xyXG5cdFx0XHR0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlICE9PSB1bmRlZmluZWQsIFwiQVROIHN0YXRlcyBzaG91bGQgbm90IGJlIHVuZGVmaW5lZC5cIik7XHJcblx0XHRcdGlmIChzdGF0ZS5zdGF0ZVR5cGUgPT09IEFUTlN0YXRlVHlwZS5JTlZBTElEX1RZUEUpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5vbmx5SGFzRXBzaWxvblRyYW5zaXRpb25zIHx8IHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnMgPD0gMSk7XHJcblxyXG5cdFx0XHRpZiAoc3RhdGUgaW5zdGFuY2VvZiBQbHVzQmxvY2tTdGFydFN0YXRlKSB7XHJcblx0XHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5sb29wQmFja1N0YXRlICE9PSB1bmRlZmluZWQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGUpIHtcclxuXHRcdFx0XHRsZXQgc3Rhckxvb3BFbnRyeVN0YXRlOiBTdGFyTG9vcEVudHJ5U3RhdGUgPSBzdGF0ZTtcclxuXHRcdFx0XHR0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXJMb29wRW50cnlTdGF0ZS5sb29wQmFja1N0YXRlICE9PSB1bmRlZmluZWQpO1xyXG5cdFx0XHRcdHRoaXMuY2hlY2tDb25kaXRpb24oc3Rhckxvb3BFbnRyeVN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnMgPT09IDIpO1xyXG5cclxuXHRcdFx0XHRpZiAoc3Rhckxvb3BFbnRyeVN0YXRlLnRyYW5zaXRpb24oMCkudGFyZ2V0IGluc3RhbmNlb2YgU3RhckJsb2NrU3RhcnRTdGF0ZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbihzdGFyTG9vcEVudHJ5U3RhdGUudHJhbnNpdGlvbigxKS50YXJnZXQgaW5zdGFuY2VvZiBMb29wRW5kU3RhdGUpO1xyXG5cdFx0XHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbighc3Rhckxvb3BFbnRyeVN0YXRlLm5vbkdyZWVkeSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHN0YXJMb29wRW50cnlTdGF0ZS50cmFuc2l0aW9uKDApLnRhcmdldCBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbihzdGFyTG9vcEVudHJ5U3RhdGUudHJhbnNpdGlvbigxKS50YXJnZXQgaW5zdGFuY2VvZiBTdGFyQmxvY2tTdGFydFN0YXRlKTtcclxuXHRcdFx0XHRcdHRoaXMuY2hlY2tDb25kaXRpb24oc3Rhckxvb3BFbnRyeVN0YXRlLm5vbkdyZWVkeSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbFN0YXRlRXhjZXB0aW9uXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BiYWNrU3RhdGUpIHtcclxuXHRcdFx0XHR0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnMgPT09IDEpO1xyXG5cdFx0XHRcdHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUudHJhbnNpdGlvbigwKS50YXJnZXQgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoc3RhdGUgaW5zdGFuY2VvZiBMb29wRW5kU3RhdGUpIHtcclxuXHRcdFx0XHR0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLmxvb3BCYWNrU3RhdGUgIT09IHVuZGVmaW5lZCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChzdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdGFydFN0YXRlKSB7XHJcblx0XHRcdFx0dGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5zdG9wU3RhdGUgIT09IHVuZGVmaW5lZCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChzdGF0ZSBpbnN0YW5jZW9mIEJsb2NrU3RhcnRTdGF0ZSkge1xyXG5cdFx0XHRcdHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUuZW5kU3RhdGUgIT09IHVuZGVmaW5lZCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChzdGF0ZSBpbnN0YW5jZW9mIEJsb2NrRW5kU3RhdGUpIHtcclxuXHRcdFx0XHR0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnN0YXJ0U3RhdGUgIT09IHVuZGVmaW5lZCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChzdGF0ZSBpbnN0YW5jZW9mIERlY2lzaW9uU3RhdGUpIHtcclxuXHRcdFx0XHRsZXQgZGVjaXNpb25TdGF0ZTogRGVjaXNpb25TdGF0ZSA9IHN0YXRlO1xyXG5cdFx0XHRcdHRoaXMuY2hlY2tDb25kaXRpb24oZGVjaXNpb25TdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zIDw9IDEgfHwgZGVjaXNpb25TdGF0ZS5kZWNpc2lvbiA+PSAwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnMgPD0gMSB8fCBzdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgY2hlY2tDb25kaXRpb24oY29uZGl0aW9uOiBib29sZWFuLCBtZXNzYWdlPzogc3RyaW5nKTogdm9pZCB7XHJcblx0XHRpZiAoIWNvbmRpdGlvbikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsU3RhdGVFeGNlcHRpb246IFwiICsgbWVzc2FnZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBpbmxpbmVTZXRSdWxlcyhhdG46IEFUTik6IG51bWJlciB7XHJcblx0XHRsZXQgaW5saW5lZENhbGxzOiBudW1iZXIgPSAwO1xyXG5cclxuXHRcdGxldCBydWxlVG9JbmxpbmVUcmFuc2l0aW9uID0gbmV3IEFycmF5PFRyYW5zaXRpb24gfCB1bmRlZmluZWQ+KGF0bi5ydWxlVG9TdGFydFN0YXRlLmxlbmd0aCk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGF0bi5ydWxlVG9TdGFydFN0YXRlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBzdGFydFN0YXRlOiBSdWxlU3RhcnRTdGF0ZSA9IGF0bi5ydWxlVG9TdGFydFN0YXRlW2ldO1xyXG5cdFx0XHRsZXQgbWlkZGxlU3RhdGU6IEFUTlN0YXRlID0gc3RhcnRTdGF0ZTtcclxuXHRcdFx0d2hpbGUgKG1pZGRsZVN0YXRlLm9ubHlIYXNFcHNpbG9uVHJhbnNpdGlvbnNcclxuXHRcdFx0XHQmJiBtaWRkbGVTdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zID09PSAxXHJcblx0XHRcdFx0JiYgbWlkZGxlU3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbigwKS5zZXJpYWxpemF0aW9uVHlwZSA9PT0gVHJhbnNpdGlvblR5cGUuRVBTSUxPTikge1xyXG5cdFx0XHRcdG1pZGRsZVN0YXRlID0gbWlkZGxlU3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbigwKS50YXJnZXQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChtaWRkbGVTdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zICE9PSAxKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBtYXRjaFRyYW5zaXRpb246IFRyYW5zaXRpb24gPSBtaWRkbGVTdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKDApO1xyXG5cdFx0XHRsZXQgbWF0Y2hUYXJnZXQ6IEFUTlN0YXRlID0gbWF0Y2hUcmFuc2l0aW9uLnRhcmdldDtcclxuXHRcdFx0aWYgKG1hdGNoVHJhbnNpdGlvbi5pc0Vwc2lsb25cclxuXHRcdFx0XHR8fCAhbWF0Y2hUYXJnZXQub25seUhhc0Vwc2lsb25UcmFuc2l0aW9uc1xyXG5cdFx0XHRcdHx8IG1hdGNoVGFyZ2V0Lm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgIT09IDFcclxuXHRcdFx0XHR8fCAhKG1hdGNoVGFyZ2V0LmdldE9wdGltaXplZFRyYW5zaXRpb24oMCkudGFyZ2V0IGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3dpdGNoIChtYXRjaFRyYW5zaXRpb24uc2VyaWFsaXphdGlvblR5cGUpIHtcclxuXHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5BVE9NOlxyXG5cdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlJBTkdFOlxyXG5cdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlNFVDpcclxuXHRcdFx0XHRydWxlVG9JbmxpbmVUcmFuc2l0aW9uW2ldID0gbWF0Y2hUcmFuc2l0aW9uO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5OT1RfU0VUOlxyXG5cdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLldJTERDQVJEOlxyXG5cdFx0XHRcdC8vIG5vdCBpbXBsZW1lbnRlZCB5ZXRcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XHJcblx0XHRcdGlmIChzdGF0ZS5ydWxlSW5kZXggPCAwKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBvcHRpbWl6ZWRUcmFuc2l0aW9uczogVHJhbnNpdGlvbltdIHwgdW5kZWZpbmVkO1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnM7IGkrKykge1xyXG5cdFx0XHRcdGxldCB0cmFuc2l0aW9uOiBUcmFuc2l0aW9uID0gc3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihpKTtcclxuXHRcdFx0XHRpZiAoISh0cmFuc2l0aW9uIGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb24pKSB7XHJcblx0XHRcdFx0XHRpZiAob3B0aW1pemVkVHJhbnNpdGlvbnMgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKHRyYW5zaXRpb24pO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IHJ1bGVUcmFuc2l0aW9uOiBSdWxlVHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XHJcblx0XHRcdFx0bGV0IGVmZmVjdGl2ZTogVHJhbnNpdGlvbiB8IHVuZGVmaW5lZCA9IHJ1bGVUb0lubGluZVRyYW5zaXRpb25bcnVsZVRyYW5zaXRpb24udGFyZ2V0LnJ1bGVJbmRleF07XHJcblx0XHRcdFx0aWYgKGVmZmVjdGl2ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRpZiAob3B0aW1pemVkVHJhbnNpdGlvbnMgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKHRyYW5zaXRpb24pO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKG9wdGltaXplZFRyYW5zaXRpb25zID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdG9wdGltaXplZFRyYW5zaXRpb25zID0gW107XHJcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKykge1xyXG5cdFx0XHRcdFx0XHRvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKHN0YXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oaSkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aW5saW5lZENhbGxzKys7XHJcblx0XHRcdFx0bGV0IHRhcmdldDogQVROU3RhdGUgPSBydWxlVHJhbnNpdGlvbi5mb2xsb3dTdGF0ZTtcclxuXHRcdFx0XHRsZXQgaW50ZXJtZWRpYXRlU3RhdGU6IEFUTlN0YXRlID0gbmV3IEJhc2ljU3RhdGUoKTtcclxuXHRcdFx0XHRpbnRlcm1lZGlhdGVTdGF0ZS5zZXRSdWxlSW5kZXgodGFyZ2V0LnJ1bGVJbmRleCk7XHJcblx0XHRcdFx0YXRuLmFkZFN0YXRlKGludGVybWVkaWF0ZVN0YXRlKTtcclxuXHRcdFx0XHRvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKG5ldyBFcHNpbG9uVHJhbnNpdGlvbihpbnRlcm1lZGlhdGVTdGF0ZSkpO1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKGVmZmVjdGl2ZS5zZXJpYWxpemF0aW9uVHlwZSkge1xyXG5cdFx0XHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuQVRPTTpcclxuXHRcdFx0XHRcdGludGVybWVkaWF0ZVN0YXRlLmFkZFRyYW5zaXRpb24obmV3IEF0b21UcmFuc2l0aW9uKHRhcmdldCwgKGVmZmVjdGl2ZSBhcyBBdG9tVHJhbnNpdGlvbikuX2xhYmVsKSk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5SQU5HRTpcclxuXHRcdFx0XHRcdGludGVybWVkaWF0ZVN0YXRlLmFkZFRyYW5zaXRpb24obmV3IFJhbmdlVHJhbnNpdGlvbih0YXJnZXQsIChlZmZlY3RpdmUgYXMgUmFuZ2VUcmFuc2l0aW9uKS5mcm9tLCAoZWZmZWN0aXZlIGFzIFJhbmdlVHJhbnNpdGlvbikudG8pKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlNFVDpcclxuXHRcdFx0XHRcdGludGVybWVkaWF0ZVN0YXRlLmFkZFRyYW5zaXRpb24obmV3IFNldFRyYW5zaXRpb24odGFyZ2V0LCAoZWZmZWN0aXZlIGFzIFNldFRyYW5zaXRpb24pLmxhYmVsKSk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG9wdGltaXplZFRyYW5zaXRpb25zICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRpZiAoc3RhdGUuaXNPcHRpbWl6ZWQpIHtcclxuXHRcdFx0XHRcdHdoaWxlIChzdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zID4gMCkge1xyXG5cdFx0XHRcdFx0XHRzdGF0ZS5yZW1vdmVPcHRpbWl6ZWRUcmFuc2l0aW9uKHN0YXRlLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgLSAxKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IHRyYW5zaXRpb24gb2Ygb3B0aW1pemVkVHJhbnNpdGlvbnMpIHtcclxuXHRcdFx0XHRcdHN0YXRlLmFkZE9wdGltaXplZFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKFBhcnNlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkFUTiBydW50aW1lIG9wdGltaXplciByZW1vdmVkIFwiICsgaW5saW5lZENhbGxzICsgXCIgcnVsZSBpbnZvY2F0aW9ucyBieSBpbmxpbmluZyBzZXRzLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW5saW5lZENhbGxzO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgY29tYmluZUNoYWluZWRFcHNpbG9ucyhhdG46IEFUTik6IG51bWJlciB7XHJcblx0XHRsZXQgcmVtb3ZlZEVkZ2VzOiBudW1iZXIgPSAwO1xyXG5cclxuXHRcdGZvciAobGV0IHN0YXRlIG9mIGF0bi5zdGF0ZXMpIHtcclxuXHRcdFx0aWYgKCFzdGF0ZS5vbmx5SGFzRXBzaWxvblRyYW5zaXRpb25zIHx8IHN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgb3B0aW1pemVkVHJhbnNpdGlvbnM6IFRyYW5zaXRpb25bXSB8IHVuZGVmaW5lZDtcclxuXHRcdFx0bmV4dFRyYW5zaXRpb246XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9uczsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IHRyYW5zaXRpb246IFRyYW5zaXRpb24gPSBzdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKGkpO1xyXG5cdFx0XHRcdGxldCBpbnRlcm1lZGlhdGU6IEFUTlN0YXRlID0gdHJhbnNpdGlvbi50YXJnZXQ7XHJcblx0XHRcdFx0aWYgKHRyYW5zaXRpb24uc2VyaWFsaXphdGlvblR5cGUgIT09IFRyYW5zaXRpb25UeXBlLkVQU0lMT05cclxuXHRcdFx0XHRcdHx8ICh0cmFuc2l0aW9uIGFzIEVwc2lsb25UcmFuc2l0aW9uKS5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuICE9PSAtMVxyXG5cdFx0XHRcdFx0fHwgaW50ZXJtZWRpYXRlLnN0YXRlVHlwZSAhPT0gQVROU3RhdGVUeXBlLkJBU0lDXHJcblx0XHRcdFx0XHR8fCAhaW50ZXJtZWRpYXRlLm9ubHlIYXNFcHNpbG9uVHJhbnNpdGlvbnMpIHtcclxuXHRcdFx0XHRcdGlmIChvcHRpbWl6ZWRUcmFuc2l0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdG9wdGltaXplZFRyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29udGludWUgbmV4dFRyYW5zaXRpb247XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGludGVybWVkaWF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zOyBqKyspIHtcclxuXHRcdFx0XHRcdGlmIChpbnRlcm1lZGlhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihqKS5zZXJpYWxpemF0aW9uVHlwZSAhPT0gVHJhbnNpdGlvblR5cGUuRVBTSUxPTlxyXG5cdFx0XHRcdFx0XHR8fCAoaW50ZXJtZWRpYXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oaikgYXMgRXBzaWxvblRyYW5zaXRpb24pLm91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4gIT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdGlmIChvcHRpbWl6ZWRUcmFuc2l0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0b3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Y29udGludWUgbmV4dFRyYW5zaXRpb247XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZW1vdmVkRWRnZXMrKztcclxuXHRcdFx0XHRpZiAob3B0aW1pemVkVHJhbnNpdGlvbnMgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0b3B0aW1pemVkVHJhbnNpdGlvbnMgPSBbXTtcclxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKSB7XHJcblx0XHRcdFx0XHRcdG9wdGltaXplZFRyYW5zaXRpb25zLnB1c2goc3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihqKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGludGVybWVkaWF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zOyBqKyspIHtcclxuXHRcdFx0XHRcdGxldCB0YXJnZXQ6IEFUTlN0YXRlID0gaW50ZXJtZWRpYXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oaikudGFyZ2V0O1xyXG5cdFx0XHRcdFx0b3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaChuZXcgRXBzaWxvblRyYW5zaXRpb24odGFyZ2V0KSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAob3B0aW1pemVkVHJhbnNpdGlvbnMgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGlmIChzdGF0ZS5pc09wdGltaXplZCkge1xyXG5cdFx0XHRcdFx0d2hpbGUgKHN0YXRlLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgPiAwKSB7XHJcblx0XHRcdFx0XHRcdHN0YXRlLnJlbW92ZU9wdGltaXplZFRyYW5zaXRpb24oc3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyAtIDEpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgdHJhbnNpdGlvbiBvZiBvcHRpbWl6ZWRUcmFuc2l0aW9ucykge1xyXG5cdFx0XHRcdFx0c3RhdGUuYWRkT3B0aW1pemVkVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiQVROIHJ1bnRpbWUgb3B0aW1pemVyIHJlbW92ZWQgXCIgKyByZW1vdmVkRWRnZXMgKyBcIiB0cmFuc2l0aW9ucyBieSBjb21iaW5pbmcgY2hhaW5lZCBlcHNpbG9uIHRyYW5zaXRpb25zLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVtb3ZlZEVkZ2VzO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgb3B0aW1pemVTZXRzKGF0bjogQVROLCBwcmVzZXJ2ZU9yZGVyOiBib29sZWFuKTogbnVtYmVyIHtcclxuXHRcdGlmIChwcmVzZXJ2ZU9yZGVyKSB7XHJcblx0XHRcdC8vIHRoaXMgb3B0aW1pemF0aW9uIGN1cnJlbnRseSBkb2Vzbid0IHByZXNlcnZlIGVkZ2Ugb3JkZXIuXHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZW1vdmVkUGF0aHM6IG51bWJlciA9IDA7XHJcblx0XHRsZXQgZGVjaXNpb25zOiBEZWNpc2lvblN0YXRlW10gPSBhdG4uZGVjaXNpb25Ub1N0YXRlO1xyXG5cdFx0Zm9yIChsZXQgZGVjaXNpb24gb2YgZGVjaXNpb25zKSB7XHJcblx0XHRcdGxldCBzZXRUcmFuc2l0aW9uczogSW50ZXJ2YWxTZXQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkZWNpc2lvbi5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zOyBpKyspIHtcclxuXHRcdFx0XHRsZXQgZXBzVHJhbnNpdGlvbjogVHJhbnNpdGlvbiA9IGRlY2lzaW9uLmdldE9wdGltaXplZFRyYW5zaXRpb24oaSk7XHJcblx0XHRcdFx0aWYgKCEoZXBzVHJhbnNpdGlvbiBpbnN0YW5jZW9mIEVwc2lsb25UcmFuc2l0aW9uKSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZXBzVHJhbnNpdGlvbi50YXJnZXQubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyAhPT0gMSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgdHJhbnNpdGlvbjogVHJhbnNpdGlvbiA9IGVwc1RyYW5zaXRpb24udGFyZ2V0LmdldE9wdGltaXplZFRyYW5zaXRpb24oMCk7XHJcblx0XHRcdFx0aWYgKCEodHJhbnNpdGlvbi50YXJnZXQgaW5zdGFuY2VvZiBCbG9ja0VuZFN0YXRlKSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIE5vdFNldFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRcdC8vIFRPRE86IG5vdCB5ZXQgaW1wbGVtZW50ZWRcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBBdG9tVHJhbnNpdGlvblxyXG5cdFx0XHRcdFx0fHwgdHJhbnNpdGlvbiBpbnN0YW5jZW9mIFJhbmdlVHJhbnNpdGlvblxyXG5cdFx0XHRcdFx0fHwgdHJhbnNpdGlvbiBpbnN0YW5jZW9mIFNldFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRcdHNldFRyYW5zaXRpb25zLmFkZChpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChzZXRUcmFuc2l0aW9ucy5zaXplIDw9IDEpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IG9wdGltaXplZFRyYW5zaXRpb25zOiBUcmFuc2l0aW9uW10gPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkZWNpc2lvbi5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zOyBpKyspIHtcclxuXHRcdFx0XHRpZiAoIXNldFRyYW5zaXRpb25zLmNvbnRhaW5zKGkpKSB7XHJcblx0XHRcdFx0XHRvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKGRlY2lzaW9uLmdldE9wdGltaXplZFRyYW5zaXRpb24oaSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGJsb2NrRW5kU3RhdGU6IEFUTlN0YXRlID0gZGVjaXNpb24uZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihzZXRUcmFuc2l0aW9ucy5taW5FbGVtZW50KS50YXJnZXQuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbigwKS50YXJnZXQ7XHJcblx0XHRcdGxldCBtYXRjaFNldDogSW50ZXJ2YWxTZXQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdFx0Zm9yIChsZXQgaW50ZXJ2YWwgb2Ygc2V0VHJhbnNpdGlvbnMuaW50ZXJ2YWxzKSB7XHJcblx0XHRcdFx0Zm9yIChsZXQgaiA9IGludGVydmFsLmE7IGogPD0gaW50ZXJ2YWwuYjsgaisrKSB7XHJcblx0XHRcdFx0XHRsZXQgbWF0Y2hUcmFuc2l0aW9uOiBUcmFuc2l0aW9uID0gZGVjaXNpb24uZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihqKS50YXJnZXQuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbigwKTtcclxuXHRcdFx0XHRcdGlmIChtYXRjaFRyYW5zaXRpb24gaW5zdGFuY2VvZiBOb3RTZXRUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0bWF0Y2hTZXQuYWRkQWxsKG1hdGNoVHJhbnNpdGlvbi5sYWJlbCBhcyBJbnRlcnZhbFNldCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgbmV3VHJhbnNpdGlvbjogVHJhbnNpdGlvbjtcclxuXHRcdFx0aWYgKG1hdGNoU2V0LmludGVydmFscy5sZW5ndGggPT09IDEpIHtcclxuXHRcdFx0XHRpZiAobWF0Y2hTZXQuc2l6ZSA9PT0gMSkge1xyXG5cdFx0XHRcdFx0bmV3VHJhbnNpdGlvbiA9IG5ldyBBdG9tVHJhbnNpdGlvbihibG9ja0VuZFN0YXRlLCBtYXRjaFNldC5taW5FbGVtZW50KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bGV0IG1hdGNoSW50ZXJ2YWw6IEludGVydmFsID0gbWF0Y2hTZXQuaW50ZXJ2YWxzWzBdO1xyXG5cdFx0XHRcdFx0bmV3VHJhbnNpdGlvbiA9IG5ldyBSYW5nZVRyYW5zaXRpb24oYmxvY2tFbmRTdGF0ZSwgbWF0Y2hJbnRlcnZhbC5hLCBtYXRjaEludGVydmFsLmIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRuZXdUcmFuc2l0aW9uID0gbmV3IFNldFRyYW5zaXRpb24oYmxvY2tFbmRTdGF0ZSwgbWF0Y2hTZXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgc2V0T3B0aW1pemVkU3RhdGU6IEFUTlN0YXRlID0gbmV3IEJhc2ljU3RhdGUoKTtcclxuXHRcdFx0c2V0T3B0aW1pemVkU3RhdGUuc2V0UnVsZUluZGV4KGRlY2lzaW9uLnJ1bGVJbmRleCk7XHJcblx0XHRcdGF0bi5hZGRTdGF0ZShzZXRPcHRpbWl6ZWRTdGF0ZSk7XHJcblxyXG5cdFx0XHRzZXRPcHRpbWl6ZWRTdGF0ZS5hZGRUcmFuc2l0aW9uKG5ld1RyYW5zaXRpb24pO1xyXG5cdFx0XHRvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKG5ldyBFcHNpbG9uVHJhbnNpdGlvbihzZXRPcHRpbWl6ZWRTdGF0ZSkpO1xyXG5cclxuXHRcdFx0cmVtb3ZlZFBhdGhzICs9IGRlY2lzaW9uLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgLSBvcHRpbWl6ZWRUcmFuc2l0aW9ucy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoZGVjaXNpb24uaXNPcHRpbWl6ZWQpIHtcclxuXHRcdFx0XHR3aGlsZSAoZGVjaXNpb24ubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyA+IDApIHtcclxuXHRcdFx0XHRcdGRlY2lzaW9uLnJlbW92ZU9wdGltaXplZFRyYW5zaXRpb24oZGVjaXNpb24ubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyAtIDEpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yIChsZXQgdHJhbnNpdGlvbiBvZiBvcHRpbWl6ZWRUcmFuc2l0aW9ucykge1xyXG5cdFx0XHRcdGRlY2lzaW9uLmFkZE9wdGltaXplZFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiQVROIHJ1bnRpbWUgb3B0aW1pemVyIHJlbW92ZWQgXCIgKyByZW1vdmVkUGF0aHMgKyBcIiBwYXRocyBieSBjb2xsYXBzaW5nIHNldHMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZW1vdmVkUGF0aHM7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBpZGVudGlmeVRhaWxDYWxscyhhdG46IEFUTik6IHZvaWQge1xyXG5cdFx0Zm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xyXG5cdFx0XHRcdGxldCB0cmFuc2l0aW9uID0gc3RhdGUudHJhbnNpdGlvbihpKTtcclxuXHRcdFx0XHRpZiAoISh0cmFuc2l0aW9uIGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb24pKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyYW5zaXRpb24udGFpbENhbGwgPSB0aGlzLnRlc3RUYWlsQ2FsbChhdG4sIHRyYW5zaXRpb24sIGZhbHNlKTtcclxuXHRcdFx0XHR0cmFuc2l0aW9uLm9wdGltaXplZFRhaWxDYWxsID0gdGhpcy50ZXN0VGFpbENhbGwoYXRuLCB0cmFuc2l0aW9uLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFzdGF0ZS5pc09wdGltaXplZCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnM7IGkrKykge1xyXG5cdFx0XHRcdGxldCB0cmFuc2l0aW9uID0gc3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihpKTtcclxuXHRcdFx0XHRpZiAoISh0cmFuc2l0aW9uIGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb24pKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyYW5zaXRpb24udGFpbENhbGwgPSB0aGlzLnRlc3RUYWlsQ2FsbChhdG4sIHRyYW5zaXRpb24sIGZhbHNlKTtcclxuXHRcdFx0XHR0cmFuc2l0aW9uLm9wdGltaXplZFRhaWxDYWxsID0gdGhpcy50ZXN0VGFpbENhbGwoYXRuLCB0cmFuc2l0aW9uLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgdGVzdFRhaWxDYWxsKGF0bjogQVROLCB0cmFuc2l0aW9uOiBSdWxlVHJhbnNpdGlvbiwgb3B0aW1pemVkUGF0aDogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKCFvcHRpbWl6ZWRQYXRoICYmIHRyYW5zaXRpb24udGFpbENhbGwpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHRpZiAob3B0aW1pemVkUGF0aCAmJiB0cmFuc2l0aW9uLm9wdGltaXplZFRhaWxDYWxsKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZWFjaGFibGU6IEJpdFNldCA9IG5ldyBCaXRTZXQoYXRuLnN0YXRlcy5sZW5ndGgpO1xyXG5cdFx0bGV0IHdvcmtsaXN0OiBBVE5TdGF0ZVtdID0gW107XHJcblx0XHR3b3JrbGlzdC5wdXNoKHRyYW5zaXRpb24uZm9sbG93U3RhdGUpO1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0bGV0IHN0YXRlID0gd29ya2xpc3QucG9wKCk7XHJcblx0XHRcdGlmICghc3RhdGUpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHJlYWNoYWJsZS5nZXQoc3RhdGUuc3RhdGVOdW1iZXIpKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChzdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFzdGF0ZS5vbmx5SGFzRXBzaWxvblRyYW5zaXRpb25zKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgdHJhbnNpdGlvbkNvdW50ID0gb3B0aW1pemVkUGF0aCA/IHN0YXRlLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgOiBzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zO1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zaXRpb25Db3VudDsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IHQgPSBvcHRpbWl6ZWRQYXRoID8gc3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihpKSA6IHN0YXRlLnRyYW5zaXRpb24oaSk7XHJcblx0XHRcdFx0aWYgKHQuc2VyaWFsaXphdGlvblR5cGUgIT09IFRyYW5zaXRpb25UeXBlLkVQU0lMT04pIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHdvcmtsaXN0LnB1c2godC50YXJnZXQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgc3RhdGljIHRvSW50KGM6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gYztcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBzdGF0aWMgdG9JbnQzMihkYXRhOiBVaW50MTZBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIChkYXRhW29mZnNldF0gfCAoZGF0YVtvZmZzZXQgKyAxXSA8PCAxNikpID4+PiAwO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHN0YXRpYyB0b1VVSUQoZGF0YTogVWludDE2QXJyYXksIG9mZnNldDogbnVtYmVyKTogVVVJRCB7XHJcblx0XHRsZXQgbGVhc3RTaWdCaXRzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQzMihkYXRhLCBvZmZzZXQpO1xyXG5cdFx0bGV0IGxlc3NTaWdCaXRzOiBudW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIudG9JbnQzMihkYXRhLCBvZmZzZXQgKyAyKTtcclxuXHRcdGxldCBtb3JlU2lnQml0czogbnVtYmVyID0gQVRORGVzZXJpYWxpemVyLnRvSW50MzIoZGF0YSwgb2Zmc2V0ICsgNCk7XHJcblx0XHRsZXQgbW9zdFNpZ0JpdHM6IG51bWJlciA9IEFUTkRlc2VyaWFsaXplci50b0ludDMyKGRhdGEsIG9mZnNldCArIDYpO1xyXG5cdFx0cmV0dXJuIG5ldyBVVUlEKG1vc3RTaWdCaXRzLCBtb3JlU2lnQml0cywgbGVzc1NpZ0JpdHMsIGxlYXN0U2lnQml0cyk7XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBlZGdlRmFjdG9yeShcclxuXHRcdEBOb3ROdWxsIGF0bjogQVROLFxyXG5cdFx0dHlwZTogVHJhbnNpdGlvblR5cGUsIHNyYzogbnVtYmVyLCB0cmc6IG51bWJlcixcclxuXHRcdGFyZzE6IG51bWJlciwgYXJnMjogbnVtYmVyLCBhcmczOiBudW1iZXIsXHJcblx0XHRzZXRzOiBJbnRlcnZhbFNldFtdKTogVHJhbnNpdGlvbiB7XHJcblx0XHRsZXQgdGFyZ2V0OiBBVE5TdGF0ZSA9IGF0bi5zdGF0ZXNbdHJnXTtcclxuXHRcdHN3aXRjaCAodHlwZSkge1xyXG5cdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLkVQU0lMT046IHJldHVybiBuZXcgRXBzaWxvblRyYW5zaXRpb24odGFyZ2V0KTtcclxuXHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5SQU5HRTpcclxuXHRcdFx0XHRpZiAoYXJnMyAhPT0gMCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBSYW5nZVRyYW5zaXRpb24odGFyZ2V0LCBUb2tlbi5FT0YsIGFyZzIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgUmFuZ2VUcmFuc2l0aW9uKHRhcmdldCwgYXJnMSwgYXJnMik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlJVTEU6XHJcblx0XHRcdFx0bGV0IHJ0OiBSdWxlVHJhbnNpdGlvbiA9IG5ldyBSdWxlVHJhbnNpdGlvbihhdG4uc3RhdGVzW2FyZzFdIGFzIFJ1bGVTdGFydFN0YXRlLCBhcmcyLCBhcmczLCB0YXJnZXQpO1xyXG5cdFx0XHRcdHJldHVybiBydDtcclxuXHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5QUkVESUNBVEU6XHJcblx0XHRcdFx0bGV0IHB0OiBQcmVkaWNhdGVUcmFuc2l0aW9uID0gbmV3IFByZWRpY2F0ZVRyYW5zaXRpb24odGFyZ2V0LCBhcmcxLCBhcmcyLCBhcmczICE9PSAwKTtcclxuXHRcdFx0XHRyZXR1cm4gcHQ7XHJcblx0XHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUFJFQ0VERU5DRTpcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uKHRhcmdldCwgYXJnMSk7XHJcblx0XHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuQVRPTTpcclxuXHRcdFx0XHRpZiAoYXJnMyAhPT0gMCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBBdG9tVHJhbnNpdGlvbih0YXJnZXQsIFRva2VuLkVPRik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBBdG9tVHJhbnNpdGlvbih0YXJnZXQsIGFyZzEpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5BQ1RJT046XHJcblx0XHRcdFx0bGV0IGE6IEFjdGlvblRyYW5zaXRpb24gPSBuZXcgQWN0aW9uVHJhbnNpdGlvbih0YXJnZXQsIGFyZzEsIGFyZzIsIGFyZzMgIT09IDApO1xyXG5cdFx0XHRcdHJldHVybiBhO1xyXG5cdFx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlNFVDogcmV0dXJuIG5ldyBTZXRUcmFuc2l0aW9uKHRhcmdldCwgc2V0c1thcmcxXSk7XHJcblx0XHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuTk9UX1NFVDogcmV0dXJuIG5ldyBOb3RTZXRUcmFuc2l0aW9uKHRhcmdldCwgc2V0c1thcmcxXSk7XHJcblx0XHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuV0lMRENBUkQ6IHJldHVybiBuZXcgV2lsZGNhcmRUcmFuc2l0aW9uKHRhcmdldCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHNwZWNpZmllZCB0cmFuc2l0aW9uIHR5cGUgaXMgbm90IHZhbGlkLlwiKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBzdGF0ZUZhY3RvcnkodHlwZTogQVROU3RhdGVUeXBlLCBydWxlSW5kZXg6IG51bWJlcik6IEFUTlN0YXRlIHtcclxuXHRcdGxldCBzOiBBVE5TdGF0ZTtcclxuXHRcdHN3aXRjaCAodHlwZSkge1xyXG5cdFx0XHRjYXNlIEFUTlN0YXRlVHlwZS5JTlZBTElEX1RZUEU6IHJldHVybiBuZXcgSW52YWxpZFN0YXRlKCk7XHJcblx0XHRcdGNhc2UgQVROU3RhdGVUeXBlLkJBU0lDOiBzID0gbmV3IEJhc2ljU3RhdGUoKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgQVROU3RhdGVUeXBlLlJVTEVfU1RBUlQ6IHMgPSBuZXcgUnVsZVN0YXJ0U3RhdGUoKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgQVROU3RhdGVUeXBlLkJMT0NLX1NUQVJUOiBzID0gbmV3IEJhc2ljQmxvY2tTdGFydFN0YXRlKCk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIEFUTlN0YXRlVHlwZS5QTFVTX0JMT0NLX1NUQVJUOiBzID0gbmV3IFBsdXNCbG9ja1N0YXJ0U3RhdGUoKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgQVROU3RhdGVUeXBlLlNUQVJfQkxPQ0tfU1RBUlQ6IHMgPSBuZXcgU3RhckJsb2NrU3RhcnRTdGF0ZSgpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBBVE5TdGF0ZVR5cGUuVE9LRU5fU1RBUlQ6IHMgPSBuZXcgVG9rZW5zU3RhcnRTdGF0ZSgpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBBVE5TdGF0ZVR5cGUuUlVMRV9TVE9QOiBzID0gbmV3IFJ1bGVTdG9wU3RhdGUoKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgQVROU3RhdGVUeXBlLkJMT0NLX0VORDogcyA9IG5ldyBCbG9ja0VuZFN0YXRlKCk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIEFUTlN0YXRlVHlwZS5TVEFSX0xPT1BfQkFDSzogcyA9IG5ldyBTdGFyTG9vcGJhY2tTdGF0ZSgpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBBVE5TdGF0ZVR5cGUuU1RBUl9MT09QX0VOVFJZOiBzID0gbmV3IFN0YXJMb29wRW50cnlTdGF0ZSgpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBBVE5TdGF0ZVR5cGUuUExVU19MT09QX0JBQ0s6IHMgPSBuZXcgUGx1c0xvb3BiYWNrU3RhdGUoKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgQVROU3RhdGVUeXBlLkxPT1BfRU5EOiBzID0gbmV3IExvb3BFbmRTdGF0ZSgpOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRsZXQgbWVzc2FnZTogc3RyaW5nID0gYFRoZSBzcGVjaWZpZWQgc3RhdGUgdHlwZSAke3R5cGV9IGlzIG5vdCB2YWxpZC5gO1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuXHRcdH1cclxuXHJcblx0XHRzLnJ1bGVJbmRleCA9IHJ1bGVJbmRleDtcclxuXHRcdHJldHVybiBzO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGxleGVyQWN0aW9uRmFjdG9yeSh0eXBlOiBMZXhlckFjdGlvblR5cGUsIGRhdGExOiBudW1iZXIsIGRhdGEyOiBudW1iZXIpOiBMZXhlckFjdGlvbiB7XHJcblx0XHRzd2l0Y2ggKHR5cGUpIHtcclxuXHRcdGNhc2UgTGV4ZXJBY3Rpb25UeXBlLkNIQU5ORUw6XHJcblx0XHRcdHJldHVybiBuZXcgTGV4ZXJDaGFubmVsQWN0aW9uKGRhdGExKTtcclxuXHJcblx0XHRjYXNlIExleGVyQWN0aW9uVHlwZS5DVVNUT006XHJcblx0XHRcdHJldHVybiBuZXcgTGV4ZXJDdXN0b21BY3Rpb24oZGF0YTEsIGRhdGEyKTtcclxuXHJcblx0XHRjYXNlIExleGVyQWN0aW9uVHlwZS5NT0RFOlxyXG5cdFx0XHRyZXR1cm4gbmV3IExleGVyTW9kZUFjdGlvbihkYXRhMSk7XHJcblxyXG5cdFx0Y2FzZSBMZXhlckFjdGlvblR5cGUuTU9SRTpcclxuXHRcdFx0cmV0dXJuIExleGVyTW9yZUFjdGlvbi5JTlNUQU5DRTtcclxuXHJcblx0XHRjYXNlIExleGVyQWN0aW9uVHlwZS5QT1BfTU9ERTpcclxuXHRcdFx0cmV0dXJuIExleGVyUG9wTW9kZUFjdGlvbi5JTlNUQU5DRTtcclxuXHJcblx0XHRjYXNlIExleGVyQWN0aW9uVHlwZS5QVVNIX01PREU6XHJcblx0XHRcdHJldHVybiBuZXcgTGV4ZXJQdXNoTW9kZUFjdGlvbihkYXRhMSk7XHJcblxyXG5cdFx0Y2FzZSBMZXhlckFjdGlvblR5cGUuU0tJUDpcclxuXHRcdFx0cmV0dXJuIExleGVyU2tpcEFjdGlvbi5JTlNUQU5DRTtcclxuXHJcblx0XHRjYXNlIExleGVyQWN0aW9uVHlwZS5UWVBFOlxyXG5cdFx0XHRyZXR1cm4gbmV3IExleGVyVHlwZUFjdGlvbihkYXRhMSk7XHJcblxyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0bGV0IG1lc3NhZ2U6IHN0cmluZyA9IGBUaGUgc3BlY2lmaWVkIGxleGVyIGFjdGlvbiB0eXBlICR7dHlwZX0gaXMgbm90IHZhbGlkLmA7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjMxLjAzNDk2MDUtMDc6MDBcclxuXHJcbmltcG9ydCB7IERlY2lzaW9uSW5mbyB9IGZyb20gXCIuL0RlY2lzaW9uSW5mb1wiO1xyXG5pbXBvcnQgeyBERkEgfSBmcm9tIFwiLi4vZGZhL0RGQVwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUHJvZmlsaW5nQVROU2ltdWxhdG9yIH0gZnJvbSBcIi4vUHJvZmlsaW5nQVROU2ltdWxhdG9yXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBhY2Nlc3MgdG8gc3BlY2lmaWMgYW5kIGFnZ3JlZ2F0ZSBzdGF0aXN0aWNzIGdhdGhlcmVkXHJcbiAqIGR1cmluZyBwcm9maWxpbmcgb2YgYSBwYXJzZXIuXHJcbiAqXHJcbiAqIEBzaW5jZSA0LjNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBQYXJzZUluZm8ge1xyXG5cdHByb3RlY3RlZCBhdG5TaW11bGF0b3I6IFByb2ZpbGluZ0FUTlNpbXVsYXRvcjtcclxuXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgYXRuU2ltdWxhdG9yOiBQcm9maWxpbmdBVE5TaW11bGF0b3IpIHtcclxuXHRcdHRoaXMuYXRuU2ltdWxhdG9yID0gYXRuU2ltdWxhdG9yO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyBhbiBhcnJheSBvZiB7QGxpbmsgRGVjaXNpb25JbmZvfSBpbnN0YW5jZXMgY29udGFpbmluZyB0aGUgcHJvZmlsaW5nXHJcblx0ICogaW5mb3JtYXRpb24gZ2F0aGVyZWQgZm9yIGVhY2ggZGVjaXNpb24gaW4gdGhlIEFUTi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHtAbGluayBEZWNpc2lvbkluZm99IGluc3RhbmNlcywgaW5kZXhlZCBieSBkZWNpc2lvblxyXG5cdCAqIG51bWJlci5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXREZWNpc2lvbkluZm8oKTogRGVjaXNpb25JbmZvW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuYXRuU2ltdWxhdG9yLmdldERlY2lzaW9uSW5mbygpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgZGVjaXNpb24gbnVtYmVycyBmb3IgZGVjaXNpb25zIHRoYXQgcmVxdWlyZWQgb25lIG9yIG1vcmVcclxuXHQgKiBmdWxsLWNvbnRleHQgcHJlZGljdGlvbnMgZHVyaW5nIHBhcnNpbmcuIFRoZXNlIGFyZSBkZWNpc2lvbnMgZm9yIHdoaWNoXHJcblx0ICoge0BsaW5rIERlY2lzaW9uSW5mbyNMTF9GYWxsYmFja30gaXMgbm9uLXplcm8uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBBIGxpc3Qgb2YgZGVjaXNpb24gbnVtYmVycyB3aGljaCByZXF1aXJlZCBvbmUgb3IgbW9yZVxyXG5cdCAqIGZ1bGwtY29udGV4dCBwcmVkaWN0aW9ucyBkdXJpbmcgcGFyc2luZy5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRMTERlY2lzaW9ucygpOiBudW1iZXJbXSB7XHJcblx0XHRsZXQgZGVjaXNpb25zOiBEZWNpc2lvbkluZm9bXSA9IHRoaXMuYXRuU2ltdWxhdG9yLmdldERlY2lzaW9uSW5mbygpO1xyXG5cdFx0bGV0IExMOiBudW1iZXJbXSA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkZWNpc2lvbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGZhbGxCYWNrOiBudW1iZXIgPSBkZWNpc2lvbnNbaV0uTExfRmFsbGJhY2s7XHJcblx0XHRcdGlmIChmYWxsQmFjayA+IDApIHtcclxuXHRcdFx0XHRMTC5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIExMO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgdG90YWwgdGltZSBzcGVudCBkdXJpbmcgcHJlZGljdGlvbiBhY3Jvc3MgYWxsIGRlY2lzaW9ucyBtYWRlXHJcblx0ICogZHVyaW5nIHBhcnNpbmcuIFRoaXMgdmFsdWUgaXMgdGhlIHN1bSBvZlxyXG5cdCAqIHtAbGluayBEZWNpc2lvbkluZm8jdGltZUluUHJlZGljdGlvbn0gZm9yIGFsbCBkZWNpc2lvbnMuXHJcblx0ICovXHJcblx0cHVibGljIGdldFRvdGFsVGltZUluUHJlZGljdGlvbigpOiBudW1iZXIge1xyXG5cdFx0bGV0IGRlY2lzaW9uczogRGVjaXNpb25JbmZvW10gPSB0aGlzLmF0blNpbXVsYXRvci5nZXREZWNpc2lvbkluZm8oKTtcclxuXHRcdGxldCB0OiBudW1iZXIgPSAwO1xyXG5cdFx0Zm9yIChsZXQgZGVjaXNpb24gb2YgZGVjaXNpb25zKSB7XHJcblx0XHRcdHQgKz0gZGVjaXNpb24udGltZUluUHJlZGljdGlvbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBTTEwgbG9va2FoZWFkIG9wZXJhdGlvbnMgYWNyb3NzIGFsbCBkZWNpc2lvbnNcclxuXHQgKiBtYWRlIGR1cmluZyBwYXJzaW5nLiBUaGlzIHZhbHVlIGlzIHRoZSBzdW0gb2ZcclxuXHQgKiB7QGxpbmsgRGVjaXNpb25JbmZvI1NMTF9Ub3RhbExvb2t9IGZvciBhbGwgZGVjaXNpb25zLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRUb3RhbFNMTExvb2thaGVhZE9wcygpOiBudW1iZXIge1xyXG5cdFx0bGV0IGRlY2lzaW9uczogRGVjaXNpb25JbmZvW10gPSB0aGlzLmF0blNpbXVsYXRvci5nZXREZWNpc2lvbkluZm8oKTtcclxuXHRcdGxldCBrOiBudW1iZXIgPSAwO1xyXG5cdFx0Zm9yIChsZXQgZGVjaXNpb24gb2YgZGVjaXNpb25zKSB7XHJcblx0XHRcdGsgKz0gZGVjaXNpb24uU0xMX1RvdGFsTG9vaztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBMTCBsb29rYWhlYWQgb3BlcmF0aW9ucyBhY3Jvc3MgYWxsIGRlY2lzaW9uc1xyXG5cdCAqIG1hZGUgZHVyaW5nIHBhcnNpbmcuIFRoaXMgdmFsdWUgaXMgdGhlIHN1bSBvZlxyXG5cdCAqIHtAbGluayBEZWNpc2lvbkluZm8jTExfVG90YWxMb29rfSBmb3IgYWxsIGRlY2lzaW9ucy5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0VG90YWxMTExvb2thaGVhZE9wcygpOiBudW1iZXIge1xyXG5cdFx0bGV0IGRlY2lzaW9uczogRGVjaXNpb25JbmZvW10gPSB0aGlzLmF0blNpbXVsYXRvci5nZXREZWNpc2lvbkluZm8oKTtcclxuXHRcdGxldCBrOiBudW1iZXIgPSAwO1xyXG5cdFx0Zm9yIChsZXQgZGVjaXNpb24gb2YgZGVjaXNpb25zKSB7XHJcblx0XHRcdGsgKz0gZGVjaXNpb24uTExfVG90YWxMb29rO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBrO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIEFUTiBsb29rYWhlYWQgb3BlcmF0aW9ucyBmb3IgU0xMIHByZWRpY3Rpb25cclxuXHQgKiBhY3Jvc3MgYWxsIGRlY2lzaW9ucyBtYWRlIGR1cmluZyBwYXJzaW5nLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRUb3RhbFNMTEFUTkxvb2thaGVhZE9wcygpOiBudW1iZXIge1xyXG5cdFx0bGV0IGRlY2lzaW9uczogRGVjaXNpb25JbmZvW10gPSB0aGlzLmF0blNpbXVsYXRvci5nZXREZWNpc2lvbkluZm8oKTtcclxuXHRcdGxldCBrOiBudW1iZXIgPSAwO1xyXG5cdFx0Zm9yIChsZXQgZGVjaXNpb24gb2YgZGVjaXNpb25zKSB7XHJcblx0XHRcdGsgKz0gZGVjaXNpb24uU0xMX0FUTlRyYW5zaXRpb25zO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBrO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIEFUTiBsb29rYWhlYWQgb3BlcmF0aW9ucyBmb3IgTEwgcHJlZGljdGlvblxyXG5cdCAqIGFjcm9zcyBhbGwgZGVjaXNpb25zIG1hZGUgZHVyaW5nIHBhcnNpbmcuXHJcblx0ICovXHJcblx0cHVibGljIGdldFRvdGFsTExBVE5Mb29rYWhlYWRPcHMoKTogbnVtYmVyIHtcclxuXHRcdGxldCBkZWNpc2lvbnM6IERlY2lzaW9uSW5mb1tdID0gdGhpcy5hdG5TaW11bGF0b3IuZ2V0RGVjaXNpb25JbmZvKCk7XHJcblx0XHRsZXQgazogbnVtYmVyID0gMDtcclxuXHRcdGZvciAobGV0IGRlY2lzaW9uIG9mIGRlY2lzaW9ucykge1xyXG5cdFx0XHRrICs9IGRlY2lzaW9uLkxMX0FUTlRyYW5zaXRpb25zO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBrO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIEFUTiBsb29rYWhlYWQgb3BlcmF0aW9ucyBmb3IgU0xMIGFuZCBMTFxyXG5cdCAqIHByZWRpY3Rpb24gYWNyb3NzIGFsbCBkZWNpc2lvbnMgbWFkZSBkdXJpbmcgcGFyc2luZy5cclxuXHQgKlxyXG5cdCAqIFRoaXMgdmFsdWUgaXMgdGhlIHN1bSBvZiB7QGxpbmsgI2dldFRvdGFsU0xMQVROTG9va2FoZWFkT3BzfSBhbmRcclxuXHQgKiB7QGxpbmsgI2dldFRvdGFsTExBVE5Mb29rYWhlYWRPcHN9LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRUb3RhbEFUTkxvb2thaGVhZE9wcygpOiBudW1iZXIge1xyXG5cdFx0bGV0IGRlY2lzaW9uczogRGVjaXNpb25JbmZvW10gPSB0aGlzLmF0blNpbXVsYXRvci5nZXREZWNpc2lvbkluZm8oKTtcclxuXHRcdGxldCBrOiBudW1iZXIgPSAwO1xyXG5cdFx0Zm9yIChsZXQgZGVjaXNpb24gb2YgZGVjaXNpb25zKSB7XHJcblx0XHRcdGsgKz0gZGVjaXNpb24uU0xMX0FUTlRyYW5zaXRpb25zO1xyXG5cdFx0XHRrICs9IGRlY2lzaW9uLkxMX0FUTlRyYW5zaXRpb25zO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBrO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIERGQSBzdGF0ZXMgc3RvcmVkIGluIHRoZSBERkEgY2FjaGUgZm9yIGFsbFxyXG5cdCAqIGRlY2lzaW9ucyBpbiB0aGUgQVROLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRERkFTaXplKCk6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIERGQSBzdGF0ZXMgc3RvcmVkIGluIHRoZSBERkEgY2FjaGUgZm9yIGFcclxuXHQgKiBwYXJ0aWN1bGFyIGRlY2lzaW9uLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRERkFTaXplKGRlY2lzaW9uOiBudW1iZXIpOiBudW1iZXI7XHJcblxyXG5cdHB1YmxpYyBnZXRERkFTaXplKGRlY2lzaW9uPzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGlmIChkZWNpc2lvbikge1xyXG5cdFx0XHRsZXQgZGVjaXNpb25Ub0RGQTogREZBID0gdGhpcy5hdG5TaW11bGF0b3IuYXRuLmRlY2lzaW9uVG9ERkFbZGVjaXNpb25dO1xyXG5cdFx0XHRyZXR1cm4gZGVjaXNpb25Ub0RGQS5zdGF0ZXMuc2l6ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBuOiBudW1iZXIgPSAwO1xyXG5cdFx0XHRsZXQgZGVjaXNpb25Ub0RGQTogREZBW10gPSB0aGlzLmF0blNpbXVsYXRvci5hdG4uZGVjaXNpb25Ub0RGQTtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkZWNpc2lvblRvREZBLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0biArPSB0aGlzLmdldERGQVNpemUoaSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBuO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTYuOTgxMjI4NC0wNzowMFxyXG5pbXBvcnQgeyBBTlRMUkVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi9BTlRMUkVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgQVROQ29uZmlnU2V0IH0gZnJvbSBcIi4vYXRuL0FUTkNvbmZpZ1NldFwiO1xyXG5pbXBvcnQgeyBCaXRTZXQgfSBmcm9tIFwiLi9taXNjL0JpdFNldFwiO1xyXG5pbXBvcnQgeyBERkEgfSBmcm9tIFwiLi9kZmEvREZBXCI7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFByb3h5RXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL1Byb3h5RXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJFcnJvckxpc3RlbmVyIH0gZnJvbSBcIi4vUGFyc2VyRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBTaW11bGF0b3JTdGF0ZSB9IGZyb20gXCIuL2F0bi9TaW11bGF0b3JTdGF0ZVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcm94eVBhcnNlckVycm9yTGlzdGVuZXIgZXh0ZW5kcyBQcm94eUVycm9yTGlzdGVuZXI8VG9rZW4sIFBhcnNlckVycm9yTGlzdGVuZXI+XHJcblx0aW1wbGVtZW50cyBQYXJzZXJFcnJvckxpc3RlbmVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoZGVsZWdhdGVzOiBQYXJzZXJFcnJvckxpc3RlbmVyW10pIHtcclxuXHRcdHN1cGVyKGRlbGVnYXRlcyk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVwb3J0QW1iaWd1aXR5KFxyXG5cdFx0cmVjb2duaXplcjogUGFyc2VyLFxyXG5cdFx0ZGZhOiBERkEsXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcixcclxuXHRcdGV4YWN0OiBib29sZWFuLFxyXG5cdFx0YW1iaWdBbHRzOiBCaXRTZXQgfCB1bmRlZmluZWQsXHJcblx0XHRjb25maWdzOiBBVE5Db25maWdTZXQpOiB2b2lkIHtcclxuXHRcdHRoaXMuZ2V0RGVsZWdhdGVzKClcclxuXHRcdFx0LmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XHJcblx0XHRcdFx0aWYgKGxpc3RlbmVyLnJlcG9ydEFtYmlndWl0eSkge1xyXG5cdFx0XHRcdFx0bGlzdGVuZXIucmVwb3J0QW1iaWd1aXR5KFxyXG5cdFx0XHRcdFx0XHRyZWNvZ25pemVyLFxyXG5cdFx0XHRcdFx0XHRkZmEsXHJcblx0XHRcdFx0XHRcdHN0YXJ0SW5kZXgsXHJcblx0XHRcdFx0XHRcdHN0b3BJbmRleCxcclxuXHRcdFx0XHRcdFx0ZXhhY3QsXHJcblx0XHRcdFx0XHRcdGFtYmlnQWx0cyxcclxuXHRcdFx0XHRcdFx0Y29uZmlncyk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KFxyXG5cdFx0cmVjb2duaXplcjogUGFyc2VyLFxyXG5cdFx0ZGZhOiBERkEsXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcixcclxuXHRcdGNvbmZsaWN0aW5nQWx0czogQml0U2V0IHwgdW5kZWZpbmVkLFxyXG5cdFx0Y29uZmxpY3RTdGF0ZTogU2ltdWxhdG9yU3RhdGUpOiB2b2lkIHtcclxuXHRcdHRoaXMuZ2V0RGVsZWdhdGVzKClcclxuXHRcdFx0LmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XHJcblx0XHRcdFx0aWYgKGxpc3RlbmVyLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCkge1xyXG5cdFx0XHRcdFx0bGlzdGVuZXIucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KFxyXG5cdFx0XHRcdFx0XHRyZWNvZ25pemVyLFxyXG5cdFx0XHRcdFx0XHRkZmEsXHJcblx0XHRcdFx0XHRcdHN0YXJ0SW5kZXgsXHJcblx0XHRcdFx0XHRcdHN0b3BJbmRleCxcclxuXHRcdFx0XHRcdFx0Y29uZmxpY3RpbmdBbHRzLFxyXG5cdFx0XHRcdFx0XHRjb25mbGljdFN0YXRlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlcG9ydENvbnRleHRTZW5zaXRpdml0eShcclxuXHRcdHJlY29nbml6ZXI6IFBhcnNlcixcclxuXHRcdGRmYTogREZBLFxyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyLFxyXG5cdFx0c3RvcEluZGV4OiBudW1iZXIsXHJcblx0XHRwcmVkaWN0aW9uOiBudW1iZXIsXHJcblx0XHRhY2NlcHRTdGF0ZTogU2ltdWxhdG9yU3RhdGUpOiB2b2lkIHtcclxuXHRcdHRoaXMuZ2V0RGVsZWdhdGVzKClcclxuXHRcdFx0LmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XHJcblx0XHRcdFx0aWYgKGxpc3RlbmVyLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eSkge1xyXG5cdFx0XHRcdFx0bGlzdGVuZXIucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KFxyXG5cdFx0XHRcdFx0XHRyZWNvZ25pemVyLFxyXG5cdFx0XHRcdFx0XHRkZmEsXHJcblx0XHRcdFx0XHRcdHN0YXJ0SW5kZXgsXHJcblx0XHRcdFx0XHRcdHN0b3BJbmRleCxcclxuXHRcdFx0XHRcdFx0cHJlZGljdGlvbixcclxuXHRcdFx0XHRcdFx0YWNjZXB0U3RhdGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0hpZ2hTdXJyb2dhdGUoY2g6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdHJldHVybiBjaCA+PSAweEQ4MDAgJiYgY2ggPD0gMHhEQkZGO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNMb3dTdXJyb2dhdGUoY2g6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdHJldHVybiBjaCA+PSAweERDMDAgJiYgY2ggPD0gMHhERkZGO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNTdXBwbGVtZW50YXJ5Q29kZVBvaW50KGNoOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRyZXR1cm4gY2ggPj0gMHgxMDAwMDtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xyXG5pbXBvcnQgKiBhcyBDaGFyYWN0ZXIgZnJvbSBcIi4vbWlzYy9DaGFyYWN0ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcGVyIGZvciBgVWludDhBcnJheWAgLyBgVWludDE2QXJyYXlgIC8gYEludDMyQXJyYXlgLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvZGVQb2ludEJ1ZmZlciB7XHJcblx0cHJpdmF0ZSByZWFkb25seSBidWZmZXI6IFVpbnQ4QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDMyQXJyYXk7XHJcblx0cHJpdmF0ZSBfcG9zaXRpb246IG51bWJlcjtcclxuXHRwcml2YXRlIF9zaXplOiBudW1iZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGJ1ZmZlcjogVWludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MzJBcnJheSwgc2l6ZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuXHRcdHRoaXMuX3Bvc2l0aW9uID0gMDtcclxuXHRcdHRoaXMuX3NpemUgPSBzaXplO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHN0YXRpYyB3aXRoQXJyYXkoYnVmZmVyOiBVaW50OEFycmF5IHwgVWludDE2QXJyYXkgfCBJbnQzMkFycmF5KTogQ29kZVBvaW50QnVmZmVyIHtcclxuXHRcdHJldHVybiBuZXcgQ29kZVBvaW50QnVmZmVyKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0IHBvc2l0aW9uKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcG9zaXRpb247XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0IHBvc2l0aW9uKG5ld1Bvc2l0aW9uOiBudW1iZXIpIHtcclxuXHRcdGlmIChuZXdQb3NpdGlvbiA8IDAgfHwgbmV3UG9zaXRpb24gPiB0aGlzLl9zaXplKSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXQgcmVtYWluaW5nKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSAtIHRoaXMucG9zaXRpb247XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0KG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmJ1ZmZlcltvZmZzZXRdO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFycmF5KCk6IFVpbnQ4QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMuX3NpemUpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHN0YXRpYyBidWlsZGVyKGluaXRpYWxCdWZmZXJTaXplOiBudW1iZXIpOiBDb2RlUG9pbnRCdWZmZXIuQnVpbGRlciB7XHJcblx0XHRyZXR1cm4gbmV3IENvZGVQb2ludEJ1ZmZlci5CdWlsZGVyKGluaXRpYWxCdWZmZXJTaXplKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgQ29kZVBvaW50QnVmZmVyIHtcclxuXHRjb25zdCBlbnVtIFR5cGUge1xyXG5cdFx0QllURSxcclxuXHRcdENIQVIsXHJcblx0XHRJTlQsXHJcblx0fVxyXG5cclxuXHRleHBvcnQgY2xhc3MgQnVpbGRlciB7XHJcblx0XHRwcml2YXRlIHR5cGU6IFR5cGU7XHJcblx0XHRwcml2YXRlIGJ1ZmZlcjogVWludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MzJBcnJheTtcclxuXHRcdHByaXZhdGUgcHJldkhpZ2hTdXJyb2dhdGU6IG51bWJlcjtcclxuXHRcdHByaXZhdGUgcG9zaXRpb246IG51bWJlcjtcclxuXHJcblx0XHRjb25zdHJ1Y3Rvcihpbml0aWFsQnVmZmVyU2l6ZTogbnVtYmVyKSB7XHJcblx0XHRcdHRoaXMudHlwZSA9IFR5cGUuQllURTtcclxuXHRcdFx0dGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShpbml0aWFsQnVmZmVyU2l6ZSk7XHJcblx0XHRcdHRoaXMucHJldkhpZ2hTdXJyb2dhdGUgPSAtMTtcclxuXHRcdFx0dGhpcy5wb3NpdGlvbiA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cHVibGljIGJ1aWxkKCk6IENvZGVQb2ludEJ1ZmZlciB7XHJcblx0XHRcdHJldHVybiBuZXcgQ29kZVBvaW50QnVmZmVyKHRoaXMuYnVmZmVyLCB0aGlzLnBvc2l0aW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHRwcml2YXRlIHN0YXRpYyByb3VuZFVwVG9OZXh0UG93ZXJPZlR3byhpOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0XHRsZXQgbmV4dFBvd2VyT2ZUd286IG51bWJlciA9IDMyIC0gTWF0aC5jbHozMihpIC0gMSk7XHJcblx0XHRcdHJldHVybiBNYXRoLnBvdygyLCBuZXh0UG93ZXJPZlR3byk7XHJcblx0XHR9XHJcblxyXG5cdFx0cHVibGljIGVuc3VyZVJlbWFpbmluZyhyZW1haW5pbmdOZWVkZWQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0XHRzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG5cdFx0XHRcdGNhc2UgVHlwZS5CWVRFOlxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuYnVmZmVyLmxlbmd0aCAtIHRoaXMucG9zaXRpb24gPCByZW1haW5pbmdOZWVkZWQpIHtcclxuXHRcdFx0XHRcdFx0bGV0IG5ld0NhcGFjaXR5OiBudW1iZXIgPSBCdWlsZGVyLnJvdW5kVXBUb05leHRQb3dlck9mVHdvKHRoaXMuYnVmZmVyLmxlbmd0aCArIHJlbWFpbmluZ05lZWRlZCk7XHJcblx0XHRcdFx0XHRcdGxldCBuZXdCdWZmZXI6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShuZXdDYXBhY2l0eSk7XHJcblx0XHRcdFx0XHRcdG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbiksIDApO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmJ1ZmZlciA9IG5ld0J1ZmZlcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgVHlwZS5DSEFSOlxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuYnVmZmVyLmxlbmd0aCAtIHRoaXMucG9zaXRpb24gPCByZW1haW5pbmdOZWVkZWQpIHtcclxuXHRcdFx0XHRcdFx0bGV0IG5ld0NhcGFjaXR5OiBudW1iZXIgPSBCdWlsZGVyLnJvdW5kVXBUb05leHRQb3dlck9mVHdvKHRoaXMuYnVmZmVyLmxlbmd0aCArIHJlbWFpbmluZ05lZWRlZCk7XHJcblx0XHRcdFx0XHRcdGxldCBuZXdCdWZmZXI6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KG5ld0NhcGFjaXR5KTtcclxuXHRcdFx0XHRcdFx0bmV3QnVmZmVyLnNldCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSwgMCk7XHJcblx0XHRcdFx0XHRcdHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBUeXBlLklOVDpcclxuXHRcdFx0XHRcdGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggLSB0aGlzLnBvc2l0aW9uIDwgcmVtYWluaW5nTmVlZGVkKSB7XHJcblx0XHRcdFx0XHRcdGxldCBuZXdDYXBhY2l0eTogbnVtYmVyID0gQnVpbGRlci5yb3VuZFVwVG9OZXh0UG93ZXJPZlR3byh0aGlzLmJ1ZmZlci5sZW5ndGggKyByZW1haW5pbmdOZWVkZWQpO1xyXG5cdFx0XHRcdFx0XHRsZXQgbmV3QnVmZmVyOiBJbnQzMkFycmF5ID0gbmV3IEludDMyQXJyYXkobmV3Q2FwYWNpdHkpO1xyXG5cdFx0XHRcdFx0XHRuZXdCdWZmZXIuc2V0KHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMucG9zaXRpb24pLCAwKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHB1YmxpYyBhcHBlbmQodXRmMTZJbjogVWludDE2QXJyYXkpOiB2b2lkIHtcclxuXHRcdFx0dGhpcy5lbnN1cmVSZW1haW5pbmcodXRmMTZJbi5sZW5ndGgpO1xyXG5cdFx0XHR0aGlzLmFwcGVuZEFycmF5KHV0ZjE2SW4pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHByaXZhdGUgYXBwZW5kQXJyYXkodXRmMTZJbjogVWludDE2QXJyYXkpOiB2b2lkIHtcclxuXHRcdFx0c3dpdGNoICh0aGlzLnR5cGUpIHtcclxuXHRcdFx0XHRjYXNlIFR5cGUuQllURTpcclxuXHRcdFx0XHRcdHRoaXMuYXBwZW5kQXJyYXlCeXRlKHV0ZjE2SW4pO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBUeXBlLkNIQVI6XHJcblx0XHRcdFx0XHR0aGlzLmFwcGVuZEFycmF5Q2hhcih1dGYxNkluKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgVHlwZS5JTlQ6XHJcblx0XHRcdFx0XHR0aGlzLmFwcGVuZEFycmF5SW50KHV0ZjE2SW4pO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRwcml2YXRlIGFwcGVuZEFycmF5Qnl0ZSh1dGYxNkluOiBVaW50MTZBcnJheSk6IHZvaWQge1xyXG5cdFx0XHRhc3NlcnQodGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZSA9PT0gLTEpO1xyXG5cclxuXHRcdFx0bGV0IGlucHV0OiBVaW50MTZBcnJheSA9IHV0ZjE2SW47XHJcblx0XHRcdGxldCBpbk9mZnNldDogbnVtYmVyID0gMDtcclxuXHRcdFx0bGV0IGluTGltaXQ6IG51bWJlciA9IHV0ZjE2SW4ubGVuZ3RoO1xyXG5cclxuXHRcdFx0bGV0IG91dEJ5dGUgPSB0aGlzLmJ1ZmZlcjtcclxuXHRcdFx0bGV0IG91dE9mZnNldDogbnVtYmVyID0gdGhpcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdHdoaWxlIChpbk9mZnNldCA8IGluTGltaXQpIHtcclxuXHRcdFx0XHRsZXQgYzogbnVtYmVyID0gaW5wdXRbaW5PZmZzZXRdO1xyXG5cdFx0XHRcdGlmIChjIDw9IDB4RkYpIHtcclxuXHRcdFx0XHRcdG91dEJ5dGVbb3V0T2Zmc2V0XSA9IGM7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHV0ZjE2SW4gPSB1dGYxNkluLnN1YmFycmF5KGluT2Zmc2V0LCBpbkxpbWl0KTtcclxuXHRcdFx0XHRcdHRoaXMucG9zaXRpb24gPSBvdXRPZmZzZXQ7XHJcblx0XHRcdFx0XHRpZiAoIUNoYXJhY3Rlci5pc0hpZ2hTdXJyb2dhdGUoYykpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5ieXRlVG9DaGFyQnVmZmVyKHV0ZjE2SW4ubGVuZ3RoKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5hcHBlbmRBcnJheUNoYXIodXRmMTZJbik7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuYnl0ZVRvSW50QnVmZmVyKHV0ZjE2SW4ubGVuZ3RoKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5hcHBlbmRBcnJheUludCh1dGYxNkluKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aW5PZmZzZXQrKztcclxuXHRcdFx0XHRvdXRPZmZzZXQrKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5wb3NpdGlvbiA9IG91dE9mZnNldDtcclxuXHRcdH1cclxuXHJcblx0XHRwcml2YXRlIGFwcGVuZEFycmF5Q2hhcih1dGYxNkluOiBVaW50MTZBcnJheSk6IHZvaWQge1xyXG5cdFx0XHRhc3NlcnQodGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZSA9PT0gLTEpO1xyXG5cclxuXHRcdFx0bGV0IGlucHV0OiBVaW50MTZBcnJheSA9IHV0ZjE2SW47XHJcblx0XHRcdGxldCBpbk9mZnNldDogbnVtYmVyID0gMDtcclxuXHRcdFx0bGV0IGluTGltaXQ6IG51bWJlciA9IHV0ZjE2SW4ubGVuZ3RoO1xyXG5cclxuXHRcdFx0bGV0IG91dENoYXIgPSB0aGlzLmJ1ZmZlcjtcclxuXHRcdFx0bGV0IG91dE9mZnNldDogbnVtYmVyID0gdGhpcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdHdoaWxlIChpbk9mZnNldCA8IGluTGltaXQpIHtcclxuXHRcdFx0XHRsZXQgYzogbnVtYmVyID0gaW5wdXRbaW5PZmZzZXRdO1xyXG5cdFx0XHRcdGlmICghQ2hhcmFjdGVyLmlzSGlnaFN1cnJvZ2F0ZShjKSkge1xyXG5cdFx0XHRcdFx0b3V0Q2hhcltvdXRPZmZzZXRdID0gYztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dXRmMTZJbiA9IHV0ZjE2SW4uc3ViYXJyYXkoaW5PZmZzZXQsIGluTGltaXQpO1xyXG5cdFx0XHRcdFx0dGhpcy5wb3NpdGlvbiA9IG91dE9mZnNldDtcclxuXHRcdFx0XHRcdHRoaXMuY2hhclRvSW50QnVmZmVyKHV0ZjE2SW4ubGVuZ3RoKTtcclxuXHRcdFx0XHRcdHRoaXMuYXBwZW5kQXJyYXlJbnQodXRmMTZJbik7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpbk9mZnNldCsrO1xyXG5cdFx0XHRcdG91dE9mZnNldCsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnBvc2l0aW9uID0gb3V0T2Zmc2V0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHByaXZhdGUgYXBwZW5kQXJyYXlJbnQodXRmMTZJbjogVWludDE2QXJyYXkpOiB2b2lkIHtcclxuXHRcdFx0bGV0IGlucHV0OiBVaW50MTZBcnJheSA9IHV0ZjE2SW47XHJcblx0XHRcdGxldCBpbk9mZnNldDogbnVtYmVyID0gMDtcclxuXHRcdFx0bGV0IGluTGltaXQ6IG51bWJlciA9IHV0ZjE2SW4ubGVuZ3RoO1xyXG5cclxuXHRcdFx0bGV0IG91dEludCA9IHRoaXMuYnVmZmVyO1xyXG5cdFx0XHRsZXQgb3V0T2Zmc2V0ID0gdGhpcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdHdoaWxlIChpbk9mZnNldCA8IGluTGltaXQpIHtcclxuXHRcdFx0XHRsZXQgYzogbnVtYmVyID0gaW5wdXRbaW5PZmZzZXRdO1xyXG5cdFx0XHRcdGluT2Zmc2V0Kys7XHJcblx0XHRcdFx0aWYgKHRoaXMucHJldkhpZ2hTdXJyb2dhdGUgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRpZiAoQ2hhcmFjdGVyLmlzTG93U3Vycm9nYXRlKGMpKSB7XHJcblx0XHRcdFx0XHRcdG91dEludFtvdXRPZmZzZXRdID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnByZXZIaWdoU3Vycm9nYXRlLCBjKS5jb2RlUG9pbnRBdCgwKSE7XHJcblx0XHRcdFx0XHRcdG91dE9mZnNldCsrO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnByZXZIaWdoU3Vycm9nYXRlID0gLTE7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvLyBEYW5nbGluZyBoaWdoIHN1cnJvZ2F0ZVxyXG5cdFx0XHRcdFx0XHRvdXRJbnRbb3V0T2Zmc2V0XSA9IHRoaXMucHJldkhpZ2hTdXJyb2dhdGU7XHJcblx0XHRcdFx0XHRcdG91dE9mZnNldCsrO1xyXG5cdFx0XHRcdFx0XHRpZiAoQ2hhcmFjdGVyLmlzSGlnaFN1cnJvZ2F0ZShjKSkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMucHJldkhpZ2hTdXJyb2dhdGUgPSBjO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdG91dEludFtvdXRPZmZzZXRdID0gYztcclxuXHRcdFx0XHRcdFx0XHRvdXRPZmZzZXQrKztcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnByZXZIaWdoU3Vycm9nYXRlID0gLTE7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYgKENoYXJhY3Rlci5pc0hpZ2hTdXJyb2dhdGUoYykpIHtcclxuXHRcdFx0XHRcdHRoaXMucHJldkhpZ2hTdXJyb2dhdGUgPSBjO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRvdXRJbnRbb3V0T2Zmc2V0XSA9IGM7XHJcblx0XHRcdFx0XHRvdXRPZmZzZXQrKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aGlzLnByZXZIaWdoU3Vycm9nYXRlICE9PSAtMSkge1xyXG5cdFx0XHRcdC8vIERhbmdsaW5nIGhpZ2ggc3Vycm9nYXRlXHJcblx0XHRcdFx0b3V0SW50W291dE9mZnNldF0gPSB0aGlzLnByZXZIaWdoU3Vycm9nYXRlO1xyXG5cdFx0XHRcdG91dE9mZnNldCsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnBvc2l0aW9uID0gb3V0T2Zmc2V0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHByaXZhdGUgYnl0ZVRvQ2hhckJ1ZmZlcih0b0FwcGVuZDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRcdC8vIENoYXJCdWZmZXJzIGhvbGQgdHdpY2UgYXMgbXVjaCBwZXIgdW5pdCBhcyBCeXRlQnVmZmVycywgc28gc3RhcnQgd2l0aCBoYWxmIHRoZSBjYXBhY2l0eS5cclxuXHRcdFx0bGV0IG5ld0J1ZmZlcjogVWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoTWF0aC5tYXgodGhpcy5wb3NpdGlvbiArIHRvQXBwZW5kLCB0aGlzLmJ1ZmZlci5sZW5ndGggPj4gMSkpO1xyXG5cdFx0XHRuZXdCdWZmZXIuc2V0KHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMucG9zaXRpb24pLCAwKTtcclxuXHJcblx0XHRcdHRoaXMudHlwZSA9IFR5cGUuQ0hBUjtcclxuXHRcdFx0dGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0cHJpdmF0ZSBieXRlVG9JbnRCdWZmZXIodG9BcHBlbmQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0XHQvLyBJbnRCdWZmZXJzIGhvbGQgZm91ciB0aW1lcyBhcyBtdWNoIHBlciB1bml0IGFzIEJ5dGVCdWZmZXJzLCBzbyBzdGFydCB3aXRoIG9uZSBxdWFydGVyIHRoZSBjYXBhY2l0eS5cclxuXHRcdFx0bGV0IG5ld0J1ZmZlcjogSW50MzJBcnJheSA9IG5ldyBJbnQzMkFycmF5KE1hdGgubWF4KHRoaXMucG9zaXRpb24gKyB0b0FwcGVuZCwgdGhpcy5idWZmZXIubGVuZ3RoID4+IDIpKTtcclxuXHRcdFx0bmV3QnVmZmVyLnNldCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSwgMCk7XHJcblxyXG5cdFx0XHR0aGlzLnR5cGUgPSBUeXBlLklOVDtcclxuXHRcdFx0dGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0cHJpdmF0ZSBjaGFyVG9JbnRCdWZmZXIodG9BcHBlbmQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0XHQvLyBJbnRCdWZmZXJzIGhvbGQgdHdvIHRpbWVzIGFzIG11Y2ggcGVyIHVuaXQgYXMgQnl0ZUJ1ZmZlcnMsIHNvIHN0YXJ0IHdpdGggb25lIGhhbGYgdGhlIGNhcGFjaXR5LlxyXG5cdFx0XHRsZXQgbmV3QnVmZmVyOiBJbnQzMkFycmF5ID0gbmV3IEludDMyQXJyYXkoTWF0aC5tYXgodGhpcy5wb3NpdGlvbiArIHRvQXBwZW5kLCB0aGlzLmJ1ZmZlci5sZW5ndGggPj4gMSkpO1xyXG5cdFx0XHRuZXdCdWZmZXIuc2V0KHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMucG9zaXRpb24pLCAwKTtcclxuXHJcblx0XHRcdHRoaXMudHlwZSA9IFR5cGUuSU5UO1xyXG5cdFx0XHR0aGlzLmJ1ZmZlciA9IG5ld0J1ZmZlcjtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcclxuaW1wb3J0IHsgQ2hhclN0cmVhbSB9IGZyb20gXCIuL0NoYXJTdHJlYW1cIjtcclxuaW1wb3J0IHsgQ29kZVBvaW50QnVmZmVyIH0gZnJvbSBcIi4vQ29kZVBvaW50QnVmZmVyXCI7XHJcbmltcG9ydCB7IEludFN0cmVhbSB9IGZyb20gXCIuL0ludFN0cmVhbVwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICogQWx0ZXJuYXRpdmUgdG8ge0BsaW5rIEFOVExSSW5wdXRTdHJlYW19IHdoaWNoIHRyZWF0cyB0aGUgaW5wdXRcclxuICogYXMgYSBzZXJpZXMgb2YgVW5pY29kZSBjb2RlIHBvaW50cywgaW5zdGVhZCBvZiBhIHNlcmllcyBvZiBVVEYtMTZcclxuICogY29kZSB1bml0cy5cclxuICpcclxuICogVXNlIHRoaXMgaWYgeW91IG5lZWQgdG8gcGFyc2UgaW5wdXQgd2hpY2ggcG90ZW50aWFsbHkgY29udGFpbnNcclxuICogVW5pY29kZSB2YWx1ZXMgPiBVK0ZGRkYuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ29kZVBvaW50Q2hhclN0cmVhbSBpbXBsZW1lbnRzIENoYXJTdHJlYW0ge1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgX2FycmF5OiBVaW50OEFycmF5IHwgVWludDE2QXJyYXkgfCBJbnQzMkFycmF5O1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgX3NpemU6IG51bWJlcjtcclxuXHRwcml2YXRlIHJlYWRvbmx5IF9uYW1lOiBzdHJpbmc7XHJcblxyXG5cdHByaXZhdGUgX3Bvc2l0aW9uOiBudW1iZXI7XHJcblxyXG5cdC8vIFVzZSB0aGUgZmFjdG9yeSBtZXRob2Qge0BsaW5rICNmcm9tQnVmZmVyKENvZGVQb2ludEJ1ZmZlcil9IHRvXHJcblx0Ly8gY29uc3RydWN0IGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXHJcblx0cHJvdGVjdGVkIGNvbnN0cnVjdG9yKGFycmF5OiBVaW50OEFycmF5IHwgVWludDE2QXJyYXkgfCBJbnQzMkFycmF5LCBwb3NpdGlvbjogbnVtYmVyLCByZW1haW5pbmc6IG51bWJlciwgbmFtZTogc3RyaW5nKSB7XHJcblx0XHQvLyBUT0RPXHJcblx0XHRhc3NlcnQocG9zaXRpb24gPT09IDApO1xyXG5cdFx0dGhpcy5fYXJyYXkgPSBhcnJheTtcclxuXHRcdHRoaXMuX3NpemUgPSByZW1haW5pbmc7XHJcblx0XHR0aGlzLl9uYW1lID0gbmFtZTtcclxuXHRcdHRoaXMuX3Bvc2l0aW9uID0gMDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXQgaW50ZXJuYWxTdG9yYWdlKCk6IFVpbnQ4QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2FycmF5O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBDb2RlUG9pbnRDaGFyU3RyZWFtfSB3aGljaCBwcm92aWRlcyBhY2Nlc3NcclxuXHQgKiB0byB0aGUgVW5pY29kZSBjb2RlIHBvaW50cyBzdG9yZWQgaW4ge0Bjb2RlIGNvZGVQb2ludEJ1ZmZlcn0uXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyBmcm9tQnVmZmVyKGNvZGVQb2ludEJ1ZmZlcjogQ29kZVBvaW50QnVmZmVyKTogQ29kZVBvaW50Q2hhclN0cmVhbTtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5hbWVkIHtAbGluayBDb2RlUG9pbnRDaGFyU3RyZWFtfSB3aGljaCBwcm92aWRlcyBhY2Nlc3NcclxuXHQgKiB0byB0aGUgVW5pY29kZSBjb2RlIHBvaW50cyBzdG9yZWQgaW4ge0Bjb2RlIGNvZGVQb2ludEJ1ZmZlcn0uXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyBmcm9tQnVmZmVyKGNvZGVQb2ludEJ1ZmZlcjogQ29kZVBvaW50QnVmZmVyLCBuYW1lOiBzdHJpbmcpOiBDb2RlUG9pbnRDaGFyU3RyZWFtO1xyXG5cdHB1YmxpYyBzdGF0aWMgZnJvbUJ1ZmZlcihjb2RlUG9pbnRCdWZmZXI6IENvZGVQb2ludEJ1ZmZlciwgbmFtZT86IHN0cmluZyk6IENvZGVQb2ludENoYXJTdHJlYW0ge1xyXG5cdFx0aWYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRuYW1lID0gSW50U3RyZWFtLlVOS05PV05fU09VUkNFX05BTUU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSmF2YSBsYWNrcyBnZW5lcmljcyBvbiBwcmltaXRpdmUgdHlwZXMuXHJcblx0XHQvL1xyXG5cdFx0Ly8gVG8gYXZvaWQgbG90cyBvZiBjYWxscyB0byB2aXJ0dWFsIG1ldGhvZHMgaW4gdGhlXHJcblx0XHQvLyB2ZXJ5IGhvdCBjb2RlcGF0aCBvZiBMQSgpIGJlbG93LCB3ZSBjb25zdHJ1Y3Qgb25lXHJcblx0XHQvLyBvZiB0aHJlZSBjb25jcmV0ZSBzdWJjbGFzc2VzLlxyXG5cdFx0Ly9cclxuXHRcdC8vIFRoZSBjb25jcmV0ZSBzdWJjbGFzc2VzIGRpcmVjdGx5IGFjY2VzcyB0aGUgY29kZVxyXG5cdFx0Ly8gcG9pbnRzIHN0b3JlZCBpbiB0aGUgdW5kZXJseWluZyBhcnJheSAoYnl0ZVtdLFxyXG5cdFx0Ly8gY2hhcltdLCBvciBpbnRbXSksIHNvIHdlIGNhbiBhdm9pZCBsb3RzIG9mIHZpcnR1YWxcclxuXHRcdC8vIG1ldGhvZCBjYWxscyB0byBCeXRlQnVmZmVyLmdldChvZmZzZXQpLlxyXG5cdFx0cmV0dXJuIG5ldyBDb2RlUG9pbnRDaGFyU3RyZWFtKFxyXG5cdFx0XHRjb2RlUG9pbnRCdWZmZXIuYXJyYXkoKSxcclxuXHRcdFx0Y29kZVBvaW50QnVmZmVyLnBvc2l0aW9uLFxyXG5cdFx0XHRjb2RlUG9pbnRCdWZmZXIucmVtYWluaW5nLFxyXG5cdFx0XHRuYW1lKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBjb25zdW1lKCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuX3NpemUgLSB0aGlzLl9wb3NpdGlvbiA9PT0gMCkge1xyXG5cdFx0XHRhc3NlcnQodGhpcy5MQSgxKSA9PT0gSW50U3RyZWFtLkVPRik7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2Fubm90IGNvbnN1bWUgRU9GXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3Bvc2l0aW9uKys7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0IGluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcG9zaXRpb247XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9zaXplO1xyXG5cdH1cclxuXHJcblx0LyoqIG1hcmsvcmVsZWFzZSBkbyBub3RoaW5nOyB3ZSBoYXZlIGVudGlyZSBidWZmZXIgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgbWFyaygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlbGVhc2UobWFya2VyOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdC8vIE5vIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2luY2UgdGhpcyBzdHJlYW0gYnVmZmVycyB0aGUgZW50aXJlIGlucHV0XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgc2VlayhpbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLl9wb3NpdGlvbiA9IGluZGV4O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGdldCBzb3VyY2VOYW1lKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbmFtZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGV4dChJbnRlcnZhbC5vZigwLCB0aGlzLnNpemUgLSAxKSk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgTEEoaTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGxldCBvZmZzZXQ6IG51bWJlcjtcclxuXHRcdHN3aXRjaCAoTWF0aC5zaWduKGkpKSB7XHJcblx0XHRcdGNhc2UgLTE6XHJcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5pbmRleCArIGk7XHJcblx0XHRcdFx0aWYgKG9mZnNldCA8IDApIHtcclxuXHRcdFx0XHRcdHJldHVybiBJbnRTdHJlYW0uRU9GO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2FycmF5W29mZnNldF07XHJcblxyXG5cdFx0XHRjYXNlIDA6XHJcblx0XHRcdFx0Ly8gVW5kZWZpbmVkXHJcblx0XHRcdFx0cmV0dXJuIDA7XHJcblxyXG5cdFx0XHRjYXNlIDE6XHJcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5pbmRleCArIGkgLSAxO1xyXG5cdFx0XHRcdGlmIChvZmZzZXQgPj0gdGhpcy5zaXplKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gSW50U3RyZWFtLkVPRjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9hcnJheVtvZmZzZXRdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm90IHJlYWNoZWRcIik7XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIHRoZSBVVEYtMTYgZW5jb2RlZCBzdHJpbmcgZm9yIHRoZSBnaXZlbiBpbnRlcnZhbCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXRUZXh0KGludGVydmFsOiBJbnRlcnZhbCk6IHN0cmluZyB7XHJcblx0XHRjb25zdCBzdGFydElkeDogbnVtYmVyID0gTWF0aC5taW4oaW50ZXJ2YWwuYSwgdGhpcy5zaXplKTtcclxuXHRcdGNvbnN0IGxlbjogbnVtYmVyID0gTWF0aC5taW4oaW50ZXJ2YWwuYiAtIGludGVydmFsLmEgKyAxLCB0aGlzLnNpemUgLSBzdGFydElkeCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xyXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uQXJyYXkuZnJvbSh0aGlzLl9hcnJheS5zdWJhcnJheShzdGFydElkeCwgc3RhcnRJZHggKyBsZW4pKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5BcnJheS5mcm9tKHRoaXMuX2FycmF5LnN1YmFycmF5KHN0YXJ0SWR4LCBzdGFydElkeCArIGxlbikpKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQ29kZVBvaW50QnVmZmVyIH0gZnJvbSBcIi4vQ29kZVBvaW50QnVmZmVyXCI7XHJcbmltcG9ydCB7IENvZGVQb2ludENoYXJTdHJlYW0gfSBmcm9tIFwiLi9Db2RlUG9pbnRDaGFyU3RyZWFtXCI7XHJcbmltcG9ydCB7IEludFN0cmVhbSB9IGZyb20gXCIuL0ludFN0cmVhbVwiO1xyXG5cclxuLy8gY29uc3QgREVGQVVMVF9CVUZGRVJfU0laRTogbnVtYmVyID0gNDA5NjtcclxuXHJcbi8qKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIHByaW1hcnkgaW50ZXJmYWNlIGZvciBjcmVhdGluZyB7QGxpbmsgQ2hhclN0cmVhbX1zXHJcbiAqICBmcm9tIGEgdmFyaWV0eSBvZiBzb3VyY2VzIGFzIG9mIDQuNy4gIFRoZSBtb3RpdmF0aW9uIHdhcyB0byBzdXBwb3J0XHJcbiAqICBVbmljb2RlIGNvZGUgcG9pbnRzID4gVStGRkZGLiAge0BsaW5rIEFOVExSSW5wdXRTdHJlYW19IGFuZFxyXG4gKiAge0BsaW5rIEFOVExSRmlsZVN0cmVhbX0gYXJlIG5vdyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHRoZSBzdHJlYW1zIGNyZWF0ZWRcclxuICogIGJ5IHRoaXMgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiAgREVQUkVDQVRFRDoge0Bjb2RlIG5ldyBBTlRMUkZpbGVTdHJlYW0oXCJteWlucHV0ZmlsZVwiKX1cclxuICogIE5FVzogICAgICAgIHtAY29kZSBDaGFyU3RyZWFtcy5mcm9tRmlsZU5hbWUoXCJteWlucHV0ZmlsZVwiKX1cclxuICpcclxuICogIFdBUk5JTkc6IElmIHlvdSB1c2UgYm90aCB0aGUgZGVwcmVjYXRlZCBhbmQgdGhlIG5ldyBzdHJlYW1zLCB5b3Ugd2lsbCBzZWVcclxuICogIGEgbm9udHJpdmlhbCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbi4gVGhpcyBzcGVlZCBoaXQgaXMgYmVjYXVzZSB0aGVcclxuICogIHtAbGluayBMZXhlcn0ncyBpbnRlcm5hbCBjb2RlIGdvZXMgZnJvbSBhIG1vbm9tb3JwaGljIHRvIG1lZ2Ftb3JwaGljXHJcbiAqICBkeW5hbWljIGRpc3BhdGNoIHRvIGdldCBjaGFyYWN0ZXJzIGZyb20gdGhlIGlucHV0IHN0cmVhbS4gSmF2YSdzXHJcbiAqICBvbi10aGUtZmx5IGNvbXBpbGVyIChKSVQpIGlzIHVuYWJsZSB0byBwZXJmb3JtIHRoZSBzYW1lIG9wdGltaXphdGlvbnNcclxuICogIHNvIHN0aWNrIHdpdGggZWl0aGVyIHRoZSBvbGQgb3IgdGhlIG5ldyBzdHJlYW1zLCBpZiBwZXJmb3JtYW5jZSBpc1xyXG4gKiAgYSBwcmltYXJ5IGNvbmNlcm4uIFNlZSB0aGUgZXh0cmVtZSBkZWJ1Z2dpbmcgYW5kIHNwZWx1bmtpbmdcclxuICogIG5lZWRlZCB0byBpZGVudGlmeSB0aGlzIGlzc3VlIGluIG91ciB0aW1pbmcgcmlnOlxyXG4gKlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRsci9hbnRscjQvcHVsbC8xNzgxXHJcbiAqXHJcbiAqICBUaGUgQU5UTFIgY2hhcmFjdGVyIHN0cmVhbXMgc3RpbGwgYnVmZmVyIGFsbCB0aGUgaW5wdXQgd2hlbiB5b3UgY3JlYXRlXHJcbiAqICB0aGUgc3RyZWFtLCBhcyB0aGV5IGhhdmUgZG9uZSBmb3IgfjIwIHllYXJzLiBJZiB5b3UgbmVlZCB1bmJ1ZmZlcmVkXHJcbiAqICBhY2Nlc3MsIHBsZWFzZSBub3RlIHRoYXQgaXQgYmVjb21lcyBjaGFsbGVuZ2luZyB0byBjcmVhdGVcclxuICogIHBhcnNlIHRyZWVzLiBUaGUgcGFyc2UgdHJlZSBoYXMgdG8gcG9pbnQgdG8gdG9rZW5zIHdoaWNoIHdpbGwgZWl0aGVyXHJcbiAqICBwb2ludCBpbnRvIGEgc3RhbGUgbG9jYXRpb24gaW4gYW4gdW5idWZmZXJlZCBzdHJlYW0gb3IgeW91IGhhdmUgdG8gY29weVxyXG4gKiAgdGhlIGNoYXJhY3RlcnMgb3V0IG9mIHRoZSBidWZmZXIgaW50byB0aGUgdG9rZW4uIFRoYXQgZGVmZWF0cyB0aGUgcHVycG9zZVxyXG4gKiAgb2YgdW5idWZmZXJlZCBpbnB1dC4gUGVyIHRoZSBBTlRMUiBib29rLCB1bmJ1ZmZlcmVkIHN0cmVhbXMgYXJlIHByaW1hcmlseVxyXG4gKiAgdXNlZnVsIGZvciBwcm9jZXNzaW5nIGluZmluaXRlIHN0cmVhbXMgKmR1cmluZyB0aGUgcGFyc2UuKlxyXG4gKlxyXG4gKiAgVGhlIG5ldyBzdHJlYW1zIGFsc28gdXNlIDgtYml0IGJ1ZmZlcnMgd2hlbiBwb3NzaWJsZSBzbyB0aGlzIG5ld1xyXG4gKiAgaW50ZXJmYWNlIHN1cHBvcnRzIGNoYXJhY3RlciBzdHJlYW1zIHRoYXQgdXNlIGhhbGYgYXMgbXVjaCBtZW1vcnlcclxuICogIGFzIHRoZSBvbGQge0BsaW5rIEFOVExSRmlsZVN0cmVhbX0sIHdoaWNoIGFzc3VtZWQgMTYtYml0IGNoYXJhY3RlcnMuXHJcbiAqXHJcbiAqICBBIGJpZyBzaG91dCBvdXQgdG8gQmVuIEhhbWlsdG9uIChnaXRodWIgYmhhbWlsdG9uY3gpIGZvciBoaXMgc3VwZXJodW1hblxyXG4gKiAgZWZmb3J0cyBhY3Jvc3MgYWxsIHRhcmdldHMgdG8gZ2V0IHRydWUgVW5pY29kZSAzLjEgc3VwcG9ydCBmb3IgVSsxMEZGRkYuXHJcbiAqXHJcbiAqICBAc2luY2UgNC43XHJcbiAqL1xyXG5leHBvcnQgbmFtZXNwYWNlIENoYXJTdHJlYW1zIHtcclxuXHQvLyAvKipcclxuXHQvLyAgKiBDcmVhdGVzIGEge0BsaW5rIENoYXJTdHJlYW19IGdpdmVuIGEgcGF0aCB0byBhIFVURi04XHJcblx0Ly8gICogZW5jb2RlZCBmaWxlIG9uIGRpc2suXHJcblx0Ly8gICpcclxuXHQvLyAgKiBSZWFkcyB0aGUgZW50aXJlIGNvbnRlbnRzIG9mIHRoZSBmaWxlIGludG8gdGhlIHJlc3VsdCBiZWZvcmUgcmV0dXJuaW5nLlxyXG5cdC8vICAqL1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tRmlsZShmaWxlOiBGaWxlKTogQ2hhclN0cmVhbTtcclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbUZpbGUoZmlsZTogRmlsZSwgY2hhcnNldDogQ2hhcnNldCk6IENoYXJTdHJlYW07XHJcblx0Ly8gZXhwb3J0IGZ1bmN0aW9uIGZyb21GaWxlKGZpbGU6IEZpbGUsIGNoYXJzZXQ/OiBDaGFyc2V0KTogQ2hhclN0cmVhbSB7XHJcblx0Ly8gXHRpZiAoY2hhcnNldCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0Ly8gXHRcdGNoYXJzZXQgPSBDaGFyc2V0LmZvck5hbWUoXCJVVEYtOFwiKTtcclxuXHQvLyBcdH1cclxuXHJcblx0Ly8gXHRsZXQgc2l6ZTogbnVtYmVyID0gZmlsZS5sZW5ndGgoKTtcclxuXHQvLyBcdHJldHVybiBmcm9tU3RyZWFtKG5ldyBGaWxlSW5wdXRTdHJlYW0oZmlsZSksIGNoYXJzZXQsIGZpbGUudG9TdHJpbmcoKSwgc2l6ZSk7XHJcblx0Ly8gfVxyXG5cclxuXHQvLyAvKipcclxuXHQvLyAgKiBDcmVhdGVzIGEge0BsaW5rIENoYXJTdHJlYW19IGdpdmVuIGEgc3RyaW5nIGNvbnRhaW5pbmcgYVxyXG5cdC8vICAqIHBhdGggdG8gYSBVVEYtOCBmaWxlIG9uIGRpc2suXHJcblx0Ly8gICpcclxuXHQvLyAgKiBSZWFkcyB0aGUgZW50aXJlIGNvbnRlbnRzIG9mIHRoZSBmaWxlIGludG8gdGhlIHJlc3VsdCBiZWZvcmUgcmV0dXJuaW5nLlxyXG5cdC8vICAqL1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tRmlsZU5hbWUoZmlsZU5hbWU6IHN0cmluZyk6IENoYXJTdHJlYW07XHJcblxyXG5cdC8vIC8qKlxyXG5cdC8vICAqIENyZWF0ZXMgYSB7QGxpbmsgQ2hhclN0cmVhbX0gZ2l2ZW4gYSBzdHJpbmcgY29udGFpbmluZyBhXHJcblx0Ly8gICogcGF0aCB0byBhIGZpbGUgb24gZGlzayBhbmQgdGhlIGNoYXJzZXQgb2YgdGhlIGJ5dGVzXHJcblx0Ly8gICogY29udGFpbmVkIGluIHRoZSBmaWxlLlxyXG5cdC8vICAqXHJcblx0Ly8gICogUmVhZHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUgZmlsZSBpbnRvIHRoZSByZXN1bHQgYmVmb3JlIHJldHVybmluZy5cclxuXHQvLyAgKi9cclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbUZpbGVOYW1lKGZpbGVOYW1lOiBzdHJpbmcsIGNoYXJzZXQ6IENoYXJzZXQpOiBDaGFyU3RyZWFtO1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tRmlsZU5hbWUoZmlsZU5hbWU6IHN0cmluZywgY2hhcnNldD86IENoYXJzZXQpOiBDaGFyU3RyZWFtIHtcclxuXHQvLyBcdGlmIChjaGFyc2V0ID09PSB1bmRlZmluZWQpIHtcclxuXHQvLyBcdFx0Y2hhcnNldCA9IENoYXJzZXQuZm9yTmFtZShcIlVURi04XCIpO1xyXG5cdC8vIFx0fVxyXG5cclxuXHQvLyBcdHJldHVybiBmcm9tRmlsZShuZXcgRmlsZShmaWxlTmFtZSksIGNoYXJzZXQpO1xyXG5cdC8vIH1cclxuXHJcblx0Ly8gLyoqXHJcblx0Ly8gICogQ3JlYXRlcyBhIHtAbGluayBDaGFyU3RyZWFtfSBnaXZlbiBhbiBvcGVuZWQge0BsaW5rIElucHV0U3RyZWFtfVxyXG5cdC8vICAqIGNvbnRhaW5pbmcgVVRGLTggYnl0ZXMuXHJcblx0Ly8gICpcclxuXHQvLyAgKiBSZWFkcyB0aGUgZW50aXJlIGNvbnRlbnRzIG9mIHRoZSB7QGNvZGUgSW5wdXRTdHJlYW19IGludG9cclxuXHQvLyAgKiB0aGUgcmVzdWx0IGJlZm9yZSByZXR1cm5pbmcsIHRoZW4gY2xvc2VzIHRoZSB7QGNvZGUgSW5wdXRTdHJlYW19LlxyXG5cdC8vICAqL1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyZWFtKGlzOiBJbnB1dFN0cmVhbSk6IENoYXJTdHJlYW07XHJcblxyXG5cdC8vIC8qKlxyXG5cdC8vICAqIENyZWF0ZXMgYSB7QGxpbmsgQ2hhclN0cmVhbX0gZ2l2ZW4gYW4gb3BlbmVkIHtAbGluayBJbnB1dFN0cmVhbX0gYW5kIHRoZVxyXG5cdC8vICAqIGNoYXJzZXQgb2YgdGhlIGJ5dGVzIGNvbnRhaW5lZCBpbiB0aGUgc3RyZWFtLlxyXG5cdC8vICAqXHJcblx0Ly8gICogUmVhZHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUge0Bjb2RlIElucHV0U3RyZWFtfSBpbnRvXHJcblx0Ly8gICogdGhlIHJlc3VsdCBiZWZvcmUgcmV0dXJuaW5nLCB0aGVuIGNsb3NlcyB0aGUge0Bjb2RlIElucHV0U3RyZWFtfS5cclxuXHQvLyAgKi9cclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbVN0cmVhbShpczogSW5wdXRTdHJlYW0sIGNoYXJzZXQ6IENoYXJzZXQpOiBDaGFyU3RyZWFtO1xyXG5cclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbVN0cmVhbShpczogSW5wdXRTdHJlYW0sIGNoYXJzZXQ6IENoYXJzZXQsIHNvdXJjZU5hbWU6IHN0cmluZywgaW5wdXRTaXplOiBudW1iZXIpOiBDaGFyU3RyZWFtO1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyZWFtKGlzOiBJbnB1dFN0cmVhbSwgY2hhcnNldD86IENoYXJzZXQsIHNvdXJjZU5hbWU/OiBzdHJpbmcsIGlucHV0U2l6ZT86IG51bWJlcik6IENoYXJTdHJlYW0ge1xyXG5cdC8vIFx0aWYgKGNoYXJzZXQgPT09IHVuZGVmaW5lZCkge1xyXG5cdC8vIFx0XHRjaGFyc2V0ID0gQ2hhcnNldC5mb3JOYW1lKFwiVVRGLThcIik7XHJcblx0Ly8gXHR9XHJcblxyXG5cdC8vIFx0aWYgKHNvdXJjZU5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdC8vIFx0XHRzb3VyY2VOYW1lID0gSW50U3RyZWFtLlVOS05PV05fU09VUkNFX05BTUU7XHJcblx0Ly8gXHR9XHJcblxyXG5cdC8vIFx0aWYgKGlucHV0U2l6ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0Ly8gXHRcdGlucHV0U2l6ZSA9IC0xO1xyXG5cdC8vIFx0fVxyXG5cclxuXHQvLyBcdHJldHVybiBmcm9tQ2hhbm5lbChcclxuXHQvLyBcdFx0Q2hhbm5lbHMubmV3Q2hhbm5lbChpcyksXHJcblx0Ly8gXHRcdGNoYXJzZXQsXHJcblx0Ly8gXHRcdERFRkFVTFRfQlVGRkVSX1NJWkUsXHJcblx0Ly8gXHRcdENvZGluZ0Vycm9yQWN0aW9uLlJFUExBQ0UsXHJcblx0Ly8gXHRcdHNvdXJjZU5hbWUsXHJcblx0Ly8gXHRcdGlucHV0U2l6ZSk7XHJcblx0Ly8gfVxyXG5cclxuXHQvLyAvKipcclxuXHQvLyAgKiBDcmVhdGVzIGEge0BsaW5rIENoYXJTdHJlYW19IGdpdmVuIGFuIG9wZW5lZCB7QGxpbmsgUmVhZGFibGVCeXRlQ2hhbm5lbH1cclxuXHQvLyAgKiBjb250YWluaW5nIFVURi04IGJ5dGVzLlxyXG5cdC8vICAqXHJcblx0Ly8gICogUmVhZHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUge0Bjb2RlIGNoYW5uZWx9IGludG9cclxuXHQvLyAgKiB0aGUgcmVzdWx0IGJlZm9yZSByZXR1cm5pbmcsIHRoZW4gY2xvc2VzIHRoZSB7QGNvZGUgY2hhbm5lbH0uXHJcblx0Ly8gICovXHJcblx0Ly8gZXhwb3J0IGZ1bmN0aW9uIGZyb21DaGFubmVsKGNoYW5uZWw6IFJlYWRhYmxlQnl0ZUNoYW5uZWwpOiBDaGFyU3RyZWFtO1xyXG5cclxuXHQvLyAvKipcclxuXHQvLyAgKiBDcmVhdGVzIGEge0BsaW5rIENoYXJTdHJlYW19IGdpdmVuIGFuIG9wZW5lZCB7QGxpbmsgUmVhZGFibGVCeXRlQ2hhbm5lbH0gYW5kIHRoZVxyXG5cdC8vICAqIGNoYXJzZXQgb2YgdGhlIGJ5dGVzIGNvbnRhaW5lZCBpbiB0aGUgY2hhbm5lbC5cclxuXHQvLyAgKlxyXG5cdC8vICAqIFJlYWRzIHRoZSBlbnRpcmUgY29udGVudHMgb2YgdGhlIHtAY29kZSBjaGFubmVsfSBpbnRvXHJcblx0Ly8gICogdGhlIHJlc3VsdCBiZWZvcmUgcmV0dXJuaW5nLCB0aGVuIGNsb3NlcyB0aGUge0Bjb2RlIGNoYW5uZWx9LlxyXG5cdC8vICAqL1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tQ2hhbm5lbChjaGFubmVsOiBSZWFkYWJsZUJ5dGVDaGFubmVsLCBjaGFyc2V0OiBDaGFyc2V0KTogQ2hhclN0cmVhbTtcclxuXHJcblx0Ly8gLyoqXHJcblx0Ly8gICogQ3JlYXRlcyBhIHtAbGluayBDaGFyU3RyZWFtfSBnaXZlbiBhbiBvcGVuZWQge0BsaW5rIFJlYWRhYmxlQnl0ZUNoYW5uZWx9XHJcblx0Ly8gICogY29udGFpbmluZyBVVEYtOCBieXRlcy5cclxuXHQvLyAgKlxyXG5cdC8vICAqIFJlYWRzIHRoZSBlbnRpcmUgY29udGVudHMgb2YgdGhlIHtAY29kZSBjaGFubmVsfSBpbnRvXHJcblx0Ly8gICogdGhlIHJlc3VsdCBiZWZvcmUgcmV0dXJuaW5nLCB0aGVuIGNsb3NlcyB0aGUge0Bjb2RlIGNoYW5uZWx9LlxyXG5cdC8vICAqL1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tQ2hhbm5lbChcclxuXHQvLyBcdGNoYW5uZWw6IFJlYWRhYmxlQnl0ZUNoYW5uZWwsXHJcblx0Ly8gXHRjaGFyc2V0OiBDaGFyc2V0LFxyXG5cdC8vIFx0YnVmZmVyU2l6ZTogbnVtYmVyLFxyXG5cdC8vIFx0ZGVjb2RpbmdFcnJvckFjdGlvbjogQ29kaW5nRXJyb3JBY3Rpb24sXHJcblx0Ly8gXHRzb3VyY2VOYW1lOiBzdHJpbmcpOiBDb2RlUG9pbnRDaGFyU3RyZWFtO1xyXG5cclxuXHQvLyBleHBvcnQgZnVuY3Rpb24gZnJvbUNoYW5uZWwoXHJcblx0Ly8gXHRjaGFubmVsOiBSZWFkYWJsZUJ5dGVDaGFubmVsLFxyXG5cdC8vIFx0Y2hhcnNldDogQ2hhcnNldCxcclxuXHQvLyBcdGJ1ZmZlclNpemU6IG51bWJlcixcclxuXHQvLyBcdGRlY29kaW5nRXJyb3JBY3Rpb246IENvZGluZ0Vycm9yQWN0aW9uLFxyXG5cdC8vIFx0c291cmNlTmFtZTogc3RyaW5nLFxyXG5cdC8vIFx0aW5wdXRTaXplOiBudW1iZXIpOiBDb2RlUG9pbnRDaGFyU3RyZWFtO1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tQ2hhbm5lbChcclxuXHQvLyBcdGNoYW5uZWw6IFJlYWRhYmxlQnl0ZUNoYW5uZWwsXHJcblx0Ly8gXHRjaGFyc2V0PzogQ2hhcnNldCxcclxuXHQvLyBcdGJ1ZmZlclNpemU/OiBudW1iZXIsXHJcblx0Ly8gXHRkZWNvZGluZ0Vycm9yQWN0aW9uPzogQ29kaW5nRXJyb3JBY3Rpb24sXHJcblx0Ly8gXHRzb3VyY2VOYW1lPzogc3RyaW5nLFxyXG5cdC8vIFx0aW5wdXRTaXplPzogbnVtYmVyKTogQ29kZVBvaW50Q2hhclN0cmVhbVxyXG5cdC8vIHtcclxuXHQvLyBcdGlmIChjaGFyc2V0ID09PSB1bmRlZmluZWQpIHtcclxuXHQvLyBcdFx0Y2hhcnNldCA9IENoYXJzZXQuZm9yTmFtZShcIlVURi04XCIpO1xyXG5cdC8vIFx0fVxyXG5cclxuXHQvLyBcdGlmIChidWZmZXJTaXplID09PSB1bmRlZmluZWQpIHtcclxuXHQvLyBcdFx0YnVmZmVyU2l6ZSA9IERFRkFVTFRfQlVGRkVSX1NJWkU7XHJcblx0Ly8gXHR9XHJcblxyXG5cdC8vIFx0aWYgKGRlY29kaW5nRXJyb3JBY3Rpb24gPT09IHVuZGVmaW5lZCkge1xyXG5cdC8vIFx0XHRkZWNvZGluZ0Vycm9yQWN0aW9uID0gQ29kaW5nRXJyb3JBY3Rpb24uUkVQTEFDRTtcclxuXHQvLyBcdH1cclxuXHJcblx0Ly8gXHRpZiAoc291cmNlTmFtZSA9PT0gdW5kZWZpbmVkIHx8IHNvdXJjZU5hbWUubGVuZ3RoID09PSAwKSB7XHJcblx0Ly8gXHRcdHNvdXJjZU5hbWUgPSBJbnRTdHJlYW0uVU5LTk9XTl9TT1VSQ0VfTkFNRTtcclxuXHQvLyBcdH1cclxuXHJcblx0Ly8gXHRpZiAoaW5wdXRTaXplID09PSB1bmRlZmluZWQpIHtcclxuXHQvLyBcdFx0aW5wdXRTaXplID0gLTE7XHJcblx0Ly8gXHR9XHJcblxyXG5cdC8vIFx0bGV0IGNvZGVQb2ludEJ1ZmZlcjogQ29kZVBvaW50QnVmZmVyID0gYnVmZmVyRnJvbUNoYW5uZWwoY2hhbm5lbCwgY2hhcnNldCwgYnVmZmVyU2l6ZSwgZGVjb2RpbmdFcnJvckFjdGlvbiwgaW5wdXRTaXplKTtcclxuXHQvLyBcdHJldHVybiBDb2RlUG9pbnRDaGFyU3RyZWFtLmZyb21CdWZmZXIoY29kZVBvaW50QnVmZmVyLCBzb3VyY2VOYW1lKTtcclxuXHQvLyB9XHJcblxyXG5cdC8vIC8qKlxyXG5cdC8vICAqIENyZWF0ZXMgYSB7QGxpbmsgQ2hhclN0cmVhbX0gZ2l2ZW4gYSB7QGxpbmsgUmVhZGVyfS4gQ2xvc2VzXHJcblx0Ly8gICogdGhlIHJlYWRlciBiZWZvcmUgcmV0dXJuaW5nLlxyXG5cdC8vICAqL1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tUmVhZGVyKHI6IFJlYWRlcik6IENvZGVQb2ludENoYXJTdHJlYW07XHJcblxyXG5cdC8vIC8qKlxyXG5cdC8vICAqIENyZWF0ZXMgYSB7QGxpbmsgQ2hhclN0cmVhbX0gZ2l2ZW4gYSB7QGxpbmsgUmVhZGVyfSBhbmQgaXRzXHJcblx0Ly8gICogc291cmNlIG5hbWUuIENsb3NlcyB0aGUgcmVhZGVyIGJlZm9yZSByZXR1cm5pbmcuXHJcblx0Ly8gICovXHJcblx0Ly8gZXhwb3J0IGZ1bmN0aW9uIGZyb21SZWFkZXIocjogUmVhZGVyLCBzb3VyY2VOYW1lOiBzdHJpbmcpOiBDb2RlUG9pbnRDaGFyU3RyZWFtO1xyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBmcm9tUmVhZGVyKHI6IFJlYWRlciwgc291cmNlTmFtZT86IHN0cmluZyk6IENvZGVQb2ludENoYXJTdHJlYW0ge1xyXG5cdC8vIFx0aWYgKHNvdXJjZU5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdC8vIFx0XHRzb3VyY2VOYW1lID0gSW50U3RyZWFtLlVOS05PV05fU09VUkNFX05BTUU7XHJcblx0Ly8gXHR9XHJcblxyXG5cdC8vIFx0dHJ5IHtcclxuXHQvLyBcdFx0bGV0IGNvZGVQb2ludEJ1ZmZlckJ1aWxkZXI6IENvZGVQb2ludEJ1ZmZlci5CdWlsZGVyID0gQ29kZVBvaW50QnVmZmVyLmJ1aWxkZXIoREVGQVVMVF9CVUZGRVJfU0laRSk7XHJcblx0Ly8gXHRcdGxldCBjaGFyQnVmZmVyOiBDaGFyQnVmZmVyID0gQ2hhckJ1ZmZlci5hbGxvY2F0ZShERUZBVUxUX0JVRkZFUl9TSVpFKTtcclxuXHQvLyBcdFx0d2hpbGUgKChyLnJlYWQoY2hhckJ1ZmZlcikpICE9PSAtMSkge1xyXG5cdC8vIFx0XHRcdGNoYXJCdWZmZXIuZmxpcCgpO1xyXG5cdC8vIFx0XHRcdGNvZGVQb2ludEJ1ZmZlckJ1aWxkZXIuYXBwZW5kKGNoYXJCdWZmZXIpO1xyXG5cdC8vIFx0XHRcdGNoYXJCdWZmZXIuY29tcGFjdCgpO1xyXG5cdC8vIFx0XHR9XHJcblxyXG5cdC8vIFx0XHRyZXR1cm4gQ29kZVBvaW50Q2hhclN0cmVhbS5mcm9tQnVmZmVyKGNvZGVQb2ludEJ1ZmZlckJ1aWxkZXIuYnVpbGQoKSwgc291cmNlTmFtZSk7XHJcblx0Ly8gXHR9IGZpbmFsbHkge1xyXG5cdC8vIFx0XHRyLmNsb3NlKCk7XHJcblx0Ly8gXHR9XHJcblx0Ly8gfVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEge0BsaW5rIENoYXJTdHJlYW19IGdpdmVuIGEge0BsaW5rIFN0cmluZ30uXHJcblx0ICovXHJcblx0ZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcoczogc3RyaW5nKTogQ29kZVBvaW50Q2hhclN0cmVhbTtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIHtAbGluayBDaGFyU3RyZWFtfSBnaXZlbiBhIHtAbGluayBTdHJpbmd9IGFuZCB0aGUge0Bjb2RlIHNvdXJjZU5hbWV9XHJcblx0ICogZnJvbSB3aGljaCBpdCBjYW1lLlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHM6IHN0cmluZywgc291cmNlTmFtZTogc3RyaW5nKTogQ29kZVBvaW50Q2hhclN0cmVhbTtcclxuXHRleHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyhzOiBzdHJpbmcsIHNvdXJjZU5hbWU/OiBzdHJpbmcpOiBDb2RlUG9pbnRDaGFyU3RyZWFtIHtcclxuXHRcdGlmIChzb3VyY2VOYW1lID09PSB1bmRlZmluZWQgfHwgc291cmNlTmFtZS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0c291cmNlTmFtZSA9IEludFN0cmVhbS5VTktOT1dOX1NPVVJDRV9OQU1FO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluaXRpYWwgZ3Vlc3MgYXNzdW1lcyBubyBjb2RlIHBvaW50cyA+IFUrRkZGRjogb25lIGNvZGVcclxuXHRcdC8vIHBvaW50IGZvciBlYWNoIGNvZGUgdW5pdCBpbiB0aGUgc3RyaW5nXHJcblx0XHRsZXQgY29kZVBvaW50QnVmZmVyQnVpbGRlcjogQ29kZVBvaW50QnVmZmVyLkJ1aWxkZXIgPSBDb2RlUG9pbnRCdWZmZXIuYnVpbGRlcihzLmxlbmd0aCk7XHJcblxyXG5cdFx0Ly8gVE9ETzogQ2hhckJ1ZmZlci53cmFwKFN0cmluZykgcmlnaHRmdWxseSByZXR1cm5zIGEgcmVhZC1vbmx5IGJ1ZmZlclxyXG5cdFx0Ly8gd2hpY2ggZG9lc24ndCBleHBvc2UgaXRzIGFycmF5LCBzbyB3ZSBtYWtlIGEgY29weS5cclxuXHRcdGxldCBjYjogVWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkocy5sZW5ndGgpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNiW2ldID0gcy5jaGFyQ29kZUF0KGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvZGVQb2ludEJ1ZmZlckJ1aWxkZXIuYXBwZW5kKGNiKTtcclxuXHRcdHJldHVybiBDb2RlUG9pbnRDaGFyU3RyZWFtLmZyb21CdWZmZXIoY29kZVBvaW50QnVmZmVyQnVpbGRlci5idWlsZCgpLCBzb3VyY2VOYW1lKTtcclxuXHR9XHJcblxyXG5cdC8vIGV4cG9ydCBmdW5jdGlvbiBidWZmZXJGcm9tQ2hhbm5lbChcclxuXHQvLyBcdGNoYW5uZWw6IFJlYWRhYmxlQnl0ZUNoYW5uZWwsXHJcblx0Ly8gXHRjaGFyc2V0OiBDaGFyc2V0LFxyXG5cdC8vIFx0YnVmZmVyU2l6ZTogbnVtYmVyLFxyXG5cdC8vIFx0ZGVjb2RpbmdFcnJvckFjdGlvbjogQ29kaW5nRXJyb3JBY3Rpb24sXHJcblx0Ly8gXHRpbnB1dFNpemU6IG51bWJlcik6IENvZGVQb2ludEJ1ZmZlciB7XHJcblx0Ly8gXHR0cnkge1xyXG5cdC8vIFx0XHRsZXQgdXRmOEJ5dGVzSW46IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJTaXplKTtcclxuXHQvLyBcdFx0bGV0IHV0ZjE2Q29kZVVuaXRzT3V0OiBVaW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheShidWZmZXJTaXplKTtcclxuXHQvLyBcdFx0aWYgKGlucHV0U2l6ZSA9PT0gLTEpIHtcclxuXHQvLyBcdFx0XHRpbnB1dFNpemUgPSBidWZmZXJTaXplO1xyXG5cdC8vIFx0XHR9IGVsc2UgaWYgKGlucHV0U2l6ZSA+IEludGVnZXIuTUFYX1ZBTFVFKSB7XHJcblx0Ly8gXHRcdFx0Ly8gQnl0ZUJ1ZmZlciBldCBhbCBkb24ndCBzdXBwb3J0IGxvbmcgc2l6ZXNcclxuXHQvLyBcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW5wdXRTaXplICR7aW5wdXRTaXplfSBsYXJnZXIgdGhhbiBtYXggJHtJbnRlZ2VyLk1BWF9WQUxVRX1gKTtcclxuXHQvLyBcdFx0fVxyXG5cclxuXHQvLyBcdFx0bGV0IGNvZGVQb2ludEJ1ZmZlckJ1aWxkZXI6IENvZGVQb2ludEJ1ZmZlci5CdWlsZGVyID0gQ29kZVBvaW50QnVmZmVyLmJ1aWxkZXIoaW5wdXRTaXplKTtcclxuXHQvLyBcdFx0bGV0IGRlY29kZXI6IENoYXJzZXREZWNvZGVyID0gY2hhcnNldFxyXG5cdC8vIFx0XHRcdFx0Lm5ld0RlY29kZXIoKVxyXG5cdC8vIFx0XHRcdFx0Lm9uTWFsZm9ybWVkSW5wdXQoZGVjb2RpbmdFcnJvckFjdGlvbilcclxuXHQvLyBcdFx0XHRcdC5vblVubWFwcGFibGVDaGFyYWN0ZXIoZGVjb2RpbmdFcnJvckFjdGlvbik7XHJcblxyXG5cdC8vIFx0XHRsZXQgZW5kT2ZJbnB1dDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdC8vIFx0XHR3aGlsZSAoIWVuZE9mSW5wdXQpIHtcclxuXHQvLyBcdFx0XHRsZXQgYnl0ZXNSZWFkOiBudW1iZXIgPSBjaGFubmVsLnJlYWQodXRmOEJ5dGVzSW4pO1xyXG5cdC8vIFx0XHRcdGVuZE9mSW5wdXQgPSAoYnl0ZXNSZWFkID09PSAtMSk7XHJcblx0Ly8gXHRcdFx0dXRmOEJ5dGVzSW4uZmxpcCgpO1xyXG5cdC8vIFx0XHRcdGxldCByZXN1bHQ6IENvZGVyUmVzdWx0ID0gZGVjb2Rlci5kZWNvZGUoXHJcblx0Ly8gXHRcdFx0XHR1dGY4Qnl0ZXNJbixcclxuXHQvLyBcdFx0XHRcdHV0ZjE2Q29kZVVuaXRzT3V0LFxyXG5cdC8vIFx0XHRcdFx0ZW5kT2ZJbnB1dCk7XHJcblx0Ly8gXHRcdFx0aWYgKHJlc3VsdC5pc0Vycm9yKCkgJiYgZGVjb2RpbmdFcnJvckFjdGlvbiA9PT0gQ29kaW5nRXJyb3JBY3Rpb24uUkVQT1JUKSB7XHJcblx0Ly8gXHRcdFx0XHRyZXN1bHQudGhyb3dFeGNlcHRpb24oKTtcclxuXHQvLyBcdFx0XHR9XHJcblxyXG5cdC8vIFx0XHRcdHV0ZjE2Q29kZVVuaXRzT3V0LmZsaXAoKTtcclxuXHQvLyBcdFx0XHRjb2RlUG9pbnRCdWZmZXJCdWlsZGVyLmFwcGVuZCh1dGYxNkNvZGVVbml0c091dCk7XHJcblx0Ly8gXHRcdFx0dXRmOEJ5dGVzSW4uY29tcGFjdCgpO1xyXG5cdC8vIFx0XHRcdHV0ZjE2Q29kZVVuaXRzT3V0LmNvbXBhY3QoKTtcclxuXHQvLyBcdFx0fVxyXG5cdC8vIFx0XHQvLyBIYW5kbGUgYW55IGJ5dGVzIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUgd2hpY2ggbmVlZCB0b1xyXG5cdC8vIFx0XHQvLyBiZSByZXByZXNlbnRlZCBhcyBlcnJvcnMgb3Igc3Vic3RpdHV0aW9uIGNoYXJhY3RlcnMuXHJcblx0Ly8gXHRcdGxldCBmbHVzaFJlc3VsdDogQ29kZXJSZXN1bHQgPSBkZWNvZGVyLmZsdXNoKHV0ZjE2Q29kZVVuaXRzT3V0KTtcclxuXHQvLyBcdFx0aWYgKGZsdXNoUmVzdWx0LmlzRXJyb3IoKSAmJiBkZWNvZGluZ0Vycm9yQWN0aW9uID09PSBDb2RpbmdFcnJvckFjdGlvbi5SRVBPUlQpIHtcclxuXHQvLyBcdFx0XHRmbHVzaFJlc3VsdC50aHJvd0V4Y2VwdGlvbigpO1xyXG5cdC8vIFx0XHR9XHJcblxyXG5cdC8vIFx0XHR1dGYxNkNvZGVVbml0c091dC5mbGlwKCk7XHJcblx0Ly8gXHRcdGNvZGVQb2ludEJ1ZmZlckJ1aWxkZXIuYXBwZW5kKHV0ZjE2Q29kZVVuaXRzT3V0KTtcclxuXHJcblx0Ly8gXHRcdHJldHVybiBjb2RlUG9pbnRCdWZmZXJCdWlsZGVyLmJ1aWxkKCk7XHJcblx0Ly8gXHR9XHJcblx0Ly8gXHRmaW5hbGx5IHtcclxuXHQvLyBcdFx0Y2hhbm5lbC5jbG9zZSgpO1xyXG5cdC8vIFx0fVxyXG5cdC8vIH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDkuNjA3NDM2NS0wNzowMFxyXG5cclxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcclxuaW1wb3J0IHsgQ29tbW9uVG9rZW4gfSBmcm9tIFwiLi9Db21tb25Ub2tlblwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9SdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuU291cmNlIH0gZnJvbSBcIi4vVG9rZW5Tb3VyY2VcIjtcclxuaW1wb3J0IHsgVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi9Ub2tlblN0cmVhbVwiO1xyXG5pbXBvcnQgeyBXcml0YWJsZVRva2VuIH0gZnJvbSBcIi4vV3JpdGFibGVUb2tlblwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFRva2VuU3RyZWFtfSBsb2FkcyB0b2tlbnMgZnJvbSBhXHJcbiAqIHtAbGluayBUb2tlblNvdXJjZX0gb24tZGVtYW5kLCBhbmQgcGxhY2VzIHRoZSB0b2tlbnMgaW4gYSBidWZmZXIgdG8gcHJvdmlkZVxyXG4gKiBhY2Nlc3MgdG8gYW55IHByZXZpb3VzIHRva2VuIGJ5IGluZGV4LlxyXG4gKlxyXG4gKiBUaGlzIHRva2VuIHN0cmVhbSBpZ25vcmVzIHRoZSB2YWx1ZSBvZiB7QGxpbmsgVG9rZW4jZ2V0Q2hhbm5lbH0uIElmIHlvdXJcclxuICogcGFyc2VyIHJlcXVpcmVzIHRoZSB0b2tlbiBzdHJlYW0gZmlsdGVyIHRva2VucyB0byBvbmx5IHRob3NlIG9uIGEgcGFydGljdWxhclxyXG4gKiBjaGFubmVsLCBzdWNoIGFzIHtAbGluayBUb2tlbiNERUZBVUxUX0NIQU5ORUx9IG9yXHJcbiAqIHtAbGluayBUb2tlbiNISURERU5fQ0hBTk5FTH0sIHVzZSBhIGZpbHRlcmluZyB0b2tlbiBzdHJlYW0gc3VjaCBhXHJcbiAqIHtAbGluayBDb21tb25Ub2tlblN0cmVhbX0uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQnVmZmVyZWRUb2tlblN0cmVhbSBpbXBsZW1lbnRzIFRva2VuU3RyZWFtIHtcclxuXHQvKipcclxuXHQgKiBUaGUge0BsaW5rIFRva2VuU291cmNlfSBmcm9tIHdoaWNoIHRva2VucyBmb3IgdGhpcyBzdHJlYW0gYXJlIGZldGNoZWQuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIF90b2tlblNvdXJjZTogVG9rZW5Tb3VyY2U7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEEgY29sbGVjdGlvbiBvZiBhbGwgdG9rZW5zIGZldGNoZWQgZnJvbSB0aGUgdG9rZW4gc291cmNlLiBUaGUgbGlzdCBpc1xyXG5cdCAqIGNvbnNpZGVyZWQgYSBjb21wbGV0ZSB2aWV3IG9mIHRoZSBpbnB1dCBvbmNlIHtAbGluayAjZmV0Y2hlZEVPRn0gaXMgc2V0XHJcblx0ICogdG8gYHRydWVgLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCB0b2tlbnM6IFRva2VuW10gPSBbXTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGluZGV4IGludG8ge0BsaW5rICN0b2tlbnN9IG9mIHRoZSBjdXJyZW50IHRva2VuIChuZXh0IHRva2VuIHRvXHJcblx0ICoge0BsaW5rICNjb25zdW1lfSkuIHtAbGluayAjdG9rZW5zfWBbYHtAbGluayAjcH1gXWAgc2hvdWxkIGJlXHJcblx0ICoge0BsaW5rICNMVCBMVCgxKX0uXHJcblx0ICpcclxuXHQgKiBUaGlzIGZpZWxkIGlzIHNldCB0byAtMSB3aGVuIHRoZSBzdHJlYW0gaXMgZmlyc3QgY29uc3RydWN0ZWQgb3Igd2hlblxyXG5cdCAqIHtAbGluayAjc2V0VG9rZW5Tb3VyY2V9IGlzIGNhbGxlZCwgaW5kaWNhdGluZyB0aGF0IHRoZSBmaXJzdCB0b2tlbiBoYXNcclxuXHQgKiBub3QgeWV0IGJlZW4gZmV0Y2hlZCBmcm9tIHRoZSB0b2tlbiBzb3VyY2UuIEZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLFxyXG5cdCAqIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvZiB7QGxpbmsgSW50U3RyZWFtfSBmb3IgYSBkZXNjcmlwdGlvbiBvZlxyXG5cdCAqIEluaXRpYWxpemluZyBNZXRob2RzLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBwOiBudW1iZXIgPSAtMTtcclxuXHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHtAbGluayBUb2tlbiNFT0Z9IHRva2VuIGhhcyBiZWVuIGZldGNoZWQgZnJvbVxyXG5cdCAqIHtAbGluayAjdG9rZW5Tb3VyY2V9IGFuZCBhZGRlZCB0byB7QGxpbmsgI3Rva2Vuc30uIFRoaXMgZmllbGQgaW1wcm92ZXNcclxuXHQgKiBwZXJmb3JtYW5jZSBmb3IgdGhlIGZvbGxvd2luZyBjYXNlczpcclxuXHQgKlxyXG5cdCAqICoge0BsaW5rICNjb25zdW1lfTogVGhlIGxvb2thaGVhZCBjaGVjayBpbiB7QGxpbmsgI2NvbnN1bWV9IHRvIHByZXZlbnRcclxuXHQgKiAgIGNvbnN1bWluZyB0aGUgRU9GIHN5bWJvbCBpcyBvcHRpbWl6ZWQgYnkgY2hlY2tpbmcgdGhlIHZhbHVlcyBvZlxyXG5cdCAqICAge0BsaW5rICNmZXRjaGVkRU9GfSBhbmQge0BsaW5rICNwfSBpbnN0ZWFkIG9mIGNhbGxpbmcge0BsaW5rICNMQX0uXHJcblx0ICogKiB7QGxpbmsgI2ZldGNofTogVGhlIGNoZWNrIHRvIHByZXZlbnQgYWRkaW5nIG11bHRpcGxlIEVPRiBzeW1ib2xzIGludG9cclxuXHQgKiAgIHtAbGluayAjdG9rZW5zfSBpcyB0cml2aWFsIHdpdGggdGhpcyBmaWVsZC5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgZmV0Y2hlZEVPRjogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCB0b2tlblNvdXJjZTogVG9rZW5Tb3VyY2UpIHtcclxuXHRcdGlmICh0b2tlblNvdXJjZSA9PSBudWxsKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInRva2VuU291cmNlIGNhbm5vdCBiZSBudWxsXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3Rva2VuU291cmNlID0gdG9rZW5Tb3VyY2U7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgdG9rZW5Tb3VyY2UoKTogVG9rZW5Tb3VyY2Uge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3Rva2VuU291cmNlO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlc2V0IHRoaXMgdG9rZW4gc3RyZWFtIGJ5IHNldHRpbmcgaXRzIHRva2VuIHNvdXJjZS4gKi9cclxuXHRzZXQgdG9rZW5Tb3VyY2UodG9rZW5Tb3VyY2U6IFRva2VuU291cmNlKSB7XHJcblx0XHR0aGlzLl90b2tlblNvdXJjZSA9IHRva2VuU291cmNlO1xyXG5cdFx0dGhpcy50b2tlbnMubGVuZ3RoID0gMDtcclxuXHRcdHRoaXMucCA9IC0xO1xyXG5cdFx0dGhpcy5mZXRjaGVkRU9GID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaW5kZXgoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLnA7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgbWFyaygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgcmVsZWFzZShtYXJrZXI6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Ly8gbm8gcmVzb3VyY2VzIHRvIHJlbGVhc2VcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBzZWVrKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMubGF6eUluaXQoKTtcclxuXHRcdHRoaXMucCA9IHRoaXMuYWRqdXN0U2Vla0luZGV4KGluZGV4KTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzaXplKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy50b2tlbnMubGVuZ3RoO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIGNvbnN1bWUoKTogdm9pZCB7XHJcblx0XHRsZXQgc2tpcEVvZkNoZWNrOiBib29sZWFuO1xyXG5cdFx0aWYgKHRoaXMucCA+PSAwKSB7XHJcblx0XHRcdGlmICh0aGlzLmZldGNoZWRFT0YpIHtcclxuXHRcdFx0XHQvLyB0aGUgbGFzdCB0b2tlbiBpbiB0b2tlbnMgaXMgRU9GLiBza2lwIGNoZWNrIGlmIHAgaW5kZXhlcyBhbnlcclxuXHRcdFx0XHQvLyBmZXRjaGVkIHRva2VuIGV4Y2VwdCB0aGUgbGFzdC5cclxuXHRcdFx0XHRza2lwRW9mQ2hlY2sgPSB0aGlzLnAgPCB0aGlzLnRva2Vucy5sZW5ndGggLSAxO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIG5vIEVPRiB0b2tlbiBpbiB0b2tlbnMuIHNraXAgY2hlY2sgaWYgcCBpbmRleGVzIGEgZmV0Y2hlZCB0b2tlbi5cclxuXHRcdFx0XHRza2lwRW9mQ2hlY2sgPSB0aGlzLnAgPCB0aGlzLnRva2Vucy5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcclxuXHRcdFx0c2tpcEVvZkNoZWNrID0gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFza2lwRW9mQ2hlY2sgJiYgdGhpcy5MQSgxKSA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb25zdW1lIEVPRlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5zeW5jKHRoaXMucCArIDEpKSB7XHJcblx0XHRcdHRoaXMucCA9IHRoaXMuYWRqdXN0U2Vla0luZGV4KHRoaXMucCArIDEpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqIE1ha2Ugc3VyZSBpbmRleCBgaWAgaW4gdG9rZW5zIGhhcyBhIHRva2VuLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIGEgdG9rZW4gaXMgbG9jYXRlZCBhdCBpbmRleCBgaWAsIG90aGVyd2lzZVxyXG5cdCAqICAgIGBmYWxzZWAuXHJcblx0ICogQHNlZSAjZ2V0KGludCBpKVxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBzeW5jKGk6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0YXNzZXJ0KGkgPj0gMCk7XHJcblx0XHRsZXQgbjogbnVtYmVyID0gaSAtIHRoaXMudG9rZW5zLmxlbmd0aCArIDE7IC8vIGhvdyBtYW55IG1vcmUgZWxlbWVudHMgd2UgbmVlZD9cclxuXHRcdC8vU3lzdGVtLm91dC5wcmludGxuKFwic3luYyhcIitpK1wiKSBuZWVkcyBcIituKTtcclxuXHRcdGlmIChuID4gMCkge1xyXG5cdFx0XHRsZXQgZmV0Y2hlZDogbnVtYmVyID0gdGhpcy5mZXRjaChuKTtcclxuXHRcdFx0cmV0dXJuIGZldGNoZWQgPj0gbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKiBBZGQgYG5gIGVsZW1lbnRzIHRvIGJ1ZmZlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBhY3R1YWwgbnVtYmVyIG9mIGVsZW1lbnRzIGFkZGVkIHRvIHRoZSBidWZmZXIuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGZldGNoKG46IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRpZiAodGhpcy5mZXRjaGVkRU9GKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdGxldCB0OiBUb2tlbiA9IHRoaXMudG9rZW5Tb3VyY2UubmV4dFRva2VuKCk7XHJcblx0XHRcdGlmICh0aGlzLmlzV3JpdGFibGVUb2tlbih0KSkge1xyXG5cdFx0XHRcdHQudG9rZW5JbmRleCA9IHRoaXMudG9rZW5zLmxlbmd0aDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy50b2tlbnMucHVzaCh0KTtcclxuXHRcdFx0aWYgKHQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdFx0dGhpcy5mZXRjaGVkRU9GID0gdHJ1ZTtcclxuXHRcdFx0XHRyZXR1cm4gaSArIDE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXQoaTogbnVtYmVyKTogVG9rZW4ge1xyXG5cdFx0aWYgKGkgPCAwIHx8IGkgPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwidG9rZW4gaW5kZXggXCIgKyBpICsgXCIgb3V0IG9mIHJhbmdlIDAuLlwiICsgKHRoaXMudG9rZW5zLmxlbmd0aCAtIDEpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy50b2tlbnNbaV07XHJcblx0fVxyXG5cclxuXHQvKiogR2V0IGFsbCB0b2tlbnMgZnJvbSBzdGFydC4uc3RvcCBpbmNsdXNpdmVseS4gKi9cclxuXHRwdWJsaWMgZ2V0UmFuZ2Uoc3RhcnQ6IG51bWJlciwgc3RvcDogbnVtYmVyKTogVG9rZW5bXSB7XHJcblx0XHRpZiAoc3RhcnQgPCAwIHx8IHN0b3AgPCAwKSB7XHJcblx0XHRcdHJldHVybiBbXTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmxhenlJbml0KCk7XHJcblx0XHRsZXQgc3Vic2V0OiBUb2tlbltdID0gbmV3IEFycmF5PFRva2VuPigpO1xyXG5cdFx0aWYgKHN0b3AgPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XHJcblx0XHRcdHN0b3AgPSB0aGlzLnRva2Vucy5sZW5ndGggLSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBzdG9wOyBpKyspIHtcclxuXHRcdFx0bGV0IHQ6IFRva2VuID0gdGhpcy50b2tlbnNbaV07XHJcblx0XHRcdGlmICh0LnR5cGUgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdWJzZXQucHVzaCh0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3Vic2V0O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIExBKGk6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRsZXQgdG9rZW4gPSB0aGlzLkxUKGkpO1xyXG5cdFx0aWYgKCF0b2tlbikge1xyXG5cdFx0XHRyZXR1cm4gVG9rZW4uSU5WQUxJRF9UWVBFO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0b2tlbi50eXBlO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHRyeUxCKGs6IG51bWJlcik6IFRva2VuIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICgodGhpcy5wIC0gaykgPCAwKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucCAtIGtdO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgTFQoazogbnVtYmVyKTogVG9rZW4ge1xyXG5cdFx0bGV0IHJlc3VsdCA9IHRoaXMudHJ5TFQoayk7XHJcblx0XHRpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJyZXF1ZXN0ZWQgbG9va2JhY2sgaW5kZXggb3V0IG9mIHJhbmdlXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdHJ5TFQoazogbnVtYmVyKTogVG9rZW4gfCB1bmRlZmluZWQge1xyXG5cdFx0dGhpcy5sYXp5SW5pdCgpO1xyXG5cdFx0aWYgKGsgPT09IDApIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCIwIGlzIG5vdCBhIHZhbGlkIGxvb2thaGVhZCBpbmRleFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoayA8IDApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudHJ5TEIoLWspO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBpOiBudW1iZXIgPSB0aGlzLnAgKyBrIC0gMTtcclxuXHRcdHRoaXMuc3luYyhpKTtcclxuXHRcdGlmIChpID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHQvLyByZXR1cm4gRU9GIHRva2VuXHJcblx0XHRcdC8vIEVPRiBtdXN0IGJlIGxhc3QgdG9rZW5cclxuXHRcdFx0cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHRcdGlmICggaT5yYW5nZSApIHJhbmdlID0gaTtcclxuXHRcdHJldHVybiB0aGlzLnRva2Vuc1tpXTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFsbG93ZWQgZGVyaXZlZCBjbGFzc2VzIHRvIG1vZGlmeSB0aGUgYmVoYXZpb3Igb2Ygb3BlcmF0aW9ucyB3aGljaCBjaGFuZ2VcclxuXHQgKiB0aGUgY3VycmVudCBzdHJlYW0gcG9zaXRpb24gYnkgYWRqdXN0aW5nIHRoZSB0YXJnZXQgdG9rZW4gaW5kZXggb2YgYSBzZWVrXHJcblx0ICogb3BlcmF0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW1wbHkgcmV0dXJucyBgaWAuIElmIGFuXHJcblx0ICogZXhjZXB0aW9uIGlzIHRocm93biBpbiB0aGlzIG1ldGhvZCwgdGhlIGN1cnJlbnQgc3RyZWFtIGluZGV4IHNob3VsZCBub3QgYmVcclxuXHQgKiBjaGFuZ2VkLlxyXG5cdCAqXHJcblx0ICogRm9yIGV4YW1wbGUsIHtAbGluayBDb21tb25Ub2tlblN0cmVhbX0gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kIHRvIGVuc3VyZSB0aGF0XHJcblx0ICogdGhlIHNlZWsgdGFyZ2V0IGlzIGFsd2F5cyBhbiBvbi1jaGFubmVsIHRva2VuLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGkgVGhlIHRhcmdldCB0b2tlbiBpbmRleC5cclxuXHQgKiBAcmV0dXJucyBUaGUgYWRqdXN0ZWQgdGFyZ2V0IHRva2VuIGluZGV4LlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBhZGp1c3RTZWVrSW5kZXgoaTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGxhenlJbml0KCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMucCA9PT0gLTEpIHtcclxuXHRcdFx0dGhpcy5zZXR1cCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHNldHVwKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5zeW5jKDApO1xyXG5cdFx0dGhpcy5wID0gdGhpcy5hZGp1c3RTZWVrSW5kZXgoMCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0VG9rZW5zKCk6IFRva2VuW107XHJcblxyXG5cdHB1YmxpYyBnZXRUb2tlbnMoc3RhcnQ6IG51bWJlciwgc3RvcDogbnVtYmVyKTogVG9rZW5bXTtcclxuXHJcblx0cHVibGljIGdldFRva2VucyhzdGFydDogbnVtYmVyLCBzdG9wOiBudW1iZXIsIHR5cGVzOiBTZXQ8bnVtYmVyPik6IFRva2VuW107XHJcblxyXG5cdHB1YmxpYyBnZXRUb2tlbnMoc3RhcnQ6IG51bWJlciwgc3RvcDogbnVtYmVyLCB0dHlwZTogbnVtYmVyKTogVG9rZW5bXTtcclxuXHJcblx0LyoqIEdpdmVuIGEgc3RhcnQgYW5kIHN0b3AgaW5kZXgsIHJldHVybiBhIGBMaXN0YCBvZiBhbGwgdG9rZW5zIGluXHJcblx0ICogIHRoZSB0b2tlbiB0eXBlIGBCaXRTZXRgLiAgUmV0dXJuIGFuIGVtcHR5IGFycmF5IGlmIG5vIHRva2VucyB3ZXJlIGZvdW5kLiAgVGhpc1xyXG5cdCAqICBtZXRob2QgbG9va3MgYXQgYm90aCBvbiBhbmQgb2ZmIGNoYW5uZWwgdG9rZW5zLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRUb2tlbnMoc3RhcnQ/OiBudW1iZXIsIHN0b3A/OiBudW1iZXIsIHR5cGVzPzogU2V0PG51bWJlcj4gfCBudW1iZXIpOiBUb2tlbltdIHtcclxuXHRcdHRoaXMubGF6eUluaXQoKTtcclxuXHJcblx0XHRpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRhc3NlcnQoc3RvcCA9PT0gdW5kZWZpbmVkICYmIHR5cGVzID09PSB1bmRlZmluZWQpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b2tlbnM7XHJcblx0XHR9IGVsc2UgaWYgKHN0b3AgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRzdG9wID0gdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3RhcnQgPCAwIHx8IHN0b3AgPj0gdGhpcy50b2tlbnMubGVuZ3RoIHx8IHN0b3AgPCAwIHx8IHN0YXJ0ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInN0YXJ0IFwiICsgc3RhcnQgKyBcIiBvciBzdG9wIFwiICsgc3RvcCArIFwiIG5vdCBpbiAwLi5cIiArICh0aGlzLnRva2Vucy5sZW5ndGggLSAxKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0YXJ0ID4gc3RvcCkge1xyXG5cdFx0XHRyZXR1cm4gW107XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVzID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9rZW5zLnNsaWNlKHN0YXJ0LCBzdG9wICsgMSk7XHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHR0eXBlcyA9IG5ldyBTZXQ8bnVtYmVyPigpLmFkZCh0eXBlcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHR5cGVzU2V0ID0gdHlwZXM7XHJcblxyXG5cdFx0Ly8gbGlzdCA9IHRva2Vuc1tzdGFydDpzdG9wXTp7VCB0LCB0LnR5cGUgaW4gdHlwZXN9XHJcblx0XHRsZXQgZmlsdGVyZWRUb2tlbnM6IFRva2VuW10gPSB0aGlzLnRva2Vucy5zbGljZShzdGFydCwgc3RvcCArIDEpO1xyXG5cdFx0ZmlsdGVyZWRUb2tlbnMgPSBmaWx0ZXJlZFRva2Vucy5maWx0ZXIoKHZhbHVlKSA9PiB0eXBlc1NldC5oYXModmFsdWUudHlwZSkpO1xyXG5cclxuXHRcdHJldHVybiBmaWx0ZXJlZFRva2VucztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdpdmVuIGEgc3RhcnRpbmcgaW5kZXgsIHJldHVybiB0aGUgaW5kZXggb2YgdGhlIG5leHQgdG9rZW4gb24gY2hhbm5lbC5cclxuXHQgKiBSZXR1cm4gYGlgIGlmIGB0b2tlbnNbaV1gIGlzIG9uIGNoYW5uZWwuIFJldHVybiB0aGUgaW5kZXggb2ZcclxuXHQgKiB0aGUgRU9GIHRva2VuIGlmIHRoZXJlIGFyZSBubyB0b2tlbnMgb24gY2hhbm5lbCBiZXR3ZWVuIGBpYCBhbmRcclxuXHQgKiBFT0YuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIG5leHRUb2tlbk9uQ2hhbm5lbChpOiBudW1iZXIsIGNoYW5uZWw6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHR0aGlzLnN5bmMoaSk7XHJcblx0XHRpZiAoaSA+PSB0aGlzLnNpemUpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2l6ZSAtIDE7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHRva2VuOiBUb2tlbiA9IHRoaXMudG9rZW5zW2ldO1xyXG5cdFx0d2hpbGUgKHRva2VuLmNoYW5uZWwgIT09IGNoYW5uZWwpIHtcclxuXHRcdFx0aWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpKys7XHJcblx0XHRcdHRoaXMuc3luYyhpKTtcclxuXHRcdFx0dG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdpdmVuIGEgc3RhcnRpbmcgaW5kZXgsIHJldHVybiB0aGUgaW5kZXggb2YgdGhlIHByZXZpb3VzIHRva2VuIG9uXHJcblx0ICogY2hhbm5lbC4gUmV0dXJuIGBpYCBpZiBgdG9rZW5zW2ldYCBpcyBvbiBjaGFubmVsLiBSZXR1cm4gLTFcclxuXHQgKiBpZiB0aGVyZSBhcmUgbm8gdG9rZW5zIG9uIGNoYW5uZWwgYmV0d2VlbiBgaWAgYW5kIDAuXHJcblx0ICpcclxuXHQgKiBJZiBgaWAgc3BlY2lmaWVzIGFuIGluZGV4IGF0IG9yIGFmdGVyIHRoZSBFT0YgdG9rZW4sIHRoZSBFT0YgdG9rZW5cclxuXHQgKiBpbmRleCBpcyByZXR1cm5lZC4gVGhpcyBpcyBkdWUgdG8gdGhlIGZhY3QgdGhhdCB0aGUgRU9GIHRva2VuIGlzIHRyZWF0ZWRcclxuXHQgKiBhcyB0aG91Z2ggaXQgd2VyZSBvbiBldmVyeSBjaGFubmVsLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBwcmV2aW91c1Rva2VuT25DaGFubmVsKGk6IG51bWJlciwgY2hhbm5lbDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHRoaXMuc3luYyhpKTtcclxuXHRcdGlmIChpID49IHRoaXMuc2l6ZSkge1xyXG5cdFx0XHQvLyB0aGUgRU9GIHRva2VuIGlzIG9uIGV2ZXJ5IGNoYW5uZWxcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2l6ZSAtIDE7XHJcblx0XHR9XHJcblxyXG5cdFx0d2hpbGUgKGkgPj0gMCkge1xyXG5cdFx0XHRsZXQgdG9rZW46IFRva2VuID0gdGhpcy50b2tlbnNbaV07XHJcblx0XHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YgfHwgdG9rZW4uY2hhbm5lbCA9PT0gY2hhbm5lbCkge1xyXG5cdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpLS07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGk7XHJcblx0fVxyXG5cclxuXHQvKiogQ29sbGVjdCBhbGwgdG9rZW5zIG9uIHNwZWNpZmllZCBjaGFubmVsIHRvIHRoZSByaWdodCBvZlxyXG5cdCAqICB0aGUgY3VycmVudCB0b2tlbiB1cCB1bnRpbCB3ZSBzZWUgYSB0b2tlbiBvbiB7QGxpbmsgTGV4ZXIjREVGQVVMVF9UT0tFTl9DSEFOTkVMfSBvclxyXG5cdCAqICBFT0YuIElmIGBjaGFubmVsYCBpcyBgLTFgLCBmaW5kIGFueSBub24gZGVmYXVsdCBjaGFubmVsIHRva2VuLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRIaWRkZW5Ub2tlbnNUb1JpZ2h0KHRva2VuSW5kZXg6IG51bWJlciwgY2hhbm5lbDogbnVtYmVyID0gLTEpOiBUb2tlbltdIHtcclxuXHRcdHRoaXMubGF6eUluaXQoKTtcclxuXHRcdGlmICh0b2tlbkluZGV4IDwgMCB8fCB0b2tlbkluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcih0b2tlbkluZGV4ICsgXCIgbm90IGluIDAuLlwiICsgKHRoaXMudG9rZW5zLmxlbmd0aCAtIDEpKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbmV4dE9uQ2hhbm5lbDogbnVtYmVyID0gdGhpcy5uZXh0VG9rZW5PbkNoYW5uZWwodG9rZW5JbmRleCArIDEsIExleGVyLkRFRkFVTFRfVE9LRU5fQ0hBTk5FTCk7XHJcblx0XHRsZXQgdG86IG51bWJlcjtcclxuXHRcdGxldCBmcm9tOiBudW1iZXIgPSB0b2tlbkluZGV4ICsgMTtcclxuXHRcdC8vIGlmIG5vbmUgb25jaGFubmVsIHRvIHJpZ2h0LCBuZXh0T25DaGFubmVsPS0xIHNvIHNldCB0byA9IGxhc3QgdG9rZW5cclxuXHRcdGlmIChuZXh0T25DaGFubmVsID09PSAtMSkge1xyXG5cdFx0XHR0byA9IHRoaXMuc2l6ZSAtIDE7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0byA9IG5leHRPbkNoYW5uZWw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyRm9yQ2hhbm5lbChmcm9tLCB0bywgY2hhbm5lbCk7XHJcblx0fVxyXG5cclxuXHQvKiogQ29sbGVjdCBhbGwgdG9rZW5zIG9uIHNwZWNpZmllZCBjaGFubmVsIHRvIHRoZSBsZWZ0IG9mXHJcblx0ICogIHRoZSBjdXJyZW50IHRva2VuIHVwIHVudGlsIHdlIHNlZSBhIHRva2VuIG9uIHtAbGluayBMZXhlciNERUZBVUxUX1RPS0VOX0NIQU5ORUx9LlxyXG5cdCAqICBJZiBgY2hhbm5lbGAgaXMgYC0xYCwgZmluZCBhbnkgbm9uIGRlZmF1bHQgY2hhbm5lbCB0b2tlbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0SGlkZGVuVG9rZW5zVG9MZWZ0KHRva2VuSW5kZXg6IG51bWJlciwgY2hhbm5lbDogbnVtYmVyID0gLTEpOiBUb2tlbltdIHtcclxuXHRcdHRoaXMubGF6eUluaXQoKTtcclxuXHRcdGlmICh0b2tlbkluZGV4IDwgMCB8fCB0b2tlbkluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcih0b2tlbkluZGV4ICsgXCIgbm90IGluIDAuLlwiICsgKHRoaXMudG9rZW5zLmxlbmd0aCAtIDEpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodG9rZW5JbmRleCA9PT0gMCkge1xyXG5cdFx0XHQvLyBvYnZpb3VzbHkgbm8gdG9rZW5zIGNhbiBhcHBlYXIgYmVmb3JlIHRoZSBmaXJzdCB0b2tlblxyXG5cdFx0XHRyZXR1cm4gW107XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHByZXZPbkNoYW5uZWw6IG51bWJlciA9IHRoaXMucHJldmlvdXNUb2tlbk9uQ2hhbm5lbCh0b2tlbkluZGV4IC0gMSwgTGV4ZXIuREVGQVVMVF9UT0tFTl9DSEFOTkVMKTtcclxuXHRcdGlmIChwcmV2T25DaGFubmVsID09PSB0b2tlbkluZGV4IC0gMSkge1xyXG5cdFx0XHRyZXR1cm4gW107XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgbm9uZSBvbmNoYW5uZWwgdG8gbGVmdCwgcHJldk9uQ2hhbm5lbD0tMSB0aGVuIGZyb209MFxyXG5cdFx0bGV0IGZyb206IG51bWJlciA9IHByZXZPbkNoYW5uZWwgKyAxO1xyXG5cdFx0bGV0IHRvOiBudW1iZXIgPSB0b2tlbkluZGV4IC0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXJGb3JDaGFubmVsKGZyb20sIHRvLCBjaGFubmVsKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBmaWx0ZXJGb3JDaGFubmVsKGZyb206IG51bWJlciwgdG86IG51bWJlciwgY2hhbm5lbDogbnVtYmVyKTogVG9rZW5bXSB7XHJcblx0XHRsZXQgaGlkZGVuOiBUb2tlbltdID0gbmV3IEFycmF5PFRva2VuPigpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IGZyb207IGkgPD0gdG87IGkrKykge1xyXG5cdFx0XHRsZXQgdDogVG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcclxuXHRcdFx0aWYgKGNoYW5uZWwgPT09IC0xKSB7XHJcblx0XHRcdFx0aWYgKHQuY2hhbm5lbCAhPT0gTGV4ZXIuREVGQVVMVF9UT0tFTl9DSEFOTkVMKSB7XHJcblx0XHRcdFx0XHRoaWRkZW4ucHVzaCh0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKHQuY2hhbm5lbCA9PT0gY2hhbm5lbCkge1xyXG5cdFx0XHRcdFx0aGlkZGVuLnB1c2godCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGhpZGRlbjtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzb3VyY2VOYW1lKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy50b2tlblNvdXJjZS5zb3VyY2VOYW1lO1xyXG5cdH1cclxuXHJcblx0LyoqIEdldCB0aGUgdGV4dCBvZiBhbGwgdG9rZW5zIGluIHRoaXMgYnVmZmVyLiAqL1xyXG5cdHB1YmxpYyBnZXRUZXh0KCk6IHN0cmluZztcclxuXHRwdWJsaWMgZ2V0VGV4dChpbnRlcnZhbDogSW50ZXJ2YWwpOiBzdHJpbmc7XHJcblx0cHVibGljIGdldFRleHQoY29udGV4dDogUnVsZUNvbnRleHQpOiBzdHJpbmc7XHJcblx0QE5vdE51bGxcclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0VGV4dChpbnRlcnZhbD86IEludGVydmFsIHwgUnVsZUNvbnRleHQpOiBzdHJpbmcge1xyXG5cdFx0aWYgKGludGVydmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aW50ZXJ2YWwgPSBJbnRlcnZhbC5vZigwLCB0aGlzLnNpemUgLSAxKTtcclxuXHRcdH0gZWxzZSBpZiAoIShpbnRlcnZhbCBpbnN0YW5jZW9mIEludGVydmFsKSkge1xyXG5cdFx0XHQvLyBOb3RlOiB0aGUgbW9yZSBvYnZpb3VzIGNoZWNrIGZvciAnaW5zdGFuY2VvZiBSdWxlQ29udGV4dCcgcmVzdWx0cyBpbiBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgcHJvYmxlbVxyXG5cdFx0XHRpbnRlcnZhbCA9IGludGVydmFsLnNvdXJjZUludGVydmFsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBzdGFydDogbnVtYmVyID0gaW50ZXJ2YWwuYTtcclxuXHRcdGxldCBzdG9wOiBudW1iZXIgPSBpbnRlcnZhbC5iO1xyXG5cdFx0aWYgKHN0YXJ0IDwgMCB8fCBzdG9wIDwgMCkge1xyXG5cdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmZpbGwoKTtcclxuXHRcdGlmIChzdG9wID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHRzdG9wID0gdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYnVmOiBzdHJpbmcgPSBcIlwiO1xyXG5cdFx0Zm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IHN0b3A7IGkrKykge1xyXG5cdFx0XHRsZXQgdDogVG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcclxuXHRcdFx0aWYgKHQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJ1ZiArPSB0LnRleHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJ1Zi50b1N0cmluZygpO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0VGV4dEZyb21SYW5nZShzdGFydDogYW55LCBzdG9wOiBhbnkpOiBzdHJpbmcge1xyXG5cdFx0aWYgKHRoaXMuaXNUb2tlbihzdGFydCkgJiYgdGhpcy5pc1Rva2VuKHN0b3ApKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldFRleHQoSW50ZXJ2YWwub2Yoc3RhcnQudG9rZW5JbmRleCwgc3RvcC50b2tlbkluZGV4KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFwiXCI7XHJcblx0fVxyXG5cclxuXHQvKiogR2V0IGFsbCB0b2tlbnMgZnJvbSBsZXhlciB1bnRpbCBFT0YuICovXHJcblx0cHVibGljIGZpbGwoKTogdm9pZCB7XHJcblx0XHR0aGlzLmxhenlJbml0KCk7XHJcblx0XHRjb25zdCBibG9ja1NpemU6IG51bWJlciA9IDEwMDA7XHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRsZXQgZmV0Y2hlZDogbnVtYmVyID0gdGhpcy5mZXRjaChibG9ja1NpemUpO1xyXG5cdFx0XHRpZiAoZmV0Y2hlZCA8IGJsb2NrU2l6ZSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gVE9ETzogRmlndXJlIG91dCBhIHdheSB0byBtYWtlIHRoaXMgbW9yZSBmbGV4aWJsZT9cclxuXHRwcml2YXRlIGlzV3JpdGFibGVUb2tlbih0OiBUb2tlbik6IHQgaXMgV3JpdGFibGVUb2tlbiB7XHJcblx0XHRyZXR1cm4gdCBpbnN0YW5jZW9mIENvbW1vblRva2VuO1xyXG5cdH1cclxuXHJcblx0Ly8gVE9ETzogRmlndXJlIG91dCBhIHdheSB0byBtYWtlIHRoaXMgbW9yZSBmbGV4aWJsZT9cclxuXHRwcml2YXRlIGlzVG9rZW4odDogYW55KTogdCBpcyBUb2tlbiB7XHJcblx0XHRyZXR1cm4gdCBpbnN0YW5jZW9mIENvbW1vblRva2VuO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTAuMzk1MzE1Ny0wNzowMFxyXG5cclxuaW1wb3J0IHsgQnVmZmVyZWRUb2tlblN0cmVhbSB9IGZyb20gXCIuL0J1ZmZlcmVkVG9rZW5TdHJlYW1cIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5Tb3VyY2UgfSBmcm9tIFwiLi9Ub2tlblNvdXJjZVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgZXh0ZW5kcyB7QGxpbmsgQnVmZmVyZWRUb2tlblN0cmVhbX0gd2l0aCBmdW5jdGlvbmFsaXR5IHRvIGZpbHRlclxyXG4gKiB0b2tlbiBzdHJlYW1zIHRvIHRva2VucyBvbiBhIHBhcnRpY3VsYXIgY2hhbm5lbCAodG9rZW5zIHdoZXJlXHJcbiAqIHtAbGluayBUb2tlbiNnZXRDaGFubmVsfSByZXR1cm5zIGEgcGFydGljdWxhciB2YWx1ZSkuXHJcbiAqXHJcbiAqIFRoaXMgdG9rZW4gc3RyZWFtIHByb3ZpZGVzIGFjY2VzcyB0byBhbGwgdG9rZW5zIGJ5IGluZGV4IG9yIHdoZW4gY2FsbGluZ1xyXG4gKiBtZXRob2RzIGxpa2Uge0BsaW5rICNnZXRUZXh0fS4gVGhlIGNoYW5uZWwgZmlsdGVyaW5nIGlzIG9ubHkgdXNlZCBmb3IgY29kZVxyXG4gKiBhY2Nlc3NpbmcgdG9rZW5zIHZpYSB0aGUgbG9va2FoZWFkIG1ldGhvZHMge0BsaW5rICNMQX0sIHtAbGluayAjTFR9LCBhbmRcclxuICoge0BsaW5rICNMQn0uXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQsIHRva2VucyBhcmUgcGxhY2VkIG9uIHRoZSBkZWZhdWx0IGNoYW5uZWxcclxuICogKHtAbGluayBUb2tlbiNERUZBVUxUX0NIQU5ORUx9KSwgYnV0IG1heSBiZSByZWFzc2lnbmVkIGJ5IHVzaW5nIHRoZVxyXG4gKiBgLT5jaGFubmVsKEhJRERFTilgIGxleGVyIGNvbW1hbmQsIG9yIGJ5IHVzaW5nIGFuIGVtYmVkZGVkIGFjdGlvbiB0b1xyXG4gKiBjYWxsIHtAbGluayBMZXhlciNzZXRDaGFubmVsfS5cclxuICpcclxuICogTm90ZTogbGV4ZXIgcnVsZXMgd2hpY2ggdXNlIHRoZSBgLT5za2lwYCBsZXhlciBjb21tYW5kIG9yIGNhbGxcclxuICoge0BsaW5rIExleGVyI3NraXB9IGRvIG5vdCBwcm9kdWNlIHRva2VucyBhdCBhbGwsIHNvIGlucHV0IHRleHQgbWF0Y2hlZCBieVxyXG4gKiBzdWNoIGEgcnVsZSB3aWxsIG5vdCBiZSBhdmFpbGFibGUgYXMgcGFydCBvZiB0aGUgdG9rZW4gc3RyZWFtLCByZWdhcmRsZXNzIG9mXHJcbiAqIGNoYW5uZWwuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ29tbW9uVG9rZW5TdHJlYW0gZXh0ZW5kcyBCdWZmZXJlZFRva2VuU3RyZWFtIHtcclxuXHQvKipcclxuXHQgKiBTcGVjaWZpZXMgdGhlIGNoYW5uZWwgdG8gdXNlIGZvciBmaWx0ZXJpbmcgdG9rZW5zLlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMge0BsaW5rIFRva2VuI0RFRkFVTFRfQ0hBTk5FTH0sIHdoaWNoIG1hdGNoZXMgdGhlXHJcblx0ICogZGVmYXVsdCBjaGFubmVsIGFzc2lnbmVkIHRvIHRva2VucyBjcmVhdGVkIGJ5IHRoZSBsZXhlci5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgY2hhbm5lbDogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHtAbGluayBDb21tb25Ub2tlblN0cmVhbX0gdXNpbmcgdGhlIHNwZWNpZmllZCB0b2tlblxyXG5cdCAqIHNvdXJjZSBhbmQgZmlsdGVyaW5nIHRva2VucyB0byB0aGUgc3BlY2lmaWVkIGNoYW5uZWwuIE9ubHkgdG9rZW5zIHdob3NlXHJcblx0ICoge0BsaW5rIFRva2VuI2dldENoYW5uZWx9IG1hdGNoZXMgYGNoYW5uZWxgIG9yIGhhdmUgdGhlXHJcblx0ICogYFRva2VuLnR5cGVgIGVxdWFsIHRvIHtAbGluayBUb2tlbiNFT0Z9IHdpbGwgYmUgcmV0dXJuZWQgYnkgdGhlXHJcblx0ICogdG9rZW4gc3RyZWFtIGxvb2thaGVhZCBtZXRob2RzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHRva2VuU291cmNlIFRoZSB0b2tlbiBzb3VyY2UuXHJcblx0ICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gdXNlIGZvciBmaWx0ZXJpbmcgdG9rZW5zLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHRva2VuU291cmNlOiBUb2tlblNvdXJjZSwgY2hhbm5lbDogbnVtYmVyID0gVG9rZW4uREVGQVVMVF9DSEFOTkVMKSB7XHJcblx0XHRzdXBlcih0b2tlblNvdXJjZSk7XHJcblx0XHR0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIGFkanVzdFNlZWtJbmRleChpOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMubmV4dFRva2VuT25DaGFubmVsKGksIHRoaXMuY2hhbm5lbCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgdHJ5TEIoazogbnVtYmVyKTogVG9rZW4gfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKCh0aGlzLnAgLSBrKSA8IDApIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgaTogbnVtYmVyID0gdGhpcy5wO1xyXG5cdFx0bGV0IG46IG51bWJlciA9IDE7XHJcblx0XHQvLyBmaW5kIGsgZ29vZCB0b2tlbnMgbG9va2luZyBiYWNrd2FyZHNcclxuXHRcdHdoaWxlIChuIDw9IGsgJiYgaSA+IDApIHtcclxuXHRcdFx0Ly8gc2tpcCBvZmYtY2hhbm5lbCB0b2tlbnNcclxuXHRcdFx0aSA9IHRoaXMucHJldmlvdXNUb2tlbk9uQ2hhbm5lbChpIC0gMSwgdGhpcy5jaGFubmVsKTtcclxuXHRcdFx0bisrO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpIDwgMCkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnRva2Vuc1tpXTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0cnlMVChrOiBudW1iZXIpOiBUb2tlbiB8IHVuZGVmaW5lZCB7XHJcblx0XHQvL1N5c3RlbS5vdXQucHJpbnRsbihcImVudGVyIExUKFwiK2srXCIpXCIpO1xyXG5cdFx0dGhpcy5sYXp5SW5pdCgpO1xyXG5cdFx0aWYgKGsgPT09IDApIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCIwIGlzIG5vdCBhIHZhbGlkIGxvb2thaGVhZCBpbmRleFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoayA8IDApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudHJ5TEIoLWspO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBpOiBudW1iZXIgPSB0aGlzLnA7XHJcblx0XHRsZXQgbjogbnVtYmVyID0gMTsgLy8gd2Uga25vdyB0b2tlbnNbcF0gaXMgYSBnb29kIG9uZVxyXG5cdFx0Ly8gZmluZCBrIGdvb2QgdG9rZW5zXHJcblx0XHR3aGlsZSAobiA8IGspIHtcclxuXHRcdFx0Ly8gc2tpcCBvZmYtY2hhbm5lbCB0b2tlbnMsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGxvb2sgcGFzdCBFT0ZcclxuXHRcdFx0aWYgKHRoaXMuc3luYyhpICsgMSkpIHtcclxuXHRcdFx0XHRpID0gdGhpcy5uZXh0VG9rZW5PbkNoYW5uZWwoaSArIDEsIHRoaXMuY2hhbm5lbCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bisrO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHRcdGlmICggaT5yYW5nZSApIHJhbmdlID0gaTtcclxuXHRcdHJldHVybiB0aGlzLnRva2Vuc1tpXTtcclxuXHR9XHJcblxyXG5cdC8qKiBDb3VudCBFT0YganVzdCBvbmNlLiAqL1xyXG5cdHB1YmxpYyBnZXROdW1iZXJPZk9uQ2hhbm5lbFRva2VucygpOiBudW1iZXIge1xyXG5cdFx0bGV0IG46IG51bWJlciA9IDA7XHJcblx0XHR0aGlzLmZpbGwoKTtcclxuXHRcdGZvciAobGV0IHQgb2YgdGhpcy50b2tlbnMpIHtcclxuXHRcdFx0aWYgKHQuY2hhbm5lbCA9PT0gdGhpcy5jaGFubmVsKSB7XHJcblx0XHRcdFx0bisrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodC50eXBlID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTIuMTkxNjk1NS0wNzowMFxyXG5cclxuaW1wb3J0IHsgQ2hhclN0cmVhbSB9IGZyb20gXCIuL0NoYXJTdHJlYW1cIjtcclxuaW1wb3J0IHsgQ29tbW9uVG9rZW5GYWN0b3J5IH0gZnJvbSBcIi4vQ29tbW9uVG9rZW5GYWN0b3J5XCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuRmFjdG9yeSB9IGZyb20gXCIuL1Rva2VuRmFjdG9yeVwiO1xyXG5pbXBvcnQgeyBUb2tlblNvdXJjZSB9IGZyb20gXCIuL1Rva2VuU291cmNlXCI7XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFRva2VuU291cmNlfSBhcyBhIHdyYXBwZXIgYXJvdW5kIGEgbGlzdFxyXG4gKiBvZiB7QGxpbmsgVG9rZW59IG9iamVjdHMuXHJcbiAqXHJcbiAqIElmIHRoZSBmaW5hbCB0b2tlbiBpbiB0aGUgbGlzdCBpcyBhbiB7QGxpbmsgVG9rZW4jRU9GfSB0b2tlbiwgaXQgd2lsbCBiZSB1c2VkXHJcbiAqIGFzIHRoZSBFT0YgdG9rZW4gZm9yIGV2ZXJ5IGNhbGwgdG8ge0BsaW5rICNuZXh0VG9rZW59IGFmdGVyIHRoZSBlbmQgb2YgdGhlXHJcbiAqIGxpc3QgaXMgcmVhY2hlZC4gT3RoZXJ3aXNlLCBhbiBFT0YgdG9rZW4gd2lsbCBiZSBjcmVhdGVkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExpc3RUb2tlblNvdXJjZSBpbXBsZW1lbnRzIFRva2VuU291cmNlIHtcclxuXHQvKipcclxuXHQgKiBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uIG9mIHtAbGluayBUb2tlbn0gb2JqZWN0cyB0byByZXR1cm4uXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHRva2VuczogVG9rZW5bXTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG5hbWUgb2YgdGhlIGlucHV0IHNvdXJjZS4gSWYgdGhpcyB2YWx1ZSBpcyBgdW5kZWZpbmVkYCwgYSBjYWxsIHRvXHJcblx0ICoge0BsaW5rICNnZXRTb3VyY2VOYW1lfSBzaG91bGQgcmV0dXJuIHRoZSBzb3VyY2UgbmFtZSB1c2VkIHRvIGNyZWF0ZSB0aGVcclxuXHQgKiB0aGUgbmV4dCB0b2tlbiBpbiB7QGxpbmsgI3Rva2Vuc30gKG9yIHRoZSBwcmV2aW91cyB0b2tlbiBpZiB0aGUgZW5kIG9mXHJcblx0ICogdGhlIGlucHV0IGhhcyBiZWVuIHJlYWNoZWQpLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX3NvdXJjZU5hbWU/OiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBpbmRleCBpbnRvIHtAbGluayAjdG9rZW5zfSBvZiB0b2tlbiB0byByZXR1cm4gYnkgdGhlIG5leHQgY2FsbCB0b1xyXG5cdCAqIHtAbGluayAjbmV4dFRva2VufS4gVGhlIGVuZCBvZiB0aGUgaW5wdXQgaXMgaW5kaWNhdGVkIGJ5IHRoaXMgdmFsdWVcclxuXHQgKiBiZWluZyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBpdGVtcyBpbiB7QGxpbmsgI3Rva2Vuc30uXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGk6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgZmllbGQgY2FjaGVzIHRoZSBFT0YgdG9rZW4gZm9yIHRoZSB0b2tlbiBzb3VyY2UuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGVvZlRva2VuPzogVG9rZW47XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIHtAbGluayAjZ2V0VG9rZW5GYWN0b3J5fSBhbmRcclxuXHQgKiB7QGxpbmsgc2V0VG9rZW5GYWN0b3J5fS5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9mYWN0b3J5OiBUb2tlbkZhY3RvcnkgPSBDb21tb25Ub2tlbkZhY3RvcnkuREVGQVVMVDtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyB7QGxpbmsgTGlzdFRva2VuU291cmNlfSBpbnN0YW5jZSBmcm9tIHRoZSBzcGVjaWZpZWRcclxuXHQgKiBjb2xsZWN0aW9uIG9mIHtAbGluayBUb2tlbn0gb2JqZWN0cyBhbmQgc291cmNlIG5hbWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gdG9rZW5zIFRoZSBjb2xsZWN0aW9uIG9mIHtAbGluayBUb2tlbn0gb2JqZWN0cyB0byBwcm92aWRlIGFzIGFcclxuXHQgKiB7QGxpbmsgVG9rZW5Tb3VyY2V9LlxyXG5cdCAqIEBwYXJhbSBzb3VyY2VOYW1lIFRoZSBuYW1lIG9mIHRoZSB7QGxpbmsgVG9rZW5Tb3VyY2V9LiBJZiB0aGlzIHZhbHVlIGlzXHJcblx0ICogYHVuZGVmaW5lZGAsIHtAbGluayAjZ2V0U291cmNlTmFtZX0gd2lsbCBhdHRlbXB0IHRvIGluZmVyIHRoZSBuYW1lIGZyb21cclxuXHQgKiB0aGUgbmV4dCB7QGxpbmsgVG9rZW59IChvciB0aGUgcHJldmlvdXMgdG9rZW4gaWYgdGhlIGVuZCBvZiB0aGUgaW5wdXQgaGFzXHJcblx0ICogYmVlbiByZWFjaGVkKS5cclxuXHQgKlxyXG5cdCAqIEBleGNlcHRpb24gTnVsbFBvaW50ZXJFeGNlcHRpb24gaWYgYHRva2Vuc2AgaXMgYHVuZGVmaW5lZGBcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCB0b2tlbnM6IFRva2VuW10sIHNvdXJjZU5hbWU/OiBzdHJpbmcpIHtcclxuXHRcdGlmICh0b2tlbnMgPT0gbnVsbCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0b2tlbnMgY2Fubm90IGJlIG51bGxcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy50b2tlbnMgPSB0b2tlbnM7XHJcblx0XHR0aGlzLl9zb3VyY2VOYW1lID0gc291cmNlTmFtZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgY2hhclBvc2l0aW9uSW5MaW5lKCk6IG51bWJlciB7XHJcblx0XHRpZiAodGhpcy5pIDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLmldLmNoYXJQb3NpdGlvbkluTGluZTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5lb2ZUb2tlbiAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVvZlRva2VuLmNoYXJQb3NpdGlvbkluTGluZTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy50b2tlbnMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHQvLyBoYXZlIHRvIGNhbGN1bGF0ZSB0aGUgcmVzdWx0IGZyb20gdGhlIGxpbmUvY29sdW1uIG9mIHRoZSBwcmV2aW91c1xyXG5cdFx0XHQvLyB0b2tlbiwgYWxvbmcgd2l0aCB0aGUgdGV4dCBvZiB0aGUgdG9rZW4uXHJcblx0XHRcdGxldCBsYXN0VG9rZW46IFRva2VuID0gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV07XHJcblx0XHRcdGxldCB0b2tlblRleHQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9IGxhc3RUb2tlbi50ZXh0O1xyXG5cdFx0XHRpZiAodG9rZW5UZXh0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRsZXQgbGFzdE5ld0xpbmU6IG51bWJlciA9IHRva2VuVGV4dC5sYXN0SW5kZXhPZihcIlxcblwiKTtcclxuXHRcdFx0XHRpZiAobGFzdE5ld0xpbmUgPj0gMCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRva2VuVGV4dC5sZW5ndGggLSBsYXN0TmV3TGluZSAtIDE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbGFzdFRva2VuLmNoYXJQb3NpdGlvbkluTGluZSArIGxhc3RUb2tlbi5zdG9wSW5kZXggLSBsYXN0VG9rZW4uc3RhcnRJbmRleCArIDE7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb25seSByZWFjaCB0aGlzIGlmIHRva2VucyBpcyBlbXB0eSwgbWVhbmluZyBFT0Ygb2NjdXJzIGF0IHRoZSBmaXJzdFxyXG5cdFx0Ly8gcG9zaXRpb24gaW4gdGhlIGlucHV0XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgbmV4dFRva2VuKCk6IFRva2VuIHtcclxuXHRcdGlmICh0aGlzLmkgPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XHJcblx0XHRcdGlmICh0aGlzLmVvZlRva2VuID09IG51bGwpIHtcclxuXHRcdFx0XHRsZXQgc3RhcnQ6IG51bWJlciA9IC0xO1xyXG5cdFx0XHRcdGlmICh0aGlzLnRva2Vucy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRsZXQgcHJldmlvdXNTdG9wOiBudW1iZXIgPSB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXS5zdG9wSW5kZXg7XHJcblx0XHRcdFx0XHRpZiAocHJldmlvdXNTdG9wICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRzdGFydCA9IHByZXZpb3VzU3RvcCArIDE7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgc3RvcDogbnVtYmVyID0gTWF0aC5tYXgoLTEsIHN0YXJ0IC0gMSk7XHJcblx0XHRcdFx0dGhpcy5lb2ZUb2tlbiA9IHRoaXMuX2ZhY3RvcnkuY3JlYXRlKHsgc291cmNlOiB0aGlzLCBzdHJlYW06IHRoaXMuaW5wdXRTdHJlYW0gfSwgVG9rZW4uRU9GLCBcIkVPRlwiLCBUb2tlbi5ERUZBVUxUX0NIQU5ORUwsIHN0YXJ0LCBzdG9wLCB0aGlzLmxpbmUsIHRoaXMuY2hhclBvc2l0aW9uSW5MaW5lKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuZW9mVG9rZW47XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHQ6IFRva2VuID0gdGhpcy50b2tlbnNbdGhpcy5pXTtcclxuXHRcdGlmICh0aGlzLmkgPT09IHRoaXMudG9rZW5zLmxlbmd0aCAtIDEgJiYgdC50eXBlID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0dGhpcy5lb2ZUb2tlbiA9IHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5pKys7XHJcblx0XHRyZXR1cm4gdDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgbGluZSgpOiBudW1iZXIge1xyXG5cdFx0aWYgKHRoaXMuaSA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pXS5saW5lO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLmVvZlRva2VuICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZW9mVG9rZW4ubGluZTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy50b2tlbnMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHQvLyBoYXZlIHRvIGNhbGN1bGF0ZSB0aGUgcmVzdWx0IGZyb20gdGhlIGxpbmUvY29sdW1uIG9mIHRoZSBwcmV2aW91c1xyXG5cdFx0XHQvLyB0b2tlbiwgYWxvbmcgd2l0aCB0aGUgdGV4dCBvZiB0aGUgdG9rZW4uXHJcblx0XHRcdGxldCBsYXN0VG9rZW46IFRva2VuID0gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV07XHJcblx0XHRcdGxldCBsaW5lOiBudW1iZXIgPSBsYXN0VG9rZW4ubGluZTtcclxuXHJcblx0XHRcdGxldCB0b2tlblRleHQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9IGxhc3RUb2tlbi50ZXh0O1xyXG5cdFx0XHRpZiAodG9rZW5UZXh0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuVGV4dC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKHRva2VuVGV4dC5jaGFyQXQoaSkgPT09IFwiXFxuXCIpIHtcclxuXHRcdFx0XHRcdFx0bGluZSsrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaWYgbm8gdGV4dCBpcyBhdmFpbGFibGUsIGFzc3VtZSB0aGUgdG9rZW4gZGlkIG5vdCBjb250YWluIGFueSBuZXdsaW5lIGNoYXJhY3RlcnMuXHJcblx0XHRcdHJldHVybiBsaW5lO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG9ubHkgcmVhY2ggdGhpcyBpZiB0b2tlbnMgaXMgZW1wdHksIG1lYW5pbmcgRU9GIG9jY3VycyBhdCB0aGUgZmlyc3RcclxuXHRcdC8vIHBvc2l0aW9uIGluIHRoZSBpbnB1dFxyXG5cdFx0cmV0dXJuIDE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGlucHV0U3RyZWFtKCk6IENoYXJTdHJlYW0gfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKHRoaXMuaSA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pXS5pbnB1dFN0cmVhbTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5lb2ZUb2tlbiAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVvZlRva2VuLmlucHV0U3RyZWFtO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLnRva2Vucy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXS5pbnB1dFN0cmVhbTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBubyBpbnB1dCBzdHJlYW0gaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzb3VyY2VOYW1lKCk6IHN0cmluZyB7XHJcblx0XHRpZiAodGhpcy5fc291cmNlTmFtZSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fc291cmNlTmFtZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgaW5wdXRTdHJlYW06IENoYXJTdHJlYW0gfCB1bmRlZmluZWQgPSB0aGlzLmlucHV0U3RyZWFtO1xyXG5cdFx0aWYgKGlucHV0U3RyZWFtICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIGlucHV0U3RyZWFtLnNvdXJjZU5hbWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFwiTGlzdFwiO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqL1xyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHNldCB0b2tlbkZhY3RvcnkoQE5vdE51bGwgZmFjdG9yeTogVG9rZW5GYWN0b3J5KSB7XHJcblx0XHR0aGlzLl9mYWN0b3J5ID0gZmFjdG9yeTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRATm90TnVsbFxyXG5cdGdldCB0b2tlbkZhY3RvcnkoKTogVG9rZW5GYWN0b3J5IHtcclxuXHRcdHJldHVybiB0aGlzLl9mYWN0b3J5O1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDIuMTM0Njk1MS0wNzowMFxyXG5cclxuZXhwb3J0IGNsYXNzIE11bHRpTWFwPEssIFY+IGV4dGVuZHMgTWFwPEssIFZbXT4ge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0c3VwZXIoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBtYXAoa2V5OiBLLCB2YWx1ZTogVik6IHZvaWQge1xyXG5cdFx0bGV0IGVsZW1lbnRzRm9yS2V5ID0gc3VwZXIuZ2V0KGtleSk7XHJcblx0XHRpZiAoIWVsZW1lbnRzRm9yS2V5KSB7XHJcblx0XHRcdGVsZW1lbnRzRm9yS2V5ID0gW10gYXMgVltdO1xyXG5cdFx0XHRzdXBlci5zZXQoa2V5LCBlbGVtZW50c0ZvcktleSk7XHJcblx0XHR9XHJcblx0XHRlbGVtZW50c0ZvcktleS5wdXNoKHZhbHVlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRQYWlycygpOiBBcnJheTxbSywgVl0+IHtcclxuXHRcdGxldCBwYWlyczogQXJyYXk8W0ssIFZdPiA9IFtdO1xyXG5cdFx0dGhpcy5mb3JFYWNoKCh2YWx1ZXM6IFZbXSwga2V5OiBLKSA9PiB7XHJcblx0XHRcdHZhbHVlcy5mb3JFYWNoKCh2KSA9PiB7XHJcblx0XHRcdFx0cGFpcnMucHVzaChba2V5LCB2XSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gcGFpcnM7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0Mi41NDQ3MDg1LTA3OjAwXHJcblxyXG4vKipcclxuICogVGhpcyBleGNlcHRpb24gaXMgdGhyb3duIHRvIGNhbmNlbCBhIHBhcnNpbmcgb3BlcmF0aW9uLiBUaGlzIGV4Y2VwdGlvbiBkb2VzXHJcbiAqIG5vdCBleHRlbmQge0BsaW5rIFJlY29nbml0aW9uRXhjZXB0aW9ufSwgYWxsb3dpbmcgaXQgdG8gYnlwYXNzIHRoZSBzdGFuZGFyZFxyXG4gKiBlcnJvciByZWNvdmVyeSBtZWNoYW5pc21zLiB7QGxpbmsgQmFpbEVycm9yU3RyYXRlZ3l9IHRocm93cyB0aGlzIGV4Y2VwdGlvbiBpblxyXG4gKiByZXNwb25zZSB0byBhIHBhcnNlIGVycm9yLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XHJcblx0Ly8gcHJpdmF0ZSBzdGF0aWMgc2VyaWFsVmVyc2lvblVJRDogbnVtYmVyID0gIC0zNTI5NTUyMDk5MzY2OTc5NjgzTDtcclxuXHRwdWJsaWMgcmVhZG9ubHkgc3RhY2s/OiBzdHJpbmc7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHB1YmxpYyBjYXVzZTogRXJyb3IpIHtcclxuXHRcdHN1cGVyKGNhdXNlLm1lc3NhZ2UpO1xyXG5cdFx0dGhpcy5zdGFjayA9IGNhdXNlLnN0YWNrO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldENhdXNlKCk6IEVycm9yIHtcclxuXHRcdHJldHVybiB0aGlzLmNhdXNlO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTEuNTg5ODU0Ni0wNzowMFxyXG5cclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGV4dGVuZHMge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0fSBieSBhbGxvd2luZyB0aGUgdmFsdWUgb2ZcclxuICoge0BsaW5rICNnZXRSdWxlSW5kZXh9IHRvIGJlIGV4cGxpY2l0bHkgc2V0IGZvciB0aGUgY29udGV4dC5cclxuICpcclxuICoge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0fSBkb2VzIG5vdCBpbmNsdWRlIGZpZWxkIHN0b3JhZ2UgZm9yIHRoZSBydWxlIGluZGV4XHJcbiAqIHNpbmNlIHRoZSBjb250ZXh0IGNsYXNzZXMgY3JlYXRlZCBieSB0aGUgY29kZSBnZW5lcmF0b3Igb3ZlcnJpZGUgdGhlXHJcbiAqIHtAbGluayAjZ2V0UnVsZUluZGV4fSBtZXRob2QgdG8gcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlIGZvciB0aGF0IGNvbnRleHQuXHJcbiAqIFNpbmNlIHRoZSBwYXJzZXIgaW50ZXJwcmV0ZXIgZG9lcyBub3QgdXNlIHRoZSBjb250ZXh0IGNsYXNzZXMgZ2VuZXJhdGVkIGZvciBhXHJcbiAqIHBhcnNlciwgdGhpcyBjbGFzcyAod2l0aCBzbGlnaHRseSBtb3JlIG1lbW9yeSBvdmVyaGVhZCBwZXIgbm9kZSkgaXMgdXNlZCB0b1xyXG4gKiBwcm92aWRlIGVxdWl2YWxlbnQgZnVuY3Rpb25hbGl0eS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbnRlcnByZXRlclJ1bGVDb250ZXh0IGV4dGVuZHMgUGFyc2VyUnVsZUNvbnRleHQge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIHtAbGluayAjZ2V0UnVsZUluZGV4fS5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9ydWxlSW5kZXg6IG51bWJlcjtcclxuXHJcblx0Y29uc3RydWN0b3IocnVsZUluZGV4OiBudW1iZXIpO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHtAbGluayBJbnRlcnByZXRlclJ1bGVDb250ZXh0fSB3aXRoIHRoZSBzcGVjaWZpZWRcclxuXHQgKiBwYXJlbnQsIGludm9raW5nIHN0YXRlLCBhbmQgcnVsZSBpbmRleC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBydWxlSW5kZXggVGhlIHJ1bGUgaW5kZXggZm9yIHRoZSBjdXJyZW50IGNvbnRleHQuXHJcblx0ICogQHBhcmFtIHBhcmVudCBUaGUgcGFyZW50IGNvbnRleHQuXHJcblx0ICogQHBhcmFtIGludm9raW5nU3RhdGVOdW1iZXIgVGhlIGludm9raW5nIHN0YXRlIG51bWJlci5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihydWxlSW5kZXg6IG51bWJlciwgcGFyZW50OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgaW52b2tpbmdTdGF0ZU51bWJlcjogbnVtYmVyKTtcclxuXHJcblx0Y29uc3RydWN0b3IocnVsZUluZGV4OiBudW1iZXIsIHBhcmVudD86IFBhcnNlclJ1bGVDb250ZXh0LCBpbnZva2luZ1N0YXRlTnVtYmVyPzogbnVtYmVyKSB7XHJcblx0XHRpZiAoaW52b2tpbmdTdGF0ZU51bWJlciAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZU51bWJlcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdXBlcigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3J1bGVJbmRleCA9IHJ1bGVJbmRleDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBydWxlSW5kZXgoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9ydWxlSW5kZXg7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1My4xMDQzNDUxLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBY3Rpb25UcmFuc2l0aW9uIH0gZnJvbSBcIi4vYXRuL0FjdGlvblRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vYXRuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL2F0bi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZVR5cGUgfSBmcm9tIFwiLi9hdG4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IEF0b21UcmFuc2l0aW9uIH0gZnJvbSBcIi4vYXRuL0F0b21UcmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IEJpdFNldCB9IGZyb20gXCIuL21pc2MvQml0U2V0XCI7XHJcbmltcG9ydCB7IERlY2lzaW9uU3RhdGUgfSBmcm9tIFwiLi9hdG4vRGVjaXNpb25TdGF0ZVwiO1xyXG5pbXBvcnQgeyBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24gfSBmcm9tIFwiLi9GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbiB9IGZyb20gXCIuL0lucHV0TWlzbWF0Y2hFeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgSW50ZXJwcmV0ZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuL0ludGVycHJldGVyUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgTG9vcEVuZFN0YXRlIH0gZnJvbSBcIi4vYXRuL0xvb3BFbmRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFBhcnNlckFUTlNpbXVsYXRvciB9IGZyb20gXCIuL2F0bi9QYXJzZXJBVE5TaW11bGF0b3JcIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbiB9IGZyb20gXCIuL2F0bi9QcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBQcmVkaWNhdGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vYXRuL1ByZWRpY2F0ZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBSdWxlU3RhcnRTdGF0ZSB9IGZyb20gXCIuL2F0bi9SdWxlU3RhcnRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBSdWxlVHJhbnNpdGlvbiB9IGZyb20gXCIuL2F0bi9SdWxlVHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBTdGFyTG9vcEVudHJ5U3RhdGUgfSBmcm9tIFwiLi9hdG4vU3Rhckxvb3BFbnRyeVN0YXRlXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi9Ub2tlblN0cmVhbVwiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vYXRuL1RyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvblR5cGUgfSBmcm9tIFwiLi9hdG4vVHJhbnNpdGlvblR5cGVcIjtcclxuaW1wb3J0IHsgVm9jYWJ1bGFyeSB9IGZyb20gXCIuL1ZvY2FidWxhcnlcIjtcclxuXHJcbi8qKiBBIHBhcnNlciBzaW11bGF0b3IgdGhhdCBtaW1pY3Mgd2hhdCBBTlRMUidzIGdlbmVyYXRlZFxyXG4gKiAgcGFyc2VyIGNvZGUgZG9lcy4gQSBQYXJzZXJBVE5TaW11bGF0b3IgaXMgdXNlZCB0byBtYWtlXHJcbiAqICBwcmVkaWN0aW9ucyB2aWEgYWRhcHRpdmVQcmVkaWN0IGJ1dCB0aGlzIGNsYXNzIG1vdmVzIGEgcG9pbnRlciB0aHJvdWdoIHRoZVxyXG4gKiAgQVROIHRvIHNpbXVsYXRlIHBhcnNpbmcuIFBhcnNlckFUTlNpbXVsYXRvciBqdXN0XHJcbiAqICBtYWtlcyB1cyBlZmZpY2llbnQgcmF0aGVyIHRoYW4gaGF2aW5nIHRvIGJhY2t0cmFjaywgZm9yIGV4YW1wbGUuXHJcbiAqXHJcbiAqICBUaGlzIHByb3Blcmx5IGNyZWF0ZXMgcGFyc2UgdHJlZXMgZXZlbiBmb3IgbGVmdCByZWN1cnNpdmUgcnVsZXMuXHJcbiAqXHJcbiAqICBXZSByZWx5IG9uIHRoZSBsZWZ0IHJlY3Vyc2l2ZSBydWxlIGludm9jYXRpb24gYW5kIHNwZWNpYWwgcHJlZGljYXRlXHJcbiAqICB0cmFuc2l0aW9ucyB0byBtYWtlIGxlZnQgcmVjdXJzaXZlIHJ1bGVzIHdvcmsuXHJcbiAqXHJcbiAqICBTZWUgVGVzdFBhcnNlckludGVycHJldGVyIGZvciBleGFtcGxlcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQYXJzZXJJbnRlcnByZXRlciBleHRlbmRzIFBhcnNlciB7XHJcblx0cHJvdGVjdGVkIF9ncmFtbWFyRmlsZU5hbWU6IHN0cmluZztcclxuXHRwcm90ZWN0ZWQgX2F0bjogQVROO1xyXG5cdC8qKiBUaGlzIGlkZW50aWZpZXMgU3Rhckxvb3BFbnRyeVN0YXRlJ3MgdGhhdCBiZWdpbiB0aGUgKC4uLikqXHJcblx0ICogIHByZWNlZGVuY2UgbG9vcHMgb2YgbGVmdCByZWN1cnNpdmUgcnVsZXMuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHB1c2hSZWN1cnNpb25Db250ZXh0U3RhdGVzOiBCaXRTZXQ7XHJcblxyXG5cdHByb3RlY3RlZCBfcnVsZU5hbWVzOiBzdHJpbmdbXTtcclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgX3ZvY2FidWxhcnk6IFZvY2FidWxhcnk7XHJcblxyXG5cdC8qKiBUaGlzIHN0YWNrIGNvcnJlc3BvbmRzIHRvIHRoZSBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUgcGFpciBvZiBsb2NhbHNcclxuXHQgKiAgdGhhdCB3b3VsZCBleGlzdCBvbiBjYWxsIHN0YWNrIGZyYW1lcyB3aXRoIGEgcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2VyO1xyXG5cdCAqICBpbiB0aGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGZvciBhIGxlZnQtcmVjdXJzaXZlIHJ1bGUgeW91J2Qgc2VlOlxyXG5cdCAqXHJcblx0ICogIHByaXZhdGUgRUNvbnRleHQgZShpbnQgX3ApIHtcclxuXHQgKiAgICAgIFBhcnNlclJ1bGVDb250ZXh0IF9wYXJlbnRjdHggPSBfY3R4OyAgICAvLyBQYWlyLmFcclxuXHQgKiAgICAgIGludCBfcGFyZW50U3RhdGUgPSBzdGF0ZTsgICAgICAgICAgLy8gUGFpci5iXHJcblx0ICogICAgICAuLi5cclxuXHQgKiAgfVxyXG5cdCAqXHJcblx0ICogIFRob3NlIHZhbHVlcyBhcmUgdXNlZCB0byBjcmVhdGUgbmV3IHJlY3Vyc2l2ZSBydWxlIGludm9jYXRpb24gY29udGV4dHNcclxuXHQgKiAgYXNzb2NpYXRlZCB3aXRoIGxlZnQgb3BlcmFuZCBvZiBhbiBhbHQgbGlrZSBcImV4cHIgJyonIGV4cHJcIi5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcmVhZG9ubHkgX3BhcmVudENvbnRleHRTdGFjazogQXJyYXk8W1BhcnNlclJ1bGVDb250ZXh0LCBudW1iZXJdPiA9IFtdO1xyXG5cclxuXHQvKiogV2UgbmVlZCBhIG1hcCBmcm9tIChkZWNpc2lvbixpbnB1dEluZGV4KS0+Zm9yY2VkIGFsdCBmb3IgY29tcHV0aW5nIGFtYmlndW91c1xyXG5cdCAqICBwYXJzZSB0cmVlcy4gRm9yIG5vdywgd2UgYWxsb3cgZXhhY3RseSBvbmUgb3ZlcnJpZGUuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIG92ZXJyaWRlRGVjaXNpb246IG51bWJlciA9IC0xO1xyXG5cdHByb3RlY3RlZCBvdmVycmlkZURlY2lzaW9uSW5wdXRJbmRleDogbnVtYmVyID0gLTE7XHJcblx0cHJvdGVjdGVkIG92ZXJyaWRlRGVjaXNpb25BbHQ6IG51bWJlciA9IC0xO1xyXG5cdHByb3RlY3RlZCBvdmVycmlkZURlY2lzaW9uUmVhY2hlZDogYm9vbGVhbiA9IGZhbHNlOyAvLyBsYXRjaCBhbmQgb25seSBvdmVycmlkZSBvbmNlOyBlcnJvciBtaWdodCB0cmlnZ2VyIGluZmluaXRlIGxvb3BcclxuXHJcblx0LyoqIFdoYXQgaXMgdGhlIGN1cnJlbnQgY29udGV4dCB3aGVuIHdlIG92ZXJyaWRlIGEgZGVjaXNpb25zPyAgVGhpcyB0ZWxsc1xyXG5cdCAqICB1cyB3aGF0IHRoZSByb290IG9mIHRoZSBwYXJzZSB0cmVlIGlzIHdoZW4gdXNpbmcgb3ZlcnJpZGVcclxuXHQgKiAgZm9yIGFuIGFtYmlndWl0eS9sb29rYWhlYWQgY2hlY2suXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIF9vdmVycmlkZURlY2lzaW9uUm9vdD86IEludGVycHJldGVyUnVsZUNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblxyXG5cdHByb3RlY3RlZCBfcm9vdENvbnRleHQhOiBJbnRlcnByZXRlclJ1bGVDb250ZXh0O1xyXG5cclxuXHQvKiogQSBjb3B5IGNvbnN0cnVjdG9yIHRoYXQgY3JlYXRlcyBhIG5ldyBwYXJzZXIgaW50ZXJwcmV0ZXIgYnkgcmV1c2luZ1xyXG5cdCAqICB0aGUgZmllbGRzIG9mIGEgcHJldmlvdXMgaW50ZXJwcmV0ZXIuXHJcblx0ICpcclxuXHQgKiAgQHBhcmFtIG9sZCBUaGUgaW50ZXJwcmV0ZXIgdG8gY29weVxyXG5cdCAqXHJcblx0ICogIEBzaW5jZSA0LjVcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcigvKkBOb3ROdWxsKi8gb2xkOiBQYXJzZXJJbnRlcnByZXRlcik7XHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRncmFtbWFyRmlsZU5hbWU6IHN0cmluZywgLypATm90TnVsbCovIHZvY2FidWxhcnk6IFZvY2FidWxhcnksXHJcblx0XHRydWxlTmFtZXM6IHN0cmluZ1tdLCBhdG46IEFUTiwgaW5wdXQ6IFRva2VuU3RyZWFtKTtcclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdGdyYW1tYXJGaWxlTmFtZTogUGFyc2VySW50ZXJwcmV0ZXIgfCBzdHJpbmcsIEBOb3ROdWxsIHZvY2FidWxhcnk/OiBWb2NhYnVsYXJ5LFxyXG5cdFx0cnVsZU5hbWVzPzogc3RyaW5nW10sIGF0bj86IEFUTiwgaW5wdXQ/OiBUb2tlblN0cmVhbSkge1xyXG5cdFx0c3VwZXIoZ3JhbW1hckZpbGVOYW1lIGluc3RhbmNlb2YgUGFyc2VySW50ZXJwcmV0ZXIgPyBncmFtbWFyRmlsZU5hbWUuaW5wdXRTdHJlYW0gOiBpbnB1dCEpO1xyXG5cdFx0aWYgKGdyYW1tYXJGaWxlTmFtZSBpbnN0YW5jZW9mIFBhcnNlckludGVycHJldGVyKSB7XHJcblx0XHRcdGxldCBvbGQ6IFBhcnNlckludGVycHJldGVyID0gZ3JhbW1hckZpbGVOYW1lO1xyXG5cdFx0XHR0aGlzLl9ncmFtbWFyRmlsZU5hbWUgPSBvbGQuX2dyYW1tYXJGaWxlTmFtZTtcclxuXHRcdFx0dGhpcy5fYXRuID0gb2xkLl9hdG47XHJcblx0XHRcdHRoaXMucHVzaFJlY3Vyc2lvbkNvbnRleHRTdGF0ZXMgPSBvbGQucHVzaFJlY3Vyc2lvbkNvbnRleHRTdGF0ZXM7XHJcblx0XHRcdHRoaXMuX3J1bGVOYW1lcyA9IG9sZC5fcnVsZU5hbWVzO1xyXG5cdFx0XHR0aGlzLl92b2NhYnVsYXJ5ID0gb2xkLl92b2NhYnVsYXJ5O1xyXG5cdFx0XHR0aGlzLmludGVycHJldGVyID0gbmV3IFBhcnNlckFUTlNpbXVsYXRvcih0aGlzLl9hdG4sIHRoaXMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gVGhlIHNlY29uZCBjb25zdHJ1Y3RvciByZXF1aXJlcyBub24tbnVsbCBhcmd1bWVudHNcclxuXHRcdFx0dm9jYWJ1bGFyeSA9IHZvY2FidWxhcnkhO1xyXG5cdFx0XHRydWxlTmFtZXMgPSBydWxlTmFtZXMhO1xyXG5cdFx0XHRhdG4gPSBhdG4hO1xyXG5cclxuXHRcdFx0dGhpcy5fZ3JhbW1hckZpbGVOYW1lID0gZ3JhbW1hckZpbGVOYW1lO1xyXG5cdFx0XHR0aGlzLl9hdG4gPSBhdG47XHJcblx0XHRcdHRoaXMuX3J1bGVOYW1lcyA9IHJ1bGVOYW1lcy5zbGljZSgwKTtcclxuXHRcdFx0dGhpcy5fdm9jYWJ1bGFyeSA9IHZvY2FidWxhcnk7XHJcblxyXG5cdFx0XHQvLyBpZGVudGlmeSB0aGUgQVROIHN0YXRlcyB3aGVyZSBwdXNoTmV3UmVjdXJzaW9uQ29udGV4dCgpIG11c3QgYmUgY2FsbGVkXHJcblx0XHRcdHRoaXMucHVzaFJlY3Vyc2lvbkNvbnRleHRTdGF0ZXMgPSBuZXcgQml0U2V0KGF0bi5zdGF0ZXMubGVuZ3RoKTtcclxuXHRcdFx0Zm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xyXG5cdFx0XHRcdGlmICghKHN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoc3RhdGUucHJlY2VkZW5jZVJ1bGVEZWNpc2lvbikge1xyXG5cdFx0XHRcdFx0dGhpcy5wdXNoUmVjdXJzaW9uQ29udGV4dFN0YXRlcy5zZXQoc3RhdGUuc3RhdGVOdW1iZXIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZ2V0IGF0biBzaW11bGF0b3IgdGhhdCBrbm93cyBob3cgdG8gZG8gcHJlZGljdGlvbnNcclxuXHRcdFx0dGhpcy5pbnRlcnByZXRlciA9IG5ldyBQYXJzZXJBVE5TaW11bGF0b3IoYXRuLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZXNldChyZXNldElucHV0PzogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0aWYgKHJlc2V0SW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRzdXBlci5yZXNldCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3VwZXIucmVzZXQocmVzZXRJbnB1dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vdmVycmlkZURlY2lzaW9uUmVhY2hlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fb3ZlcnJpZGVEZWNpc2lvblJvb3QgPSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgYXRuKCk6IEFUTiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYXRuO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHZvY2FidWxhcnkoKTogVm9jYWJ1bGFyeSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdm9jYWJ1bGFyeTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBydWxlTmFtZXMoKTogc3RyaW5nW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3J1bGVOYW1lcztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBncmFtbWFyRmlsZU5hbWUoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLl9ncmFtbWFyRmlsZU5hbWU7XHJcblx0fVxyXG5cclxuXHQvKiogQmVnaW4gcGFyc2luZyBhdCBzdGFydFJ1bGVJbmRleCAqL1xyXG5cdHB1YmxpYyBwYXJzZShzdGFydFJ1bGVJbmRleDogbnVtYmVyKTogUGFyc2VyUnVsZUNvbnRleHQge1xyXG5cdFx0bGV0IHN0YXJ0UnVsZVN0YXJ0U3RhdGU6IFJ1bGVTdGFydFN0YXRlID0gdGhpcy5fYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbc3RhcnRSdWxlSW5kZXhdO1xyXG5cclxuXHRcdHRoaXMuX3Jvb3RDb250ZXh0ID0gdGhpcy5jcmVhdGVJbnRlcnByZXRlclJ1bGVDb250ZXh0KHVuZGVmaW5lZCwgQVROU3RhdGUuSU5WQUxJRF9TVEFURV9OVU1CRVIsIHN0YXJ0UnVsZUluZGV4KTtcclxuXHRcdGlmIChzdGFydFJ1bGVTdGFydFN0YXRlLmlzUHJlY2VkZW5jZVJ1bGUpIHtcclxuXHRcdFx0dGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUodGhpcy5fcm9vdENvbnRleHQsIHN0YXJ0UnVsZVN0YXJ0U3RhdGUuc3RhdGVOdW1iZXIsIHN0YXJ0UnVsZUluZGV4LCAwKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0aGlzLmVudGVyUnVsZSh0aGlzLl9yb290Q29udGV4dCwgc3RhcnRSdWxlU3RhcnRTdGF0ZS5zdGF0ZU51bWJlciwgc3RhcnRSdWxlSW5kZXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGxldCBwOiBBVE5TdGF0ZSA9IHRoaXMuYXRuU3RhdGU7XHJcblx0XHRcdHN3aXRjaCAocC5zdGF0ZVR5cGUpIHtcclxuXHRcdFx0Y2FzZSBBVE5TdGF0ZVR5cGUuUlVMRV9TVE9QOlxyXG5cdFx0XHRcdC8vIHBvcDsgcmV0dXJuIGZyb20gcnVsZVxyXG5cdFx0XHRcdGlmICh0aGlzLl9jdHguaXNFbXB0eSkge1xyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0UnVsZVN0YXJ0U3RhdGUuaXNQcmVjZWRlbmNlUnVsZSkge1xyXG5cdFx0XHRcdFx0XHRsZXQgcmVzdWx0OiBQYXJzZXJSdWxlQ29udGV4dCA9IHRoaXMuX2N0eDtcclxuXHRcdFx0XHRcdFx0bGV0IHBhcmVudENvbnRleHQ6IFtQYXJzZXJSdWxlQ29udGV4dCwgbnVtYmVyXSA9IHRoaXMuX3BhcmVudENvbnRleHRTdGFjay5wb3AoKSAhO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKHBhcmVudENvbnRleHRbMF0pO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuZXhpdFJ1bGUoKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3Jvb3RDb250ZXh0O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy52aXNpdFJ1bGVTdG9wU3RhdGUocCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR0aGlzLnZpc2l0U3RhdGUocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRpZiAoZSBpbnN0YW5jZW9mIFJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUgPSB0aGlzLl9hdG4ucnVsZVRvU3RvcFN0YXRlW3AucnVsZUluZGV4XS5zdGF0ZU51bWJlcjtcclxuXHRcdFx0XHRcdFx0dGhpcy5jb250ZXh0LmV4Y2VwdGlvbiA9IGU7XHJcblx0XHRcdFx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIGUpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnJlY292ZXIoZSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHg6IFBhcnNlclJ1bGVDb250ZXh0LCBzdGF0ZTogbnVtYmVyLCBydWxlSW5kZXg6IG51bWJlciwgcHJlY2VkZW5jZTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLl9wYXJlbnRDb250ZXh0U3RhY2sucHVzaChbdGhpcy5fY3R4LCBsb2NhbGN0eC5pbnZva2luZ1N0YXRlXSk7XHJcblx0XHRzdXBlci5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIHN0YXRlLCBydWxlSW5kZXgsIHByZWNlZGVuY2UpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldCBhdG5TdGF0ZSgpOiBBVE5TdGF0ZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYXRuLnN0YXRlc1t0aGlzLnN0YXRlXTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCB2aXNpdFN0YXRlKHA6IEFUTlN0YXRlKTogdm9pZCB7XHJcblx0XHRsZXQgcHJlZGljdGVkQWx0OiBudW1iZXIgPSAxO1xyXG5cdFx0aWYgKHAubnVtYmVyT2ZUcmFuc2l0aW9ucyA+IDEpIHtcclxuXHRcdFx0cHJlZGljdGVkQWx0ID0gdGhpcy52aXNpdERlY2lzaW9uU3RhdGUocCBhcyBEZWNpc2lvblN0YXRlKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdHJhbnNpdGlvbjogVHJhbnNpdGlvbiA9IHAudHJhbnNpdGlvbihwcmVkaWN0ZWRBbHQgLSAxKTtcclxuXHRcdHN3aXRjaCAodHJhbnNpdGlvbi5zZXJpYWxpemF0aW9uVHlwZSkge1xyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5FUFNJTE9OOlxyXG5cdFx0XHRpZiAodGhpcy5wdXNoUmVjdXJzaW9uQ29udGV4dFN0YXRlcy5nZXQocC5zdGF0ZU51bWJlcikgJiZcclxuXHRcdFx0XHQhKHRyYW5zaXRpb24udGFyZ2V0IGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKSkge1xyXG5cdFx0XHRcdC8vIFdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgYSBsZWZ0IHJlY3Vyc2l2ZSBydWxlJ3MgKC4uLikqIGxvb3BcclxuXHRcdFx0XHQvLyBhbmQgd2UncmUgbm90IHRha2luZyB0aGUgZXhpdCBicmFuY2ggb2YgbG9vcC5cclxuXHRcdFx0XHRsZXQgcGFyZW50Q29udGV4dCA9IHRoaXMuX3BhcmVudENvbnRleHRTdGFja1t0aGlzLl9wYXJlbnRDb250ZXh0U3RhY2subGVuZ3RoIC0gMV07XHJcblx0XHRcdFx0bGV0IGxvY2FsY3R4OiBJbnRlcnByZXRlclJ1bGVDb250ZXh0ID1cclxuXHRcdFx0XHRcdHRoaXMuY3JlYXRlSW50ZXJwcmV0ZXJSdWxlQ29udGV4dChwYXJlbnRDb250ZXh0WzBdLCBwYXJlbnRDb250ZXh0WzFdLCB0aGlzLl9jdHgucnVsZUluZGV4KTtcclxuXHRcdFx0XHR0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LFxyXG5cdFx0XHRcdFx0dGhpcy5fYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbcC5ydWxlSW5kZXhdLnN0YXRlTnVtYmVyLFxyXG5cdFx0XHRcdFx0dGhpcy5fY3R4LnJ1bGVJbmRleCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5BVE9NOlxyXG5cdFx0XHR0aGlzLm1hdGNoKCh0cmFuc2l0aW9uIGFzIEF0b21UcmFuc2l0aW9uKS5fbGFiZWwpO1xyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlJBTkdFOlxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5TRVQ6XHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLk5PVF9TRVQ6XHJcblx0XHRcdGlmICghdHJhbnNpdGlvbi5tYXRjaGVzKHRoaXMuX2lucHV0LkxBKDEpLCBUb2tlbi5NSU5fVVNFUl9UT0tFTl9UWVBFLCA2NTUzNSkpIHtcclxuXHRcdFx0XHR0aGlzLnJlY292ZXJJbmxpbmUoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLm1hdGNoV2lsZGNhcmQoKTtcclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5XSUxEQ0FSRDpcclxuXHRcdFx0dGhpcy5tYXRjaFdpbGRjYXJkKCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgVHJhbnNpdGlvblR5cGUuUlVMRTpcclxuXHRcdFx0bGV0IHJ1bGVTdGFydFN0YXRlOiBSdWxlU3RhcnRTdGF0ZSA9IHRyYW5zaXRpb24udGFyZ2V0IGFzIFJ1bGVTdGFydFN0YXRlO1xyXG5cdFx0XHRsZXQgcnVsZUluZGV4OiBudW1iZXIgPSBydWxlU3RhcnRTdGF0ZS5ydWxlSW5kZXg7XHJcblx0XHRcdGxldCBuZXdjdHg6IEludGVycHJldGVyUnVsZUNvbnRleHQgPSB0aGlzLmNyZWF0ZUludGVycHJldGVyUnVsZUNvbnRleHQodGhpcy5fY3R4LCBwLnN0YXRlTnVtYmVyLCBydWxlSW5kZXgpO1xyXG5cdFx0XHRpZiAocnVsZVN0YXJ0U3RhdGUuaXNQcmVjZWRlbmNlUnVsZSkge1xyXG5cdFx0XHRcdHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKG5ld2N0eCwgcnVsZVN0YXJ0U3RhdGUuc3RhdGVOdW1iZXIsIHJ1bGVJbmRleCwgKHRyYW5zaXRpb24gYXMgUnVsZVRyYW5zaXRpb24pLnByZWNlZGVuY2UpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZW50ZXJSdWxlKG5ld2N0eCwgdHJhbnNpdGlvbi50YXJnZXQuc3RhdGVOdW1iZXIsIHJ1bGVJbmRleCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUcmFuc2l0aW9uVHlwZS5QUkVESUNBVEU6XHJcblx0XHRcdGxldCBwcmVkaWNhdGVUcmFuc2l0aW9uOiBQcmVkaWNhdGVUcmFuc2l0aW9uID0gdHJhbnNpdGlvbiBhcyBQcmVkaWNhdGVUcmFuc2l0aW9uO1xyXG5cdFx0XHRpZiAoIXRoaXMuc2VtcHJlZCh0aGlzLl9jdHgsIHByZWRpY2F0ZVRyYW5zaXRpb24ucnVsZUluZGV4LCBwcmVkaWNhdGVUcmFuc2l0aW9uLnByZWRJbmRleCkpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLkFDVElPTjpcclxuXHRcdFx0bGV0IGFjdGlvblRyYW5zaXRpb246IEFjdGlvblRyYW5zaXRpb24gPSB0cmFuc2l0aW9uIGFzIEFjdGlvblRyYW5zaXRpb247XHJcblx0XHRcdHRoaXMuYWN0aW9uKHRoaXMuX2N0eCwgYWN0aW9uVHJhbnNpdGlvbi5ydWxlSW5kZXgsIGFjdGlvblRyYW5zaXRpb24uYWN0aW9uSW5kZXgpO1xyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIFRyYW5zaXRpb25UeXBlLlBSRUNFREVOQ0U6XHJcblx0XHRcdGlmICghdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsICh0cmFuc2l0aW9uIGFzIFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uKS5wcmVjZWRlbmNlKSkge1xyXG5cdFx0XHRcdGxldCBwcmVjZWRlbmNlID0gKHRyYW5zaXRpb24gYXMgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24pLnByZWNlZGVuY2U7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBgcHJlY3ByZWQoX2N0eCwgJHtwcmVjZWRlbmNlfSlgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbjogVW5yZWNvZ25pemVkIEFUTiB0cmFuc2l0aW9uIHR5cGUuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc3RhdGUgPSB0cmFuc2l0aW9uLnRhcmdldC5zdGF0ZU51bWJlcjtcclxuXHR9XHJcblxyXG5cdC8qKiBNZXRob2QgdmlzaXREZWNpc2lvblN0YXRlKCkgaXMgY2FsbGVkIHdoZW4gdGhlIGludGVycHJldGVyIHJlYWNoZXNcclxuXHQgKiAgYSBkZWNpc2lvbiBzdGF0ZSAoaW5zdGFuY2Ugb2YgRGVjaXNpb25TdGF0ZSkuIEl0IGdpdmVzIGFuIG9wcG9ydHVuaXR5XHJcblx0ICogIGZvciBzdWJjbGFzc2VzIHRvIHRyYWNrIGludGVyZXN0aW5nIHRoaW5ncy5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgdmlzaXREZWNpc2lvblN0YXRlKHA6IERlY2lzaW9uU3RhdGUpOiBudW1iZXIge1xyXG5cdFx0bGV0IHByZWRpY3RlZEFsdDogbnVtYmVyO1xyXG5cdFx0dGhpcy5lcnJvckhhbmRsZXIuc3luYyh0aGlzKTtcclxuXHRcdGxldCBkZWNpc2lvbjogbnVtYmVyID0gcC5kZWNpc2lvbjtcclxuXHRcdGlmIChkZWNpc2lvbiA9PT0gdGhpcy5vdmVycmlkZURlY2lzaW9uICYmIHRoaXMuX2lucHV0LmluZGV4ID09PSB0aGlzLm92ZXJyaWRlRGVjaXNpb25JbnB1dEluZGV4ICYmICF0aGlzLm92ZXJyaWRlRGVjaXNpb25SZWFjaGVkKSB7XHJcblx0XHRcdHByZWRpY3RlZEFsdCA9IHRoaXMub3ZlcnJpZGVEZWNpc2lvbkFsdDtcclxuXHRcdFx0dGhpcy5vdmVycmlkZURlY2lzaW9uUmVhY2hlZCA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0cHJlZGljdGVkQWx0ID0gdGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIGRlY2lzaW9uLCB0aGlzLl9jdHgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHByZWRpY3RlZEFsdDtcclxuXHR9XHJcblxyXG5cdC8qKiBQcm92aWRlIHNpbXBsZSBcImZhY3RvcnlcIiBmb3IgSW50ZXJwcmV0ZXJSdWxlQ29udGV4dCdzLlxyXG5cdCAqICBAc2luY2UgNC41LjFcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgY3JlYXRlSW50ZXJwcmV0ZXJSdWxlQ29udGV4dChcclxuXHRcdHBhcmVudDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsXHJcblx0XHRpbnZva2luZ1N0YXRlTnVtYmVyOiBudW1iZXIsXHJcblx0XHRydWxlSW5kZXg6IG51bWJlcik6IEludGVycHJldGVyUnVsZUNvbnRleHQge1xyXG5cdFx0cmV0dXJuIG5ldyBJbnRlcnByZXRlclJ1bGVDb250ZXh0KHJ1bGVJbmRleCwgcGFyZW50LCBpbnZva2luZ1N0YXRlTnVtYmVyKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCB2aXNpdFJ1bGVTdG9wU3RhdGUocDogQVROU3RhdGUpOiB2b2lkIHtcclxuXHRcdGxldCBydWxlU3RhcnRTdGF0ZTogUnVsZVN0YXJ0U3RhdGUgPSB0aGlzLl9hdG4ucnVsZVRvU3RhcnRTdGF0ZVtwLnJ1bGVJbmRleF07XHJcblx0XHRpZiAocnVsZVN0YXJ0U3RhdGUuaXNQcmVjZWRlbmNlUnVsZSkge1xyXG5cdFx0XHRsZXQgcGFyZW50Q29udGV4dDogW1BhcnNlclJ1bGVDb250ZXh0LCBudW1iZXJdID0gdGhpcy5fcGFyZW50Q29udGV4dFN0YWNrLnBvcCgpITtcclxuXHRcdFx0dGhpcy51bnJvbGxSZWN1cnNpb25Db250ZXh0cyhwYXJlbnRDb250ZXh0WzBdKTtcclxuXHRcdFx0dGhpcy5zdGF0ZSA9IHBhcmVudENvbnRleHRbMV07XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5leGl0UnVsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBydWxlVHJhbnNpdGlvbjogUnVsZVRyYW5zaXRpb24gPSB0aGlzLl9hdG4uc3RhdGVzW3RoaXMuc3RhdGVdLnRyYW5zaXRpb24oMCkgYXMgUnVsZVRyYW5zaXRpb247XHJcblx0XHR0aGlzLnN0YXRlID0gcnVsZVRyYW5zaXRpb24uZm9sbG93U3RhdGUuc3RhdGVOdW1iZXI7XHJcblx0fVxyXG5cclxuXHQvKiogT3ZlcnJpZGUgdGhpcyBwYXJzZXIgaW50ZXJwcmV0ZXJzIG5vcm1hbCBkZWNpc2lvbi1tYWtpbmcgcHJvY2Vzc1xyXG5cdCAqICBhdCBhIHBhcnRpY3VsYXIgZGVjaXNpb24gYW5kIGlucHV0IHRva2VuIGluZGV4LiBJbnN0ZWFkIG9mXHJcblx0ICogIGFsbG93aW5nIHRoZSBhZGFwdGl2ZSBwcmVkaWN0aW9uIG1lY2hhbmlzbSB0byBjaG9vc2UgdGhlXHJcblx0ICogIGZpcnN0IGFsdGVybmF0aXZlIHdpdGhpbiBhIGJsb2NrIHRoYXQgbGVhZHMgdG8gYSBzdWNjZXNzZnVsIHBhcnNlLFxyXG5cdCAqICBmb3JjZSBpdCB0byB0YWtlIHRoZSBhbHRlcm5hdGl2ZSwgMS4ubiBmb3IgbiBhbHRlcm5hdGl2ZXMuXHJcblx0ICpcclxuXHQgKiAgQXMgYW4gaW1wbGVtZW50YXRpb24gbGltaXRhdGlvbiByaWdodCBub3csIHlvdSBjYW4gb25seSBzcGVjaWZ5IG9uZVxyXG5cdCAqICBvdmVycmlkZS4gVGhpcyBpcyBzdWZmaWNpZW50IHRvIGFsbG93IGNvbnN0cnVjdGlvbiBvZiBkaWZmZXJlbnRcclxuXHQgKiAgcGFyc2UgdHJlZXMgZm9yIGFtYmlndW91cyBpbnB1dC4gSXQgbWVhbnMgcmUtcGFyc2luZyB0aGUgZW50aXJlIGlucHV0XHJcblx0ICogIGluIGdlbmVyYWwgYmVjYXVzZSB5b3UncmUgbmV2ZXIgc3VyZSB3aGVyZSBhbiBhbWJpZ3VvdXMgc2VxdWVuY2Ugd291bGRcclxuXHQgKiAgbGl2ZSBpbiB0aGUgdmFyaW91cyBwYXJzZSB0cmVlcy4gRm9yIGV4YW1wbGUsIGluIG9uZSBpbnRlcnByZXRhdGlvbixcclxuXHQgKiAgYW4gYW1iaWd1b3VzIGlucHV0IHNlcXVlbmNlIHdvdWxkIGJlIG1hdGNoZWQgY29tcGxldGVseSBpbiBleHByZXNzaW9uXHJcblx0ICogIGJ1dCBpbiBhbm90aGVyIGl0IGNvdWxkIG1hdGNoIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIHJvb3QuXHJcblx0ICpcclxuXHQgKiAgcyA6IGUgJyEnPyA7XHJcblx0ICogIGUgOiBJRFxyXG5cdCAqICAgIHwgSUQgJyEnXHJcblx0ICogICAgO1xyXG5cdCAqXHJcblx0ICogIEhlcmUsIHghIGNhbiBiZSBtYXRjaGVkIGFzIChzIChlIElEKSAhKSBvciAocyAoZSBJRCAhKSkuIEluIHRoZSBmaXJzdFxyXG5cdCAqICBjYXNlLCB0aGUgYW1iaWd1b3VzIHNlcXVlbmNlIGlzIGZ1bGx5IGNvbnRhaW5lZCBvbmx5IGJ5IHRoZSByb290LlxyXG5cdCAqICBJbiB0aGUgc2Vjb25kIGNhc2UsIHRoZSBhbWJpZ3VvdXMgc2VxdWVuY2VzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4ganVzdFxyXG5cdCAqICBlLCBhcyBpbjogKGUgSUQgISkuXHJcblx0ICpcclxuXHQgKiAgUmF0aGVyIHRoYW4gdHJ5aW5nIHRvIG9wdGltaXplIHRoaXMgYW5kIG1ha2VcclxuXHQgKiAgc29tZSBpbnRlbGxpZ2VudCBkZWNpc2lvbnMgZm9yIG9wdGltaXphdGlvbiBwdXJwb3NlcywgSSBzZXR0bGVkIG9uXHJcblx0ICogIGp1c3QgcmUtcGFyc2luZyB0aGUgd2hvbGUgaW5wdXQgYW5kIHRoZW4gdXNpbmdcclxuXHQgKiAge2xpbmsgVHJlZXMjZ2V0Um9vdE9mU3VidHJlZUVuY2xvc2luZ1JlZ2lvbn0gdG8gZmluZCB0aGUgbWluaW1hbFxyXG5cdCAqICBzdWJ0cmVlIHRoYXQgY29udGFpbnMgdGhlIGFtYmlndW91cyBzZXF1ZW5jZS4gSSBvcmlnaW5hbGx5IHRyaWVkIHRvXHJcblx0ICogIHJlY29yZCB0aGUgY2FsbCBzdGFjayBhdCB0aGUgcG9pbnQgdGhlIHBhcnNlciBkZXRlY3RlZCBhbmQgYW1iaWd1aXR5IGJ1dFxyXG5cdCAqICBsZWZ0IHJlY3Vyc2l2ZSBydWxlcyBjcmVhdGUgYSBwYXJzZSB0cmVlIHN0YWNrIHRoYXQgZG9lcyBub3QgcmVmbGVjdFxyXG5cdCAqICB0aGUgYWN0dWFsIGNhbGwgc3RhY2suIFRoYXQgaW1wZWRhbmNlIG1pc21hdGNoIHdhcyBlbm91Z2ggdG8gbWFrZVxyXG5cdCAqICBpdCBpdCBjaGFsbGVuZ2luZyB0byByZXN0YXJ0IHRoZSBwYXJzZXIgYXQgYSBkZWVwbHkgbmVzdGVkIHJ1bGVcclxuXHQgKiAgaW52b2NhdGlvbi5cclxuXHQgKlxyXG5cdCAqICBPbmx5IHBhcnNlciBpbnRlcnByZXRlcnMgY2FuIG92ZXJyaWRlIGRlY2lzaW9ucyBzbyBhcyB0byBhdm9pZCBpbnNlcnRpbmdcclxuXHQgKiAgb3ZlcnJpZGUgY2hlY2tpbmcgY29kZSBpbiB0aGUgY3JpdGljYWwgQUxMKCopIHByZWRpY3Rpb24gZXhlY3V0aW9uIHBhdGguXHJcblx0ICpcclxuXHQgKiAgQHNpbmNlIDQuNVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBhZGREZWNpc2lvbk92ZXJyaWRlKGRlY2lzaW9uOiBudW1iZXIsIHRva2VuSW5kZXg6IG51bWJlciwgZm9yY2VkQWx0OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMub3ZlcnJpZGVEZWNpc2lvbiA9IGRlY2lzaW9uO1xyXG5cdFx0dGhpcy5vdmVycmlkZURlY2lzaW9uSW5wdXRJbmRleCA9IHRva2VuSW5kZXg7XHJcblx0XHR0aGlzLm92ZXJyaWRlRGVjaXNpb25BbHQgPSBmb3JjZWRBbHQ7XHJcblx0fVxyXG5cclxuXHRnZXQgb3ZlcnJpZGVEZWNpc2lvblJvb3QoKTogSW50ZXJwcmV0ZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fb3ZlcnJpZGVEZWNpc2lvblJvb3Q7XHJcblx0fVxyXG5cclxuXHQvKiogUmVseSBvbiB0aGUgZXJyb3IgaGFuZGxlciBmb3IgdGhpcyBwYXJzZXIgYnV0LCBpZiBubyB0b2tlbnMgYXJlIGNvbnN1bWVkXHJcblx0ICogIHRvIHJlY292ZXIsIGFkZCBhbiBlcnJvciBub2RlLiBPdGhlcndpc2UsIG5vdGhpbmcgaXMgc2VlbiBpbiB0aGUgcGFyc2VcclxuXHQgKiAgdHJlZS5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcmVjb3ZlcihlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbik6IHZvaWQge1xyXG5cdFx0bGV0IGk6IG51bWJlciA9IHRoaXMuX2lucHV0LmluZGV4O1xyXG5cdFx0dGhpcy5lcnJvckhhbmRsZXIucmVjb3Zlcih0aGlzLCBlKTtcclxuXHRcdGlmICh0aGlzLl9pbnB1dC5pbmRleCA9PT0gaSkge1xyXG5cdFx0XHQvLyBubyBpbnB1dCBjb25zdW1lZCwgYmV0dGVyIGFkZCBhbiBlcnJvciBub2RlXHJcblx0XHRcdGxldCB0b2s6IFRva2VuIHwgdW5kZWZpbmVkID0gZS5nZXRPZmZlbmRpbmdUb2tlbigpO1xyXG5cdFx0XHRpZiAoIXRvaykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGV4Y2VwdGlvbiB0byBoYXZlIGFuIG9mZmVuZGluZyB0b2tlblwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHNvdXJjZSA9IHRvay50b2tlblNvdXJjZTtcclxuXHRcdFx0bGV0IHN0cmVhbSA9IHNvdXJjZSAhPT0gdW5kZWZpbmVkID8gc291cmNlLmlucHV0U3RyZWFtIDogdW5kZWZpbmVkO1xyXG5cdFx0XHRsZXQgc291cmNlUGFpciA9IHsgc291cmNlLCBzdHJlYW0gfTtcclxuXHJcblx0XHRcdGlmIChlIGluc3RhbmNlb2YgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbikge1xyXG5cdFx0XHRcdGxldCBleHBlY3RlZFRva2VucyA9IGUuZXhwZWN0ZWRUb2tlbnM7XHJcblx0XHRcdFx0aWYgKGV4cGVjdGVkVG9rZW5zID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHRoZSBleGNlcHRpb24gdG8gcHJvdmlkZSBleHBlY3RlZCB0b2tlbnNcIik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgZXhwZWN0ZWRUb2tlblR5cGU6IG51bWJlciA9IFRva2VuLklOVkFMSURfVFlQRTtcclxuXHRcdFx0XHRpZiAoIWV4cGVjdGVkVG9rZW5zLmlzTmlsKSB7XHJcblx0XHRcdFx0XHQvLyBnZXQgYW55IGVsZW1lbnRcclxuXHRcdFx0XHRcdGV4cGVjdGVkVG9rZW5UeXBlID0gZXhwZWN0ZWRUb2tlbnMubWluRWxlbWVudDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBlcnJUb2tlbjogVG9rZW4gPVxyXG5cdFx0XHRcdFx0dGhpcy50b2tlbkZhY3RvcnkuY3JlYXRlKHNvdXJjZVBhaXIsXHJcblx0XHRcdFx0XHRcdGV4cGVjdGVkVG9rZW5UeXBlLCB0b2sudGV4dCxcclxuXHRcdFx0XHRcdFx0VG9rZW4uREVGQVVMVF9DSEFOTkVMLFxyXG5cdFx0XHRcdFx0XHQtMSwgLTEsIC8vIGludmFsaWQgc3RhcnQvc3RvcFxyXG5cdFx0XHRcdFx0XHR0b2subGluZSwgdG9rLmNoYXJQb3NpdGlvbkluTGluZSk7XHJcblx0XHRcdFx0dGhpcy5fY3R4LmFkZEVycm9yTm9kZSh0aGlzLmNyZWF0ZUVycm9yTm9kZSh0aGlzLl9jdHgsIGVyclRva2VuKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7IC8vIE5vVmlhYmxlQWx0XHJcblx0XHRcdFx0bGV0IHNvdXJjZSA9IHRvay50b2tlblNvdXJjZTtcclxuXHRcdFx0XHRsZXQgZXJyVG9rZW46IFRva2VuID1cclxuXHRcdFx0XHRcdHRoaXMudG9rZW5GYWN0b3J5LmNyZWF0ZShzb3VyY2VQYWlyLFxyXG5cdFx0XHRcdFx0XHRUb2tlbi5JTlZBTElEX1RZUEUsIHRvay50ZXh0LFxyXG5cdFx0XHRcdFx0XHRUb2tlbi5ERUZBVUxUX0NIQU5ORUwsXHJcblx0XHRcdFx0XHRcdC0xLCAtMSwgLy8gaW52YWxpZCBzdGFydC9zdG9wXHJcblx0XHRcdFx0XHRcdHRvay5saW5lLCB0b2suY2hhclBvc2l0aW9uSW5MaW5lKTtcclxuXHRcdFx0XHR0aGlzLl9jdHguYWRkRXJyb3JOb2RlKHRoaXMuY3JlYXRlRXJyb3JOb2RlKHRoaXMuX2N0eCwgZXJyVG9rZW4pKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHJlY292ZXJJbmxpbmUoKTogVG9rZW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZXR1cm4gdGhlIHJvb3Qgb2YgdGhlIHBhcnNlLCB3aGljaCBjYW4gYmUgdXNlZnVsIGlmIHRoZSBwYXJzZXJcclxuXHQgKiAgYmFpbHMgb3V0LiBZb3Ugc3RpbGwgY2FuIGFjY2VzcyB0aGUgdG9wIG5vZGUuIE5vdGUgdGhhdCxcclxuXHQgKiAgYmVjYXVzZSBvZiB0aGUgd2F5IGxlZnQgcmVjdXJzaXZlIHJ1bGVzIGFkZCBjaGlsZHJlbiwgaXQncyBwb3NzaWJsZVxyXG5cdCAqICB0aGF0IHRoZSByb290IHdpbGwgbm90IGhhdmUgYW55IGNoaWxkcmVuIGlmIHRoZSBzdGFydCBydWxlIGltbWVkaWF0ZWx5XHJcblx0ICogIGNhbGxlZCBhbmQgbGVmdCByZWN1cnNpdmUgcnVsZSB0aGF0IGZhaWxzLlxyXG5cdCAqXHJcblx0ICogQHNpbmNlIDQuNS4xXHJcblx0ICovXHJcblx0Z2V0IHJvb3RDb250ZXh0KCk6IEludGVycHJldGVyUnVsZUNvbnRleHQge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3Jvb3RDb250ZXh0O1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDT05WRVJTVElPTiBjb21wbGV0ZSwgQnVydCBIYXJyaXMgMTAvMTQvMjAxNlxyXG5pbXBvcnQgeyBNdWx0aU1hcCB9IGZyb20gXCIuLi8uLi9taXNjL011bHRpTWFwXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uLy4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlIH0gZnJvbSBcIi4uL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWVQYXR0ZXJuIH0gZnJvbSBcIi4vUGFyc2VUcmVlUGF0dGVyblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHJlc3VsdCBvZiBtYXRjaGluZyBhIHtAbGluayBQYXJzZVRyZWV9IGFnYWluc3QgYSB0cmVlIHBhdHRlcm4uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGFyc2VUcmVlTWF0Y2gge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGB0cmVlYC5cclxuXHQgKi9cclxuXHRwcml2YXRlIF90cmVlOiBQYXJzZVRyZWU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBwYXR0ZXJuYC5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9wYXR0ZXJuOiBQYXJzZVRyZWVQYXR0ZXJuO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgbGFiZWxzYC5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9sYWJlbHM6IE11bHRpTWFwPHN0cmluZywgUGFyc2VUcmVlPjtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3IgYG1pc21hdGNoZWROb2RlYC5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9taXNtYXRjaGVkTm9kZT86IFBhcnNlVHJlZTtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgUGFyc2VUcmVlTWF0Y2h9IGZyb20gdGhlIHNwZWNpZmllZFxyXG5cdCAqIHBhcnNlIHRyZWUgYW5kIHBhdHRlcm4uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gdHJlZSBUaGUgcGFyc2UgdHJlZSB0byBtYXRjaCBhZ2FpbnN0IHRoZSBwYXR0ZXJuLlxyXG5cdCAqIEBwYXJhbSBwYXR0ZXJuIFRoZSBwYXJzZSB0cmVlIHBhdHRlcm4uXHJcblx0ICogQHBhcmFtIGxhYmVscyBBIG1hcHBpbmcgZnJvbSBsYWJlbCBuYW1lcyB0byBjb2xsZWN0aW9ucyBvZlxyXG5cdCAqIHtAbGluayBQYXJzZVRyZWV9IG9iamVjdHMgbG9jYXRlZCBieSB0aGUgdHJlZSBwYXR0ZXJuIG1hdGNoaW5nIHByb2Nlc3MuXHJcblx0ICogQHBhcmFtIG1pc21hdGNoZWROb2RlIFRoZSBmaXJzdCBub2RlIHdoaWNoIGZhaWxlZCB0byBtYXRjaCB0aGUgdHJlZVxyXG5cdCAqIHBhdHRlcm4gZHVyaW5nIHRoZSBtYXRjaGluZyBwcm9jZXNzLlxyXG5cdCAqXHJcblx0ICogQHRocm93cyB7QGxpbmsgRXJyb3J9IGlmIGB0cmVlYCBpcyBub3QgZGVmaW5lZFxyXG5cdCAqIEB0aHJvd3Mge0BsaW5rIEVycm9yfSBpZiBgcGF0dGVybmAgaXMgbm90IGRlZmluZWRcclxuXHQgKiBAdGhyb3dzIHtAbGluayBFcnJvcn0gaWYgYGxhYmVsc2AgaXMgbm90IGRlZmluZWRcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdEBOb3ROdWxsIHRyZWU6IFBhcnNlVHJlZSxcclxuXHRcdEBOb3ROdWxsIHBhdHRlcm46IFBhcnNlVHJlZVBhdHRlcm4sXHJcblx0XHRATm90TnVsbCBsYWJlbHM6IE11bHRpTWFwPHN0cmluZywgUGFyc2VUcmVlPixcclxuXHRcdG1pc21hdGNoZWROb2RlOiBQYXJzZVRyZWUgfCB1bmRlZmluZWQpIHtcclxuXHRcdGlmICghdHJlZSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0cmVlIGNhbm5vdCBiZSBudWxsXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghcGF0dGVybikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJwYXR0ZXJuIGNhbm5vdCBiZSBudWxsXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghbGFiZWxzKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImxhYmVscyBjYW5ub3QgYmUgbnVsbFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl90cmVlID0gdHJlZTtcclxuXHRcdHRoaXMuX3BhdHRlcm4gPSBwYXR0ZXJuO1xyXG5cdFx0dGhpcy5fbGFiZWxzID0gbGFiZWxzO1xyXG5cdFx0dGhpcy5fbWlzbWF0Y2hlZE5vZGUgPSBtaXNtYXRjaGVkTm9kZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbGFzdCBub2RlIGFzc29jaWF0ZWQgd2l0aCBhIHNwZWNpZmljIGBsYWJlbGAuXHJcblx0ICpcclxuXHQgKiBGb3IgZXhhbXBsZSwgZm9yIHBhdHRlcm4gYDxpZDpJRD5gLCBgZ2V0KFwiaWRcIilgIHJldHVybnMgdGhlXHJcblx0ICogbm9kZSBtYXRjaGVkIGZvciB0aGF0IGBJRGAuIElmIG1vcmUgdGhhbiBvbmUgbm9kZVxyXG5cdCAqIG1hdGNoZWQgdGhlIHNwZWNpZmllZCBsYWJlbCwgb25seSB0aGUgbGFzdCBpcyByZXR1cm5lZC4gSWYgdGhlcmUgaXNcclxuXHQgKiBubyBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGFiZWwsIHRoaXMgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuXHQgKlxyXG5cdCAqIFBhdHRlcm4gdGFncyBsaWtlIGA8SUQ+YCBhbmQgYDxleHByPmAgd2l0aG91dCBsYWJlbHMgYXJlXHJcblx0ICogY29uc2lkZXJlZCB0byBiZSBsYWJlbGVkIHdpdGggYElEYCBhbmQgYGV4cHJgLCByZXNwZWN0aXZlbHkuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsIHRvIGNoZWNrLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIGxhc3Qge0BsaW5rIFBhcnNlVHJlZX0gdG8gbWF0Y2ggYSB0YWcgd2l0aCB0aGUgc3BlY2lmaWVkXHJcblx0ICogbGFiZWwsIG9yIGB1bmRlZmluZWRgIGlmIG5vIHBhcnNlIHRyZWUgbWF0Y2hlZCBhIHRhZyB3aXRoIHRoZSBsYWJlbC5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0KGxhYmVsOiBzdHJpbmcpOiBQYXJzZVRyZWUgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IHBhcnNlVHJlZXMgPSB0aGlzLl9sYWJlbHMuZ2V0KGxhYmVsKTtcclxuXHRcdGlmICghcGFyc2VUcmVlcyB8fCBwYXJzZVRyZWVzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXJzZVRyZWVzW3BhcnNlVHJlZXMubGVuZ3RoIC0gMV07IC8vIHJldHVybiBsYXN0IGlmIG11bHRpcGxlXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gYWxsIG5vZGVzIG1hdGNoaW5nIGEgcnVsZSBvciB0b2tlbiB0YWcgd2l0aCB0aGUgc3BlY2lmaWVkIGxhYmVsLlxyXG5cdCAqXHJcblx0ICogSWYgdGhlIGBsYWJlbGAgaXMgdGhlIG5hbWUgb2YgYSBwYXJzZXIgcnVsZSBvciB0b2tlbiBpbiB0aGVcclxuXHQgKiBncmFtbWFyLCB0aGUgcmVzdWx0aW5nIGxpc3Qgd2lsbCBjb250YWluIGJvdGggdGhlIHBhcnNlIHRyZWVzIG1hdGNoaW5nXHJcblx0ICogcnVsZSBvciB0YWdzIGV4cGxpY2l0bHkgbGFiZWxlZCB3aXRoIHRoZSBsYWJlbCBhbmQgdGhlIGNvbXBsZXRlIHNldCBvZlxyXG5cdCAqIHBhcnNlIHRyZWVzIG1hdGNoaW5nIHRoZSBsYWJlbGVkIGFuZCB1bmxhYmVsZWQgdGFncyBpbiB0aGUgcGF0dGVybiBmb3JcclxuXHQgKiB0aGUgcGFyc2VyIHJ1bGUgb3IgdG9rZW4uIEZvciBleGFtcGxlLCBpZiBgbGFiZWxgIGlzIGBcImZvb1wiYCxcclxuXHQgKiB0aGUgcmVzdWx0IHdpbGwgY29udGFpbiAqYWxsKiBvZiB0aGUgZm9sbG93aW5nLlxyXG5cdCAqXHJcblx0ICogKiBQYXJzZSB0cmVlIG5vZGVzIG1hdGNoaW5nIHRhZ3Mgb2YgdGhlIGZvcm0gYDxmb286YW55UnVsZU5hbWU+YCBhbmRcclxuXHQgKiAgIGA8Zm9vOkFueVRva2VuTmFtZT5gLlxyXG5cdCAqICogUGFyc2UgdHJlZSBub2RlcyBtYXRjaGluZyB0YWdzIG9mIHRoZSBmb3JtIGA8YW55TGFiZWw6Zm9vPmAuXHJcblx0ICogKiBQYXJzZSB0cmVlIG5vZGVzIG1hdGNoaW5nIHRhZ3Mgb2YgdGhlIGZvcm0gYDxmb28+YC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBsYWJlbCBUaGUgbGFiZWwuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBBIGNvbGxlY3Rpb24gb2YgYWxsIHtAbGluayBQYXJzZVRyZWV9IG5vZGVzIG1hdGNoaW5nIHRhZ3Mgd2l0aFxyXG5cdCAqIHRoZSBzcGVjaWZpZWQgYGxhYmVsYC4gSWYgbm8gbm9kZXMgbWF0Y2hlZCB0aGUgbGFiZWwsIGFuIGVtcHR5IGxpc3RcclxuXHQgKiBpcyByZXR1cm5lZC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRBbGwoQE5vdE51bGwgbGFiZWw6IHN0cmluZyk6IFBhcnNlVHJlZVtdIHtcclxuXHRcdGNvbnN0IG5vZGVzID0gdGhpcy5fbGFiZWxzLmdldChsYWJlbCk7XHJcblx0XHRpZiAoIW5vZGVzKSB7XHJcblx0XHRcdHJldHVybiBbXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBub2RlcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiBhIG1hcHBpbmcgZnJvbSBsYWJlbCAmcmFycjsgW2xpc3Qgb2Ygbm9kZXNdLlxyXG5cdCAqXHJcblx0ICogVGhlIG1hcCBpbmNsdWRlcyBzcGVjaWFsIGVudHJpZXMgY29ycmVzcG9uZGluZyB0byB0aGUgbmFtZXMgb2YgcnVsZXMgYW5kXHJcblx0ICogdG9rZW5zIHJlZmVyZW5jZWQgaW4gdGFncyBpbiB0aGUgb3JpZ2luYWwgcGF0dGVybi4gRm9yIGFkZGl0aW9uYWxcclxuXHQgKiBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkZXNjcmlwdGlvbiBvZiB7QGxpbmsgI2dldEFsbChTdHJpbmcpfS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIEEgbWFwcGluZyBmcm9tIGxhYmVscyB0byBwYXJzZSB0cmVlIG5vZGVzLiBJZiB0aGUgcGFyc2UgdHJlZVxyXG5cdCAqIHBhdHRlcm4gZGlkIG5vdCBjb250YWluIGFueSBydWxlIG9yIHRva2VuIHRhZ3MsIHRoaXMgbWFwIHdpbGwgYmUgZW1wdHkuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRnZXQgbGFiZWxzKCk6IE11bHRpTWFwPHN0cmluZywgUGFyc2VUcmVlPiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGFiZWxzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBub2RlIGF0IHdoaWNoIHdlIGZpcnN0IGRldGVjdGVkIGEgbWlzbWF0Y2guXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB0aGUgbm9kZSBhdCB3aGljaCB3ZSBmaXJzdCBkZXRlY3RlZCBhIG1pc21hdGNoLCBvciBgdW5kZWZpbmVkYFxyXG5cdCAqIGlmIHRoZSBtYXRjaCB3YXMgc3VjY2Vzc2Z1bC5cclxuXHQgKi9cclxuXHRnZXQgbWlzbWF0Y2hlZE5vZGUoKTogUGFyc2VUcmVlIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLl9taXNtYXRjaGVkTm9kZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIG1hdGNoIG9wZXJhdGlvbiBzdWNjZWVkZWQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1hdGNoIG9wZXJhdGlvbiBzdWNjZWVkZWQ7IG90aGVyd2lzZSxcclxuXHQgKiBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdGdldCBzdWNjZWVkZWQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gIXRoaXMuX21pc21hdGNoZWROb2RlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSB0cmVlIHBhdHRlcm4gd2UgYXJlIG1hdGNoaW5nIGFnYWluc3QuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgdHJlZSBwYXR0ZXJuIHdlIGFyZSBtYXRjaGluZyBhZ2FpbnN0LlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IHBhdHRlcm4oKTogUGFyc2VUcmVlUGF0dGVybiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGF0dGVybjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgcGFyc2UgdHJlZSB3ZSBhcmUgdHJ5aW5nIHRvIG1hdGNoIHRvIGEgcGF0dGVybi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSB7QGxpbmsgUGFyc2VUcmVlfSB3ZSBhcmUgdHJ5aW5nIHRvIG1hdGNoIHRvIGEgcGF0dGVybi5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCB0cmVlKCk6IFBhcnNlVHJlZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJlZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgTWF0Y2ggJHtcclxuXHRcdFx0dGhpcy5zdWNjZWVkZWQgPyBcInN1Y2NlZWRlZFwiIDogXCJmYWlsZWRcIn07IGZvdW5kICR7XHJcblx0XHRcdHRoaXMubGFiZWxzLnNpemV9IGxhYmVsc2A7XHJcblx0fVxyXG59XHJcbiIsICIvLyBHZW5lcmF0ZWQgZnJvbSBYUGF0aExleGVyLmc0IGJ5IEFOVExSIDQuOS4wLVNOQVBTSE9UXHJcblxyXG5cclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4uLy4uL2F0bi9BVE5cIjtcclxuaW1wb3J0IHsgQVRORGVzZXJpYWxpemVyIH0gZnJvbSBcIi4uLy4uL2F0bi9BVE5EZXNlcmlhbGl6ZXJcIjtcclxuaW1wb3J0IHsgQ2hhclN0cmVhbSB9IGZyb20gXCIuLi8uLi9DaGFyU3RyZWFtXCI7XHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uLy4uL0xleGVyXCI7XHJcbmltcG9ydCB7IExleGVyQVROU2ltdWxhdG9yIH0gZnJvbSBcIi4uLy4uL2F0bi9MZXhlckFUTlNpbXVsYXRvclwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsIH0gZnJvbSBcIi4uLy4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCIuLi8uLi9SdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBWb2NhYnVsYXJ5IH0gZnJvbSBcIi4uLy4uL1ZvY2FidWxhcnlcIjtcclxuaW1wb3J0IHsgVm9jYWJ1bGFyeUltcGwgfSBmcm9tIFwiLi4vLi4vVm9jYWJ1bGFyeUltcGxcIjtcclxuXHJcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gXCIuLi8uLi9taXNjL1V0aWxzXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFhQYXRoTGV4ZXIgZXh0ZW5kcyBMZXhlciB7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBUT0tFTl9SRUYgPSAxO1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUlVMRV9SRUYgPSAyO1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQU5ZV0hFUkUgPSAzO1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUk9PVCA9IDQ7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBXSUxEQ0FSRCA9IDU7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBCQU5HID0gNjtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IElEID0gNztcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNUUklORyA9IDg7XHJcblxyXG5cdC8vIHRzbGludDpkaXNhYmxlOm5vLXRyYWlsaW5nLXdoaXRlc3BhY2VcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNoYW5uZWxOYW1lczogc3RyaW5nW10gPSBbXHJcblx0XHRcIkRFRkFVTFRfVE9LRU5fQ0hBTk5FTFwiLCBcIkhJRERFTlwiLFxyXG5cdF07XHJcblxyXG5cdC8vIHRzbGludDpkaXNhYmxlOm5vLXRyYWlsaW5nLXdoaXRlc3BhY2VcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IG1vZGVOYW1lczogc3RyaW5nW10gPSBbXHJcblx0XHRcIkRFRkFVTFRfTU9ERVwiLFxyXG5cdF07XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgcnVsZU5hbWVzOiBzdHJpbmdbXSA9IFtcclxuXHRcdFwiQU5ZV0hFUkVcIiwgXCJST09UXCIsIFwiV0lMRENBUkRcIiwgXCJCQU5HXCIsIFwiSURcIiwgXCJOYW1lQ2hhclwiLCBcIk5hbWVTdGFydENoYXJcIiwgXHJcblx0XHRcIlNUUklOR1wiLFxyXG5cdF07XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IF9MSVRFUkFMX05BTUVTOiBBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0gW1xyXG5cdFx0dW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCInLy8nXCIsIFwiJy8nXCIsIFwiJyonXCIsIFwiJyEnXCIsXHJcblx0XTtcclxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBfU1lNQk9MSUNfTkFNRVM6IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZD4gPSBbXHJcblx0XHR1bmRlZmluZWQsIFwiVE9LRU5fUkVGXCIsIFwiUlVMRV9SRUZcIiwgXCJBTllXSEVSRVwiLCBcIlJPT1RcIiwgXCJXSUxEQ0FSRFwiLCBcIkJBTkdcIiwgXHJcblx0XHRcIklEXCIsIFwiU1RSSU5HXCIsXHJcblx0XTtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFZPQ0FCVUxBUlk6IFZvY2FidWxhcnkgPSBuZXcgVm9jYWJ1bGFyeUltcGwoWFBhdGhMZXhlci5fTElURVJBTF9OQU1FUywgWFBhdGhMZXhlci5fU1lNQk9MSUNfTkFNRVMsIFtdKTtcclxuXHJcblx0Ly8gQE92ZXJyaWRlXHJcblx0Ly8gQE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0IHZvY2FidWxhcnkoKTogVm9jYWJ1bGFyeSB7XHJcblx0XHRyZXR1cm4gWFBhdGhMZXhlci5WT0NBQlVMQVJZO1xyXG5cdH1cclxuXHQvLyB0c2xpbnQ6ZW5hYmxlOm5vLXRyYWlsaW5nLXdoaXRlc3BhY2VcclxuXHJcblxyXG5cdGNvbnN0cnVjdG9yKGlucHV0OiBDaGFyU3RyZWFtKSB7XHJcblx0XHRzdXBlcihpbnB1dCk7XHJcblx0XHR0aGlzLl9pbnRlcnAgPSBuZXcgTGV4ZXJBVE5TaW11bGF0b3IoWFBhdGhMZXhlci5fQVROLCB0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXQgZ3JhbW1hckZpbGVOYW1lKCk6IHN0cmluZyB7IHJldHVybiBcIlhQYXRoTGV4ZXIuZzRcIjsgfVxyXG5cclxuXHQvLyBAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0IHJ1bGVOYW1lcygpOiBzdHJpbmdbXSB7IHJldHVybiBYUGF0aExleGVyLnJ1bGVOYW1lczsgfVxyXG5cclxuXHQvLyBAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZ2V0IHNlcmlhbGl6ZWRBVE4oKTogc3RyaW5nIHsgcmV0dXJuIFhQYXRoTGV4ZXIuX3NlcmlhbGl6ZWRBVE47IH1cclxuXHJcblx0Ly8gQE92ZXJyaWRlXHJcblx0cHVibGljIGdldCBjaGFubmVsTmFtZXMoKTogc3RyaW5nW10geyByZXR1cm4gWFBhdGhMZXhlci5jaGFubmVsTmFtZXM7IH1cclxuXHJcblx0Ly8gQE92ZXJyaWRlXHJcblx0cHVibGljIGdldCBtb2RlTmFtZXMoKTogc3RyaW5nW10geyByZXR1cm4gWFBhdGhMZXhlci5tb2RlTmFtZXM7IH1cclxuXHJcblx0Ly8gQE92ZXJyaWRlXHJcblx0cHVibGljIGFjdGlvbihfbG9jYWxjdHg6IFJ1bGVDb250ZXh0LCBydWxlSW5kZXg6IG51bWJlciwgYWN0aW9uSW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0c3dpdGNoIChydWxlSW5kZXgpIHtcclxuXHRcdGNhc2UgNDpcclxuXHRcdFx0dGhpcy5JRF9hY3Rpb24oX2xvY2FsY3R4LCBhY3Rpb25JbmRleCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwcml2YXRlIElEX2FjdGlvbihfbG9jYWxjdHg6IFJ1bGVDb250ZXh0LCBhY3Rpb25JbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRzd2l0Y2ggKGFjdGlvbkluZGV4KSB7XHJcblx0XHRjYXNlIDA6XHJcblxyXG5cdFx0XHRsZXQgdGV4dCA9IHRoaXMudGV4dDtcclxuXHRcdFx0aWYgKHRleHQuY2hhckF0KDApID09PSB0ZXh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpKSB7XHJcblx0XHRcdFx0dGhpcy50eXBlID0gWFBhdGhMZXhlci5UT0tFTl9SRUY7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy50eXBlID0gWFBhdGhMZXhlci5SVUxFX1JFRjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBfc2VyaWFsaXplZEFUTlNlZ21lbnRzOiBudW1iZXIgPSAyO1xyXG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IF9zZXJpYWxpemVkQVROU2VnbWVudDA6IHN0cmluZyA9XHJcblx0XHRcIlxceDAzXFx1QzkxRFxcdUNBQkFcXHUwNThEXFx1QUZCQVxcdTRGNTNcXHUwNjA3XFx1RUE4QlxcdUMyNDFcXHgwMlxcbjJcXGJcXHgwMVxceDA0XCIgK1xyXG5cdFx0XCJcXHgwMlxcdFxceDAyXFx4MDRcXHgwM1xcdFxceDAzXFx4MDRcXHgwNFxcdFxceDA0XFx4MDRcXHgwNVxcdFxceDA1XFx4MDRcXHgwNlxcdFxceDA2XFx4MDRcIiArXHJcblx0XHRcIlxceDA3XFx0XFx4MDdcXHgwNFxcYlxcdFxcYlxceDA0XFx0XFx0XFx0XFx4MDNcXHgwMlxceDAzXFx4MDJcXHgwM1xceDAyXFx4MDNcXHgwM1xceDAzXFx4MDNcIiArXHJcblx0XHRcIlxceDAzXFx4MDRcXHgwM1xceDA0XFx4MDNcXHgwNVxceDAzXFx4MDVcXHgwM1xceDA2XFx4MDNcXHgwNlxceDA3XFx4MDZcXHgxRlxcblxceDA2XFxmXFx4MDZcIiArXHJcblx0XHRcIlxceDBFXFx4MDZcXFwiXFx2XFx4MDZcXHgwM1xceDA2XFx4MDNcXHgwNlxceDAzXFx4MDdcXHgwM1xceDA3XFx4MDNcXGJcXHgwM1xcYlxceDAzXFx0XFx4MDNcIiArXHJcblx0XHRcIlxcdFxceDA3XFx0LFxcblxcdFxcZlxcdFxceDBFXFx0L1xcdlxcdFxceDAzXFx0XFx4MDNcXHRcXHgwMy1cXHgwMlxceDAyXFxuXFx4MDNcXHgwMlxceDA1XFx4MDVcIiArXHJcblx0XHRcIlxceDAyXFx4MDZcXHgwN1xceDAyXFx4MDdcXHRcXHgwMlxcYlxcdlxceDAyXFx0XFxyXFx4MDJcXHgwMlxceDBGXFx4MDJcXHgwMlxceDExXFx4MDJcXG5cXHgwM1wiICtcclxuXHRcdFwiXFx4MDJcXHgwMlxceDA0XFx1MDJCNlxceDAyXFx4MDJcXHgwMlxcblxceDAyXFx4MTBcXHgwMlxceDFEXFx4MDIyXFx4MDI7XFx4MDJDXFx4MDJcXFxcXCIgK1xyXG5cdFx0XCJcXHgwMmFcXHgwMmFcXHgwMmNcXHgwMnxcXHgwMlxceDgxXFx4MDJcXHhBMVxceDAyXFx4QUNcXHgwMlxceEFDXFx4MDJcXHhBRlxceDAyXFx4QUZcXHgwMlwiICtcclxuXHRcdFwiXFx4QjdcXHgwMlxceEI3XFx4MDJcXHhCQ1xceDAyXFx4QkNcXHgwMlxceEMyXFx4MDJcXHhEOFxceDAyXFx4REFcXHgwMlxceEY4XFx4MDJcXHhGQVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwMkMzXFx4MDJcXHUwMkM4XFx4MDJcXHUwMkQzXFx4MDJcXHUwMkUyXFx4MDJcXHUwMkU2XFx4MDJcXHUwMkVFXFx4MDJcXHUwMkVFXFx4MDJcIiArXHJcblx0XHRcIlxcdTAyRjBcXHgwMlxcdTAyRjBcXHgwMlxcdTAzMDJcXHgwMlxcdTAzNzZcXHgwMlxcdTAzNzhcXHgwMlxcdTAzNzlcXHgwMlxcdTAzN0NcXHgwMlwiICtcclxuXHRcdFwiXFx1MDM3RlxceDAyXFx1MDM4MVxceDAyXFx1MDM4MVxceDAyXFx1MDM4OFxceDAyXFx1MDM4OFxceDAyXFx1MDM4QVxceDAyXFx1MDM4Q1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwMzhFXFx4MDJcXHUwMzhFXFx4MDJcXHUwMzkwXFx4MDJcXHUwM0EzXFx4MDJcXHUwM0E1XFx4MDJcXHUwM0Y3XFx4MDJcXHUwM0Y5XFx4MDJcIiArXHJcblx0XHRcIlxcdTA0ODNcXHgwMlxcdTA0ODVcXHgwMlxcdTA0ODlcXHgwMlxcdTA0OENcXHgwMlxcdTA1MzFcXHgwMlxcdTA1MzNcXHgwMlxcdTA1NThcXHgwMlwiICtcclxuXHRcdFwiXFx1MDU1QlxceDAyXFx1MDU1QlxceDAyXFx1MDU2M1xceDAyXFx1MDU4OVxceDAyXFx1MDU5M1xceDAyXFx1MDVCRlxceDAyXFx1MDVDMVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwNUMxXFx4MDJcXHUwNUMzXFx4MDJcXHUwNUM0XFx4MDJcXHUwNUM2XFx4MDJcXHUwNUM3XFx4MDJcXHUwNUM5XFx4MDJcXHUwNUM5XFx4MDJcIiArXHJcblx0XHRcIlxcdTA1RDJcXHgwMlxcdTA1RUNcXHgwMlxcdTA1RjJcXHgwMlxcdTA1RjRcXHgwMlxcdTA2MDJcXHgwMlxcdTA2MDdcXHgwMlxcdTA2MTJcXHgwMlwiICtcclxuXHRcdFwiXFx1MDYxQ1xceDAyXFx1MDYxRVxceDAyXFx1MDYxRVxceDAyXFx1MDYyMlxceDAyXFx1MDY2QlxceDAyXFx1MDY3MFxceDAyXFx1MDZENVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwNkQ3XFx4MDJcXHUwNkRGXFx4MDJcXHUwNkUxXFx4MDJcXHUwNkVBXFx4MDJcXHUwNkVDXFx4MDJcXHUwNkZFXFx4MDJcXHUwNzAxXFx4MDJcIiArXHJcblx0XHRcIlxcdTA3MDFcXHgwMlxcdTA3MTFcXHgwMlxcdTA3NENcXHgwMlxcdTA3NEZcXHgwMlxcdTA3QjNcXHgwMlxcdTA3QzJcXHgwMlxcdTA3RjdcXHgwMlwiICtcclxuXHRcdFwiXFx1MDdGQ1xceDAyXFx1MDdGQ1xceDAyXFx1MDgwMlxceDAyXFx1MDgyRlxceDAyXFx1MDg0MlxceDAyXFx1MDg1RFxceDAyXFx1MDhBMlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwOEI2XFx4MDJcXHUwOEI4XFx4MDJcXHUwOEJGXFx4MDJcXHUwOEQ2XFx4MDJcXHUwOTY1XFx4MDJcXHUwOTY4XFx4MDJcXHUwOTcxXFx4MDJcIiArXHJcblx0XHRcIlxcdTA5NzNcXHgwMlxcdTA5ODVcXHgwMlxcdTA5ODdcXHgwMlxcdTA5OEVcXHgwMlxcdTA5OTFcXHgwMlxcdTA5OTJcXHgwMlxcdTA5OTVcXHgwMlwiICtcclxuXHRcdFwiXFx1MDlBQVxceDAyXFx1MDlBQ1xceDAyXFx1MDlCMlxceDAyXFx1MDlCNFxceDAyXFx1MDlCNFxceDAyXFx1MDlCOFxceDAyXFx1MDlCQlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwOUJFXFx4MDJcXHUwOUM2XFx4MDJcXHUwOUM5XFx4MDJcXHUwOUNBXFx4MDJcXHUwOUNEXFx4MDJcXHUwOUQwXFx4MDJcXHUwOUQ5XFx4MDJcIiArXHJcblx0XHRcIlxcdTA5RDlcXHgwMlxcdTA5REVcXHgwMlxcdTA5REZcXHgwMlxcdTA5RTFcXHgwMlxcdTA5RTVcXHgwMlxcdTA5RThcXHgwMlxcdTA5RjNcXHgwMlwiICtcclxuXHRcdFwiXFx1MEEwM1xceDAyXFx1MEEwNVxceDAyXFx1MEEwN1xceDAyXFx1MEEwQ1xceDAyXFx1MEExMVxceDAyXFx1MEExMlxceDAyXFx1MEExNVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQTJBXFx4MDJcXHUwQTJDXFx4MDJcXHUwQTMyXFx4MDJcXHUwQTM0XFx4MDJcXHUwQTM1XFx4MDJcXHUwQTM3XFx4MDJcXHUwQTM4XFx4MDJcIiArXHJcblx0XHRcIlxcdTBBM0FcXHgwMlxcdTBBM0JcXHgwMlxcdTBBM0VcXHgwMlxcdTBBM0VcXHgwMlxcdTBBNDBcXHgwMlxcdTBBNDRcXHgwMlxcdTBBNDlcXHgwMlwiICtcclxuXHRcdFwiXFx1MEE0QVxceDAyXFx1MEE0RFxceDAyXFx1MEE0RlxceDAyXFx1MEE1M1xceDAyXFx1MEE1M1xceDAyXFx1MEE1QlxceDAyXFx1MEE1RVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQTYwXFx4MDJcXHUwQTYwXFx4MDJcXHUwQTY4XFx4MDJcXHUwQTc3XFx4MDJcXHUwQTgzXFx4MDJcXHUwQTg1XFx4MDJcXHUwQTg3XFx4MDJcIiArXHJcblx0XHRcIlxcdTBBOEZcXHgwMlxcdTBBOTFcXHgwMlxcdTBBOTNcXHgwMlxcdTBBOTVcXHgwMlxcdTBBQUFcXHgwMlxcdTBBQUNcXHgwMlxcdTBBQjJcXHgwMlwiICtcclxuXHRcdFwiXFx1MEFCNFxceDAyXFx1MEFCNVxceDAyXFx1MEFCN1xceDAyXFx1MEFCQlxceDAyXFx1MEFCRVxceDAyXFx1MEFDN1xceDAyXFx1MEFDOVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQUNCXFx4MDJcXHUwQUNEXFx4MDJcXHUwQUNGXFx4MDJcXHUwQUQyXFx4MDJcXHUwQUQyXFx4MDJcXHUwQUUyXFx4MDJcXHUwQUU1XFx4MDJcIiArXHJcblx0XHRcIlxcdTBBRThcXHgwMlxcdTBBRjFcXHgwMlxcdTBBRkJcXHgwMlxcdTBBRkJcXHgwMlxcdTBCMDNcXHgwMlxcdTBCMDVcXHgwMlxcdTBCMDdcXHgwMlwiICtcclxuXHRcdFwiXFx1MEIwRVxceDAyXFx1MEIxMVxceDAyXFx1MEIxMlxceDAyXFx1MEIxNVxceDAyXFx1MEIyQVxceDAyXFx1MEIyQ1xceDAyXFx1MEIzMlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQjM0XFx4MDJcXHUwQjM1XFx4MDJcXHUwQjM3XFx4MDJcXHUwQjNCXFx4MDJcXHUwQjNFXFx4MDJcXHUwQjQ2XFx4MDJcXHUwQjQ5XFx4MDJcIiArXHJcblx0XHRcIlxcdTBCNEFcXHgwMlxcdTBCNERcXHgwMlxcdTBCNEZcXHgwMlxcdTBCNThcXHgwMlxcdTBCNTlcXHgwMlxcdTBCNUVcXHgwMlxcdTBCNUZcXHgwMlwiICtcclxuXHRcdFwiXFx1MEI2MVxceDAyXFx1MEI2NVxceDAyXFx1MEI2OFxceDAyXFx1MEI3MVxceDAyXFx1MEI3M1xceDAyXFx1MEI3M1xceDAyXFx1MEI4NFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQjg1XFx4MDJcXHUwQjg3XFx4MDJcXHUwQjhDXFx4MDJcXHUwQjkwXFx4MDJcXHUwQjkyXFx4MDJcXHUwQjk0XFx4MDJcXHUwQjk3XFx4MDJcIiArXHJcblx0XHRcIlxcdTBCOUJcXHgwMlxcdTBCOUNcXHgwMlxcdTBCOUVcXHgwMlxcdTBCOUVcXHgwMlxcdTBCQTBcXHgwMlxcdTBCQTFcXHgwMlxcdTBCQTVcXHgwMlwiICtcclxuXHRcdFwiXFx1MEJBNlxceDAyXFx1MEJBQVxceDAyXFx1MEJBQ1xceDAyXFx1MEJCMFxceDAyXFx1MEJCQlxceDAyXFx1MEJDMFxceDAyXFx1MEJDNFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQkM4XFx4MDJcXHUwQkNBXFx4MDJcXHUwQkNDXFx4MDJcXHUwQkNGXFx4MDJcXHUwQkQyXFx4MDJcXHUwQkQyXFx4MDJcXHUwQkQ5XFx4MDJcIiArXHJcblx0XHRcIlxcdTBCRDlcXHgwMlxcdTBCRThcXHgwMlxcdTBCRjFcXHgwMlxcdTBDMDJcXHgwMlxcdTBDMDVcXHgwMlxcdTBDMDdcXHgwMlxcdTBDMEVcXHgwMlwiICtcclxuXHRcdFwiXFx1MEMxMFxceDAyXFx1MEMxMlxceDAyXFx1MEMxNFxceDAyXFx1MEMyQVxceDAyXFx1MEMyQ1xceDAyXFx1MEMzQlxceDAyXFx1MEMzRlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQzQ2XFx4MDJcXHUwQzQ4XFx4MDJcXHUwQzRBXFx4MDJcXHUwQzRDXFx4MDJcXHUwQzRGXFx4MDJcXHUwQzU3XFx4MDJcXHUwQzU4XFx4MDJcIiArXHJcblx0XHRcIlxcdTBDNUFcXHgwMlxcdTBDNUNcXHgwMlxcdTBDNjJcXHgwMlxcdTBDNjVcXHgwMlxcdTBDNjhcXHgwMlxcdTBDNzFcXHgwMlxcdTBDODJcXHgwMlwiICtcclxuXHRcdFwiXFx1MEM4NVxceDAyXFx1MEM4N1xceDAyXFx1MEM4RVxceDAyXFx1MEM5MFxceDAyXFx1MEM5MlxceDAyXFx1MEM5NFxceDAyXFx1MENBQVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQ0FDXFx4MDJcXHUwQ0I1XFx4MDJcXHUwQ0I3XFx4MDJcXHUwQ0JCXFx4MDJcXHUwQ0JFXFx4MDJcXHUwQ0M2XFx4MDJcXHUwQ0M4XFx4MDJcIiArXHJcblx0XHRcIlxcdTBDQ0FcXHgwMlxcdTBDQ0NcXHgwMlxcdTBDQ0ZcXHgwMlxcdTBDRDdcXHgwMlxcdTBDRDhcXHgwMlxcdTBDRTBcXHgwMlxcdTBDRTBcXHgwMlwiICtcclxuXHRcdFwiXFx1MENFMlxceDAyXFx1MENFNVxceDAyXFx1MENFOFxceDAyXFx1MENGMVxceDAyXFx1MENGM1xceDAyXFx1MENGNFxceDAyXFx1MEQwM1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwRDA1XFx4MDJcXHUwRDA3XFx4MDJcXHUwRDBFXFx4MDJcXHUwRDEwXFx4MDJcXHUwRDEyXFx4MDJcXHUwRDE0XFx4MDJcXHUwRDNDXFx4MDJcIiArXHJcblx0XHRcIlxcdTBEM0ZcXHgwMlxcdTBENDZcXHgwMlxcdTBENDhcXHgwMlxcdTBENEFcXHgwMlxcdTBENENcXHgwMlxcdTBENTBcXHgwMlxcdTBENTZcXHgwMlwiICtcclxuXHRcdFwiXFx1MEQ1OVxceDAyXFx1MEQ2MVxceDAyXFx1MEQ2NVxceDAyXFx1MEQ2OFxceDAyXFx1MEQ3MVxceDAyXFx1MEQ3Q1xceDAyXFx1MEQ4MVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRDg0XFx4MDJcXHUwRDg1XFx4MDJcXHUwRDg3XFx4MDJcXHUwRDk4XFx4MDJcXHUwRDlDXFx4MDJcXHUwREIzXFx4MDJcXHUwREI1XFx4MDJcIiArXHJcblx0XHRcIlxcdTBEQkRcXHgwMlxcdTBEQkZcXHgwMlxcdTBEQkZcXHgwMlxcdTBEQzJcXHgwMlxcdTBEQzhcXHgwMlxcdTBEQ0NcXHgwMlxcdTBEQ0NcXHgwMlwiICtcclxuXHRcdFwiXFx1MEREMVxceDAyXFx1MERENlxceDAyXFx1MEREOFxceDAyXFx1MEREOFxceDAyXFx1MEREQVxceDAyXFx1MERFMVxceDAyXFx1MERFOFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwREYxXFx4MDJcXHUwREY0XFx4MDJcXHUwREY1XFx4MDJcXHUwRTAzXFx4MDJcXHUwRTNDXFx4MDJcXHUwRTQyXFx4MDJcXHUwRTUwXFx4MDJcIiArXHJcblx0XHRcIlxcdTBFNTJcXHgwMlxcdTBFNUJcXHgwMlxcdTBFODNcXHgwMlxcdTBFODRcXHgwMlxcdTBFODZcXHgwMlxcdTBFODZcXHgwMlxcdTBFODlcXHgwMlwiICtcclxuXHRcdFwiXFx1MEU4QVxceDAyXFx1MEU4Q1xceDAyXFx1MEU4Q1xceDAyXFx1MEU4RlxceDAyXFx1MEU4RlxceDAyXFx1MEU5NlxceDAyXFx1MEU5OVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRTlCXFx4MDJcXHUwRUExXFx4MDJcXHUwRUEzXFx4MDJcXHUwRUE1XFx4MDJcXHUwRUE3XFx4MDJcXHUwRUE3XFx4MDJcXHUwRUE5XFx4MDJcIiArXHJcblx0XHRcIlxcdTBFQTlcXHgwMlxcdTBFQUNcXHgwMlxcdTBFQURcXHgwMlxcdTBFQUZcXHgwMlxcdTBFQkJcXHgwMlxcdTBFQkRcXHgwMlxcdTBFQkZcXHgwMlwiICtcclxuXHRcdFwiXFx1MEVDMlxceDAyXFx1MEVDNlxceDAyXFx1MEVDOFxceDAyXFx1MEVDOFxceDAyXFx1MEVDQVxceDAyXFx1MEVDRlxceDAyXFx1MEVEMlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRURCXFx4MDJcXHUwRURFXFx4MDJcXHUwRUUxXFx4MDJcXHUwRjAyXFx4MDJcXHUwRjAyXFx4MDJcXHUwRjFBXFx4MDJcXHUwRjFCXFx4MDJcIiArXHJcblx0XHRcIlxcdTBGMjJcXHgwMlxcdTBGMkJcXHgwMlxcdTBGMzdcXHgwMlxcdTBGMzdcXHgwMlxcdTBGMzlcXHgwMlxcdTBGMzlcXHgwMlxcdTBGM0JcXHgwMlwiICtcclxuXHRcdFwiXFx1MEYzQlxceDAyXFx1MEY0MFxceDAyXFx1MEY0OVxceDAyXFx1MEY0QlxceDAyXFx1MEY2RVxceDAyXFx1MEY3M1xceDAyXFx1MEY4NlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRjg4XFx4MDJcXHUwRjk5XFx4MDJcXHUwRjlCXFx4MDJcXHUwRkJFXFx4MDJcXHUwRkM4XFx4MDJcXHUwRkM4XFx4MDJcXHUxMDAyXFx4MDJcIiArXHJcblx0XHRcIlxcdTEwNEJcXHgwMlxcdTEwNTJcXHgwMlxcdTEwOUZcXHgwMlxcdTEwQTJcXHgwMlxcdTEwQzdcXHgwMlxcdTEwQzlcXHgwMlxcdTEwQzlcXHgwMlwiICtcclxuXHRcdFwiXFx1MTBDRlxceDAyXFx1MTBDRlxceDAyXFx1MTBEMlxceDAyXFx1MTBGQ1xceDAyXFx1MTBGRVxceDAyXFx1MTI0QVxceDAyXFx1MTI0Q1xceDAyXCIgK1xyXG5cdFx0XCJcXHUxMjRGXFx4MDJcXHUxMjUyXFx4MDJcXHUxMjU4XFx4MDJcXHUxMjVBXFx4MDJcXHUxMjVBXFx4MDJcXHUxMjVDXFx4MDJcXHUxMjVGXFx4MDJcIiArXHJcblx0XHRcIlxcdTEyNjJcXHgwMlxcdTEyOEFcXHgwMlxcdTEyOENcXHgwMlxcdTEyOEZcXHgwMlxcdTEyOTJcXHgwMlxcdTEyQjJcXHgwMlxcdTEyQjRcXHgwMlwiICtcclxuXHRcdFwiXFx1MTJCN1xceDAyXFx1MTJCQVxceDAyXFx1MTJDMFxceDAyXFx1MTJDMlxceDAyXFx1MTJDMlxceDAyXFx1MTJDNFxceDAyXFx1MTJDN1xceDAyXCIgK1xyXG5cdFx0XCJcXHUxMkNBXFx4MDJcXHUxMkQ4XFx4MDJcXHUxMkRBXFx4MDJcXHUxMzEyXFx4MDJcXHUxMzE0XFx4MDJcXHUxMzE3XFx4MDJcXHUxMzFBXFx4MDJcIiArXHJcblx0XHRcIlxcdTEzNUNcXHgwMlxcdTEzNUZcXHgwMlxcdTEzNjFcXHgwMlxcdTEzODJcXHgwMlxcdTEzOTFcXHgwMlxcdTEzQTJcXHgwMlxcdTEzRjdcXHgwMlwiICtcclxuXHRcdFwiXFx1MTNGQVxceDAyXFx1MTNGRlxceDAyXFx1MTQwM1xceDAyXFx1MTY2RVxceDAyXFx1MTY3MVxceDAyXFx1MTY4MVxceDAyXFx1MTY4M1xceDAyXCIgK1xyXG5cdFx0XCJcXHUxNjlDXFx4MDJcXHUxNkEyXFx4MDJcXHUxNkVDXFx4MDJcXHUxNkYwXFx4MDJcXHUxNkZBXFx4MDJcXHUxNzAyXFx4MDJcXHUxNzBFXFx4MDJcIiArXHJcblx0XHRcIlxcdTE3MTBcXHgwMlxcdTE3MTZcXHgwMlxcdTE3MjJcXHgwMlxcdTE3MzZcXHgwMlxcdTE3NDJcXHgwMlxcdTE3NTVcXHgwMlxcdTE3NjJcXHgwMlwiICtcclxuXHRcdFwiXFx1MTc2RVxceDAyXFx1MTc3MFxceDAyXFx1MTc3MlxceDAyXFx1MTc3NFxceDAyXFx1MTc3NVxceDAyXFx1MTc4MlxceDAyXFx1MTdENVxceDAyXCIgK1xyXG5cdFx0XCJcXHUxN0Q5XFx4MDJcXHUxN0Q5XFx4MDJcXHUxN0RFXFx4MDJcXHUxN0RGXFx4MDJcXHUxN0UyXFx4MDJcXHUxN0VCXFx4MDJcXHUxODBEXFx4MDJcIiArXHJcblx0XHRcIlxcdTE4MTBcXHgwMlxcdTE4MTJcXHgwMlxcdTE4MUJcXHgwMlxcdTE4MjJcXHgwMlxcdTE4NzlcXHgwMlxcdTE4ODJcXHgwMlxcdTE4QUNcXHgwMlwiICtcclxuXHRcdFwiXFx1MThCMlxceDAyXFx1MThGN1xceDAyXFx1MTkwMlxceDAyXFx1MTkyMFxceDAyXFx1MTkyMlxceDAyXFx1MTkyRFxceDAyXFx1MTkzMlxceDAyXCIgK1xyXG5cdFx0XCJcXHUxOTNEXFx4MDJcXHUxOTQ4XFx4MDJcXHUxOTZGXFx4MDJcXHUxOTcyXFx4MDJcXHUxOTc2XFx4MDJcXHUxOTgyXFx4MDJcXHUxOUFEXFx4MDJcIiArXHJcblx0XHRcIlxcdTE5QjJcXHgwMlxcdTE5Q0JcXHgwMlxcdTE5RDJcXHgwMlxcdTE5REJcXHgwMlxcdTFBMDJcXHgwMlxcdTFBMURcXHgwMlxcdTFBMjJcXHgwMlwiICtcclxuXHRcdFwiXFx1MUE2MFxceDAyXFx1MUE2MlxceDAyXFx1MUE3RVxceDAyXFx1MUE4MVxceDAyXFx1MUE4QlxceDAyXFx1MUE5MlxceDAyXFx1MUE5QlxceDAyXCIgK1xyXG5cdFx0XCJcXHUxQUE5XFx4MDJcXHUxQUE5XFx4MDJcXHUxQUIyXFx4MDJcXHUxQUJGXFx4MDJcXHUxQjAyXFx4MDJcXHUxQjREXFx4MDJcXHUxQjUyXFx4MDJcIiArXHJcblx0XHRcIlxcdTFCNUJcXHgwMlxcdTFCNkRcXHgwMlxcdTFCNzVcXHgwMlxcdTFCODJcXHgwMlxcdTFCRjVcXHgwMlxcdTFDMDJcXHgwMlxcdTFDMzlcXHgwMlwiICtcclxuXHRcdFwiXFx1MUM0MlxceDAyXFx1MUM0QlxceDAyXFx1MUM0RlxceDAyXFx1MUM3RlxceDAyXFx1MUM4MlxceDAyXFx1MUM4QVxceDAyXFx1MUNEMlxceDAyXCIgK1xyXG5cdFx0XCJcXHUxQ0Q0XFx4MDJcXHUxQ0Q2XFx4MDJcXHUxQ0Y4XFx4MDJcXHUxQ0ZBXFx4MDJcXHUxQ0ZCXFx4MDJcXHUxRDAyXFx4MDJcXHUxREY3XFx4MDJcIiArXHJcblx0XHRcIlxcdTFERkRcXHgwMlxcdTFGMTdcXHgwMlxcdTFGMUFcXHgwMlxcdTFGMUZcXHgwMlxcdTFGMjJcXHgwMlxcdTFGNDdcXHgwMlxcdTFGNEFcXHgwMlwiICtcclxuXHRcdFwiXFx1MUY0RlxceDAyXFx1MUY1MlxceDAyXFx1MUY1OVxceDAyXFx1MUY1QlxceDAyXFx1MUY1QlxceDAyXFx1MUY1RFxceDAyXFx1MUY1RFxceDAyXCIgK1xyXG5cdFx0XCJcXHUxRjVGXFx4MDJcXHUxRjVGXFx4MDJcXHUxRjYxXFx4MDJcXHUxRjdGXFx4MDJcXHUxRjgyXFx4MDJcXHUxRkI2XFx4MDJcXHUxRkI4XFx4MDJcIiArXHJcblx0XHRcIlxcdTFGQkVcXHgwMlxcdTFGQzBcXHgwMlxcdTFGQzBcXHgwMlxcdTFGQzRcXHgwMlxcdTFGQzZcXHgwMlxcdTFGQzhcXHgwMlxcdTFGQ0VcXHgwMlwiICtcclxuXHRcdFwiXFx1MUZEMlxceDAyXFx1MUZENVxceDAyXFx1MUZEOFxceDAyXFx1MUZERFxceDAyXFx1MUZFMlxceDAyXFx1MUZFRVxceDAyXFx1MUZGNFxceDAyXCIgK1xyXG5cdFx0XCJcXHUxRkY2XFx4MDJcXHUxRkY4XFx4MDJcXHUxRkZFXFx4MDJcXHUyMDBEXFx4MDJcXHUyMDExXFx4MDJcXHUyMDJDXFx4MDJcXHUyMDMwXFx4MDJcIiArXHJcblx0XHRcIlxcdTIwNDFcXHgwMlxcdTIwNDJcXHgwMlxcdTIwNTZcXHgwMlxcdTIwNTZcXHgwMlxcdTIwNjJcXHgwMlxcdTIwNjZcXHgwMlxcdTIwNjhcXHgwMlwiICtcclxuXHRcdFwiXFx1MjA3MVxceDAyXFx1MjA3M1xceDAyXFx1MjA3M1xceDAyXFx1MjA4MVxceDAyXFx1MjA4MVxceDAyXFx1MjA5MlxceDAyXFx1MjA5RVxceDAyXCIgK1xyXG5cdFx0XCJcXHUyMEQyXFx4MDJcXHUyMERFXFx4MDJcXHUyMEUzXFx4MDJcXHUyMEUzXFx4MDJcXHUyMEU3XFx4MDJcXHUyMEYyXFx4MDJcXHUyMTA0XFx4MDJcIiArXHJcblx0XHRcIlxcdTIxMDRcXHgwMlxcdTIxMDlcXHgwMlxcdTIxMDlcXHgwMlxcdTIxMENcXHgwMlxcdTIxMTVcXHgwMlxcdTIxMTdcXHgwMlxcdTIxMTdcXHgwMlwiICtcclxuXHRcdFwiXFx1MjExQlxceDAyXFx1MjExRlxceDAyXFx1MjEyNlxceDAyXFx1MjEyNlxceDAyXFx1MjEyOFxceDAyXFx1MjEyOFxceDAyXFx1MjEyQVxceDAyXCIgK1xyXG5cdFx0XCJcXHUyMTJBXFx4MDJcXHUyMTJDXFx4MDJcXHUyMTJGXFx4MDJcXHUyMTMxXFx4MDJcXHUyMTNCXFx4MDJcXHUyMTNFXFx4MDJcXHUyMTQxXFx4MDJcIiArXHJcblx0XHRcIlxcdTIxNDdcXHgwMlxcdTIxNEJcXHgwMlxcdTIxNTBcXHgwMlxcdTIxNTBcXHgwMlxcdTIxNjJcXHgwMlxcdTIxOEFcXHgwMlxcdTJDMDJcXHgwMlwiICtcclxuXHRcdFwiXFx1MkMzMFxceDAyXFx1MkMzMlxceDAyXFx1MkM2MFxceDAyXFx1MkM2MlxceDAyXFx1MkNFNlxceDAyXFx1MkNFRFxceDAyXFx1MkNGNVxceDAyXCIgK1xyXG5cdFx0XCJcXHUyRDAyXFx4MDJcXHUyRDI3XFx4MDJcXHUyRDI5XFx4MDJcXHUyRDI5XFx4MDJcXHUyRDJGXFx4MDJcXHUyRDJGXFx4MDJcXHUyRDMyXFx4MDJcIiArXHJcblx0XHRcIlxcdTJENjlcXHgwMlxcdTJENzFcXHgwMlxcdTJENzFcXHgwMlxcdTJEODFcXHgwMlxcdTJEOThcXHgwMlxcdTJEQTJcXHgwMlxcdTJEQThcXHgwMlwiICtcclxuXHRcdFwiXFx1MkRBQVxceDAyXFx1MkRCMFxceDAyXFx1MkRCMlxceDAyXFx1MkRCOFxceDAyXFx1MkRCQVxceDAyXFx1MkRDMFxceDAyXFx1MkRDMlxceDAyXCIgK1xyXG5cdFx0XCJcXHUyREM4XFx4MDJcXHUyRENBXFx4MDJcXHUyREQwXFx4MDJcXHUyREQyXFx4MDJcXHUyREQ4XFx4MDJcXHUyRERBXFx4MDJcXHUyREUwXFx4MDJcIiArXHJcblx0XHRcIlxcdTJERTJcXHgwMlxcdTJFMDFcXHgwMlxcdTJFMzFcXHgwMlxcdTJFMzFcXHgwMlxcdTMwMDdcXHgwMlxcdTMwMDlcXHgwMlxcdTMwMjNcXHgwMlwiICtcclxuXHRcdFwiXFx1MzAzMVxceDAyXFx1MzAzM1xceDAyXFx1MzAzN1xceDAyXFx1MzAzQVxceDAyXFx1MzAzRVxceDAyXFx1MzA0M1xceDAyXFx1MzA5OFxceDAyXCIgK1xyXG5cdFx0XCJcXHUzMDlCXFx4MDJcXHUzMDlDXFx4MDJcXHUzMDlGXFx4MDJcXHUzMEExXFx4MDJcXHUzMEEzXFx4MDJcXHUzMEZDXFx4MDJcXHUzMEZFXFx4MDJcIiArXHJcblx0XHRcIlxcdTMxMDFcXHgwMlxcdTMxMDdcXHgwMlxcdTMxMkZcXHgwMlxcdTMxMzNcXHgwMlxcdTMxOTBcXHgwMlxcdTMxQTJcXHgwMlxcdTMxQkNcXHgwMlwiICtcclxuXHRcdFwiXFx1MzFGMlxceDAyXFx1MzIwMVxceDAyXFx1MzQwMlxceDAyXFx1NERCN1xceDAyXFx1NEUwMlxceDAyXFx1OUZEN1xceDAyXFx1QTAwMlxceDAyXCIgK1xyXG5cdFx0XCJcXHVBNDhFXFx4MDJcXHVBNEQyXFx4MDJcXHVBNEZGXFx4MDJcXHVBNTAyXFx4MDJcXHVBNjBFXFx4MDJcXHVBNjEyXFx4MDJcXHVBNjJEXFx4MDJcIiArXHJcblx0XHRcIlxcdUE2NDJcXHgwMlxcdUE2NzFcXHgwMlxcdUE2NzZcXHgwMlxcdUE2N0ZcXHgwMlxcdUE2ODFcXHgwMlxcdUE2RjNcXHgwMlxcdUE3MTlcXHgwMlwiICtcclxuXHRcdFwiXFx1QTcyMVxceDAyXFx1QTcyNFxceDAyXFx1QTc4QVxceDAyXFx1QTc4RFxceDAyXFx1QTdCMFxceDAyXFx1QTdCMlxceDAyXFx1QTdCOVxceDAyXCIgK1xyXG5cdFx0XCJcXHVBN0Y5XFx4MDJcXHVBODI5XFx4MDJcXHVBODQyXFx4MDJcXHVBODc1XFx4MDJcXHVBODgyXFx4MDJcXHVBOEM3XFx4MDJcXHVBOEQyXFx4MDJcIiArXHJcblx0XHRcIlxcdUE4REJcXHgwMlxcdUE4RTJcXHgwMlxcdUE4RjlcXHgwMlxcdUE4RkRcXHgwMlxcdUE4RkRcXHgwMlxcdUE4RkZcXHgwMlxcdUE4RkZcXHgwMlwiICtcclxuXHRcdFwiXFx1QTkwMlxceDAyXFx1QTkyRlxceDAyXFx1QTkzMlxceDAyXFx1QTk1NVxceDAyXFx1QTk2MlxceDAyXFx1QTk3RVxceDAyXFx1QTk4MlxceDAyXCIgK1xyXG5cdFx0XCJcXHVBOUMyXFx4MDJcXHVBOUQxXFx4MDJcXHVBOURCXFx4MDJcXHVBOUUyXFx4MDJcXHVBQTAwXFx4MDJcXHVBQTAyXFx4MDJcXHVBQTM4XFx4MDJcIiArXHJcblx0XHRcIlxcdUFBNDJcXHgwMlxcdUFBNEZcXHgwMlxcdUFBNTJcXHgwMlxcdUFBNUJcXHgwMlxcdUFBNjJcXHgwMlxcdUFBNzhcXHgwMlxcdUFBN0NcXHgwMlwiICtcclxuXHRcdFwiXFx1QUFDNFxceDAyXFx1QUFERFxceDAyXFx1QUFERlxceDAyXFx1QUFFMlxceDAyXFx1QUFGMVxceDAyXFx1QUFGNFxceDAyXFx1QUFGOFxceDAyXCIgK1xyXG5cdFx0XCJcXHVBQjAzXFx4MDJcXHVBQjA4XFx4MDJcXHVBQjBCXFx4MDJcXHVBQjEwXFx4MDJcXHVBQjEzXFx4MDJcXHVBQjE4XFx4MDJcXHVBQjIyXFx4MDJcIiArXHJcblx0XHRcIlxcdUFCMjhcXHgwMlxcdUFCMkFcXHgwMlxcdUFCMzBcXHgwMlxcdUFCMzJcXHgwMlxcdUFCNUNcXHgwMlxcdUFCNUVcXHgwMlxcdUFCNjdcXHgwMlwiICtcclxuXHRcdFwiXFx1QUI3MlxceDAyXFx1QUJFQ1xceDAyXFx1QUJFRVxceDAyXFx1QUJFRlxceDAyXFx1QUJGMlxceDAyXFx1QUJGQlxceDAyXFx1QUMwMlxceDAyXCIgK1xyXG5cdFx0XCJcXHVEN0E1XFx4MDJcXHVEN0IyXFx4MDJcXHVEN0M4XFx4MDJcXHVEN0NEXFx4MDJcXHVEN0ZEXFx4MDJcXHVGOTAyXFx4MDJcXHVGQTZGXFx4MDJcIiArXHJcblx0XHRcIlxcdUZBNzJcXHgwMlxcdUZBREJcXHgwMlxcdUZCMDJcXHgwMlxcdUZCMDhcXHgwMlxcdUZCMTVcXHgwMlxcdUZCMTlcXHgwMlxcdUZCMUZcXHgwMlwiICtcclxuXHRcdFwiXFx1RkIyQVxceDAyXFx1RkIyQ1xceDAyXFx1RkIzOFxceDAyXFx1RkIzQVxceDAyXFx1RkIzRVxceDAyXFx1RkI0MFxceDAyXFx1RkI0MFxceDAyXCIgK1xyXG5cdFx0XCJcXHVGQjQyXFx4MDJcXHVGQjQzXFx4MDJcXHVGQjQ1XFx4MDJcXHVGQjQ2XFx4MDJcXHVGQjQ4XFx4MDJcXHVGQkIzXFx4MDJcXHVGQkQ1XFx4MDJcIiArXHJcblx0XHRcIlxcdUZEM0ZcXHgwMlxcdUZENTJcXHgwMlxcdUZEOTFcXHgwMlxcdUZEOTRcXHgwMlxcdUZEQzlcXHgwMlxcdUZERjJcXHgwMlxcdUZERkRcXHgwMlwiICtcclxuXHRcdFwiXFx1RkUwMlxceDAyXFx1RkUxMVxceDAyXFx1RkUyMlxceDAyXFx1RkUzMVxceDAyXFx1RkUzNVxceDAyXFx1RkUzNlxceDAyXFx1RkU0RlxceDAyXCIgK1xyXG5cdFx0XCJcXHVGRTUxXFx4MDJcXHVGRTcyXFx4MDJcXHVGRTc2XFx4MDJcXHVGRTc4XFx4MDJcXHVGRUZFXFx4MDJcXHVGRjAxXFx4MDJcXHVGRjAxXFx4MDJcIiArXHJcblx0XHRcIlxcdUZGMTJcXHgwMlxcdUZGMUJcXHgwMlxcdUZGMjNcXHgwMlxcdUZGM0NcXHgwMlxcdUZGNDFcXHgwMlxcdUZGNDFcXHgwMlxcdUZGNDNcXHgwMlwiICtcclxuXHRcdFwiXFx1RkY1Q1xceDAyXFx1RkY2OFxceDAyXFx1RkZDMFxceDAyXFx1RkZDNFxceDAyXFx1RkZDOVxceDAyXFx1RkZDQ1xceDAyXFx1RkZEMVxceDAyXCIgK1xyXG5cdFx0XCJcXHVGRkQ0XFx4MDJcXHVGRkQ5XFx4MDJcXHVGRkRDXFx4MDJcXHVGRkRFXFx4MDJcXHVGRkZCXFx4MDJcXHVGRkZEXFx4MDJcXHgwMlxceDAzXFxyXCIgK1xyXG5cdFx0XCJcXHgwM1xceDBGXFx4MDMoXFx4MDMqXFx4MDM8XFx4MDM+XFx4MDM/XFx4MDNBXFx4MDNPXFx4MDNSXFx4MDNfXFx4MDNcXHg4MlxceDAzXFx4RkNcIiArXHJcblx0XHRcIlxceDAzXFx1MDE0MlxceDAzXFx1MDE3NlxceDAzXFx1MDFGRlxceDAzXFx1MDFGRlxceDAzXFx1MDI4MlxceDAzXFx1MDI5RVxceDAzXFx1MDJBMlwiICtcclxuXHRcdFwiXFx4MDNcXHUwMkQyXFx4MDNcXHUwMkUyXFx4MDNcXHUwMkUyXFx4MDNcXHUwMzAyXFx4MDNcXHUwMzIxXFx4MDNcXHUwMzMyXFx4MDNcXHUwMzRDXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTAzNTJcXHgwM1xcdTAzN0NcXHgwM1xcdTAzODJcXHgwM1xcdTAzOUZcXHgwM1xcdTAzQTJcXHgwM1xcdTAzQzVcXHgwM1xcdTAzQ0FcIiArXHJcblx0XHRcIlxceDAzXFx1MDNEMVxceDAzXFx1MDNEM1xceDAzXFx1MDNEN1xceDAzXFx1MDQwMlxceDAzXFx1MDQ5RlxceDAzXFx1MDRBMlxceDAzXFx1MDRBQlwiICtcclxuXHRcdFwiXFx4MDNcXHUwNEIyXFx4MDNcXHUwNEQ1XFx4MDNcXHUwNERBXFx4MDNcXHUwNEZEXFx4MDNcXHUwNTAyXFx4MDNcXHUwNTI5XFx4MDNcXHUwNTMyXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTA1NjVcXHgwM1xcdTA2MDJcXHgwM1xcdTA3MzhcXHgwM1xcdTA3NDJcXHgwM1xcdTA3NTdcXHgwM1xcdTA3NjJcXHgwM1xcdTA3NjlcIiArXHJcblx0XHRcIlxceDAzXFx1MDgwMlxceDAzXFx1MDgwN1xceDAzXFx1MDgwQVxceDAzXFx1MDgwQVxceDAzXFx1MDgwQ1xceDAzXFx1MDgzN1xceDAzXFx1MDgzOVwiICtcclxuXHRcdFwiXFx4MDNcXHUwODNBXFx4MDNcXHUwODNFXFx4MDNcXHUwODNFXFx4MDNcXHUwODQxXFx4MDNcXHUwODU3XFx4MDNcXHUwODYyXFx4MDNcXHUwODc4XCIgK1xyXG5cdFx0XCJcXHgwM1xcdTA4ODJcXHgwM1xcdTA4QTBcXHgwM1xcdTA4RTJcXHgwM1xcdTA4RjRcXHgwM1xcdTA4RjZcXHgwM1xcdTA4RjdcXHgwM1xcdTA5MDJcIiArXHJcblx0XHRcIlxceDAzXFx1MDkxN1xceDAzXFx1MDkyMlxceDAzXFx1MDkzQlxceDAzXFx1MDk4MlxceDAzXFx1MDlCOVxceDAzXFx1MDlDMFxceDAzXFx1MDlDMVwiICtcclxuXHRcdFwiXFx4MDNcXHUwQTAyXFx4MDNcXHUwQTA1XFx4MDNcXHUwQTA3XFx4MDNcXHUwQTA4XFx4MDNcXHUwQTBFXFx4MDNcXHUwQTE1XFx4MDNcXHUwQTE3XCIgK1xyXG5cdFx0XCJcXHgwM1xcdTBBMTlcXHgwM1xcdTBBMUJcXHgwM1xcdTBBMzVcXHgwM1xcdTBBM0FcXHgwM1xcdTBBM0NcXHgwM1xcdTBBNDFcXHgwM1xcdTBBNDFcIiArXHJcblx0XHRcIlxceDAzXFx1MEE2MlxceDAzXFx1MEE3RVxceDAzXFx1MEE4MlxceDAzXFx1MEE5RVxceDAzXFx1MEFDMlxceDAzXFx1MEFDOVxceDAzXFx1MEFDQlwiICtcclxuXHRcdFwiXFx4MDNcXHUwQUU4XFx4MDNcXHUwQjAyXFx4MDNcXHUwQjM3XFx4MDNcXHUwQjQyXFx4MDNcXHUwQjU3XFx4MDNcXHUwQjYyXFx4MDNcXHUwQjc0XCIgK1xyXG5cdFx0XCJcXHgwM1xcdTBCODJcXHgwM1xcdTBCOTNcXHgwM1xcdTBDMDJcXHgwM1xcdTBDNEFcXHgwM1xcdTBDODJcXHgwM1xcdTBDQjRcXHgwM1xcdTBDQzJcIiArXHJcblx0XHRcIlxceDAzXFx1MENGNFxceDAzXFx1MTAwMlxceDAzXFx1MTA0OFxceDAzXFx1MTA2OFxceDAzXFx1MTA3MVxceDAzXFx1MTA4MVxceDAzXFx1MTBCQ1wiICtcclxuXHRcdFwiXFx4MDNcXHUxMEJGXFx4MDNcXHUxMEJGXFx4MDNcXHUxMEQyXFx4MDNcXHUxMEVBXFx4MDNcXHUxMEYyXFx4MDNcXHUxMEZCXFx4MDNcXHUxMTAyXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTExMzZcXHgwM1xcdTExMzhcXHgwM1xcdTExNDFcXHgwM1xcdTExNTJcXHgwM1xcdTExNzVcXHgwM1xcdTExNzhcXHgwM1xcdTExNzhcIiArXHJcblx0XHRcIlxceDAzXFx1MTE4MlxceDAzXFx1MTFDNlxceDAzXFx1MTFDQ1xceDAzXFx1MTFDRVxceDAzXFx1MTFEMlxceDAzXFx1MTFEQ1xceDAzXFx1MTFERVwiICtcclxuXHRcdFwiXFx4MDNcXHUxMURFXFx4MDNcXHUxMjAyXFx4MDNcXHUxMjEzXFx4MDNcXHUxMjE1XFx4MDNcXHUxMjM5XFx4MDNcXHUxMjQwXFx4MDNcXHUxMjQwXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTEyODJcXHgwM1xcdTEyODhcXHgwM1xcdTEyOEFcXHgwM1xcdTEyOEFcXHgwM1xcdTEyOENcXHgwM1xcdTEyOEZcXHgwM1xcdTEyOTFcIiArXHJcblx0XHRcIlxceDAzXFx1MTI5RlxceDAzXFx1MTJBMVxceDAzXFx1MTJBQVxceDAzXFx1MTJCMlxceDAzXFx1MTJFQ1xceDAzXFx1MTJGMlxceDAzXFx1MTJGQlwiICtcclxuXHRcdFwiXFx4MDNcXHUxMzAyXFx4MDNcXHUxMzA1XFx4MDNcXHUxMzA3XFx4MDNcXHUxMzBFXFx4MDNcXHUxMzExXFx4MDNcXHUxMzEyXFx4MDNcXHUxMzE1XCIgK1xyXG5cdFx0XCJcXHgwM1xcdTEzMkFcXHgwM1xcdTEzMkNcXHgwM1xcdTEzMzJcXHgwM1xcdTEzMzRcXHgwM1xcdTEzMzVcXHgwM1xcdTEzMzdcXHgwM1xcdTEzM0JcIiArXHJcblx0XHRcIlxceDAzXFx1MTMzRVxceDAzXFx1MTM0NlxceDAzXFx1MTM0OVxceDAzXFx1MTM0QVxceDAzXFx1MTM0RFxceDAzXFx1MTM0RlxceDAzXFx1MTM1MlwiICtcclxuXHRcdFwiXFx4MDNcXHUxMzUyXFx4MDNcXHUxMzU5XFx4MDNcXHUxMzU5XFx4MDNcXHUxMzVGXFx4MDNcXHUxMzY1XFx4MDNcXHUxMzY4XFx4MDNcXHUxMzZFXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTEzNzJcXHgwM1xcdTEzNzZcXHgwM1xcdTE0MDJcXHgwM1xcdTE0NENcXHgwM1xcdTE0NTJcXHgwM1xcdTE0NUJcXHgwM1xcdTE0ODJcIiArXHJcblx0XHRcIlxceDAzXFx1MTRDN1xceDAzXFx1MTRDOVxceDAzXFx1MTRDOVxceDAzXFx1MTREMlxceDAzXFx1MTREQlxceDAzXFx1MTU4MlxceDAzXFx1MTVCN1wiICtcclxuXHRcdFwiXFx4MDNcXHUxNUJBXFx4MDNcXHUxNUMyXFx4MDNcXHUxNURBXFx4MDNcXHUxNURGXFx4MDNcXHUxNjAyXFx4MDNcXHUxNjQyXFx4MDNcXHUxNjQ2XCIgK1xyXG5cdFx0XCJcXHgwM1xcdTE2NDZcXHgwM1xcdTE2NTJcXHgwM1xcdTE2NUJcXHgwM1xcdTE2ODJcXHgwM1xcdTE2QjlcXHgwM1xcdTE2QzJcXHgwM1xcdTE2Q0JcIiArXHJcblx0XHRcIlxceDAzXFx1MTcwMlxceDAzXFx1MTcxQlxceDAzXFx1MTcxRlxceDAzXFx1MTcyRFxceDAzXFx1MTczMlxceDAzXFx1MTczQlxceDAzXFx1MThBMlwiICtcclxuXHRcdFwiXFx4MDNcXHUxOEVCXFx4MDNcXHUxOTAxXFx4MDNcXHUxOTAxXFx4MDNcXHUxQUMyXFx4MDNcXHUxQUZBXFx4MDNcXHUxQzAyXFx4MDNcXHUxQzBBXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTFDMENcXHgwM1xcdTFDMzhcXHgwM1xcdTFDM0FcXHgwM1xcdTFDNDJcXHgwM1xcdTFDNTJcXHgwM1xcdTFDNUJcXHgwM1xcdTFDNzRcIiArXHJcblx0XHRcIlxceDAzXFx1MUM5MVxceDAzXFx1MUM5NFxceDAzXFx1MUNBOVxceDAzXFx1MUNBQlxceDAzXFx1MUNCOFxceDAzXFx1MjAwMlxceDAzXFx1MjM5QlwiICtcclxuXHRcdFwiXFx4MDNcXHUyNDAyXFx4MDNcXHUyNDcwXFx4MDNcXHUyNDgyXFx4MDNcXHUyNTQ1XFx4MDNcXHUzMDAyXFx4MDNcXHUzNDMwXFx4MDNcXHU0NDAyXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTQ2NDhcXHgwM1xcdTY4MDJcXHgwM1xcdTZBM0FcXHgwM1xcdTZBNDJcXHgwM1xcdTZBNjBcXHgwM1xcdTZBNjJcXHgwM1xcdTZBNkJcIiArXHJcblx0XHRcIlxceDAzXFx1NkFEMlxceDAzXFx1NkFFRlxceDAzXFx1NkFGMlxceDAzXFx1NkFGNlxceDAzXFx1NkIwMlxceDAzXFx1NkIzOFxceDAzXFx1NkI0MlwiICtcclxuXHRcdFwiXFx4MDNcXHU2QjQ1XFx4MDNcXHU2QjUyXFx4MDNcXHU2QjVCXFx4MDNcXHU2QjY1XFx4MDNcXHU2Qjc5XFx4MDNcXHU2QjdGXFx4MDNcXHU2QjkxXCIgK1xyXG5cdFx0XCJcXHgwM1xcdTZGMDJcXHgwM1xcdTZGNDZcXHgwM1xcdTZGNTJcXHgwM1xcdTZGODBcXHgwM1xcdTZGOTFcXHgwM1xcdTZGQTFcXHgwM1xcdTZGRTJcIiArXHJcblx0XHRcIlxceDAzXFx1NkZFMlxceDAzXFx1NzAwMlxceDAzXFx1ODdFRVxceDAzXFx1ODgwMlxceDAzXFx1OEFGNFxceDAzXFx1QjAwMlxceDAzXFx1QjAwM1wiICtcclxuXHRcdFwiXFx4MDNcXHVCQzAyXFx4MDNcXHVCQzZDXFx4MDNcXHVCQzcyXFx4MDNcXHVCQzdFXFx4MDNcXHVCQzgyXFx4MDNcXHVCQzhBXFx4MDNcXHVCQzkyXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUJDOUJcXHgwM1xcdUJDOUZcXHgwM1xcdUJDQTBcXHgwM1xcdUJDQTJcXHgwM1xcdUJDQTVcXHgwM1xcdUQxNjdcXHgwM1xcdUQxNkJcIiArXHJcblx0XHRcIlxceDAzXFx1RDE2RlxceDAzXFx1RDE4NFxceDAzXFx1RDE4N1xceDAzXFx1RDE4RFxceDAzXFx1RDFBQ1xceDAzXFx1RDFBRlxceDAzXFx1RDI0NFwiICtcclxuXHRcdFwiXFx4MDNcXHVEMjQ2XFx4MDNcXHVENDAyXFx4MDNcXHVENDU2XFx4MDNcXHVENDU4XFx4MDNcXHVENDlFXFx4MDNcXHVENEEwXFx4MDNcXHVENEExXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUQ0QTRcXHgwM1xcdUQ0QTRcXHgwM1xcdUQ0QTdcXHgwM1xcdUQ0QThcXHgwM1xcdUQ0QUJcXHgwM1xcdUQ0QUVcXHgwM1xcdUQ0QjBcIiArXHJcblx0XHRcIlxceDAzXFx1RDRCQlxceDAzXFx1RDRCRFxceDAzXFx1RDRCRFxceDAzXFx1RDRCRlxceDAzXFx1RDRDNVxceDAzXFx1RDRDN1xceDAzXFx1RDUwN1wiICtcclxuXHRcdFwiXFx4MDNcXHVENTA5XFx4MDNcXHVENTBDXFx4MDNcXHVENTBGXFx4MDNcXHVENTE2XFx4MDNcXHVENTE4XFx4MDNcXHVENTFFXFx4MDNcXHVENTIwXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUQ1M0JcXHgwM1xcdUQ1M0RcXHgwM1xcdUQ1NDBcXHgwM1xcdUQ1NDJcXHgwM1xcdUQ1NDZcXHgwM1xcdUQ1NDhcXHgwM1xcdUQ1NDhcIiArXHJcblx0XHRcIlxceDAzXFx1RDU0Q1xceDAzXFx1RDU1MlxceDAzXFx1RDU1NFxceDAzXFx1RDZBN1xceDAzXFx1RDZBQVxceDAzXFx1RDZDMlxceDAzXFx1RDZDNFwiICtcclxuXHRcdFwiXFx4MDNcXHVENkRDXFx4MDNcXHVENkRFXFx4MDNcXHVENkZDXFx4MDNcXHVENkZFXFx4MDNcXHVENzE2XFx4MDNcXHVENzE4XFx4MDNcXHVENzM2XCIgK1xyXG5cdFx0XCJcXHgwM1xcdUQ3MzhcXHgwM1xcdUQ3NTBcXHgwM1xcdUQ3NTJcXHgwM1xcdUQ3NzBcXHgwM1xcdUQ3NzJcXHgwM1xcdUQ3OEFcXHgwM1xcdUQ3OENcIiArXHJcblx0XHRcIlxceDAzXFx1RDdBQVxceDAzXFx1RDdBQ1xceDAzXFx1RDdDNFxceDAzXFx1RDdDNlxceDAzXFx1RDdDRFxceDAzXFx1RDdEMFxceDAzXFx1RDgwMVwiICtcclxuXHRcdFwiXFx4MDNcXHVEQTAyXFx4MDNcXHVEQTM4XFx4MDNcXHVEQTNEXFx4MDNcXHVEQTZFXFx4MDNcXHVEQTc3XFx4MDNcXHVEQTc3XFx4MDNcXHVEQTg2XCIgK1xyXG5cdFx0XCJcXHgwM1xcdURBODZcXHgwM1xcdURBOURcXHgwM1xcdURBQTFcXHgwM1xcdURBQTNcXHgwM1xcdURBQjFcXHgwM1xcdUUwMDJcXHgwM1xcdUUwMDhcIiArXHJcblx0XHRcIlxceDAzXFx1RTAwQVxceDAzXFx1RTAxQVxceDAzXFx1RTAxRFxceDAzXFx1RTAyM1xceDAzXFx1RTAyNVxceDAzXFx1RTAyNlxceDAzXFx1RTAyOFwiICtcclxuXHRcdFwiXFx4MDNcXHVFMDJDXFx4MDNcXHVFODAyXFx4MDNcXHVFOEM2XFx4MDNcXHVFOEQyXFx4MDNcXHVFOEQ4XFx4MDNcXHVFOTAyXFx4MDNcXHVFOTRDXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUU5NTJcXHgwM1xcdUU5NUJcXHgwM1xcdUVFMDJcXHgwM1xcdUVFMDVcXHgwM1xcdUVFMDdcXHgwM1xcdUVFMjFcXHgwM1xcdUVFMjNcIiArXHJcblx0XHRcIlxceDAzXFx1RUUyNFxceDAzXFx1RUUyNlxceDAzXFx1RUUyNlxceDAzXFx1RUUyOVxceDAzXFx1RUUyOVxceDAzXFx1RUUyQlxceDAzXFx1RUUzNFwiICtcclxuXHRcdFwiXFx4MDNcXHVFRTM2XFx4MDNcXHVFRTM5XFx4MDNcXHVFRTNCXFx4MDNcXHVFRTNCXFx4MDNcXHVFRTNEXFx4MDNcXHVFRTNEXFx4MDNcXHVFRTQ0XCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFNDRcXHgwM1xcdUVFNDlcXHgwM1xcdUVFNDlcXHgwM1xcdUVFNEJcXHgwM1xcdUVFNEJcXHgwM1xcdUVFNERcXHgwM1xcdUVFNERcIiArXHJcblx0XHRcIlxceDAzXFx1RUU0RlxceDAzXFx1RUU1MVxceDAzXFx1RUU1M1xceDAzXFx1RUU1NFxceDAzXFx1RUU1NlxceDAzXFx1RUU1NlxceDAzXFx1RUU1OVwiICtcclxuXHRcdFwiXFx4MDNcXHVFRTU5XFx4MDNcXHVFRTVCXFx4MDNcXHVFRTVCXFx4MDNcXHVFRTVEXFx4MDNcXHVFRTVEXFx4MDNcXHVFRTVGXFx4MDNcXHVFRTVGXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFNjFcXHgwM1xcdUVFNjFcXHgwM1xcdUVFNjNcXHgwM1xcdUVFNjRcXHgwM1xcdUVFNjZcXHgwM1xcdUVFNjZcXHgwM1xcdUVFNjlcIiArXHJcblx0XHRcIlxceDAzXFx1RUU2Q1xceDAzXFx1RUU2RVxceDAzXFx1RUU3NFxceDAzXFx1RUU3NlxceDAzXFx1RUU3OVxceDAzXFx1RUU3QlxceDAzXFx1RUU3RVwiICtcclxuXHRcdFwiXFx4MDNcXHVFRTgwXFx4MDNcXHVFRTgwXFx4MDNcXHVFRTgyXFx4MDNcXHVFRThCXFx4MDNcXHVFRThEXFx4MDNcXHVFRTlEXFx4MDNcXHVFRUEzXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFQTVcXHgwM1xcdUVFQTdcXHgwM1xcdUVFQUJcXHgwM1xcdUVFQURcXHgwM1xcdUVFQkRcXHgwM1xceDAyXFx4MDRcXHVBNkQ4XFx4MDRcIiArXHJcblx0XHRcIlxcdUE3MDJcXHgwNFxcdUI3MzZcXHgwNFxcdUI3NDJcXHgwNFxcdUI4MUZcXHgwNFxcdUI4MjJcXHgwNFxcdUNFQTNcXHgwNFxcdUY4MDJcXHgwNFwiICtcclxuXHRcdFwiXFx1RkExRlxceDA0XFx4MDNcXHgxMFxceDAzXFx4MTBcXFwiXFx4MTBcXHg4MVxceDEwXFx1MDEwMlxceDEwXFx1MDFGMVxceDEwXFx1MDI0MFxceDAyXCIgK1xyXG5cdFx0XCJDXFx4MDJcXFxcXFx4MDJjXFx4MDJ8XFx4MDJcXHhBQ1xceDAyXFx4QUNcXHgwMlxceEI3XFx4MDJcXHhCN1xceDAyXFx4QkNcXHgwMlxceEJDXFx4MDJcIiArXHJcblx0XHRcIlxceEMyXFx4MDJcXHhEOFxceDAyXFx4REFcXHgwMlxceEY4XFx4MDJcXHhGQVxceDAyXFx1MDJDM1xceDAyXFx1MDJDOFxceDAyXFx1MDJEM1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwMkUyXFx4MDJcXHUwMkU2XFx4MDJcXHUwMkVFXFx4MDJcXHUwMkVFXFx4MDJcXHUwMkYwXFx4MDJcXHUwMkYwXFx4MDJcXHUwMzcyXFx4MDJcIiArXHJcblx0XHRcIlxcdTAzNzZcXHgwMlxcdTAzNzhcXHgwMlxcdTAzNzlcXHgwMlxcdTAzN0NcXHgwMlxcdTAzN0ZcXHgwMlxcdTAzODFcXHgwMlxcdTAzODFcXHgwMlwiICtcclxuXHRcdFwiXFx1MDM4OFxceDAyXFx1MDM4OFxceDAyXFx1MDM4QVxceDAyXFx1MDM4Q1xceDAyXFx1MDM4RVxceDAyXFx1MDM4RVxceDAyXFx1MDM5MFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwM0EzXFx4MDJcXHUwM0E1XFx4MDJcXHUwM0Y3XFx4MDJcXHUwM0Y5XFx4MDJcXHUwNDgzXFx4MDJcXHUwNDhDXFx4MDJcXHUwNTMxXFx4MDJcIiArXHJcblx0XHRcIlxcdTA1MzNcXHgwMlxcdTA1NThcXHgwMlxcdTA1NUJcXHgwMlxcdTA1NUJcXHgwMlxcdTA1NjNcXHgwMlxcdTA1ODlcXHgwMlxcdTA1RDJcXHgwMlwiICtcclxuXHRcdFwiXFx1MDVFQ1xceDAyXFx1MDVGMlxceDAyXFx1MDVGNFxceDAyXFx1MDYyMlxceDAyXFx1MDY0Q1xceDAyXFx1MDY3MFxceDAyXFx1MDY3MVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwNjczXFx4MDJcXHUwNkQ1XFx4MDJcXHUwNkQ3XFx4MDJcXHUwNkQ3XFx4MDJcXHUwNkU3XFx4MDJcXHUwNkU4XFx4MDJcXHUwNkYwXFx4MDJcIiArXHJcblx0XHRcIlxcdTA2RjFcXHgwMlxcdTA2RkNcXHgwMlxcdTA2RkVcXHgwMlxcdTA3MDFcXHgwMlxcdTA3MDFcXHgwMlxcdTA3MTJcXHgwMlxcdTA3MTJcXHgwMlwiICtcclxuXHRcdFwiXFx1MDcxNFxceDAyXFx1MDczMVxceDAyXFx1MDc0RlxceDAyXFx1MDdBN1xceDAyXFx1MDdCM1xceDAyXFx1MDdCM1xceDAyXFx1MDdDQ1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwN0VDXFx4MDJcXHUwN0Y2XFx4MDJcXHUwN0Y3XFx4MDJcXHUwN0ZDXFx4MDJcXHUwN0ZDXFx4MDJcXHUwODAyXFx4MDJcXHUwODE3XFx4MDJcIiArXHJcblx0XHRcIlxcdTA4MUNcXHgwMlxcdTA4MUNcXHgwMlxcdTA4MjZcXHgwMlxcdTA4MjZcXHgwMlxcdTA4MkFcXHgwMlxcdTA4MkFcXHgwMlxcdTA4NDJcXHgwMlwiICtcclxuXHRcdFwiXFx1MDg1QVxceDAyXFx1MDhBMlxceDAyXFx1MDhCNlxceDAyXFx1MDhCOFxceDAyXFx1MDhCRlxceDAyXFx1MDkwNlxceDAyXFx1MDkzQlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwOTNGXFx4MDJcXHUwOTNGXFx4MDJcXHUwOTUyXFx4MDJcXHUwOTUyXFx4MDJcXHUwOTVBXFx4MDJcXHUwOTYzXFx4MDJcXHUwOTczXFx4MDJcIiArXHJcblx0XHRcIlxcdTA5ODJcXHgwMlxcdTA5ODdcXHgwMlxcdTA5OEVcXHgwMlxcdTA5OTFcXHgwMlxcdTA5OTJcXHgwMlxcdTA5OTVcXHgwMlxcdTA5QUFcXHgwMlwiICtcclxuXHRcdFwiXFx1MDlBQ1xceDAyXFx1MDlCMlxceDAyXFx1MDlCNFxceDAyXFx1MDlCNFxceDAyXFx1MDlCOFxceDAyXFx1MDlCQlxceDAyXFx1MDlCRlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwOUJGXFx4MDJcXHUwOUQwXFx4MDJcXHUwOUQwXFx4MDJcXHUwOURFXFx4MDJcXHUwOURGXFx4MDJcXHUwOUUxXFx4MDJcXHUwOUUzXFx4MDJcIiArXHJcblx0XHRcIlxcdTA5RjJcXHgwMlxcdTA5RjNcXHgwMlxcdTBBMDdcXHgwMlxcdTBBMENcXHgwMlxcdTBBMTFcXHgwMlxcdTBBMTJcXHgwMlxcdTBBMTVcXHgwMlwiICtcclxuXHRcdFwiXFx1MEEyQVxceDAyXFx1MEEyQ1xceDAyXFx1MEEzMlxceDAyXFx1MEEzNFxceDAyXFx1MEEzNVxceDAyXFx1MEEzN1xceDAyXFx1MEEzOFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQTNBXFx4MDJcXHUwQTNCXFx4MDJcXHUwQTVCXFx4MDJcXHUwQTVFXFx4MDJcXHUwQTYwXFx4MDJcXHUwQTYwXFx4MDJcXHUwQTc0XFx4MDJcIiArXHJcblx0XHRcIlxcdTBBNzZcXHgwMlxcdTBBODdcXHgwMlxcdTBBOEZcXHgwMlxcdTBBOTFcXHgwMlxcdTBBOTNcXHgwMlxcdTBBOTVcXHgwMlxcdTBBQUFcXHgwMlwiICtcclxuXHRcdFwiXFx1MEFBQ1xceDAyXFx1MEFCMlxceDAyXFx1MEFCNFxceDAyXFx1MEFCNVxceDAyXFx1MEFCN1xceDAyXFx1MEFCQlxceDAyXFx1MEFCRlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQUJGXFx4MDJcXHUwQUQyXFx4MDJcXHUwQUQyXFx4MDJcXHUwQUUyXFx4MDJcXHUwQUUzXFx4MDJcXHUwQUZCXFx4MDJcXHUwQUZCXFx4MDJcIiArXHJcblx0XHRcIlxcdTBCMDdcXHgwMlxcdTBCMEVcXHgwMlxcdTBCMTFcXHgwMlxcdTBCMTJcXHgwMlxcdTBCMTVcXHgwMlxcdTBCMkFcXHgwMlxcdTBCMkNcXHgwMlwiICtcclxuXHRcdFwiXFx1MEIzMlxceDAyXFx1MEIzNFxceDAyXFx1MEIzNVxceDAyXFx1MEIzN1xceDAyXFx1MEIzQlxceDAyXFx1MEIzRlxceDAyXFx1MEIzRlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQjVFXFx4MDJcXHUwQjVGXFx4MDJcXHUwQjYxXFx4MDJcXHUwQjYzXFx4MDJcXHUwQjczXFx4MDJcXHUwQjczXFx4MDJcXHUwQjg1XFx4MDJcIiArXHJcblx0XHRcIlxcdTBCODVcXHgwMlxcdTBCODdcXHgwMlxcdTBCOENcXHgwMlxcdTBCOTBcXHgwMlxcdTBCOTJcXHgwMlxcdTBCOTRcXHgwMlxcdTBCOTdcXHgwMlwiICtcclxuXHRcdFwiXFx1MEI5QlxceDAyXFx1MEI5Q1xceDAyXFx1MEI5RVxceDAyXFx1MEI5RVxceDAyXFx1MEJBMFxceDAyXFx1MEJBMVxceDAyXFx1MEJBNVxceDAyXCIgK1xyXG5cdFx0XCJcXHUwQkE2XFx4MDJcXHUwQkFBXFx4MDJcXHUwQkFDXFx4MDJcXHUwQkIwXFx4MDJcXHUwQkJCXFx4MDJcXHUwQkQyXFx4MDJcXHUwQkQyXFx4MDJcIiArXHJcblx0XHRcIlxcdTBDMDdcXHgwMlxcdTBDMEVcXHgwMlxcdTBDMTBcXHgwMlxcdTBDMTJcXHgwMlxcdTBDMTRcXHgwMlxcdTBDMkFcXHgwMlxcdTBDMkNcXHgwMlwiICtcclxuXHRcdFwiXFx1MEMzQlxceDAyXFx1MEMzRlxceDAyXFx1MEMzRlxceDAyXFx1MEM1QVxceDAyXFx1MEM1Q1xceDAyXFx1MEM2MlxceDAyXFx1MEM2M1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwQzgyXFx4MDJcXHUwQzgyXFx4MDJcXHUwQzg3XFx4MDJcXHUwQzhFXFx4MDJcXHUwQzkwXFx4MDJcXHUwQzkyXFx4MDJcXHUwQzk0XFx4MDJcIiArXHJcblx0XHRcIlxcdTBDQUFcXHgwMlxcdTBDQUNcXHgwMlxcdTBDQjVcXHgwMlxcdTBDQjdcXHgwMlxcdTBDQkJcXHgwMlxcdTBDQkZcXHgwMlxcdTBDQkZcXHgwMlwiICtcclxuXHRcdFwiXFx1MENFMFxceDAyXFx1MENFMFxceDAyXFx1MENFMlxceDAyXFx1MENFM1xceDAyXFx1MENGM1xceDAyXFx1MENGNFxceDAyXFx1MEQwN1xceDAyXCIgK1xyXG5cdFx0XCJcXHUwRDBFXFx4MDJcXHUwRDEwXFx4MDJcXHUwRDEyXFx4MDJcXHUwRDE0XFx4MDJcXHUwRDNDXFx4MDJcXHUwRDNGXFx4MDJcXHUwRDNGXFx4MDJcIiArXHJcblx0XHRcIlxcdTBENTBcXHgwMlxcdTBENTBcXHgwMlxcdTBENTZcXHgwMlxcdTBENThcXHgwMlxcdTBENjFcXHgwMlxcdTBENjNcXHgwMlxcdTBEN0NcXHgwMlwiICtcclxuXHRcdFwiXFx1MEQ4MVxceDAyXFx1MEQ4N1xceDAyXFx1MEQ5OFxceDAyXFx1MEQ5Q1xceDAyXFx1MERCM1xceDAyXFx1MERCNVxceDAyXFx1MERCRFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwREJGXFx4MDJcXHUwREJGXFx4MDJcXHUwREMyXFx4MDJcXHUwREM4XFx4MDJcXHUwRTAzXFx4MDJcXHUwRTMyXFx4MDJcXHUwRTM0XFx4MDJcIiArXHJcblx0XHRcIlxcdTBFMzVcXHgwMlxcdTBFNDJcXHgwMlxcdTBFNDhcXHgwMlxcdTBFODNcXHgwMlxcdTBFODRcXHgwMlxcdTBFODZcXHgwMlxcdTBFODZcXHgwMlwiICtcclxuXHRcdFwiXFx1MEU4OVxceDAyXFx1MEU4QVxceDAyXFx1MEU4Q1xceDAyXFx1MEU4Q1xceDAyXFx1MEU4RlxceDAyXFx1MEU4RlxceDAyXFx1MEU5NlxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRTk5XFx4MDJcXHUwRTlCXFx4MDJcXHUwRUExXFx4MDJcXHUwRUEzXFx4MDJcXHUwRUE1XFx4MDJcXHUwRUE3XFx4MDJcXHUwRUE3XFx4MDJcIiArXHJcblx0XHRcIlxcdTBFQTlcXHgwMlxcdTBFQTlcXHgwMlxcdTBFQUNcXHgwMlxcdTBFQURcXHgwMlxcdTBFQUZcXHgwMlxcdTBFQjJcXHgwMlxcdTBFQjRcXHgwMlwiICtcclxuXHRcdFwiXFx1MEVCNVxceDAyXFx1MEVCRlxceDAyXFx1MEVCRlxceDAyXFx1MEVDMlxceDAyXFx1MEVDNlxceDAyXFx1MEVDOFxceDAyXFx1MEVDOFxceDAyXCIgK1xyXG5cdFx0XCJcXHUwRURFXFx4MDJcXHUwRUUxXFx4MDJcXHUwRjAyXFx4MDJcXHUwRjAyXFx4MDJcXHUwRjQyXFx4MDJcXHUwRjQ5XFx4MDJcXHUwRjRCXFx4MDJcIiArXHJcblx0XHRcIlxcdTBGNkVcXHgwMlxcdTBGOEFcXHgwMlxcdTBGOEVcXHgwMlxcdTEwMDJcXHgwMlxcdTEwMkNcXHgwMlxcdTEwNDFcXHgwMlxcdTEwNDFcXHgwMlwiICtcclxuXHRcdFwiXFx1MTA1MlxceDAyXFx1MTA1N1xceDAyXFx1MTA1Q1xceDAyXFx1MTA1RlxceDAyXFx1MTA2M1xceDAyXFx1MTA2M1xceDAyXFx1MTA2N1xceDAyXCIgK1xyXG5cdFx0XCJcXHUxMDY4XFx4MDJcXHUxMDcwXFx4MDJcXHUxMDcyXFx4MDJcXHUxMDc3XFx4MDJcXHUxMDgzXFx4MDJcXHUxMDkwXFx4MDJcXHUxMDkwXFx4MDJcIiArXHJcblx0XHRcIlxcdTEwQTJcXHgwMlxcdTEwQzdcXHgwMlxcdTEwQzlcXHgwMlxcdTEwQzlcXHgwMlxcdTEwQ0ZcXHgwMlxcdTEwQ0ZcXHgwMlxcdTEwRDJcXHgwMlwiICtcclxuXHRcdFwiXFx1MTBGQ1xceDAyXFx1MTBGRVxceDAyXFx1MTI0QVxceDAyXFx1MTI0Q1xceDAyXFx1MTI0RlxceDAyXFx1MTI1MlxceDAyXFx1MTI1OFxceDAyXCIgK1xyXG5cdFx0XCJcXHUxMjVBXFx4MDJcXHUxMjVBXFx4MDJcXHUxMjVDXFx4MDJcXHUxMjVGXFx4MDJcXHUxMjYyXFx4MDJcXHUxMjhBXFx4MDJcXHUxMjhDXFx4MDJcIiArXHJcblx0XHRcIlxcdTEyOEZcXHgwMlxcdTEyOTJcXHgwMlxcdTEyQjJcXHgwMlxcdTEyQjRcXHgwMlxcdTEyQjdcXHgwMlxcdTEyQkFcXHgwMlxcdTEyQzBcXHgwMlwiICtcclxuXHRcdFwiXFx1MTJDMlxceDAyXFx1MTJDMlxceDAyXFx1MTJDNFxceDAyXFx1MTJDN1xceDAyXFx1MTJDQVxceDAyXFx1MTJEOFxceDAyXFx1MTJEQVxceDAyXCIgK1xyXG5cdFx0XCJcXHUxMzEyXFx4MDJcXHUxMzE0XFx4MDJcXHUxMzE3XFx4MDJcXHUxMzFBXFx4MDJcXHUxMzVDXFx4MDJcXHUxMzgyXFx4MDJcXHUxMzkxXFx4MDJcIiArXHJcblx0XHRcIlxcdTEzQTJcXHgwMlxcdTEzRjdcXHgwMlxcdTEzRkFcXHgwMlxcdTEzRkZcXHgwMlxcdTE0MDNcXHgwMlxcdTE2NkVcXHgwMlxcdTE2NzFcXHgwMlwiICtcclxuXHRcdFwiXFx1MTY4MVxceDAyXFx1MTY4M1xceDAyXFx1MTY5Q1xceDAyXFx1MTZBMlxceDAyXFx1MTZFQ1xceDAyXFx1MTZGMFxceDAyXFx1MTZGQVxceDAyXCIgK1xyXG5cdFx0XCJcXHUxNzAyXFx4MDJcXHUxNzBFXFx4MDJcXHUxNzEwXFx4MDJcXHUxNzEzXFx4MDJcXHUxNzIyXFx4MDJcXHUxNzMzXFx4MDJcXHUxNzQyXFx4MDJcIiArXHJcblx0XHRcIlxcdTE3NTNcXHgwMlxcdTE3NjJcXHgwMlxcdTE3NkVcXHgwMlxcdTE3NzBcXHgwMlxcdTE3NzJcXHgwMlxcdTE3ODJcXHgwMlxcdTE3QjVcXHgwMlwiICtcclxuXHRcdFwiXFx1MTdEOVxceDAyXFx1MTdEOVxceDAyXFx1MTdERVxceDAyXFx1MTdERVxceDAyXFx1MTgyMlxceDAyXFx1MTg3OVxceDAyXFx1MTg4MlxceDAyXCIgK1xyXG5cdFx0XCJcXHUxODg2XFx4MDJcXHUxODg5XFx4MDJcXHUxOEFBXFx4MDJcXHUxOEFDXFx4MDJcXHUxOEFDXFx4MDJcXHUxOEIyXFx4MDJcXHUxOEY3XFx4MDJcIiArXHJcblx0XHRcIlxcdTE5MDJcXHgwMlxcdTE5MjBcXHgwMlxcdTE5NTJcXHgwMlxcdTE5NkZcXHgwMlxcdTE5NzJcXHgwMlxcdTE5NzZcXHgwMlxcdTE5ODJcXHgwMlwiICtcclxuXHRcdFwiXFx1MTlBRFxceDAyXFx1MTlCMlxceDAyXFx1MTlDQlxceDAyXFx1MUEwMlxceDAyXFx1MUExOFxceDAyXFx1MUEyMlxceDAyXFx1MUE1NlxceDAyXCIgK1xyXG5cdFx0XCJcXHUxQUE5XFx4MDJcXHUxQUE5XFx4MDJcXHUxQjA3XFx4MDJcXHUxQjM1XFx4MDJcXHUxQjQ3XFx4MDJcXHUxQjREXFx4MDJcXHUxQjg1XFx4MDJcIiArXHJcblx0XHRcIlxcdTFCQTJcXHgwMlxcdTFCQjBcXHgwMlxcdTFCQjFcXHgwMlxcdTFCQkNcXHgwMlxcdTFCRTdcXHgwMlxcdTFDMDJcXHgwMlxcdTFDMjVcXHgwMlwiICtcclxuXHRcdFwiXFx1MUM0RlxceDAyXFx1MUM1MVxceDAyXFx1MUM1Q1xceDAyXFx1MUM3RlxceDAyXFx1MUM4MlxceDAyXFx1MUM4QVxceDAyXFx1MUNFQlxceDAyXCIgK1xyXG5cdFx0XCJcXHUxQ0VFXFx4MDJcXHUxQ0YwXFx4MDJcXHUxQ0YzXFx4MDJcXHUxQ0Y3XFx4MDJcXHUxQ0Y4XFx4MDJcXHUxRDAyXFx4MDJcXHUxREMxXFx4MDJcIiArXHJcblx0XHRcIlxcdTFFMDJcXHgwMlxcdTFGMTdcXHgwMlxcdTFGMUFcXHgwMlxcdTFGMUZcXHgwMlxcdTFGMjJcXHgwMlxcdTFGNDdcXHgwMlxcdTFGNEFcXHgwMlwiICtcclxuXHRcdFwiXFx1MUY0RlxceDAyXFx1MUY1MlxceDAyXFx1MUY1OVxceDAyXFx1MUY1QlxceDAyXFx1MUY1QlxceDAyXFx1MUY1RFxceDAyXFx1MUY1RFxceDAyXCIgK1xyXG5cdFx0XCJcXHUxRjVGXFx4MDJcXHUxRjVGXFx4MDJcXHUxRjYxXFx4MDJcXHUxRjdGXFx4MDJcXHUxRjgyXFx4MDJcXHUxRkI2XFx4MDJcXHUxRkI4XFx4MDJcIiArXHJcblx0XHRcIlxcdTFGQkVcXHgwMlxcdTFGQzBcXHgwMlxcdTFGQzBcXHgwMlxcdTFGQzRcXHgwMlxcdTFGQzZcXHgwMlxcdTFGQzhcXHgwMlxcdTFGQ0VcXHgwMlwiICtcclxuXHRcdFwiXFx1MUZEMlxceDAyXFx1MUZENVxceDAyXFx1MUZEOFxceDAyXFx1MUZERFxceDAyXFx1MUZFMlxceDAyXFx1MUZFRVxceDAyXFx1MUZGNFxceDAyXCIgK1xyXG5cdFx0XCJcXHUxRkY2XFx4MDJcXHUxRkY4XFx4MDJcXHUxRkZFXFx4MDJcXHUyMDczXFx4MDJcXHUyMDczXFx4MDJcXHUyMDgxXFx4MDJcXHUyMDgxXFx4MDJcIiArXHJcblx0XHRcIlxcdTIwOTJcXHgwMlxcdTIwOUVcXHgwMlxcdTIxMDRcXHgwMlxcdTIxMDRcXHgwMlxcdTIxMDlcXHgwMlxcdTIxMDlcXHgwMlxcdTIxMENcXHgwMlwiICtcclxuXHRcdFwiXFx1MjExNVxceDAyXFx1MjExN1xceDAyXFx1MjExN1xceDAyXFx1MjExQlxceDAyXFx1MjExRlxceDAyXFx1MjEyNlxceDAyXFx1MjEyNlxceDAyXCIgK1xyXG5cdFx0XCJcXHUyMTI4XFx4MDJcXHUyMTI4XFx4MDJcXHUyMTJBXFx4MDJcXHUyMTJBXFx4MDJcXHUyMTJDXFx4MDJcXHUyMTJGXFx4MDJcXHUyMTMxXFx4MDJcIiArXHJcblx0XHRcIlxcdTIxM0JcXHgwMlxcdTIxM0VcXHgwMlxcdTIxNDFcXHgwMlxcdTIxNDdcXHgwMlxcdTIxNEJcXHgwMlxcdTIxNTBcXHgwMlxcdTIxNTBcXHgwMlwiICtcclxuXHRcdFwiXFx1MjE2MlxceDAyXFx1MjE4QVxceDAyXFx1MkMwMlxceDAyXFx1MkMzMFxceDAyXFx1MkMzMlxceDAyXFx1MkM2MFxceDAyXFx1MkM2MlxceDAyXCIgK1xyXG5cdFx0XCJcXHUyQ0U2XFx4MDJcXHUyQ0VEXFx4MDJcXHUyQ0YwXFx4MDJcXHUyQ0Y0XFx4MDJcXHUyQ0Y1XFx4MDJcXHUyRDAyXFx4MDJcXHUyRDI3XFx4MDJcIiArXHJcblx0XHRcIlxcdTJEMjlcXHgwMlxcdTJEMjlcXHgwMlxcdTJEMkZcXHgwMlxcdTJEMkZcXHgwMlxcdTJEMzJcXHgwMlxcdTJENjlcXHgwMlxcdTJENzFcXHgwMlwiICtcclxuXHRcdFwiXFx1MkQ3MVxceDAyXFx1MkQ4MlxceDAyXFx1MkQ5OFxceDAyXFx1MkRBMlxceDAyXFx1MkRBOFxceDAyXFx1MkRBQVxceDAyXFx1MkRCMFxceDAyXCIgK1xyXG5cdFx0XCJcXHUyREIyXFx4MDJcXHUyREI4XFx4MDJcXHUyREJBXFx4MDJcXHUyREMwXFx4MDJcXHUyREMyXFx4MDJcXHUyREM4XFx4MDJcXHUyRENBXFx4MDJcIiArXHJcblx0XHRcIlxcdTJERDBcXHgwMlxcdTJERDJcXHgwMlxcdTJERDhcXHgwMlxcdTJEREFcXHgwMlxcdTJERTBcXHgwMlxcdTJFMzFcXHgwMlxcdTJFMzFcXHgwMlwiICtcclxuXHRcdFwiXFx1MzAwN1xceDAyXFx1MzAwOVxceDAyXFx1MzAyM1xceDAyXFx1MzAyQlxceDAyXFx1MzAzM1xceDAyXFx1MzAzN1xceDAyXFx1MzAzQVxceDAyXCIgK1xyXG5cdFx0XCJcXHUzMDNFXFx4MDJcXHUzMDQzXFx4MDJcXHUzMDk4XFx4MDJcXHUzMDlGXFx4MDJcXHUzMEExXFx4MDJcXHUzMEEzXFx4MDJcXHUzMEZDXFx4MDJcIiArXHJcblx0XHRcIlxcdTMwRkVcXHgwMlxcdTMxMDFcXHgwMlxcdTMxMDdcXHgwMlxcdTMxMkZcXHgwMlxcdTMxMzNcXHgwMlxcdTMxOTBcXHgwMlxcdTMxQTJcXHgwMlwiICtcclxuXHRcdFwiXFx1MzFCQ1xceDAyXFx1MzFGMlxceDAyXFx1MzIwMVxceDAyXFx1MzQwMlxceDAyXFx1NERCN1xceDAyXFx1NEUwMlxceDAyXFx1OUZEN1xceDAyXCIgK1xyXG5cdFx0XCJcXHVBMDAyXFx4MDJcXHVBNDhFXFx4MDJcXHVBNEQyXFx4MDJcXHVBNEZGXFx4MDJcXHVBNTAyXFx4MDJcXHVBNjBFXFx4MDJcXHVBNjEyXFx4MDJcIiArXHJcblx0XHRcIlxcdUE2MjFcXHgwMlxcdUE2MkNcXHgwMlxcdUE2MkRcXHgwMlxcdUE2NDJcXHgwMlxcdUE2NzBcXHgwMlxcdUE2ODFcXHgwMlxcdUE2OUZcXHgwMlwiICtcclxuXHRcdFwiXFx1QTZBMlxceDAyXFx1QTZGMVxceDAyXFx1QTcxOVxceDAyXFx1QTcyMVxceDAyXFx1QTcyNFxceDAyXFx1QTc4QVxceDAyXFx1QTc4RFxceDAyXCIgK1xyXG5cdFx0XCJcXHVBN0IwXFx4MDJcXHVBN0IyXFx4MDJcXHVBN0I5XFx4MDJcXHVBN0Y5XFx4MDJcXHVBODAzXFx4MDJcXHVBODA1XFx4MDJcXHVBODA3XFx4MDJcIiArXHJcblx0XHRcIlxcdUE4MDlcXHgwMlxcdUE4MENcXHgwMlxcdUE4MEVcXHgwMlxcdUE4MjRcXHgwMlxcdUE4NDJcXHgwMlxcdUE4NzVcXHgwMlxcdUE4ODRcXHgwMlwiICtcclxuXHRcdFwiXFx1QThCNVxceDAyXFx1QThGNFxceDAyXFx1QThGOVxceDAyXFx1QThGRFxceDAyXFx1QThGRFxceDAyXFx1QThGRlxceDAyXFx1QThGRlxceDAyXCIgK1xyXG5cdFx0XCJcXHVBOTBDXFx4MDJcXHVBOTI3XFx4MDJcXHVBOTMyXFx4MDJcXHVBOTQ4XFx4MDJcXHVBOTYyXFx4MDJcXHVBOTdFXFx4MDJcXHVBOTg2XFx4MDJcIiArXHJcblx0XHRcIlxcdUE5QjRcXHgwMlxcdUE5RDFcXHgwMlxcdUE5RDFcXHgwMlxcdUE5RTJcXHgwMlxcdUE5RTZcXHgwMlxcdUE5RThcXHgwMlxcdUE5RjFcXHgwMlwiICtcclxuXHRcdFwiXFx1QTlGQ1xceDAyXFx1QUEwMFxceDAyXFx1QUEwMlxceDAyXFx1QUEyQVxceDAyXFx1QUE0MlxceDAyXFx1QUE0NFxceDAyXFx1QUE0NlxceDAyXCIgK1xyXG5cdFx0XCJcXHVBQTREXFx4MDJcXHVBQTYyXFx4MDJcXHVBQTc4XFx4MDJcXHVBQTdDXFx4MDJcXHVBQTdDXFx4MDJcXHVBQTgwXFx4MDJcXHVBQUIxXFx4MDJcIiArXHJcblx0XHRcIlxcdUFBQjNcXHgwMlxcdUFBQjNcXHgwMlxcdUFBQjdcXHgwMlxcdUFBQjhcXHgwMlxcdUFBQkJcXHgwMlxcdUFBQkZcXHgwMlxcdUFBQzJcXHgwMlwiICtcclxuXHRcdFwiXFx1QUFDMlxceDAyXFx1QUFDNFxceDAyXFx1QUFDNFxceDAyXFx1QUFERFxceDAyXFx1QUFERlxceDAyXFx1QUFFMlxceDAyXFx1QUFFQ1xceDAyXCIgK1xyXG5cdFx0XCJcXHVBQUY0XFx4MDJcXHVBQUY2XFx4MDJcXHVBQjAzXFx4MDJcXHVBQjA4XFx4MDJcXHVBQjBCXFx4MDJcXHVBQjEwXFx4MDJcXHVBQjEzXFx4MDJcIiArXHJcblx0XHRcIlxcdUFCMThcXHgwMlxcdUFCMjJcXHgwMlxcdUFCMjhcXHgwMlxcdUFCMkFcXHgwMlxcdUFCMzBcXHgwMlxcdUFCMzJcXHgwMlxcdUFCNUNcXHgwMlwiICtcclxuXHRcdFwiXFx1QUI1RVxceDAyXFx1QUI2N1xceDAyXFx1QUI3MlxceDAyXFx1QUJFNFxceDAyXFx1QUMwMlxceDAyXFx1RDdBNVxceDAyXFx1RDdCMlxceDAyXCIgK1xyXG5cdFx0XCJcXHVEN0M4XFx4MDJcXHVEN0NEXFx4MDJcXHVEN0ZEXFx4MDJcXHVGOTAyXFx4MDJcXHVGQTZGXFx4MDJcXHVGQTcyXFx4MDJcXHVGQURCXFx4MDJcIiArXHJcblx0XHRcIlxcdUZCMDJcXHgwMlxcdUZCMDhcXHgwMlxcdUZCMTVcXHgwMlxcdUZCMTlcXHgwMlxcdUZCMUZcXHgwMlxcdUZCMUZcXHgwMlxcdUZCMjFcXHgwMlwiICtcclxuXHRcdFwiXFx1RkIyQVxceDAyXFx1RkIyQ1xceDAyXFx1RkIzOFxceDAyXFx1RkIzQVxceDAyXFx1RkIzRVxceDAyXFx1RkI0MFxceDAyXFx1RkI0MFxceDAyXCIgK1xyXG5cdFx0XCJcXHVGQjQyXFx4MDJcXHVGQjQzXFx4MDJcXHVGQjQ1XFx4MDJcXHVGQjQ2XFx4MDJcXHVGQjQ4XFx4MDJcXHVGQkIzXFx4MDJcXHVGQkQ1XFx4MDJcIiArXHJcblx0XHRcIlxcdUZEM0ZcXHgwMlxcdUZENTJcXHgwMlxcdUZEOTFcXHgwMlxcdUZEOTRcXHgwMlxcdUZEQzlcXHgwMlxcdUZERjJcXHgwMlxcdUZERkRcXHgwMlwiICtcclxuXHRcdFwiXFx1RkU3MlxceDAyXFx1RkU3NlxceDAyXFx1RkU3OFxceDAyXFx1RkVGRVxceDAyXFx1RkYyM1xceDAyXFx1RkYzQ1xceDAyXFx1RkY0M1xceDAyXCIgK1xyXG5cdFx0XCJcXHVGRjVDXFx4MDJcXHVGRjY4XFx4MDJcXHVGRkMwXFx4MDJcXHVGRkM0XFx4MDJcXHVGRkM5XFx4MDJcXHVGRkNDXFx4MDJcXHVGRkQxXFx4MDJcIiArXHJcblx0XHRcIlxcdUZGRDRcXHgwMlxcdUZGRDlcXHgwMlxcdUZGRENcXHgwMlxcdUZGREVcXHgwMlxceDAyXFx4MDNcXHJcXHgwM1xceDBGXFx4MDMoXFx4MDMqXFx4MDNcIiArXHJcblx0XHRcIjxcXHgwMz5cXHgwMz9cXHgwM0FcXHgwM09cXHgwM1JcXHgwM19cXHgwM1xceDgyXFx4MDNcXHhGQ1xceDAzXFx1MDE0MlxceDAzXFx1MDE3NlxceDAzXCIgK1xyXG5cdFx0XCJcXHUwMjgyXFx4MDNcXHUwMjlFXFx4MDNcXHUwMkEyXFx4MDNcXHUwMkQyXFx4MDNcXHUwMzAyXFx4MDNcXHUwMzIxXFx4MDNcXHUwMzMyXFx4MDNcIiArXHJcblx0XHRcIlxcdTAzNENcXHgwM1xcdTAzNTJcXHgwM1xcdTAzNzdcXHgwM1xcdTAzODJcXHgwM1xcdTAzOUZcXHgwM1xcdTAzQTJcXHgwM1xcdTAzQzVcXHgwM1wiICtcclxuXHRcdFwiXFx1MDNDQVxceDAzXFx1MDNEMVxceDAzXFx1MDNEM1xceDAzXFx1MDNEN1xceDAzXFx1MDQwMlxceDAzXFx1MDQ5RlxceDAzXFx1MDRCMlxceDAzXCIgK1xyXG5cdFx0XCJcXHUwNEQ1XFx4MDNcXHUwNERBXFx4MDNcXHUwNEZEXFx4MDNcXHUwNTAyXFx4MDNcXHUwNTI5XFx4MDNcXHUwNTMyXFx4MDNcXHUwNTY1XFx4MDNcIiArXHJcblx0XHRcIlxcdTA2MDJcXHgwM1xcdTA3MzhcXHgwM1xcdTA3NDJcXHgwM1xcdTA3NTdcXHgwM1xcdTA3NjJcXHgwM1xcdTA3NjlcXHgwM1xcdTA4MDJcXHgwM1wiICtcclxuXHRcdFwiXFx1MDgwN1xceDAzXFx1MDgwQVxceDAzXFx1MDgwQVxceDAzXFx1MDgwQ1xceDAzXFx1MDgzN1xceDAzXFx1MDgzOVxceDAzXFx1MDgzQVxceDAzXCIgK1xyXG5cdFx0XCJcXHUwODNFXFx4MDNcXHUwODNFXFx4MDNcXHUwODQxXFx4MDNcXHUwODU3XFx4MDNcXHUwODYyXFx4MDNcXHUwODc4XFx4MDNcXHUwODgyXFx4MDNcIiArXHJcblx0XHRcIlxcdTA4QTBcXHgwM1xcdTA4RTJcXHgwM1xcdTA4RjRcXHgwM1xcdTA4RjZcXHgwM1xcdTA4RjdcXHgwM1xcdTA5MDJcXHgwM1xcdTA5MTdcXHgwM1wiICtcclxuXHRcdFwiXFx1MDkyMlxceDAzXFx1MDkzQlxceDAzXFx1MDk4MlxceDAzXFx1MDlCOVxceDAzXFx1MDlDMFxceDAzXFx1MDlDMVxceDAzXFx1MEEwMlxceDAzXCIgK1xyXG5cdFx0XCJcXHUwQTAyXFx4MDNcXHUwQTEyXFx4MDNcXHUwQTE1XFx4MDNcXHUwQTE3XFx4MDNcXHUwQTE5XFx4MDNcXHUwQTFCXFx4MDNcXHUwQTM1XFx4MDNcIiArXHJcblx0XHRcIlxcdTBBNjJcXHgwM1xcdTBBN0VcXHgwM1xcdTBBODJcXHgwM1xcdTBBOUVcXHgwM1xcdTBBQzJcXHgwM1xcdTBBQzlcXHgwM1xcdTBBQ0JcXHgwM1wiICtcclxuXHRcdFwiXFx1MEFFNlxceDAzXFx1MEIwMlxceDAzXFx1MEIzN1xceDAzXFx1MEI0MlxceDAzXFx1MEI1N1xceDAzXFx1MEI2MlxceDAzXFx1MEI3NFxceDAzXCIgK1xyXG5cdFx0XCJcXHUwQjgyXFx4MDNcXHUwQjkzXFx4MDNcXHUwQzAyXFx4MDNcXHUwQzRBXFx4MDNcXHUwQzgyXFx4MDNcXHUwQ0I0XFx4MDNcXHUwQ0MyXFx4MDNcIiArXHJcblx0XHRcIlxcdTBDRjRcXHgwM1xcdTEwMDVcXHgwM1xcdTEwMzlcXHgwM1xcdTEwODVcXHgwM1xcdTEwQjFcXHgwM1xcdTEwRDJcXHgwM1xcdTEwRUFcXHgwM1wiICtcclxuXHRcdFwiXFx1MTEwNVxceDAzXFx1MTEyOFxceDAzXFx1MTE1MlxceDAzXFx1MTE3NFxceDAzXFx1MTE3OFxceDAzXFx1MTE3OFxceDAzXFx1MTE4NVxceDAzXCIgK1xyXG5cdFx0XCJcXHUxMUI0XFx4MDNcXHUxMUMzXFx4MDNcXHUxMUM2XFx4MDNcXHUxMURDXFx4MDNcXHUxMURDXFx4MDNcXHUxMURFXFx4MDNcXHUxMURFXFx4MDNcIiArXHJcblx0XHRcIlxcdTEyMDJcXHgwM1xcdTEyMTNcXHgwM1xcdTEyMTVcXHgwM1xcdTEyMkRcXHgwM1xcdTEyODJcXHgwM1xcdTEyODhcXHgwM1xcdTEyOEFcXHgwM1wiICtcclxuXHRcdFwiXFx1MTI4QVxceDAzXFx1MTI4Q1xceDAzXFx1MTI4RlxceDAzXFx1MTI5MVxceDAzXFx1MTI5RlxceDAzXFx1MTJBMVxceDAzXFx1MTJBQVxceDAzXCIgK1xyXG5cdFx0XCJcXHUxMkIyXFx4MDNcXHUxMkUwXFx4MDNcXHUxMzA3XFx4MDNcXHUxMzBFXFx4MDNcXHUxMzExXFx4MDNcXHUxMzEyXFx4MDNcXHUxMzE1XFx4MDNcIiArXHJcblx0XHRcIlxcdTEzMkFcXHgwM1xcdTEzMkNcXHgwM1xcdTEzMzJcXHgwM1xcdTEzMzRcXHgwM1xcdTEzMzVcXHgwM1xcdTEzMzdcXHgwM1xcdTEzM0JcXHgwM1wiICtcclxuXHRcdFwiXFx1MTMzRlxceDAzXFx1MTMzRlxceDAzXFx1MTM1MlxceDAzXFx1MTM1MlxceDAzXFx1MTM1RlxceDAzXFx1MTM2M1xceDAzXFx1MTQwMlxceDAzXCIgK1xyXG5cdFx0XCJcXHUxNDM2XFx4MDNcXHUxNDQ5XFx4MDNcXHUxNDRDXFx4MDNcXHUxNDgyXFx4MDNcXHUxNEIxXFx4MDNcXHUxNEM2XFx4MDNcXHUxNEM3XFx4MDNcIiArXHJcblx0XHRcIlxcdTE0QzlcXHgwM1xcdTE0QzlcXHgwM1xcdTE1ODJcXHgwM1xcdTE1QjBcXHgwM1xcdTE1REFcXHgwM1xcdTE1RERcXHgwM1xcdTE2MDJcXHgwM1wiICtcclxuXHRcdFwiXFx1MTYzMVxceDAzXFx1MTY0NlxceDAzXFx1MTY0NlxceDAzXFx1MTY4MlxceDAzXFx1MTZBQ1xceDAzXFx1MTcwMlxceDAzXFx1MTcxQlxceDAzXCIgK1xyXG5cdFx0XCJcXHUxOEEyXFx4MDNcXHUxOEUxXFx4MDNcXHUxOTAxXFx4MDNcXHUxOTAxXFx4MDNcXHUxQUMyXFx4MDNcXHUxQUZBXFx4MDNcXHUxQzAyXFx4MDNcIiArXHJcblx0XHRcIlxcdTFDMEFcXHgwM1xcdTFDMENcXHgwM1xcdTFDMzBcXHgwM1xcdTFDNDJcXHgwM1xcdTFDNDJcXHgwM1xcdTFDNzRcXHgwM1xcdTFDOTFcXHgwM1wiICtcclxuXHRcdFwiXFx1MjAwMlxceDAzXFx1MjM5QlxceDAzXFx1MjQwMlxceDAzXFx1MjQ3MFxceDAzXFx1MjQ4MlxceDAzXFx1MjU0NVxceDAzXFx1MzAwMlxceDAzXCIgK1xyXG5cdFx0XCJcXHUzNDMwXFx4MDNcXHU0NDAyXFx4MDNcXHU0NjQ4XFx4MDNcXHU2ODAyXFx4MDNcXHU2QTNBXFx4MDNcXHU2QTQyXFx4MDNcXHU2QTYwXFx4MDNcIiArXHJcblx0XHRcIlxcdTZBRDJcXHgwM1xcdTZBRUZcXHgwM1xcdTZCMDJcXHgwM1xcdTZCMzFcXHgwM1xcdTZCNDJcXHgwM1xcdTZCNDVcXHgwM1xcdTZCNjVcXHgwM1wiICtcclxuXHRcdFwiXFx1NkI3OVxceDAzXFx1NkI3RlxceDAzXFx1NkI5MVxceDAzXFx1NkYwMlxceDAzXFx1NkY0NlxceDAzXFx1NkY1MlxceDAzXFx1NkY1MlxceDAzXCIgK1xyXG5cdFx0XCJcXHU2Rjk1XFx4MDNcXHU2RkExXFx4MDNcXHU2RkUyXFx4MDNcXHU2RkUyXFx4MDNcXHU3MDAyXFx4MDNcXHU4N0VFXFx4MDNcXHU4ODAyXFx4MDNcIiArXHJcblx0XHRcIlxcdThBRjRcXHgwM1xcdUIwMDJcXHgwM1xcdUIwMDNcXHgwM1xcdUJDMDJcXHgwM1xcdUJDNkNcXHgwM1xcdUJDNzJcXHgwM1xcdUJDN0VcXHgwM1wiICtcclxuXHRcdFwiXFx1QkM4MlxceDAzXFx1QkM4QVxceDAzXFx1QkM5MlxceDAzXFx1QkM5QlxceDAzXFx1RDQwMlxceDAzXFx1RDQ1NlxceDAzXFx1RDQ1OFxceDAzXCIgK1xyXG5cdFx0XCJcXHVENDlFXFx4MDNcXHVENEEwXFx4MDNcXHVENEExXFx4MDNcXHVENEE0XFx4MDNcXHVENEE0XFx4MDNcXHVENEE3XFx4MDNcXHVENEE4XFx4MDNcIiArXHJcblx0XHRcIlxcdUQ0QUJcXHgwM1xcdUQ0QUVcXHgwM1xcdUQ0QjBcXHgwM1xcdUQ0QkJcXHgwM1xcdUQ0QkRcXHgwM1xcdUQ0QkRcXHgwM1xcdUQ0QkZcXHgwM1wiICtcclxuXHRcdFwiXFx1RDRDNVxceDAzXFx1RDRDN1xceDAzXFx1RDUwN1xceDAzXFx1RDUwOVxceDAzXFx1RDUwQ1xceDAzXFx1RDUwRlxceDAzXFx1RDUxNlxceDAzXCIgK1xyXG5cdFx0XCJcXHVENTE4XFx4MDNcXHVENTFFXFx4MDNcXHVENTIwXFx4MDNcXHVENTNCXFx4MDNcXHVENTNEXFx4MDNcXHVENTQwXFx4MDNcXHVENTQyXFx4MDNcIiArXHJcblx0XHRcIlxcdUQ1NDZcXHgwM1xcdUQ1NDhcXHgwM1xcdUQ1NDhcIjtcclxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBfc2VyaWFsaXplZEFUTlNlZ21lbnQxOiBzdHJpbmcgPVxyXG5cdFx0XCJcXHgwM1xcdUQ1NENcXHgwM1xcdUQ1NTJcXHgwM1xcdUQ1NTRcXHgwM1xcdUQ2QTdcXHgwM1xcdUQ2QUFcXHgwM1xcdUQ2QzJcXHgwM1xcdUQ2QzRcIiArXHJcblx0XHRcIlxceDAzXFx1RDZEQ1xceDAzXFx1RDZERVxceDAzXFx1RDZGQ1xceDAzXFx1RDZGRVxceDAzXFx1RDcxNlxceDAzXFx1RDcxOFxceDAzXFx1RDczNlwiICtcclxuXHRcdFwiXFx4MDNcXHVENzM4XFx4MDNcXHVENzUwXFx4MDNcXHVENzUyXFx4MDNcXHVENzcwXFx4MDNcXHVENzcyXFx4MDNcXHVENzhBXFx4MDNcXHVENzhDXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUQ3QUFcXHgwM1xcdUQ3QUNcXHgwM1xcdUQ3QzRcXHgwM1xcdUQ3QzZcXHgwM1xcdUQ3Q0RcXHgwM1xcdUU4MDJcXHgwM1xcdUU4QzZcIiArXHJcblx0XHRcIlxceDAzXFx1RTkwMlxceDAzXFx1RTk0NVxceDAzXFx1RUUwMlxceDAzXFx1RUUwNVxceDAzXFx1RUUwN1xceDAzXFx1RUUyMVxceDAzXFx1RUUyM1wiICtcclxuXHRcdFwiXFx4MDNcXHVFRTI0XFx4MDNcXHVFRTI2XFx4MDNcXHVFRTI2XFx4MDNcXHVFRTI5XFx4MDNcXHVFRTI5XFx4MDNcXHVFRTJCXFx4MDNcXHVFRTM0XCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFMzZcXHgwM1xcdUVFMzlcXHgwM1xcdUVFM0JcXHgwM1xcdUVFM0JcXHgwM1xcdUVFM0RcXHgwM1xcdUVFM0RcXHgwM1xcdUVFNDRcIiArXHJcblx0XHRcIlxceDAzXFx1RUU0NFxceDAzXFx1RUU0OVxceDAzXFx1RUU0OVxceDAzXFx1RUU0QlxceDAzXFx1RUU0QlxceDAzXFx1RUU0RFxceDAzXFx1RUU0RFwiICtcclxuXHRcdFwiXFx4MDNcXHVFRTRGXFx4MDNcXHVFRTUxXFx4MDNcXHVFRTUzXFx4MDNcXHVFRTU0XFx4MDNcXHVFRTU2XFx4MDNcXHVFRTU2XFx4MDNcXHVFRTU5XCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFNTlcXHgwM1xcdUVFNUJcXHgwM1xcdUVFNUJcXHgwM1xcdUVFNURcXHgwM1xcdUVFNURcXHgwM1xcdUVFNUZcXHgwM1xcdUVFNUZcIiArXHJcblx0XHRcIlxceDAzXFx1RUU2MVxceDAzXFx1RUU2MVxceDAzXFx1RUU2M1xceDAzXFx1RUU2NFxceDAzXFx1RUU2NlxceDAzXFx1RUU2NlxceDAzXFx1RUU2OVwiICtcclxuXHRcdFwiXFx4MDNcXHVFRTZDXFx4MDNcXHVFRTZFXFx4MDNcXHVFRTc0XFx4MDNcXHVFRTc2XFx4MDNcXHVFRTc5XFx4MDNcXHVFRTdCXFx4MDNcXHVFRTdFXCIgK1xyXG5cdFx0XCJcXHgwM1xcdUVFODBcXHgwM1xcdUVFODBcXHgwM1xcdUVFODJcXHgwM1xcdUVFOEJcXHgwM1xcdUVFOERcXHgwM1xcdUVFOURcXHgwM1xcdUVFQTNcIiArXHJcblx0XHRcIlxceDAzXFx1RUVBNVxceDAzXFx1RUVBN1xceDAzXFx1RUVBQlxceDAzXFx1RUVBRFxceDAzXFx1RUVCRFxceDAzXFx4MDJcXHgwNFxcdUE2RDhcXHgwNFwiICtcclxuXHRcdFwiXFx1QTcwMlxceDA0XFx1QjczNlxceDA0XFx1Qjc0MlxceDA0XFx1QjgxRlxceDA0XFx1QjgyMlxceDA0XFx1Q0VBM1xceDA0XFx1RjgwMlxceDA0XCIgK1xyXG5cdFx0XCJcXHVGQTFGXFx4MDQxXFx4MDJcXHgwM1xceDAzXFx4MDJcXHgwMlxceDAyXFx4MDJcXHgwNVxceDAzXFx4MDJcXHgwMlxceDAyXFx4MDJcXHgwN1xceDAzXCIgK1xyXG5cdFx0XCJcXHgwMlxceDAyXFx4MDJcXHgwMlxcdFxceDAzXFx4MDJcXHgwMlxceDAyXFx4MDJcXHZcXHgwM1xceDAyXFx4MDJcXHgwMlxceDAyXFx4MTFcXHgwM1xceDAyXCIgK1xyXG5cdFx0XCJcXHgwMlxceDAyXFx4MDNcXHgxM1xceDAzXFx4MDJcXHgwMlxceDAyXFx4MDVcXHgxNlxceDAzXFx4MDJcXHgwMlxceDAyXFx4MDdcXHgxOFxceDAzXFx4MDJcIiArXHJcblx0XHRcIlxceDAyXFx4MDJcXHRcXHgxQVxceDAzXFx4MDJcXHgwMlxceDAyXFx2XFx4MUNcXHgwM1xceDAyXFx4MDJcXHgwMlxcciVcXHgwM1xceDAyXFx4MDJcXHgwMlwiICtcclxuXHRcdFwiXFx4MEZcXCdcXHgwM1xceDAyXFx4MDJcXHgwMlxceDExKVxceDAzXFx4MDJcXHgwMlxceDAyXFx4MTNcXHgxNFxceDA3MVxceDAyXFx4MDJcXHgxNFxceDE1XCIgK1xyXG5cdFx0XCJcXHgwNzFcXHgwMlxceDAyXFx4MTVcXHgwNFxceDAzXFx4MDJcXHgwMlxceDAyXFx4MTZcXHgxN1xceDA3MVxceDAyXFx4MDJcXHgxN1xceDA2XFx4MDNcIiArXHJcblx0XHRcIlxceDAyXFx4MDJcXHgwMlxceDE4XFx4MTlcXHgwNyxcXHgwMlxceDAyXFx4MTlcXGJcXHgwM1xceDAyXFx4MDJcXHgwMlxceDFBXFx4MUJcXHgwNyNcXHgwMlwiICtcclxuXHRcdFwiXFx4MDJcXHgxQlxcblxceDAzXFx4MDJcXHgwMlxceDAyXFx4MUMgXFx4MDVcXHgwRlxcYlxceDAyXFx4MURcXHgxRlxceDA1XFxyXFx4MDdcXHgwMlxceDFFXCIgK1xyXG5cdFx0XCJcXHgxRFxceDAzXFx4MDJcXHgwMlxceDAyXFx4MUZcXFwiXFx4MDNcXHgwMlxceDAyXFx4MDIgXFx4MUVcXHgwM1xceDAyXFx4MDJcXHgwMiAhXFx4MDNcIiArXHJcblx0XHRcIlxceDAyXFx4MDJcXHgwMiEjXFx4MDNcXHgwMlxceDAyXFx4MDJcXFwiIFxceDAzXFx4MDJcXHgwMlxceDAyIyRcXGJcXHgwNlxceDAyXFx4MDIkXFxmXFx4MDNcIiArXHJcblx0XHRcIlxceDAyXFx4MDJcXHgwMiUmXFx0XFx4MDJcXHgwMlxceDAyJlxceDBFXFx4MDNcXHgwMlxceDAyXFx4MDJcXCcoXFx0XFx4MDNcXHgwMlxceDAyKFxceDEwXCIgK1xyXG5cdFx0XCJcXHgwM1xceDAyXFx4MDJcXHgwMiktXFx4MDcpXFx4MDJcXHgwMiosXFx2XFx4MDJcXHgwMlxceDAyKypcXHgwM1xceDAyXFx4MDJcXHgwMiwvXFx4MDNcIiArXHJcblx0XHRcIlxceDAyXFx4MDJcXHgwMi0uXFx4MDNcXHgwMlxceDAyXFx4MDItK1xceDAzXFx4MDJcXHgwMlxceDAyLjBcXHgwM1xceDAyXFx4MDJcXHgwMi8tXFx4MDNcIiArXHJcblx0XHRcIlxceDAyXFx4MDJcXHgwMjAxXFx4MDcpXFx4MDJcXHgwMjFcXHgxMlxceDAzXFx4MDJcXHgwMlxceDAyXFx4MDVcXHgwMiAtXFx4MDNcXHgwM1xceDA2XCIgK1xyXG5cdFx0XCJcXHgwMlwiO1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgX3NlcmlhbGl6ZWRBVE46IHN0cmluZyA9IFV0aWxzLmpvaW4oXHJcblx0XHRbXHJcblx0XHRcdFhQYXRoTGV4ZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50MCxcclxuXHRcdFx0WFBhdGhMZXhlci5fc2VyaWFsaXplZEFUTlNlZ21lbnQxLFxyXG5cdFx0XSxcclxuXHRcdFwiXCIsXHJcblx0KTtcclxuXHRwdWJsaWMgc3RhdGljIF9fQVROOiBBVE47XHJcblx0cHVibGljIHN0YXRpYyBnZXQgX0FUTigpOiBBVE4ge1xyXG5cdFx0aWYgKCFYUGF0aExleGVyLl9fQVROKSB7XHJcblx0XHRcdFhQYXRoTGV4ZXIuX19BVE4gPSBuZXcgQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoVXRpbHMudG9DaGFyQXJyYXkoWFBhdGhMZXhlci5fc2VyaWFsaXplZEFUTikpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBYUGF0aExleGVyLl9fQVROO1xyXG5cdH1cclxuXHJcbn1cclxuXHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENPTlZFUlNUSU9OIGNvbXBsZXRlLCBCdXJ0IEhhcnJpcyAxMC8xNC8yMDE2XHJcblxyXG5pbXBvcnQgeyBBTlRMUkVycm9yTGlzdGVuZXIgfSBmcm9tIFwiLi4vLi4vQU5UTFJFcnJvckxpc3RlbmVyXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uLy4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUmVjb2duaXplciB9IGZyb20gXCIuLi8uLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFJlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgWFBhdGhMZXhlckVycm9yTGlzdGVuZXIgaW1wbGVtZW50cyBBTlRMUkVycm9yTGlzdGVuZXI8bnVtYmVyPiB7XHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHN5bnRheEVycm9yPFQgZXh0ZW5kcyBudW1iZXI+KFxyXG5cdFx0cmVjb2duaXplcjogUmVjb2duaXplcjxULCBhbnk+LCBvZmZlbmRpbmdTeW1ib2w6IFQgfCB1bmRlZmluZWQsXHJcblx0XHRsaW5lOiBudW1iZXIsIGNoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyLCBtc2c6IHN0cmluZyxcclxuXHRcdGU6IFJlY29nbml0aW9uRXhjZXB0aW9uIHwgdW5kZWZpbmVkKTogdm9pZCB7XHJcblx0XHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENPTlZFUlNUSU9OIGNvbXBsZXRlLCBCdXJ0IEhhcnJpcyAxMC8xNC8yMDE2XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uLy4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlIH0gZnJvbSBcIi4uL1BhcnNlVHJlZVwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFhQYXRoRWxlbWVudCB7XHJcblx0cHJvdGVjdGVkIG5vZGVOYW1lOiBzdHJpbmc7XHJcblx0cHVibGljIGludmVydDogYm9vbGVhbjtcclxuXHJcblx0LyoqIENvbnN0cnVjdCBlbGVtZW50IGxpa2UgYC9JRGAgb3IgYElEYCBvciBgLypgIGV0Yy4uLlxyXG5cdCAqICBvcCBpcyBudWxsIGlmIGp1c3Qgbm9kZVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKG5vZGVOYW1lOiBzdHJpbmcpIHtcclxuXHRcdHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcclxuXHRcdHRoaXMuaW52ZXJ0ID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHaXZlbiB0cmVlIHJvb3RlZCBhdCBgdGAgcmV0dXJuIGFsbCBub2RlcyBtYXRjaGVkIGJ5IHRoaXMgcGF0aFxyXG5cdCAqIGVsZW1lbnQuXHJcblx0ICovXHJcblx0cHVibGljIGFic3RyYWN0IGV2YWx1YXRlKHQ6IFBhcnNlVHJlZSk6IFBhcnNlVHJlZVtdO1xyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGxldCBpbnY6IHN0cmluZyA9IHRoaXMuaW52ZXJ0ID8gXCIhXCIgOiBcIlwiO1xyXG5cdFx0bGV0IGNsYXNzTmFtZTogc3RyaW5nID0gT2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XHJcblx0XHRyZXR1cm4gY2xhc3NOYW1lICsgXCJbXCIgKyBpbnYgKyB0aGlzLm5vZGVOYW1lICsgXCJdXCI7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENPTlZFUlNUSU9OIGNvbXBsZXRlLCBCdXJ0IEhhcnJpcyAxMC8xNC8yMDE2XHJcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcIi4uLy4uL1BhcnNlclJ1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uLy4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlIH0gZnJvbSBcIi4uL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBUcmVlcyB9IGZyb20gXCIuLi9UcmVlc1wiO1xyXG5pbXBvcnQgeyBYUGF0aEVsZW1lbnQgfSBmcm9tIFwiLi9YUGF0aEVsZW1lbnRcIjtcclxuXHJcbi8qKlxyXG4gKiBFaXRoZXIgYElEYCBhdCBzdGFydCBvZiBwYXRoIG9yIGAuLi4vL0lEYCBpbiBtaWRkbGUgb2YgcGF0aC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBYUGF0aFJ1bGVBbnl3aGVyZUVsZW1lbnQgZXh0ZW5kcyBYUGF0aEVsZW1lbnQge1xyXG5cdHByb3RlY3RlZCBydWxlSW5kZXg6IG51bWJlcjtcclxuXHRjb25zdHJ1Y3RvcihydWxlTmFtZTogc3RyaW5nLCBydWxlSW5kZXg6IG51bWJlcikge1xyXG5cdFx0c3VwZXIocnVsZU5hbWUpO1xyXG5cdFx0dGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXZhbHVhdGUodDogUGFyc2VUcmVlKTogUGFyc2VUcmVlW10ge1xyXG5cdFx0cmV0dXJuIFRyZWVzLmZpbmRBbGxSdWxlTm9kZXModCwgdGhpcy5ydWxlSW5kZXgpO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDT05WRVJTVElPTiBjb21wbGV0ZSwgQnVydCBIYXJyaXMgMTAvMTQvMjAxNlxyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuLi8uLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuLi9QYXJzZVRyZWVcIjtcclxuaW1wb3J0IHsgVHJlZXMgfSBmcm9tIFwiLi4vVHJlZXNcIjtcclxuaW1wb3J0IHsgWFBhdGhFbGVtZW50IH0gZnJvbSBcIi4vWFBhdGhFbGVtZW50XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgWFBhdGhSdWxlRWxlbWVudCBleHRlbmRzIFhQYXRoRWxlbWVudCB7XHJcblx0cHJvdGVjdGVkIHJ1bGVJbmRleDogbnVtYmVyO1xyXG5cdGNvbnN0cnVjdG9yKHJ1bGVOYW1lOiBzdHJpbmcsIHJ1bGVJbmRleDogbnVtYmVyKSB7XHJcblx0XHRzdXBlcihydWxlTmFtZSk7XHJcblx0XHR0aGlzLnJ1bGVJbmRleCA9IHJ1bGVJbmRleDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBldmFsdWF0ZSh0OiBQYXJzZVRyZWUpOiBQYXJzZVRyZWVbXSB7XHJcblx0XHQvLyByZXR1cm4gYWxsIGNoaWxkcmVuIG9mIHQgdGhhdCBtYXRjaCBub2RlTmFtZVxyXG5cdFx0bGV0IG5vZGVzOiBQYXJzZVRyZWVbXSA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgYyBvZiBUcmVlcy5nZXRDaGlsZHJlbih0KSkge1xyXG5cdFx0XHRpZiAoYyBpbnN0YW5jZW9mIFBhcnNlclJ1bGVDb250ZXh0KSB7XHJcblx0XHRcdFx0aWYgKChjLnJ1bGVJbmRleCA9PT0gdGhpcy5ydWxlSW5kZXggJiYgIXRoaXMuaW52ZXJ0KSB8fFxyXG5cdFx0XHRcdFx0KGMucnVsZUluZGV4ICE9PSB0aGlzLnJ1bGVJbmRleCAmJiB0aGlzLmludmVydCkpIHtcclxuXHRcdFx0XHRcdG5vZGVzLnB1c2goYyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbm9kZXM7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENPTlZFUlNUSU9OIGNvbXBsZXRlLCBCdXJ0IEhhcnJpcyAxMC8xNC8yMDE2XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4uLy4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlIH0gZnJvbSBcIi4uL1BhcnNlVHJlZVwiO1xyXG5pbXBvcnQgeyBUcmVlcyB9IGZyb20gXCIuLi9UcmVlc1wiO1xyXG5pbXBvcnQgeyBYUGF0aEVsZW1lbnQgfSBmcm9tIFwiLi9YUGF0aEVsZW1lbnRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBYUGF0aFRva2VuQW55d2hlcmVFbGVtZW50IGV4dGVuZHMgWFBhdGhFbGVtZW50IHtcclxuXHRwcm90ZWN0ZWQgdG9rZW5UeXBlOiBudW1iZXI7XHJcblx0Y29uc3RydWN0b3IodG9rZW5OYW1lOiBzdHJpbmcsIHRva2VuVHlwZTogbnVtYmVyKSB7XHJcblx0XHRzdXBlcih0b2tlbk5hbWUpO1xyXG5cdFx0dGhpcy50b2tlblR5cGUgPSB0b2tlblR5cGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXZhbHVhdGUodDogUGFyc2VUcmVlKTogUGFyc2VUcmVlW10ge1xyXG5cdFx0cmV0dXJuIFRyZWVzLmZpbmRBbGxUb2tlbk5vZGVzKHQsIHRoaXMudG9rZW5UeXBlKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ09OVkVSU1RJT04gY29tcGxldGUsIEJ1cnQgSGFycmlzIDEwLzE0LzIwMTZcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWUgfSBmcm9tIFwiLi4vUGFyc2VUcmVlXCI7XHJcbmltcG9ydCB7IFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuLi9UZXJtaW5hbE5vZGVcIjtcclxuaW1wb3J0IHsgVHJlZXMgfSBmcm9tIFwiLi4vVHJlZXNcIjtcclxuaW1wb3J0IHsgWFBhdGhFbGVtZW50IH0gZnJvbSBcIi4vWFBhdGhFbGVtZW50XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgWFBhdGhUb2tlbkVsZW1lbnQgZXh0ZW5kcyBYUGF0aEVsZW1lbnQge1xyXG5cdHByb3RlY3RlZCB0b2tlblR5cGU6IG51bWJlcjtcclxuXHRjb25zdHJ1Y3Rvcih0b2tlbk5hbWU6IHN0cmluZywgdG9rZW5UeXBlOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKHRva2VuTmFtZSk7XHJcblx0XHR0aGlzLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBldmFsdWF0ZSh0OiBQYXJzZVRyZWUpOiBQYXJzZVRyZWVbXSB7XHJcblx0XHQvLyByZXR1cm4gYWxsIGNoaWxkcmVuIG9mIHQgdGhhdCBtYXRjaCBub2RlTmFtZVxyXG5cdFx0bGV0IG5vZGVzOiBQYXJzZVRyZWVbXSA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgYyBvZiBUcmVlcy5nZXRDaGlsZHJlbih0KSkge1xyXG5cdFx0XHRpZiAoYyBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZSkge1xyXG5cdFx0XHRcdGlmICgoYy5zeW1ib2wudHlwZSA9PT0gdGhpcy50b2tlblR5cGUgJiYgIXRoaXMuaW52ZXJ0KSB8fFxyXG5cdFx0XHRcdFx0KGMuc3ltYm9sLnR5cGUgIT09IHRoaXMudG9rZW5UeXBlICYmIHRoaXMuaW52ZXJ0KSkge1xyXG5cdFx0XHRcdFx0bm9kZXMucHVzaChjKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBub2RlcztcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ09OVkVSU1RJT04gY29tcGxldGUsIEJ1cnQgSGFycmlzIDEwLzE0LzIwMTZcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWUgfSBmcm9tIFwiLi4vUGFyc2VUcmVlXCI7XHJcbmltcG9ydCB7IFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuLi9UZXJtaW5hbE5vZGVcIjtcclxuaW1wb3J0IHsgVHJlZXMgfSBmcm9tIFwiLi4vVHJlZXNcIjtcclxuaW1wb3J0IHsgWFBhdGggfSBmcm9tIFwiLi9YUGF0aFwiO1xyXG5pbXBvcnQgeyBYUGF0aEVsZW1lbnQgfSBmcm9tIFwiLi9YUGF0aEVsZW1lbnRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBYUGF0aFdpbGRjYXJkQW55d2hlcmVFbGVtZW50IGV4dGVuZHMgWFBhdGhFbGVtZW50IHtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHN1cGVyKFhQYXRoLldJTERDQVJEKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBldmFsdWF0ZSh0OiBQYXJzZVRyZWUpOiBQYXJzZVRyZWVbXSB7XHJcblx0XHRpZiAodGhpcy5pbnZlcnQpIHtcclxuXHRcdFx0Ly8gISogaXMgd2VpcmQgYnV0IHZhbGlkIChlbXB0eSlcclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIFRyZWVzLmdldERlc2NlbmRhbnRzKHQpO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDT05WRVJTVElPTiBjb21wbGV0ZSwgQnVydCBIYXJyaXMgMTAvMTQvMjAxNlxyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuLi9QYXJzZVRyZWVcIjtcclxuaW1wb3J0IHsgVGVybWluYWxOb2RlIH0gZnJvbSBcIi4uL1Rlcm1pbmFsTm9kZVwiO1xyXG5pbXBvcnQgeyBUcmVlcyB9IGZyb20gXCIuLi9UcmVlc1wiO1xyXG5pbXBvcnQgeyBYUGF0aCB9IGZyb20gXCIuL1hQYXRoXCI7XHJcbmltcG9ydCB7IFhQYXRoRWxlbWVudCB9IGZyb20gXCIuL1hQYXRoRWxlbWVudFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFhQYXRoV2lsZGNhcmRFbGVtZW50IGV4dGVuZHMgWFBhdGhFbGVtZW50IHtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHN1cGVyKFhQYXRoLldJTERDQVJEKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBldmFsdWF0ZSh0OiBQYXJzZVRyZWUpOiBQYXJzZVRyZWVbXSB7XHJcblx0XHRsZXQga2lkczogUGFyc2VUcmVlW10gPSBbXTtcclxuXHRcdGlmICh0aGlzLmludmVydCkge1xyXG5cdFx0XHQvLyAhKiBpcyB3ZWlyZCBidXQgdmFsaWQgKGVtcHR5KVxyXG5cdFx0XHRyZXR1cm4ga2lkcztcclxuXHRcdH1cclxuXHRcdGZvciAobGV0IGMgb2YgVHJlZXMuZ2V0Q2hpbGRyZW4odCkpIHtcclxuXHRcdFx0a2lkcy5wdXNoKGMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGtpZHM7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0Ni40MzczODg4LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBDaGFyU3RyZWFtcyB9IGZyb20gXCIuLi8uLi9DaGFyU3RyZWFtc1wiO1xyXG5pbXBvcnQgeyBDb21tb25Ub2tlblN0cmVhbSB9IGZyb20gXCIuLi8uLi9Db21tb25Ub2tlblN0cmVhbVwiO1xyXG5pbXBvcnQgeyBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL0xleGVyTm9WaWFibGVBbHRFeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4uLy4uL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuLi8uLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWUgfSBmcm9tIFwiLi4vUGFyc2VUcmVlXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4uLy4uL1Rva2VuXCI7XHJcbmltcG9ydCB7IFhQYXRoRWxlbWVudCB9IGZyb20gXCIuL1hQYXRoRWxlbWVudFwiO1xyXG5pbXBvcnQgeyBYUGF0aExleGVyIH0gZnJvbSBcIi4vWFBhdGhMZXhlclwiO1xyXG5pbXBvcnQgeyBYUGF0aExleGVyRXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL1hQYXRoTGV4ZXJFcnJvckxpc3RlbmVyXCI7XHJcbmltcG9ydCB7IFhQYXRoUnVsZUFueXdoZXJlRWxlbWVudCB9IGZyb20gXCIuL1hQYXRoUnVsZUFueXdoZXJlRWxlbWVudFwiO1xyXG5pbXBvcnQgeyBYUGF0aFJ1bGVFbGVtZW50IH0gZnJvbSBcIi4vWFBhdGhSdWxlRWxlbWVudFwiO1xyXG5pbXBvcnQgeyBYUGF0aFRva2VuQW55d2hlcmVFbGVtZW50IH0gZnJvbSBcIi4vWFBhdGhUb2tlbkFueXdoZXJlRWxlbWVudFwiO1xyXG5pbXBvcnQgeyBYUGF0aFRva2VuRWxlbWVudCB9IGZyb20gXCIuL1hQYXRoVG9rZW5FbGVtZW50XCI7XHJcbmltcG9ydCB7IFhQYXRoV2lsZGNhcmRBbnl3aGVyZUVsZW1lbnQgfSBmcm9tIFwiLi9YUGF0aFdpbGRjYXJkQW55d2hlcmVFbGVtZW50XCI7XHJcbmltcG9ydCB7IFhQYXRoV2lsZGNhcmRFbGVtZW50IH0gZnJvbSBcIi4vWFBhdGhXaWxkY2FyZEVsZW1lbnRcIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnQgYSBzdWJzZXQgb2YgWFBhdGggWE1MIHBhdGggc3ludGF4IGZvciB1c2UgaW4gaWRlbnRpZnlpbmcgbm9kZXMgaW5cclxuICogcGFyc2UgdHJlZXMuXHJcbiAqXHJcbiAqIFNwbGl0IHBhdGggaW50byB3b3JkcyBhbmQgc2VwYXJhdG9ycyBgL2AgYW5kIGAvL2AgdmlhIEFOVExSXHJcbiAqIGl0c2VsZiB0aGVuIHdhbGsgcGF0aCBlbGVtZW50cyBmcm9tIGxlZnQgdG8gcmlnaHQuIEF0IGVhY2ggc2VwYXJhdG9yLXdvcmRcclxuICogcGFpciwgZmluZCBzZXQgb2Ygbm9kZXMuIE5leHQgc3RhZ2UgdXNlcyB0aG9zZSBhcyB3b3JrIGxpc3QuXHJcbiAqXHJcbiAqIFRoZSBiYXNpYyBpbnRlcmZhY2UgaXNcclxuICoge0BsaW5rIFhQYXRoI2ZpbmRBbGwgUGFyc2VUcmVlLmZpbmRBbGx9YCh0cmVlLCBwYXRoU3RyaW5nLCBwYXJzZXIpYC5cclxuICogQnV0IHRoYXQgaXMganVzdCBzaG9ydGhhbmQgZm9yOlxyXG4gKlxyXG4gKiBgYGBcclxuICogbGV0IHAgPSBuZXcgWFBhdGgocGFyc2VyLCBwYXRoU3RyaW5nKTtcclxuICogcmV0dXJuIHAuZXZhbHVhdGUodHJlZSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBTZWUgYFRlc3RYUGF0aGAgZm9yIGRlc2NyaXB0aW9ucy4gSW4gc2hvcnQsIHRoaXNcclxuICogYWxsb3dzIG9wZXJhdG9yczpcclxuICpcclxuICogfCB8IHxcclxuICogfCAtLS0gfCAtLS0gfFxyXG4gKiB8IGAvYCB8IHJvb3QgfFxyXG4gKiB8IGAvL2AgfCBhbnl3aGVyZSB8XHJcbiAqIHwgYCFgIHwgaW52ZXJ0OyB0aGlzIG11Y2ggYXBwZWFyIGRpcmVjdGx5IGFmdGVyIHJvb3Qgb3IgYW55d2hlcmUgb3BlcmF0b3IgfFxyXG4gKlxyXG4gKiBhbmQgcGF0aCBlbGVtZW50czpcclxuICpcclxuICogfCB8IHxcclxuICogfCAtLS0gfCAtLS0gfFxyXG4gKiB8IGBJRGAgfCB0b2tlbiBuYW1lIHxcclxuICogfCBgJ3N0cmluZydgIHwgYW55IHN0cmluZyBsaXRlcmFsIHRva2VuIGZyb20gdGhlIGdyYW1tYXIgfFxyXG4gKiB8IGBleHByYCB8IHJ1bGUgbmFtZSB8XHJcbiAqIHwgYCpgIHwgd2lsZGNhcmQgbWF0Y2hpbmcgYW55IG5vZGUgfFxyXG4gKlxyXG4gKiBXaGl0ZXNwYWNlIGlzIG5vdCBhbGxvd2VkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFhQYXRoIHtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFdJTERDQVJEOiBzdHJpbmcgPSBcIipcIjsgLy8gd29yZCBub3Qgb3BlcmF0b3Ivc2VwYXJhdG9yXHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBOT1Q6IHN0cmluZyA9IFwiIVwiOyBcdCAgIC8vIHdvcmQgZm9yIGludmVydCBvcGVyYXRvclxyXG5cclxuXHRwcm90ZWN0ZWQgcGF0aDogc3RyaW5nO1xyXG5cdHByb3RlY3RlZCBlbGVtZW50czogWFBhdGhFbGVtZW50W107XHJcblx0cHJvdGVjdGVkIHBhcnNlcjogUGFyc2VyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihwYXJzZXI6IFBhcnNlciwgcGF0aDogc3RyaW5nKSB7XHJcblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuXHRcdHRoaXMucGF0aCA9IHBhdGg7XHJcblx0XHR0aGlzLmVsZW1lbnRzID0gdGhpcy5zcGxpdChwYXRoKTtcclxuXHRcdC8vIGNvbnNvbGUubG9nKHRoaXMuZWxlbWVudHMudG9TdHJpbmcoKSk7XHJcblx0fVxyXG5cclxuXHQvLyBUT0RPOiBjaGVjayBmb3IgaW52YWxpZCB0b2tlbi9ydWxlIG5hbWVzLCBiYWQgc3ludGF4XHJcblxyXG5cdHB1YmxpYyBzcGxpdChwYXRoOiBzdHJpbmcpOiBYUGF0aEVsZW1lbnRbXSB7XHJcblx0XHRsZXQgbGV4ZXIgPSBuZXcgWFBhdGhMZXhlcihDaGFyU3RyZWFtcy5mcm9tU3RyaW5nKHBhdGgpKTtcclxuXHRcdGxleGVyLnJlY292ZXIgPSAoZTogTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbikgPT4geyB0aHJvdyBlOyB9O1xyXG5cclxuXHRcdGxleGVyLnJlbW92ZUVycm9yTGlzdGVuZXJzKCk7XHJcblx0XHRsZXhlci5hZGRFcnJvckxpc3RlbmVyKG5ldyBYUGF0aExleGVyRXJyb3JMaXN0ZW5lcigpKTtcclxuXHRcdGxldCB0b2tlblN0cmVhbSA9IG5ldyBDb21tb25Ub2tlblN0cmVhbShsZXhlcik7XHJcblx0XHR0cnkge1xyXG5cdFx0XHR0b2tlblN0cmVhbS5maWxsKCk7XHJcblx0XHR9XHJcblx0XHRjYXRjaCAoZSkge1xyXG5cdFx0XHRpZiAoZSBpbnN0YW5jZW9mIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24pIHtcclxuXHRcdFx0XHRsZXQgcG9zOiBudW1iZXIgPSBsZXhlci5jaGFyUG9zaXRpb25JbkxpbmU7XHJcblx0XHRcdFx0bGV0IG1zZzogc3RyaW5nID0gXCJJbnZhbGlkIHRva2VucyBvciBjaGFyYWN0ZXJzIGF0IGluZGV4IFwiICsgcG9zICsgXCIgaW4gcGF0aCAnXCIgKyBwYXRoICsgXCInIC0tIFwiICsgZS5tZXNzYWdlO1xyXG5cdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKG1zZyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhyb3cgZTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdG9rZW5zOiBUb2tlbltdID0gdG9rZW5TdHJlYW0uZ2V0VG9rZW5zKCk7XHJcblx0XHQvLyBjb25zb2xlLmxvZyhcInBhdGg9XCIgKyBwYXRoICsgXCI9PlwiICsgdG9rZW5zKTtcclxuXHRcdGxldCBlbGVtZW50czogWFBhdGhFbGVtZW50W10gPSBbXTtcclxuXHRcdGxldCBuOiBudW1iZXIgPSB0b2tlbnMubGVuZ3RoO1xyXG5cdFx0bGV0IGk6IG51bWJlciA9IDA7XHJcblx0XHRsb29wOlxyXG5cdFx0d2hpbGUgKGkgPCBuKSB7XHJcblx0XHRcdGxldCBlbDogVG9rZW4gPSB0b2tlbnNbaV07XHJcblx0XHRcdGxldCBuZXh0OiBUb2tlbiB8IHVuZGVmaW5lZDtcclxuXHRcdFx0c3dpdGNoIChlbC50eXBlKSB7XHJcblx0XHRcdFx0Y2FzZSBYUGF0aExleGVyLlJPT1Q6XHJcblx0XHRcdFx0Y2FzZSBYUGF0aExleGVyLkFOWVdIRVJFOlxyXG5cdFx0XHRcdFx0bGV0IGFueXdoZXJlOiBib29sZWFuID0gZWwudHlwZSA9PT0gWFBhdGhMZXhlci5BTllXSEVSRTtcclxuXHRcdFx0XHRcdGkrKztcclxuXHRcdFx0XHRcdG5leHQgPSB0b2tlbnNbaV07XHJcblx0XHRcdFx0XHRsZXQgaW52ZXJ0OiBib29sZWFuID0gbmV4dC50eXBlID09PSBYUGF0aExleGVyLkJBTkc7XHJcblx0XHRcdFx0XHRpZiAoaW52ZXJ0KSB7XHJcblx0XHRcdFx0XHRcdGkrKztcclxuXHRcdFx0XHRcdFx0bmV4dCA9IHRva2Vuc1tpXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxldCBwYXRoRWxlbWVudDogWFBhdGhFbGVtZW50ID0gdGhpcy5nZXRYUGF0aEVsZW1lbnQobmV4dCwgYW55d2hlcmUpO1xyXG5cdFx0XHRcdFx0cGF0aEVsZW1lbnQuaW52ZXJ0ID0gaW52ZXJ0O1xyXG5cdFx0XHRcdFx0ZWxlbWVudHMucHVzaChwYXRoRWxlbWVudCk7XHJcblx0XHRcdFx0XHRpKys7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBYUGF0aExleGVyLlRPS0VOX1JFRjpcclxuXHRcdFx0XHRjYXNlIFhQYXRoTGV4ZXIuUlVMRV9SRUY6XHJcblx0XHRcdFx0Y2FzZSBYUGF0aExleGVyLldJTERDQVJEOlxyXG5cdFx0XHRcdFx0ZWxlbWVudHMucHVzaCh0aGlzLmdldFhQYXRoRWxlbWVudChlbCwgZmFsc2UpKTtcclxuXHRcdFx0XHRcdGkrKztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRva2VuLkVPRjpcclxuXHRcdFx0XHRcdGJyZWFrIGxvb3A7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3d0aCBwYXRoIGVsZW1lbnQgXCIgKyBlbCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBlbGVtZW50cztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnQgd29yZCBsaWtlIGAqYCBvciBgSURgIG9yIGBleHByYCB0byBhIHBhdGhcclxuXHQgKiBlbGVtZW50LiBgYW55d2hlcmVgIGlzIGB0cnVlYCBpZiBgLy9gIHByZWNlZGVzIHRoZVxyXG5cdCAqIHdvcmQuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGdldFhQYXRoRWxlbWVudCh3b3JkVG9rZW46IFRva2VuLCBhbnl3aGVyZTogYm9vbGVhbik6IFhQYXRoRWxlbWVudCB7XHJcblx0XHRpZiAod29yZFRva2VuLnR5cGUgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHBhdGggZWxlbWVudCBhdCBlbmQgb2YgcGF0aFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgd29yZCA9IHdvcmRUb2tlbi50ZXh0O1xyXG5cdFx0aWYgKHdvcmQgPT0gbnVsbCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB3b3JkVG9rZW4gdG8gaGF2ZSB0ZXh0IGNvbnRlbnQuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0dHlwZTogbnVtYmVyID0gdGhpcy5wYXJzZXIuZ2V0VG9rZW5UeXBlKHdvcmQpO1xyXG5cdFx0bGV0IHJ1bGVJbmRleDogbnVtYmVyID0gdGhpcy5wYXJzZXIuZ2V0UnVsZUluZGV4KHdvcmQpO1xyXG5cdFx0c3dpdGNoICh3b3JkVG9rZW4udHlwZSkge1xyXG5cdFx0XHRjYXNlIFhQYXRoTGV4ZXIuV0lMRENBUkQ6XHJcblx0XHRcdFx0cmV0dXJuIGFueXdoZXJlID9cclxuXHRcdFx0XHRcdG5ldyBYUGF0aFdpbGRjYXJkQW55d2hlcmVFbGVtZW50KCkgOlxyXG5cdFx0XHRcdFx0bmV3IFhQYXRoV2lsZGNhcmRFbGVtZW50KCk7XHJcblx0XHRcdGNhc2UgWFBhdGhMZXhlci5UT0tFTl9SRUY6XHJcblx0XHRcdGNhc2UgWFBhdGhMZXhlci5TVFJJTkc6XHJcblx0XHRcdFx0aWYgKHR0eXBlID09PSBUb2tlbi5JTlZBTElEX1RZUEUpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcih3b3JkICsgXCIgYXQgaW5kZXggXCIgK1xyXG5cdFx0XHRcdFx0XHR3b3JkVG9rZW4uc3RhcnRJbmRleCArXHJcblx0XHRcdFx0XHRcdFwiIGlzbid0IGEgdmFsaWQgdG9rZW4gbmFtZVwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGFueXdoZXJlID9cclxuXHRcdFx0XHRcdG5ldyBYUGF0aFRva2VuQW55d2hlcmVFbGVtZW50KHdvcmQsIHR0eXBlKSA6XHJcblx0XHRcdFx0XHRuZXcgWFBhdGhUb2tlbkVsZW1lbnQod29yZCwgdHR5cGUpO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGlmIChydWxlSW5kZXggPT09IC0xKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3Iod29yZCArIFwiIGF0IGluZGV4IFwiICtcclxuXHRcdFx0XHRcdFx0d29yZFRva2VuLnN0YXJ0SW5kZXggK1xyXG5cdFx0XHRcdFx0XHRcIiBpc24ndCBhIHZhbGlkIHJ1bGUgbmFtZVwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGFueXdoZXJlID9cclxuXHRcdFx0XHRcdG5ldyBYUGF0aFJ1bGVBbnl3aGVyZUVsZW1lbnQod29yZCwgcnVsZUluZGV4KSA6XHJcblx0XHRcdFx0XHRuZXcgWFBhdGhSdWxlRWxlbWVudCh3b3JkLCBydWxlSW5kZXgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIHN0YXRpYyBmaW5kQWxsKHRyZWU6IFBhcnNlVHJlZSwgeHBhdGg6IHN0cmluZywgcGFyc2VyOiBQYXJzZXIpOiBTZXQ8UGFyc2VUcmVlPiB7XHJcblx0XHRsZXQgcDogWFBhdGggPSBuZXcgWFBhdGgocGFyc2VyLCB4cGF0aCk7XHJcblx0XHRyZXR1cm4gcC5ldmFsdWF0ZSh0cmVlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiBhIGxpc3Qgb2YgYWxsIG5vZGVzIHN0YXJ0aW5nIGF0IGB0YCBhcyByb290IHRoYXQgc2F0aXNmeSB0aGVcclxuXHQgKiBwYXRoLiBUaGUgcm9vdCBgL2AgaXMgcmVsYXRpdmUgdG8gdGhlIG5vZGUgcGFzc2VkIHRvIHtAbGluayBldmFsdWF0ZX0uXHJcblx0ICovXHJcblx0cHVibGljIGV2YWx1YXRlKHQ6IFBhcnNlVHJlZSk6IFNldDxQYXJzZVRyZWU+IHtcclxuXHRcdGxldCBkdW1teVJvb3QgPSBuZXcgUGFyc2VyUnVsZUNvbnRleHQoKTtcclxuXHRcdGR1bW15Um9vdC5hZGRDaGlsZCh0IGFzIFBhcnNlclJ1bGVDb250ZXh0KTtcclxuXHJcblx0XHRsZXQgd29yayA9IG5ldyBTZXQ8UGFyc2VUcmVlPihbZHVtbXlSb290XSk7XHJcblxyXG5cdFx0bGV0IGk6IG51bWJlciA9IDA7XHJcblx0XHR3aGlsZSAoaSA8IHRoaXMuZWxlbWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdGxldCBuZXh0ID0gbmV3IFNldDxQYXJzZVRyZWU+KCk7XHJcblx0XHRcdGZvciAobGV0IG5vZGUgb2Ygd29yaykge1xyXG5cdFx0XHRcdGlmIChub2RlLmNoaWxkQ291bnQgPiAwKSB7XHJcblx0XHRcdFx0XHQvLyBvbmx5IHRyeSB0byBtYXRjaCBuZXh0IGVsZW1lbnQgaWYgaXQgaGFzIGNoaWxkcmVuXHJcblx0XHRcdFx0XHQvLyBlLmcuLCAvL2Z1bmMvKi9zdGF0IG1pZ2h0IGhhdmUgYSB0b2tlbiBub2RlIGZvciB3aGljaFxyXG5cdFx0XHRcdFx0Ly8gd2UgY2FuJ3QgZ28gbG9va2luZyBmb3Igc3RhdCBub2Rlcy5cclxuXHRcdFx0XHRcdGxldCBtYXRjaGluZyA9IHRoaXMuZWxlbWVudHNbaV0uZXZhbHVhdGUobm9kZSk7XHJcblx0XHRcdFx0XHRtYXRjaGluZy5mb3JFYWNoKG5leHQuYWRkLCBuZXh0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aSsrO1xyXG5cdFx0XHR3b3JrID0gbmV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gd29yaztcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ09OVkVSU1RJT04gY29tcGxldGUsIEJ1cnQgSGFycmlzIDEwLzE0LzIwMTZcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZSB9IGZyb20gXCIuLi9QYXJzZVRyZWVcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlTWF0Y2ggfSBmcm9tIFwiLi9QYXJzZVRyZWVNYXRjaFwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlciB9IGZyb20gXCIuL1BhcnNlVHJlZVBhdHRlcm5NYXRjaGVyXCI7XHJcbmltcG9ydCB7IFhQYXRoIH0gZnJvbSBcIi4uL3hwYXRoL1hQYXRoXCI7XHJcblxyXG4vKipcclxuICogQSBwYXR0ZXJuIGxpa2UgYDxJRD4gPSA8ZXhwcj47YCBjb252ZXJ0ZWQgdG8gYSB7QGxpbmsgUGFyc2VUcmVlfSBieVxyXG4gKiB7QGxpbmsgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIjY29tcGlsZShTdHJpbmcsIGludCl9LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBhcnNlVHJlZVBhdHRlcm4ge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBwYXR0ZXJuUnVsZUluZGV4YC5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9wYXR0ZXJuUnVsZUluZGV4OiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBwYXR0ZXJuYC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgX3BhdHRlcm46IHN0cmluZztcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3IgYHBhdHRlcm5UcmVlYC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgX3BhdHRlcm5UcmVlOiBQYXJzZVRyZWU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBtYXRjaGVyYC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgX21hdGNoZXI6IFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3QgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJufSBjbGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBtYXRjaGVyIFRoZSB7QGxpbmsgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXJ9IHdoaWNoIGNyZWF0ZWQgdGhpc1xyXG5cdCAqIHRyZWUgcGF0dGVybi5cclxuXHQgKiBAcGFyYW0gcGF0dGVybiBUaGUgdHJlZSBwYXR0ZXJuIGluIGNvbmNyZXRlIHN5bnRheCBmb3JtLlxyXG5cdCAqIEBwYXJhbSBwYXR0ZXJuUnVsZUluZGV4IFRoZSBwYXJzZXIgcnVsZSB3aGljaCBzZXJ2ZXMgYXMgdGhlIHJvb3Qgb2YgdGhlXHJcblx0ICogdHJlZSBwYXR0ZXJuLlxyXG5cdCAqIEBwYXJhbSBwYXR0ZXJuVHJlZSBUaGUgdHJlZSBwYXR0ZXJuIGluIHtAbGluayBQYXJzZVRyZWV9IGZvcm0uXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRATm90TnVsbCBtYXRjaGVyOiBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcixcclxuXHRcdEBOb3ROdWxsIHBhdHRlcm46IHN0cmluZyxcclxuXHRcdHBhdHRlcm5SdWxlSW5kZXg6IG51bWJlcixcclxuXHRcdEBOb3ROdWxsIHBhdHRlcm5UcmVlOiBQYXJzZVRyZWUpIHtcclxuXHRcdHRoaXMuX21hdGNoZXIgPSBtYXRjaGVyO1xyXG5cdFx0dGhpcy5fcGF0dGVyblJ1bGVJbmRleCA9IHBhdHRlcm5SdWxlSW5kZXg7XHJcblx0XHR0aGlzLl9wYXR0ZXJuID0gcGF0dGVybjtcclxuXHRcdHRoaXMuX3BhdHRlcm5UcmVlID0gcGF0dGVyblRyZWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBNYXRjaCBhIHNwZWNpZmljIHBhcnNlIHRyZWUgYWdhaW5zdCB0aGlzIHRyZWUgcGF0dGVybi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0cmVlIFRoZSBwYXJzZSB0cmVlIHRvIG1hdGNoIGFnYWluc3QgdGhpcyB0cmVlIHBhdHRlcm4uXHJcblx0ICogQHJldHVybnMgQSB7QGxpbmsgUGFyc2VUcmVlTWF0Y2h9IG9iamVjdCBkZXNjcmliaW5nIHRoZSByZXN1bHQgb2YgdGhlXHJcblx0ICogbWF0Y2ggb3BlcmF0aW9uLiBUaGUgYFBhcnNlVHJlZU1hdGNoLnN1Y2NlZWRlZGAgbWV0aG9kIGNhbiBiZVxyXG5cdCAqIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRjaCB3YXMgc3VjY2Vzc2Z1bC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBtYXRjaChATm90TnVsbCB0cmVlOiBQYXJzZVRyZWUpOiBQYXJzZVRyZWVNYXRjaCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbWF0Y2hlci5tYXRjaCh0cmVlLCB0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIHBhcnNlIHRyZWUgbWF0Y2hlcyB0aGlzIHRyZWUgcGF0dGVybi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0cmVlIFRoZSBwYXJzZSB0cmVlIHRvIG1hdGNoIGFnYWluc3QgdGhpcyB0cmVlIHBhdHRlcm4uXHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIGB0cmVlYCBpcyBhIG1hdGNoIGZvciB0aGUgY3VycmVudCB0cmVlXHJcblx0ICogcGF0dGVybjsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBtYXRjaGVzKEBOb3ROdWxsIHRyZWU6IFBhcnNlVHJlZSk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX21hdGNoZXIubWF0Y2godHJlZSwgdGhpcykuc3VjY2VlZGVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRmluZCBhbGwgbm9kZXMgdXNpbmcgWFBhdGggYW5kIHRoZW4gdHJ5IHRvIG1hdGNoIHRob3NlIHN1YnRyZWVzIGFnYWluc3RcclxuXHQgKiB0aGlzIHRyZWUgcGF0dGVybi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0cmVlIFRoZSB7QGxpbmsgUGFyc2VUcmVlfSB0byBtYXRjaCBhZ2FpbnN0IHRoaXMgcGF0dGVybi5cclxuXHQgKiBAcGFyYW0geHBhdGggQW4gZXhwcmVzc2lvbiBtYXRjaGluZyB0aGUgbm9kZXNcclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIEEgY29sbGVjdGlvbiBvZiB7QGxpbmsgUGFyc2VUcmVlTWF0Y2h9IG9iamVjdHMgZGVzY3JpYmluZyB0aGVcclxuXHQgKiBzdWNjZXNzZnVsIG1hdGNoZXMuIFVuc3VjY2Vzc2Z1bCBtYXRjaGVzIGFyZSBvbWl0dGVkIGZyb20gdGhlIHJlc3VsdCxcclxuXHQgKiByZWdhcmRsZXNzIG9mIHRoZSByZWFzb24gZm9yIHRoZSBmYWlsdXJlLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGZpbmRBbGwoQE5vdE51bGwgdHJlZTogUGFyc2VUcmVlLCBATm90TnVsbCB4cGF0aDogc3RyaW5nKTogUGFyc2VUcmVlTWF0Y2hbXSB7XHJcblx0XHRsZXQgc3VidHJlZXM6IFNldDxQYXJzZVRyZWU+ID0gWFBhdGguZmluZEFsbCh0cmVlLCB4cGF0aCwgdGhpcy5fbWF0Y2hlci5wYXJzZXIpO1xyXG5cdFx0bGV0IG1hdGNoZXM6IFBhcnNlVHJlZU1hdGNoW10gPSBbXTtcclxuXHRcdGZvciAobGV0IHQgb2Ygc3VidHJlZXMpIHtcclxuXHRcdFx0bGV0IG1hdGNoOiBQYXJzZVRyZWVNYXRjaCA9IHRoaXMubWF0Y2godCk7XHJcblx0XHRcdGlmIChtYXRjaC5zdWNjZWVkZWQpIHtcclxuXHRcdFx0XHRtYXRjaGVzLnB1c2gobWF0Y2gpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbWF0Y2hlcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUge0BsaW5rIFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyfSB3aGljaCBjcmVhdGVkIHRoaXMgdHJlZSBwYXR0ZXJuLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcn0gd2hpY2ggY3JlYXRlZCB0aGlzIHRyZWVcclxuXHQgKiBwYXR0ZXJuLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IG1hdGNoZXIoKTogUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX21hdGNoZXI7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHRyZWUgcGF0dGVybiBpbiBjb25jcmV0ZSBzeW50YXggZm9ybS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSB0cmVlIHBhdHRlcm4gaW4gY29uY3JldGUgc3ludGF4IGZvcm0uXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRnZXQgcGF0dGVybigpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhdHRlcm47XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHBhcnNlciBydWxlIHdoaWNoIHNlcnZlcyBhcyB0aGUgb3V0ZXJtb3N0IHJ1bGUgZm9yIHRoZSB0cmVlXHJcblx0ICogcGF0dGVybi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBwYXJzZXIgcnVsZSB3aGljaCBzZXJ2ZXMgYXMgdGhlIG91dGVybW9zdCBydWxlIGZvciB0aGUgdHJlZVxyXG5cdCAqIHBhdHRlcm4uXHJcblx0ICovXHJcblx0Z2V0IHBhdHRlcm5SdWxlSW5kZXgoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYXR0ZXJuUnVsZUluZGV4O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSB0cmVlIHBhdHRlcm4gYXMgYSB7QGxpbmsgUGFyc2VUcmVlfS4gVGhlIHJ1bGUgYW5kIHRva2VuIHRhZ3MgZnJvbVxyXG5cdCAqIHRoZSBwYXR0ZXJuIGFyZSBwcmVzZW50IGluIHRoZSBwYXJzZSB0cmVlIGFzIHRlcm1pbmFsIG5vZGVzIHdpdGggYSBzeW1ib2xcclxuXHQgKiBvZiB0eXBlIHtAbGluayBSdWxlVGFnVG9rZW59IG9yIHtAbGluayBUb2tlblRhZ1Rva2VufS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSB0cmVlIHBhdHRlcm4gYXMgYSB7QGxpbmsgUGFyc2VUcmVlfS5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBwYXR0ZXJuVHJlZSgpOiBQYXJzZVRyZWUge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhdHRlcm5UcmVlO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDYuMDM0MzUwMC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQ2hhclN0cmVhbSB9IGZyb20gXCIuLi8uLi9DaGFyU3RyZWFtXCI7XHJcbmltcG9ydCB7IE5vdE51bGwsIE92ZXJyaWRlIH0gZnJvbSBcIi4uLy4uL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi4vLi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5Tb3VyY2UgfSBmcm9tIFwiLi4vLi4vVG9rZW5Tb3VyY2VcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHtAbGluayBUb2tlbn0gb2JqZWN0IHJlcHJlc2VudGluZyBhbiBlbnRpcmUgc3VidHJlZSBtYXRjaGVkIGJ5IGEgcGFyc2VyXHJcbiAqIHJ1bGU7IGUuZy4sIGA8ZXhwcj5gLiBUaGVzZSB0b2tlbnMgYXJlIGNyZWF0ZWQgZm9yIHtAbGluayBUYWdDaHVua31cclxuICogY2h1bmtzIHdoZXJlIHRoZSB0YWcgY29ycmVzcG9uZHMgdG8gYSBwYXJzZXIgcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlVGFnVG9rZW4gaW1wbGVtZW50cyBUb2tlbiB7XHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3IgYHJ1bGVOYW1lYC5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9ydWxlTmFtZTogc3RyaW5nO1xyXG5cdC8qKlxyXG5cdCAqIFRoZSB0b2tlbiB0eXBlIGZvciB0aGUgY3VycmVudCB0b2tlbi4gVGhpcyBpcyB0aGUgdG9rZW4gdHlwZSBhc3NpZ25lZCB0b1xyXG5cdCAqIHRoZSBieXBhc3MgYWx0ZXJuYXRpdmUgZm9yIHRoZSBydWxlIGR1cmluZyBBVE4gZGVzZXJpYWxpemF0aW9uLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgYnlwYXNzVG9rZW5UeXBlOiBudW1iZXI7XHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3IgYGxhYmVsYC5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9sYWJlbD86IHN0cmluZztcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgUnVsZVRhZ1Rva2VufSB3aXRoIHRoZSBzcGVjaWZpZWQgcnVsZVxyXG5cdCAqIG5hbWUsIGJ5cGFzcyB0b2tlbiB0eXBlLCBhbmQgbGFiZWwuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcnVsZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHBhcnNlciBydWxlIHRoaXMgcnVsZSB0YWcgbWF0Y2hlcy5cclxuXHQgKiBAcGFyYW0gYnlwYXNzVG9rZW5UeXBlIFRoZSBieXBhc3MgdG9rZW4gdHlwZSBhc3NpZ25lZCB0byB0aGUgcGFyc2VyIHJ1bGUuXHJcblx0ICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCBhc3NvY2lhdGVkIHdpdGggdGhlIHJ1bGUgdGFnLCBvciBgdW5kZWZpbmVkYCBpZlxyXG5cdCAqIHRoZSBydWxlIHRhZyBpcyB1bmxhYmVsZWQuXHJcblx0ICpcclxuXHQgKiBAZXhjZXB0aW9uIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBgcnVsZU5hbWVgIGlzIG5vdCBkZWZpbmVkXHJcblx0ICogb3IgZW1wdHkuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoQE5vdE51bGwgcnVsZU5hbWU6IHN0cmluZywgYnlwYXNzVG9rZW5UeXBlOiBudW1iZXIsIGxhYmVsPzogc3RyaW5nKSB7XHJcblx0XHRpZiAocnVsZU5hbWUgPT0gbnVsbCB8fCBydWxlTmFtZS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwicnVsZU5hbWUgY2Fubm90IGJlIG51bGwgb3IgZW1wdHkuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3J1bGVOYW1lID0gcnVsZU5hbWU7XHJcblx0XHR0aGlzLmJ5cGFzc1Rva2VuVHlwZSA9IGJ5cGFzc1Rva2VuVHlwZTtcclxuXHRcdHRoaXMuX2xhYmVsID0gbGFiZWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBydWxlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJ1bGUgdGFnLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIHBhcnNlciBydWxlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJ1bGUgdGFnLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IHJ1bGVOYW1lKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcnVsZU5hbWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBsYWJlbCBhc3NvY2lhdGVkIHdpdGggdGhlIHJ1bGUgdGFnLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIGxhYmVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgcnVsZSB0YWcsIG9yXHJcblx0ICogYHVuZGVmaW5lZGAgaWYgdGhpcyBpcyBhbiB1bmxhYmVsZWQgcnVsZSB0YWcuXHJcblx0ICovXHJcblx0Z2V0IGxhYmVsKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGFiZWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBSdWxlIHRhZyB0b2tlbnMgYXJlIGFsd2F5cyBwbGFjZWQgb24gdGhlIHtAbGluayAjREVGQVVMVF9DSEFOTkVMfS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgY2hhbm5lbCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIFRva2VuLkRFRkFVTFRfQ0hBTk5FTDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHJ1bGUgdGFnIGZvcm1hdHRlZCB3aXRoIGA8YCBhbmQgYD5gXHJcblx0ICogZGVsaW1pdGVycy5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgdGV4dCgpOiBzdHJpbmcge1xyXG5cdFx0aWYgKHRoaXMuX2xhYmVsICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIFwiPFwiICsgdGhpcy5fbGFiZWwgKyBcIjpcIiArIHRoaXMuX3J1bGVOYW1lICsgXCI+XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFwiPFwiICsgdGhpcy5fcnVsZU5hbWUgKyBcIj5cIjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFJ1bGUgdGFnIHRva2VucyBoYXZlIHR5cGVzIGFzc2lnbmVkIGFjY29yZGluZyB0byB0aGUgcnVsZSBieXBhc3NcclxuXHQgKiB0cmFuc2l0aW9ucyBjcmVhdGVkIGR1cmluZyBBVE4gZGVzZXJpYWxpemF0aW9uLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCB0eXBlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5ieXBhc3NUb2tlblR5cGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBSdWxlVGFnVG9rZW59IGFsd2F5cyByZXR1cm5zIDAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGxpbmUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiAwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGltcGxlbWVudGF0aW9uIGZvciB7QGxpbmsgUnVsZVRhZ1Rva2VufSBhbHdheXMgcmV0dXJucyAtMS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgY2hhclBvc2l0aW9uSW5MaW5lKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBSdWxlVGFnVG9rZW59IGFsd2F5cyByZXR1cm5zIC0xLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCB0b2tlbkluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBSdWxlVGFnVG9rZW59IGFsd2F5cyByZXR1cm5zIC0xLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdGFydEluZGV4KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBSdWxlVGFnVG9rZW59IGFsd2F5cyByZXR1cm5zIC0xLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBzdG9wSW5kZXgoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoZSBpbXBsZW1lbnRhdGlvbiBmb3Ige0BsaW5rIFJ1bGVUYWdUb2tlbn0gYWx3YXlzIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHRva2VuU291cmNlKCk6IFRva2VuU291cmNlIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBSdWxlVGFnVG9rZW59IGFsd2F5cyByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBpbnB1dFN0cmVhbSgpOiBDaGFyU3RyZWFtIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBSdWxlVGFnVG9rZW59IHJldHVybnMgYSBzdHJpbmcgb2YgdGhlIGZvcm1cclxuXHQgKiBgcnVsZU5hbWU6YnlwYXNzVG9rZW5UeXBlYC5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLl9ydWxlTmFtZSArIFwiOlwiICsgdGhpcy5ieXBhc3NUb2tlblR5cGU7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0NS4yNzk5MDYwLTA3OjAwXHJcblxyXG4vKipcclxuICogQSBjaHVuayBpcyBlaXRoZXIgYSB0b2tlbiB0YWcsIGEgcnVsZSB0YWcsIG9yIGEgc3BhbiBvZiBsaXRlcmFsIHRleHQgd2l0aGluIGFcclxuICogdHJlZSBwYXR0ZXJuLlxyXG4gKlxyXG4gKiBUaGUgbWV0aG9kIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlciNzcGxpdChTdHJpbmcpfSByZXR1cm5zIGEgbGlzdCBvZlxyXG4gKiBjaHVua3MgaW4gcHJlcGFyYXRpb24gZm9yIGNyZWF0aW5nIGEgdG9rZW4gc3RyZWFtIGJ5XHJcbiAqIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlciN0b2tlbml6ZShTdHJpbmcpfS4gRnJvbSB0aGVyZSwgd2UgZ2V0IGEgcGFyc2VcclxuICogdHJlZSBmcm9tIHdpdGgge0BsaW5rIFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyI2NvbXBpbGUoU3RyaW5nLCBpbnQpfS4gVGhlc2VcclxuICogY2h1bmtzIGFyZSBjb252ZXJ0ZWQgdG8ge0BsaW5rIFJ1bGVUYWdUb2tlbn0sIHtAbGluayBUb2tlblRhZ1Rva2VufSwgb3IgdGhlXHJcbiAqIHJlZ3VsYXIgdG9rZW5zIG9mIHRoZSB0ZXh0IHN1cnJvdW5kaW5nIHRoZSB0YWdzLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENodW5rIHtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NDYuMTY3MDY2OS0wNzowMFxyXG5cclxuaW1wb3J0IHsgQ2h1bmsgfSBmcm9tIFwiLi9DaHVua1wiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHBsYWNlaG9sZGVyIHRhZyBpbiBhIHRyZWUgcGF0dGVybi4gQSB0YWcgY2FuIGhhdmUgYW55IG9mIHRoZVxyXG4gKiBmb2xsb3dpbmcgZm9ybXMuXHJcbiAqXHJcbiAqICogYGV4cHJgOiBBbiB1bmxhYmVsZWQgcGxhY2Vob2xkZXIgZm9yIGEgcGFyc2VyIHJ1bGUgYGV4cHJgLlxyXG4gKiAqIGBJRGA6IEFuIHVubGFiZWxlZCBwbGFjZWhvbGRlciBmb3IgYSB0b2tlbiBvZiB0eXBlIGBJRGAuXHJcbiAqICogYGU6ZXhwcmA6IEEgbGFiZWxlZCBwbGFjZWhvbGRlciBmb3IgYSBwYXJzZXIgcnVsZSBgZXhwcmAuXHJcbiAqICogYGlkOklEYDogQSBsYWJlbGVkIHBsYWNlaG9sZGVyIGZvciBhIHRva2VuIG9mIHR5cGUgYElEYC5cclxuICpcclxuICogVGhpcyBjbGFzcyBkb2VzIG5vdCBwZXJmb3JtIGFueSB2YWxpZGF0aW9uIG9uIHRoZSB0YWcgb3IgbGFiZWwgbmFtZXMgYXNpZGVcclxuICogZnJvbSBlbnN1cmluZyB0aGF0IHRoZSB0YWcgaXMgYSBkZWZpbmVkLCBub24tZW1wdHkgc3RyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRhZ0NodW5rIGV4dGVuZHMgQ2h1bmsge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGB0YWdgLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX3RhZzogc3RyaW5nO1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBsYWJlbGAuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfbGFiZWw/OiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdCBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVGFnQ2h1bmt9IHVzaW5nIHRoZSBzcGVjaWZpZWQgbGFiZWxcclxuXHQgKiBhbmQgdGFnLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCBmb3IgdGhlIHRhZy4gSWYgdGhpcyBpcyBgdW5kZWZpbmVkYCwgdGhlXHJcblx0ICoge0BsaW5rIFRhZ0NodW5rfSByZXByZXNlbnRzIGFuIHVubGFiZWxlZCB0YWcuXHJcblx0ICogQHBhcmFtIHRhZyBUaGUgdGFnLCB3aGljaCBzaG91bGQgYmUgdGhlIG5hbWUgb2YgYSBwYXJzZXIgcnVsZSBvciB0b2tlblxyXG5cdCAqIHR5cGUuXHJcblx0ICpcclxuXHQgKiBAZXhjZXB0aW9uIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBgdGFnYCBpcyBub3QgZGVmaW5lZCBvclxyXG5cdCAqIGVtcHR5LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHRhZzogc3RyaW5nLCBsYWJlbD86IHN0cmluZykge1xyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHRpZiAodGFnID09IG51bGwgfHwgdGFnLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0YWcgY2Fubm90IGJlIG51bGwgb3IgZW1wdHlcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdGFnID0gdGFnO1xyXG5cdFx0dGhpcy5fbGFiZWwgPSBsYWJlbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdGFnIGZvciB0aGlzIGNodW5rLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIHRhZyBmb3IgdGhlIGNodW5rLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IHRhZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3RhZztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbGFiZWwsIGlmIGFueSwgYXNzaWduZWQgdG8gdGhpcyBjaHVuay5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBsYWJlbCBhc3NpZ25lZCB0byB0aGlzIGNodW5rLCBvciBgdW5kZWZpbmVkYCBpZiBubyBsYWJlbCBpc1xyXG5cdCAqIGFzc2lnbmVkIHRvIHRoZSBjaHVuay5cclxuXHQgKi9cclxuXHRnZXQgbGFiZWwoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYWJlbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0YWcgY2h1bmsuIExhYmVsZWQgdGFnc1xyXG5cdCAqIGFyZSByZXR1cm5lZCBpbiB0aGUgZm9ybSBgbGFiZWw6dGFnYCwgYW5kIHVubGFiZWxlZCB0YWdzIGFyZVxyXG5cdCAqIHJldHVybmVkIGFzIGp1c3QgdGhlIHRhZyBuYW1lLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0aWYgKHRoaXMuX2xhYmVsICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2xhYmVsICsgXCI6XCIgKyB0aGlzLl90YWc7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3RhZztcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ2LjI1MjE0NDgtMDc6MDBcclxuXHJcbmltcG9ydCB7IENodW5rIH0gZnJvbSBcIi4vQ2h1bmtcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vLi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBzcGFuIG9mIHJhdyB0ZXh0IChjb25jcmV0ZSBzeW50YXgpIGJldHdlZW4gdGFncyBpbiBhIHRyZWVcclxuICogcGF0dGVybiBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGV4dENodW5rIGV4dGVuZHMgQ2h1bmsge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIHtAbGluayAjZ2V0VGV4dH0uXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIF90ZXh0OiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFRleHRDaHVua30gd2l0aCB0aGUgc3BlY2lmaWVkIHRleHQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCBvZiB0aGlzIGNodW5rLlxyXG5cdCAqIEBleGNlcHRpb24gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIGB0ZXh0YCBpcyBub3QgZGVmaW5lZC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihATm90TnVsbCB0ZXh0OiBzdHJpbmcpIHtcclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0aWYgKHRleHQgPT0gbnVsbCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0ZXh0IGNhbm5vdCBiZSBudWxsXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3RleHQgPSB0ZXh0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgcmF3IHRleHQgb2YgdGhpcyBjaHVuay5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSB0ZXh0IG9mIHRoZSBjaHVuay5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCB0ZXh0KCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdGV4dDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoZSBpbXBsZW1lbnRhdGlvbiBmb3Ige0BsaW5rIFRleHRDaHVua30gcmV0dXJucyB0aGUgcmVzdWx0IG9mXHJcblx0ICogYHRleHRgIGluIHNpbmdsZSBxdW90ZXMuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCInXCIgKyB0aGlzLl90ZXh0ICsgXCInXCI7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0Ni4zMjgxOTg4LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBDb21tb25Ub2tlbiB9IGZyb20gXCIuLi8uLi9Db21tb25Ub2tlblwiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcblxyXG4vKipcclxuICogQSB7QGxpbmsgVG9rZW59IG9iamVjdCByZXByZXNlbnRpbmcgYSB0b2tlbiBvZiBhIHBhcnRpY3VsYXIgdHlwZTsgZS5nLixcclxuICogYDxJRD5gLiBUaGVzZSB0b2tlbnMgYXJlIGNyZWF0ZWQgZm9yIHtAbGluayBUYWdDaHVua30gY2h1bmtzIHdoZXJlIHRoZVxyXG4gKiB0YWcgY29ycmVzcG9uZHMgdG8gYSBsZXhlciBydWxlIG9yIHRva2VuIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVG9rZW5UYWdUb2tlbiBleHRlbmRzIENvbW1vblRva2VuIHtcclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciBgdG9rZW5OYW1lYC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgX3Rva2VuTmFtZTogc3RyaW5nO1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBsYWJlbGAuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfbGFiZWw6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVG9rZW5UYWdUb2tlbn0gd2l0aCB0aGUgc3BlY2lmaWVkXHJcblx0ICogdG9rZW4gbmFtZSwgdHlwZSwgYW5kIGxhYmVsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHRva2VuTmFtZSBUaGUgdG9rZW4gbmFtZS5cclxuXHQgKiBAcGFyYW0gdHlwZSBUaGUgdG9rZW4gdHlwZS5cclxuXHQgKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9rZW4gdGFnLCBvciBgdW5kZWZpbmVkYCBpZlxyXG5cdCAqIHRoZSB0b2tlbiB0YWcgaXMgdW5sYWJlbGVkLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKEBOb3ROdWxsIHRva2VuTmFtZTogc3RyaW5nLCB0eXBlOiBudW1iZXIsIGxhYmVsPzogc3RyaW5nKSB7XHJcblx0XHRzdXBlcih0eXBlKTtcclxuXHRcdHRoaXMuX3Rva2VuTmFtZSA9IHRva2VuTmFtZTtcclxuXHRcdHRoaXMuX2xhYmVsID0gbGFiZWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB0b2tlbiBuYW1lLlxyXG5cdCAqIEByZXR1cm5zIFRoZSB0b2tlbiBuYW1lLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IHRva2VuTmFtZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3Rva2VuTmFtZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGxhYmVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgcnVsZSB0YWcuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgbGFiZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBydWxlIHRhZywgb3JcclxuXHQgKiBgdW5kZWZpbmVkYCBpZiB0aGlzIGlzIGFuIHVubGFiZWxlZCBydWxlIHRhZy5cclxuXHQgKi9cclxuXHRnZXQgbGFiZWwoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYWJlbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoZSBpbXBsZW1lbnRhdGlvbiBmb3Ige0BsaW5rIFRva2VuVGFnVG9rZW59IHJldHVybnMgdGhlIHRva2VuIHRhZ1xyXG5cdCAqIGZvcm1hdHRlZCB3aXRoIGA8YCBhbmQgYD5gIGRlbGltaXRlcnMuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHRleHQoKTogc3RyaW5nIHtcclxuXHRcdGlmICh0aGlzLl9sYWJlbCAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBcIjxcIiArIHRoaXMuX2xhYmVsICsgXCI6XCIgKyB0aGlzLl90b2tlbk5hbWUgKyBcIj5cIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gXCI8XCIgKyB0aGlzLl90b2tlbk5hbWUgKyBcIj5cIjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoZSBpbXBsZW1lbnRhdGlvbiBmb3Ige0BsaW5rIFRva2VuVGFnVG9rZW59IHJldHVybnMgYSBzdHJpbmcgb2YgdGhlIGZvcm1cclxuXHQgKiBgdG9rZW5OYW1lOnR5cGVgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3Rva2VuTmFtZSArIFwiOlwiICsgdGhpcy50eXBlO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDT05WRVJTVElPTiBjb21wbGV0ZSwgQnVydCBIYXJyaXMgMTAvMTQvMjAxNlxyXG5cclxuaW1wb3J0IHsgQmFpbEVycm9yU3RyYXRlZ3kgfSBmcm9tIFwiLi4vLi4vQmFpbEVycm9yU3RyYXRlZ3lcIjtcclxuaW1wb3J0IHsgQ2hhclN0cmVhbXMgfSBmcm9tIFwiLi4vLi4vQ2hhclN0cmVhbXNcIjtcclxuaW1wb3J0IHsgQ2h1bmsgfSBmcm9tIFwiLi9DaHVua1wiO1xyXG5pbXBvcnQgeyBDb21tb25Ub2tlblN0cmVhbSB9IGZyb20gXCIuLi8uLi9Db21tb25Ub2tlblN0cmVhbVwiO1xyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi8uLi9MZXhlclwiO1xyXG5pbXBvcnQgeyBMaXN0VG9rZW5Tb3VyY2UgfSBmcm9tIFwiLi4vLi4vTGlzdFRva2VuU291cmNlXCI7XHJcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSBcIi4uLy4uL21pc2MvTXVsdGlNYXBcIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuLi8uLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL21pc2MvUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4uLy4uL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJJbnRlcnByZXRlciB9IGZyb20gXCIuLi8uLi9QYXJzZXJJbnRlcnByZXRlclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuLi8uLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWUgfSBmcm9tIFwiLi4vUGFyc2VUcmVlXCI7XHJcbmltcG9ydCB7IFBhcnNlVHJlZU1hdGNoIH0gZnJvbSBcIi4vUGFyc2VUcmVlTWF0Y2hcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlUGF0dGVybiB9IGZyb20gXCIuL1BhcnNlVHJlZVBhdHRlcm5cIjtcclxuaW1wb3J0IHsgUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi4vLi4vUmVjb2duaXRpb25FeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgUnVsZU5vZGUgfSBmcm9tIFwiLi4vUnVsZU5vZGVcIjtcclxuaW1wb3J0IHsgUnVsZVRhZ1Rva2VuIH0gZnJvbSBcIi4vUnVsZVRhZ1Rva2VuXCI7XHJcbmltcG9ydCB7IFRhZ0NodW5rIH0gZnJvbSBcIi4vVGFnQ2h1bmtcIjtcclxuaW1wb3J0IHsgVGVybWluYWxOb2RlIH0gZnJvbSBcIi4uL1Rlcm1pbmFsTm9kZVwiO1xyXG5pbXBvcnQgeyBUZXh0Q2h1bmsgfSBmcm9tIFwiLi9UZXh0Q2h1bmtcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi4vLi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5UYWdUb2tlbiB9IGZyb20gXCIuL1Rva2VuVGFnVG9rZW5cIjtcclxuXHJcbi8qKlxyXG4gKiBBIHRyZWUgcGF0dGVybiBtYXRjaGluZyBtZWNoYW5pc20gZm9yIEFOVExSIHtAbGluayBQYXJzZVRyZWV9cy5cclxuICpcclxuICogUGF0dGVybnMgYXJlIHN0cmluZ3Mgb2Ygc291cmNlIGlucHV0IHRleHQgd2l0aCBzcGVjaWFsIHRhZ3MgcmVwcmVzZW50aW5nXHJcbiAqIHRva2VuIG9yIHJ1bGUgcmVmZXJlbmNlcyBzdWNoIGFzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPElEPiA9IDxleHByPjtcclxuICogYGBgXHJcbiAqXHJcbiAqIEdpdmVuIGEgcGF0dGVybiBzdGFydCBydWxlIHN1Y2ggYXMgYHN0YXRlbWVudGAsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdHNcclxuICogYSB7QGxpbmsgUGFyc2VUcmVlfSB3aXRoIHBsYWNlaG9sZGVycyBmb3IgdGhlIGBJRGAgYW5kIGBleHByYFxyXG4gKiBzdWJ0cmVlLiBUaGVuIHRoZSB7QGxpbmsgI21hdGNofSByb3V0aW5lcyBjYW4gY29tcGFyZSBhbiBhY3R1YWxcclxuICoge0BsaW5rIFBhcnNlVHJlZX0gZnJvbSBhIHBhcnNlIHdpdGggdGhpcyBwYXR0ZXJuLiBUYWcgYDxJRD5gIG1hdGNoZXNcclxuICogYW55IGBJRGAgdG9rZW4gYW5kIHRhZyBgPGV4cHI+YCByZWZlcmVuY2VzIHRoZSByZXN1bHQgb2YgdGhlXHJcbiAqIGBleHByYCBydWxlIChnZW5lcmFsbHkgYW4gaW5zdGFuY2Ugb2YgYEV4cHJDb250ZXh0YC5cclxuICpcclxuICogUGF0dGVybiBgeCA9IDA7YCBpcyBhIHNpbWlsYXIgcGF0dGVybiB0aGF0IG1hdGNoZXMgdGhlIHNhbWUgcGF0dGVyblxyXG4gKiBleGNlcHQgdGhhdCBpdCByZXF1aXJlcyB0aGUgaWRlbnRpZmllciB0byBiZSBgeGAgYW5kIHRoZSBleHByZXNzaW9uIHRvXHJcbiAqIGJlIGAwYC5cclxuICpcclxuICogVGhlIHtAbGluayAjbWF0Y2hlc30gcm91dGluZXMgcmV0dXJuIGB0cnVlYCBvciBgZmFsc2VgIGJhc2VkXHJcbiAqIHVwb24gYSBtYXRjaCBmb3IgdGhlIHRyZWUgcm9vdGVkIGF0IHRoZSBwYXJhbWV0ZXIgc2VudCBpbi4gVGhlXHJcbiAqIHtAbGluayAjbWF0Y2h9IHJvdXRpbmVzIHJldHVybiBhIHtAbGluayBQYXJzZVRyZWVNYXRjaH0gb2JqZWN0IHRoYXRcclxuICogY29udGFpbnMgdGhlIHBhcnNlIHRyZWUsIHRoZSBwYXJzZSB0cmVlIHBhdHRlcm4sIGFuZCBhIG1hcCBmcm9tIHRhZyBuYW1lIHRvXHJcbiAqIG1hdGNoZWQgbm9kZXMgKG1vcmUgYmVsb3cpLiBBIHN1YnRyZWUgdGhhdCBmYWlscyB0byBtYXRjaCwgcmV0dXJucyB3aXRoXHJcbiAqIHtAbGluayBQYXJzZVRyZWVNYXRjaCNtaXNtYXRjaGVkTm9kZX0gc2V0IHRvIHRoZSBmaXJzdCB0cmVlIG5vZGUgdGhhdCBkaWQgbm90XHJcbiAqIG1hdGNoLlxyXG4gKlxyXG4gKiBGb3IgZWZmaWNpZW5jeSwgeW91IGNhbiBjb21waWxlIGEgdHJlZSBwYXR0ZXJuIGluIHN0cmluZyBmb3JtIHRvIGFcclxuICoge0BsaW5rIFBhcnNlVHJlZVBhdHRlcm59IG9iamVjdC5cclxuICpcclxuICogU2VlIGBUZXN0UGFyc2VUcmVlTWF0Y2hlcmAgZm9yIGxvdHMgb2YgZXhhbXBsZXMuXHJcbiAqIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJufSBoYXMgdHdvIHN0YXRpYyBoZWxwZXIgbWV0aG9kczpcclxuICoge0BsaW5rIFBhcnNlVHJlZVBhdHRlcm4jZmluZEFsbH0gYW5kIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJuI21hdGNofSB0aGF0XHJcbiAqIGFyZSBlYXN5IHRvIHVzZSBidXQgbm90IHN1cGVyIGVmZmljaWVudCBiZWNhdXNlIHRoZXkgY3JlYXRlIG5ld1xyXG4gKiB7QGxpbmsgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXJ9IG9iamVjdHMgZWFjaCB0aW1lIGFuZCBoYXZlIHRvIGNvbXBpbGUgdGhlXHJcbiAqIHBhdHRlcm4gaW4gc3RyaW5nIGZvcm0gYmVmb3JlIHVzaW5nIGl0LlxyXG4gKlxyXG4gKiBUaGUgbGV4ZXIgYW5kIHBhcnNlciB0aGF0IHlvdSBwYXNzIGludG8gdGhlIHtAbGluayBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcn1cclxuICogY29uc3RydWN0b3IgYXJlIHVzZWQgdG8gcGFyc2UgdGhlIHBhdHRlcm4gaW4gc3RyaW5nIGZvcm0uIFRoZSBsZXhlciBjb252ZXJ0c1xyXG4gKiB0aGUgYDxJRD4gPSA8ZXhwcj47YCBpbnRvIGEgc2VxdWVuY2Ugb2YgZm91ciB0b2tlbnMgKGFzc3VtaW5nIGxleGVyXHJcbiAqIHRocm93cyBvdXQgd2hpdGVzcGFjZSBvciBwdXRzIGl0IG9uIGEgaGlkZGVuIGNoYW5uZWwpLiBCZSBhd2FyZSB0aGF0IHRoZVxyXG4gKiBpbnB1dCBzdHJlYW0gaXMgcmVzZXQgZm9yIHRoZSBsZXhlciAoYnV0IG5vdCB0aGUgcGFyc2VyOyBhXHJcbiAqIHtAbGluayBQYXJzZXJJbnRlcnByZXRlcn0gaXMgY3JlYXRlZCB0byBwYXJzZSB0aGUgaW5wdXQuKS4gQW55IHVzZXItZGVmaW5lZFxyXG4gKiBmaWVsZHMgeW91IGhhdmUgcHV0IGludG8gdGhlIGxleGVyIG1pZ2h0IGdldCBjaGFuZ2VkIHdoZW4gdGhpcyBtZWNoYW5pc20gYXNrc1xyXG4gKiBpdCB0byBzY2FuIHRoZSBwYXR0ZXJuIHN0cmluZy5cclxuICpcclxuICogTm9ybWFsbHkgYSBwYXJzZXIgZG9lcyBub3QgYWNjZXB0IHRva2VuIGA8ZXhwcj5gIGFzIGEgdmFsaWRcclxuICogYGV4cHJgIGJ1dCwgZnJvbSB0aGUgcGFyc2VyIHBhc3NlZCBpbiwgd2UgY3JlYXRlIGEgc3BlY2lhbCB2ZXJzaW9uIG9mXHJcbiAqIHRoZSB1bmRlcmx5aW5nIGdyYW1tYXIgcmVwcmVzZW50YXRpb24gKGFuIHtAbGluayBBVE59KSB0aGF0IGFsbG93cyBpbWFnaW5hcnlcclxuICogdG9rZW5zIHJlcHJlc2VudGluZyBydWxlcyAoYDxleHByPmApIHRvIG1hdGNoIGVudGlyZSBydWxlcy4gV2UgY2FsbFxyXG4gKiB0aGVzZSAqYnlwYXNzIGFsdGVybmF0aXZlcyouXHJcbiAqXHJcbiAqIERlbGltaXRlcnMgYXJlIGA8YH0gYW5kIGA+YH0sIHdpdGggYFxcYCBhcyB0aGUgZXNjYXBlIHN0cmluZ1xyXG4gKiBieSBkZWZhdWx0LCBidXQgeW91IGNhbiBzZXQgdGhlbSB0byB3aGF0ZXZlciB5b3Ugd2FudCB1c2luZ1xyXG4gKiB7QGxpbmsgI3NldERlbGltaXRlcnN9LiBZb3UgbXVzdCBlc2NhcGUgYm90aCBzdGFydCBhbmQgc3RvcCBzdHJpbmdzXHJcbiAqIGBcXDxgIGFuZCBgXFw+YC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlciB7XHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3IgYGxleGVyYC5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9sZXhlcjogTGV4ZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGJhY2tpbmcgZmllbGQgZm9yIGBwYXJzZXJgLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX3BhcnNlcjogUGFyc2VyO1xyXG5cclxuXHRwcm90ZWN0ZWQgc3RhcnQgPSBcIjxcIjtcclxuXHRwcm90ZWN0ZWQgc3RvcCA9IFwiPlwiO1xyXG5cdHByb3RlY3RlZCBlc2NhcGUgPSBcIlxcXFxcIjsgLy8gZS5nLiwgXFw8IGFuZCBcXD4gbXVzdCBlc2NhcGUgQk9USCFcclxuXHJcblx0LyoqXHJcblx0ICogUmVndWxhciBleHByZXNzaW9uIGNvcnJlc3BvbmRpbmcgdG8gZXNjYXBlLCBmb3IgZ2xvYmFsIHJlcGxhY2VcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgZXNjYXBlUkUgPSAvXFxcXC9nO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyfSBvciBmcm9tIGEge0BsaW5rIExleGVyfSBhbmRcclxuXHQgKiB7QGxpbmsgUGFyc2VyfSBvYmplY3QuIFRoZSBsZXhlciBpbnB1dCBzdHJlYW0gaXMgYWx0ZXJlZCBmb3IgdG9rZW5pemluZ1xyXG5cdCAqIHRoZSB0cmVlIHBhdHRlcm5zLiBUaGUgcGFyc2VyIGlzIHVzZWQgYXMgYSBjb252ZW5pZW50IG1lY2hhbmlzbSB0byBnZXRcclxuXHQgKiB0aGUgZ3JhbW1hciBuYW1lLCBwbHVzIHRva2VuLCBydWxlIG5hbWVzLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGxleGVyOiBMZXhlciwgcGFyc2VyOiBQYXJzZXIpIHtcclxuXHRcdHRoaXMuX2xleGVyID0gbGV4ZXI7XHJcblx0XHR0aGlzLl9wYXJzZXIgPSBwYXJzZXI7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIGRlbGltaXRlcnMgdXNlZCBmb3IgbWFya2luZyBydWxlIGFuZCB0b2tlbiB0YWdzIHdpdGhpbiBjb25jcmV0ZVxyXG5cdCAqIHN5bnRheCB1c2VkIGJ5IHRoZSB0cmVlIHBhdHRlcm4gcGFyc2VyLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHN0YXJ0IFRoZSBzdGFydCBkZWxpbWl0ZXIuXHJcblx0ICogQHBhcmFtIHN0b3AgVGhlIHN0b3AgZGVsaW1pdGVyLlxyXG5cdCAqIEBwYXJhbSBlc2NhcGVMZWZ0IFRoZSBlc2NhcGUgc2VxdWVuY2UgdG8gdXNlIGZvciBlc2NhcGluZyBhIHN0YXJ0IG9yIHN0b3AgZGVsaW1pdGVyLlxyXG5cdCAqXHJcblx0ICogQHRocm93cyB7QGxpbmsgRXJyb3J9IGlmIGBzdGFydGAgaXMgbm90IGRlZmluZWQgb3IgZW1wdHkuXHJcblx0ICogQHRocm93cyB7QGxpbmsgRXJyb3J9IGlmIGBzdG9wYCBpcyBub3QgZGVmaW5lZCBvciBlbXB0eS5cclxuXHQgKi9cclxuXHRwdWJsaWMgc2V0RGVsaW1pdGVycyhzdGFydDogc3RyaW5nLCBzdG9wOiBzdHJpbmcsIGVzY2FwZUxlZnQ6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0aWYgKCFzdGFydCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCBjYW5ub3QgYmUgbnVsbCBvciBlbXB0eVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN0b3ApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic3RvcCBjYW5ub3QgYmUgbnVsbCBvciBlbXB0eVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcblx0XHR0aGlzLnN0b3AgPSBzdG9wO1xyXG5cdFx0dGhpcy5lc2NhcGUgPSBlc2NhcGVMZWZ0O1xyXG5cdFx0dGhpcy5lc2NhcGVSRSA9IG5ldyBSZWdFeHAoZXNjYXBlTGVmdC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIiksIFwiZ1wiKTtcclxuXHR9XHJcblxyXG5cdC8qKiBEb2VzIGBwYXR0ZXJuYCBtYXRjaGVkIGFzIHJ1bGUgYHBhdHRlcm5SdWxlSW5kZXhgIG1hdGNoIGB0cmVlYD8gKi9cclxuXHRwdWJsaWMgbWF0Y2hlcyh0cmVlOiBQYXJzZVRyZWUsIHBhdHRlcm46IHN0cmluZywgcGF0dGVyblJ1bGVJbmRleDogbnVtYmVyKTogYm9vbGVhbjtcclxuXHJcblx0LyoqIERvZXMgYHBhdHRlcm5gIG1hdGNoZWQgYXMgcnVsZSBwYXR0ZXJuUnVsZUluZGV4IG1hdGNoIHRyZWU/IFBhc3MgaW4gYVxyXG5cdCAqICBjb21waWxlZCBwYXR0ZXJuIGluc3RlYWQgb2YgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB0cmVlIHBhdHRlcm4uXHJcblx0ICovXHJcblx0cHVibGljIG1hdGNoZXModHJlZTogUGFyc2VUcmVlLCBwYXR0ZXJuOiBQYXJzZVRyZWVQYXR0ZXJuKTogYm9vbGVhbjtcclxuXHJcblx0cHVibGljIG1hdGNoZXModHJlZTogUGFyc2VUcmVlLCBwYXR0ZXJuOiBzdHJpbmcgfCBQYXJzZVRyZWVQYXR0ZXJuLCBwYXR0ZXJuUnVsZUluZGV4OiBudW1iZXIgPSAwKTogYm9vbGVhbiB7XHJcblx0XHRpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0bGV0IHA6IFBhcnNlVHJlZVBhdHRlcm4gPSB0aGlzLmNvbXBpbGUocGF0dGVybiwgcGF0dGVyblJ1bGVJbmRleCk7XHJcblx0XHRcdHJldHVybiB0aGlzLm1hdGNoZXModHJlZSwgcCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgbGFiZWxzID0gbmV3IE11bHRpTWFwPHN0cmluZywgUGFyc2VUcmVlPigpO1xyXG5cdFx0XHRsZXQgbWlzbWF0Y2hlZE5vZGUgPSB0aGlzLm1hdGNoSW1wbCh0cmVlLCBwYXR0ZXJuLnBhdHRlcm5UcmVlLCBsYWJlbHMpO1xyXG5cdFx0XHRyZXR1cm4gIW1pc21hdGNoZWROb2RlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29tcGFyZSBgcGF0dGVybmAgbWF0Y2hlZCBhcyBydWxlIGBwYXR0ZXJuUnVsZUluZGV4YCBhZ2FpbnN0XHJcblx0ICogYHRyZWVgIGFuZCByZXR1cm4gYSB7QGxpbmsgUGFyc2VUcmVlTWF0Y2h9IG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxyXG5cdCAqIG1hdGNoZWQgZWxlbWVudHMsIG9yIHRoZSBub2RlIGF0IHdoaWNoIHRoZSBtYXRjaCBmYWlsZWQuXHJcblx0ICovXHJcblx0cHVibGljIG1hdGNoKHRyZWU6IFBhcnNlVHJlZSwgcGF0dGVybjogc3RyaW5nLCBwYXR0ZXJuUnVsZUluZGV4OiBudW1iZXIpOiBQYXJzZVRyZWVNYXRjaDtcclxuXHJcblx0LyoqXHJcblx0ICogQ29tcGFyZSBgcGF0dGVybmAgbWF0Y2hlZCBhZ2FpbnN0IGB0cmVlYCBhbmQgcmV0dXJuIGFcclxuXHQgKiB7QGxpbmsgUGFyc2VUcmVlTWF0Y2h9IG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBtYXRjaGVkIGVsZW1lbnRzLCBvciB0aGVcclxuXHQgKiBub2RlIGF0IHdoaWNoIHRoZSBtYXRjaCBmYWlsZWQuIFBhc3MgaW4gYSBjb21waWxlZCBwYXR0ZXJuIGluc3RlYWQgb2YgYVxyXG5cdCAqIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHRyZWUgcGF0dGVybi5cclxuXHQgKi9cclxuXHRwdWJsaWMgbWF0Y2godHJlZTogUGFyc2VUcmVlLCBwYXR0ZXJuOiBQYXJzZVRyZWVQYXR0ZXJuKTogUGFyc2VUcmVlTWF0Y2g7XHJcblxyXG5cdC8vIEltcGxlbWVudGF0aW9uIG9mIG1hdGNoXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgbWF0Y2godHJlZTogUGFyc2VUcmVlLCBATm90TnVsbCBwYXR0ZXJuOiBzdHJpbmcgfCBQYXJzZVRyZWVQYXR0ZXJuLCBwYXR0ZXJuUnVsZUluZGV4OiBudW1iZXIgPSAwKTogUGFyc2VUcmVlTWF0Y2gge1xyXG5cdFx0aWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdGxldCBwOiBQYXJzZVRyZWVQYXR0ZXJuID0gdGhpcy5jb21waWxlKHBhdHRlcm4sIHBhdHRlcm5SdWxlSW5kZXgpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tYXRjaCh0cmVlLCBwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBsYWJlbHMgPSBuZXcgTXVsdGlNYXA8c3RyaW5nLCBQYXJzZVRyZWU+KCk7XHJcblx0XHRcdGxldCBtaXNtYXRjaGVkTm9kZSA9IHRoaXMubWF0Y2hJbXBsKHRyZWUsIHBhdHRlcm4ucGF0dGVyblRyZWUsIGxhYmVscyk7XHJcblx0XHRcdHJldHVybiBuZXcgUGFyc2VUcmVlTWF0Y2godHJlZSwgcGF0dGVybiwgbGFiZWxzLCBtaXNtYXRjaGVkTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBGb3IgcmVwZWF0ZWQgdXNlIG9mIGEgdHJlZSBwYXR0ZXJuLCBjb21waWxlIGl0IHRvIGFcclxuXHQgKiB7QGxpbmsgUGFyc2VUcmVlUGF0dGVybn0gdXNpbmcgdGhpcyBtZXRob2QuXHJcblx0ICovXHJcblx0cHVibGljIGNvbXBpbGUocGF0dGVybjogc3RyaW5nLCBwYXR0ZXJuUnVsZUluZGV4OiBudW1iZXIpOiBQYXJzZVRyZWVQYXR0ZXJuIHtcclxuXHRcdGxldCB0b2tlbkxpc3QgPSB0aGlzLnRva2VuaXplKHBhdHRlcm4pO1xyXG5cdFx0bGV0IHRva2VuU3JjID0gbmV3IExpc3RUb2tlblNvdXJjZSh0b2tlbkxpc3QpO1xyXG5cdFx0bGV0IHRva2VucyA9IG5ldyBDb21tb25Ub2tlblN0cmVhbSh0b2tlblNyYyk7XHJcblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzLl9wYXJzZXI7XHJcblxyXG5cdFx0bGV0IHBhcnNlckludGVycCA9IG5ldyBQYXJzZXJJbnRlcnByZXRlcihcclxuXHRcdFx0cGFyc2VyLmdyYW1tYXJGaWxlTmFtZSxcclxuXHRcdFx0cGFyc2VyLnZvY2FidWxhcnksXHJcblx0XHRcdHBhcnNlci5ydWxlTmFtZXMsXHJcblx0XHRcdHBhcnNlci5nZXRBVE5XaXRoQnlwYXNzQWx0cygpLFxyXG5cdFx0XHR0b2tlbnMpO1xyXG5cclxuXHRcdGxldCB0cmVlOiBQYXJzZVRyZWU7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRwYXJzZXJJbnRlcnAuZXJyb3JIYW5kbGVyID0gbmV3IEJhaWxFcnJvclN0cmF0ZWd5KCk7XHJcblx0XHRcdHRyZWUgPSBwYXJzZXJJbnRlcnAucGFyc2UocGF0dGVyblJ1bGVJbmRleCk7XHJcbi8vXHRcdFx0U3lzdGVtLm91dC5wcmludGxuKFwicGF0dGVybiB0cmVlID0gXCIrdHJlZS50b1N0cmluZ1RyZWUocGFyc2VySW50ZXJwKSk7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdGlmIChlIGluc3RhbmNlb2YgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24pIHtcclxuXHRcdFx0XHR0aHJvdyBlLmdldENhdXNlKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIFJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0XHRcdFx0dGhyb3cgZTtcclxuXHRcdFx0fSBlbHNlIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIuQ2Fubm90SW52b2tlU3RhcnRSdWxlKGUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IGU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBNYWtlIHN1cmUgdHJlZSBwYXR0ZXJuIGNvbXBpbGF0aW9uIGNoZWNrcyBmb3IgYSBjb21wbGV0ZSBwYXJzZVxyXG5cdFx0aWYgKHRva2Vucy5MQSgxKSAhPT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdHRocm93IG5ldyBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlci5TdGFydFJ1bGVEb2VzTm90Q29uc3VtZUZ1bGxQYXR0ZXJuKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQYXJzZVRyZWVQYXR0ZXJuKHRoaXMsIHBhdHRlcm4sIHBhdHRlcm5SdWxlSW5kZXgsIHRyZWUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXNlZCB0byBjb252ZXJ0IHRoZSB0cmVlIHBhdHRlcm4gc3RyaW5nIGludG8gYSBzZXJpZXMgb2YgdG9rZW5zLiBUaGVcclxuXHQgKiBpbnB1dCBzdHJlYW0gaXMgcmVzZXQuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRnZXQgbGV4ZXIoKTogTGV4ZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xleGVyO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXNlZCB0byBjb2xsZWN0IHRvIHRoZSBncmFtbWFyIGZpbGUgbmFtZSwgdG9rZW4gbmFtZXMsIHJ1bGUgbmFtZXMgZm9yXHJcblx0ICogdXNlZCB0byBwYXJzZSB0aGUgcGF0dGVybiBpbnRvIGEgcGFyc2UgdHJlZS5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBwYXJzZXIoKTogUGFyc2VyIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYXJzZXI7XHJcblx0fVxyXG5cclxuXHQvLyAtLS0tIFNVUFBPUlQgQ09ERSAtLS0tXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlY3Vyc2l2ZWx5IHdhbGsgYHRyZWVgIGFnYWluc3QgYHBhdHRlcm5UcmVlYCwgZmlsbGluZ1xyXG5cdCAqIGBtYXRjaC5ge0BsaW5rIFBhcnNlVHJlZU1hdGNoI2xhYmVscyBsYWJlbHN9LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgdGhlIGZpcnN0IG5vZGUgZW5jb3VudGVyZWQgaW4gYHRyZWVgIHdoaWNoIGRvZXMgbm90IG1hdGNoXHJcblx0ICogYSBjb3JyZXNwb25kaW5nIG5vZGUgaW4gYHBhdHRlcm5UcmVlYCwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIG1hdGNoXHJcblx0ICogd2FzIHN1Y2Nlc3NmdWwuIFRoZSBzcGVjaWZpYyBub2RlIHJldHVybmVkIGRlcGVuZHMgb24gdGhlIG1hdGNoaW5nXHJcblx0ICogYWxnb3JpdGhtIHVzZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uLCBhbmQgbWF5IGJlIG92ZXJyaWRkZW4uXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIG1hdGNoSW1wbChcclxuXHRcdEBOb3ROdWxsIHRyZWU6IFBhcnNlVHJlZSxcclxuXHRcdEBOb3ROdWxsIHBhdHRlcm5UcmVlOiBQYXJzZVRyZWUsXHJcblx0XHRATm90TnVsbCBsYWJlbHM6IE11bHRpTWFwPHN0cmluZywgUGFyc2VUcmVlPik6IFBhcnNlVHJlZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRpZiAoIXRyZWUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcInRyZWUgY2Fubm90IGJlIG51bGxcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFwYXR0ZXJuVHJlZSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwicGF0dGVyblRyZWUgY2Fubm90IGJlIG51bGxcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8geCBhbmQgPElEPiwgeCBhbmQgeSwgb3IgeCBhbmQgeDsgb3IgY291bGQgYmUgbWlzbWF0Y2hlZCB0eXBlc1xyXG5cdFx0aWYgKHRyZWUgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUgJiYgcGF0dGVyblRyZWUgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcclxuXHRcdFx0bGV0IG1pc21hdGNoZWROb2RlOiBQYXJzZVRyZWUgfCB1bmRlZmluZWQ7XHJcblx0XHRcdC8vIGJvdGggYXJlIHRva2VucyBhbmQgdGhleSBoYXZlIHNhbWUgdHlwZVxyXG5cdFx0XHRpZiAodHJlZS5zeW1ib2wudHlwZSA9PT0gcGF0dGVyblRyZWUuc3ltYm9sLnR5cGUpIHtcclxuXHRcdFx0XHRpZiAocGF0dGVyblRyZWUuc3ltYm9sIGluc3RhbmNlb2YgVG9rZW5UYWdUb2tlbikgeyAvLyB4IGFuZCA8SUQ+XHJcblx0XHRcdFx0XHRsZXQgdG9rZW5UYWdUb2tlbiA9IHBhdHRlcm5UcmVlLnN5bWJvbDtcclxuXHRcdFx0XHRcdC8vIHRyYWNrIGxhYmVsLT5saXN0LW9mLW5vZGVzIGZvciBib3RoIHRva2VuIG5hbWUgYW5kIGxhYmVsIChpZiBhbnkpXHJcblx0XHRcdFx0XHRsYWJlbHMubWFwKHRva2VuVGFnVG9rZW4udG9rZW5OYW1lLCB0cmVlKTtcclxuXHRcdFx0XHRcdGNvbnN0IGwgPSB0b2tlblRhZ1Rva2VuLmxhYmVsO1xyXG5cdFx0XHRcdFx0aWYgKGwpIHtcclxuXHRcdFx0XHRcdFx0bGFiZWxzLm1hcChsLCB0cmVlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAodHJlZS50ZXh0ID09PSBwYXR0ZXJuVHJlZS50ZXh0KSB7XHJcblx0XHRcdFx0XHQvLyB4IGFuZCB4XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8geCBhbmQgeVxyXG5cdFx0XHRcdFx0aWYgKCFtaXNtYXRjaGVkTm9kZSkge1xyXG5cdFx0XHRcdFx0XHRtaXNtYXRjaGVkTm9kZSA9IHRyZWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGlmICghbWlzbWF0Y2hlZE5vZGUpIHtcclxuXHRcdFx0XHRcdG1pc21hdGNoZWROb2RlID0gdHJlZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtaXNtYXRjaGVkTm9kZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHJlZSBpbnN0YW5jZW9mIFBhcnNlclJ1bGVDb250ZXh0XHJcblx0XHRcdCYmIHBhdHRlcm5UcmVlIGluc3RhbmNlb2YgUGFyc2VyUnVsZUNvbnRleHQpIHtcclxuXHRcdFx0bGV0IG1pc21hdGNoZWROb2RlOiBQYXJzZVRyZWUgfCB1bmRlZmluZWQ7XHJcblx0XHRcdC8vIChleHByIC4uLikgYW5kIDxleHByPlxyXG5cdFx0XHRsZXQgcnVsZVRhZ1Rva2VuID0gdGhpcy5nZXRSdWxlVGFnVG9rZW4ocGF0dGVyblRyZWUpO1xyXG5cdFx0XHRpZiAocnVsZVRhZ1Rva2VuKSB7XHJcblx0XHRcdFx0bGV0IG06IFBhcnNlVHJlZU1hdGNoO1xyXG5cdFx0XHRcdGlmICh0cmVlLnJ1bGVDb250ZXh0LnJ1bGVJbmRleCA9PT0gcGF0dGVyblRyZWUucnVsZUNvbnRleHQucnVsZUluZGV4KSB7XHJcblx0XHRcdFx0XHQvLyB0cmFjayBsYWJlbC0+bGlzdC1vZi1ub2RlcyBmb3IgYm90aCBydWxlIG5hbWUgYW5kIGxhYmVsIChpZiBhbnkpXHJcblx0XHRcdFx0XHRsYWJlbHMubWFwKHJ1bGVUYWdUb2tlbi5ydWxlTmFtZSwgdHJlZSk7XHJcblx0XHRcdFx0XHRjb25zdCBsID0gcnVsZVRhZ1Rva2VuLmxhYmVsO1xyXG5cdFx0XHRcdFx0aWYgKGwpIHtcclxuXHRcdFx0XHRcdFx0bGFiZWxzLm1hcChsLCB0cmVlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoIW1pc21hdGNoZWROb2RlKSB7XHJcblx0XHRcdFx0XHRcdG1pc21hdGNoZWROb2RlID0gdHJlZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBtaXNtYXRjaGVkTm9kZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gKGV4cHIgLi4uKSBhbmQgKGV4cHIgLi4uKVxyXG5cdFx0XHRpZiAodHJlZS5jaGlsZENvdW50ICE9PSBwYXR0ZXJuVHJlZS5jaGlsZENvdW50KSB7XHJcblx0XHRcdFx0aWYgKCFtaXNtYXRjaGVkTm9kZSkge1xyXG5cdFx0XHRcdFx0bWlzbWF0Y2hlZE5vZGUgPSB0cmVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIG1pc21hdGNoZWROb2RlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgbjogbnVtYmVyID0gdHJlZS5jaGlsZENvdW50O1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRcdGxldCBjaGlsZE1hdGNoID0gdGhpcy5tYXRjaEltcGwodHJlZS5nZXRDaGlsZChpKSwgcGF0dGVyblRyZWUuZ2V0Q2hpbGQoaSksIGxhYmVscyk7XHJcblx0XHRcdFx0aWYgKGNoaWxkTWF0Y2gpIHtcclxuXHRcdFx0XHRcdHJldHVybiBjaGlsZE1hdGNoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1pc21hdGNoZWROb2RlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIG5vZGVzIGFyZW4ndCBib3RoIHRva2VucyBvciBib3RoIHJ1bGUgbm9kZXMsIGNhbid0IG1hdGNoXHJcblx0XHRyZXR1cm4gdHJlZTtcclxuXHR9XHJcblxyXG5cdC8qKiBJcyBgdGAgYChleHByIDxleHByPilgIHN1YnRyZWU/ICovXHJcblx0cHJvdGVjdGVkIGdldFJ1bGVUYWdUb2tlbih0OiBQYXJzZVRyZWUpOiBSdWxlVGFnVG9rZW4gfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKHQgaW5zdGFuY2VvZiBSdWxlTm9kZSkge1xyXG5cdFx0XHRpZiAodC5jaGlsZENvdW50ID09PSAxICYmIHQuZ2V0Q2hpbGQoMCkgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcclxuXHRcdFx0XHRsZXQgYyA9IHQuZ2V0Q2hpbGQoMCkgYXMgVGVybWluYWxOb2RlO1xyXG5cdFx0XHRcdGlmIChjLnN5bWJvbCBpbnN0YW5jZW9mIFJ1bGVUYWdUb2tlbikge1xyXG4vL1x0XHRcdFx0XHRTeXN0ZW0ub3V0LnByaW50bG4oXCJydWxlIHRhZyBzdWJ0cmVlIFwiK3QudG9TdHJpbmdUcmVlKHBhcnNlcikpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGMuc3ltYm9sO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB0b2tlbml6ZShwYXR0ZXJuOiBzdHJpbmcpOiBUb2tlbltdIHtcclxuXHRcdC8vIHNwbGl0IHBhdHRlcm4gaW50byBjaHVua3M6IHNlYSAocmF3IGlucHV0KSBhbmQgaXNsYW5kcyAoPElEPiwgPGV4cHI+KVxyXG5cdFx0bGV0IGNodW5rcyA9IHRoaXMuc3BsaXQocGF0dGVybik7XHJcblxyXG5cdFx0Ly8gY3JlYXRlIHRva2VuIHN0cmVhbSBmcm9tIHRleHQgYW5kIHRhZ3NcclxuXHRcdGxldCB0b2tlbnM6IFRva2VuW10gPSBbXTtcclxuXHJcblx0XHRmb3IgKGxldCBjaHVuayBvZiBjaHVua3MpIHtcclxuXHRcdFx0aWYgKGNodW5rIGluc3RhbmNlb2YgVGFnQ2h1bmspIHtcclxuXHRcdFx0XHRsZXQgdGFnQ2h1bmsgPSBjaHVuaztcclxuXHRcdFx0XHRjb25zdCBmaXJzdENoYXIgPSB0YWdDaHVuay50YWcuc3Vic3RyKDAsIDEpO1xyXG5cdFx0XHRcdC8vIGFkZCBzcGVjaWFsIHJ1bGUgdG9rZW4gb3IgY29uanVyZSB1cCBuZXcgdG9rZW4gZnJvbSBuYW1lXHJcblx0XHRcdFx0aWYgKGZpcnN0Q2hhciA9PT0gZmlyc3RDaGFyLnRvVXBwZXJDYXNlKCkpIHtcclxuXHRcdFx0XHRcdGxldCB0dHlwZTogbnVtYmVyID0gdGhpcy5fcGFyc2VyLmdldFRva2VuVHlwZSh0YWdDaHVuay50YWcpO1xyXG5cdFx0XHRcdFx0aWYgKHR0eXBlID09PSBUb2tlbi5JTlZBTElEX1RZUEUpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0b2tlbiBcIiArIHRhZ0NodW5rLnRhZyArIFwiIGluIHBhdHRlcm46IFwiICsgcGF0dGVybik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsZXQgdDogVG9rZW5UYWdUb2tlbiA9IG5ldyBUb2tlblRhZ1Rva2VuKHRhZ0NodW5rLnRhZywgdHR5cGUsIHRhZ0NodW5rLmxhYmVsKTtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmIChmaXJzdENoYXIgPT09IGZpcnN0Q2hhci50b0xvd2VyQ2FzZSgpKSB7XHJcblx0XHRcdFx0XHRsZXQgcnVsZUluZGV4OiBudW1iZXIgPSB0aGlzLl9wYXJzZXIuZ2V0UnVsZUluZGV4KHRhZ0NodW5rLnRhZyk7XHJcblx0XHRcdFx0XHRpZiAocnVsZUluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHJ1bGUgXCIgKyB0YWdDaHVuay50YWcgKyBcIiBpbiBwYXR0ZXJuOiBcIiArIHBhdHRlcm4pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IHJ1bGVJbWFnaW5hcnlUb2tlblR5cGU6IG51bWJlciA9IHRoaXMuX3BhcnNlci5nZXRBVE5XaXRoQnlwYXNzQWx0cygpLnJ1bGVUb1Rva2VuVHlwZVtydWxlSW5kZXhdO1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2gobmV3IFJ1bGVUYWdUb2tlbih0YWdDaHVuay50YWcsIHJ1bGVJbWFnaW5hcnlUb2tlblR5cGUsIHRhZ0NodW5rLmxhYmVsKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0YWc6IFwiICsgdGFnQ2h1bmsudGFnICsgXCIgaW4gcGF0dGVybjogXCIgKyBwYXR0ZXJuKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0bGV0IHRleHRDaHVuayA9IGNodW5rIGFzIFRleHRDaHVuaztcclxuXHRcdFx0XHR0aGlzLl9sZXhlci5pbnB1dFN0cmVhbSA9IENoYXJTdHJlYW1zLmZyb21TdHJpbmcodGV4dENodW5rLnRleHQpO1xyXG5cdFx0XHRcdGxldCB0OiBUb2tlbiA9IHRoaXMuX2xleGVyLm5leHRUb2tlbigpO1xyXG5cdFx0XHRcdHdoaWxlICh0LnR5cGUgIT09IFRva2VuLkVPRikge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2godCk7XHJcblx0XHRcdFx0XHR0ID0gdGhpcy5fbGV4ZXIubmV4dFRva2VuKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG4vL1x0XHRTeXN0ZW0ub3V0LnByaW50bG4oXCJ0b2tlbnM9XCIrdG9rZW5zKTtcclxuXHRcdHJldHVybiB0b2tlbnM7XHJcblx0fVxyXG5cclxuXHQvKiogU3BsaXQgYDxJRD4gPSA8ZTpleHByPiA7YCBpbnRvIDQgY2h1bmtzIGZvciB0b2tlbml6aW5nIGJ5IHtAbGluayAjdG9rZW5pemV9LiAqL1xyXG5cdHB1YmxpYyBzcGxpdChwYXR0ZXJuOiBzdHJpbmcpOiBDaHVua1tdIHtcclxuXHRcdGxldCBwOiBudW1iZXIgPSAwO1xyXG5cdFx0bGV0IG46IG51bWJlciA9IHBhdHRlcm4ubGVuZ3RoO1xyXG5cdFx0bGV0IGNodW5rczogQ2h1bmtbXSA9IFtdO1xyXG5cdFx0bGV0IGJ1ZjogXCJcIjtcclxuXHRcdC8vIGZpbmQgYWxsIHN0YXJ0IGFuZCBzdG9wIGluZGV4ZXMgZmlyc3QsIHRoZW4gY29sbGVjdFxyXG5cdFx0bGV0IHN0YXJ0czogbnVtYmVyW10gPSBbXTtcclxuXHRcdGxldCBzdG9wczogbnVtYmVyW10gPSBbXTtcclxuXHRcdHdoaWxlIChwIDwgbikge1xyXG5cdFx0XHRpZiAocCA9PT0gcGF0dGVybi5pbmRleE9mKHRoaXMuZXNjYXBlICsgdGhpcy5zdGFydCwgcCkpIHtcclxuXHRcdFx0XHRwICs9IHRoaXMuZXNjYXBlLmxlbmd0aCArIHRoaXMuc3RhcnQubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHAgPT09IHBhdHRlcm4uaW5kZXhPZih0aGlzLmVzY2FwZSArIHRoaXMuc3RvcCwgcCkpIHtcclxuXHRcdFx0XHRwICs9IHRoaXMuZXNjYXBlLmxlbmd0aCArIHRoaXMuc3RvcC5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAocCA9PT0gcGF0dGVybi5pbmRleE9mKHRoaXMuc3RhcnQsIHApKSB7XHJcblx0XHRcdFx0c3RhcnRzLnB1c2gocCk7XHJcblx0XHRcdFx0cCArPSB0aGlzLnN0YXJ0Lmxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChwID09PSBwYXR0ZXJuLmluZGV4T2YodGhpcy5zdG9wLCBwKSkge1xyXG5cdFx0XHRcdHN0b3BzLnB1c2gocCk7XHJcblx0XHRcdFx0cCArPSB0aGlzLnN0b3AubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHArKztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuLy9cdFx0U3lzdGVtLm91dC5wcmludGxuKFwiXCIpO1xyXG4vL1x0XHRTeXN0ZW0ub3V0LnByaW50bG4oc3RhcnRzKTtcclxuLy9cdFx0U3lzdGVtLm91dC5wcmludGxuKHN0b3BzKTtcclxuXHRcdGlmIChzdGFydHMubGVuZ3RoID4gc3RvcHMubGVuZ3RoKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInVudGVybWluYXRlZCB0YWcgaW4gcGF0dGVybjogXCIgKyBwYXR0ZXJuKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3RhcnRzLmxlbmd0aCA8IHN0b3BzLmxlbmd0aCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHN0YXJ0IHRhZyBpbiBwYXR0ZXJuOiBcIiArIHBhdHRlcm4pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBudGFnczogbnVtYmVyID0gc3RhcnRzLmxlbmd0aDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnRhZ3M7IGkrKykge1xyXG5cdFx0XHRpZiAoc3RhcnRzW2ldID49IHN0b3BzW2ldKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidGFnIGRlbGltaXRlcnMgb3V0IG9mIG9yZGVyIGluIHBhdHRlcm46IFwiICsgcGF0dGVybik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjb2xsZWN0IGludG8gY2h1bmtzIG5vd1xyXG5cdFx0aWYgKG50YWdzID09PSAwKSB7XHJcblx0XHRcdGxldCB0ZXh0OiBzdHJpbmcgPSBwYXR0ZXJuLnN1YnN0cmluZygwLCBuKTtcclxuXHRcdFx0Y2h1bmtzLnB1c2gobmV3IFRleHRDaHVuayh0ZXh0KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG50YWdzID4gMCAmJiBzdGFydHNbMF0gPiAwKSB7IC8vIGNvcHkgdGV4dCB1cCB0byBmaXJzdCB0YWcgaW50byBjaHVua3NcclxuXHRcdFx0bGV0IHRleHQ6IHN0cmluZyA9IHBhdHRlcm4uc3Vic3RyaW5nKDAsIHN0YXJ0c1swXSk7XHJcblx0XHRcdGNodW5rcy5wdXNoKG5ldyBUZXh0Q2h1bmsodGV4dCkpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudGFnczsgaSsrKSB7XHJcblx0XHRcdC8vIGNvcHkgaW5zaWRlIG9mIDx0YWc+XHJcblx0XHRcdGxldCB0YWc6IHN0cmluZyA9IHBhdHRlcm4uc3Vic3RyaW5nKHN0YXJ0c1tpXSArIHRoaXMuc3RhcnQubGVuZ3RoLCBzdG9wc1tpXSk7XHJcblx0XHRcdGxldCBydWxlT3JUb2tlbjogc3RyaW5nID0gdGFnO1xyXG5cdFx0XHRsZXQgbGFiZWw6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHRcdFx0bGV0IGNvbG9uOiBudW1iZXIgPSB0YWcuaW5kZXhPZihcIjpcIik7XHJcblx0XHRcdGlmIChjb2xvbiA+PSAwKSB7XHJcblx0XHRcdFx0bGFiZWwgPSB0YWcuc3Vic3RyaW5nKDAsIGNvbG9uKTtcclxuXHRcdFx0XHRydWxlT3JUb2tlbiA9IHRhZy5zdWJzdHJpbmcoY29sb24gKyAxLCB0YWcubGVuZ3RoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjaHVua3MucHVzaChuZXcgVGFnQ2h1bmsocnVsZU9yVG9rZW4sIGxhYmVsKSk7XHJcblx0XHRcdGlmIChpICsgMSA8IG50YWdzKSB7XHJcblx0XHRcdFx0Ly8gY29weSBmcm9tIGVuZCBvZiA8dGFnPiB0byBzdGFydCBvZiBuZXh0XHJcblx0XHRcdFx0bGV0IHRleHQ6IHN0cmluZyA9IHBhdHRlcm4uc3Vic3RyaW5nKHN0b3BzW2ldICsgdGhpcy5zdG9wLmxlbmd0aCwgc3RhcnRzW2kgKyAxXSk7XHJcblx0XHRcdFx0Y2h1bmtzLnB1c2gobmV3IFRleHRDaHVuayh0ZXh0KSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChudGFncyA+IDApIHtcclxuXHRcdFx0bGV0IGFmdGVyTGFzdFRhZzogbnVtYmVyID0gc3RvcHNbbnRhZ3MgLSAxXSArIHRoaXMuc3RvcC5sZW5ndGg7XHJcblx0XHRcdGlmIChhZnRlckxhc3RUYWcgPCBuKSB7IC8vIGNvcHkgdGV4dCBmcm9tIGVuZCBvZiBsYXN0IHRhZyB0byBlbmRcclxuXHRcdFx0XHRsZXQgdGV4dDogc3RyaW5nID0gcGF0dGVybi5zdWJzdHJpbmcoYWZ0ZXJMYXN0VGFnLCBuKTtcclxuXHRcdFx0XHRjaHVua3MucHVzaChuZXcgVGV4dENodW5rKHRleHQpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHN0cmlwIG91dCB0aGUgZXNjYXBlIHNlcXVlbmNlcyBmcm9tIHRleHQgY2h1bmtzIGJ1dCBub3QgdGFnc1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGM6IENodW5rID0gY2h1bmtzW2ldO1xyXG5cdFx0XHRpZiAoYyBpbnN0YW5jZW9mIFRleHRDaHVuaykge1xyXG5cdFx0XHRcdGxldCB1bmVzY2FwZWQ6IHN0cmluZyA9IGMudGV4dC5yZXBsYWNlKHRoaXMuZXNjYXBlUkUsIFwiXCIpO1xyXG5cdFx0XHRcdGlmICh1bmVzY2FwZWQubGVuZ3RoIDwgYy50ZXh0Lmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0Y2h1bmtzW2ldID0gbmV3IFRleHRDaHVuayh1bmVzY2FwZWQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjaHVua3M7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyIHtcclxuXHRleHBvcnQgY2xhc3MgQ2Fubm90SW52b2tlU3RhcnRSdWxlIGV4dGVuZHMgRXJyb3Ige1xyXG5cdFx0cHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyBlcnJvcjogRXJyb3IpIHtcclxuXHRcdFx0c3VwZXIoYENhbm5vdEludm9rZVN0YXJ0UnVsZTogJHtlcnJvcn1gKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRsci9hbnRscjQvaXNzdWVzLzQxM1xyXG5cdC8vIFwiVHJlZSBwYXR0ZXJuIGNvbXBpbGF0aW9uIGRvZXNuJ3QgY2hlY2sgZm9yIGEgY29tcGxldGUgcGFyc2VcIlxyXG5cdGV4cG9ydCBjbGFzcyBTdGFydFJ1bGVEb2VzTm90Q29uc3VtZUZ1bGxQYXR0ZXJuIGV4dGVuZHMgRXJyb3Ige1xyXG5cdFx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRcdHN1cGVyKFwiU3RhcnRSdWxlRG9lc05vdENvbnN1bWVGdWxsUGF0dGVyblwiKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI4LjI0MDEwMzItMDc6MDBcclxuXHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBTaW11bGF0b3JTdGF0ZSB9IGZyb20gXCIuL1NpbXVsYXRvclN0YXRlXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4uL1Rva2VuU3RyZWFtXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgZ2F0aGVyaW5nIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHByZWRpY3Rpb25cclxuICogZXZlbnRzIHdoaWNoIG9jY3VyIGR1cmluZyBwYXJzaW5nLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgd2UgY291bGQgcmVjb3JkIHRoZSBwYXJzZXIgY2FsbCBzdGFjayBhdCB0aGUgdGltZSB0aGlzIGV2ZW50XHJcbiAqIG9jY3VycmVkIGJ1dCBpbiB0aGUgcHJlc2VuY2Ugb2YgbGVmdCByZWN1cnNpdmUgcnVsZXMsIHRoZSBzdGFjayBpcyBraW5kIG9mXHJcbiAqIG1lYW5pbmdsZXNzLiBJdCdzIGJldHRlciB0byBsb29rIGF0IHRoZSBpbmRpdmlkdWFsIGNvbmZpZ3VyYXRpb25zIGZvciB0aGVpclxyXG4gKiBpbmRpdmlkdWFsIHN0YWNrcy4gT2YgY291cnNlIHRoYXQgaXMgYSB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHR9IG9iamVjdFxyXG4gKiBub3QgYSBwYXJzZSB0cmVlIG5vZGUgYW5kIHNvIGl0IGRvZXMgbm90IGhhdmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGV4dGVudFxyXG4gKiAoc3RhcnQuLi5zdG9wKSBvZiB0aGUgdmFyaW91cyBzdWJ0cmVlcy4gRXhhbWluaW5nIHRoZSBzdGFjayB0b3BzIG9mIGFsbFxyXG4gKiBjb25maWd1cmF0aW9ucyBwcm92aWRlIHRoZSByZXR1cm4gc3RhdGVzIGZvciB0aGUgcnVsZSBpbnZvY2F0aW9ucy5cclxuICogRnJvbSB0aGVyZSB5b3UgY2FuIGdldCB0aGUgZW5jbG9zaW5nIHJ1bGUuXHJcbiAqXHJcbiAqIEBzaW5jZSA0LjNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBEZWNpc2lvbkV2ZW50SW5mbyB7XHJcblx0LyoqXHJcblx0ICogVGhlIGludm9rZWQgZGVjaXNpb24gbnVtYmVyIHdoaWNoIHRoaXMgZXZlbnQgaXMgcmVsYXRlZCB0by5cclxuXHQgKlxyXG5cdCAqIEBzZWUgQVROI2RlY2lzaW9uVG9TdGF0ZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBkZWNpc2lvbjogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgc2ltdWxhdG9yIHN0YXRlIGNvbnRhaW5pbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWxldmFudCB0byB0aGVcclxuXHQgKiBwcmVkaWN0aW9uIHN0YXRlIHdoZW4gdGhlIGN1cnJlbnQgZXZlbnQgb2NjdXJyZWQsIG9yIGB1bmRlZmluZWRgIGlmIG5vXHJcblx0ICogYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpcyByZWxldmFudCBvciBhdmFpbGFibGUuXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRlOiBTaW11bGF0b3JTdGF0ZSB8IHVuZGVmaW5lZDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGlucHV0IHRva2VuIHN0cmVhbSB3aGljaCBpcyBiZWluZyBwYXJzZWQuXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgaW5wdXQ6IFRva2VuU3RyZWFtO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgdG9rZW4gaW5kZXggaW4gdGhlIGlucHV0IHN0cmVhbSBhdCB3aGljaCB0aGUgY3VycmVudCBwcmVkaWN0aW9uIHdhc1xyXG5cdCAqIG9yaWdpbmFsbHkgaW52b2tlZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhcnRJbmRleDogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgdG9rZW4gaW5kZXggaW4gdGhlIGlucHV0IHN0cmVhbSBhdCB3aGljaCB0aGUgY3VycmVudCBldmVudCBvY2N1cnJlZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgc3RvcEluZGV4OiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIGB0cnVlYCBpZiB0aGUgY3VycmVudCBldmVudCBvY2N1cnJlZCBkdXJpbmcgTEwgcHJlZGljdGlvbjtcclxuXHQgKiBvdGhlcndpc2UsIGBmYWxzZWAgaWYgdGhlIGlucHV0IG9jY3VycmVkIGR1cmluZyBTTEwgcHJlZGljdGlvbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgZnVsbEN0eDogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRkZWNpc2lvbjogbnVtYmVyLFxyXG5cdFx0c3RhdGU6IFNpbXVsYXRvclN0YXRlIHwgdW5kZWZpbmVkLFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IFRva2VuU3RyZWFtLFxyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyLFxyXG5cdFx0c3RvcEluZGV4OiBudW1iZXIsXHJcblx0XHRmdWxsQ3R4OiBib29sZWFuKSB7XHJcblxyXG5cdFx0dGhpcy5kZWNpc2lvbiA9IGRlY2lzaW9uO1xyXG5cdFx0dGhpcy5mdWxsQ3R4ID0gZnVsbEN0eDtcclxuXHRcdHRoaXMuc3RvcEluZGV4ID0gc3RvcEluZGV4O1xyXG5cdFx0dGhpcy5pbnB1dCA9IGlucHV0O1xyXG5cdFx0dGhpcy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcclxuXHRcdHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI0LjgyMjkyNzktMDc6MDBcclxuXHJcbmltcG9ydCB7IEJpdFNldCB9IGZyb20gXCIuLi9taXNjL0JpdFNldFwiO1xyXG5pbXBvcnQgeyBEZWNpc2lvbkV2ZW50SW5mbyB9IGZyb20gXCIuL0RlY2lzaW9uRXZlbnRJbmZvXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBTaW11bGF0b3JTdGF0ZSB9IGZyb20gXCIuL1NpbXVsYXRvclN0YXRlXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4uL1Rva2VuU3RyZWFtXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHByb2ZpbGluZyBldmVudCBpbmZvcm1hdGlvbiBmb3IgYW4gYW1iaWd1aXR5LlxyXG4gKiBBbWJpZ3VpdGllcyBhcmUgZGVjaXNpb25zIHdoZXJlIGEgcGFydGljdWxhciBpbnB1dCByZXN1bHRlZCBpbiBhbiBTTExcclxuICogY29uZmxpY3QsIGZvbGxvd2VkIGJ5IExMIHByZWRpY3Rpb24gYWxzbyByZWFjaGluZyBhIGNvbmZsaWN0IHN0YXRlXHJcbiAqIChpbmRpY2F0aW5nIGEgdHJ1ZSBhbWJpZ3VpdHkgaW4gdGhlIGdyYW1tYXIpLlxyXG4gKlxyXG4gKiBUaGlzIGV2ZW50IG1heSBiZSByZXBvcnRlZCBkdXJpbmcgU0xMIHByZWRpY3Rpb24gaW4gY2FzZXMgd2hlcmUgdGhlXHJcbiAqIGNvbmZsaWN0aW5nIFNMTCBjb25maWd1cmF0aW9uIHNldCBwcm92aWRlcyBzdWZmaWNpZW50IGluZm9ybWF0aW9uIHRvXHJcbiAqIGRldGVybWluZSB0aGF0IHRoZSBTTEwgY29uZmxpY3QgaXMgdHJ1bHkgYW4gYW1iaWd1aXR5LiBGb3IgZXhhbXBsZSwgaWYgbm9uZVxyXG4gKiBvZiB0aGUgQVROIGNvbmZpZ3VyYXRpb25zIGluIHRoZSBjb25mbGljdGluZyBTTEwgY29uZmlndXJhdGlvbiBzZXQgaGF2ZVxyXG4gKiB0cmF2ZXJzZWQgYSBnbG9iYWwgZm9sbG93IHRyYW5zaXRpb24gKGkuZS5cclxuICoge0BsaW5rIEFUTkNvbmZpZyNnZXRSZWFjaGVzSW50b091dGVyQ29udGV4dH0gaXMgYGZhbHNlYCBmb3IgYWxsXHJcbiAqIGNvbmZpZ3VyYXRpb25zKSwgdGhlbiB0aGUgcmVzdWx0IG9mIFNMTCBwcmVkaWN0aW9uIGZvciB0aGF0IGlucHV0IGlzIGtub3duIHRvXHJcbiAqIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBvZiBMTCBwcmVkaWN0aW9uIGZvciB0aGF0IGlucHV0LlxyXG4gKlxyXG4gKiBJbiBzb21lIGNhc2VzLCB0aGUgbWluaW11bSByZXByZXNlbnRlZCBhbHRlcm5hdGl2ZSBpbiB0aGUgY29uZmxpY3RpbmcgTExcclxuICogY29uZmlndXJhdGlvbiBzZXQgaXMgbm90IGVxdWFsIHRvIHRoZSBtaW5pbXVtIHJlcHJlc2VudGVkIGFsdGVybmF0aXZlIGluIHRoZVxyXG4gKiBjb25mbGljdGluZyBTTEwgY29uZmlndXJhdGlvbiBzZXQuIEdyYW1tYXJzIGFuZCBpbnB1dHMgd2hpY2ggcmVzdWx0IGluIHRoaXNcclxuICogc2NlbmFyaW8gYXJlIHVuYWJsZSB0byB1c2Uge0BsaW5rIFByZWRpY3Rpb25Nb2RlI1NMTH0sIHdoaWNoIGluIHR1cm4gbWVhbnNcclxuICogdGhleSBjYW5ub3QgdXNlIHRoZSB0d28tc3RhZ2UgcGFyc2luZyBzdHJhdGVneSB0byBpbXByb3ZlIHBhcnNpbmcgcGVyZm9ybWFuY2VcclxuICogZm9yIHRoYXQgaW5wdXQuXHJcbiAqXHJcbiAqIEBzZWUgUGFyc2VyQVROU2ltdWxhdG9yI3JlcG9ydEFtYmlndWl0eVxyXG4gKiBAc2VlIFBhcnNlckVycm9yTGlzdGVuZXIjcmVwb3J0QW1iaWd1aXR5XHJcbiAqXHJcbiAqIEBzaW5jZSA0LjNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBbWJpZ3VpdHlJbmZvIGV4dGVuZHMgRGVjaXNpb25FdmVudEluZm8ge1xyXG5cdC8qKiBUaGUgc2V0IG9mIGFsdGVybmF0aXZlIG51bWJlcnMgZm9yIHRoaXMgZGVjaXNpb24gZXZlbnQgdGhhdCBsZWFkIHRvIGEgdmFsaWQgcGFyc2UuICovXHJcblx0QE5vdE51bGxcclxuXHRwcml2YXRlIGFtYmlnQWx0czogQml0U2V0O1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQW1iaWd1aXR5SW5mb30gY2xhc3Mgd2l0aCB0aGVcclxuXHQgKiBzcGVjaWZpZWQgZGV0YWlsZWQgYW1iaWd1aXR5IGluZm9ybWF0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGRlY2lzaW9uIFRoZSBkZWNpc2lvbiBudW1iZXJcclxuXHQgKiBAcGFyYW0gc3RhdGUgVGhlIGZpbmFsIHNpbXVsYXRvciBzdGF0ZSBpZGVudGlmeWluZyB0aGUgYW1iaWd1b3VzXHJcblx0ICogYWx0ZXJuYXRpdmVzIGZvciB0aGUgY3VycmVudCBpbnB1dFxyXG5cdCAqIEBwYXJhbSBhbWJpZ0FsdHMgVGhlIHNldCBvZiBhbHRlcm5hdGl2ZXMgaW4gdGhlIGRlY2lzaW9uIHRoYXQgbGVhZCB0byBhIHZhbGlkIHBhcnNlLlxyXG5cdCAqICAgICAgICAgICAgICAgICAgVGhlIHByZWRpY3RlZCBhbHQgaXMgdGhlIG1pbihhbWJpZ0FsdHMpXHJcblx0ICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0b2tlbiBzdHJlYW1cclxuXHQgKiBAcGFyYW0gc3RhcnRJbmRleCBUaGUgc3RhcnQgaW5kZXggZm9yIHRoZSBjdXJyZW50IHByZWRpY3Rpb25cclxuXHQgKiBAcGFyYW0gc3RvcEluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0aGUgYW1iaWd1aXR5IHdhcyBpZGVudGlmaWVkIGR1cmluZ1xyXG5cdCAqIHByZWRpY3Rpb25cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdGRlY2lzaW9uOiBudW1iZXIsXHJcblx0XHRATm90TnVsbCBzdGF0ZTogU2ltdWxhdG9yU3RhdGUsXHJcblx0XHRATm90TnVsbCBhbWJpZ0FsdHM6IEJpdFNldCxcclxuXHRcdEBOb3ROdWxsIGlucHV0OiBUb2tlblN0cmVhbSxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyKSB7XHJcblx0XHRzdXBlcihkZWNpc2lvbiwgc3RhdGUsIGlucHV0LCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHN0YXRlLnVzZUNvbnRleHQpO1xyXG5cdFx0dGhpcy5hbWJpZ0FsdHMgPSBhbWJpZ0FsdHM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBzZXQgb2YgYWx0ZXJuYXRpdmVzIGluIHRoZSBkZWNpc2lvbiB0aGF0IGxlYWQgdG8gYSB2YWxpZCBwYXJzZS5cclxuXHQgKlxyXG5cdCAqIEBzaW5jZSA0LjVcclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdGdldCBhbWJpZ3VvdXNBbHRlcm5hdGl2ZXMoKTogQml0U2V0IHtcclxuXHRcdHJldHVybiB0aGlzLmFtYmlnQWx0cztcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI4LjE1NzU5MzMtMDc6MDBcclxuXHJcbmltcG9ydCB7IERlY2lzaW9uRXZlbnRJbmZvIH0gZnJvbSBcIi4vRGVjaXNpb25FdmVudEluZm9cIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFNpbXVsYXRvclN0YXRlIH0gZnJvbSBcIi4vU2ltdWxhdG9yU3RhdGVcIjtcclxuaW1wb3J0IHsgVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi4vVG9rZW5TdHJlYW1cIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgcHJvZmlsaW5nIGV2ZW50IGluZm9ybWF0aW9uIGZvciBhIGNvbnRleHQgc2Vuc2l0aXZpdHkuXHJcbiAqIENvbnRleHQgc2Vuc2l0aXZpdGllcyBhcmUgZGVjaXNpb25zIHdoZXJlIGEgcGFydGljdWxhciBpbnB1dCByZXN1bHRlZCBpbiBhblxyXG4gKiBTTEwgY29uZmxpY3QsIGJ1dCBMTCBwcmVkaWN0aW9uIHByb2R1Y2VkIGEgc2luZ2xlIHVuaXF1ZSBhbHRlcm5hdGl2ZS5cclxuICpcclxuICogSW4gc29tZSBjYXNlcywgdGhlIHVuaXF1ZSBhbHRlcm5hdGl2ZSBpZGVudGlmaWVkIGJ5IExMIHByZWRpY3Rpb24gaXMgbm90XHJcbiAqIGVxdWFsIHRvIHRoZSBtaW5pbXVtIHJlcHJlc2VudGVkIGFsdGVybmF0aXZlIGluIHRoZSBjb25mbGljdGluZyBTTExcclxuICogY29uZmlndXJhdGlvbiBzZXQuIEdyYW1tYXJzIGFuZCBpbnB1dHMgd2hpY2ggcmVzdWx0IGluIHRoaXMgc2NlbmFyaW8gYXJlXHJcbiAqIHVuYWJsZSB0byB1c2Uge0BsaW5rIFByZWRpY3Rpb25Nb2RlI1NMTH0sIHdoaWNoIGluIHR1cm4gbWVhbnMgdGhleSBjYW5ub3QgdXNlXHJcbiAqIHRoZSB0d28tc3RhZ2UgcGFyc2luZyBzdHJhdGVneSB0byBpbXByb3ZlIHBhcnNpbmcgcGVyZm9ybWFuY2UgZm9yIHRoYXRcclxuICogaW5wdXQuXHJcbiAqXHJcbiAqIEBzZWUgUGFyc2VyQVROU2ltdWxhdG9yI3JlcG9ydENvbnRleHRTZW5zaXRpdml0eVxyXG4gKiBAc2VlIFBhcnNlckVycm9yTGlzdGVuZXIjcmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5XHJcbiAqXHJcbiAqIEBzaW5jZSA0LjNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb250ZXh0U2Vuc2l0aXZpdHlJbmZvIGV4dGVuZHMgRGVjaXNpb25FdmVudEluZm8ge1xyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBDb250ZXh0U2Vuc2l0aXZpdHlJbmZvfSBjbGFzc1xyXG5cdCAqIHdpdGggdGhlIHNwZWNpZmllZCBkZXRhaWxlZCBjb250ZXh0IHNlbnNpdGl2aXR5IGluZm9ybWF0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGRlY2lzaW9uIFRoZSBkZWNpc2lvbiBudW1iZXJcclxuXHQgKiBAcGFyYW0gc3RhdGUgVGhlIGZpbmFsIHNpbXVsYXRvciBzdGF0ZSBjb250YWluaW5nIHRoZSB1bmlxdWVcclxuXHQgKiBhbHRlcm5hdGl2ZSBpZGVudGlmaWVkIGJ5IGZ1bGwtY29udGV4dCBwcmVkaWN0aW9uXHJcblx0ICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0b2tlbiBzdHJlYW1cclxuXHQgKiBAcGFyYW0gc3RhcnRJbmRleCBUaGUgc3RhcnQgaW5kZXggZm9yIHRoZSBjdXJyZW50IHByZWRpY3Rpb25cclxuXHQgKiBAcGFyYW0gc3RvcEluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0aGUgY29udGV4dCBzZW5zaXRpdml0eSB3YXNcclxuXHQgKiBpZGVudGlmaWVkIGR1cmluZyBmdWxsLWNvbnRleHQgcHJlZGljdGlvblxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0ZGVjaXNpb246IG51bWJlcixcclxuXHRcdEBOb3ROdWxsIHN0YXRlOiBTaW11bGF0b3JTdGF0ZSxcclxuXHRcdEBOb3ROdWxsIGlucHV0OiBUb2tlblN0cmVhbSxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyKSB7XHJcblxyXG5cdFx0c3VwZXIoZGVjaXNpb24sIHN0YXRlLCBpbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCB0cnVlKTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjI4LjMzMzA2NzMtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFtYmlndWl0eUluZm8gfSBmcm9tIFwiLi9BbWJpZ3VpdHlJbmZvXCI7XHJcbmltcG9ydCB7IENvbnRleHRTZW5zaXRpdml0eUluZm8gfSBmcm9tIFwiLi9Db250ZXh0U2Vuc2l0aXZpdHlJbmZvXCI7XHJcbmltcG9ydCB7IEVycm9ySW5mbyB9IGZyb20gXCIuL0Vycm9ySW5mb1wiO1xyXG5pbXBvcnQgeyBMb29rYWhlYWRFdmVudEluZm8gfSBmcm9tIFwiLi9Mb29rYWhlYWRFdmVudEluZm9cIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQcmVkaWNhdGVFdmFsSW5mbyB9IGZyb20gXCIuL1ByZWRpY2F0ZUV2YWxJbmZvXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBjb250YWlucyBwcm9maWxpbmcgZ2F0aGVyZWQgZm9yIGEgcGFydGljdWxhciBkZWNpc2lvbi5cclxuICpcclxuICogUGFyc2luZyBwZXJmb3JtYW5jZSBpbiBBTlRMUiA0IGlzIGhlYXZpbHkgaW5mbHVlbmNlZCBieSBib3RoIHN0YXRpYyBmYWN0b3JzXHJcbiAqIChlLmcuIHRoZSBmb3JtIG9mIHRoZSBydWxlcyBpbiB0aGUgZ3JhbW1hcikgYW5kIGR5bmFtaWMgZmFjdG9ycyAoZS5nLiB0aGVcclxuICogY2hvaWNlIG9mIGlucHV0IGFuZCB0aGUgc3RhdGUgb2YgdGhlIERGQSBjYWNoZSBhdCB0aGUgdGltZSBwcm9maWxpbmdcclxuICogb3BlcmF0aW9ucyBhcmUgc3RhcnRlZCkuIEZvciBiZXN0IHJlc3VsdHMsIGdhdGhlciBhbmQgdXNlIGFnZ3JlZ2F0ZVxyXG4gKiBzdGF0aXN0aWNzIGZyb20gYSBsYXJnZSBzYW1wbGUgb2YgaW5wdXRzIHJlcHJlc2VudGluZyB0aGUgaW5wdXRzIGV4cGVjdGVkIGluXHJcbiAqIHByb2R1Y3Rpb24gYmVmb3JlIHVzaW5nIHRoZSByZXN1bHRzIHRvIG1ha2UgY2hhbmdlcyBpbiB0aGUgZ3JhbW1hci5cclxuICpcclxuICogQHNpbmNlIDQuM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERlY2lzaW9uSW5mbyB7XHJcblx0LyoqXHJcblx0ICogVGhlIGRlY2lzaW9uIG51bWJlciwgd2hpY2ggaXMgYW4gaW5kZXggaW50byB7QGxpbmsgQVROI2RlY2lzaW9uVG9TdGF0ZX0uXHJcblx0ICovXHJcblx0cHVibGljIGRlY2lzaW9uOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSB0b3RhbCBudW1iZXIgb2YgdGltZXMge0BsaW5rIFBhcnNlckFUTlNpbXVsYXRvciNhZGFwdGl2ZVByZWRpY3R9IHdhc1xyXG5cdCAqIGludm9rZWQgZm9yIHRoaXMgZGVjaXNpb24uXHJcblx0ICovXHJcblx0cHVibGljIGludm9jYXRpb25zOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgdG90YWwgdGltZSBzcGVudCBpbiB7QGxpbmsgUGFyc2VyQVROU2ltdWxhdG9yI2FkYXB0aXZlUHJlZGljdH0gZm9yXHJcblx0ICogdGhpcyBkZWNpc2lvbiwgaW4gbmFub3NlY29uZHMuXHJcblx0ICpcclxuXHQgKiBUaGUgdmFsdWUgb2YgdGhpcyBmaWVsZCBjb250YWlucyB0aGUgc3VtIG9mIGRpZmZlcmVudGlhbCByZXN1bHRzIG9idGFpbmVkXHJcblx0ICogYnkge0BsaW5rIFN5c3RlbSNuYW5vVGltZSgpfSwgYW5kIGlzIG5vdCBhZGp1c3RlZCB0byBjb21wZW5zYXRlIGZvciBKSVRcclxuXHQgKiBhbmQvb3IgZ2FyYmFnZSBjb2xsZWN0aW9uIG92ZXJoZWFkLiBGb3IgYmVzdCBhY2N1cmFjeSwgdXNlIGEgbW9kZXJuIEpWTVxyXG5cdCAqIGltcGxlbWVudGF0aW9uIHRoYXQgcHJvdmlkZXMgcHJlY2lzZSByZXN1bHRzIGZyb21cclxuXHQgKiB7QGxpbmsgU3lzdGVtI25hbm9UaW1lKCl9LCBhbmQgcGVyZm9ybSBwcm9maWxpbmcgaW4gYSBzZXBhcmF0ZSBwcm9jZXNzXHJcblx0ICogd2hpY2ggaXMgd2FybWVkIHVwIGJ5IHBhcnNpbmcgdGhlIGlucHV0IHByaW9yIHRvIHByb2ZpbGluZy4gSWYgZGVzaXJlZCxcclxuXHQgKiBjYWxsIHtAbGluayBBVE5TaW11bGF0b3IjY2xlYXJERkF9IHRvIHJlc2V0IHRoZSBERkEgY2FjaGUgdG8gaXRzIGluaXRpYWxcclxuXHQgKiBzdGF0ZSBiZWZvcmUgc3RhcnRpbmcgdGhlIHByb2ZpbGluZyBtZWFzdXJlbWVudCBwYXNzLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyB0aW1lSW5QcmVkaWN0aW9uOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgc3VtIG9mIHRoZSBsb29rYWhlYWQgcmVxdWlyZWQgZm9yIFNMTCBwcmVkaWN0aW9uIGZvciB0aGlzIGRlY2lzaW9uLlxyXG5cdCAqIE5vdGUgdGhhdCBTTEwgcHJlZGljdGlvbiBpcyB1c2VkIGJlZm9yZSBMTCBwcmVkaWN0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cdCAqIHJlYXNvbnMgZXZlbiB3aGVuIHtAbGluayBQcmVkaWN0aW9uTW9kZSNMTH0gb3JcclxuXHQgKiB7QGxpbmsgUHJlZGljdGlvbk1vZGUjTExfRVhBQ1RfQU1CSUdfREVURUNUSU9OfSBpcyB1c2VkLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBTTExfVG90YWxMb29rOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBtaW5pbXVtIGxvb2thaGVhZCByZXF1aXJlZCBmb3IgYW55IHNpbmdsZSBTTEwgcHJlZGljdGlvbiB0b1xyXG5cdCAqIGNvbXBsZXRlIGZvciB0aGlzIGRlY2lzaW9uLCBieSByZWFjaGluZyBhIHVuaXF1ZSBwcmVkaWN0aW9uLCByZWFjaGluZyBhblxyXG5cdCAqIFNMTCBjb25mbGljdCBzdGF0ZSwgb3IgZW5jb3VudGVyaW5nIGEgc3ludGF4IGVycm9yLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBTTExfTWluTG9vazogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgbWF4aW11bSBsb29rYWhlYWQgcmVxdWlyZWQgZm9yIGFueSBzaW5nbGUgU0xMIHByZWRpY3Rpb24gdG9cclxuXHQgKiBjb21wbGV0ZSBmb3IgdGhpcyBkZWNpc2lvbiwgYnkgcmVhY2hpbmcgYSB1bmlxdWUgcHJlZGljdGlvbiwgcmVhY2hpbmcgYW5cclxuXHQgKiBTTEwgY29uZmxpY3Qgc3RhdGUsIG9yIGVuY291bnRlcmluZyBhIHN5bnRheCBlcnJvci5cclxuXHQgKi9cclxuXHRwdWJsaWMgU0xMX01heExvb2s6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHtAbGluayBMb29rYWhlYWRFdmVudEluZm99IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQgd2hlcmUgdGhlXHJcblx0ICoge0BsaW5rICNTTExfTWF4TG9va30gdmFsdWUgd2FzIHNldC5cclxuXHQgKi9cclxuXHRwdWJsaWMgU0xMX01heExvb2tFdmVudD86IExvb2thaGVhZEV2ZW50SW5mbztcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHN1bSBvZiB0aGUgbG9va2FoZWFkIHJlcXVpcmVkIGZvciBMTCBwcmVkaWN0aW9uIGZvciB0aGlzIGRlY2lzaW9uLlxyXG5cdCAqIE5vdGUgdGhhdCBMTCBwcmVkaWN0aW9uIGlzIG9ubHkgdXNlZCB3aGVuIFNMTCBwcmVkaWN0aW9uIHJlYWNoZXMgYVxyXG5cdCAqIGNvbmZsaWN0IHN0YXRlLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBMTF9Ub3RhbExvb2s6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIG1pbmltdW0gbG9va2FoZWFkIHJlcXVpcmVkIGZvciBhbnkgc2luZ2xlIExMIHByZWRpY3Rpb24gdG9cclxuXHQgKiBjb21wbGV0ZSBmb3IgdGhpcyBkZWNpc2lvbi4gQW4gTEwgcHJlZGljdGlvbiBjb21wbGV0ZXMgd2hlbiB0aGUgYWxnb3JpdGhtXHJcblx0ICogcmVhY2hlcyBhIHVuaXF1ZSBwcmVkaWN0aW9uLCBhIGNvbmZsaWN0IHN0YXRlIChmb3JcclxuXHQgKiB7QGxpbmsgUHJlZGljdGlvbk1vZGUjTEx9LCBhbiBhbWJpZ3VpdHkgc3RhdGUgKGZvclxyXG5cdCAqIHtAbGluayBQcmVkaWN0aW9uTW9kZSNMTF9FWEFDVF9BTUJJR19ERVRFQ1RJT059LCBvciBhIHN5bnRheCBlcnJvci5cclxuXHQgKi9cclxuXHRwdWJsaWMgTExfTWluTG9vazogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgbWF4aW11bSBsb29rYWhlYWQgcmVxdWlyZWQgZm9yIGFueSBzaW5nbGUgTEwgcHJlZGljdGlvbiB0b1xyXG5cdCAqIGNvbXBsZXRlIGZvciB0aGlzIGRlY2lzaW9uLiBBbiBMTCBwcmVkaWN0aW9uIGNvbXBsZXRlcyB3aGVuIHRoZSBhbGdvcml0aG1cclxuXHQgKiByZWFjaGVzIGEgdW5pcXVlIHByZWRpY3Rpb24sIGEgY29uZmxpY3Qgc3RhdGUgKGZvclxyXG5cdCAqIHtAbGluayBQcmVkaWN0aW9uTW9kZSNMTH0sIGFuIGFtYmlndWl0eSBzdGF0ZSAoZm9yXHJcblx0ICoge0BsaW5rIFByZWRpY3Rpb25Nb2RlI0xMX0VYQUNUX0FNQklHX0RFVEVDVElPTn0sIG9yIGEgc3ludGF4IGVycm9yLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBMTF9NYXhMb29rOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB7QGxpbmsgTG9va2FoZWFkRXZlbnRJbmZvfSBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50IHdoZXJlIHRoZVxyXG5cdCAqIHtAbGluayAjTExfTWF4TG9va30gdmFsdWUgd2FzIHNldC5cclxuXHQgKi9cclxuXHRwdWJsaWMgTExfTWF4TG9va0V2ZW50PzogTG9va2FoZWFkRXZlbnRJbmZvO1xyXG5cclxuXHQvKipcclxuXHQgKiBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIENvbnRleHRTZW5zaXRpdml0eUluZm99IGluc3RhbmNlcyBkZXNjcmliaW5nIHRoZVxyXG5cdCAqIGNvbnRleHQgc2Vuc2l0aXZpdGllcyBlbmNvdW50ZXJlZCBkdXJpbmcgTEwgcHJlZGljdGlvbiBmb3IgdGhpcyBkZWNpc2lvbi5cclxuXHQgKlxyXG5cdCAqIEBzZWUgQ29udGV4dFNlbnNpdGl2aXR5SW5mb1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBjb250ZXh0U2Vuc2l0aXZpdGllczogQ29udGV4dFNlbnNpdGl2aXR5SW5mb1tdID0gW107XHJcblxyXG5cdC8qKlxyXG5cdCAqIEEgY29sbGVjdGlvbiBvZiB7QGxpbmsgRXJyb3JJbmZvfSBpbnN0YW5jZXMgZGVzY3JpYmluZyB0aGUgcGFyc2UgZXJyb3JzXHJcblx0ICogaWRlbnRpZmllZCBkdXJpbmcgY2FsbHMgdG8ge0BsaW5rIFBhcnNlckFUTlNpbXVsYXRvciNhZGFwdGl2ZVByZWRpY3R9IGZvclxyXG5cdCAqIHRoaXMgZGVjaXNpb24uXHJcblx0ICpcclxuXHQgKiBAc2VlIEVycm9ySW5mb1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBlcnJvcnM6IEVycm9ySW5mb1tdID0gW107XHJcblxyXG5cdC8qKlxyXG5cdCAqIEEgY29sbGVjdGlvbiBvZiB7QGxpbmsgQW1iaWd1aXR5SW5mb30gaW5zdGFuY2VzIGRlc2NyaWJpbmcgdGhlXHJcblx0ICogYW1iaWd1aXRpZXMgZW5jb3VudGVyZWQgZHVyaW5nIExMIHByZWRpY3Rpb24gZm9yIHRoaXMgZGVjaXNpb24uXHJcblx0ICpcclxuXHQgKiBAc2VlIEFtYmlndWl0eUluZm9cclxuXHQgKi9cclxuXHRwdWJsaWMgYW1iaWd1aXRpZXM6IEFtYmlndWl0eUluZm9bXSA9IFtdO1xyXG5cclxuXHQvKipcclxuXHQgKiBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIFByZWRpY2F0ZUV2YWxJbmZvfSBpbnN0YW5jZXMgZGVzY3JpYmluZyB0aGVcclxuXHQgKiByZXN1bHRzIG9mIGV2YWx1YXRpbmcgaW5kaXZpZHVhbCBwcmVkaWNhdGVzIGR1cmluZyBwcmVkaWN0aW9uIGZvciB0aGlzXHJcblx0ICogZGVjaXNpb24uXHJcblx0ICpcclxuXHQgKiBAc2VlIFByZWRpY2F0ZUV2YWxJbmZvXHJcblx0ICovXHJcblx0cHVibGljIHByZWRpY2F0ZUV2YWxzOiBQcmVkaWNhdGVFdmFsSW5mb1tdID0gW107XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSB0b3RhbCBudW1iZXIgb2YgQVROIHRyYW5zaXRpb25zIHJlcXVpcmVkIGR1cmluZyBTTEwgcHJlZGljdGlvbiBmb3JcclxuXHQgKiB0aGlzIGRlY2lzaW9uLiBBbiBBVE4gdHJhbnNpdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBudW1iZXIgb2YgdGltZXMgdGhlXHJcblx0ICogREZBIGRvZXMgbm90IGNvbnRhaW4gYW4gZWRnZSB0aGF0IGlzIHJlcXVpcmVkIGZvciBwcmVkaWN0aW9uLCByZXN1bHRpbmdcclxuXHQgKiBpbiBvbi10aGUtZmx5IGNvbXB1dGF0aW9uIG9mIHRoYXQgZWRnZS5cclxuXHQgKlxyXG5cdCAqIElmIERGQSBjYWNoaW5nIG9mIFNMTCB0cmFuc2l0aW9ucyBpcyBlbXBsb3llZCBieSB0aGUgaW1wbGVtZW50YXRpb24sIEFUTlxyXG5cdCAqIGNvbXB1dGF0aW9uIG1heSBjYWNoZSB0aGUgY29tcHV0ZWQgZWRnZSBmb3IgZWZmaWNpZW50IGxvb2t1cCBkdXJpbmdcclxuXHQgKiBmdXR1cmUgcGFyc2luZyBvZiB0aGlzIGRlY2lzaW9uLiBPdGhlcndpc2UsIHRoZSBTTEwgcGFyc2luZyBhbGdvcml0aG1cclxuXHQgKiB3aWxsIHVzZSBBVE4gdHJhbnNpdGlvbnMgZXhjbHVzaXZlbHkuXHJcblx0ICpcclxuXHQgKiBAc2VlICNTTExfQVROVHJhbnNpdGlvbnNcclxuXHQgKiBAc2VlIFBhcnNlckFUTlNpbXVsYXRvciNjb21wdXRlVGFyZ2V0U3RhdGVcclxuXHQgKiBAc2VlIExleGVyQVROU2ltdWxhdG9yI2NvbXB1dGVUYXJnZXRTdGF0ZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBTTExfQVROVHJhbnNpdGlvbnM6IG51bWJlciA9IDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSB0b3RhbCBudW1iZXIgb2YgREZBIHRyYW5zaXRpb25zIHJlcXVpcmVkIGR1cmluZyBTTEwgcHJlZGljdGlvbiBmb3JcclxuXHQgKiB0aGlzIGRlY2lzaW9uLlxyXG5cdCAqXHJcblx0ICogSWYgdGhlIEFUTiBzaW11bGF0b3IgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgdXNlIERGQSBjYWNoaW5nIGZvciBTTExcclxuXHQgKiB0cmFuc2l0aW9ucywgdGhpcyB2YWx1ZSB3aWxsIGJlIDAuXHJcblx0ICpcclxuXHQgKiBAc2VlIFBhcnNlckFUTlNpbXVsYXRvciNnZXRFeGlzdGluZ1RhcmdldFN0YXRlXHJcblx0ICogQHNlZSBMZXhlckFUTlNpbXVsYXRvciNnZXRFeGlzdGluZ1RhcmdldFN0YXRlXHJcblx0ICovXHJcblx0cHVibGljIFNMTF9ERkFUcmFuc2l0aW9uczogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIHRpbWVzIFNMTCBwcmVkaWN0aW9uIGNvbXBsZXRlZCBpbiBhIGNvbmZsaWN0XHJcblx0ICogc3RhdGUsIHJlc3VsdGluZyBpbiBmYWxsYmFjayB0byBMTCBwcmVkaWN0aW9uLlxyXG5cdCAqXHJcblx0ICogTm90ZSB0aGF0IHRoaXMgdmFsdWUgaXMgbm90IHJlbGF0ZWQgdG8gd2hldGhlciBvciBub3RcclxuXHQgKiB7QGxpbmsgUHJlZGljdGlvbk1vZGUjU0xMfSBtYXkgYmUgdXNlZCBzdWNjZXNzZnVsbHkgd2l0aCBhIHBhcnRpY3VsYXJcclxuXHQgKiBncmFtbWFyLiBJZiB0aGUgYW1iaWd1aXR5IHJlc29sdXRpb24gYWxnb3JpdGhtIGFwcGxpZWQgdG8gdGhlIFNMTFxyXG5cdCAqIGNvbmZsaWN0cyBmb3IgdGhpcyBkZWNpc2lvbiBwcm9kdWNlIHRoZSBzYW1lIHJlc3VsdCBhcyBMTCBwcmVkaWN0aW9uIGZvclxyXG5cdCAqIHRoaXMgZGVjaXNpb24sIHtAbGluayBQcmVkaWN0aW9uTW9kZSNTTEx9IHdvdWxkIHByb2R1Y2UgdGhlIHNhbWUgb3ZlcmFsbFxyXG5cdCAqIHBhcnNpbmcgcmVzdWx0IGFzIHtAbGluayBQcmVkaWN0aW9uTW9kZSNMTH0uXHJcblx0ICovXHJcblx0cHVibGljIExMX0ZhbGxiYWNrOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgdG90YWwgbnVtYmVyIG9mIEFUTiB0cmFuc2l0aW9ucyByZXF1aXJlZCBkdXJpbmcgTEwgcHJlZGljdGlvbiBmb3JcclxuXHQgKiB0aGlzIGRlY2lzaW9uLiBBbiBBVE4gdHJhbnNpdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBudW1iZXIgb2YgdGltZXMgdGhlXHJcblx0ICogREZBIGRvZXMgbm90IGNvbnRhaW4gYW4gZWRnZSB0aGF0IGlzIHJlcXVpcmVkIGZvciBwcmVkaWN0aW9uLCByZXN1bHRpbmdcclxuXHQgKiBpbiBvbi10aGUtZmx5IGNvbXB1dGF0aW9uIG9mIHRoYXQgZWRnZS5cclxuXHQgKlxyXG5cdCAqIElmIERGQSBjYWNoaW5nIG9mIExMIHRyYW5zaXRpb25zIGlzIGVtcGxveWVkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiwgQVROXHJcblx0ICogY29tcHV0YXRpb24gbWF5IGNhY2hlIHRoZSBjb21wdXRlZCBlZGdlIGZvciBlZmZpY2llbnQgbG9va3VwIGR1cmluZ1xyXG5cdCAqIGZ1dHVyZSBwYXJzaW5nIG9mIHRoaXMgZGVjaXNpb24uIE90aGVyd2lzZSwgdGhlIExMIHBhcnNpbmcgYWxnb3JpdGhtIHdpbGxcclxuXHQgKiB1c2UgQVROIHRyYW5zaXRpb25zIGV4Y2x1c2l2ZWx5LlxyXG5cdCAqXHJcblx0ICogQHNlZSAjTExfREZBVHJhbnNpdGlvbnNcclxuXHQgKiBAc2VlIFBhcnNlckFUTlNpbXVsYXRvciNjb21wdXRlVGFyZ2V0U3RhdGVcclxuXHQgKiBAc2VlIExleGVyQVROU2ltdWxhdG9yI2NvbXB1dGVUYXJnZXRTdGF0ZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBMTF9BVE5UcmFuc2l0aW9uczogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHRvdGFsIG51bWJlciBvZiBERkEgdHJhbnNpdGlvbnMgcmVxdWlyZWQgZHVyaW5nIExMIHByZWRpY3Rpb24gZm9yXHJcblx0ICogdGhpcyBkZWNpc2lvbi5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSBBVE4gc2ltdWxhdG9yIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHVzZSBERkEgY2FjaGluZyBmb3IgTExcclxuXHQgKiB0cmFuc2l0aW9ucywgdGhpcyB2YWx1ZSB3aWxsIGJlIDAuXHJcblx0ICpcclxuXHQgKiBAc2VlIFBhcnNlckFUTlNpbXVsYXRvciNnZXRFeGlzdGluZ1RhcmdldFN0YXRlXHJcblx0ICogQHNlZSBMZXhlckFUTlNpbXVsYXRvciNnZXRFeGlzdGluZ1RhcmdldFN0YXRlXHJcblx0ICovXHJcblx0cHVibGljIExMX0RGQVRyYW5zaXRpb25zOiBudW1iZXIgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRGVjaXNpb25JbmZvfSBjbGFzcyB0byBjb250YWluXHJcblx0ICogc3RhdGlzdGljcyBmb3IgYSBwYXJ0aWN1bGFyIGRlY2lzaW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGRlY2lzaW9uIFRoZSBkZWNpc2lvbiBudW1iZXJcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihkZWNpc2lvbjogbnVtYmVyKSB7XHJcblx0XHR0aGlzLmRlY2lzaW9uID0gZGVjaXNpb247XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIntcIiArXHJcblx0XHRcdFwiZGVjaXNpb249XCIgKyB0aGlzLmRlY2lzaW9uICtcclxuXHRcdFx0XCIsIGNvbnRleHRTZW5zaXRpdml0aWVzPVwiICsgdGhpcy5jb250ZXh0U2Vuc2l0aXZpdGllcy5sZW5ndGggK1xyXG5cdFx0XHRcIiwgZXJyb3JzPVwiICsgdGhpcy5lcnJvcnMubGVuZ3RoICtcclxuXHRcdFx0XCIsIGFtYmlndWl0aWVzPVwiICsgdGhpcy5hbWJpZ3VpdGllcy5sZW5ndGggK1xyXG5cdFx0XHRcIiwgU0xMX2xvb2thaGVhZD1cIiArIHRoaXMuU0xMX1RvdGFsTG9vayArXHJcblx0XHRcdFwiLCBTTExfQVROVHJhbnNpdGlvbnM9XCIgKyB0aGlzLlNMTF9BVE5UcmFuc2l0aW9ucyArXHJcblx0XHRcdFwiLCBTTExfREZBVHJhbnNpdGlvbnM9XCIgKyB0aGlzLlNMTF9ERkFUcmFuc2l0aW9ucyArXHJcblx0XHRcdFwiLCBMTF9GYWxsYmFjaz1cIiArIHRoaXMuTExfRmFsbGJhY2sgK1xyXG5cdFx0XHRcIiwgTExfbG9va2FoZWFkPVwiICsgdGhpcy5MTF9Ub3RhbExvb2sgK1xyXG5cdFx0XHRcIiwgTExfQVROVHJhbnNpdGlvbnM9XCIgKyB0aGlzLkxMX0FUTlRyYW5zaXRpb25zICtcclxuXHRcdFx0XCJ9XCI7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjoyOC43MjEzNjQ3LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBEZWNpc2lvbkV2ZW50SW5mbyB9IGZyb20gXCIuL0RlY2lzaW9uRXZlbnRJbmZvXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBTaW11bGF0b3JTdGF0ZSB9IGZyb20gXCIuL1NpbXVsYXRvclN0YXRlXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4uL1Rva2VuU3RyZWFtXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHByb2ZpbGluZyBldmVudCBpbmZvcm1hdGlvbiBmb3IgYSBzeW50YXggZXJyb3JcclxuICogaWRlbnRpZmllZCBkdXJpbmcgcHJlZGljdGlvbi4gU3ludGF4IGVycm9ycyBvY2N1ciB3aGVuIHRoZSBwcmVkaWN0aW9uXHJcbiAqIGFsZ29yaXRobSBpcyB1bmFibGUgdG8gaWRlbnRpZnkgYW4gYWx0ZXJuYXRpdmUgd2hpY2ggd291bGQgbGVhZCB0byBhXHJcbiAqIHN1Y2Nlc3NmdWwgcGFyc2UuXHJcbiAqXHJcbiAqIEBzZWUgUGFyc2VyI25vdGlmeUVycm9yTGlzdGVuZXJzKFRva2VuLCBTdHJpbmcsIFJlY29nbml0aW9uRXhjZXB0aW9uKVxyXG4gKiBAc2VlIEFOVExSRXJyb3JMaXN0ZW5lciNzeW50YXhFcnJvclxyXG4gKlxyXG4gKiBAc2luY2UgNC4zXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRXJyb3JJbmZvIGV4dGVuZHMgRGVjaXNpb25FdmVudEluZm8ge1xyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFcnJvckluZm99IGNsYXNzIHdpdGggdGhlXHJcblx0ICogc3BlY2lmaWVkIGRldGFpbGVkIHN5bnRheCBlcnJvciBpbmZvcm1hdGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBkZWNpc2lvbiBUaGUgZGVjaXNpb24gbnVtYmVyXHJcblx0ICogQHBhcmFtIHN0YXRlIFRoZSBmaW5hbCBzaW11bGF0b3Igc3RhdGUgcmVhY2hlZCBkdXJpbmcgcHJlZGljdGlvblxyXG5cdCAqIHByaW9yIHRvIHJlYWNoaW5nIHRoZSB7QGxpbmsgQVROU2ltdWxhdG9yI0VSUk9SfSBzdGF0ZVxyXG5cdCAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG9rZW4gc3RyZWFtXHJcblx0ICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IGZvciB0aGUgY3VycmVudCBwcmVkaWN0aW9uXHJcblx0ICogQHBhcmFtIHN0b3BJbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdGhlIHN5bnRheCBlcnJvciB3YXMgaWRlbnRpZmllZFxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0ZGVjaXNpb246IG51bWJlcixcclxuXHRcdEBOb3ROdWxsIHN0YXRlOiBTaW11bGF0b3JTdGF0ZSxcclxuXHRcdEBOb3ROdWxsIGlucHV0OiBUb2tlblN0cmVhbSxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyKSB7XHJcblxyXG5cdFx0c3VwZXIoZGVjaXNpb24sIHN0YXRlLCBpbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBzdGF0ZS51c2VDb250ZXh0KTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjMwLjY4NTI1NjUtMDc6MDBcclxuXHJcbmltcG9ydCB7IERlY2lzaW9uRXZlbnRJbmZvIH0gZnJvbSBcIi4vRGVjaXNpb25FdmVudEluZm9cIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IFNpbXVsYXRvclN0YXRlIH0gZnJvbSBcIi4vU2ltdWxhdG9yU3RhdGVcIjtcclxuaW1wb3J0IHsgVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi4vVG9rZW5TdHJlYW1cIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgcHJvZmlsaW5nIGV2ZW50IGluZm9ybWF0aW9uIGZvciB0cmFja2luZyB0aGUgbG9va2FoZWFkXHJcbiAqIGRlcHRoIHJlcXVpcmVkIGluIG9yZGVyIHRvIG1ha2UgYSBwcmVkaWN0aW9uLlxyXG4gKlxyXG4gKiBAc2luY2UgNC4zXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTG9va2FoZWFkRXZlbnRJbmZvIGV4dGVuZHMgRGVjaXNpb25FdmVudEluZm8ge1xyXG5cdC8qKiBUaGUgYWx0ZXJuYXRpdmUgY2hvc2VuIGJ5IGFkYXB0aXZlUHJlZGljdCgpLCBub3QgbmVjZXNzYXJpbHlcclxuXHQgKiAgdGhlIG91dGVybW9zdCBhbHQgc2hvd24gZm9yIGEgcnVsZTsgbGVmdC1yZWN1cnNpdmUgcnVsZXMgaGF2ZVxyXG5cdCAqICB1c2VyLWxldmVsIGFsdHMgdGhhdCBkaWZmZXIgZnJvbSB0aGUgcmV3cml0dGVuIHJ1bGUgd2l0aCBhICguLi4pIGJsb2NrXHJcblx0ICogIGFuZCBhICguLikqIGxvb3AuXHJcblx0ICovXHJcblx0cHVibGljIHByZWRpY3RlZEFsdDogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgTG9va2FoZWFkRXZlbnRJbmZvfSBjbGFzcyB3aXRoXHJcblx0ICogdGhlIHNwZWNpZmllZCBkZXRhaWxlZCBsb29rYWhlYWQgaW5mb3JtYXRpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gZGVjaXNpb24gVGhlIGRlY2lzaW9uIG51bWJlclxyXG5cdCAqIEBwYXJhbSBzdGF0ZSBUaGUgZmluYWwgc2ltdWxhdG9yIHN0YXRlIGNvbnRhaW5pbmcgdGhlIG5lY2Vzc2FyeVxyXG5cdCAqIGluZm9ybWF0aW9uIHRvIGRldGVybWluZSB0aGUgcmVzdWx0IG9mIGEgcHJlZGljdGlvbiwgb3IgYHVuZGVmaW5lZGAgaWZcclxuXHQgKiB0aGUgZmluYWwgc3RhdGUgaXMgbm90IGF2YWlsYWJsZVxyXG5cdCAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG9rZW4gc3RyZWFtXHJcblx0ICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IGZvciB0aGUgY3VycmVudCBwcmVkaWN0aW9uXHJcblx0ICogQHBhcmFtIHN0b3BJbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdGhlIHByZWRpY3Rpb24gd2FzIGZpbmFsbHkgbWFkZVxyXG5cdCAqIEBwYXJhbSBmdWxsQ3R4IGB0cnVlYCBpZiB0aGUgY3VycmVudCBsb29rYWhlYWQgaXMgcGFydCBvZiBhbiBMTFxyXG5cdCAqIHByZWRpY3Rpb247IG90aGVyd2lzZSwgYGZhbHNlYCBpZiB0aGUgY3VycmVudCBsb29rYWhlYWQgaXMgcGFydCBvZlxyXG5cdCAqIGFuIFNMTCBwcmVkaWN0aW9uXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRkZWNpc2lvbjogbnVtYmVyLFxyXG5cdFx0c3RhdGU6IFNpbXVsYXRvclN0YXRlIHwgdW5kZWZpbmVkLFxyXG5cdFx0cHJlZGljdGVkQWx0OiBudW1iZXIsXHJcblx0XHRATm90TnVsbCBpbnB1dDogVG9rZW5TdHJlYW0sXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcixcclxuXHRcdGZ1bGxDdHg6IGJvb2xlYW4pIHtcclxuXHJcblx0XHRzdXBlcihkZWNpc2lvbiwgc3RhdGUsIGlucHV0LCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGZ1bGxDdHgpO1xyXG5cdFx0dGhpcy5wcmVkaWN0ZWRBbHQgPSBwcmVkaWN0ZWRBbHQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjozNS4xOTE0MzA1LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBEZWNpc2lvbkV2ZW50SW5mbyB9IGZyb20gXCIuL0RlY2lzaW9uRXZlbnRJbmZvXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBTZW1hbnRpY0NvbnRleHQgfSBmcm9tIFwiLi9TZW1hbnRpY0NvbnRleHRcIjtcclxuaW1wb3J0IHsgU2ltdWxhdG9yU3RhdGUgfSBmcm9tIFwiLi9TaW11bGF0b3JTdGF0ZVwiO1xyXG5pbXBvcnQgeyBUb2tlblN0cmVhbSB9IGZyb20gXCIuLi9Ub2tlblN0cmVhbVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBwcm9maWxpbmcgZXZlbnQgaW5mb3JtYXRpb24gZm9yIHNlbWFudGljIHByZWRpY2F0ZVxyXG4gKiBldmFsdWF0aW9ucyB3aGljaCBvY2N1ciBkdXJpbmcgcHJlZGljdGlvbi5cclxuICpcclxuICogQHNlZSBQYXJzZXJBVE5TaW11bGF0b3IjZXZhbFNlbWFudGljQ29udGV4dFxyXG4gKlxyXG4gKiBAc2luY2UgNC4zXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUHJlZGljYXRlRXZhbEluZm8gZXh0ZW5kcyBEZWNpc2lvbkV2ZW50SW5mbyB7XHJcblx0LyoqXHJcblx0ICogVGhlIHNlbWFudGljIGNvbnRleHQgd2hpY2ggd2FzIGV2YWx1YXRlZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgc2VtY3R4OiBTZW1hbnRpY0NvbnRleHQ7XHJcblx0LyoqXHJcblx0ICogVGhlIGFsdGVybmF0aXZlIG51bWJlciBmb3IgdGhlIGRlY2lzaW9uIHdoaWNoIGlzIGd1YXJkZWQgYnkgdGhlIHNlbWFudGljXHJcblx0ICogY29udGV4dCB7QGxpbmsgI3NlbWN0eH0uIE5vdGUgdGhhdCBvdGhlciBBVE5cclxuXHQgKiBjb25maWd1cmF0aW9ucyBtYXkgcHJlZGljdCB0aGUgc2FtZSBhbHRlcm5hdGl2ZSB3aGljaCBhcmUgZ3VhcmRlZCBieVxyXG5cdCAqIG90aGVyIHNlbWFudGljIGNvbnRleHRzIGFuZC9vciB7QGxpbmsgU2VtYW50aWNDb250ZXh0I05PTkV9LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBwcmVkaWN0ZWRBbHQ6IG51bWJlcjtcclxuXHQvKipcclxuXHQgKiBUaGUgcmVzdWx0IG9mIGV2YWx1YXRpbmcgdGhlIHNlbWFudGljIGNvbnRleHQge0BsaW5rICNzZW1jdHh9LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBldmFsUmVzdWx0OiBib29sZWFuO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgUHJlZGljYXRlRXZhbEluZm99IGNsYXNzIHdpdGggdGhlXHJcblx0ICogc3BlY2lmaWVkIGRldGFpbGVkIHByZWRpY2F0ZSBldmFsdWF0aW9uIGluZm9ybWF0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHN0YXRlIFRoZSBzaW11bGF0b3Igc3RhdGVcclxuXHQgKiBAcGFyYW0gZGVjaXNpb24gVGhlIGRlY2lzaW9uIG51bWJlclxyXG5cdCAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG9rZW4gc3RyZWFtXHJcblx0ICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IGZvciB0aGUgY3VycmVudCBwcmVkaWN0aW9uXHJcblx0ICogQHBhcmFtIHN0b3BJbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdGhlIHByZWRpY2F0ZSBldmFsdWF0aW9uIHdhc1xyXG5cdCAqIHRyaWdnZXJlZC4gTm90ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gbWF5IGJlIHJlc2V0IHRvIG90aGVyIHBvc2l0aW9ucyBmb3JcclxuXHQgKiB0aGUgYWN0dWFsIGV2YWx1YXRpb24gb2YgaW5kaXZpZHVhbCBwcmVkaWNhdGVzLlxyXG5cdCAqIEBwYXJhbSBzZW1jdHggVGhlIHNlbWFudGljIGNvbnRleHQgd2hpY2ggd2FzIGV2YWx1YXRlZFxyXG5cdCAqIEBwYXJhbSBldmFsUmVzdWx0IFRoZSByZXN1bHRzIG9mIGV2YWx1YXRpbmcgdGhlIHNlbWFudGljIGNvbnRleHRcclxuXHQgKiBAcGFyYW0gcHJlZGljdGVkQWx0IFRoZSBhbHRlcm5hdGl2ZSBudW1iZXIgZm9yIHRoZSBkZWNpc2lvbiB3aGljaCBpc1xyXG5cdCAqIGd1YXJkZWQgYnkgdGhlIHNlbWFudGljIGNvbnRleHQgYHNlbWN0eGAuIFNlZSB7QGxpbmsgI3ByZWRpY3RlZEFsdH1cclxuXHQgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuXHQgKlxyXG5cdCAqIEBzZWUgUGFyc2VyQVROU2ltdWxhdG9yI2V2YWxTZW1hbnRpY0NvbnRleHQoU2VtYW50aWNDb250ZXh0LCBQYXJzZXJSdWxlQ29udGV4dCwgaW50KVxyXG5cdCAqIEBzZWUgU2VtYW50aWNDb250ZXh0I2V2YWwoUmVjb2duaXplciwgUnVsZUNvbnRleHQpXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRATm90TnVsbCBzdGF0ZTogU2ltdWxhdG9yU3RhdGUsXHJcblx0XHRkZWNpc2lvbjogbnVtYmVyLFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IFRva2VuU3RyZWFtLFxyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyLFxyXG5cdFx0c3RvcEluZGV4OiBudW1iZXIsXHJcblx0XHRATm90TnVsbCBzZW1jdHg6IFNlbWFudGljQ29udGV4dCxcclxuXHRcdGV2YWxSZXN1bHQ6IGJvb2xlYW4sXHJcblx0XHRwcmVkaWN0ZWRBbHQ6IG51bWJlcikge1xyXG5cclxuXHRcdHN1cGVyKGRlY2lzaW9uLCBzdGF0ZSwgaW5wdXQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgc3RhdGUudXNlQ29udGV4dCk7XHJcblx0XHR0aGlzLnNlbWN0eCA9IHNlbWN0eDtcclxuXHRcdHRoaXMuZXZhbFJlc3VsdCA9IGV2YWxSZXN1bHQ7XHJcblx0XHR0aGlzLnByZWRpY3RlZEFsdCA9IHByZWRpY3RlZEFsdDtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjM2LjQxODgzNTItMDc6MDBcclxuXHJcbmltcG9ydCB7IEFtYmlndWl0eUluZm8gfSBmcm9tIFwiLi9BbWJpZ3VpdHlJbmZvXCI7XHJcbmltcG9ydCB7IEFUTiB9IGZyb20gXCIuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5Db25maWdTZXQgfSBmcm9tIFwiLi9BVE5Db25maWdTZXRcIjtcclxuaW1wb3J0IHsgQVROU2ltdWxhdG9yIH0gZnJvbSBcIi4vQVROU2ltdWxhdG9yXCI7XHJcbmltcG9ydCB7IEJpdFNldCB9IGZyb20gXCIuLi9taXNjL0JpdFNldFwiO1xyXG5pbXBvcnQgeyBDb250ZXh0U2Vuc2l0aXZpdHlJbmZvIH0gZnJvbSBcIi4vQ29udGV4dFNlbnNpdGl2aXR5SW5mb1wiO1xyXG5pbXBvcnQgeyBEZWNpc2lvbkluZm8gfSBmcm9tIFwiLi9EZWNpc2lvbkluZm9cIjtcclxuaW1wb3J0IHsgREZBIH0gZnJvbSBcIi4uL2RmYS9ERkFcIjtcclxuaW1wb3J0IHsgREZBU3RhdGUgfSBmcm9tIFwiLi4vZGZhL0RGQVN0YXRlXCI7XHJcbmltcG9ydCB7IEVycm9ySW5mbyB9IGZyb20gXCIuL0Vycm9ySW5mb1wiO1xyXG5pbXBvcnQgeyBOb3ROdWxsLCBPdmVycmlkZSB9IGZyb20gXCIuLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IExvb2thaGVhZEV2ZW50SW5mbyB9IGZyb20gXCIuL0xvb2thaGVhZEV2ZW50SW5mb1wiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IFBhcnNlckFUTlNpbXVsYXRvciB9IGZyb20gXCIuL1BhcnNlckFUTlNpbXVsYXRvclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBQcmVkaWNhdGVFdmFsSW5mbyB9IGZyb20gXCIuL1ByZWRpY2F0ZUV2YWxJbmZvXCI7XHJcbmltcG9ydCB7IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUgfSBmcm9tIFwiLi9QcmVkaWN0aW9uQ29udGV4dENhY2hlXCI7XHJcbmltcG9ydCB7IFNlbWFudGljQ29udGV4dCB9IGZyb20gXCIuL1NlbWFudGljQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBTaW11bGF0b3JTdGF0ZSB9IGZyb20gXCIuL1NpbXVsYXRvclN0YXRlXCI7XHJcbmltcG9ydCB7IFRva2VuU3RyZWFtIH0gZnJvbSBcIi4uL1Rva2VuU3RyZWFtXCI7XHJcblxyXG4vKipcclxuICogQHNpbmNlIDQuM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFByb2ZpbGluZ0FUTlNpbXVsYXRvciBleHRlbmRzIFBhcnNlckFUTlNpbXVsYXRvciB7XHJcblx0cHJvdGVjdGVkIGRlY2lzaW9uczogRGVjaXNpb25JbmZvW107XHJcblx0cHJvdGVjdGVkIG51bURlY2lzaW9uczogbnVtYmVyO1xyXG5cclxuXHRwcm90ZWN0ZWQgX2lucHV0OiBUb2tlblN0cmVhbSB8IHVuZGVmaW5lZDtcclxuXHRwcm90ZWN0ZWQgX3N0YXJ0SW5kZXg6IG51bWJlciA9IDA7XHJcblx0cHJvdGVjdGVkIF9zbGxTdG9wSW5kZXg6IG51bWJlciA9IDA7XHJcblx0cHJvdGVjdGVkIF9sbFN0b3BJbmRleDogbnVtYmVyID0gMDtcclxuXHJcblx0cHJvdGVjdGVkIGN1cnJlbnREZWNpc2lvbjogbnVtYmVyID0gMDtcclxuXHRwcm90ZWN0ZWQgY3VycmVudFN0YXRlOiBTaW11bGF0b3JTdGF0ZSB8IHVuZGVmaW5lZDtcclxuXHJcblx0LyoqIEF0IHRoZSBwb2ludCBvZiBMTCBmYWlsb3Zlciwgd2UgcmVjb3JkIGhvdyBTTEwgd291bGQgcmVzb2x2ZSB0aGUgY29uZmxpY3Qgc28gdGhhdFxyXG5cdCAqICB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGEgZGVjaXNpb24gLyBpbnB1dCBwYWlyIGlzIGNvbnRleHQtc2Vuc2l0aXZlLlxyXG5cdCAqICBJZiBMTCBnaXZlcyBhIGRpZmZlcmVudCByZXN1bHQgdGhhbiBTTEwncyBwcmVkaWN0ZWQgYWx0ZXJuYXRpdmUsIHdlIGhhdmUgYVxyXG5cdCAqICBjb250ZXh0IHNlbnNpdGl2aXR5IGZvciBzdXJlLiBUaGUgY29udmVyc2UgaXMgbm90IG5lY2Vzc2FyaWx5IHRydWUsIGhvd2V2ZXIuXHJcblx0ICogIEl0J3MgcG9zc2libGUgdGhhdCBhZnRlciBjb25mbGljdCByZXNvbHV0aW9uIGNob29zZXMgbWluaW11bSBhbHRlcm5hdGl2ZXMsXHJcblx0ICogIFNMTCBjb3VsZCBnZXQgdGhlIHNhbWUgYW5zd2VyIGFzIExMLiBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSByZXN1bHQgaW5kaWNhdGVzXHJcblx0ICogIGFuIGFtYmlndWl0eSwgaXQgaXMgbm90IHRyZWF0ZWQgYXMgYSBjb250ZXh0IHNlbnNpdGl2aXR5IGJlY2F1c2UgTEwgcHJlZGljdGlvblxyXG5cdCAqICB3YXMgbm90IHJlcXVpcmVkIGluIG9yZGVyIHRvIHByb2R1Y2UgYSBjb3JyZWN0IHByZWRpY3Rpb24gZm9yIHRoaXMgZGVjaXNpb24gYW5kIGlucHV0IHNlcXVlbmNlLlxyXG5cdCAqICBJdCBtYXkgaW4gZmFjdCBzdGlsbCBiZSBhIGNvbnRleHQgc2Vuc2l0aXZpdHkgYnV0IHdlIGRvbid0IGtub3cgYnkgbG9va2luZyBhdCB0aGVcclxuXHQgKiAgbWluaW11bSBhbHRlcm5hdGl2ZXMgZm9yIHRoZSBjdXJyZW50IGlucHV0LlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBjb25mbGljdGluZ0FsdFJlc29sdmVkQnlTTEw6IG51bWJlciA9IDA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHBhcnNlcjogUGFyc2VyKSB7XHJcblx0XHRzdXBlcihwYXJzZXIuaW50ZXJwcmV0ZXIuYXRuLCBwYXJzZXIpO1xyXG5cdFx0dGhpcy5vcHRpbWl6ZV9sbDEgPSBmYWxzZTtcclxuXHRcdHRoaXMucmVwb3J0QW1iaWd1aXRpZXMgPSB0cnVlO1xyXG5cdFx0dGhpcy5udW1EZWNpc2lvbnMgPSB0aGlzLmF0bi5kZWNpc2lvblRvU3RhdGUubGVuZ3RoO1xyXG5cdFx0dGhpcy5kZWNpc2lvbnMgPSBbXTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1EZWNpc2lvbnM7IGkrKykge1xyXG5cdFx0XHR0aGlzLmRlY2lzaW9ucy5wdXNoKG5ldyBEZWNpc2lvbkluZm8oaSkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGFkYXB0aXZlUHJlZGljdCgvKkBOb3ROdWxsKi8gaW5wdXQ6IFRva2VuU3RyZWFtLCBkZWNpc2lvbjogbnVtYmVyLCBvdXRlckNvbnRleHQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkKTogbnVtYmVyO1xyXG5cdHB1YmxpYyBhZGFwdGl2ZVByZWRpY3QoLypATm90TnVsbCovIGlucHV0OiBUb2tlblN0cmVhbSwgZGVjaXNpb246IG51bWJlciwgb3V0ZXJDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgdXNlQ29udGV4dDogYm9vbGVhbik6IG51bWJlcjtcclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgYWRhcHRpdmVQcmVkaWN0KFxyXG5cdFx0QE5vdE51bGwgaW5wdXQ6IFRva2VuU3RyZWFtLFxyXG5cdFx0ZGVjaXNpb246IG51bWJlcixcclxuXHRcdG91dGVyQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsXHJcblx0XHR1c2VDb250ZXh0PzogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRpZiAodXNlQ29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiBzdXBlci5hZGFwdGl2ZVByZWRpY3QoaW5wdXQsIGRlY2lzaW9uLCBvdXRlckNvbnRleHQsIHVzZUNvbnRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHRoaXMuX2lucHV0ID0gaW5wdXQ7XHJcblx0XHRcdHRoaXMuX3N0YXJ0SW5kZXggPSBpbnB1dC5pbmRleDtcclxuXHRcdFx0Ly8gaXQncyBwb3NzaWJsZSBmb3IgU0xMIHRvIHJlYWNoIGEgY29uZmxpY3Qgc3RhdGUgd2l0aG91dCBjb25zdW1pbmcgYW55IGlucHV0XHJcblx0XHRcdHRoaXMuX3NsbFN0b3BJbmRleCA9IHRoaXMuX3N0YXJ0SW5kZXggLSAxO1xyXG5cdFx0XHR0aGlzLl9sbFN0b3BJbmRleCA9IC0xO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnREZWNpc2lvbiA9IGRlY2lzaW9uO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTdGF0ZSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0dGhpcy5jb25mbGljdGluZ0FsdFJlc29sdmVkQnlTTEwgPSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xyXG5cdFx0XHRsZXQgc3RhcnQ6IG51bWJlcltdID0gcHJvY2Vzcy5ocnRpbWUoKTtcclxuXHRcdFx0bGV0IGFsdDogbnVtYmVyID0gc3VwZXIuYWRhcHRpdmVQcmVkaWN0KGlucHV0LCBkZWNpc2lvbiwgb3V0ZXJDb250ZXh0KTtcclxuXHRcdFx0bGV0IHN0b3A6IG51bWJlcltdID0gcHJvY2Vzcy5ocnRpbWUoKTtcclxuXHJcblx0XHRcdGxldCBuYW5vc2Vjb25kczogbnVtYmVyID0gKHN0b3BbMF0gLSBzdGFydFswXSkgKiAxMDAwMDAwMDAwO1xyXG5cdFx0XHRpZiAobmFub3NlY29uZHMgPT09IDApIHtcclxuXHRcdFx0XHRuYW5vc2Vjb25kcyA9IHN0b3BbMV0gLSBzdGFydFsxXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBBZGQgbmFub3NlY29uZHMgZnJvbSBzdGFydCB0byBlbmQgb2YgdGhhdCBzZWNvbmQsIHBsdXMgc3RhcnQgb2YgdGhlIGVuZCBzZWNvbmQgdG8gZW5kXHJcblx0XHRcdFx0bmFub3NlY29uZHMgKz0gKDEwMDAwMDAwMDAgLSBzdGFydFsxXSkgKyBzdG9wWzFdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0udGltZUluUHJlZGljdGlvbiArPSBuYW5vc2Vjb25kcztcclxuXHRcdFx0dGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLmludm9jYXRpb25zKys7XHJcblxyXG5cdFx0XHRsZXQgU0xMX2s6IG51bWJlciA9IHRoaXMuX3NsbFN0b3BJbmRleCAtIHRoaXMuX3N0YXJ0SW5kZXggKyAxO1xyXG5cdFx0XHR0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0uU0xMX1RvdGFsTG9vayArPSBTTExfaztcclxuXHRcdFx0dGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9NaW5Mb29rID0gdGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9NaW5Mb29rID09PSAwID8gU0xMX2sgOiBNYXRoLm1pbih0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0uU0xMX01pbkxvb2ssIFNMTF9rKTtcclxuXHRcdFx0aWYgKFNMTF9rID4gdGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9NYXhMb29rKSB7XHJcblx0XHRcdFx0dGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9NYXhMb29rID0gU0xMX2s7XHJcblx0XHRcdFx0dGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9NYXhMb29rRXZlbnQgPVxyXG5cdFx0XHRcdFx0bmV3IExvb2thaGVhZEV2ZW50SW5mbyhkZWNpc2lvbiwgdW5kZWZpbmVkLCBhbHQsIGlucHV0LCB0aGlzLl9zdGFydEluZGV4LCB0aGlzLl9zbGxTdG9wSW5kZXgsIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXMuX2xsU3RvcEluZGV4ID49IDApIHtcclxuXHRcdFx0XHRsZXQgTExfazogbnVtYmVyID0gdGhpcy5fbGxTdG9wSW5kZXggLSB0aGlzLl9zdGFydEluZGV4ICsgMTtcclxuXHRcdFx0XHR0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0uTExfVG90YWxMb29rICs9IExMX2s7XHJcblx0XHRcdFx0dGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLkxMX01pbkxvb2sgPSB0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0uTExfTWluTG9vayA9PT0gMCA/IExMX2sgOiBNYXRoLm1pbih0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0uTExfTWluTG9vaywgTExfayk7XHJcblx0XHRcdFx0aWYgKExMX2sgPiB0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0uTExfTWF4TG9vaykge1xyXG5cdFx0XHRcdFx0dGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLkxMX01heExvb2sgPSBMTF9rO1xyXG5cdFx0XHRcdFx0dGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLkxMX01heExvb2tFdmVudCA9XHJcblx0XHRcdFx0XHRcdG5ldyBMb29rYWhlYWRFdmVudEluZm8oZGVjaXNpb24sIHVuZGVmaW5lZCwgYWx0LCBpbnB1dCwgdGhpcy5fc3RhcnRJbmRleCwgdGhpcy5fbGxTdG9wSW5kZXgsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGFsdDtcclxuXHRcdH1cclxuXHRcdGZpbmFsbHkge1xyXG5cdFx0XHR0aGlzLl9pbnB1dCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0dGhpcy5jdXJyZW50RGVjaXNpb24gPSAtMTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCBnZXRTdGFydFN0YXRlKGRmYTogREZBLCBpbnB1dDogVG9rZW5TdHJlYW0sIG91dGVyQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQsIHVzZUNvbnRleHQ6IGJvb2xlYW4pOiBTaW11bGF0b3JTdGF0ZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRsZXQgc3RhdGU6IFNpbXVsYXRvclN0YXRlIHwgdW5kZWZpbmVkID0gc3VwZXIuZ2V0U3RhcnRTdGF0ZShkZmEsIGlucHV0LCBvdXRlckNvbnRleHQsIHVzZUNvbnRleHQpO1xyXG5cdFx0dGhpcy5jdXJyZW50U3RhdGUgPSBzdGF0ZTtcclxuXHRcdHJldHVybiBzdGF0ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCBjb21wdXRlU3RhcnRTdGF0ZShkZmE6IERGQSwgZ2xvYmFsQ29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQsIHVzZUNvbnRleHQ6IGJvb2xlYW4pOiBTaW11bGF0b3JTdGF0ZSB7XHJcblx0XHRsZXQgc3RhdGU6IFNpbXVsYXRvclN0YXRlID0gc3VwZXIuY29tcHV0ZVN0YXJ0U3RhdGUoZGZhLCBnbG9iYWxDb250ZXh0LCB1c2VDb250ZXh0KTtcclxuXHRcdHRoaXMuY3VycmVudFN0YXRlID0gc3RhdGU7XHJcblx0XHRyZXR1cm4gc3RhdGU7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgY29tcHV0ZVJlYWNoU2V0KGRmYTogREZBLCBwcmV2aW91czogU2ltdWxhdG9yU3RhdGUsIHQ6IG51bWJlciwgY29udGV4dENhY2hlOiBQcmVkaWN0aW9uQ29udGV4dENhY2hlKTogU2ltdWxhdG9yU3RhdGUgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKHRoaXMuX2lucHV0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVhY2hTdGF0ZTogU2ltdWxhdG9yU3RhdGUgfCB1bmRlZmluZWQgPSBzdXBlci5jb21wdXRlUmVhY2hTZXQoZGZhLCBwcmV2aW91cywgdCwgY29udGV4dENhY2hlKTtcclxuXHRcdGlmIChyZWFjaFN0YXRlID09IG51bGwpIHtcclxuXHRcdFx0Ly8gbm8gcmVhY2ggb24gY3VycmVudCBsb29rYWhlYWQgc3ltYm9sLiBFUlJPUi5cclxuXHRcdFx0dGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLmVycm9ycy5wdXNoKFxyXG5cdFx0XHRcdG5ldyBFcnJvckluZm8odGhpcy5jdXJyZW50RGVjaXNpb24sIHByZXZpb3VzLCB0aGlzLl9pbnB1dCwgdGhpcy5fc3RhcnRJbmRleCwgdGhpcy5faW5wdXQuaW5kZXgpLFxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY3VycmVudFN0YXRlID0gcmVhY2hTdGF0ZTtcclxuXHRcdHJldHVybiByZWFjaFN0YXRlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIGdldEV4aXN0aW5nVGFyZ2V0U3RhdGUocHJldmlvdXNEOiBERkFTdGF0ZSwgdDogbnVtYmVyKTogREZBU3RhdGUgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKHRoaXMuY3VycmVudFN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5faW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBhZnRlciBlYWNoIHRpbWUgdGhlIGlucHV0IHBvc2l0aW9uIGFkdmFuY2VzXHJcblx0XHRpZiAodGhpcy5jdXJyZW50U3RhdGUudXNlQ29udGV4dCkge1xyXG5cdFx0XHR0aGlzLl9sbFN0b3BJbmRleCA9IHRoaXMuX2lucHV0LmluZGV4O1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuX3NsbFN0b3BJbmRleCA9IHRoaXMuX2lucHV0LmluZGV4O1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBleGlzdGluZ1RhcmdldFN0YXRlOiBERkFTdGF0ZSB8IHVuZGVmaW5lZCA9IHN1cGVyLmdldEV4aXN0aW5nVGFyZ2V0U3RhdGUocHJldmlvdXNELCB0KTtcclxuXHRcdGlmIChleGlzdGluZ1RhcmdldFN0YXRlICE9IG51bGwpIHtcclxuXHRcdFx0Ly8gdGhpcyBtZXRob2QgaXMgZGlyZWN0bHkgY2FsbGVkIGJ5IGV4ZWNERkE7IG11c3QgY29uc3RydWN0IGEgU2ltdWxhdG9yU3RhdGVcclxuXHRcdFx0Ly8gdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHN0YXRlIGZvciB0aGlzIGNhc2VcclxuXHRcdFx0dGhpcy5jdXJyZW50U3RhdGUgPSBuZXcgU2ltdWxhdG9yU3RhdGUodGhpcy5jdXJyZW50U3RhdGUub3V0ZXJDb250ZXh0LCBleGlzdGluZ1RhcmdldFN0YXRlLCB0aGlzLmN1cnJlbnRTdGF0ZS51c2VDb250ZXh0LCB0aGlzLmN1cnJlbnRTdGF0ZS5yZW1haW5pbmdPdXRlckNvbnRleHQpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFN0YXRlLnVzZUNvbnRleHQpIHtcclxuXHRcdFx0XHR0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uTExfREZBVHJhbnNpdGlvbnMrKztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uU0xMX0RGQVRyYW5zaXRpb25zKys7IC8vIGNvdW50IG9ubHkgaWYgd2UgdHJhbnNpdGlvbiBvdmVyIGEgREZBIHN0YXRlXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChleGlzdGluZ1RhcmdldFN0YXRlID09PSBBVE5TaW11bGF0b3IuRVJST1IpIHtcclxuXHRcdFx0XHRsZXQgc3RhdGU6IFNpbXVsYXRvclN0YXRlID0gbmV3IFNpbXVsYXRvclN0YXRlKHRoaXMuY3VycmVudFN0YXRlLm91dGVyQ29udGV4dCwgcHJldmlvdXNELCB0aGlzLmN1cnJlbnRTdGF0ZS51c2VDb250ZXh0LCB0aGlzLmN1cnJlbnRTdGF0ZS5yZW1haW5pbmdPdXRlckNvbnRleHQpO1xyXG5cdFx0XHRcdHRoaXMuZGVjaXNpb25zW3RoaXMuY3VycmVudERlY2lzaW9uXS5lcnJvcnMucHVzaChcclxuXHRcdFx0XHRcdG5ldyBFcnJvckluZm8odGhpcy5jdXJyZW50RGVjaXNpb24sIHN0YXRlLCB0aGlzLl9pbnB1dCwgdGhpcy5fc3RhcnRJbmRleCwgdGhpcy5faW5wdXQuaW5kZXgpLFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXhpc3RpbmdUYXJnZXRTdGF0ZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCBjb21wdXRlVGFyZ2V0U3RhdGUoZGZhOiBERkEsIHM6IERGQVN0YXRlLCByZW1haW5pbmdHbG9iYWxDb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCwgdDogbnVtYmVyLCB1c2VDb250ZXh0OiBib29sZWFuLCBjb250ZXh0Q2FjaGU6IFByZWRpY3Rpb25Db250ZXh0Q2FjaGUpOiBbREZBU3RhdGUsIFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkXSB7XHJcblx0XHRsZXQgdGFyZ2V0U3RhdGU6IFtERkFTdGF0ZSwgUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWRdID0gc3VwZXIuY29tcHV0ZVRhcmdldFN0YXRlKGRmYSwgcywgcmVtYWluaW5nR2xvYmFsQ29udGV4dCwgdCwgdXNlQ29udGV4dCwgY29udGV4dENhY2hlKTtcclxuXHJcblx0XHRpZiAodXNlQ29udGV4dCkge1xyXG5cdFx0XHR0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uTExfQVROVHJhbnNpdGlvbnMrKztcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uU0xMX0FUTlRyYW5zaXRpb25zKys7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldFN0YXRlO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIGV2YWxTZW1hbnRpY0NvbnRleHRJbXBsKHByZWQ6IFNlbWFudGljQ29udGV4dCwgcGFyc2VyQ2FsbFN0YWNrOiBQYXJzZXJSdWxlQ29udGV4dCwgYWx0OiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2lucHV0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVzdWx0OiBib29sZWFuID0gc3VwZXIuZXZhbFNlbWFudGljQ29udGV4dEltcGwocHJlZCwgcGFyc2VyQ2FsbFN0YWNrLCBhbHQpO1xyXG5cdFx0aWYgKCEocHJlZCBpbnN0YW5jZW9mIFNlbWFudGljQ29udGV4dC5QcmVjZWRlbmNlUHJlZGljYXRlKSkge1xyXG5cdFx0XHRsZXQgZnVsbENvbnRleHQ6IGJvb2xlYW4gPSB0aGlzLl9sbFN0b3BJbmRleCA+PSAwO1xyXG5cdFx0XHRsZXQgc3RvcEluZGV4OiBudW1iZXIgPSBmdWxsQ29udGV4dCA/IHRoaXMuX2xsU3RvcEluZGV4IDogdGhpcy5fc2xsU3RvcEluZGV4O1xyXG5cdFx0XHR0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0ucHJlZGljYXRlRXZhbHMucHVzaChcclxuXHRcdFx0XHRuZXcgUHJlZGljYXRlRXZhbEluZm8odGhpcy5jdXJyZW50U3RhdGUsIHRoaXMuY3VycmVudERlY2lzaW9uLCB0aGlzLl9pbnB1dCwgdGhpcy5fc3RhcnRJbmRleCwgc3RvcEluZGV4LCBwcmVkLCByZXN1bHQsIGFsdCksXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHByb3RlY3RlZCByZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkoZGZhOiBERkEsIHByZWRpY3Rpb246IG51bWJlciwgYWNjZXB0U3RhdGU6IFNpbXVsYXRvclN0YXRlLCBzdGFydEluZGV4OiBudW1iZXIsIHN0b3BJbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5faW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcmVkaWN0aW9uICE9PSB0aGlzLmNvbmZsaWN0aW5nQWx0UmVzb2x2ZWRCeVNMTCkge1xyXG5cdFx0XHR0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uY29udGV4dFNlbnNpdGl2aXRpZXMucHVzaChcclxuXHRcdFx0XHRuZXcgQ29udGV4dFNlbnNpdGl2aXR5SW5mbyh0aGlzLmN1cnJlbnREZWNpc2lvbiwgYWNjZXB0U3RhdGUsIHRoaXMuX2lucHV0LCBzdGFydEluZGV4LCBzdG9wSW5kZXgpLFxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdFx0c3VwZXIucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KGRmYSwgcHJlZGljdGlvbiwgYWNjZXB0U3RhdGUsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgcmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KGRmYTogREZBLCBjb25mbGljdGluZ0FsdHM6IEJpdFNldCwgY29uZmxpY3RTdGF0ZTogU2ltdWxhdG9yU3RhdGUsIHN0YXJ0SW5kZXg6IG51bWJlciwgc3RvcEluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmIChjb25mbGljdGluZ0FsdHMgIT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLmNvbmZsaWN0aW5nQWx0UmVzb2x2ZWRCeVNMTCA9IGNvbmZsaWN0aW5nQWx0cy5uZXh0U2V0Qml0KDApO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuY29uZmxpY3RpbmdBbHRSZXNvbHZlZEJ5U0xMID0gY29uZmxpY3RTdGF0ZS5zMC5jb25maWdzLmdldFJlcHJlc2VudGVkQWx0ZXJuYXRpdmVzKCkubmV4dFNldEJpdCgwKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZGVjaXNpb25zW3RoaXMuY3VycmVudERlY2lzaW9uXS5MTF9GYWxsYmFjaysrO1xyXG5cdFx0c3VwZXIucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KGRmYSwgY29uZmxpY3RpbmdBbHRzLCBjb25mbGljdFN0YXRlLCBzdGFydEluZGV4LCBzdG9wSW5kZXgpO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIHJlcG9ydEFtYmlndWl0eShATm90TnVsbCBkZmE6IERGQSwgRDogREZBU3RhdGUsIHN0YXJ0SW5kZXg6IG51bWJlciwgc3RvcEluZGV4OiBudW1iZXIsIGV4YWN0OiBib29sZWFuLCBATm90TnVsbCBhbWJpZ0FsdHM6IEJpdFNldCwgQE5vdE51bGwgY29uZmlnczogQVROQ29uZmlnU2V0KTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9pbnB1dCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGVcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHByZWRpY3Rpb246IG51bWJlcjtcclxuXHRcdGlmIChhbWJpZ0FsdHMgIT0gbnVsbCkge1xyXG5cdFx0XHRwcmVkaWN0aW9uID0gYW1iaWdBbHRzLm5leHRTZXRCaXQoMCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0cHJlZGljdGlvbiA9IGNvbmZpZ3MuZ2V0UmVwcmVzZW50ZWRBbHRlcm5hdGl2ZXMoKS5uZXh0U2V0Qml0KDApO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuY29uZmxpY3RpbmdBbHRSZXNvbHZlZEJ5U0xMICE9PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSICYmIHByZWRpY3Rpb24gIT09IHRoaXMuY29uZmxpY3RpbmdBbHRSZXNvbHZlZEJ5U0xMKSB7XHJcblx0XHRcdC8vIEV2ZW4gdGhvdWdoIHRoaXMgaXMgYW4gYW1iaWd1aXR5IHdlIGFyZSByZXBvcnRpbmcsIHdlIGNhblxyXG5cdFx0XHQvLyBzdGlsbCBkZXRlY3Qgc29tZSBjb250ZXh0IHNlbnNpdGl2aXRpZXMuICBCb3RoIFNMTCBhbmQgTExcclxuXHRcdFx0Ly8gYXJlIHNob3dpbmcgYSBjb25mbGljdCwgaGVuY2UgYW4gYW1iaWd1aXR5LCBidXQgaWYgdGhleSByZXNvbHZlXHJcblx0XHRcdC8vIHRvIGRpZmZlcmVudCBtaW5pbXVtIGFsdGVybmF0aXZlcyB3ZSBoYXZlIGFsc28gaWRlbnRpZmllZCBhXHJcblx0XHRcdC8vIGNvbnRleHQgc2Vuc2l0aXZpdHkuXHJcblx0XHRcdHRoaXMuZGVjaXNpb25zW3RoaXMuY3VycmVudERlY2lzaW9uXS5jb250ZXh0U2Vuc2l0aXZpdGllcy5wdXNoKFxyXG5cdFx0XHRcdG5ldyBDb250ZXh0U2Vuc2l0aXZpdHlJbmZvKHRoaXMuY3VycmVudERlY2lzaW9uLCB0aGlzLmN1cnJlbnRTdGF0ZSwgdGhpcy5faW5wdXQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCksXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uYW1iaWd1aXRpZXMucHVzaChcclxuXHRcdFx0bmV3IEFtYmlndWl0eUluZm8odGhpcy5jdXJyZW50RGVjaXNpb24sIHRoaXMuY3VycmVudFN0YXRlLCBhbWJpZ0FsdHMsIHRoaXMuX2lucHV0LCBzdGFydEluZGV4LCBzdG9wSW5kZXgpLFxyXG5cdFx0KTtcclxuXHRcdHN1cGVyLnJlcG9ydEFtYmlndWl0eShkZmEsIEQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncyk7XHJcblx0fVxyXG5cclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblx0cHVibGljIGdldERlY2lzaW9uSW5mbygpOiBEZWNpc2lvbkluZm9bXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5kZWNpc2lvbnM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0Q3VycmVudFN0YXRlKCk6IFNpbXVsYXRvclN0YXRlIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRTdGF0ZTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUyLjQzOTkxOTMtMDc6MDBcclxuXHJcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XHJcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gXCIuL21pc2MvVXRpbHNcIjtcclxuXHJcbmltcG9ydCB7IEFOVExSRXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL0FOVExSRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBBTlRMUkVycm9yU3RyYXRlZ3kgfSBmcm9tIFwiLi9BTlRMUkVycm9yU3RyYXRlZ3lcIjtcclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vYXRuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zIH0gZnJvbSBcIi4vYXRuL0FUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnNcIjtcclxuaW1wb3J0IHsgQVRORGVzZXJpYWxpemVyIH0gZnJvbSBcIi4vYXRuL0FUTkRlc2VyaWFsaXplclwiO1xyXG5pbXBvcnQgeyBBVE5TaW11bGF0b3IgfSBmcm9tIFwiLi9hdG4vQVROU2ltdWxhdG9yXCI7XHJcbmltcG9ydCB7IEFUTlN0YXRlIH0gZnJvbSBcIi4vYXRuL0FUTlN0YXRlXCI7XHJcbmltcG9ydCB7IERlZmF1bHRFcnJvclN0cmF0ZWd5IH0gZnJvbSBcIi4vRGVmYXVsdEVycm9yU3RyYXRlZ3lcIjtcclxuaW1wb3J0IHsgREZBIH0gZnJvbSBcIi4vZGZhL0RGQVwiO1xyXG5pbXBvcnQgeyBFcnJvck5vZGUgfSBmcm9tIFwiLi90cmVlL0Vycm9yTm9kZVwiO1xyXG5pbXBvcnQgeyBJbnRlZ2VyU3RhY2sgfSBmcm9tIFwiLi9taXNjL0ludGVnZXJTdGFja1wiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbFNldCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxTZXRcIjtcclxuaW1wb3J0IHsgSW50U3RyZWFtIH0gZnJvbSBcIi4vSW50U3RyZWFtXCI7XHJcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4vTGV4ZXJcIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUsIE5vdE51bGwsIE51bGxhYmxlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZUluZm8gfSBmcm9tIFwiLi9hdG4vUGFyc2VJbmZvXCI7XHJcbmltcG9ydCB7IFBhcnNlckFUTlNpbXVsYXRvciB9IGZyb20gXCIuL2F0bi9QYXJzZXJBVE5TaW11bGF0b3JcIjtcclxuaW1wb3J0IHsgUGFyc2VyRXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL1BhcnNlckVycm9yTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWVMaXN0ZW5lciB9IGZyb20gXCIuL3RyZWUvUGFyc2VUcmVlTGlzdGVuZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlUGF0dGVybiB9IGZyb20gXCIuL3RyZWUvcGF0dGVybi9QYXJzZVRyZWVQYXR0ZXJuXCI7XHJcbmltcG9ydCB7IFByb3h5UGFyc2VyRXJyb3JMaXN0ZW5lciB9IGZyb20gXCIuL1Byb3h5UGFyc2VyRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUnVsZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9hdG4vUnVsZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVGVybWluYWxOb2RlIH0gZnJvbSBcIi4vdHJlZS9UZXJtaW5hbE5vZGVcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBUb2tlbkZhY3RvcnkgfSBmcm9tIFwiLi9Ub2tlbkZhY3RvcnlcIjtcclxuaW1wb3J0IHsgVG9rZW5Tb3VyY2UgfSBmcm9tIFwiLi9Ub2tlblNvdXJjZVwiO1xyXG5pbXBvcnQgeyBUb2tlblN0cmVhbSB9IGZyb20gXCIuL1Rva2VuU3RyZWFtXCI7XHJcblxyXG5jbGFzcyBUcmFjZUxpc3RlbmVyIGltcGxlbWVudHMgUGFyc2VUcmVlTGlzdGVuZXIge1xyXG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgcnVsZU5hbWVzOiBzdHJpbmdbXSwgcHJpdmF0ZSB0b2tlblN0cmVhbTogVG9rZW5TdHJlYW0pIHtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBlbnRlckV2ZXJ5UnVsZShjdHg6IFBhcnNlclJ1bGVDb250ZXh0KTogdm9pZCB7XHJcblx0XHRjb25zb2xlLmxvZyhcImVudGVyICAgXCIgKyB0aGlzLnJ1bGVOYW1lc1tjdHgucnVsZUluZGV4XSArXHJcblx0XHRcdFwiLCBMVCgxKT1cIiArIHRoaXMudG9rZW5TdHJlYW0uTFQoMSkudGV4dCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgZXhpdEV2ZXJ5UnVsZShjdHg6IFBhcnNlclJ1bGVDb250ZXh0KTogdm9pZCB7XHJcblx0XHRjb25zb2xlLmxvZyhcImV4aXQgICAgXCIgKyB0aGlzLnJ1bGVOYW1lc1tjdHgucnVsZUluZGV4XSArXHJcblx0XHRcdFwiLCBMVCgxKT1cIiArIHRoaXMudG9rZW5TdHJlYW0uTFQoMSkudGV4dCk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdmlzaXRFcnJvck5vZGUobm9kZTogRXJyb3JOb2RlKTogdm9pZCB7XHJcblx0XHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdmlzaXRUZXJtaW5hbChub2RlOiBUZXJtaW5hbE5vZGUpOiB2b2lkIHtcclxuXHRcdGxldCBwYXJlbnQgPSBub2RlLnBhcmVudCEucnVsZUNvbnRleHQ7XHJcblx0XHRsZXQgdG9rZW46IFRva2VuID0gbm9kZS5zeW1ib2w7XHJcblx0XHRjb25zb2xlLmxvZyhcImNvbnN1bWUgXCIgKyB0b2tlbiArIFwiIHJ1bGUgXCIgKyB0aGlzLnJ1bGVOYW1lc1twYXJlbnQucnVsZUluZGV4XSk7XHJcblx0fVxyXG59XHJcblxyXG4vKiogVGhpcyBpcyBhbGwgdGhlIHBhcnNpbmcgc3VwcG9ydCBjb2RlIGVzc2VudGlhbGx5OyBtb3N0IG9mIGl0IGlzIGVycm9yIHJlY292ZXJ5IHN0dWZmLiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUGFyc2VyIGV4dGVuZHMgUmVjb2duaXplcjxUb2tlbiwgUGFyc2VyQVROU2ltdWxhdG9yPiB7XHJcblx0LyoqXHJcblx0ICogVGhpcyBmaWVsZCBtYXBzIGZyb20gdGhlIHNlcmlhbGl6ZWQgQVROIHN0cmluZyB0byB0aGUgZGVzZXJpYWxpemVkIHtAbGluayBBVE59IHdpdGhcclxuXHQgKiBieXBhc3MgYWx0ZXJuYXRpdmVzLlxyXG5cdCAqXHJcblx0ICogQHNlZSBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zLmlzR2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnNcclxuXHQgKi9cclxuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBieXBhc3NBbHRzQXRuQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgQVROPigpO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ3kgZm9yIHRoZSBwYXJzZXIuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgbmV3XHJcblx0ICogaW5zdGFuY2Ugb2Yge0BsaW5rIERlZmF1bHRFcnJvclN0cmF0ZWd5fS5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI2dldEVycm9ySGFuZGxlclxyXG5cdCAqIEBzZWUgI3NldEVycm9ySGFuZGxlclxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIF9lcnJIYW5kbGVyOiBBTlRMUkVycm9yU3RyYXRlZ3kgPSBuZXcgRGVmYXVsdEVycm9yU3RyYXRlZ3koKTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGlucHV0IHN0cmVhbS5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI2dldElucHV0U3RyZWFtXHJcblx0ICogQHNlZSAjc2V0SW5wdXRTdHJlYW1cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgX2lucHV0ITogVG9rZW5TdHJlYW07XHJcblxyXG5cdHByb3RlY3RlZCByZWFkb25seSBfcHJlY2VkZW5jZVN0YWNrOiBJbnRlZ2VyU3RhY2sgPSBuZXcgSW50ZWdlclN0YWNrKCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHR9IG9iamVjdCBmb3IgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcnVsZS5cclxuXHQgKlxyXG5cdCAqIFRoaXMgaXMgYWx3YXlzIG5vbi11bmRlZmluZWQgZHVyaW5nIHRoZSBwYXJzaW5nIHByb2Nlc3MuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIF9jdHghOiBQYXJzZXJSdWxlQ29udGV4dDtcclxuXHJcblx0LyoqXHJcblx0ICogU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoZSBwYXJzZXIgc2hvdWxkIGNvbnN0cnVjdCBhIHBhcnNlIHRyZWUgZHVyaW5nXHJcblx0ICogdGhlIHBhcnNpbmcgcHJvY2Vzcy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxyXG5cdCAqXHJcblx0ICogQHNlZSBgYnVpbGRQYXJzZVRyZWVgXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfYnVpbGRQYXJzZVRyZWVzOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcblx0LyoqXHJcblx0ICogV2hlbiB7QGxpbmsgI3NldFRyYWNlfWAodHJ1ZSlgIGlzIGNhbGxlZCwgYSByZWZlcmVuY2UgdG8gdGhlXHJcblx0ICoge0BsaW5rIFRyYWNlTGlzdGVuZXJ9IGlzIHN0b3JlZCBoZXJlIHNvIGl0IGNhbiBiZSBlYXNpbHkgcmVtb3ZlZCBpbiBhXHJcblx0ICogbGF0ZXIgY2FsbCB0byB7QGxpbmsgI3NldFRyYWNlfWAoZmFsc2UpYC4gVGhlIGxpc3RlbmVyIGl0c2VsZiBpc1xyXG5cdCAqIGltcGxlbWVudGVkIGFzIGEgcGFyc2VyIGxpc3RlbmVyIHNvIHRoaXMgZmllbGQgaXMgbm90IGRpcmVjdGx5IHVzZWQgYnlcclxuXHQgKiBvdGhlciBwYXJzZXIgbWV0aG9kcy5cclxuXHQgKi9cclxuXHRwcml2YXRlIF90cmFjZXI6IFRyYWNlTGlzdGVuZXIgfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBsaXN0IG9mIHtAbGluayBQYXJzZVRyZWVMaXN0ZW5lcn0gbGlzdGVuZXJzIHJlZ2lzdGVyZWQgdG8gcmVjZWl2ZVxyXG5cdCAqIGV2ZW50cyBkdXJpbmcgdGhlIHBhcnNlLlxyXG5cdCAqXHJcblx0ICogQHNlZSAjYWRkUGFyc2VMaXN0ZW5lclxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBfcGFyc2VMaXN0ZW5lcnM6IFBhcnNlVHJlZUxpc3RlbmVyW10gPSBbXTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG51bWJlciBvZiBzeW50YXggZXJyb3JzIHJlcG9ydGVkIGR1cmluZyBwYXJzaW5nLiBUaGlzIHZhbHVlIGlzXHJcblx0ICogaW5jcmVtZW50ZWQgZWFjaCB0aW1lIHtAbGluayAjbm90aWZ5RXJyb3JMaXN0ZW5lcnN9IGlzIGNhbGxlZC5cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgX3N5bnRheEVycm9yczogbnVtYmVyID0gMDtcclxuXHJcblx0LyoqIEluZGljYXRlcyBwYXJzZXIgaGFzIG1hdGNoKCllZCBFT0YgdG9rZW4uIFNlZSB7QGxpbmsgI2V4aXRSdWxlKCl9LiAqL1xyXG5cdHByb3RlY3RlZCBtYXRjaGVkRU9GOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGlucHV0OiBUb2tlblN0cmVhbSkge1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMuX3ByZWNlZGVuY2VTdGFjay5wdXNoKDApO1xyXG5cdFx0dGhpcy5pbnB1dFN0cmVhbSA9IGlucHV0O1xyXG5cdH1cclxuXHJcblx0LyoqIHJlc2V0IHRoZSBwYXJzZXIncyBzdGF0ZSAqL1xyXG5cdHB1YmxpYyByZXNldCgpOiB2b2lkO1xyXG5cdHB1YmxpYyByZXNldChyZXNldElucHV0OiBib29sZWFuKTogdm9pZDtcclxuXHRwdWJsaWMgcmVzZXQocmVzZXRJbnB1dD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdC8vIE5vdGU6IHRoaXMgbWV0aG9kIGV4ZWN1dGVzIHdoZW4gbm90IHBhcnNpbmcsIHNvIF9jdHggY2FuIGJlIHVuZGVmaW5lZFxyXG5cdFx0aWYgKHJlc2V0SW5wdXQgPT09IHVuZGVmaW5lZCB8fCByZXNldElucHV0KSB7XHJcblx0XHRcdHRoaXMuaW5wdXRTdHJlYW0uc2VlaygwKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlc2V0KHRoaXMpO1xyXG5cdFx0dGhpcy5fY3R4ID0gdW5kZWZpbmVkIGFzIGFueTtcclxuXHRcdHRoaXMuX3N5bnRheEVycm9ycyA9IDA7XHJcblx0XHR0aGlzLm1hdGNoZWRFT0YgPSBmYWxzZTtcclxuXHRcdHRoaXMuaXNUcmFjZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fcHJlY2VkZW5jZVN0YWNrLmNsZWFyKCk7XHJcblx0XHR0aGlzLl9wcmVjZWRlbmNlU3RhY2sucHVzaCgwKTtcclxuXHRcdGxldCBpbnRlcnByZXRlcjogQVROU2ltdWxhdG9yID0gdGhpcy5pbnRlcnByZXRlcjtcclxuXHRcdGlmIChpbnRlcnByZXRlciAhPSBudWxsKSB7XHJcblx0XHRcdGludGVycHJldGVyLnJlc2V0KCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBNYXRjaCBjdXJyZW50IGlucHV0IHN5bWJvbCBhZ2FpbnN0IGB0dHlwZWAuIElmIHRoZSBzeW1ib2wgdHlwZVxyXG5cdCAqIG1hdGNoZXMsIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3kjcmVwb3J0TWF0Y2h9IGFuZCB7QGxpbmsgI2NvbnN1bWV9IGFyZVxyXG5cdCAqIGNhbGxlZCB0byBjb21wbGV0ZSB0aGUgbWF0Y2ggcHJvY2Vzcy5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSBzeW1ib2wgdHlwZSBkb2VzIG5vdCBtYXRjaCxcclxuXHQgKiB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5I3JlY292ZXJJbmxpbmV9IGlzIGNhbGxlZCBvbiB0aGUgY3VycmVudCBlcnJvclxyXG5cdCAqIHN0cmF0ZWd5IHRvIGF0dGVtcHQgcmVjb3ZlcnkuIElmIHtAbGluayAjZ2V0QnVpbGRQYXJzZVRyZWV9IGlzXHJcblx0ICogYHRydWVgIGFuZCB0aGUgdG9rZW4gaW5kZXggb2YgdGhlIHN5bWJvbCByZXR1cm5lZCBieVxyXG5cdCAqIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3kjcmVjb3ZlcklubGluZX0gaXMgLTEsIHRoZSBzeW1ib2wgaXMgYWRkZWQgdG9cclxuXHQgKiB0aGUgcGFyc2UgdHJlZSBieSBjYWxsaW5nIHtAbGluayAjY3JlYXRlRXJyb3JOb2RlKFBhcnNlclJ1bGVDb250ZXh0LCBUb2tlbil9IHRoZW5cclxuXHQgKiB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHQjYWRkRXJyb3JOb2RlKEVycm9yTm9kZSl9LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHR0eXBlIHRoZSB0b2tlbiB0eXBlIHRvIG1hdGNoXHJcblx0ICogQHJldHVybnMgdGhlIG1hdGNoZWQgc3ltYm9sXHJcblx0ICogQCBpZiB0aGUgY3VycmVudCBpbnB1dCBzeW1ib2wgZGlkIG5vdCBtYXRjaFxyXG5cdCAqIGB0dHlwZWAgYW5kIHRoZSBlcnJvciBzdHJhdGVneSBjb3VsZCBub3QgcmVjb3ZlciBmcm9tIHRoZVxyXG5cdCAqIG1pc21hdGNoZWQgc3ltYm9sXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgbWF0Y2godHR5cGU6IG51bWJlcik6IFRva2VuIHtcclxuXHRcdGxldCB0OiBUb2tlbiA9IHRoaXMuY3VycmVudFRva2VuO1xyXG5cdFx0aWYgKHQudHlwZSA9PT0gdHR5cGUpIHtcclxuXHRcdFx0aWYgKHR0eXBlID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0XHR0aGlzLm1hdGNoZWRFT0YgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XHJcblx0XHRcdHRoaXMuY29uc3VtZSgpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHQgPSB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XHJcblx0XHRcdGlmICh0aGlzLl9idWlsZFBhcnNlVHJlZXMgJiYgdC50b2tlbkluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRcdC8vIHdlIG11c3QgaGF2ZSBjb25qdXJlZCB1cCBhIG5ldyB0b2tlbiBkdXJpbmcgc2luZ2xlIHRva2VuIGluc2VydGlvblxyXG5cdFx0XHRcdC8vIGlmIGl0J3Mgbm90IHRoZSBjdXJyZW50IHN5bWJvbFxyXG5cdFx0XHRcdHRoaXMuX2N0eC5hZGRFcnJvck5vZGUodGhpcy5jcmVhdGVFcnJvck5vZGUodGhpcy5fY3R4LCB0KSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTWF0Y2ggY3VycmVudCBpbnB1dCBzeW1ib2wgYXMgYSB3aWxkY2FyZC4gSWYgdGhlIHN5bWJvbCB0eXBlIG1hdGNoZXNcclxuXHQgKiAoaS5lLiBoYXMgYSB2YWx1ZSBncmVhdGVyIHRoYW4gMCksIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3kjcmVwb3J0TWF0Y2h9XHJcblx0ICogYW5kIHtAbGluayAjY29uc3VtZX0gYXJlIGNhbGxlZCB0byBjb21wbGV0ZSB0aGUgbWF0Y2ggcHJvY2Vzcy5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSBzeW1ib2wgdHlwZSBkb2VzIG5vdCBtYXRjaCxcclxuXHQgKiB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5I3JlY292ZXJJbmxpbmV9IGlzIGNhbGxlZCBvbiB0aGUgY3VycmVudCBlcnJvclxyXG5cdCAqIHN0cmF0ZWd5IHRvIGF0dGVtcHQgcmVjb3ZlcnkuIElmIHtAbGluayAjZ2V0QnVpbGRQYXJzZVRyZWV9IGlzXHJcblx0ICogYHRydWVgIGFuZCB0aGUgdG9rZW4gaW5kZXggb2YgdGhlIHN5bWJvbCByZXR1cm5lZCBieVxyXG5cdCAqIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3kjcmVjb3ZlcklubGluZX0gaXMgLTEsIHRoZSBzeW1ib2wgaXMgYWRkZWQgdG9cclxuXHQgKiB0aGUgcGFyc2UgdHJlZSBieSBjYWxsaW5nIHtAbGluayBQYXJzZXIjY3JlYXRlRXJyb3JOb2RlKFBhcnNlclJ1bGVDb250ZXh0LCBUb2tlbil9IHRoZW5cclxuXHQgKiB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHQjYWRkRXJyb3JOb2RlKEVycm9yTm9kZSl9LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgdGhlIG1hdGNoZWQgc3ltYm9sXHJcblx0ICogQCBpZiB0aGUgY3VycmVudCBpbnB1dCBzeW1ib2wgZGlkIG5vdCBtYXRjaFxyXG5cdCAqIGEgd2lsZGNhcmQgYW5kIHRoZSBlcnJvciBzdHJhdGVneSBjb3VsZCBub3QgcmVjb3ZlciBmcm9tIHRoZSBtaXNtYXRjaGVkXHJcblx0ICogc3ltYm9sXHJcblx0ICovXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgbWF0Y2hXaWxkY2FyZCgpOiBUb2tlbiB7XHJcblx0XHRsZXQgdDogVG9rZW4gPSB0aGlzLmN1cnJlbnRUb2tlbjtcclxuXHRcdGlmICh0LnR5cGUgPiAwKSB7XHJcblx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XHJcblx0XHRcdHRoaXMuY29uc3VtZSgpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHQgPSB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XHJcblx0XHRcdGlmICh0aGlzLl9idWlsZFBhcnNlVHJlZXMgJiYgdC50b2tlbkluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRcdC8vIHdlIG11c3QgaGF2ZSBjb25qdXJlZCB1cCBhIG5ldyB0b2tlbiBkdXJpbmcgc2luZ2xlIHRva2VuIGluc2VydGlvblxyXG5cdFx0XHRcdC8vIGlmIGl0J3Mgbm90IHRoZSBjdXJyZW50IHN5bWJvbFxyXG5cdFx0XHRcdHRoaXMuX2N0eC5hZGRFcnJvck5vZGUodGhpcy5jcmVhdGVFcnJvck5vZGUodGhpcy5fY3R4LCB0KSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRyYWNrIHRoZSB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHR9IG9iamVjdHMgZHVyaW5nIHRoZSBwYXJzZSBhbmQgaG9va1xyXG5cdCAqIHRoZW0gdXAgdXNpbmcgdGhlIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dCNjaGlsZHJlbn0gbGlzdCBzbyB0aGF0IGl0XHJcblx0ICogZm9ybXMgYSBwYXJzZSB0cmVlLiBUaGUge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0fSByZXR1cm5lZCBmcm9tIHRoZSBzdGFydFxyXG5cdCAqIHJ1bGUgcmVwcmVzZW50cyB0aGUgcm9vdCBvZiB0aGUgcGFyc2UgdHJlZS5cclxuXHQgKlxyXG5cdCAqIE5vdGUgdGhhdCBpZiB3ZSBhcmUgbm90IGJ1aWxkaW5nIHBhcnNlIHRyZWVzLCBydWxlIGNvbnRleHRzIG9ubHkgcG9pbnRcclxuXHQgKiB1cHdhcmRzLiBXaGVuIGEgcnVsZSBleGl0cywgaXQgcmV0dXJucyB0aGUgY29udGV4dCBidXQgdGhhdCBnZXRzIGdhcmJhZ2VcclxuXHQgKiBjb2xsZWN0ZWQgaWYgbm9ib2R5IGhvbGRzIGEgcmVmZXJlbmNlLiBJdCBwb2ludHMgdXB3YXJkcyBidXQgbm9ib2R5XHJcblx0ICogcG9pbnRzIGF0IGl0LlxyXG5cdCAqXHJcblx0ICogV2hlbiB3ZSBidWlsZCBwYXJzZSB0cmVlcywgd2UgYXJlIGFkZGluZyBhbGwgb2YgdGhlc2UgY29udGV4dHMgdG9cclxuXHQgKiB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHQjY2hpbGRyZW59IGxpc3QuIENvbnRleHRzIGFyZSB0aGVuIG5vdCBjYW5kaWRhdGVzXHJcblx0ICogZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cclxuXHQgKi9cclxuXHRzZXQgYnVpbGRQYXJzZVRyZWUoYnVpbGRQYXJzZVRyZWVzOiBib29sZWFuKSB7XHJcblx0XHR0aGlzLl9idWlsZFBhcnNlVHJlZXMgPSBidWlsZFBhcnNlVHJlZXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHdoZXRoZXIgb3Igbm90IGEgY29tcGxldGUgcGFyc2UgdHJlZSB3aWxsIGJlIGNvbnN0cnVjdGVkIHdoaWxlXHJcblx0ICogcGFyc2luZy4gVGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAgZm9yIGEgbmV3bHkgY29uc3RydWN0ZWQgcGFyc2VyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgYHRydWVgIGlmIGEgY29tcGxldGUgcGFyc2UgdHJlZSB3aWxsIGJlIGNvbnN0cnVjdGVkIHdoaWxlXHJcblx0ICogcGFyc2luZywgb3RoZXJ3aXNlIGBmYWxzZWBcclxuXHQgKi9cclxuXHRnZXQgYnVpbGRQYXJzZVRyZWUoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYnVpbGRQYXJzZVRyZWVzO1xyXG5cdH1cclxuXHJcblx0QE5vdE51bGxcclxuXHRwdWJsaWMgZ2V0UGFyc2VMaXN0ZW5lcnMoKTogUGFyc2VUcmVlTGlzdGVuZXJbXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFyc2VMaXN0ZW5lcnM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWdpc3RlcnMgYGxpc3RlbmVyYCB0byByZWNlaXZlIGV2ZW50cyBkdXJpbmcgdGhlIHBhcnNpbmcgcHJvY2Vzcy5cclxuXHQgKlxyXG5cdCAqIFRvIHN1cHBvcnQgb3V0cHV0LXByZXNlcnZpbmcgZ3JhbW1hciB0cmFuc2Zvcm1hdGlvbnMgKGluY2x1ZGluZyBidXQgbm90XHJcblx0ICogbGltaXRlZCB0byBsZWZ0LXJlY3Vyc2lvbiByZW1vdmFsLCBhdXRvbWF0ZWQgbGVmdC1mYWN0b3JpbmcsIGFuZFxyXG5cdCAqIG9wdGltaXplZCBjb2RlIGdlbmVyYXRpb24pLCBjYWxscyB0byBsaXN0ZW5lciBtZXRob2RzIGR1cmluZyB0aGUgcGFyc2VcclxuXHQgKiBtYXkgZGlmZmVyIHN1YnN0YW50aWFsbHkgZnJvbSBjYWxscyBtYWRlIGJ5XHJcblx0ICoge0BsaW5rIFBhcnNlVHJlZVdhbGtlciNERUZBVUxUfSB1c2VkIGFmdGVyIHRoZSBwYXJzZSBpcyBjb21wbGV0ZS4gSW5cclxuXHQgKiBwYXJ0aWN1bGFyLCBydWxlIGVudHJ5IGFuZCBleGl0IGV2ZW50cyBtYXkgb2NjdXIgaW4gYSBkaWZmZXJlbnQgb3JkZXJcclxuXHQgKiBkdXJpbmcgdGhlIHBhcnNlIHRoYW4gYWZ0ZXIgdGhlIHBhcnNlci4gSW4gYWRkaXRpb24sIGNhbGxzIHRvIGNlcnRhaW5cclxuXHQgKiBydWxlIGVudHJ5IG1ldGhvZHMgbWF5IGJlIG9taXR0ZWQuXHJcblx0ICpcclxuXHQgKiBXaXRoIHRoZSBmb2xsb3dpbmcgc3BlY2lmaWMgZXhjZXB0aW9ucywgY2FsbHMgdG8gbGlzdGVuZXIgZXZlbnRzIGFyZVxyXG5cdCAqICpkZXRlcm1pbmlzdGljKiwgaS5lLiBmb3IgaWRlbnRpY2FsIGlucHV0IHRoZSBjYWxscyB0byBsaXN0ZW5lclxyXG5cdCAqIG1ldGhvZHMgd2lsbCBiZSB0aGUgc2FtZS5cclxuXHQgKlxyXG5cdCAqICogQWx0ZXJhdGlvbnMgdG8gdGhlIGdyYW1tYXIgdXNlZCB0byBnZW5lcmF0ZSBjb2RlIG1heSBjaGFuZ2UgdGhlXHJcblx0ICogICBiZWhhdmlvciBvZiB0aGUgbGlzdGVuZXIgY2FsbHMuXHJcblx0ICogKiBBbHRlcmF0aW9ucyB0byB0aGUgY29tbWFuZCBsaW5lIG9wdGlvbnMgcGFzc2VkIHRvIEFOVExSIDQgd2hlblxyXG5cdCAqICAgZ2VuZXJhdGluZyB0aGUgcGFyc2VyIG1heSBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHRoZSBsaXN0ZW5lciBjYWxscy5cclxuXHQgKiAqIENoYW5naW5nIHRoZSB2ZXJzaW9uIG9mIHRoZSBBTlRMUiBUb29sIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHBhcnNlclxyXG5cdCAqICAgbWF5IGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgdGhlIGxpc3RlbmVyIGNhbGxzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byBhZGRcclxuXHQgKlxyXG5cdCAqIEB0aHJvd3Mge0BsaW5rIFR5cGVFcnJvcn0gaWYgYGxpc3RlbmVyYCBpcyBgdW5kZWZpbmVkYFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBhZGRQYXJzZUxpc3RlbmVyKEBOb3ROdWxsIGxpc3RlbmVyOiBQYXJzZVRyZWVMaXN0ZW5lcik6IHZvaWQge1xyXG5cdFx0aWYgKGxpc3RlbmVyID09IG51bGwpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcImxpc3RlbmVyIGNhbm5vdCBiZSBudWxsXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BhcnNlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIGBsaXN0ZW5lcmAgZnJvbSB0aGUgbGlzdCBvZiBwYXJzZSBsaXN0ZW5lcnMuXHJcblx0ICpcclxuXHQgKiBJZiBgbGlzdGVuZXJgIGlzIGB1bmRlZmluZWRgIG9yIGhhcyBub3QgYmVlbiBhZGRlZCBhcyBhIHBhcnNlXHJcblx0ICogbGlzdGVuZXIsIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI2FkZFBhcnNlTGlzdGVuZXJcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgdG8gcmVtb3ZlXHJcblx0ICovXHJcblx0cHVibGljIHJlbW92ZVBhcnNlTGlzdGVuZXIobGlzdGVuZXI6IFBhcnNlVHJlZUxpc3RlbmVyKTogdm9pZCB7XHJcblx0XHRsZXQgaW5kZXggPSB0aGlzLl9wYXJzZUxpc3RlbmVycy5maW5kSW5kZXgoKGwpID0+IGwgPT09IGxpc3RlbmVyKTtcclxuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcclxuXHRcdFx0dGhpcy5fcGFyc2VMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgYWxsIHBhcnNlIGxpc3RlbmVycy5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI2FkZFBhcnNlTGlzdGVuZXJcclxuXHQgKi9cclxuXHRwdWJsaWMgcmVtb3ZlUGFyc2VMaXN0ZW5lcnMoKTogdm9pZCB7XHJcblx0XHR0aGlzLl9wYXJzZUxpc3RlbmVycy5sZW5ndGggPSAwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTm90aWZ5IGFueSBwYXJzZSBsaXN0ZW5lcnMgb2YgYW4gZW50ZXIgcnVsZSBldmVudC5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI2FkZFBhcnNlTGlzdGVuZXJcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgdHJpZ2dlckVudGVyUnVsZUV2ZW50KCk6IHZvaWQge1xyXG5cdFx0Zm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fcGFyc2VMaXN0ZW5lcnMpIHtcclxuXHRcdFx0aWYgKGxpc3RlbmVyLmVudGVyRXZlcnlSdWxlKSB7XHJcblx0XHRcdFx0bGlzdGVuZXIuZW50ZXJFdmVyeVJ1bGUodGhpcy5fY3R4KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fY3R4LmVudGVyUnVsZShsaXN0ZW5lcik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBOb3RpZnkgYW55IHBhcnNlIGxpc3RlbmVycyBvZiBhbiBleGl0IHJ1bGUgZXZlbnQuXHJcblx0ICpcclxuXHQgKiBAc2VlICNhZGRQYXJzZUxpc3RlbmVyXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHRyaWdnZXJFeGl0UnVsZUV2ZW50KCk6IHZvaWQge1xyXG5cdFx0Ly8gcmV2ZXJzZSBvcmRlciB3YWxrIG9mIGxpc3RlbmVyc1xyXG5cdFx0Zm9yIChsZXQgaSA9IHRoaXMuX3BhcnNlTGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGxldCBsaXN0ZW5lcjogUGFyc2VUcmVlTGlzdGVuZXIgPSB0aGlzLl9wYXJzZUxpc3RlbmVyc1tpXTtcclxuXHRcdFx0dGhpcy5fY3R4LmV4aXRSdWxlKGxpc3RlbmVyKTtcclxuXHRcdFx0aWYgKGxpc3RlbmVyLmV4aXRFdmVyeVJ1bGUpIHtcclxuXHRcdFx0XHRsaXN0ZW5lci5leGl0RXZlcnlSdWxlKHRoaXMuX2N0eCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIG51bWJlciBvZiBzeW50YXggZXJyb3JzIHJlcG9ydGVkIGR1cmluZyBwYXJzaW5nLiBUaGlzIHZhbHVlIGlzXHJcblx0ICogaW5jcmVtZW50ZWQgZWFjaCB0aW1lIHtAbGluayAjbm90aWZ5RXJyb3JMaXN0ZW5lcnN9IGlzIGNhbGxlZC5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI25vdGlmeUVycm9yTGlzdGVuZXJzXHJcblx0ICovXHJcblx0Z2V0IG51bWJlck9mU3ludGF4RXJyb3JzKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc3ludGF4RXJyb3JzO1xyXG5cdH1cclxuXHJcblx0Z2V0IHRva2VuRmFjdG9yeSgpOiBUb2tlbkZhY3Rvcnkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2lucHV0LnRva2VuU291cmNlLnRva2VuRmFjdG9yeTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBBVE4gd2l0aCBieXBhc3MgYWx0ZXJuYXRpdmVzIGlzIGV4cGVuc2l2ZSB0byBjcmVhdGUgc28gd2UgY3JlYXRlIGl0XHJcblx0ICogbGF6aWx5LlxyXG5cdCAqXHJcblx0ICogQCBpZiB0aGUgY3VycmVudCBwYXJzZXIgZG9lcyBub3RcclxuXHQgKiBpbXBsZW1lbnQgdGhlIGBzZXJpYWxpemVkQVROYCBwcm9wZXJ0eS5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRBVE5XaXRoQnlwYXNzQWx0cygpOiBBVE4ge1xyXG5cdFx0bGV0IHNlcmlhbGl6ZWRBdG46IHN0cmluZyA9IHRoaXMuc2VyaWFsaXplZEFUTjtcclxuXHRcdGlmIChzZXJpYWxpemVkQXRuID09IG51bGwpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgcGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgYW4gQVROIHdpdGggYnlwYXNzIGFsdGVybmF0aXZlcy5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJlc3VsdCA9IFBhcnNlci5ieXBhc3NBbHRzQXRuQ2FjaGUuZ2V0KHNlcmlhbGl6ZWRBdG4pO1xyXG5cdFx0aWYgKHJlc3VsdCA9PSBudWxsKSB7XHJcblx0XHRcdGxldCBkZXNlcmlhbGl6YXRpb25PcHRpb25zOiBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zID0gbmV3IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMoKTtcclxuXHRcdFx0ZGVzZXJpYWxpemF0aW9uT3B0aW9ucy5pc0dlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zID0gdHJ1ZTtcclxuXHRcdFx0cmVzdWx0ID0gbmV3IEFUTkRlc2VyaWFsaXplcihkZXNlcmlhbGl6YXRpb25PcHRpb25zKS5kZXNlcmlhbGl6ZShVdGlscy50b0NoYXJBcnJheShzZXJpYWxpemVkQXRuKSk7XHJcblx0XHRcdFBhcnNlci5ieXBhc3NBbHRzQXRuQ2FjaGUuc2V0KHNlcmlhbGl6ZWRBdG4sIHJlc3VsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBwcmVmZXJyZWQgbWV0aG9kIG9mIGdldHRpbmcgYSB0cmVlIHBhdHRlcm4uIEZvciBleGFtcGxlLCBoZXJlJ3MgYVxyXG5cdCAqIHNhbXBsZSB1c2U6XHJcblx0ICpcclxuXHQgKiBgYGBcclxuXHQgKiBsZXQgdDogUGFyc2VUcmVlID0gcGFyc2VyLmV4cHIoKTtcclxuXHQgKiBsZXQgcDogUGFyc2VUcmVlUGF0dGVybiA9IGF3YWl0IHBhcnNlci5jb21waWxlUGFyc2VUcmVlUGF0dGVybihcIjxJRD4rMFwiLCBNeVBhcnNlci5SVUxFX2V4cHIpO1xyXG5cdCAqIGxldCBtOiBQYXJzZVRyZWVNYXRjaCA9IHAubWF0Y2godCk7XHJcblx0ICogbGV0IGlkOiBzdHJpbmcgPSBtLmdldChcIklEXCIpO1xyXG5cdCAqIGBgYFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjb21waWxlUGFyc2VUcmVlUGF0dGVybihwYXR0ZXJuOiBzdHJpbmcsIHBhdHRlcm5SdWxlSW5kZXg6IG51bWJlcik6IFByb21pc2U8UGFyc2VUcmVlUGF0dGVybj47XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBzYW1lIGFzIHtAbGluayAjY29tcGlsZVBhcnNlVHJlZVBhdHRlcm4oU3RyaW5nLCBpbnQpfSBidXQgc3BlY2lmeSBhXHJcblx0ICoge0BsaW5rIExleGVyfSByYXRoZXIgdGhhbiB0cnlpbmcgdG8gZGVkdWNlIGl0IGZyb20gdGhpcyBwYXJzZXIuXHJcblx0ICovXHJcblx0cHVibGljIGNvbXBpbGVQYXJzZVRyZWVQYXR0ZXJuKHBhdHRlcm46IHN0cmluZywgcGF0dGVyblJ1bGVJbmRleDogbnVtYmVyLCBsZXhlcj86IExleGVyKTogUHJvbWlzZTxQYXJzZVRyZWVQYXR0ZXJuPjtcclxuXHJcblx0cHVibGljIGFzeW5jIGNvbXBpbGVQYXJzZVRyZWVQYXR0ZXJuKHBhdHRlcm46IHN0cmluZywgcGF0dGVyblJ1bGVJbmRleDogbnVtYmVyLCBsZXhlcj86IExleGVyKTogUHJvbWlzZTxQYXJzZVRyZWVQYXR0ZXJuPiB7XHJcblx0XHRpZiAoIWxleGVyKSB7XHJcblx0XHRcdGlmICh0aGlzLmlucHV0U3RyZWFtKSB7XHJcblx0XHRcdFx0bGV0IHRva2VuU291cmNlID0gdGhpcy5pbnB1dFN0cmVhbS50b2tlblNvdXJjZTtcclxuXHRcdFx0XHRpZiAodG9rZW5Tb3VyY2UgaW5zdGFuY2VvZiBMZXhlcikge1xyXG5cdFx0XHRcdFx0bGV4ZXIgPSB0b2tlblNvdXJjZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghbGV4ZXIpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZXIgY2FuJ3QgZGlzY292ZXIgYSBsZXhlciB0byB1c2VcIik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgY3VycmVudExleGVyID0gbGV4ZXI7XHJcblx0XHRsZXQgbSA9IGF3YWl0IGltcG9ydChcIi4vdHJlZS9wYXR0ZXJuL1BhcnNlVHJlZVBhdHRlcm5NYXRjaGVyXCIpO1xyXG5cdFx0bGV0IG1hdGNoZXIgPSBuZXcgbS5QYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcihjdXJyZW50TGV4ZXIsIHRoaXMpO1xyXG5cdFx0cmV0dXJuIG1hdGNoZXIuY29tcGlsZShwYXR0ZXJuLCBwYXR0ZXJuUnVsZUluZGV4KTtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGVycm9ySGFuZGxlcigpOiBBTlRMUkVycm9yU3RyYXRlZ3kge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2VyckhhbmRsZXI7XHJcblx0fVxyXG5cclxuXHRzZXQgZXJyb3JIYW5kbGVyKEBOb3ROdWxsIGhhbmRsZXI6IEFOVExSRXJyb3JTdHJhdGVneSkge1xyXG5cdFx0dGhpcy5fZXJySGFuZGxlciA9IGhhbmRsZXI7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgaW5wdXRTdHJlYW0oKTogVG9rZW5TdHJlYW0ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2lucHV0O1xyXG5cdH1cclxuXHJcblx0LyoqIFNldCB0aGUgdG9rZW4gc3RyZWFtIGFuZCByZXNldCB0aGUgcGFyc2VyLiAqL1xyXG5cdHNldCBpbnB1dFN0cmVhbShpbnB1dDogVG9rZW5TdHJlYW0pIHtcclxuXHRcdHRoaXMucmVzZXQoZmFsc2UpO1xyXG5cdFx0dGhpcy5faW5wdXQgPSBpbnB1dDtcclxuXHR9XHJcblxyXG5cdC8qKiBNYXRjaCBuZWVkcyB0byByZXR1cm4gdGhlIGN1cnJlbnQgaW5wdXQgc3ltYm9sLCB3aGljaCBnZXRzIHB1dFxyXG5cdCAqICBpbnRvIHRoZSBsYWJlbCBmb3IgdGhlIGFzc29jaWF0ZWQgdG9rZW4gcmVmOyBlLmcuLCB4PUlELlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0Z2V0IGN1cnJlbnRUb2tlbigpOiBUb2tlbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW5wdXQuTFQoMSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgbm90aWZ5RXJyb3JMaXN0ZW5lcnMoLypATm90TnVsbCovIG1zZzogc3RyaW5nKTogdm9pZDtcclxuXHRwdWJsaWMgbm90aWZ5RXJyb3JMaXN0ZW5lcnMoLypATm90TnVsbCovIG1zZzogc3RyaW5nLCAvKkBOb3ROdWxsKi8gb2ZmZW5kaW5nVG9rZW46IFRva2VuIHwgbnVsbCwgZTogUmVjb2duaXRpb25FeGNlcHRpb24gfCB1bmRlZmluZWQpOiB2b2lkO1xyXG5cclxuXHRwdWJsaWMgbm90aWZ5RXJyb3JMaXN0ZW5lcnMobXNnOiBzdHJpbmcsIG9mZmVuZGluZ1Rva2VuPzogVG9rZW4gfCBudWxsLCBlPzogUmVjb2duaXRpb25FeGNlcHRpb24gfCB1bmRlZmluZWQpOiB2b2lkIHtcclxuXHRcdGlmIChvZmZlbmRpbmdUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG9mZmVuZGluZ1Rva2VuID0gdGhpcy5jdXJyZW50VG9rZW47XHJcblx0XHR9IGVsc2UgaWYgKG9mZmVuZGluZ1Rva2VuID09PSBudWxsKSB7XHJcblx0XHRcdG9mZmVuZGluZ1Rva2VuID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N5bnRheEVycm9ycysrO1xyXG5cdFx0bGV0IGxpbmU6IG51bWJlciA9IC0xO1xyXG5cdFx0bGV0IGNoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyID0gLTE7XHJcblx0XHRpZiAob2ZmZW5kaW5nVG9rZW4gIT0gbnVsbCkge1xyXG5cdFx0XHRsaW5lID0gb2ZmZW5kaW5nVG9rZW4ubGluZTtcclxuXHRcdFx0Y2hhclBvc2l0aW9uSW5MaW5lID0gb2ZmZW5kaW5nVG9rZW4uY2hhclBvc2l0aW9uSW5MaW5lO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBsaXN0ZW5lciA9IHRoaXMuZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCk7XHJcblx0XHRpZiAobGlzdGVuZXIuc3ludGF4RXJyb3IpIHtcclxuXHRcdFx0bGlzdGVuZXIuc3ludGF4RXJyb3IodGhpcywgb2ZmZW5kaW5nVG9rZW4sIGxpbmUsIGNoYXJQb3NpdGlvbkluTGluZSwgbXNnLCBlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN1bWUgYW5kIHJldHVybiB0aGUgW2N1cnJlbnQgc3ltYm9sXShgY3VycmVudFRva2VuYCkuXHJcblx0ICpcclxuXHQgKiBFLmcuLCBnaXZlbiB0aGUgZm9sbG93aW5nIGlucHV0IHdpdGggYEFgIGJlaW5nIHRoZSBjdXJyZW50XHJcblx0ICogbG9va2FoZWFkIHN5bWJvbCwgdGhpcyBmdW5jdGlvbiBtb3ZlcyB0aGUgY3Vyc29yIHRvIGBCYCBhbmQgcmV0dXJuc1xyXG5cdCAqIGBBYC5cclxuXHQgKlxyXG5cdCAqIGBgYFxyXG5cdCAqIEEgQlxyXG5cdCAqIF5cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIElmIHRoZSBwYXJzZXIgaXMgbm90IGluIGVycm9yIHJlY292ZXJ5IG1vZGUsIHRoZSBjb25zdW1lZCBzeW1ib2wgaXMgYWRkZWRcclxuXHQgKiB0byB0aGUgcGFyc2UgdHJlZSB1c2luZyB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHQjYWRkQ2hpbGQoVGVybWluYWxOb2RlKX0sIGFuZFxyXG5cdCAqIHtAbGluayBQYXJzZVRyZWVMaXN0ZW5lciN2aXNpdFRlcm1pbmFsfSBpcyBjYWxsZWQgb24gYW55IHBhcnNlIGxpc3RlbmVycy5cclxuXHQgKiBJZiB0aGUgcGFyc2VyICppcyogaW4gZXJyb3IgcmVjb3ZlcnkgbW9kZSwgdGhlIGNvbnN1bWVkIHN5bWJvbCBpc1xyXG5cdCAqIGFkZGVkIHRvIHRoZSBwYXJzZSB0cmVlIHVzaW5nIHtAbGluayAjY3JlYXRlRXJyb3JOb2RlKFBhcnNlclJ1bGVDb250ZXh0LCBUb2tlbil9IHRoZW5cclxuXHQgKiB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHQjYWRkRXJyb3JOb2RlKEVycm9yTm9kZSl9IGFuZFxyXG5cdCAqIHtAbGluayBQYXJzZVRyZWVMaXN0ZW5lciN2aXNpdEVycm9yTm9kZX0gaXMgY2FsbGVkIG9uIGFueSBwYXJzZVxyXG5cdCAqIGxpc3RlbmVycy5cclxuXHQgKi9cclxuXHRwdWJsaWMgY29uc3VtZSgpOiBUb2tlbiB7XHJcblx0XHRsZXQgbzogVG9rZW4gPSB0aGlzLmN1cnJlbnRUb2tlbjtcclxuXHRcdGlmIChvLnR5cGUgIT09IFBhcnNlci5FT0YpIHtcclxuXHRcdFx0dGhpcy5pbnB1dFN0cmVhbS5jb25zdW1lKCk7XHJcblx0XHR9XHJcblx0XHRsZXQgaGFzTGlzdGVuZXI6IGJvb2xlYW4gPSB0aGlzLl9wYXJzZUxpc3RlbmVycy5sZW5ndGggIT09IDA7XHJcblx0XHRpZiAodGhpcy5fYnVpbGRQYXJzZVRyZWVzIHx8IGhhc0xpc3RlbmVyKSB7XHJcblx0XHRcdGlmICh0aGlzLl9lcnJIYW5kbGVyLmluRXJyb3JSZWNvdmVyeU1vZGUodGhpcykpIHtcclxuXHRcdFx0XHRsZXQgbm9kZTogRXJyb3JOb2RlID0gdGhpcy5fY3R4LmFkZEVycm9yTm9kZSh0aGlzLmNyZWF0ZUVycm9yTm9kZSh0aGlzLl9jdHgsIG8pKTtcclxuXHRcdFx0XHRpZiAoaGFzTGlzdGVuZXIpIHtcclxuXHRcdFx0XHRcdGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3BhcnNlTGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0XHRcdGlmIChsaXN0ZW5lci52aXNpdEVycm9yTm9kZSkge1xyXG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLnZpc2l0RXJyb3JOb2RlKG5vZGUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGxldCBub2RlOiBUZXJtaW5hbE5vZGUgPSB0aGlzLmNyZWF0ZVRlcm1pbmFsTm9kZSh0aGlzLl9jdHgsIG8pO1xyXG5cdFx0XHRcdHRoaXMuX2N0eC5hZGRDaGlsZChub2RlKTtcclxuXHRcdFx0XHRpZiAoaGFzTGlzdGVuZXIpIHtcclxuXHRcdFx0XHRcdGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3BhcnNlTGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0XHRcdGlmIChsaXN0ZW5lci52aXNpdFRlcm1pbmFsKSB7XHJcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIudmlzaXRUZXJtaW5hbChub2RlKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG87XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBIb3cgdG8gY3JlYXRlIGEgdG9rZW4gbGVhZiBub2RlIGFzc29jaWF0ZWQgd2l0aCBhIHBhcmVudC5cclxuXHQgKiBUeXBpY2FsbHksIHRoZSB0ZXJtaW5hbCBub2RlIHRvIGNyZWF0ZSBpcyBub3QgYSBmdW5jdGlvbiBvZiB0aGUgcGFyZW50LlxyXG5cdCAqXHJcblx0ICogQHNpbmNlIDQuN1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBjcmVhdGVUZXJtaW5hbE5vZGUocGFyZW50OiBQYXJzZXJSdWxlQ29udGV4dCwgdDogVG9rZW4pOiBUZXJtaW5hbE5vZGUge1xyXG5cdFx0cmV0dXJuIG5ldyBUZXJtaW5hbE5vZGUodCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBIb3cgdG8gY3JlYXRlIGFuIGVycm9yIG5vZGUsIGdpdmVuIGEgdG9rZW4sIGFzc29jaWF0ZWQgd2l0aCBhIHBhcmVudC5cclxuXHQgKiBUeXBpY2FsbHksIHRoZSBlcnJvciBub2RlIHRvIGNyZWF0ZSBpcyBub3QgYSBmdW5jdGlvbiBvZiB0aGUgcGFyZW50LlxyXG5cdCAqXHJcblx0ICogQHNpbmNlIDQuN1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBjcmVhdGVFcnJvck5vZGUocGFyZW50OiBQYXJzZXJSdWxlQ29udGV4dCwgdDogVG9rZW4pOiBFcnJvck5vZGUge1xyXG5cdFx0cmV0dXJuIG5ldyBFcnJvck5vZGUodCk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgYWRkQ29udGV4dFRvUGFyc2VUcmVlKCk6IHZvaWQge1xyXG5cdFx0bGV0IHBhcmVudCA9IHRoaXMuX2N0eC5fcGFyZW50IGFzIFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkO1xyXG5cdFx0Ly8gYWRkIGN1cnJlbnQgY29udGV4dCB0byBwYXJlbnQgaWYgd2UgaGF2ZSBhIHBhcmVudFxyXG5cdFx0aWYgKHBhcmVudCAhPSBudWxsKSB7XHJcblx0XHRcdHBhcmVudC5hZGRDaGlsZCh0aGlzLl9jdHgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWx3YXlzIGNhbGxlZCBieSBnZW5lcmF0ZWQgcGFyc2VycyB1cG9uIGVudHJ5IHRvIGEgcnVsZS4gQWNjZXNzIGZpZWxkXHJcblx0ICoge0BsaW5rICNfY3R4fSBnZXQgdGhlIGN1cnJlbnQgY29udGV4dC5cclxuXHQgKi9cclxuXHRwdWJsaWMgZW50ZXJSdWxlKEBOb3ROdWxsIGxvY2FsY3R4OiBQYXJzZXJSdWxlQ29udGV4dCwgc3RhdGU6IG51bWJlciwgcnVsZUluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHRcdHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xyXG5cdFx0dGhpcy5fY3R4Ll9zdGFydCA9IHRoaXMuX2lucHV0LkxUKDEpO1xyXG5cdFx0aWYgKHRoaXMuX2J1aWxkUGFyc2VUcmVlcykge1xyXG5cdFx0XHR0aGlzLmFkZENvbnRleHRUb1BhcnNlVHJlZSgpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJSdWxlRXZlbnQoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBlbnRlckxlZnRGYWN0b3JlZFJ1bGUobG9jYWxjdHg6IFBhcnNlclJ1bGVDb250ZXh0LCBzdGF0ZTogbnVtYmVyLCBydWxlSW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cdFx0aWYgKHRoaXMuX2J1aWxkUGFyc2VUcmVlcykge1xyXG5cdFx0XHRsZXQgZmFjdG9yZWRDb250ZXh0ID0gdGhpcy5fY3R4LmdldENoaWxkKHRoaXMuX2N0eC5jaGlsZENvdW50IC0gMSkgYXMgUGFyc2VyUnVsZUNvbnRleHQ7XHJcblx0XHRcdHRoaXMuX2N0eC5yZW1vdmVMYXN0Q2hpbGQoKTtcclxuXHRcdFx0ZmFjdG9yZWRDb250ZXh0Ll9wYXJlbnQgPSBsb2NhbGN0eDtcclxuXHRcdFx0bG9jYWxjdHguYWRkQ2hpbGQoZmFjdG9yZWRDb250ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jdHggPSBsb2NhbGN0eDtcclxuXHRcdHRoaXMuX2N0eC5fc3RhcnQgPSB0aGlzLl9pbnB1dC5MVCgxKTtcclxuXHRcdGlmICh0aGlzLl9idWlsZFBhcnNlVHJlZXMpIHtcclxuXHRcdFx0dGhpcy5hZGRDb250ZXh0VG9QYXJzZVRyZWUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnRyaWdnZXJFbnRlclJ1bGVFdmVudCgpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGV4aXRSdWxlKCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMubWF0Y2hlZEVPRikge1xyXG5cdFx0XHQvLyBpZiB3ZSBoYXZlIG1hdGNoZWQgRU9GLCBpdCBjYW5ub3QgY29uc3VtZSBwYXN0IEVPRiBzbyB3ZSB1c2UgTFQoMSkgaGVyZVxyXG5cdFx0XHR0aGlzLl9jdHguX3N0b3AgPSB0aGlzLl9pbnB1dC5MVCgxKTsgLy8gTFQoMSkgd2lsbCBiZSBlbmQgb2YgZmlsZVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuX2N0eC5fc3RvcCA9IHRoaXMuX2lucHV0LnRyeUxUKC0xKTsgLy8gc3RvcCBub2RlIGlzIHdoYXQgd2UganVzdCBtYXRjaGVkXHJcblx0XHR9XHJcblx0XHQvLyB0cmlnZ2VyIGV2ZW50IG9uIF9jdHgsIGJlZm9yZSBpdCByZXZlcnRzIHRvIHBhcmVudFxyXG5cdFx0dGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuX2N0eC5pbnZva2luZ1N0YXRlO1xyXG5cdFx0dGhpcy5fY3R4ID0gdGhpcy5fY3R4Ll9wYXJlbnQgYXMgUGFyc2VyUnVsZUNvbnRleHQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZW50ZXJPdXRlckFsdChsb2NhbGN0eDogUGFyc2VyUnVsZUNvbnRleHQsIGFsdE51bTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRsb2NhbGN0eC5hbHROdW1iZXIgPSBhbHROdW07XHJcblx0XHQvLyBpZiB3ZSBoYXZlIG5ldyBsb2NhbGN0eCwgbWFrZSBzdXJlIHdlIHJlcGxhY2UgZXhpc3RpbmcgY3R4XHJcblx0XHQvLyB0aGF0IGlzIHByZXZpb3VzIGNoaWxkIG9mIHBhcnNlIHRyZWVcclxuXHRcdGlmICh0aGlzLl9idWlsZFBhcnNlVHJlZXMgJiYgdGhpcy5fY3R4ICE9PSBsb2NhbGN0eCkge1xyXG5cdFx0XHRsZXQgcGFyZW50ID0gdGhpcy5fY3R4Ll9wYXJlbnQgYXMgUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQ7XHJcblx0XHRcdGlmIChwYXJlbnQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdHBhcmVudC5yZW1vdmVMYXN0Q2hpbGQoKTtcclxuXHRcdFx0XHRwYXJlbnQuYWRkQ2hpbGQobG9jYWxjdHgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLl9jdHggPSBsb2NhbGN0eDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgcHJlY2VkZW5jZSBsZXZlbCBmb3IgdGhlIHRvcC1tb3N0IHByZWNlZGVuY2UgcnVsZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBwcmVjZWRlbmNlIGxldmVsIGZvciB0aGUgdG9wLW1vc3QgcHJlY2VkZW5jZSBydWxlLCBvciAtMSBpZlxyXG5cdCAqIHRoZSBwYXJzZXIgY29udGV4dCBpcyBub3QgbmVzdGVkIHdpdGhpbiBhIHByZWNlZGVuY2UgcnVsZS5cclxuXHQgKi9cclxuXHRnZXQgcHJlY2VkZW5jZSgpOiBudW1iZXIge1xyXG5cdFx0aWYgKHRoaXMuX3ByZWNlZGVuY2VTdGFjay5pc0VtcHR5KSB7XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fcHJlY2VkZW5jZVN0YWNrLnBlZWsoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBlbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHg6IFBhcnNlclJ1bGVDb250ZXh0LCBzdGF0ZTogbnVtYmVyLCBydWxlSW5kZXg6IG51bWJlciwgcHJlY2VkZW5jZTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XHJcblx0XHR0aGlzLl9wcmVjZWRlbmNlU3RhY2sucHVzaChwcmVjZWRlbmNlKTtcclxuXHRcdHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xyXG5cdFx0dGhpcy5fY3R4Ll9zdGFydCA9IHRoaXMuX2lucHV0LkxUKDEpO1xyXG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJSdWxlRXZlbnQoKTsgLy8gc2ltdWxhdGVzIHJ1bGUgZW50cnkgZm9yIGxlZnQtcmVjdXJzaXZlIHJ1bGVzXHJcblx0fVxyXG5cclxuXHQvKiogTGlrZSB7QGxpbmsgI2VudGVyUnVsZX0gYnV0IGZvciByZWN1cnNpdmUgcnVsZXMuXHJcblx0ICogIE1ha2UgdGhlIGN1cnJlbnQgY29udGV4dCB0aGUgY2hpbGQgb2YgdGhlIGluY29taW5nIGxvY2FsY3R4LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBwdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eDogUGFyc2VyUnVsZUNvbnRleHQsIHN0YXRlOiBudW1iZXIsIHJ1bGVJbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRsZXQgcHJldmlvdXM6IFBhcnNlclJ1bGVDb250ZXh0ID0gdGhpcy5fY3R4O1xyXG5cdFx0cHJldmlvdXMuX3BhcmVudCA9IGxvY2FsY3R4O1xyXG5cdFx0cHJldmlvdXMuaW52b2tpbmdTdGF0ZSA9IHN0YXRlO1xyXG5cdFx0cHJldmlvdXMuX3N0b3AgPSB0aGlzLl9pbnB1dC50cnlMVCgtMSk7XHJcblxyXG5cdFx0dGhpcy5fY3R4ID0gbG9jYWxjdHg7XHJcblx0XHR0aGlzLl9jdHguX3N0YXJ0ID0gcHJldmlvdXMuX3N0YXJ0O1xyXG5cdFx0aWYgKHRoaXMuX2J1aWxkUGFyc2VUcmVlcykge1xyXG5cdFx0XHR0aGlzLl9jdHguYWRkQ2hpbGQocHJldmlvdXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudHJpZ2dlckVudGVyUnVsZUV2ZW50KCk7IC8vIHNpbXVsYXRlcyBydWxlIGVudHJ5IGZvciBsZWZ0LXJlY3Vyc2l2ZSBydWxlc1xyXG5cdH1cclxuXHJcblx0cHVibGljIHVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHg6IFBhcnNlclJ1bGVDb250ZXh0KTogdm9pZCB7XHJcblx0XHR0aGlzLl9wcmVjZWRlbmNlU3RhY2sucG9wKCk7XHJcblx0XHR0aGlzLl9jdHguX3N0b3AgPSB0aGlzLl9pbnB1dC50cnlMVCgtMSk7XHJcblx0XHRsZXQgcmV0Y3R4OiBQYXJzZXJSdWxlQ29udGV4dCA9IHRoaXMuX2N0eDsgLy8gc2F2ZSBjdXJyZW50IGN0eCAocmV0dXJuIHZhbHVlKVxyXG5cclxuXHRcdC8vIHVucm9sbCBzbyBfY3R4IGlzIGFzIGl0IHdhcyBiZWZvcmUgY2FsbCB0byByZWN1cnNpdmUgbWV0aG9kXHJcblx0XHRpZiAodGhpcy5fcGFyc2VMaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHR3aGlsZSAodGhpcy5fY3R4ICE9PSBfcGFyZW50Y3R4KSB7XHJcblx0XHRcdFx0dGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG5cdFx0XHRcdHRoaXMuX2N0eCA9IHRoaXMuX2N0eC5fcGFyZW50IGFzIFBhcnNlclJ1bGVDb250ZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5fY3R4ID0gX3BhcmVudGN0eDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBob29rIGludG8gdHJlZVxyXG5cdFx0cmV0Y3R4Ll9wYXJlbnQgPSBfcGFyZW50Y3R4O1xyXG5cclxuXHRcdGlmICh0aGlzLl9idWlsZFBhcnNlVHJlZXMgJiYgX3BhcmVudGN0eCAhPSBudWxsKSB7XHJcblx0XHRcdC8vIGFkZCByZXR1cm4gY3R4IGludG8gaW52b2tpbmcgcnVsZSdzIHRyZWVcclxuXHRcdFx0X3BhcmVudGN0eC5hZGRDaGlsZChyZXRjdHgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGdldEludm9raW5nQ29udGV4dChydWxlSW5kZXg6IG51bWJlcik6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkIHtcclxuXHRcdGxldCBwID0gdGhpcy5fY3R4O1xyXG5cdFx0d2hpbGUgKHAgJiYgcC5ydWxlSW5kZXggIT09IHJ1bGVJbmRleCkge1xyXG5cdFx0XHRwID0gcC5fcGFyZW50IGFzIFBhcnNlclJ1bGVDb250ZXh0O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHA7XHJcblx0fVxyXG5cclxuXHRnZXQgY29udGV4dCgpOiBQYXJzZXJSdWxlQ29udGV4dCB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3R4O1xyXG5cdH1cclxuXHJcblx0c2V0IGNvbnRleHQoY3R4OiBQYXJzZXJSdWxlQ29udGV4dCkge1xyXG5cdFx0dGhpcy5fY3R4ID0gY3R4O1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHByZWNwcmVkKEBOdWxsYWJsZSBsb2NhbGN0eDogUnVsZUNvbnRleHQsIHByZWNlZGVuY2U6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHByZWNlZGVuY2UgPj0gdGhpcy5fcHJlY2VkZW5jZVN0YWNrLnBlZWsoKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBnZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKTogUGFyc2VyRXJyb3JMaXN0ZW5lciB7XHJcblx0XHRyZXR1cm4gbmV3IFByb3h5UGFyc2VyRXJyb3JMaXN0ZW5lcih0aGlzLmdldEVycm9yTGlzdGVuZXJzKCkpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGluQ29udGV4dChjb250ZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdC8vIFRPRE86IHVzZWZ1bCBpbiBwYXJzZXI/XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVja3Mgd2hldGhlciBvciBub3QgYHN5bWJvbGAgY2FuIGZvbGxvdyB0aGUgY3VycmVudCBzdGF0ZSBpbiB0aGVcclxuXHQgKiBBVE4uIFRoZSBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIHRoZSBmb2xsb3dpbmcsIGJ1dCBpc1xyXG5cdCAqIGltcGxlbWVudGVkIHN1Y2ggdGhhdCB0aGUgY29tcGxldGUgY29udGV4dC1zZW5zaXRpdmUgZm9sbG93IHNldCBkb2VzIG5vdFxyXG5cdCAqIG5lZWQgdG8gYmUgZXhwbGljaXRseSBjb25zdHJ1Y3RlZC5cclxuXHQgKlxyXG5cdCAqIGBgYFxyXG5cdCAqIHJldHVybiBnZXRFeHBlY3RlZFRva2VucygpLmNvbnRhaW5zKHN5bWJvbCk7XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gc3ltYm9sIHRoZSBzeW1ib2wgdHlwZSB0byBjaGVja1xyXG5cdCAqIEByZXR1cm5zIGB0cnVlYCBpZiBgc3ltYm9sYCBjYW4gZm9sbG93IHRoZSBjdXJyZW50IHN0YXRlIGluXHJcblx0ICogdGhlIEFUTiwgb3RoZXJ3aXNlIGBmYWxzZWAuXHJcblx0ICovXHJcblx0cHVibGljIGlzRXhwZWN0ZWRUb2tlbihzeW1ib2w6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4vLyAgIFx0XHRyZXR1cm4gaW50ZXJwcmV0ZXIuYXRuLm5leHRUb2tlbnMoX2N0eCk7XHJcblx0XHRsZXQgYXRuOiBBVE4gPSB0aGlzLmludGVycHJldGVyLmF0bjtcclxuXHRcdGxldCBjdHg6IFBhcnNlclJ1bGVDb250ZXh0ID0gdGhpcy5fY3R4O1xyXG5cdFx0bGV0IHM6IEFUTlN0YXRlID0gYXRuLnN0YXRlc1t0aGlzLnN0YXRlXTtcclxuXHRcdGxldCBmb2xsb3dpbmc6IEludGVydmFsU2V0ID0gYXRuLm5leHRUb2tlbnMocyk7XHJcblx0XHRpZiAoZm9sbG93aW5nLmNvbnRhaW5zKHN5bWJvbCkpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcbi8vICAgICAgICBTeXN0ZW0ub3V0LnByaW50bG4oXCJmb2xsb3dpbmcgXCIrcytcIj1cIitmb2xsb3dpbmcpO1xyXG5cdFx0aWYgKCFmb2xsb3dpbmcuY29udGFpbnMoVG9rZW4uRVBTSUxPTikpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHdoaWxlIChjdHggIT0gbnVsbCAmJiBjdHguaW52b2tpbmdTdGF0ZSA+PSAwICYmIGZvbGxvd2luZy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSkge1xyXG5cdFx0XHRsZXQgaW52b2tpbmdTdGF0ZTogQVROU3RhdGUgPSBhdG4uc3RhdGVzW2N0eC5pbnZva2luZ1N0YXRlXTtcclxuXHRcdFx0bGV0IHJ0ID0gaW52b2tpbmdTdGF0ZS50cmFuc2l0aW9uKDApIGFzIFJ1bGVUcmFuc2l0aW9uO1xyXG5cdFx0XHRmb2xsb3dpbmcgPSBhdG4ubmV4dFRva2VucyhydC5mb2xsb3dTdGF0ZSk7XHJcblx0XHRcdGlmIChmb2xsb3dpbmcuY29udGFpbnMoc3ltYm9sKSkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjdHggPSBjdHguX3BhcmVudCBhcyBQYXJzZXJSdWxlQ29udGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZm9sbG93aW5nLmNvbnRhaW5zKFRva2VuLkVQU0lMT04pICYmIHN5bWJvbCA9PT0gVG9rZW4uRU9GKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdGdldCBpc01hdGNoZWRFT0YoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXRjaGVkRU9GO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29tcHV0ZXMgdGhlIHNldCBvZiBpbnB1dCBzeW1ib2xzIHdoaWNoIGNvdWxkIGZvbGxvdyB0aGUgY3VycmVudCBwYXJzZXJcclxuXHQgKiBzdGF0ZSBhbmQgY29udGV4dCwgYXMgZ2l2ZW4gYnkge0BsaW5rICNnZXRTdGF0ZX0gYW5kIHtAbGluayAjZ2V0Q29udGV4dH0sXHJcblx0ICogcmVzcGVjdGl2ZWx5LlxyXG5cdCAqXHJcblx0ICogQHNlZSBBVE4jZ2V0RXhwZWN0ZWRUb2tlbnMoaW50LCBSdWxlQ29udGV4dClcclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHB1YmxpYyBnZXRFeHBlY3RlZFRva2VucygpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRyZXR1cm4gdGhpcy5hdG4uZ2V0RXhwZWN0ZWRUb2tlbnModGhpcy5zdGF0ZSwgdGhpcy5jb250ZXh0KTtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHVibGljIGdldEV4cGVjdGVkVG9rZW5zV2l0aGluQ3VycmVudFJ1bGUoKTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0bGV0IGF0bjogQVROID0gdGhpcy5pbnRlcnByZXRlci5hdG47XHJcblx0XHRsZXQgczogQVROU3RhdGUgPSBhdG4uc3RhdGVzW3RoaXMuc3RhdGVdO1xyXG5cdFx0cmV0dXJuIGF0bi5uZXh0VG9rZW5zKHMpO1xyXG5cdH1cclxuXHJcblx0LyoqIEdldCBhIHJ1bGUncyBpbmRleCAoaS5lLiwgYFJVTEVfcnVsZU5hbWVgIGZpZWxkKSBvciAtMSBpZiBub3QgZm91bmQuICovXHJcblx0cHVibGljIGdldFJ1bGVJbmRleChydWxlTmFtZTogc3RyaW5nKTogbnVtYmVyIHtcclxuXHRcdGxldCBydWxlSW5kZXggPSB0aGlzLmdldFJ1bGVJbmRleE1hcCgpLmdldChydWxlTmFtZSk7XHJcblx0XHRpZiAocnVsZUluZGV4ICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHJ1bGVJbmRleDtcclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcblxyXG5cdGdldCBydWxlQ29udGV4dCgpOiBQYXJzZXJSdWxlQ29udGV4dCB7IHJldHVybiB0aGlzLl9jdHg7IH1cclxuXHJcblx0LyoqIFJldHVybiBMaXN0Jmx0O1N0cmluZyZndDsgb2YgdGhlIHJ1bGUgbmFtZXMgaW4geW91ciBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKiAgbGVhZGluZyB1cCB0byBhIGNhbGwgdG8gdGhlIGN1cnJlbnQgcnVsZS4gIFlvdSBjb3VsZCBvdmVycmlkZSBpZlxyXG5cdCAqICB5b3Ugd2FudCBtb3JlIGRldGFpbHMgc3VjaCBhcyB0aGUgZmlsZS9saW5lIGluZm8gb2Ygd2hlcmVcclxuXHQgKiAgaW4gdGhlIEFUTiBhIHJ1bGUgaXMgaW52b2tlZC5cclxuXHQgKlxyXG5cdCAqICBUaGlzIGlzIHZlcnkgdXNlZnVsIGZvciBlcnJvciBtZXNzYWdlcy5cclxuXHQgKi9cclxuXHJcblx0cHVibGljIGdldFJ1bGVJbnZvY2F0aW9uU3RhY2soY3R4OiBSdWxlQ29udGV4dCA9IHRoaXMuX2N0eCk6IHN0cmluZ1tdIHtcclxuXHRcdGxldCBwOiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCA9IGN0eDsgIFx0XHQvLyBXb3JrYXJvdW5kIGZvciBNaWNyb3NvZnQvVHlwZVNjcmlwdCMxNDQ4N1xyXG5cdFx0bGV0IHJ1bGVOYW1lczogc3RyaW5nW10gPSB0aGlzLnJ1bGVOYW1lcztcclxuXHRcdGxldCBzdGFjazogc3RyaW5nW10gPSBbXTtcclxuXHRcdHdoaWxlIChwICE9IG51bGwpIHtcclxuXHRcdFx0Ly8gY29tcHV0ZSB3aGF0IGZvbGxvd3Mgd2hvIGludm9rZWQgdXNcclxuXHRcdFx0bGV0IHJ1bGVJbmRleDogbnVtYmVyID0gcC5ydWxlSW5kZXg7XHJcblx0XHRcdGlmIChydWxlSW5kZXggPCAwKSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChcIm4vYVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKHJ1bGVOYW1lc1tydWxlSW5kZXhdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwID0gcC5fcGFyZW50IGFzIFJ1bGVDb250ZXh0O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0YWNrO1xyXG5cdH1cclxuXHJcblx0LyoqIEZvciBkZWJ1Z2dpbmcgYW5kIG90aGVyIHB1cnBvc2VzLiAqL1xyXG5cdHB1YmxpYyBnZXRERkFTdHJpbmdzKCk6IHN0cmluZ1tdIHtcclxuXHRcdGxldCBzOiBzdHJpbmdbXSA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgZGZhIG9mIHRoaXMuX2ludGVycC5hdG4uZGVjaXNpb25Ub0RGQSkge1xyXG5cdFx0XHRzLnB1c2goZGZhLnRvU3RyaW5nKHRoaXMudm9jYWJ1bGFyeSwgdGhpcy5ydWxlTmFtZXMpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzO1xyXG5cdH1cclxuXHJcblx0LyoqIEZvciBkZWJ1Z2dpbmcgYW5kIG90aGVyIHB1cnBvc2VzLiAqL1xyXG5cdHB1YmxpYyBkdW1wREZBKCk6IHZvaWQge1xyXG5cdFx0bGV0IHNlZW5PbmU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdGZvciAobGV0IGRmYSBvZiB0aGlzLl9pbnRlcnAuYXRuLmRlY2lzaW9uVG9ERkEpIHtcclxuXHRcdFx0aWYgKCFkZmEuaXNFbXB0eSkge1xyXG5cdFx0XHRcdGlmIChzZWVuT25lKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkRlY2lzaW9uIFwiICsgZGZhLmRlY2lzaW9uICsgXCI6XCIpO1xyXG5cdFx0XHRcdHByb2Nlc3Muc3Rkb3V0LndyaXRlKGRmYS50b1N0cmluZyh0aGlzLnZvY2FidWxhcnksIHRoaXMucnVsZU5hbWVzKSk7XHJcblx0XHRcdFx0c2Vlbk9uZSA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGdldCBzb3VyY2VOYW1lKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW5wdXQuc291cmNlTmFtZTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBwYXJzZUluZm8oKTogUHJvbWlzZTxQYXJzZUluZm8gfCB1bmRlZmluZWQ+IHtcclxuXHRcdHJldHVybiBpbXBvcnQoXCIuL2F0bi9Qcm9maWxpbmdBVE5TaW11bGF0b3JcIikudGhlbigobSkgPT4ge1xyXG5cdFx0XHRsZXQgaW50ZXJwOiBQYXJzZXJBVE5TaW11bGF0b3IgPSB0aGlzLmludGVycHJldGVyO1xyXG5cdFx0XHRpZiAoaW50ZXJwIGluc3RhbmNlb2YgbS5Qcm9maWxpbmdBVE5TaW11bGF0b3IpIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFBhcnNlSW5mbyhpbnRlcnApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAc2luY2UgNC4zXHJcblx0ICovXHJcblx0cHVibGljIGFzeW5jIHNldFByb2ZpbGUocHJvZmlsZTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0bGV0IG0gPSBhd2FpdCBpbXBvcnQoXCIuL2F0bi9Qcm9maWxpbmdBVE5TaW11bGF0b3JcIik7XHJcblx0XHRsZXQgaW50ZXJwOiBQYXJzZXJBVE5TaW11bGF0b3IgPSB0aGlzLmludGVycHJldGVyO1xyXG5cdFx0aWYgKHByb2ZpbGUpIHtcclxuXHRcdFx0aWYgKCEoaW50ZXJwIGluc3RhbmNlb2YgbS5Qcm9maWxpbmdBVE5TaW11bGF0b3IpKSB7XHJcblx0XHRcdFx0dGhpcy5pbnRlcnByZXRlciA9IG5ldyBtLlByb2ZpbGluZ0FUTlNpbXVsYXRvcih0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChpbnRlcnAgaW5zdGFuY2VvZiBtLlByb2ZpbGluZ0FUTlNpbXVsYXRvcikge1xyXG5cdFx0XHR0aGlzLmludGVycHJldGVyID0gbmV3IFBhcnNlckFUTlNpbXVsYXRvcih0aGlzLmF0biwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5pbnRlcnByZXRlci5zZXRQcmVkaWN0aW9uTW9kZShpbnRlcnAuZ2V0UHJlZGljdGlvbk1vZGUoKSk7XHJcblx0fVxyXG5cclxuXHQvKiogRHVyaW5nIGEgcGFyc2UgaXMgc29tZXRpbWVzIHVzZWZ1bCB0byBsaXN0ZW4gaW4gb24gdGhlIHJ1bGUgZW50cnkgYW5kIGV4aXRcclxuXHQgKiAgZXZlbnRzIGFzIHdlbGwgYXMgdG9rZW4gbWF0Y2hlcy4gVGhpcyBpcyBmb3IgcXVpY2sgYW5kIGRpcnR5IGRlYnVnZ2luZy5cclxuXHQgKi9cclxuXHRzZXQgaXNUcmFjZSh0cmFjZTogYm9vbGVhbikge1xyXG5cdFx0aWYgKCF0cmFjZSkge1xyXG5cdFx0XHRpZiAodGhpcy5fdHJhY2VyKSB7XHJcblx0XHRcdFx0dGhpcy5yZW1vdmVQYXJzZUxpc3RlbmVyKHRoaXMuX3RyYWNlcik7XHJcblx0XHRcdFx0dGhpcy5fdHJhY2VyID0gdW5kZWZpbmVkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0aWYgKHRoaXMuX3RyYWNlcikge1xyXG5cdFx0XHRcdHRoaXMucmVtb3ZlUGFyc2VMaXN0ZW5lcih0aGlzLl90cmFjZXIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuX3RyYWNlciA9IG5ldyBUcmFjZUxpc3RlbmVyKHRoaXMucnVsZU5hbWVzLCB0aGlzLl9pbnB1dCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYWRkUGFyc2VMaXN0ZW5lcih0aGlzLl90cmFjZXIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB3aGV0aGVyIGEge0BsaW5rIFRyYWNlTGlzdGVuZXJ9IGlzIHJlZ2lzdGVyZWQgYXMgYSBwYXJzZSBsaXN0ZW5lclxyXG5cdCAqIGZvciB0aGUgcGFyc2VyLlxyXG5cdCAqL1xyXG5cdGdldCBpc1RyYWNlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYWNlciAhPSBudWxsO1xyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTIuMzI1NTU0OC0wNzowMFxyXG5cclxuaW1wb3J0IHsgQVROQ29uZmlnU2V0IH0gZnJvbSBcIi4vYXRuL0FUTkNvbmZpZ1NldFwiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi9QYXJzZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi9Ub2tlblN0cmVhbVwiO1xyXG5pbXBvcnQgeyBJbnRTdHJlYW0gfSBmcm9tIFwiLi9JbnRTdHJlYW1cIjtcclxuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuXHJcbi8qKiBJbmRpY2F0ZXMgdGhhdCB0aGUgcGFyc2VyIGNvdWxkIG5vdCBkZWNpZGUgd2hpY2ggb2YgdHdvIG9yIG1vcmUgcGF0aHNcclxuICogIHRvIHRha2UgYmFzZWQgdXBvbiB0aGUgcmVtYWluaW5nIGlucHV0LiBJdCB0cmFja3MgdGhlIHN0YXJ0aW5nIHRva2VuXHJcbiAqICBvZiB0aGUgb2ZmZW5kaW5nIGlucHV0IGFuZCBhbHNvIGtub3dzIHdoZXJlIHRoZSBwYXJzZXIgd2FzXHJcbiAqICBpbiB0aGUgdmFyaW91cyBwYXRocyB3aGVuIHRoZSBlcnJvci4gUmVwb3J0ZWQgYnkgcmVwb3J0Tm9WaWFibGVBbHRlcm5hdGl2ZSgpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTm9WaWFibGVBbHRFeGNlcHRpb24gZXh0ZW5kcyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB7XHJcblx0Ly9wcml2YXRlIHN0YXRpYyBzZXJpYWxWZXJzaW9uVUlEOiBudW1iZXIgPSAgNTA5NjAwMDAwODk5Mjg2NzA1Mkw7XHJcblxyXG5cdC8qKiBXaGljaCBjb25maWd1cmF0aW9ucyBkaWQgd2UgdHJ5IGF0IGlucHV0LmluZGV4IHRoYXQgY291bGRuJ3QgbWF0Y2ggaW5wdXQuTFQoMSk/ICovXHJcblx0cHJpdmF0ZSBfZGVhZEVuZENvbmZpZ3M/OiBBVE5Db25maWdTZXQ7XHJcblxyXG5cdC8qKiBUaGUgdG9rZW4gb2JqZWN0IGF0IHRoZSBzdGFydCBpbmRleDsgdGhlIGlucHV0IHN0cmVhbSBtaWdodFxyXG5cdCAqIFx0bm90IGJlIGJ1ZmZlcmluZyB0b2tlbnMgc28gZ2V0IGEgcmVmZXJlbmNlIHRvIGl0LiAoQXQgdGhlXHJcblx0ICogIHRpbWUgdGhlIGVycm9yIG9jY3VycmVkLCBvZiBjb3Vyc2UgdGhlIHN0cmVhbSBuZWVkcyB0byBrZWVwIGFcclxuXHQgKiAgYnVmZmVyIGFsbCBvZiB0aGUgdG9rZW5zIGJ1dCBsYXRlciB3ZSBtaWdodCBub3QgaGF2ZSBhY2Nlc3MgdG8gdGhvc2UuKVxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJpdmF0ZSBfc3RhcnRUb2tlbjogVG9rZW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKC8qQE5vdE51bGwqLyByZWNvZ25pemVyOiBQYXJzZXIpO1xyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRyZWNvZ25pemVyOiBSZWNvZ25pemVyPFRva2VuLCBhbnk+LFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRpbnB1dDogVG9rZW5TdHJlYW0sXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdHN0YXJ0VG9rZW46IFRva2VuLFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRvZmZlbmRpbmdUb2tlbjogVG9rZW4sXHJcblx0XHRkZWFkRW5kQ29uZmlnczogQVROQ29uZmlnU2V0IHwgdW5kZWZpbmVkLFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRjdHg6IFBhcnNlclJ1bGVDb250ZXh0KTtcclxuXHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRyZWNvZ25pemVyOiBSZWNvZ25pemVyPFRva2VuLCBhbnk+LFxyXG5cdFx0aW5wdXQ/OiBUb2tlblN0cmVhbSxcclxuXHRcdHN0YXJ0VG9rZW4/OiBUb2tlbixcclxuXHRcdG9mZmVuZGluZ1Rva2VuPzogVG9rZW4sXHJcblx0XHRkZWFkRW5kQ29uZmlncz86IEFUTkNvbmZpZ1NldCxcclxuXHRcdGN0eD86IFBhcnNlclJ1bGVDb250ZXh0KSB7XHJcblx0XHRpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFBhcnNlcikge1xyXG5cdFx0XHRpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGlucHV0ID0gcmVjb2duaXplci5pbnB1dFN0cmVhbTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHN0YXJ0VG9rZW4gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHN0YXJ0VG9rZW4gPSByZWNvZ25pemVyLmN1cnJlbnRUb2tlbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG9mZmVuZGluZ1Rva2VuID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRvZmZlbmRpbmdUb2tlbiA9IHJlY29nbml6ZXIuY3VycmVudFRva2VuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoY3R4ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjdHggPSByZWNvZ25pemVyLmNvbnRleHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRzdXBlcihyZWNvZ25pemVyLCBpbnB1dCwgY3R4KTtcclxuXHRcdHRoaXMuX2RlYWRFbmRDb25maWdzID0gZGVhZEVuZENvbmZpZ3M7XHJcblx0XHR0aGlzLl9zdGFydFRva2VuID0gc3RhcnRUb2tlbiBhcyBUb2tlbjtcclxuXHRcdHRoaXMuc2V0T2ZmZW5kaW5nVG9rZW4ocmVjb2duaXplciwgb2ZmZW5kaW5nVG9rZW4pO1xyXG5cdH1cclxuXHJcblx0Z2V0IHN0YXJ0VG9rZW4oKTogVG9rZW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3N0YXJ0VG9rZW47XHJcblx0fVxyXG5cclxuXHRnZXQgZGVhZEVuZENvbmZpZ3MoKTogQVROQ29uZmlnU2V0IHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLl9kZWFkRW5kQ29uZmlncztcclxuXHR9XHJcblxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1MC44MjkwNTI3LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBTlRMUkVycm9yU3RyYXRlZ3kgfSBmcm9tIFwiLi9BTlRMUkVycm9yU3RyYXRlZ3lcIjtcclxuaW1wb3J0IHsgQVROIH0gZnJvbSBcIi4vYXRuL0FUTlwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZSB9IGZyb20gXCIuL2F0bi9BVE5TdGF0ZVwiO1xyXG5pbXBvcnQgeyBBVE5TdGF0ZVR5cGUgfSBmcm9tIFwiLi9hdG4vQVROU3RhdGVUeXBlXCI7XHJcbmltcG9ydCB7IEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbiB9IGZyb20gXCIuL0ZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uIH0gZnJvbSBcIi4vSW5wdXRNaXNtYXRjaEV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBJbnRlcnZhbFNldCB9IGZyb20gXCIuL21pc2MvSW50ZXJ2YWxTZXRcIjtcclxuaW1wb3J0IHsgTm9WaWFibGVBbHRFeGNlcHRpb24gfSBmcm9tIFwiLi9Ob1ZpYWJsZUFsdEV4Y2VwdGlvblwiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi9QYXJzZXJcIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uQ29udGV4dCB9IGZyb20gXCIuL2F0bi9QcmVkaWN0aW9uQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFJ1bGVDb250ZXh0IH0gZnJvbSBcIi4vUnVsZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgUnVsZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9hdG4vUnVsZVRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgVG9rZW5TdHJlYW0gfSBmcm9tIFwiLi9Ub2tlblN0cmVhbVwiO1xyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcbmltcG9ydCB7IFRva2VuRmFjdG9yeSB9IGZyb20gXCIuL1Rva2VuRmFjdG9yeVwiO1xyXG5pbXBvcnQgeyBUb2tlblNvdXJjZSB9IGZyb20gXCIuL1Rva2VuU291cmNlXCI7XHJcbmltcG9ydCB7IFZvY2FidWxhcnkgfSBmcm9tIFwiLi9Wb2NhYnVsYXJ5XCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlLCBOb3ROdWxsIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIEFOVExSRXJyb3JTdHJhdGVneX0gdXNlZCBmb3JcclxuICogZXJyb3IgcmVwb3J0aW5nIGFuZCByZWNvdmVyeSBpbiBBTlRMUiBwYXJzZXJzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERlZmF1bHRFcnJvclN0cmF0ZWd5IGltcGxlbWVudHMgQU5UTFJFcnJvclN0cmF0ZWd5IHtcclxuXHQvKipcclxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXJyb3Igc3RyYXRlZ3kgaXMgY3VycmVudGx5IFwicmVjb3ZlcmluZyBmcm9tIGFuXHJcblx0ICogZXJyb3JcIi4gVGhpcyBpcyB1c2VkIHRvIHN1cHByZXNzIHJlcG9ydGluZyBtdWx0aXBsZSBlcnJvciBtZXNzYWdlcyB3aGlsZVxyXG5cdCAqIGF0dGVtcHRpbmcgdG8gcmVjb3ZlciBmcm9tIGEgZGV0ZWN0ZWQgc3ludGF4IGVycm9yLlxyXG5cdCAqXHJcblx0ICogQHNlZSAjaW5FcnJvclJlY292ZXJ5TW9kZVxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBlcnJvclJlY292ZXJ5TW9kZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHQvKiogVGhlIGluZGV4IGludG8gdGhlIGlucHV0IHN0cmVhbSB3aGVyZSB0aGUgbGFzdCBlcnJvciBvY2N1cnJlZC5cclxuXHQgKiBcdFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzIHdoZXJlIGFuIGVycm9yIGlzIGZvdW5kXHJcblx0ICogIGJ1dCBubyB0b2tlbiBpcyBjb25zdW1lZCBkdXJpbmcgcmVjb3ZlcnkuLi5hbm90aGVyIGVycm9yIGlzIGZvdW5kLFxyXG5cdCAqICBhZCBuYXVzZXVtLiAgVGhpcyBpcyBhIGZhaWxzYWZlIG1lY2hhbmlzbSB0byBndWFyYW50ZWUgdGhhdCBhdCBsZWFzdFxyXG5cdCAqICBvbmUgdG9rZW4vdHJlZSBub2RlIGlzIGNvbnN1bWVkIGZvciB0d28gZXJyb3JzLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBsYXN0RXJyb3JJbmRleDogbnVtYmVyID0gLTE7XHJcblxyXG5cdHByb3RlY3RlZCBsYXN0RXJyb3JTdGF0ZXM/OiBJbnRlcnZhbFNldDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBmaWVsZCBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbG9va2FoZWFkIGZvbGxvd2luZ1xyXG5cdCAqIHRoZSBwcmV2aW91cyBtYXRjaC4gU2luY2UgcHJlZGljdGlvbiBwcmVmZXJzIGNvbXBsZXRpbmcgdGhlIGN1cnJlbnQgcnVsZVxyXG5cdCAqIHRvIGVycm9yIHJlY292ZXJ5IGVmZm9ydHMsIGVycm9yIHJlcG9ydGluZyBtYXkgb2NjdXIgbGF0ZXIgdGhhbiB0aGVcclxuXHQgKiBvcmlnaW5hbCBwb2ludCB3aGVyZSBpdCB3YXMgZGlzY292ZXJhYmxlLiBUaGUgb3JpZ2luYWwgY29udGV4dCBpcyB1c2VkIHRvXHJcblx0ICogY29tcHV0ZSB0aGUgdHJ1ZSBleHBlY3RlZCBzZXRzIGFzIHRob3VnaCB0aGUgcmVwb3J0aW5nIG9jY3VycmVkIGFzIGVhcmx5XHJcblx0ICogYXMgcG9zc2libGUuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIG5leHRUb2tlbnNDb250ZXh0PzogUGFyc2VyUnVsZUNvbnRleHQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBzZWUgI25leHRUb2tlbnNDb250ZXh0XHJcblx0ICovXHJcblx0cHJvdGVjdGVkIG5leHRUb2tlbnNTdGF0ZTogbnVtYmVyID0gQVROU3RhdGUuSU5WQUxJRF9TVEFURV9OVU1CRVI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNpbXBseSBjYWxscyB7QGxpbmsgI2VuZEVycm9yQ29uZGl0aW9ufSB0b1xyXG5cdCAqIGVuc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGlzIG5vdCBpbiBlcnJvciByZWNvdmVyeSBtb2RlLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZXNldChyZWNvZ25pemVyOiBQYXJzZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMuZW5kRXJyb3JDb25kaXRpb24ocmVjb2duaXplcik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdG8gZW50ZXIgZXJyb3IgcmVjb3ZlcnkgbW9kZSB3aGVuIGEgcmVjb2duaXRpb25cclxuXHQgKiBleGNlcHRpb24gaXMgcmVwb3J0ZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGJlZ2luRXJyb3JDb25kaXRpb24oQE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyKTogdm9pZCB7XHJcblx0XHR0aGlzLmVycm9yUmVjb3ZlcnlNb2RlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgaW5FcnJvclJlY292ZXJ5TW9kZShyZWNvZ25pemVyOiBQYXJzZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmVycm9yUmVjb3ZlcnlNb2RlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHRvIGxlYXZlIGVycm9yIHJlY292ZXJ5IG1vZGUgYWZ0ZXIgcmVjb3ZlcmluZyBmcm9tXHJcblx0ICogYSByZWNvZ25pdGlvbiBleGNlcHRpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplclxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBlbmRFcnJvckNvbmRpdGlvbihATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMuZXJyb3JSZWNvdmVyeU1vZGUgPSBmYWxzZTtcclxuXHRcdHRoaXMubGFzdEVycm9yU3RhdGVzID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5sYXN0RXJyb3JJbmRleCA9IC0xO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2ltcGx5IGNhbGxzIHtAbGluayAjZW5kRXJyb3JDb25kaXRpb259LlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZXBvcnRNYXRjaChyZWNvZ25pemVyOiBQYXJzZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMuZW5kRXJyb3JDb25kaXRpb24ocmVjb2duaXplcik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGltbWVkaWF0ZWx5IGlmIHRoZSBoYW5kbGVyIGlzIGFscmVhZHlcclxuXHQgKiBpbiBlcnJvciByZWNvdmVyeSBtb2RlLiBPdGhlcndpc2UsIGl0IGNhbGxzIHtAbGluayAjYmVnaW5FcnJvckNvbmRpdGlvbn1cclxuXHQgKiBhbmQgZGlzcGF0Y2hlcyB0aGUgcmVwb3J0aW5nIHRhc2sgYmFzZWQgb24gdGhlIHJ1bnRpbWUgdHlwZSBvZiBgZWBcclxuXHQgKiBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyB0YWJsZS5cclxuXHQgKlxyXG5cdCAqICoge0BsaW5rIE5vVmlhYmxlQWx0RXhjZXB0aW9ufTogRGlzcGF0Y2hlcyB0aGUgY2FsbCB0b1xyXG5cdCAqICAge0BsaW5rICNyZXBvcnROb1ZpYWJsZUFsdGVybmF0aXZlfVxyXG5cdCAqICoge0BsaW5rIElucHV0TWlzbWF0Y2hFeGNlcHRpb259OiBEaXNwYXRjaGVzIHRoZSBjYWxsIHRvXHJcblx0ICogICB7QGxpbmsgI3JlcG9ydElucHV0TWlzbWF0Y2h9XHJcblx0ICogKiB7QGxpbmsgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9ufTogRGlzcGF0Y2hlcyB0aGUgY2FsbCB0b1xyXG5cdCAqICAge0BsaW5rICNyZXBvcnRGYWlsZWRQcmVkaWNhdGV9XHJcblx0ICogKiBBbGwgb3RoZXIgdHlwZXM6IGNhbGxzIHtAbGluayBQYXJzZXIjbm90aWZ5RXJyb3JMaXN0ZW5lcnN9IHRvIHJlcG9ydFxyXG5cdCAqICAgdGhlIGV4Y2VwdGlvblxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZXBvcnRFcnJvcihcclxuXHRcdHJlY29nbml6ZXI6IFBhcnNlcixcclxuXHRcdGU6IFJlY29nbml0aW9uRXhjZXB0aW9uKTogdm9pZCB7XHJcblx0XHQvLyBpZiB3ZSd2ZSBhbHJlYWR5IHJlcG9ydGVkIGFuIGVycm9yIGFuZCBoYXZlIG5vdCBtYXRjaGVkIGEgdG9rZW5cclxuXHRcdC8vIHlldCBzdWNjZXNzZnVsbHksIGRvbid0IHJlcG9ydCBhbnkgZXJyb3JzLlxyXG5cdFx0aWYgKHRoaXMuaW5FcnJvclJlY292ZXJ5TW9kZShyZWNvZ25pemVyKSkge1xyXG4vL1x0XHRcdFN5c3RlbS5lcnIucHJpbnQoXCJbU1BVUklPVVNdIFwiKTtcclxuXHRcdFx0cmV0dXJuOyAvLyBkb24ndCByZXBvcnQgc3B1cmlvdXMgZXJyb3JzXHJcblx0XHR9XHJcblx0XHR0aGlzLmJlZ2luRXJyb3JDb25kaXRpb24ocmVjb2duaXplcik7XHJcblx0XHRpZiAoZSBpbnN0YW5jZW9mIE5vVmlhYmxlQWx0RXhjZXB0aW9uKSB7XHJcblx0XHRcdHRoaXMucmVwb3J0Tm9WaWFibGVBbHRlcm5hdGl2ZShyZWNvZ25pemVyLCBlKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBJbnB1dE1pc21hdGNoRXhjZXB0aW9uKSB7XHJcblx0XHRcdHRoaXMucmVwb3J0SW5wdXRNaXNtYXRjaChyZWNvZ25pemVyLCBlKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24pIHtcclxuXHRcdFx0dGhpcy5yZXBvcnRGYWlsZWRQcmVkaWNhdGUocmVjb2duaXplciwgZSk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihgdW5rbm93biByZWNvZ25pdGlvbiBlcnJvciB0eXBlOiAke2V9YCk7XHJcblx0XHRcdHRoaXMubm90aWZ5RXJyb3JMaXN0ZW5lcnMocmVjb2duaXplciwgZS50b1N0cmluZygpLCBlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBub3RpZnlFcnJvckxpc3RlbmVycyhATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIsIG1lc3NhZ2U6IHN0cmluZywgZTogUmVjb2duaXRpb25FeGNlcHRpb24pOiB2b2lkIHtcclxuXHRcdGxldCBvZmZlbmRpbmdUb2tlbjogVG9rZW4gfCBudWxsIHwgdW5kZWZpbmVkID0gZS5nZXRPZmZlbmRpbmdUb2tlbihyZWNvZ25pemVyKTtcclxuXHRcdGlmIChvZmZlbmRpbmdUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdC8vIFBhc3MgbnVsbCB0byBub3RpZnlFcnJvckxpc3RlbmVycyBzbyBpdCBpbiB0dXJuIGNhbGxzIHRoZSBlcnJvciBsaXN0ZW5lcnMgd2l0aCB1bmRlZmluZWQgYXMgdGhlIG9mZmVuZGluZ1xyXG5cdFx0XHQvLyB0b2tlbi4gSWYgd2UgcGFzc2VkIHVuZGVmaW5lZCwgaXQgd291bGQgaW5zdGVhZCBjYWxsIHRoZSBsaXN0ZW5lcnMgd2l0aCBjdXJyZW50VG9rZW4gZnJvbSB0aGUgcGFyc2VyLlxyXG5cdFx0XHRvZmZlbmRpbmdUb2tlbiA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtZXNzYWdlLCBvZmZlbmRpbmdUb2tlbiwgZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXN5bmNocm9uaXplcyB0aGUgcGFyc2VyIGJ5IGNvbnN1bWluZyB0b2tlbnNcclxuXHQgKiB1bnRpbCB3ZSBmaW5kIG9uZSBpbiB0aGUgcmVzeW5jaHJvbml6YXRpb24gc2V0LS1sb29zZWx5IHRoZSBzZXQgb2YgdG9rZW5zXHJcblx0ICogdGhhdCBjYW4gZm9sbG93IHRoZSBjdXJyZW50IHJ1bGUuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlY292ZXIocmVjb2duaXplcjogUGFyc2VyLCBlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbik6IHZvaWQge1xyXG4vL1x0XHRTeXN0ZW0ub3V0LnByaW50bG4oXCJyZWNvdmVyIGluIFwiK3JlY29nbml6ZXIuZ2V0UnVsZUludm9jYXRpb25TdGFjaygpK1xyXG4vL1x0XHRcdFx0XHRcdCAgIFwiIGluZGV4PVwiK3JlY29nbml6ZXIuaW5wdXRTdHJlYW0uaW5kZXgrXHJcbi8vXHRcdFx0XHRcdFx0ICAgXCIsIGxhc3RFcnJvckluZGV4PVwiK1xyXG4vL1x0XHRcdFx0XHRcdCAgIGxhc3RFcnJvckluZGV4K1xyXG4vL1x0XHRcdFx0XHRcdCAgIFwiLCBzdGF0ZXM9XCIrbGFzdEVycm9yU3RhdGVzKTtcclxuXHRcdGlmICh0aGlzLmxhc3RFcnJvckluZGV4ID09PSByZWNvZ25pemVyLmlucHV0U3RyZWFtLmluZGV4ICYmXHJcblx0XHRcdHRoaXMubGFzdEVycm9yU3RhdGVzICYmXHJcblx0XHRcdHRoaXMubGFzdEVycm9yU3RhdGVzLmNvbnRhaW5zKHJlY29nbml6ZXIuc3RhdGUpKSB7XHJcblx0XHRcdC8vIHVoIG9oLCBhbm90aGVyIGVycm9yIGF0IHNhbWUgdG9rZW4gaW5kZXggYW5kIHByZXZpb3VzbHktdmlzaXRlZFxyXG5cdFx0XHQvLyBzdGF0ZSBpbiBBVE47IG11c3QgYmUgYSBjYXNlIHdoZXJlIExUKDEpIGlzIGluIHRoZSByZWNvdmVyeVxyXG5cdFx0XHQvLyB0b2tlbiBzZXQgc28gbm90aGluZyBnb3QgY29uc3VtZWQuIENvbnN1bWUgYSBzaW5nbGUgdG9rZW5cclxuXHRcdFx0Ly8gYXQgbGVhc3QgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wOyB0aGlzIGlzIGEgZmFpbHNhZmUuXHJcbi8vXHRcdFx0U3lzdGVtLmVyci5wcmludGxuKFwic2VlbiBlcnJvciBjb25kaXRpb24gYmVmb3JlIGluZGV4PVwiK1xyXG4vL1x0XHRcdFx0XHRcdFx0ICAgbGFzdEVycm9ySW5kZXgrXCIsIHN0YXRlcz1cIitsYXN0RXJyb3JTdGF0ZXMpO1xyXG4vL1x0XHRcdFN5c3RlbS5lcnIucHJpbnRsbihcIkZBSUxTQUZFIGNvbnN1bWVzIFwiK3JlY29nbml6ZXIuZ2V0VG9rZW5OYW1lcygpW3JlY29nbml6ZXIuaW5wdXRTdHJlYW0uTEEoMSldKTtcclxuXHRcdFx0cmVjb2duaXplci5jb25zdW1lKCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxhc3RFcnJvckluZGV4ID0gcmVjb2duaXplci5pbnB1dFN0cmVhbS5pbmRleDtcclxuXHRcdGlmICghdGhpcy5sYXN0RXJyb3JTdGF0ZXMpIHtcclxuXHRcdFx0dGhpcy5sYXN0RXJyb3JTdGF0ZXMgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcclxuXHRcdH1cclxuXHRcdHRoaXMubGFzdEVycm9yU3RhdGVzLmFkZChyZWNvZ25pemVyLnN0YXRlKTtcclxuXHRcdGxldCBmb2xsb3dTZXQ6IEludGVydmFsU2V0ID0gdGhpcy5nZXRFcnJvclJlY292ZXJ5U2V0KHJlY29nbml6ZXIpO1xyXG5cdFx0dGhpcy5jb25zdW1lVW50aWwocmVjb2duaXplciwgZm9sbG93U2V0KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3kjc3luY30gbWFrZXMgc3VyZVxyXG5cdCAqIHRoYXQgdGhlIGN1cnJlbnQgbG9va2FoZWFkIHN5bWJvbCBpcyBjb25zaXN0ZW50IHdpdGggd2hhdCB3ZXJlIGV4cGVjdGluZ1xyXG5cdCAqIGF0IHRoaXMgcG9pbnQgaW4gdGhlIEFUTi4gWW91IGNhbiBjYWxsIHRoaXMgYW55dGltZSBidXQgQU5UTFIgb25seVxyXG5cdCAqIGdlbmVyYXRlcyBjb2RlIHRvIGNoZWNrIGJlZm9yZSBzdWJydWxlcy9sb29wcyBhbmQgZWFjaCBpdGVyYXRpb24uXHJcblx0ICpcclxuXHQgKiBJbXBsZW1lbnRzIEppbSBJZGxlJ3MgbWFnaWMgc3luYyBtZWNoYW5pc20gaW4gY2xvc3VyZXMgYW5kIG9wdGlvbmFsXHJcblx0ICogc3VicnVsZXMuIEUuZy4sXHJcblx0ICpcclxuXHQgKiBgYGBhbnRsclxyXG5cdCAqIGEgOiBzeW5jICggc3R1ZmYgc3luYyApKiA7XHJcblx0ICogc3luYyA6IHtjb25zdW1lIHRvIHdoYXQgY2FuIGZvbGxvdyBzeW5jfSA7XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBBdCB0aGUgc3RhcnQgb2YgYSBzdWIgcnVsZSB1cG9uIGVycm9yLCB7QGxpbmsgI3N5bmN9IHBlcmZvcm1zIHNpbmdsZVxyXG5cdCAqIHRva2VuIGRlbGV0aW9uLCBpZiBwb3NzaWJsZS4gSWYgaXQgY2FuJ3QgZG8gdGhhdCwgaXQgYmFpbHMgb24gdGhlIGN1cnJlbnRcclxuXHQgKiBydWxlIGFuZCB1c2VzIHRoZSBkZWZhdWx0IGVycm9yIHJlY292ZXJ5LCB3aGljaCBjb25zdW1lcyB1bnRpbCB0aGVcclxuXHQgKiByZXN5bmNocm9uaXphdGlvbiBzZXQgb2YgdGhlIGN1cnJlbnQgcnVsZS5cclxuXHQgKlxyXG5cdCAqIElmIHRoZSBzdWIgcnVsZSBpcyBvcHRpb25hbCAoYCguLi4pP2AsIGAoLi4uKSpgLCBvciBibG9ja1xyXG5cdCAqIHdpdGggYW4gZW1wdHkgYWx0ZXJuYXRpdmUpLCB0aGVuIHRoZSBleHBlY3RlZCBzZXQgaW5jbHVkZXMgd2hhdCBmb2xsb3dzXHJcblx0ICogdGhlIHN1YnJ1bGUuXHJcblx0ICpcclxuXHQgKiBEdXJpbmcgbG9vcCBpdGVyYXRpb24sIGl0IGNvbnN1bWVzIHVudGlsIGl0IHNlZXMgYSB0b2tlbiB0aGF0IGNhbiBzdGFydCBhXHJcblx0ICogc3ViIHJ1bGUgb3Igd2hhdCBmb2xsb3dzIGxvb3AuIFllcywgdGhhdCBpcyBwcmV0dHkgYWdncmVzc2l2ZS4gV2Ugb3B0IHRvXHJcblx0ICogc3RheSBpbiB0aGUgbG9vcCBhcyBsb25nIGFzIHBvc3NpYmxlLlxyXG5cdCAqXHJcblx0ICogKipPUklHSU5TKipcclxuXHQgKlxyXG5cdCAqIFByZXZpb3VzIHZlcnNpb25zIG9mIEFOVExSIGRpZCBhIHBvb3Igam9iIG9mIHRoZWlyIHJlY292ZXJ5IHdpdGhpbiBsb29wcy5cclxuXHQgKiBBIHNpbmdsZSBtaXNtYXRjaCB0b2tlbiBvciBtaXNzaW5nIHRva2VuIHdvdWxkIGZvcmNlIHRoZSBwYXJzZXIgdG8gYmFpbFxyXG5cdCAqIG91dCBvZiB0aGUgZW50aXJlIHJ1bGVzIHN1cnJvdW5kaW5nIHRoZSBsb29wLiBTbywgZm9yIHJ1bGVcclxuXHQgKlxyXG5cdCAqIGBgYGFudGxyXHJcblx0ICogY2xhc3NEZWYgOiAnY2xhc3MnIElEICd7JyBtZW1iZXIqICd9J1xyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogaW5wdXQgd2l0aCBhbiBleHRyYSB0b2tlbiBiZXR3ZWVuIG1lbWJlcnMgd291bGQgZm9yY2UgdGhlIHBhcnNlciB0b1xyXG5cdCAqIGNvbnN1bWUgdW50aWwgaXQgZm91bmQgdGhlIG5leHQgY2xhc3MgZGVmaW5pdGlvbiByYXRoZXIgdGhhbiB0aGUgbmV4dFxyXG5cdCAqIG1lbWJlciBkZWZpbml0aW9uIG9mIHRoZSBjdXJyZW50IGNsYXNzLlxyXG5cdCAqXHJcblx0ICogVGhpcyBmdW5jdGlvbmFsaXR5IGNvc3QgYSBsaXR0bGUgYml0IG9mIGVmZm9ydCBiZWNhdXNlIHRoZSBwYXJzZXIgaGFzIHRvXHJcblx0ICogY29tcGFyZSB0b2tlbiBzZXQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsb29wIGFuZCBhdCBlYWNoIGl0ZXJhdGlvbi4gSWYgZm9yXHJcblx0ICogc29tZSByZWFzb24gc3BlZWQgaXMgc3VmZmVyaW5nIGZvciB5b3UsIHlvdSBjYW4gdHVybiBvZmYgdGhpc1xyXG5cdCAqIGZ1bmN0aW9uYWxpdHkgYnkgc2ltcGx5IG92ZXJyaWRpbmcgdGhpcyBtZXRob2QgYXMgYSBibGFuayB7IH0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHN5bmMocmVjb2duaXplcjogUGFyc2VyKTogdm9pZCB7XHJcblx0XHRsZXQgczogQVROU3RhdGUgPSByZWNvZ25pemVyLmludGVycHJldGVyLmF0bi5zdGF0ZXNbcmVjb2duaXplci5zdGF0ZV07XHJcbi8vXHRcdFN5c3RlbS5lcnIucHJpbnRsbihcInN5bmMgQCBcIitzLnN0YXRlTnVtYmVyK1wiPVwiK3MuZ2V0Q2xhc3MoKS5nZXRTaW1wbGVOYW1lKCkpO1xyXG5cdFx0Ly8gSWYgYWxyZWFkeSByZWNvdmVyaW5nLCBkb24ndCB0cnkgdG8gc3luY1xyXG5cdFx0aWYgKHRoaXMuaW5FcnJvclJlY292ZXJ5TW9kZShyZWNvZ25pemVyKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHRva2VuczogVG9rZW5TdHJlYW0gPSByZWNvZ25pemVyLmlucHV0U3RyZWFtO1xyXG5cdFx0bGV0IGxhOiBudW1iZXIgPSB0b2tlbnMuTEEoMSk7XHJcblxyXG5cdFx0Ly8gdHJ5IGNoZWFwZXIgc3Vic2V0IGZpcnN0OyBtaWdodCBnZXQgbHVja3kuIHNlZW1zIHRvIHNoYXZlIGEgd2VlIGJpdCBvZmZcclxuXHRcdGxldCBuZXh0VG9rZW5zOiBJbnRlcnZhbFNldCA9IHJlY29nbml6ZXIuYXRuLm5leHRUb2tlbnMocyk7XHJcblx0XHRpZiAobmV4dFRva2Vucy5jb250YWlucyhsYSkpIHtcclxuXHRcdFx0Ly8gV2UgYXJlIHN1cmUgdGhlIHRva2VuIG1hdGNoZXNcclxuXHRcdFx0dGhpcy5uZXh0VG9rZW5zQ29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0dGhpcy5uZXh0VG9rZW5zU3RhdGUgPSBBVE5TdGF0ZS5JTlZBTElEX1NUQVRFX05VTUJFUjtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChuZXh0VG9rZW5zLmNvbnRhaW5zKFRva2VuLkVQU0lMT04pKSB7XHJcblx0XHRcdGlmICh0aGlzLm5leHRUb2tlbnNDb250ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHQvLyBJdCdzIHBvc3NpYmxlIHRoZSBuZXh0IHRva2VuIHdvbid0IG1hdGNoOyBpbmZvcm1hdGlvbiB0cmFja2VkXHJcblx0XHRcdFx0Ly8gYnkgc3luYyBpcyByZXN0cmljdGVkIGZvciBwZXJmb3JtYW5jZS5cclxuXHRcdFx0XHR0aGlzLm5leHRUb2tlbnNDb250ZXh0ID0gcmVjb2duaXplci5jb250ZXh0O1xyXG5cdFx0XHRcdHRoaXMubmV4dFRva2Vuc1N0YXRlID0gcmVjb2duaXplci5zdGF0ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN3aXRjaCAocy5zdGF0ZVR5cGUpIHtcclxuXHRcdGNhc2UgQVROU3RhdGVUeXBlLkJMT0NLX1NUQVJUOlxyXG5cdFx0Y2FzZSBBVE5TdGF0ZVR5cGUuU1RBUl9CTE9DS19TVEFSVDpcclxuXHRcdGNhc2UgQVROU3RhdGVUeXBlLlBMVVNfQkxPQ0tfU1RBUlQ6XHJcblx0XHRjYXNlIEFUTlN0YXRlVHlwZS5TVEFSX0xPT1BfRU5UUlk6XHJcblx0XHRcdC8vIHJlcG9ydCBlcnJvciBhbmQgcmVjb3ZlciBpZiBwb3NzaWJsZVxyXG5cdFx0XHRpZiAodGhpcy5zaW5nbGVUb2tlbkRlbGV0aW9uKHJlY29nbml6ZXIpKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbihyZWNvZ25pemVyKTtcclxuXHJcblx0XHRjYXNlIEFUTlN0YXRlVHlwZS5QTFVTX0xPT1BfQkFDSzpcclxuXHRcdGNhc2UgQVROU3RhdGVUeXBlLlNUQVJfTE9PUF9CQUNLOlxyXG4vL1x0XHRcdFN5c3RlbS5lcnIucHJpbnRsbihcImF0IGxvb3AgYmFjazogXCIrcy5nZXRDbGFzcygpLmdldFNpbXBsZU5hbWUoKSk7XHJcblx0XHRcdHRoaXMucmVwb3J0VW53YW50ZWRUb2tlbihyZWNvZ25pemVyKTtcclxuXHRcdFx0bGV0IGV4cGVjdGluZzogSW50ZXJ2YWxTZXQgPSByZWNvZ25pemVyLmdldEV4cGVjdGVkVG9rZW5zKCk7XHJcblx0XHRcdGxldCB3aGF0Rm9sbG93c0xvb3BJdGVyYXRpb25PclJ1bGU6IEludGVydmFsU2V0ID1cclxuXHRcdFx0XHRleHBlY3Rpbmcub3IodGhpcy5nZXRFcnJvclJlY292ZXJ5U2V0KHJlY29nbml6ZXIpKTtcclxuXHRcdFx0dGhpcy5jb25zdW1lVW50aWwocmVjb2duaXplciwgd2hhdEZvbGxvd3NMb29wSXRlcmF0aW9uT3JSdWxlKTtcclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0Ly8gZG8gbm90aGluZyBpZiB3ZSBjYW4ndCBpZGVudGlmeSB0aGUgZXhhY3Qga2luZCBvZiBBVE4gc3RhdGVcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIGNhbGxlZCBieSB7QGxpbmsgI3JlcG9ydEVycm9yfSB3aGVuIHRoZSBleGNlcHRpb24gaXMgYVxyXG5cdCAqIHtAbGluayBOb1ZpYWJsZUFsdEV4Y2VwdGlvbn0uXHJcblx0ICpcclxuXHQgKiBAc2VlICNyZXBvcnRFcnJvclxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxyXG5cdCAqIEBwYXJhbSBlIHRoZSByZWNvZ25pdGlvbiBleGNlcHRpb25cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcmVwb3J0Tm9WaWFibGVBbHRlcm5hdGl2ZShcclxuXHRcdEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlcixcclxuXHRcdEBOb3ROdWxsIGU6IE5vVmlhYmxlQWx0RXhjZXB0aW9uKTogdm9pZCB7XHJcblx0XHRsZXQgdG9rZW5zOiBUb2tlblN0cmVhbSA9IHJlY29nbml6ZXIuaW5wdXRTdHJlYW07XHJcblx0XHRsZXQgaW5wdXQ6IHN0cmluZztcclxuXHRcdGlmICh0b2tlbnMpIHtcclxuXHRcdFx0aWYgKGUuc3RhcnRUb2tlbi50eXBlID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0XHRpbnB1dCA9IFwiPEVPRj5cIjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpbnB1dCA9IHRva2Vucy5nZXRUZXh0RnJvbVJhbmdlKGUuc3RhcnRUb2tlbiwgZS5nZXRPZmZlbmRpbmdUb2tlbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGlucHV0ID0gXCI8dW5rbm93biBpbnB1dD5cIjtcclxuXHRcdH1cclxuXHRcdGxldCBtc2c6IHN0cmluZyA9IFwibm8gdmlhYmxlIGFsdGVybmF0aXZlIGF0IGlucHV0IFwiICsgdGhpcy5lc2NhcGVXU0FuZFF1b3RlKGlucHV0KTtcclxuXHRcdHRoaXMubm90aWZ5RXJyb3JMaXN0ZW5lcnMocmVjb2duaXplciwgbXNnLCBlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgY2FsbGVkIGJ5IHtAbGluayAjcmVwb3J0RXJyb3J9IHdoZW4gdGhlIGV4Y2VwdGlvbiBpcyBhblxyXG5cdCAqIHtAbGluayBJbnB1dE1pc21hdGNoRXhjZXB0aW9ufS5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI3JlcG9ydEVycm9yXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICogQHBhcmFtIGUgdGhlIHJlY29nbml0aW9uIGV4Y2VwdGlvblxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCByZXBvcnRJbnB1dE1pc21hdGNoKFxyXG5cdFx0QE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyLFxyXG5cdFx0QE5vdE51bGwgZTogSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbik6IHZvaWQge1xyXG5cdFx0bGV0IGV4cGVjdGVkID0gZS5leHBlY3RlZFRva2VucztcclxuXHRcdGxldCBleHBlY3RlZFN0cmluZyA9IGV4cGVjdGVkID8gZXhwZWN0ZWQudG9TdHJpbmdWb2NhYnVsYXJ5KHJlY29nbml6ZXIudm9jYWJ1bGFyeSkgOiBcIlwiO1xyXG5cdFx0bGV0IG1zZzogc3RyaW5nID0gXCJtaXNtYXRjaGVkIGlucHV0IFwiICsgdGhpcy5nZXRUb2tlbkVycm9yRGlzcGxheShlLmdldE9mZmVuZGluZ1Rva2VuKHJlY29nbml6ZXIpKSArXHJcblx0XHRcdFwiIGV4cGVjdGluZyBcIiArIGV4cGVjdGVkU3RyaW5nO1xyXG5cdFx0dGhpcy5ub3RpZnlFcnJvckxpc3RlbmVycyhyZWNvZ25pemVyLCBtc2csIGUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyBjYWxsZWQgYnkge0BsaW5rICNyZXBvcnRFcnJvcn0gd2hlbiB0aGUgZXhjZXB0aW9uIGlzIGFcclxuXHQgKiB7QGxpbmsgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9ufS5cclxuXHQgKlxyXG5cdCAqIEBzZWUgI3JlcG9ydEVycm9yXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICogQHBhcmFtIGUgdGhlIHJlY29nbml0aW9uIGV4Y2VwdGlvblxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCByZXBvcnRGYWlsZWRQcmVkaWNhdGUoXHJcblx0XHRATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIsXHJcblx0XHRATm90TnVsbCBlOiBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24pOiB2b2lkIHtcclxuXHRcdGxldCBydWxlTmFtZTogc3RyaW5nID0gcmVjb2duaXplci5ydWxlTmFtZXNbcmVjb2duaXplci5jb250ZXh0LnJ1bGVJbmRleF07XHJcblx0XHRsZXQgbXNnOiBzdHJpbmcgPSBcInJ1bGUgXCIgKyBydWxlTmFtZSArIFwiIFwiICsgZS5tZXNzYWdlO1xyXG5cdFx0dGhpcy5ub3RpZnlFcnJvckxpc3RlbmVycyhyZWNvZ25pemVyLCBtc2csIGUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHRvIHJlcG9ydCBhIHN5bnRheCBlcnJvciB3aGljaCByZXF1aXJlcyB0aGUgcmVtb3ZhbFxyXG5cdCAqIG9mIGEgdG9rZW4gZnJvbSB0aGUgaW5wdXQgc3RyZWFtLiBBdCB0aGUgdGltZSB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZVxyXG5cdCAqIGVycm9uZW91cyBzeW1ib2wgaXMgY3VycmVudCBgTFQoMSlgIHN5bWJvbCBhbmQgaGFzIG5vdCB5ZXQgYmVlblxyXG5cdCAqIHJlbW92ZWQgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLiBXaGVuIHRoaXMgbWV0aG9kIHJldHVybnMsXHJcblx0ICogYHJlY29nbml6ZXJgIGlzIGluIGVycm9yIHJlY292ZXJ5IG1vZGUuXHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB7QGxpbmsgI3NpbmdsZVRva2VuRGVsZXRpb259IGlkZW50aWZpZXNcclxuXHQgKiBzaW5nbGUtdG9rZW4gZGVsZXRpb24gYXMgYSB2aWFibGUgcmVjb3Zlcnkgc3RyYXRlZ3kgZm9yIGEgbWlzbWF0Y2hlZFxyXG5cdCAqIGlucHV0IGVycm9yLlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2ltcGx5IHJldHVybnMgaWYgdGhlIGhhbmRsZXIgaXMgYWxyZWFkeSBpblxyXG5cdCAqIGVycm9yIHJlY292ZXJ5IG1vZGUuIE90aGVyd2lzZSwgaXQgY2FsbHMge0BsaW5rICNiZWdpbkVycm9yQ29uZGl0aW9ufSB0b1xyXG5cdCAqIGVudGVyIGVycm9yIHJlY292ZXJ5IG1vZGUsIGZvbGxvd2VkIGJ5IGNhbGxpbmdcclxuXHQgKiB7QGxpbmsgUGFyc2VyI25vdGlmeUVycm9yTGlzdGVuZXJzfS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcmVwb3J0VW53YW50ZWRUb2tlbihATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLmluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcikpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYmVnaW5FcnJvckNvbmRpdGlvbihyZWNvZ25pemVyKTtcclxuXHJcblx0XHRsZXQgdDogVG9rZW4gPSByZWNvZ25pemVyLmN1cnJlbnRUb2tlbjtcclxuXHRcdGxldCB0b2tlbk5hbWU6IHN0cmluZyA9IHRoaXMuZ2V0VG9rZW5FcnJvckRpc3BsYXkodCk7XHJcblx0XHRsZXQgZXhwZWN0aW5nOiBJbnRlcnZhbFNldCA9IHRoaXMuZ2V0RXhwZWN0ZWRUb2tlbnMocmVjb2duaXplcik7XHJcblx0XHRsZXQgbXNnOiBzdHJpbmcgPSBcImV4dHJhbmVvdXMgaW5wdXQgXCIgKyB0b2tlbk5hbWUgKyBcIiBleHBlY3RpbmcgXCIgK1xyXG5cdFx0XHRleHBlY3RpbmcudG9TdHJpbmdWb2NhYnVsYXJ5KHJlY29nbml6ZXIudm9jYWJ1bGFyeSk7XHJcblx0XHRyZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZywgdCwgdW5kZWZpbmVkKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0byByZXBvcnQgYSBzeW50YXggZXJyb3Igd2hpY2ggcmVxdWlyZXMgdGhlXHJcblx0ICogaW5zZXJ0aW9uIG9mIGEgbWlzc2luZyB0b2tlbiBpbnRvIHRoZSBpbnB1dCBzdHJlYW0uIEF0IHRoZSB0aW1lIHRoaXNcclxuXHQgKiBtZXRob2QgaXMgY2FsbGVkLCB0aGUgbWlzc2luZyB0b2tlbiBoYXMgbm90IHlldCBiZWVuIGluc2VydGVkLiBXaGVuIHRoaXNcclxuXHQgKiBtZXRob2QgcmV0dXJucywgYHJlY29nbml6ZXJgIGlzIGluIGVycm9yIHJlY292ZXJ5IG1vZGUuXHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB7QGxpbmsgI3NpbmdsZVRva2VuSW5zZXJ0aW9ufSBpZGVudGlmaWVzXHJcblx0ICogc2luZ2xlLXRva2VuIGluc2VydGlvbiBhcyBhIHZpYWJsZSByZWNvdmVyeSBzdHJhdGVneSBmb3IgYSBtaXNtYXRjaGVkXHJcblx0ICogaW5wdXQgZXJyb3IuXHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW1wbHkgcmV0dXJucyBpZiB0aGUgaGFuZGxlciBpcyBhbHJlYWR5IGluXHJcblx0ICogZXJyb3IgcmVjb3ZlcnkgbW9kZS4gT3RoZXJ3aXNlLCBpdCBjYWxscyB7QGxpbmsgI2JlZ2luRXJyb3JDb25kaXRpb259IHRvXHJcblx0ICogZW50ZXIgZXJyb3IgcmVjb3ZlcnkgbW9kZSwgZm9sbG93ZWQgYnkgY2FsbGluZ1xyXG5cdCAqIHtAbGluayBQYXJzZXIjbm90aWZ5RXJyb3JMaXN0ZW5lcnN9LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCByZXBvcnRNaXNzaW5nVG9rZW4oQE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5pbkVycm9yUmVjb3ZlcnlNb2RlKHJlY29nbml6ZXIpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJlZ2luRXJyb3JDb25kaXRpb24ocmVjb2duaXplcik7XHJcblxyXG5cdFx0bGV0IHQ6IFRva2VuID0gcmVjb2duaXplci5jdXJyZW50VG9rZW47XHJcblx0XHRsZXQgZXhwZWN0aW5nOiBJbnRlcnZhbFNldCA9IHRoaXMuZ2V0RXhwZWN0ZWRUb2tlbnMocmVjb2duaXplcik7XHJcblx0XHRsZXQgbXNnOiBzdHJpbmcgPSBcIm1pc3NpbmcgXCIgKyBleHBlY3RpbmcudG9TdHJpbmdWb2NhYnVsYXJ5KHJlY29nbml6ZXIudm9jYWJ1bGFyeSkgK1xyXG5cdFx0XHRcIiBhdCBcIiArIHRoaXMuZ2V0VG9rZW5FcnJvckRpc3BsYXkodCk7XHJcblxyXG5cdFx0cmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtc2csIHQsIHVuZGVmaW5lZCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBhdHRlbXB0cyB0byByZWNvdmVyIGZyb20gdGhlIG1pc21hdGNoZWQgaW5wdXRcclxuXHQgKiBieSB1c2luZyBzaW5nbGUgdG9rZW4gaW5zZXJ0aW9uIGFuZCBkZWxldGlvbiBhcyBkZXNjcmliZWQgYmVsb3cuIElmIHRoZVxyXG5cdCAqIHJlY292ZXJ5IGF0dGVtcHQgZmFpbHMsIHRoaXMgbWV0aG9kXHJcblx0ICoge0BsaW5rIElucHV0TWlzbWF0Y2hFeGNlcHRpb259LlxyXG5cdCAqXHJcblx0ICogKipFWFRSQSBUT0tFTioqIChzaW5nbGUgdG9rZW4gZGVsZXRpb24pXHJcblx0ICpcclxuXHQgKiBgTEEoMSlgIGlzIG5vdCB3aGF0IHdlIGFyZSBsb29raW5nIGZvci4gSWYgYExBKDIpYCBoYXMgdGhlXHJcblx0ICogcmlnaHQgdG9rZW4sIGhvd2V2ZXIsIHRoZW4gYXNzdW1lIGBMQSgxKWAgaXMgc29tZSBleHRyYSBzcHVyaW91c1xyXG5cdCAqIHRva2VuIGFuZCBkZWxldGUgaXQuIFRoZW4gY29uc3VtZSBhbmQgcmV0dXJuIHRoZSBuZXh0IHRva2VuICh3aGljaCB3YXNcclxuXHQgKiB0aGUgYExBKDIpYCB0b2tlbikgYXMgdGhlIHN1Y2Nlc3NmdWwgcmVzdWx0IG9mIHRoZSBtYXRjaCBvcGVyYXRpb24uXHJcblx0ICpcclxuXHQgKiBUaGlzIHJlY292ZXJ5IHN0cmF0ZWd5IGlzIGltcGxlbWVudGVkIGJ5IHtAbGluayAjc2luZ2xlVG9rZW5EZWxldGlvbn0uXHJcblx0ICpcclxuXHQgKiAqKk1JU1NJTkcgVE9LRU4qKiAoc2luZ2xlIHRva2VuIGluc2VydGlvbilcclxuXHQgKlxyXG5cdCAqIElmIGN1cnJlbnQgdG9rZW4gKGF0IGBMQSgxKWApIGlzIGNvbnNpc3RlbnQgd2l0aCB3aGF0IGNvdWxkIGNvbWVcclxuXHQgKiBhZnRlciB0aGUgZXhwZWN0ZWQgYExBKDEpYCB0b2tlbiwgdGhlbiBhc3N1bWUgdGhlIHRva2VuIGlzIG1pc3NpbmdcclxuXHQgKiBhbmQgdXNlIHRoZSBwYXJzZXIncyB7QGxpbmsgVG9rZW5GYWN0b3J5fSB0byBjcmVhdGUgaXQgb24gdGhlIGZseS4gVGhlXHJcblx0ICogXCJpbnNlcnRpb25cIiBpcyBwZXJmb3JtZWQgYnkgcmV0dXJuaW5nIHRoZSBjcmVhdGVkIHRva2VuIGFzIHRoZSBzdWNjZXNzZnVsXHJcblx0ICogcmVzdWx0IG9mIHRoZSBtYXRjaCBvcGVyYXRpb24uXHJcblx0ICpcclxuXHQgKiBUaGlzIHJlY292ZXJ5IHN0cmF0ZWd5IGlzIGltcGxlbWVudGVkIGJ5IHtAbGluayAjc2luZ2xlVG9rZW5JbnNlcnRpb259LlxyXG5cdCAqXHJcblx0ICogKipFWEFNUExFKipcclxuXHQgKlxyXG5cdCAqIEZvciBleGFtcGxlLCBJbnB1dCBgaT0oMztgIGlzIGNsZWFybHkgbWlzc2luZyB0aGUgYCcpJ2AuIFdoZW5cclxuXHQgKiB0aGUgcGFyc2VyIHJldHVybnMgZnJvbSB0aGUgbmVzdGVkIGNhbGwgdG8gYGV4cHJgLCBpdCB3aWxsIGhhdmVcclxuXHQgKiBjYWxsIGNoYWluOlxyXG5cdCAqXHJcblx0ICogYGBgXHJcblx0ICogc3RhdCBcdTIxOTIgZXhwciBcdTIxOTIgYXRvbVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogYW5kIGl0IHdpbGwgYmUgdHJ5aW5nIHRvIG1hdGNoIHRoZSBgJyknYCBhdCB0aGlzIHBvaW50IGluIHRoZVxyXG5cdCAqIGRlcml2YXRpb246XHJcblx0ICpcclxuXHQgKiBgYGBcclxuXHQgKiA9PiBJRCAnPScgJygnIElOVCAnKScgKCcrJyBhdG9tKSogJzsnXHJcblx0ICogICAgICAgICAgICAgICAgICAgIF5cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIFRoZSBhdHRlbXB0IHRvIG1hdGNoIGAnKSdgIHdpbGwgZmFpbCB3aGVuIGl0IHNlZXMgYCc7J2AgYW5kXHJcblx0ICogY2FsbCB7QGxpbmsgI3JlY292ZXJJbmxpbmV9LiBUbyByZWNvdmVyLCBpdCBzZWVzIHRoYXQgYExBKDEpPT0nOydgXHJcblx0ICogaXMgaW4gdGhlIHNldCBvZiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IHRoZSBgJyknYCB0b2tlbiByZWZlcmVuY2VcclxuXHQgKiBpbiBydWxlIGBhdG9tYC4gSXQgY2FuIGFzc3VtZSB0aGF0IHlvdSBmb3Jnb3QgdGhlIGAnKSdgLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZWNvdmVySW5saW5lKHJlY29nbml6ZXI6IFBhcnNlcik6IFRva2VuIHtcclxuXHRcdC8vIFNJTkdMRSBUT0tFTiBERUxFVElPTlxyXG5cdFx0bGV0IG1hdGNoZWRTeW1ib2wgPSB0aGlzLnNpbmdsZVRva2VuRGVsZXRpb24ocmVjb2duaXplcik7XHJcblx0XHRpZiAobWF0Y2hlZFN5bWJvbCkge1xyXG5cdFx0XHQvLyB3ZSBoYXZlIGRlbGV0ZWQgdGhlIGV4dHJhIHRva2VuLlxyXG5cdFx0XHQvLyBub3csIG1vdmUgcGFzdCB0dHlwZSB0b2tlbiBhcyBpZiBhbGwgd2VyZSBva1xyXG5cdFx0XHRyZWNvZ25pemVyLmNvbnN1bWUoKTtcclxuXHRcdFx0cmV0dXJuIG1hdGNoZWRTeW1ib2w7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU0lOR0xFIFRPS0VOIElOU0VSVElPTlxyXG5cdFx0aWYgKHRoaXMuc2luZ2xlVG9rZW5JbnNlcnRpb24ocmVjb2duaXplcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0TWlzc2luZ1N5bWJvbChyZWNvZ25pemVyKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBldmVuIHRoYXQgZGlkbid0IHdvcms7IG11c3QgdGhyb3cgdGhlIGV4Y2VwdGlvblxyXG5cdFx0aWYgKHRoaXMubmV4dFRva2Vuc0NvbnRleHQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbihyZWNvZ25pemVyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRocm93IG5ldyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uKHJlY29nbml6ZXIsIHRoaXMubmV4dFRva2Vuc1N0YXRlLCB0aGlzLm5leHRUb2tlbnNDb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIHNpbmdsZS10b2tlbiBpbnNlcnRpb24gaW5saW5lIGVycm9yIHJlY292ZXJ5XHJcblx0ICogc3RyYXRlZ3kuIEl0IGlzIGNhbGxlZCBieSB7QGxpbmsgI3JlY292ZXJJbmxpbmV9IGlmIHRoZSBzaW5nbGUtdG9rZW5cclxuXHQgKiBkZWxldGlvbiBzdHJhdGVneSBmYWlscyB0byByZWNvdmVyIGZyb20gdGhlIG1pc21hdGNoZWQgaW5wdXQuIElmIHRoaXNcclxuXHQgKiBtZXRob2QgcmV0dXJucyBgdHJ1ZWAsIGByZWNvZ25pemVyYCB3aWxsIGJlIGluIGVycm9yIHJlY292ZXJ5XHJcblx0ICogbW9kZS5cclxuXHQgKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGRldGVybWluZXMgd2hldGhlciBvciBub3Qgc2luZ2xlLXRva2VuIGluc2VydGlvbiBpcyB2aWFibGUgYnlcclxuXHQgKiBjaGVja2luZyBpZiB0aGUgYExBKDEpYCBpbnB1dCBzeW1ib2wgY291bGQgYmUgc3VjY2Vzc2Z1bGx5IG1hdGNoZWRcclxuXHQgKiBpZiBpdCB3ZXJlIGluc3RlYWQgdGhlIGBMQSgyKWAgc3ltYm9sLiBJZiB0aGlzIG1ldGhvZCByZXR1cm5zXHJcblx0ICogYHRydWVgLCB0aGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgaW5zZXJ0aW5nIGFcclxuXHQgKiB0b2tlbiB3aXRoIHRoZSBjb3JyZWN0IHR5cGUgdG8gcHJvZHVjZSB0aGlzIGJlaGF2aW9yLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxyXG5cdCAqIEByZXR1cm5zIGB0cnVlYCBpZiBzaW5nbGUtdG9rZW4gaW5zZXJ0aW9uIGlzIGEgdmlhYmxlIHJlY292ZXJ5XHJcblx0ICogc3RyYXRlZ3kgZm9yIHRoZSBjdXJyZW50IG1pc21hdGNoZWQgaW5wdXQsIG90aGVyd2lzZSBgZmFsc2VgXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHNpbmdsZVRva2VuSW5zZXJ0aW9uKEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlcik6IGJvb2xlYW4ge1xyXG5cdFx0bGV0IGN1cnJlbnRTeW1ib2xUeXBlOiBudW1iZXIgPSByZWNvZ25pemVyLmlucHV0U3RyZWFtLkxBKDEpO1xyXG5cdFx0Ly8gaWYgY3VycmVudCB0b2tlbiBpcyBjb25zaXN0ZW50IHdpdGggd2hhdCBjb3VsZCBjb21lIGFmdGVyIGN1cnJlbnRcclxuXHRcdC8vIEFUTiBzdGF0ZSwgdGhlbiB3ZSBrbm93IHdlJ3JlIG1pc3NpbmcgYSB0b2tlbjsgZXJyb3IgcmVjb3ZlcnlcclxuXHRcdC8vIGlzIGZyZWUgdG8gY29uanVyZSB1cCBhbmQgaW5zZXJ0IHRoZSBtaXNzaW5nIHRva2VuXHJcblx0XHRsZXQgY3VycmVudFN0YXRlID0gcmVjb2duaXplci5pbnRlcnByZXRlci5hdG4uc3RhdGVzW3JlY29nbml6ZXIuc3RhdGVdO1xyXG5cdFx0bGV0IG5leHQ6IEFUTlN0YXRlID0gY3VycmVudFN0YXRlLnRyYW5zaXRpb24oMCkudGFyZ2V0O1xyXG5cdFx0bGV0IGF0bjogQVROID0gcmVjb2duaXplci5pbnRlcnByZXRlci5hdG47XHJcblx0XHRsZXQgZXhwZWN0aW5nQXRMTDI6IEludGVydmFsU2V0ID0gYXRuLm5leHRUb2tlbnMobmV4dCwgUHJlZGljdGlvbkNvbnRleHQuZnJvbVJ1bGVDb250ZXh0KGF0biwgcmVjb2duaXplci5jb250ZXh0KSk7XHJcbi8vXHRcdGNvbnNvbGUud2FybihcIkxUKDIpIHNldD1cIitleHBlY3RpbmdBdExMMi50b1N0cmluZyhyZWNvZ25pemVyLmdldFRva2VuTmFtZXMoKSkpO1xyXG5cdFx0aWYgKGV4cGVjdGluZ0F0TEwyLmNvbnRhaW5zKGN1cnJlbnRTeW1ib2xUeXBlKSkge1xyXG5cdFx0XHR0aGlzLnJlcG9ydE1pc3NpbmdUb2tlbihyZWNvZ25pemVyKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBzaW5nbGUtdG9rZW4gZGVsZXRpb24gaW5saW5lIGVycm9yIHJlY292ZXJ5XHJcblx0ICogc3RyYXRlZ3kuIEl0IGlzIGNhbGxlZCBieSB7QGxpbmsgI3JlY292ZXJJbmxpbmV9IHRvIGF0dGVtcHQgdG8gcmVjb3ZlclxyXG5cdCAqIGZyb20gbWlzbWF0Y2hlZCBpbnB1dC4gSWYgdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYCwgdGhlIHBhcnNlciBhbmQgZXJyb3JcclxuXHQgKiBoYW5kbGVyIHN0YXRlIHdpbGwgbm90IGhhdmUgY2hhbmdlZC4gSWYgdGhpcyBtZXRob2QgcmV0dXJucyBub24tYHVuZGVmaW5lZGAsXHJcblx0ICogYHJlY29nbml6ZXJgIHdpbGwgKm5vdCogYmUgaW4gZXJyb3IgcmVjb3ZlcnkgbW9kZSBzaW5jZSB0aGVcclxuXHQgKiByZXR1cm5lZCB0b2tlbiB3YXMgYSBzdWNjZXNzZnVsIG1hdGNoLlxyXG5cdCAqXHJcblx0ICogSWYgdGhlIHNpbmdsZS10b2tlbiBkZWxldGlvbiBpcyBzdWNjZXNzZnVsLCB0aGlzIG1ldGhvZCBjYWxsc1xyXG5cdCAqIHtAbGluayAjcmVwb3J0VW53YW50ZWRUb2tlbn0gdG8gcmVwb3J0IHRoZSBlcnJvciwgZm9sbG93ZWQgYnlcclxuXHQgKiB7QGxpbmsgUGFyc2VyI2NvbnN1bWV9IHRvIGFjdHVhbGx5IFwiZGVsZXRlXCIgdGhlIGV4dHJhbmVvdXMgdG9rZW4uIFRoZW4sXHJcblx0ICogYmVmb3JlIHJldHVybmluZyB7QGxpbmsgI3JlcG9ydE1hdGNofSBpcyBjYWxsZWQgdG8gc2lnbmFsIGEgc3VjY2Vzc2Z1bFxyXG5cdCAqIG1hdGNoLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxyXG5cdCAqIEByZXR1cm5zIHRoZSBzdWNjZXNzZnVsbHkgbWF0Y2hlZCB7QGxpbmsgVG9rZW59IGluc3RhbmNlIGlmIHNpbmdsZS10b2tlblxyXG5cdCAqIGRlbGV0aW9uIHN1Y2Nlc3NmdWxseSByZWNvdmVycyBmcm9tIHRoZSBtaXNtYXRjaGVkIGlucHV0LCBvdGhlcndpc2VcclxuXHQgKiBgdW5kZWZpbmVkYFxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBzaW5nbGVUb2tlbkRlbGV0aW9uKEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlcik6IFRva2VuIHwgdW5kZWZpbmVkIHtcclxuXHRcdGxldCBuZXh0VG9rZW5UeXBlOiBudW1iZXIgPSByZWNvZ25pemVyLmlucHV0U3RyZWFtLkxBKDIpO1xyXG5cdFx0bGV0IGV4cGVjdGluZzogSW50ZXJ2YWxTZXQgPSB0aGlzLmdldEV4cGVjdGVkVG9rZW5zKHJlY29nbml6ZXIpO1xyXG5cdFx0aWYgKGV4cGVjdGluZy5jb250YWlucyhuZXh0VG9rZW5UeXBlKSkge1xyXG5cdFx0XHR0aGlzLnJlcG9ydFVud2FudGVkVG9rZW4ocmVjb2duaXplcik7XHJcblx0XHRcdC8qXHJcblx0XHRcdFN5c3RlbS5lcnIucHJpbnRsbihcInJlY292ZXJGcm9tTWlzbWF0Y2hlZFRva2VuIGRlbGV0aW5nIFwiK1xyXG5cdFx0XHRcdFx0XHRcdCAgICgoVG9rZW5TdHJlYW0pcmVjb2duaXplci5pbnB1dFN0cmVhbSkuTFQoMSkrXHJcblx0XHRcdFx0XHRcdFx0ICAgXCIgc2luY2UgXCIrKChUb2tlblN0cmVhbSlyZWNvZ25pemVyLmlucHV0U3RyZWFtKS5MVCgyKStcclxuXHRcdFx0XHRcdFx0XHQgICBcIiBpcyB3aGF0IHdlIHdhbnRcIik7XHJcblx0XHRcdCovXHJcblx0XHRcdHJlY29nbml6ZXIuY29uc3VtZSgpOyAvLyBzaW1wbHkgZGVsZXRlIGV4dHJhIHRva2VuXHJcblx0XHRcdC8vIHdlIHdhbnQgdG8gcmV0dXJuIHRoZSB0b2tlbiB3ZSdyZSBhY3R1YWxseSBtYXRjaGluZ1xyXG5cdFx0XHRsZXQgbWF0Y2hlZFN5bWJvbDogVG9rZW4gPSByZWNvZ25pemVyLmN1cnJlbnRUb2tlbjtcclxuXHRcdFx0dGhpcy5yZXBvcnRNYXRjaChyZWNvZ25pemVyKTsgIC8vIHdlIGtub3cgY3VycmVudCB0b2tlbiBpcyBjb3JyZWN0XHJcblx0XHRcdHJldHVybiBtYXRjaGVkU3ltYm9sO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdC8qKiBDb25qdXJlIHVwIGEgbWlzc2luZyB0b2tlbiBkdXJpbmcgZXJyb3IgcmVjb3ZlcnkuXHJcblx0ICpcclxuXHQgKiAgVGhlIHJlY29nbml6ZXIgYXR0ZW1wdHMgdG8gcmVjb3ZlciBmcm9tIHNpbmdsZSBtaXNzaW5nXHJcblx0ICogIHN5bWJvbHMuIEJ1dCwgYWN0aW9ucyBtaWdodCByZWZlciB0byB0aGF0IG1pc3Npbmcgc3ltYm9sLlxyXG5cdCAqICBGb3IgZXhhbXBsZSwgeD1JRCB7ZigkeCk7fS4gVGhlIGFjdGlvbiBjbGVhcmx5IGFzc3VtZXNcclxuXHQgKiAgdGhhdCB0aGVyZSBoYXMgYmVlbiBhbiBpZGVudGlmaWVyIG1hdGNoZWQgcHJldmlvdXNseSBhbmQgdGhhdFxyXG5cdCAqICAkeCBwb2ludHMgYXQgdGhhdCB0b2tlbi4gSWYgdGhhdCB0b2tlbiBpcyBtaXNzaW5nLCBidXRcclxuXHQgKiAgdGhlIG5leHQgdG9rZW4gaW4gdGhlIHN0cmVhbSBpcyB3aGF0IHdlIHdhbnQgd2UgYXNzdW1lIHRoYXRcclxuXHQgKiAgdGhpcyB0b2tlbiBpcyBtaXNzaW5nIGFuZCB3ZSBrZWVwIGdvaW5nLiBCZWNhdXNlIHdlXHJcblx0ICogIGhhdmUgdG8gcmV0dXJuIHNvbWUgdG9rZW4gdG8gcmVwbGFjZSB0aGUgbWlzc2luZyB0b2tlbixcclxuXHQgKiAgd2UgaGF2ZSB0byBjb25qdXJlIG9uZSB1cC4gVGhpcyBtZXRob2QgZ2l2ZXMgdGhlIHVzZXIgY29udHJvbFxyXG5cdCAqICBvdmVyIHRoZSB0b2tlbnMgcmV0dXJuZWQgZm9yIG1pc3NpbmcgdG9rZW5zLiBNb3N0bHksXHJcblx0ICogIHlvdSB3aWxsIHdhbnQgdG8gY3JlYXRlIHNvbWV0aGluZyBzcGVjaWFsIGZvciBpZGVudGlmaWVyXHJcblx0ICogIHRva2Vucy4gRm9yIGxpdGVyYWxzIHN1Y2ggYXMgJ3snIGFuZCAnLCcsIHRoZSBkZWZhdWx0XHJcblx0ICogIGFjdGlvbiBpbiB0aGUgcGFyc2VyIG9yIHRyZWUgcGFyc2VyIHdvcmtzLiBJdCBzaW1wbHkgY3JlYXRlc1xyXG5cdCAqICBhIENvbW1vblRva2VuIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlLiBUaGUgdGV4dCB3aWxsIGJlIHRoZSB0b2tlbi5cclxuXHQgKiAgSWYgeW91IGNoYW5nZSB3aGF0IHRva2VucyBtdXN0IGJlIGNyZWF0ZWQgYnkgdGhlIGxleGVyLFxyXG5cdCAqICBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIHRva2Vucy5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBnZXRNaXNzaW5nU3ltYm9sKEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlcik6IFRva2VuIHtcclxuXHRcdGxldCBjdXJyZW50U3ltYm9sOiBUb2tlbiA9IHJlY29nbml6ZXIuY3VycmVudFRva2VuO1xyXG5cdFx0bGV0IGV4cGVjdGluZzogSW50ZXJ2YWxTZXQgPSB0aGlzLmdldEV4cGVjdGVkVG9rZW5zKHJlY29nbml6ZXIpO1xyXG5cdFx0bGV0IGV4cGVjdGVkVG9rZW5UeXBlOiBudW1iZXIgPSBUb2tlbi5JTlZBTElEX1RZUEU7XHJcblx0XHRpZiAoIWV4cGVjdGluZy5pc05pbCkge1xyXG5cdFx0XHQvLyBnZXQgYW55IGVsZW1lbnRcclxuXHRcdFx0ZXhwZWN0ZWRUb2tlblR5cGUgPSBleHBlY3RpbmcubWluRWxlbWVudDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdG9rZW5UZXh0OiBzdHJpbmc7XHJcblx0XHRpZiAoZXhwZWN0ZWRUb2tlblR5cGUgPT09IFRva2VuLkVPRikge1xyXG5cdFx0XHR0b2tlblRleHQgPSBcIjxtaXNzaW5nIEVPRj5cIjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRva2VuVGV4dCA9IFwiPG1pc3NpbmcgXCIgKyByZWNvZ25pemVyLnZvY2FidWxhcnkuZ2V0RGlzcGxheU5hbWUoZXhwZWN0ZWRUb2tlblR5cGUpICsgXCI+XCI7XHJcblx0XHR9XHJcblx0XHRsZXQgY3VycmVudDogVG9rZW4gPSBjdXJyZW50U3ltYm9sO1xyXG5cdFx0bGV0IGxvb2tiYWNrID0gcmVjb2duaXplci5pbnB1dFN0cmVhbS50cnlMVCgtMSk7XHJcblx0XHRpZiAoY3VycmVudC50eXBlID09PSBUb2tlbi5FT0YgJiYgbG9va2JhY2sgIT0gbnVsbCkge1xyXG5cdFx0XHRjdXJyZW50ID0gbG9va2JhY2s7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0VG9rZW4ocmVjb2duaXplci5pbnB1dFN0cmVhbS50b2tlblNvdXJjZSwgZXhwZWN0ZWRUb2tlblR5cGUsIHRva2VuVGV4dCwgY3VycmVudCk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgY29uc3RydWN0VG9rZW4oXHJcblx0XHR0b2tlblNvdXJjZTogVG9rZW5Tb3VyY2UsXHJcblx0XHRleHBlY3RlZFRva2VuVHlwZTogbnVtYmVyLFxyXG5cdFx0dG9rZW5UZXh0OiBzdHJpbmcsXHJcblx0XHRjdXJyZW50OiBUb2tlbik6IFRva2VuIHtcclxuXHRcdGxldCBmYWN0b3J5OiBUb2tlbkZhY3RvcnkgPSB0b2tlblNvdXJjZS50b2tlbkZhY3Rvcnk7XHJcblx0XHRsZXQgeCA9IGN1cnJlbnQudG9rZW5Tb3VyY2U7XHJcblx0XHRsZXQgc3RyZWFtID0geCA/IHguaW5wdXRTdHJlYW0gOiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0cmV0dXJuIGZhY3RvcnkuY3JlYXRlKFxyXG5cdFx0XHR7IHNvdXJjZTogdG9rZW5Tb3VyY2UsIHN0cmVhbSB9LFxyXG5cdFx0XHRleHBlY3RlZFRva2VuVHlwZSwgdG9rZW5UZXh0LFxyXG5cdFx0XHRUb2tlbi5ERUZBVUxUX0NIQU5ORUwsXHJcblx0XHRcdC0xLCAtMSxcclxuXHRcdFx0Y3VycmVudC5saW5lLCBjdXJyZW50LmNoYXJQb3NpdGlvbkluTGluZSk7XHJcblx0fVxyXG5cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBnZXRFeHBlY3RlZFRva2VucyhATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIpOiBJbnRlcnZhbFNldCB7XHJcblx0XHRyZXR1cm4gcmVjb2duaXplci5nZXRFeHBlY3RlZFRva2VucygpO1xyXG5cdH1cclxuXHJcblx0LyoqIEhvdyBzaG91bGQgYSB0b2tlbiBiZSBkaXNwbGF5ZWQgaW4gYW4gZXJyb3IgbWVzc2FnZT8gVGhlIGRlZmF1bHRcclxuXHQgKiAgaXMgdG8gZGlzcGxheSBqdXN0IHRoZSB0ZXh0LCBidXQgZHVyaW5nIGRldmVsb3BtZW50IHlvdSBtaWdodFxyXG5cdCAqICB3YW50IHRvIGhhdmUgYSBsb3Qgb2YgaW5mb3JtYXRpb24gc3BpdCBvdXQuICBPdmVycmlkZSBpbiB0aGF0IGNhc2VcclxuXHQgKiAgdG8gdXNlIHQudG9TdHJpbmcoKSAod2hpY2gsIGZvciBDb21tb25Ub2tlbiwgZHVtcHMgZXZlcnl0aGluZyBhYm91dFxyXG5cdCAqICB0aGUgdG9rZW4pLiBUaGlzIGlzIGJldHRlciB0aGFuIGZvcmNpbmcgeW91IHRvIG92ZXJyaWRlIGEgbWV0aG9kIGluXHJcblx0ICogIHlvdXIgdG9rZW4gb2JqZWN0cyBiZWNhdXNlIHlvdSBkb24ndCBoYXZlIHRvIGdvIG1vZGlmeSB5b3VyIGxleGVyXHJcblx0ICogIHNvIHRoYXQgaXQgY3JlYXRlcyBhIG5ldyBKYXZhIHR5cGUuXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGdldFRva2VuRXJyb3JEaXNwbGF5KHQ6IFRva2VuIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcclxuXHRcdGlmICghdCkge1xyXG5cdFx0XHRyZXR1cm4gXCI8bm8gdG9rZW4+XCI7XHJcblx0XHR9XHJcblx0XHRsZXQgcyA9IHRoaXMuZ2V0U3ltYm9sVGV4dCh0KTtcclxuXHRcdGlmICghcykge1xyXG5cdFx0XHRpZiAodGhpcy5nZXRTeW1ib2xUeXBlKHQpID09PSBUb2tlbi5FT0YpIHtcclxuXHRcdFx0XHRzID0gXCI8RU9GPlwiO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHMgPSBgPCR7dGhpcy5nZXRTeW1ib2xUeXBlKHQpfT5gO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5lc2NhcGVXU0FuZFF1b3RlKHMpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldFN5bWJvbFRleHQoQE5vdE51bGwgc3ltYm9sOiBUb2tlbik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gc3ltYm9sLnRleHQ7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0U3ltYm9sVHlwZShATm90TnVsbCBzeW1ib2w6IFRva2VuKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBzeW1ib2wudHlwZTtcclxuXHR9XHJcblxyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGVzY2FwZVdTQW5kUXVvdGUoQE5vdE51bGwgczogc3RyaW5nKTogc3RyaW5nIHtcclxuLy9cdFx0aWYgKCBzPT1udWxsICkgcmV0dXJuIHM7XHJcblx0XHRzID0gcy5yZXBsYWNlKFwiXFxuXCIsIFwiXFxcXG5cIik7XHJcblx0XHRzID0gcy5yZXBsYWNlKFwiXFxyXCIsIFwiXFxcXHJcIik7XHJcblx0XHRzID0gcy5yZXBsYWNlKFwiXFx0XCIsIFwiXFxcXHRcIik7XHJcblx0XHRyZXR1cm4gXCInXCIgKyBzICsgXCInXCI7XHJcblx0fVxyXG5cclxuXHQvKiAgQ29tcHV0ZSB0aGUgZXJyb3IgcmVjb3Zlcnkgc2V0IGZvciB0aGUgY3VycmVudCBydWxlLiAgRHVyaW5nXHJcblx0ICogIHJ1bGUgaW52b2NhdGlvbiwgdGhlIHBhcnNlciBwdXNoZXMgdGhlIHNldCBvZiB0b2tlbnMgdGhhdCBjYW5cclxuXHQgKiAgZm9sbG93IHRoYXQgcnVsZSByZWZlcmVuY2Ugb24gdGhlIHN0YWNrOyB0aGlzIGFtb3VudHMgdG9cclxuXHQgKiAgY29tcHV0aW5nIEZJUlNUIG9mIHdoYXQgZm9sbG93cyB0aGUgcnVsZSByZWZlcmVuY2UgaW4gdGhlXHJcblx0ICogIGVuY2xvc2luZyBydWxlLiBTZWUgTGluZWFyQXBwcm94aW1hdG9yLkZJUlNUKCkuXHJcblx0ICogIFRoaXMgbG9jYWwgZm9sbG93IHNldCBvbmx5IGluY2x1ZGVzIHRva2Vuc1xyXG5cdCAqICBmcm9tIHdpdGhpbiB0aGUgcnVsZTsgaS5lLiwgdGhlIEZJUlNUIGNvbXB1dGF0aW9uIGRvbmUgYnlcclxuXHQgKiAgQU5UTFIgc3RvcHMgYXQgdGhlIGVuZCBvZiBhIHJ1bGUuXHJcblx0ICpcclxuXHQgKiAgRVhBTVBMRVxyXG5cdCAqXHJcblx0ICogIFdoZW4geW91IGZpbmQgYSBcIm5vIHZpYWJsZSBhbHQgZXhjZXB0aW9uXCIsIHRoZSBpbnB1dCBpcyBub3RcclxuXHQgKiAgY29uc2lzdGVudCB3aXRoIGFueSBvZiB0aGUgYWx0ZXJuYXRpdmVzIGZvciBydWxlIHIuICBUaGUgYmVzdFxyXG5cdCAqICB0aGluZyB0byBkbyBpcyB0byBjb25zdW1lIHRva2VucyB1bnRpbCB5b3Ugc2VlIHNvbWV0aGluZyB0aGF0XHJcblx0ICogIGNhbiBsZWdhbGx5IGZvbGxvdyBhIGNhbGwgdG8gciAqb3IqIGFueSBydWxlIHRoYXQgY2FsbGVkIHIuXHJcblx0ICogIFlvdSBkb24ndCB3YW50IHRoZSBleGFjdCBzZXQgb2YgdmlhYmxlIG5leHQgdG9rZW5zIGJlY2F1c2UgdGhlXHJcblx0ICogIGlucHV0IG1pZ2h0IGp1c3QgYmUgbWlzc2luZyBhIHRva2VuLS15b3UgbWlnaHQgY29uc3VtZSB0aGVcclxuXHQgKiAgcmVzdCBvZiB0aGUgaW5wdXQgbG9va2luZyBmb3Igb25lIG9mIHRoZSBtaXNzaW5nIHRva2Vucy5cclxuXHQgKlxyXG5cdCAqICBDb25zaWRlciBncmFtbWFyOlxyXG5cdCAqXHJcblx0ICogIGEgOiAnWycgYiAnXSdcclxuXHQgKiAgICB8ICcoJyBiICcpJ1xyXG5cdCAqICAgIDtcclxuXHQgKiAgYiA6IGMgJ14nIElOVCA7XHJcblx0ICogIGMgOiBJRFxyXG5cdCAqICAgIHwgSU5UXHJcblx0ICogICAgO1xyXG5cdCAqXHJcblx0ICogIEF0IGVhY2ggcnVsZSBpbnZvY2F0aW9uLCB0aGUgc2V0IG9mIHRva2VucyB0aGF0IGNvdWxkIGZvbGxvd1xyXG5cdCAqICB0aGF0IHJ1bGUgaXMgcHVzaGVkIG9uIGEgc3RhY2suICBIZXJlIGFyZSB0aGUgdmFyaW91c1xyXG5cdCAqICBjb250ZXh0LXNlbnNpdGl2ZSBmb2xsb3cgc2V0czpcclxuXHQgKlxyXG5cdCAqICBGT0xMT1coYjFfaW5fYSkgPSBGSVJTVCgnXScpID0gJ10nXHJcblx0ICogIEZPTExPVyhiMl9pbl9hKSA9IEZJUlNUKCcpJykgPSAnKSdcclxuXHQgKiAgRk9MTE9XKGNfaW5fYikgPSBGSVJTVCgnXicpID0gJ14nXHJcblx0ICpcclxuXHQgKiAgVXBvbiBlcnJvbmVvdXMgaW5wdXQgXCJbXVwiLCB0aGUgY2FsbCBjaGFpbiBpc1xyXG5cdCAqXHJcblx0ICogIGEgLT4gYiAtPiBjXHJcblx0ICpcclxuXHQgKiAgYW5kLCBoZW5jZSwgdGhlIGZvbGxvdyBjb250ZXh0IHN0YWNrIGlzOlxyXG5cdCAqXHJcblx0ICogIGRlcHRoICAgICBmb2xsb3cgc2V0ICAgICAgIHN0YXJ0IG9mIHJ1bGUgZXhlY3V0aW9uXHJcblx0ICogICAgMCAgICAgICAgIDxFT0Y+ICAgICAgICAgICAgICAgICAgICBhIChmcm9tIG1haW4oKSlcclxuXHQgKiAgICAxICAgICAgICAgICddJyAgICAgICAgICAgICAgICAgICAgIGJcclxuXHQgKiAgICAyICAgICAgICAgICdeJyAgICAgICAgICAgICAgICAgICAgIGNcclxuXHQgKlxyXG5cdCAqICBOb3RpY2UgdGhhdCAnKScgaXMgbm90IGluY2x1ZGVkLCBiZWNhdXNlIGIgd291bGQgaGF2ZSB0byBoYXZlXHJcblx0ICogIGJlZW4gY2FsbGVkIGZyb20gYSBkaWZmZXJlbnQgY29udGV4dCBpbiBydWxlIGEgZm9yICcpJyB0byBiZVxyXG5cdCAqICBpbmNsdWRlZC5cclxuXHQgKlxyXG5cdCAqICBGb3IgZXJyb3IgcmVjb3ZlcnksIHdlIGNhbm5vdCBjb25zaWRlciBGT0xMT1coYylcclxuXHQgKiAgKGNvbnRleHQtc2Vuc2l0aXZlIG9yIG90aGVyd2lzZSkuICBXZSBuZWVkIHRoZSBjb21iaW5lZCBzZXQgb2ZcclxuXHQgKiAgYWxsIGNvbnRleHQtc2Vuc2l0aXZlIEZPTExPVyBzZXRzLS10aGUgc2V0IG9mIGFsbCB0b2tlbnMgdGhhdFxyXG5cdCAqICBjb3VsZCBmb2xsb3cgYW55IHJlZmVyZW5jZSBpbiB0aGUgY2FsbCBjaGFpbi4gIFdlIG5lZWQgdG9cclxuXHQgKiAgcmVzeW5jIHRvIG9uZSBvZiB0aG9zZSB0b2tlbnMuICBOb3RlIHRoYXQgRk9MTE9XKGMpPSdeJyBhbmQgaWZcclxuXHQgKiAgd2UgcmVzeW5jJ2QgdG8gdGhhdCB0b2tlbiwgd2UnZCBjb25zdW1lIHVudGlsIEVPRi4gIFdlIG5lZWQgdG9cclxuXHQgKiAgc3luYyB0byBjb250ZXh0LXNlbnNpdGl2ZSBGT0xMT1dzIGZvciBhLCBiLCBhbmQgYzogeyddJywnXid9LlxyXG5cdCAqICBJbiB0aGlzIGNhc2UsIGZvciBpbnB1dCBcIltdXCIsIExBKDEpIGlzICddJyBhbmQgaW4gdGhlIHNldCwgc28gd2Ugd291bGRcclxuXHQgKiAgbm90IGNvbnN1bWUgYW55dGhpbmcuIEFmdGVyIHByaW50aW5nIGFuIGVycm9yLCBydWxlIGMgd291bGRcclxuXHQgKiAgcmV0dXJuIG5vcm1hbGx5LiAgUnVsZSBiIHdvdWxkIG5vdCBmaW5kIHRoZSByZXF1aXJlZCAnXicgdGhvdWdoLlxyXG5cdCAqICBBdCB0aGlzIHBvaW50LCBpdCBnZXRzIGEgbWlzbWF0Y2hlZCB0b2tlbiBlcnJvciBhbmRcclxuXHQgKiAgZXhjZXB0aW9uIChzaW5jZSBMQSgxKSBpcyBub3QgaW4gdGhlIHZpYWJsZSBmb2xsb3dpbmcgdG9rZW5cclxuXHQgKiAgc2V0KS4gIFRoZSBydWxlIGV4Y2VwdGlvbiBoYW5kbGVyIHRyaWVzIHRvIHJlY292ZXIsIGJ1dCBmaW5kc1xyXG5cdCAqICB0aGUgc2FtZSByZWNvdmVyeSBzZXQgYW5kIGRvZXNuJ3QgY29uc3VtZSBhbnl0aGluZy4gIFJ1bGUgYlxyXG5cdCAqICBleGl0cyBub3JtYWxseSByZXR1cm5pbmcgdG8gcnVsZSBhLiAgTm93IGl0IGZpbmRzIHRoZSAnXScgKGFuZFxyXG5cdCAqICB3aXRoIHRoZSBzdWNjZXNzZnVsIG1hdGNoIGV4aXRzIGVycm9yUmVjb3ZlcnkgbW9kZSkuXHJcblx0ICpcclxuXHQgKiAgU28sIHlvdSBjYW4gc2VlIHRoYXQgdGhlIHBhcnNlciB3YWxrcyB1cCB0aGUgY2FsbCBjaGFpbiBsb29raW5nXHJcblx0ICogIGZvciB0aGUgdG9rZW4gdGhhdCB3YXMgYSBtZW1iZXIgb2YgdGhlIHJlY292ZXJ5IHNldC5cclxuXHQgKlxyXG5cdCAqICBFcnJvcnMgYXJlIG5vdCBnZW5lcmF0ZWQgaW4gZXJyb3JSZWNvdmVyeSBtb2RlLlxyXG5cdCAqXHJcblx0ICogIEFOVExSJ3MgZXJyb3IgcmVjb3ZlcnkgbWVjaGFuaXNtIGlzIGJhc2VkIHVwb24gb3JpZ2luYWwgaWRlYXM6XHJcblx0ICpcclxuXHQgKiAgXCJBbGdvcml0aG1zICsgRGF0YSBTdHJ1Y3R1cmVzID0gUHJvZ3JhbXNcIiBieSBOaWtsYXVzIFdpcnRoXHJcblx0ICpcclxuXHQgKiAgYW5kXHJcblx0ICpcclxuXHQgKiAgXCJBIG5vdGUgb24gZXJyb3IgcmVjb3ZlcnkgaW4gcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2Vyc1wiOlxyXG5cdCAqICBodHRwOi8vcG9ydGFsLmFjbS5vcmcvY2l0YXRpb24uY2ZtP2lkPTk0NzkwMi45NDc5MDVcclxuXHQgKlxyXG5cdCAqICBMYXRlciwgSm9zZWYgR3Jvc2NoIGhhZCBzb21lIGdvb2QgaWRlYXM6XHJcblx0ICpcclxuXHQgKiAgXCJFZmZpY2llbnQgYW5kIENvbWZvcnRhYmxlIEVycm9yIFJlY292ZXJ5IGluIFJlY3Vyc2l2ZSBEZXNjZW50XHJcblx0ICogIFBhcnNlcnNcIjpcclxuXHQgKiAgZnRwOi8vd3d3LmNvY29sYWIuY29tL3Byb2R1Y3RzL2NvY2t0YWlsL2RvY2E0LnBzL2VsbC5wcy56aXBcclxuXHQgKlxyXG5cdCAqICBMaWtlIEdyb3NjaCBJIGltcGxlbWVudCBjb250ZXh0LXNlbnNpdGl2ZSBGT0xMT1cgc2V0cyB0aGF0IGFyZSBjb21iaW5lZFxyXG5cdCAqICBhdCBydW4tdGltZSB1cG9uIGVycm9yIHRvIGF2b2lkIG92ZXJoZWFkIGR1cmluZyBwYXJzaW5nLlxyXG5cdCAqL1xyXG5cdEBOb3ROdWxsXHJcblx0cHJvdGVjdGVkIGdldEVycm9yUmVjb3ZlcnlTZXQoQE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyKTogSW50ZXJ2YWxTZXQge1xyXG5cdFx0bGV0IGF0bjogQVROID0gcmVjb2duaXplci5pbnRlcnByZXRlci5hdG47XHJcblx0XHRsZXQgY3R4OiBSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCA9IHJlY29nbml6ZXIuY29udGV4dDtcclxuXHRcdGxldCByZWNvdmVyU2V0OiBJbnRlcnZhbFNldCA9IG5ldyBJbnRlcnZhbFNldCgpO1xyXG5cdFx0d2hpbGUgKGN0eCAmJiBjdHguaW52b2tpbmdTdGF0ZSA+PSAwKSB7XHJcblx0XHRcdC8vIGNvbXB1dGUgd2hhdCBmb2xsb3dzIHdobyBpbnZva2VkIHVzXHJcblx0XHRcdGxldCBpbnZva2luZ1N0YXRlOiBBVE5TdGF0ZSA9IGF0bi5zdGF0ZXNbY3R4Lmludm9raW5nU3RhdGVdO1xyXG5cdFx0XHRsZXQgcnQgPSBpbnZva2luZ1N0YXRlLnRyYW5zaXRpb24oMCkgYXMgUnVsZVRyYW5zaXRpb247XHJcblx0XHRcdGxldCBmb2xsb3c6IEludGVydmFsU2V0ID0gYXRuLm5leHRUb2tlbnMocnQuZm9sbG93U3RhdGUpO1xyXG5cdFx0XHRyZWNvdmVyU2V0LmFkZEFsbChmb2xsb3cpO1xyXG5cdFx0XHRjdHggPSBjdHguX3BhcmVudDtcclxuXHRcdH1cclxuXHRcdHJlY292ZXJTZXQucmVtb3ZlKFRva2VuLkVQU0lMT04pO1xyXG4vL1x0XHRTeXN0ZW0ub3V0LnByaW50bG4oXCJyZWNvdmVyIHNldCBcIityZWNvdmVyU2V0LnRvU3RyaW5nKHJlY29nbml6ZXIuZ2V0VG9rZW5OYW1lcygpKSk7XHJcblx0XHRyZXR1cm4gcmVjb3ZlclNldDtcclxuXHR9XHJcblxyXG5cdC8qKiBDb25zdW1lIHRva2VucyB1bnRpbCBvbmUgbWF0Y2hlcyB0aGUgZ2l2ZW4gdG9rZW4gc2V0LiAqL1xyXG5cdHByb3RlY3RlZCBjb25zdW1lVW50aWwoQE5vdE51bGwgcmVjb2duaXplcjogUGFyc2VyLCBATm90TnVsbCBzZXQ6IEludGVydmFsU2V0KTogdm9pZCB7XHJcbi8vXHRcdFN5c3RlbS5lcnIucHJpbnRsbihcImNvbnN1bWVVbnRpbChcIitzZXQudG9TdHJpbmcocmVjb2duaXplci5nZXRUb2tlbk5hbWVzKCkpK1wiKVwiKTtcclxuXHRcdGxldCB0dHlwZTogbnVtYmVyID0gcmVjb2duaXplci5pbnB1dFN0cmVhbS5MQSgxKTtcclxuXHRcdHdoaWxlICh0dHlwZSAhPT0gVG9rZW4uRU9GICYmICFzZXQuY29udGFpbnModHR5cGUpKSB7XHJcblx0XHRcdC8vU3lzdGVtLm91dC5wcmludGxuKFwiY29uc3VtZSBkdXJpbmcgcmVjb3ZlciBMQSgxKT1cIitnZXRUb2tlbk5hbWVzKClbaW5wdXQuTEEoMSldKTtcclxuLy9cdFx0XHRyZWNvZ25pemVyLmlucHV0U3RyZWFtLmNvbnN1bWUoKTtcclxuXHRcdFx0cmVjb2duaXplci5jb25zdW1lKCk7XHJcblx0XHRcdHR0eXBlID0gcmVjb2duaXplci5pbnB1dFN0cmVhbS5MQSgxKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjQ5LjI4NTUwNTYtMDc6MDBcclxuXHJcbmltcG9ydCB7IERlZmF1bHRFcnJvclN0cmF0ZWd5IH0gZnJvbSBcIi4vRGVmYXVsdEVycm9yU3RyYXRlZ3lcIjtcclxuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmltcG9ydCB7IElucHV0TWlzbWF0Y2hFeGNlcHRpb24gfSBmcm9tIFwiLi9JbnB1dE1pc21hdGNoRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL21pc2MvUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb25cIjtcclxuaW1wb3J0IHsgUGFyc2VyUnVsZUNvbnRleHQgfSBmcm9tIFwiLi9QYXJzZXJSdWxlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3l9IHJlc3BvbmRzIHRvIHN5bnRheCBlcnJvcnNcclxuICogYnkgaW1tZWRpYXRlbHkgY2FuY2VsaW5nIHRoZSBwYXJzZSBvcGVyYXRpb24gd2l0aCBhXHJcbiAqIHtAbGluayBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbn0uIFRoZSBpbXBsZW1lbnRhdGlvbiBlbnN1cmVzIHRoYXQgdGhlXHJcbiAqIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dCNleGNlcHRpb259IGZpZWxkIGlzIHNldCBmb3IgYWxsIHBhcnNlIHRyZWUgbm9kZXNcclxuICogdGhhdCB3ZXJlIG5vdCBjb21wbGV0ZWQgcHJpb3IgdG8gZW5jb3VudGVyaW5nIHRoZSBlcnJvci5cclxuICpcclxuICogVGhpcyBlcnJvciBzdHJhdGVneSBpcyB1c2VmdWwgaW4gdGhlIGZvbGxvd2luZyBzY2VuYXJpb3MuXHJcbiAqXHJcbiAqICogKipUd28tc3RhZ2UgcGFyc2luZzoqKiBUaGlzIGVycm9yIHN0cmF0ZWd5IGFsbG93cyB0aGUgZmlyc3RcclxuICogICBzdGFnZSBvZiB0d28tc3RhZ2UgcGFyc2luZyB0byBpbW1lZGlhdGVseSB0ZXJtaW5hdGUgaWYgYW4gZXJyb3IgaXNcclxuICogICBlbmNvdW50ZXJlZCwgYW5kIGltbWVkaWF0ZWx5IGZhbGwgYmFjayB0byB0aGUgc2Vjb25kIHN0YWdlLiBJbiBhZGRpdGlvbiB0b1xyXG4gKiAgIGF2b2lkaW5nIHdhc3RlZCB3b3JrIGJ5IGF0dGVtcHRpbmcgdG8gcmVjb3ZlciBmcm9tIGVycm9ycyBoZXJlLCB0aGUgZW1wdHlcclxuICogICBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQmFpbEVycm9yU3RyYXRlZ3kjc3luY30gaW1wcm92ZXMgdGhlIHBlcmZvcm1hbmNlIG9mXHJcbiAqICAgdGhlIGZpcnN0IHN0YWdlLlxyXG4gKiAqICoqU2lsZW50IHZhbGlkYXRpb246KiogV2hlbiBzeW50YXggZXJyb3JzIGFyZSBub3QgYmVpbmdcclxuICogICByZXBvcnRlZCBvciBsb2dnZWQsIGFuZCB0aGUgcGFyc2UgcmVzdWx0IGlzIHNpbXBseSBpZ25vcmVkIGlmIGVycm9ycyBvY2N1cixcclxuICogICB0aGUge0BsaW5rIEJhaWxFcnJvclN0cmF0ZWd5fSBhdm9pZHMgd2FzdGluZyB3b3JrIG9uIHJlY292ZXJpbmcgZnJvbSBlcnJvcnNcclxuICogICB3aGVuIHRoZSByZXN1bHQgd2lsbCBiZSBpZ25vcmVkIGVpdGhlciB3YXkuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBteXBhcnNlci5lcnJvckhhbmRsZXIgPSBuZXcgQmFpbEVycm9yU3RyYXRlZ3koKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBzZWUgUGFyc2VyLmVycm9ySGFuZGxlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJhaWxFcnJvclN0cmF0ZWd5IGV4dGVuZHMgRGVmYXVsdEVycm9yU3RyYXRlZ3kge1xyXG5cdC8qKiBJbnN0ZWFkIG9mIHJlY292ZXJpbmcgZnJvbSBleGNlcHRpb24gYGVgLCByZS10aHJvdyBpdCB3cmFwcGVkXHJcblx0ICogIGluIGEge0BsaW5rIFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9ufSBzbyBpdCBpcyBub3QgY2F1Z2h0IGJ5IHRoZVxyXG5cdCAqICBydWxlIGZ1bmN0aW9uIGNhdGNoZXMuICBVc2Uge0BsaW5rIEV4Y2VwdGlvbiNnZXRDYXVzZSgpfSB0byBnZXQgdGhlXHJcblx0ICogIG9yaWdpbmFsIHtAbGluayBSZWNvZ25pdGlvbkV4Y2VwdGlvbn0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlY292ZXIocmVjb2duaXplcjogUGFyc2VyLCBlOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbik6IHZvaWQge1xyXG5cdFx0Zm9yIChsZXQgY29udGV4dDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQgPSByZWNvZ25pemVyLmNvbnRleHQ7IGNvbnRleHQ7IGNvbnRleHQgPSBjb250ZXh0LnBhcmVudCkge1xyXG5cdFx0XHRjb250ZXh0LmV4Y2VwdGlvbiA9IGU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhyb3cgbmV3IFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uKGUpO1xyXG5cdH1cclxuXHJcblx0LyoqIE1ha2Ugc3VyZSB3ZSBkb24ndCBhdHRlbXB0IHRvIHJlY292ZXIgaW5saW5lOyBpZiB0aGUgcGFyc2VyXHJcblx0ICogIHN1Y2Nlc3NmdWxseSByZWNvdmVycywgaXQgd29uJ3QgdGhyb3cgYW4gZXhjZXB0aW9uLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZWNvdmVySW5saW5lKHJlY29nbml6ZXI6IFBhcnNlcik6IFRva2VuIHtcclxuXHRcdGxldCBlID0gbmV3IElucHV0TWlzbWF0Y2hFeGNlcHRpb24ocmVjb2duaXplcik7XHJcblx0XHRmb3IgKGxldCBjb250ZXh0OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCA9IHJlY29nbml6ZXIuY29udGV4dDsgY29udGV4dDsgY29udGV4dCA9IGNvbnRleHQucGFyZW50KSB7XHJcblx0XHRcdGNvbnRleHQuZXhjZXB0aW9uID0gZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aHJvdyBuZXcgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24oZSk7XHJcblx0fVxyXG5cclxuXHQvKiogTWFrZSBzdXJlIHdlIGRvbid0IGF0dGVtcHQgdG8gcmVjb3ZlciBmcm9tIHByb2JsZW1zIGluIHN1YnJ1bGVzLiAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBzeW5jKHJlY29nbml6ZXI6IFBhcnNlcik6IHZvaWQge1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH1cclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTAuMDY1OTI5Ny0wNzowMFxyXG5cclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IEludFN0cmVhbSB9IGZyb20gXCIuL0ludFN0cmVhbVwiO1xyXG5cclxuLyoqIEEgc291cmNlIG9mIGNoYXJhY3RlcnMgZm9yIGFuIEFOVExSIGxleGVyLiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIENoYXJTdHJlYW0gZXh0ZW5kcyBJbnRTdHJlYW0ge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHRleHQgZm9yIGEgcmFuZ2Ugb2YgY2hhcmFjdGVycyB3aXRoaW4gdGhpcyBpbnB1dFxyXG5cdCAqIHN0cmVhbS4gVGhpcyBtZXRob2QgaXMgZ3VhcmFudGVlZCB0byBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZVxyXG5cdCAqIHNwZWNpZmllZCBgaW50ZXJ2YWxgIGxpZXMgZW50aXJlbHkgd2l0aGluIGEgbWFya2VkIHJhbmdlLiBGb3IgbW9yZVxyXG5cdCAqIGluZm9ybWF0aW9uIGFib3V0IG1hcmtlZCByYW5nZXMsIHNlZSB7QGxpbmsgSW50U3RyZWFtI21hcmt9LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGludGVydmFsIGFuIGludGVydmFsIHdpdGhpbiB0aGUgc3RyZWFtXHJcblx0ICogQHJldHVybnMgdGhlIHRleHQgb2YgdGhlIHNwZWNpZmllZCBpbnRlcnZhbFxyXG5cdCAqXHJcblx0ICogQHRocm93cyBOdWxsUG9pbnRlckV4Y2VwdGlvbiBpZiBgaW50ZXJ2YWxgIGlzIGB1bmRlZmluZWRgXHJcblx0ICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYGludGVydmFsLmEgPCAwYCwgb3IgaWZcclxuXHQgKiBgaW50ZXJ2YWwuYiA8IGludGVydmFsLmEgLSAxYCwgb3IgaWYgYGludGVydmFsLmJgIGxpZXMgYXQgb3JcclxuXHQgKiBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmVhbVxyXG5cdCAqIEB0aHJvd3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gaWYgdGhlIHN0cmVhbSBkb2VzIG5vdCBzdXBwb3J0XHJcblx0ICogZ2V0dGluZyB0aGUgdGV4dCBvZiB0aGUgc3BlY2lmaWVkIGludGVydmFsXHJcblx0ICovXHJcblx0Ly9ATm90TnVsbFxyXG5cdGdldFRleHQoLypATm90TnVsbCovIGludGVydmFsOiBJbnRlcnZhbCk6IHN0cmluZztcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTEuMTM0OTgyOS0wNzowMFxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBlbnVtIERlcGVuZGVudHMge1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgZWxlbWVudCBpcyBkZXBlbmRlbnQgdXBvbiB0aGUgc3BlY2lmaWVkIHJ1bGUuXHJcblx0ICovXHJcblx0U0VMRixcclxuXHQvKipcclxuXHQgKiBUaGUgZWxlbWVudCBpcyBkZXBlbmRlbnQgdXBvbiB0aGUgc2V0IG9mIHRoZSBzcGVjaWZpZWQgcnVsZSdzIHBhcmVudHNcclxuXHQgKiAocnVsZXMgd2hpY2ggZGlyZWN0bHkgcmVmZXJlbmNlIGl0KS5cclxuXHQgKi9cclxuXHRQQVJFTlRTLFxyXG5cdC8qKlxyXG5cdCAqIFRoZSBlbGVtZW50IGlzIGRlcGVuZGVudCB1cG9uIHRoZSBzZXQgb2YgdGhlIHNwZWNpZmllZCBydWxlJ3MgY2hpbGRyZW5cclxuXHQgKiAocnVsZXMgd2hpY2ggaXQgZGlyZWN0bHkgcmVmZXJlbmNlcykuXHJcblx0ICovXHJcblx0Q0hJTERSRU4sXHJcblx0LyoqXHJcblx0ICogVGhlIGVsZW1lbnQgaXMgZGVwZW5kZW50IHVwb24gdGhlIHNldCBvZiB0aGUgc3BlY2lmaWVkIHJ1bGUncyBhbmNlc3RvcnNcclxuXHQgKiAodGhlIHRyYW5zaXRpdmUgY2xvc3VyZSBvZiBgUEFSRU5UU2AgcnVsZXMpLlxyXG5cdCAqL1xyXG5cdEFOQ0VTVE9SUyxcclxuXHQvKipcclxuXHQgKiBUaGUgZWxlbWVudCBpcyBkZXBlbmRlbnQgdXBvbiB0aGUgc2V0IG9mIHRoZSBzcGVjaWZpZWQgcnVsZSdzIGRlc2NlbmRhbnRzXHJcblx0ICogKHRoZSB0cmFuc2l0aXZlIGNsb3N1cmUgb2YgYENISUxEUkVOYCBydWxlcykuXHJcblx0ICovXHJcblx0REVTQ0VOREFOVFMsXHJcblx0LyoqXHJcblx0ICogVGhlIGVsZW1lbnQgaXMgZGVwZW5kZW50IHVwb24gdGhlIHNldCBvZiB0aGUgc3BlY2lmaWVkIHJ1bGUncyBzaWJsaW5nc1xyXG5cdCAqICh0aGUgdW5pb24gb2YgYENISUxEUkVOYCBvZiBpdHMgYFBBUkVOVFNgKS5cclxuXHQgKi9cclxuXHRTSUJMSU5HUyxcclxuXHQvKipcclxuXHQgKiBUaGUgZWxlbWVudCBpcyBkZXBlbmRlbnQgdXBvbiB0aGUgc2V0IG9mIHRoZSBzcGVjaWZpZWQgcnVsZSdzIHByZWNlZWRpbmdcclxuXHQgKiBzaWJsaW5ncyAodGhlIHVuaW9uIG9mIGBDSElMRFJFTmAgb2YgaXRzIGBQQVJFTlRTYCB3aGljaFxyXG5cdCAqIGFwcGVhciBiZWZvcmUgYSByZWZlcmVuY2UgdG8gdGhlIHJ1bGUpLlxyXG5cdCAqL1xyXG5cdFBSRUNFRURJTkdfU0lCTElOR1MsXHJcblx0LyoqXHJcblx0ICogVGhlIGVsZW1lbnQgaXMgZGVwZW5kZW50IHVwb24gdGhlIHNldCBvZiB0aGUgc3BlY2lmaWVkIHJ1bGUncyBmb2xsb3dpbmdcclxuXHQgKiBzaWJsaW5ncyAodGhlIHVuaW9uIG9mIGBDSElMRFJFTmAgb2YgaXRzIGBQQVJFTlRTYCB3aGljaFxyXG5cdCAqIGFwcGVhciBhZnRlciBhIHJlZmVyZW5jZSB0byB0aGUgcnVsZSkuXHJcblx0ICovXHJcblx0Rk9MTE9XSU5HX1NJQkxJTkdTLFxyXG5cdC8qKlxyXG5cdCAqIFRoZSBlbGVtZW50IGlzIGRlcGVuZGVudCB1cG9uIHRoZSBzZXQgb2YgdGhlIHNwZWNpZmllZCBydWxlJ3MgcHJlY2VlZGluZ1xyXG5cdCAqIGVsZW1lbnRzIChydWxlcyB3aGljaCBtaWdodCBlbmQgYmVmb3JlIHRoZSBzdGFydCBvZiB0aGUgc3BlY2lmaWVkIHJ1bGVcclxuXHQgKiB3aGlsZSBwYXJzaW5nKS4gVGhpcyBpcyBjYWxjdWxhdGVkIGJ5IHRha2luZyB0aGVcclxuXHQgKiBgUFJFQ0VFRElOR19TSUJMSU5HU2Agb2YgdGhlIHJ1bGUgYW5kIGVhY2ggb2YgaXRzXHJcblx0ICogYEFOQ0VTVE9SU2AsIGFsb25nIHdpdGggdGhlIGBERVNDRU5EQU5UU2Agb2YgdGhvc2VcclxuXHQgKiBlbGVtZW50cy5cclxuXHQgKi9cclxuXHRQUkVDRUVESU5HLFxyXG5cdC8qKlxyXG5cdCAqIFRoZSBlbGVtZW50IGlzIGRlcGVuZGVudCB1cG9uIHRoZSBzZXQgb2YgdGhlIHNwZWNpZmllZCBydWxlJ3MgZm9sbG93aW5nXHJcblx0ICogZWxlbWVudHMgKHJ1bGVzIHdoaWNoIG1pZ2h0IHN0YXJ0IGFmdGVyIHRoZSBlbmQgb2YgdGhlIHNwZWNpZmllZCBydWxlXHJcblx0ICogd2hpbGUgcGFyc2luZykuIFRoaXMgaXMgY2FsY3VsYXRlZCBieSB0YWtpbmcgdGhlXHJcblx0ICogYEZPTExPV0lOR19TSUJMSU5HU2Agb2YgdGhlIHJ1bGUgYW5kIGVhY2ggb2YgaXRzXHJcblx0ICogYEFOQ0VTVE9SU2AsIGFsb25nIHdpdGggdGhlIGBERVNDRU5EQU5UU2Agb2YgdGhvc2VcclxuXHQgKiBlbGVtZW50cy5cclxuXHQgKi9cclxuXHRGT0xMT1dJTkcsXHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUxLjIxMzM2ODUtMDc6MDBcclxuXHJcbmltcG9ydCB7IEFUTkNvbmZpZyB9IGZyb20gXCIuL2F0bi9BVE5Db25maWdcIjtcclxuaW1wb3J0IHsgQVROQ29uZmlnU2V0IH0gZnJvbSBcIi4vYXRuL0FUTkNvbmZpZ1NldFwiO1xyXG5pbXBvcnQgeyBCaXRTZXQgfSBmcm9tIFwiLi9taXNjL0JpdFNldFwiO1xyXG5pbXBvcnQgeyBERkEgfSBmcm9tIFwiLi9kZmEvREZBXCI7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJFcnJvckxpc3RlbmVyIH0gZnJvbSBcIi4vUGFyc2VyRXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XHJcbmltcG9ydCB7IFJlY29nbml6ZXIgfSBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcbmltcG9ydCB7IFNpbXVsYXRvclN0YXRlIH0gZnJvbSBcIi4vYXRuL1NpbXVsYXRvclN0YXRlXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgT3ZlcnJpZGUsIE5vdE51bGwgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIEFOVExSRXJyb3JMaXN0ZW5lcn0gY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnlcclxuICogY2VydGFpbiBwb3RlbnRpYWwgY29ycmVjdG5lc3MgYW5kIHBlcmZvcm1hbmNlIHByb2JsZW1zIGluIGdyYW1tYXJzLiBcIlJlcG9ydHNcIlxyXG4gKiBhcmUgbWFkZSBieSBjYWxsaW5nIHtAbGluayBQYXJzZXIjbm90aWZ5RXJyb3JMaXN0ZW5lcnN9IHdpdGggdGhlIGFwcHJvcHJpYXRlXHJcbiAqIG1lc3NhZ2UuXHJcbiAqXHJcbiAqICogKipBbWJpZ3VpdGllcyoqOiBUaGVzZSBhcmUgY2FzZXMgd2hlcmUgbW9yZSB0aGFuIG9uZSBwYXRoIHRocm91Z2ggdGhlXHJcbiAqICAgZ3JhbW1hciBjYW4gbWF0Y2ggdGhlIGlucHV0LlxyXG4gKiAqICoqV2VhayBjb250ZXh0IHNlbnNpdGl2aXR5Kio6IFRoZXNlIGFyZSBjYXNlcyB3aGVyZSBmdWxsLWNvbnRleHRcclxuICogICBwcmVkaWN0aW9uIHJlc29sdmVkIGFuIFNMTCBjb25mbGljdCB0byBhIHVuaXF1ZSBhbHRlcm5hdGl2ZSB3aGljaCBlcXVhbGVkIHRoZVxyXG4gKiAgIG1pbmltdW0gYWx0ZXJuYXRpdmUgb2YgdGhlIFNMTCBjb25mbGljdC5cclxuICogKiAqKlN0cm9uZyAoZm9yY2VkKSBjb250ZXh0IHNlbnNpdGl2aXR5Kio6IFRoZXNlIGFyZSBjYXNlcyB3aGVyZSB0aGVcclxuICogICBmdWxsLWNvbnRleHQgcHJlZGljdGlvbiByZXNvbHZlZCBhbiBTTEwgY29uZmxpY3QgdG8gYSB1bmlxdWUgYWx0ZXJuYXRpdmUsXHJcbiAqICAgKmFuZCogdGhlIG1pbmltdW0gYWx0ZXJuYXRpdmUgb2YgdGhlIFNMTCBjb25mbGljdCB3YXMgZm91bmQgdG8gbm90IGJlXHJcbiAqICAgYSB0cnVseSB2aWFibGUgYWx0ZXJuYXRpdmUuIFR3by1zdGFnZSBwYXJzaW5nIGNhbm5vdCBiZSB1c2VkIGZvciBpbnB1dHMgd2hlcmVcclxuICogICB0aGlzIHNpdHVhdGlvbiBvY2N1cnMuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBEaWFnbm9zdGljRXJyb3JMaXN0ZW5lciBpbXBsZW1lbnRzIFBhcnNlckVycm9yTGlzdGVuZXIge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXJ9LCBzcGVjaWZ5aW5nXHJcblx0ICogd2hldGhlciBhbGwgYW1iaWd1aXRpZXMgb3Igb25seSBleGFjdCBhbWJpZ3VpdGllcyBhcmUgcmVwb3J0ZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gZXhhY3RPbmx5IGB0cnVlYCB0byByZXBvcnQgb25seSBleGFjdCBhbWJpZ3VpdGllcywgb3RoZXJ3aXNlXHJcblx0ICogYGZhbHNlYCB0byByZXBvcnQgYWxsIGFtYmlndWl0aWVzLiAgRGVmYXVsdHMgdG8gdHJ1ZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZXhhY3RPbmx5OiBib29sZWFuID0gdHJ1ZSkge1xyXG5cdFx0dGhpcy5leGFjdE9ubHkgPSBleGFjdE9ubHk7XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgc3ludGF4RXJyb3I8VCBleHRlbmRzIFRva2VuPihcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0cmVjb2duaXplcjogUmVjb2duaXplcjxULCBhbnk+LFxyXG5cdFx0b2ZmZW5kaW5nU3ltYm9sOiBUIHwgdW5kZWZpbmVkLFxyXG5cdFx0bGluZTogbnVtYmVyLFxyXG5cdFx0Y2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXIsXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdG1zZzogc3RyaW5nLFxyXG5cdFx0ZTogUmVjb2duaXRpb25FeGNlcHRpb24gfCB1bmRlZmluZWQpOiB2b2lkXHJcblx0e1xyXG5cdFx0Ly8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHJlcG9ydEFtYmlndWl0eShcclxuXHRcdEBOb3ROdWxsIHJlY29nbml6ZXI6IFBhcnNlcixcclxuXHRcdEBOb3ROdWxsIGRmYTogREZBLFxyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyLFxyXG5cdFx0c3RvcEluZGV4OiBudW1iZXIsXHJcblx0XHRleGFjdDogYm9vbGVhbixcclxuXHRcdGFtYmlnQWx0czogQml0U2V0IHwgdW5kZWZpbmVkLFxyXG5cdFx0QE5vdE51bGwgY29uZmlnczogQVROQ29uZmlnU2V0KTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5leGFjdE9ubHkgJiYgIWV4YWN0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZGVjaXNpb246IHN0cmluZyA9IHRoaXMuZ2V0RGVjaXNpb25EZXNjcmlwdGlvbihyZWNvZ25pemVyLCBkZmEpO1xyXG5cdFx0bGV0IGNvbmZsaWN0aW5nQWx0czogQml0U2V0ID0gdGhpcy5nZXRDb25mbGljdGluZ0FsdHMoYW1iaWdBbHRzLCBjb25maWdzKTtcclxuXHRcdGxldCB0ZXh0OiBzdHJpbmcgPSByZWNvZ25pemVyLmlucHV0U3RyZWFtLmdldFRleHQoSW50ZXJ2YWwub2Yoc3RhcnRJbmRleCwgc3RvcEluZGV4KSk7XHJcblx0XHRsZXQgbWVzc2FnZTogc3RyaW5nID0gYHJlcG9ydEFtYmlndWl0eSBkPSR7ZGVjaXNpb259OiBhbWJpZ0FsdHM9JHtjb25mbGljdGluZ0FsdHN9LCBpbnB1dD0nJHt0ZXh0fSdgO1xyXG5cdFx0cmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtZXNzYWdlKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQoXHJcblx0XHRATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIsXHJcblx0XHRATm90TnVsbCBkZmE6IERGQSxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyLFxyXG5cdFx0Y29uZmxpY3RpbmdBbHRzOiBCaXRTZXQgfCB1bmRlZmluZWQsXHJcblx0XHRATm90TnVsbCBjb25mbGljdFN0YXRlOiBTaW11bGF0b3JTdGF0ZSk6IHZvaWQge1xyXG5cdFx0bGV0IGZvcm1hdDogc3RyaW5nID0gXCJyZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQgZD0lcywgaW5wdXQ9JyVzJ1wiO1xyXG5cdFx0bGV0IGRlY2lzaW9uOiBzdHJpbmcgPSB0aGlzLmdldERlY2lzaW9uRGVzY3JpcHRpb24ocmVjb2duaXplciwgZGZhKTtcclxuXHRcdGxldCB0ZXh0OiBzdHJpbmcgPSByZWNvZ25pemVyLmlucHV0U3RyZWFtLmdldFRleHQoSW50ZXJ2YWwub2Yoc3RhcnRJbmRleCwgc3RvcEluZGV4KSk7XHJcblx0XHRsZXQgbWVzc2FnZTogc3RyaW5nID0gYHJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCBkPSR7ZGVjaXNpb259LCBpbnB1dD0nJHt0ZXh0fSdgO1xyXG5cdFx0cmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtZXNzYWdlKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyByZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkoXHJcblx0XHRATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIsXHJcblx0XHRATm90TnVsbCBkZmE6IERGQSxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyLFxyXG5cdFx0cHJlZGljdGlvbjogbnVtYmVyLFxyXG5cdFx0QE5vdE51bGwgYWNjZXB0U3RhdGU6IFNpbXVsYXRvclN0YXRlKTogdm9pZCB7XHJcblx0XHRsZXQgZm9ybWF0OiBzdHJpbmcgPSBcInJlcG9ydENvbnRleHRTZW5zaXRpdml0eSBkPSVzLCBpbnB1dD0nJXMnXCI7XHJcblx0XHRsZXQgZGVjaXNpb246IHN0cmluZyA9IHRoaXMuZ2V0RGVjaXNpb25EZXNjcmlwdGlvbihyZWNvZ25pemVyLCBkZmEpO1xyXG5cdFx0bGV0IHRleHQ6IHN0cmluZyA9IHJlY29nbml6ZXIuaW5wdXRTdHJlYW0uZ2V0VGV4dChJbnRlcnZhbC5vZihzdGFydEluZGV4LCBzdG9wSW5kZXgpKTtcclxuXHRcdGxldCBtZXNzYWdlOiBzdHJpbmcgPSBgcmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5IGQ9JHtkZWNpc2lvbn0sIGlucHV0PScke3RleHR9J2A7XHJcblx0XHRyZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1lc3NhZ2UpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldERlY2lzaW9uRGVzY3JpcHRpb24oXHJcblx0XHRATm90TnVsbCByZWNvZ25pemVyOiBQYXJzZXIsXHJcblx0XHRATm90TnVsbCBkZmE6IERGQSk6IHN0cmluZyB7XHJcblx0XHRsZXQgZGVjaXNpb246IG51bWJlciA9IGRmYS5kZWNpc2lvbjtcclxuXHRcdGxldCBydWxlSW5kZXg6IG51bWJlciA9IGRmYS5hdG5TdGFydFN0YXRlLnJ1bGVJbmRleDtcclxuXHJcblx0XHRsZXQgcnVsZU5hbWVzOiBzdHJpbmdbXSA9IHJlY29nbml6ZXIucnVsZU5hbWVzO1xyXG5cdFx0aWYgKHJ1bGVJbmRleCA8IDAgfHwgcnVsZUluZGV4ID49IHJ1bGVOYW1lcy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGRlY2lzaW9uLnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJ1bGVOYW1lOiBzdHJpbmcgPSBydWxlTmFtZXNbcnVsZUluZGV4XTtcclxuXHRcdGlmICghcnVsZU5hbWUpIHtcclxuXHRcdFx0cmV0dXJuIGRlY2lzaW9uLnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGAke2RlY2lzaW9ufSAoJHtydWxlTmFtZX0pYDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGVzIHRoZSBzZXQgb2YgY29uZmxpY3Rpbmcgb3IgYW1iaWd1b3VzIGFsdGVybmF0aXZlcyBmcm9tIGFcclxuXHQgKiBjb25maWd1cmF0aW9uIHNldCwgaWYgdGhhdCBpbmZvcm1hdGlvbiB3YXMgbm90IGFscmVhZHkgcHJvdmlkZWQgYnkgdGhlXHJcblx0ICogcGFyc2VyLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlcG9ydGVkQWx0cyBUaGUgc2V0IG9mIGNvbmZsaWN0aW5nIG9yIGFtYmlndW91cyBhbHRlcm5hdGl2ZXMsIGFzXHJcblx0ICogcmVwb3J0ZWQgYnkgdGhlIHBhcnNlci5cclxuXHQgKiBAcGFyYW0gY29uZmlncyBUaGUgY29uZmxpY3Rpbmcgb3IgYW1iaWd1b3VzIGNvbmZpZ3VyYXRpb24gc2V0LlxyXG5cdCAqIEByZXR1cm5zIFJldHVybnMgYHJlcG9ydGVkQWx0c2AgaWYgaXQgaXMgbm90IGB1bmRlZmluZWRgLCBvdGhlcndpc2VcclxuXHQgKiByZXR1cm5zIHRoZSBzZXQgb2YgYWx0ZXJuYXRpdmVzIHJlcHJlc2VudGVkIGluIGBjb25maWdzYC5cclxuXHQgKi9cclxuXHRATm90TnVsbFxyXG5cdHByb3RlY3RlZCBnZXRDb25mbGljdGluZ0FsdHMocmVwb3J0ZWRBbHRzOiBCaXRTZXQgfCB1bmRlZmluZWQsIEBOb3ROdWxsIGNvbmZpZ3M6IEFUTkNvbmZpZ1NldCk6IEJpdFNldCB7XHJcblx0XHRpZiAocmVwb3J0ZWRBbHRzICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHJlcG9ydGVkQWx0cztcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVzdWx0OiBCaXRTZXQgPSBuZXcgQml0U2V0KCk7XHJcblx0XHRmb3IgKGxldCBjb25maWcgb2YgY29uZmlncykge1xyXG5cdFx0XHRyZXN1bHQuc2V0KGNvbmZpZy5hbHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1MS45OTU0NTY2LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9hdG4vQVROXCI7XHJcbmltcG9ydCB7IEFUTlR5cGUgfSBmcm9tIFwiLi9hdG4vQVROVHlwZVwiO1xyXG5pbXBvcnQgeyBDaGFyU3RyZWFtIH0gZnJvbSBcIi4vQ2hhclN0cmVhbVwiO1xyXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuL0xleGVyXCI7XHJcbmltcG9ydCB7IExleGVyQVROU2ltdWxhdG9yIH0gZnJvbSBcIi4vYXRuL0xleGVyQVROU2ltdWxhdG9yXCI7XHJcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiLi9EZWNvcmF0b3JzXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBWb2NhYnVsYXJ5IH0gZnJvbSBcIi4vVm9jYWJ1bGFyeVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIExleGVySW50ZXJwcmV0ZXIgZXh0ZW5kcyBMZXhlciB7XHJcblx0cHJvdGVjdGVkIF9ncmFtbWFyRmlsZU5hbWU6IHN0cmluZztcclxuXHRwcm90ZWN0ZWQgX2F0bjogQVROO1xyXG5cclxuXHRwcm90ZWN0ZWQgX3J1bGVOYW1lczogc3RyaW5nW107XHJcblx0cHJvdGVjdGVkIF9jaGFubmVsTmFtZXM6IHN0cmluZ1tdO1xyXG5cdHByb3RlY3RlZCBfbW9kZU5hbWVzOiBzdHJpbmdbXTtcclxuXHRATm90TnVsbFxyXG5cdHByaXZhdGUgX3ZvY2FidWxhcnk6IFZvY2FidWxhcnk7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGdyYW1tYXJGaWxlTmFtZTogc3RyaW5nLCBATm90TnVsbCB2b2NhYnVsYXJ5OiBWb2NhYnVsYXJ5LCBydWxlTmFtZXM6IHN0cmluZ1tdLCBjaGFubmVsTmFtZXM6IHN0cmluZ1tdLCBtb2RlTmFtZXM6IHN0cmluZ1tdLCBhdG46IEFUTiwgaW5wdXQ6IENoYXJTdHJlYW0pIHtcclxuXHRcdHN1cGVyKGlucHV0KTtcclxuXHJcblx0XHRpZiAoYXRuLmdyYW1tYXJUeXBlICE9PSBBVE5UeXBlLkxFWEVSKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIklsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbjogVGhlIEFUTiBtdXN0IGJlIGEgbGV4ZXIgQVROLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9ncmFtbWFyRmlsZU5hbWUgPSBncmFtbWFyRmlsZU5hbWU7XHJcblx0XHR0aGlzLl9hdG4gPSBhdG47XHJcblxyXG5cdFx0dGhpcy5fcnVsZU5hbWVzID0gcnVsZU5hbWVzLnNsaWNlKDApO1xyXG5cdFx0dGhpcy5fY2hhbm5lbE5hbWVzID0gY2hhbm5lbE5hbWVzLnNsaWNlKDApO1xyXG5cdFx0dGhpcy5fbW9kZU5hbWVzID0gbW9kZU5hbWVzLnNsaWNlKDApO1xyXG5cdFx0dGhpcy5fdm9jYWJ1bGFyeSA9IHZvY2FidWxhcnk7XHJcblx0XHR0aGlzLl9pbnRlcnAgPSBuZXcgTGV4ZXJBVE5TaW11bGF0b3IoYXRuLCB0aGlzKTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdGdldCBhdG4oKTogQVROIHtcclxuXHRcdHJldHVybiB0aGlzLl9hdG47XHJcblx0fVxyXG5cclxuXHRAT3ZlcnJpZGVcclxuXHRnZXQgZ3JhbW1hckZpbGVOYW1lKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ3JhbW1hckZpbGVOYW1lO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHJ1bGVOYW1lcygpOiBzdHJpbmdbXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcnVsZU5hbWVzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGNoYW5uZWxOYW1lcygpOiBzdHJpbmdbXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hhbm5lbE5hbWVzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IG1vZGVOYW1lcygpOiBzdHJpbmdbXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbW9kZU5hbWVzO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IHZvY2FidWxhcnkoKTogVm9jYWJ1bGFyeSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdm9jYWJ1bGFyeTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjUyLjk0NzE4NjMtMDc6MDBcclxuaW1wb3J0IHsgQU5UTFJFcnJvckxpc3RlbmVyIH0gZnJvbSBcIi4vQU5UTFJFcnJvckxpc3RlbmVyXCI7XHJcbmltcG9ydCB7IEFUTkNvbmZpZ1NldCB9IGZyb20gXCIuL2F0bi9BVE5Db25maWdTZXRcIjtcclxuaW1wb3J0IHsgQml0U2V0IH0gZnJvbSBcIi4vbWlzYy9CaXRTZXRcIjtcclxuaW1wb3J0IHsgREZBIH0gZnJvbSBcIi4vZGZhL0RGQVwiO1xyXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi9QYXJzZXJcIjtcclxuaW1wb3J0IHsgU2ltdWxhdG9yU3RhdGUgfSBmcm9tIFwiLi9hdG4vU2ltdWxhdG9yU3RhdGVcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblwiO1xyXG5pbXBvcnQgKiBhcyBTdHVicyBmcm9tIFwiLi9taXNjL1N0dWJzXCI7XHJcbmltcG9ydCAqIGFzIEV4Y2VwdGlvbiBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5cclxuLyoqIEhvdyB0byBlbWl0IHJlY29nbml0aW9uIGVycm9ycyBmb3IgcGFyc2Vycy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VyRXJyb3JMaXN0ZW5lciBleHRlbmRzIEFOVExSRXJyb3JMaXN0ZW5lcjxUb2tlbj4ge1xyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgcGFyc2VyIHdoZW4gYSBmdWxsLWNvbnRleHQgcHJlZGljdGlvblxyXG5cdCAqIHJlc3VsdHMgaW4gYW4gYW1iaWd1aXR5LlxyXG5cdCAqXHJcblx0ICogRWFjaCBmdWxsLWNvbnRleHQgcHJlZGljdGlvbiB3aGljaCBkb2VzIG5vdCByZXN1bHQgaW4gYSBzeW50YXggZXJyb3JcclxuXHQgKiB3aWxsIGNhbGwgZWl0aGVyIHtAbGluayAjcmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5fSBvclxyXG5cdCAqIHtAbGluayAjcmVwb3J0QW1iaWd1aXR5fS5cclxuXHQgKlxyXG5cdCAqIFdoZW4gYGFtYmlnQWx0c2AgaXMgbm90IGB1bmRlZmluZWRgLCBpdCBjb250YWlucyB0aGUgc2V0IG9mIHBvdGVudGlhbGx5XHJcblx0ICogdmlhYmxlIGFsdGVybmF0aXZlcyBpZGVudGlmaWVkIGJ5IHRoZSBwcmVkaWN0aW9uIGFsZ29yaXRobS4gV2hlblxyXG5cdCAqIGBhbWJpZ0FsdHNgIGlzIGB1bmRlZmluZWRgLCB1c2VcclxuXHQgKiB7QGxpbmsgQVROQ29uZmlnU2V0I2dldFJlcHJlc2VudGVkQWx0ZXJuYXRpdmVzfSB0byBvYnRhaW4gdGhlIHJlcHJlc2VudGVkXHJcblx0ICogYWx0ZXJuYXRpdmVzIGZyb20gdGhlIGBjb25maWdzYCBhcmd1bWVudC5cclxuXHQgKlxyXG5cdCAqIFdoZW4gYGV4YWN0YCBpcyBgdHJ1ZWAsICphbGwqIG9mIHRoZSBwb3RlbnRpYWxseVxyXG5cdCAqIHZpYWJsZSBhbHRlcm5hdGl2ZXMgYXJlIHRydWx5IHZpYWJsZSwgaS5lLiB0aGlzIGlzIHJlcG9ydGluZyBhbiBleGFjdFxyXG5cdCAqIGFtYmlndWl0eS4gV2hlbiBgZXhhY3RgIGlzIGBmYWxzZWAsICphdCBsZWFzdCB0d28qIG9mXHJcblx0ICogdGhlIHBvdGVudGlhbGx5IHZpYWJsZSBhbHRlcm5hdGl2ZXMgYXJlIHZpYWJsZSBmb3IgdGhlIGN1cnJlbnQgaW5wdXQsIGJ1dFxyXG5cdCAqIHRoZSBwcmVkaWN0aW9uIGFsZ29yaXRobSB0ZXJtaW5hdGVkIGFzIHNvb24gYXMgaXQgZGV0ZXJtaW5lZCB0aGF0IGF0XHJcblx0ICogbGVhc3QgdGhlICptaW5pbXVtKiBwb3RlbnRpYWxseSB2aWFibGUgYWx0ZXJuYXRpdmUgaXMgdHJ1bHlcclxuXHQgKiB2aWFibGUuXHJcblx0ICpcclxuXHQgKiBXaGVuIHRoZSB7QGxpbmsgUHJlZGljdGlvbk1vZGUjTExfRVhBQ1RfQU1CSUdfREVURUNUSU9OfSBwcmVkaWN0aW9uXHJcblx0ICogbW9kZSBpcyB1c2VkLCB0aGUgcGFyc2VyIGlzIHJlcXVpcmVkIHRvIGlkZW50aWZ5IGV4YWN0IGFtYmlndWl0aWVzIHNvXHJcblx0ICogYGV4YWN0YCB3aWxsIGFsd2F5cyBiZSBgdHJ1ZWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXHJcblx0ICogQHBhcmFtIGRmYSB0aGUgREZBIGZvciB0aGUgY3VycmVudCBkZWNpc2lvblxyXG5cdCAqIEBwYXJhbSBzdGFydEluZGV4IHRoZSBpbnB1dCBpbmRleCB3aGVyZSB0aGUgZGVjaXNpb24gc3RhcnRlZFxyXG5cdCAqIEBwYXJhbSBzdG9wSW5kZXggdGhlIGlucHV0IGlucHV0IHdoZXJlIHRoZSBhbWJpZ3VpdHkgd2FzIGlkZW50aWZpZWRcclxuXHQgKiBAcGFyYW0gZXhhY3QgYHRydWVgIGlmIHRoZSBhbWJpZ3VpdHkgaXMgZXhhY3RseSBrbm93biwgb3RoZXJ3aXNlXHJcblx0ICogYGZhbHNlYC4gVGhpcyBpcyBhbHdheXMgYHRydWVgIHdoZW5cclxuXHQgKiB7QGxpbmsgUHJlZGljdGlvbk1vZGUjTExfRVhBQ1RfQU1CSUdfREVURUNUSU9OfSBpcyB1c2VkLlxyXG5cdCAqIEBwYXJhbSBhbWJpZ0FsdHMgdGhlIHBvdGVudGlhbGx5IGFtYmlndW91cyBhbHRlcm5hdGl2ZXMsIG9yIGB1bmRlZmluZWRgXHJcblx0ICogdG8gaW5kaWNhdGUgdGhhdCB0aGUgcG90ZW50aWFsbHkgYW1iaWd1b3VzIGFsdGVybmF0aXZlcyBhcmUgdGhlIGNvbXBsZXRlXHJcblx0ICogc2V0IG9mIHJlcHJlc2VudGVkIGFsdGVybmF0aXZlcyBpbiBgY29uZmlnc2BcclxuXHQgKiBAcGFyYW0gY29uZmlncyB0aGUgQVROIGNvbmZpZ3VyYXRpb24gc2V0IHdoZXJlIHRoZSBhbWJpZ3VpdHkgd2FzXHJcblx0ICogaWRlbnRpZmllZFxyXG5cdCAqL1xyXG5cdHJlcG9ydEFtYmlndWl0eT86IChcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0cmVjb2duaXplcjogUGFyc2VyLFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRkZmE6IERGQSxcclxuXHRcdHN0YXJ0SW5kZXg6IG51bWJlcixcclxuXHRcdHN0b3BJbmRleDogbnVtYmVyLFxyXG5cdFx0ZXhhY3Q6IGJvb2xlYW4sXHJcblx0XHRhbWJpZ0FsdHM6IEJpdFNldCB8IHVuZGVmaW5lZCxcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0Y29uZmlnczogQVROQ29uZmlnU2V0KSA9PiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiBhbiBTTEwgY29uZmxpY3Qgb2NjdXJzIGFuZCB0aGUgcGFyc2VyIGlzIGFib3V0XHJcblx0ICogdG8gdXNlIHRoZSBmdWxsIGNvbnRleHQgaW5mb3JtYXRpb24gdG8gbWFrZSBhbiBMTCBkZWNpc2lvbi5cclxuXHQgKlxyXG5cdCAqIElmIG9uZSBvciBtb3JlIGNvbmZpZ3VyYXRpb25zIGluIGBjb25maWdzYCBjb250YWlucyBhIHNlbWFudGljXHJcblx0ICogcHJlZGljYXRlLCB0aGUgcHJlZGljYXRlcyBhcmUgZXZhbHVhdGVkIGJlZm9yZSB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuIFRoZVxyXG5cdCAqIHN1YnNldCBvZiBhbHRlcm5hdGl2ZXMgd2hpY2ggYXJlIHN0aWxsIHZpYWJsZSBhZnRlciBwcmVkaWNhdGVzIGFyZVxyXG5cdCAqIGV2YWx1YXRlZCBpcyByZXBvcnRlZCBpbiBgY29uZmxpY3RpbmdBbHRzYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKiBAcGFyYW0gZGZhIHRoZSBERkEgZm9yIHRoZSBjdXJyZW50IGRlY2lzaW9uXHJcblx0ICogQHBhcmFtIHN0YXJ0SW5kZXggdGhlIGlucHV0IGluZGV4IHdoZXJlIHRoZSBkZWNpc2lvbiBzdGFydGVkXHJcblx0ICogQHBhcmFtIHN0b3BJbmRleCB0aGUgaW5wdXQgaW5kZXggd2hlcmUgdGhlIFNMTCBjb25mbGljdCBvY2N1cnJlZFxyXG5cdCAqIEBwYXJhbSBjb25mbGljdGluZ0FsdHMgVGhlIHNwZWNpZmljIGNvbmZsaWN0aW5nIGFsdGVybmF0aXZlcy4gSWYgdGhpcyBpc1xyXG5cdCAqIGB1bmRlZmluZWRgLCB0aGUgY29uZmxpY3RpbmcgYWx0ZXJuYXRpdmVzIGFyZSBhbGwgYWx0ZXJuYXRpdmVzXHJcblx0ICogcmVwcmVzZW50ZWQgaW4gYGNvbmZpZ3NgLlxyXG5cdCAqIEBwYXJhbSBjb25mbGljdFN0YXRlIHRoZSBzaW11bGF0b3Igc3RhdGUgd2hlbiB0aGUgU0xMIGNvbmZsaWN0IHdhc1xyXG5cdCAqIGRldGVjdGVkXHJcblx0ICovXHJcblx0cmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0PzogKFxyXG5cdFx0LypATm90TnVsbCovXHJcblx0XHRyZWNvZ25pemVyOiBQYXJzZXIsXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdGRmYTogREZBLFxyXG5cdFx0c3RhcnRJbmRleDogbnVtYmVyLFxyXG5cdFx0c3RvcEluZGV4OiBudW1iZXIsXHJcblx0XHRjb25mbGljdGluZ0FsdHM6IEJpdFNldCB8IHVuZGVmaW5lZCxcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0Y29uZmxpY3RTdGF0ZTogU2ltdWxhdG9yU3RhdGUpID0+IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgcGFyc2VyIHdoZW4gYSBmdWxsLWNvbnRleHQgcHJlZGljdGlvbiBoYXMgYVxyXG5cdCAqIHVuaXF1ZSByZXN1bHQuXHJcblx0ICpcclxuXHQgKiBFYWNoIGZ1bGwtY29udGV4dCBwcmVkaWN0aW9uIHdoaWNoIGRvZXMgbm90IHJlc3VsdCBpbiBhIHN5bnRheCBlcnJvclxyXG5cdCAqIHdpbGwgY2FsbCBlaXRoZXIge0BsaW5rICNyZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHl9IG9yXHJcblx0ICoge0BsaW5rICNyZXBvcnRBbWJpZ3VpdHl9LlxyXG5cdCAqXHJcblx0ICogRm9yIHByZWRpY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgb25seSBldmFsdWF0ZSBmdWxsLWNvbnRleHRcclxuXHQgKiBwcmVkaWN0aW9ucyB3aGVuIGFuIFNMTCBjb25mbGljdCBpcyBmb3VuZCAoaW5jbHVkaW5nIHRoZSBkZWZhdWx0XHJcblx0ICoge0BsaW5rIFBhcnNlckFUTlNpbXVsYXRvcn0gaW1wbGVtZW50YXRpb24pLCB0aGlzIG1ldGhvZCByZXBvcnRzIGNhc2VzXHJcblx0ICogd2hlcmUgU0xMIGNvbmZsaWN0cyB3ZXJlIHJlc29sdmVkIHRvIHVuaXF1ZSBmdWxsLWNvbnRleHQgcHJlZGljdGlvbnMsXHJcblx0ICogaS5lLiB0aGUgZGVjaXNpb24gd2FzIGNvbnRleHQtc2Vuc2l0aXZlLiBUaGlzIHJlcG9ydCBkb2VzIG5vdCBuZWNlc3NhcmlseVxyXG5cdCAqIGluZGljYXRlIGEgcHJvYmxlbSwgYW5kIGl0IG1heSBhcHBlYXIgZXZlbiBpbiBjb21wbGV0ZWx5IHVuYW1iaWd1b3VzXHJcblx0ICogZ3JhbW1hcnMuXHJcblx0ICpcclxuXHQgKiBgY29uZmlnc2AgbWF5IGhhdmUgbW9yZSB0aGFuIG9uZSByZXByZXNlbnRlZCBhbHRlcm5hdGl2ZSBpZiB0aGVcclxuXHQgKiBmdWxsLWNvbnRleHQgcHJlZGljdGlvbiBhbGdvcml0aG0gZG9lcyBub3QgZXZhbHVhdGUgcHJlZGljYXRlcyBiZWZvcmVcclxuXHQgKiBiZWdpbm5pbmcgdGhlIGZ1bGwtY29udGV4dCBwcmVkaWN0aW9uLiBJbiBhbGwgY2FzZXMsIHRoZSBmaW5hbCBwcmVkaWN0aW9uXHJcblx0ICogaXMgcGFzc2VkIGFzIHRoZSBgcHJlZGljdGlvbmAgYXJndW1lbnQuXHJcblx0ICpcclxuXHQgKiBOb3RlIHRoYXQgdGhlIGRlZmluaXRpb24gb2YgXCJjb250ZXh0IHNlbnNpdGl2aXR5XCIgaW4gdGhpcyBtZXRob2RcclxuXHQgKiBkaWZmZXJzIGZyb20gdGhlIGNvbmNlcHQgaW4ge0BsaW5rIERlY2lzaW9uSW5mbyNjb250ZXh0U2Vuc2l0aXZpdGllc30uXHJcblx0ICogVGhpcyBtZXRob2QgcmVwb3J0cyBhbGwgaW5zdGFuY2VzIHdoZXJlIGFuIFNMTCBjb25mbGljdCBvY2N1cnJlZCBidXQgTExcclxuXHQgKiBwYXJzaW5nIHByb2R1Y2VkIGEgdW5pcXVlIHJlc3VsdCwgd2hldGhlciBvciBub3QgdGhhdCB1bmlxdWUgcmVzdWx0XHJcblx0ICogbWF0Y2hlcyB0aGUgbWluaW11bSBhbHRlcm5hdGl2ZSBpbiB0aGUgU0xMIGNvbmZsaWN0aW5nIHNldC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2VcclxuXHQgKiBAcGFyYW0gZGZhIHRoZSBERkEgZm9yIHRoZSBjdXJyZW50IGRlY2lzaW9uXHJcblx0ICogQHBhcmFtIHN0YXJ0SW5kZXggdGhlIGlucHV0IGluZGV4IHdoZXJlIHRoZSBkZWNpc2lvbiBzdGFydGVkXHJcblx0ICogQHBhcmFtIHN0b3BJbmRleCB0aGUgaW5wdXQgaW5kZXggd2hlcmUgdGhlIGNvbnRleHQgc2Vuc2l0aXZpdHkgd2FzXHJcblx0ICogZmluYWxseSBkZXRlcm1pbmVkXHJcblx0ICogQHBhcmFtIHByZWRpY3Rpb24gdGhlIHVuYW1iaWd1b3VzIHJlc3VsdCBvZiB0aGUgZnVsbC1jb250ZXh0IHByZWRpY3Rpb25cclxuXHQgKiBAcGFyYW0gYWNjZXB0U3RhdGUgdGhlIHNpbXVsYXRvciBzdGF0ZSB3aGVuIHRoZSB1bmFtYmlndW91cyBwcmVkaWN0aW9uXHJcblx0ICogd2FzIGRldGVybWluZWRcclxuXHQgKi9cclxuXHRyZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHk/OiAoXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdHJlY29nbml6ZXI6IFBhcnNlcixcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0ZGZhOiBERkEsXHJcblx0XHRzdGFydEluZGV4OiBudW1iZXIsXHJcblx0XHRzdG9wSW5kZXg6IG51bWJlcixcclxuXHRcdHByZWRpY3Rpb246IG51bWJlcixcclxuXHRcdC8qQE5vdE51bGwqL1xyXG5cdFx0YWNjZXB0U3RhdGU6IFNpbXVsYXRvclN0YXRlKSA9PiB2b2lkO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1Ny40NzQxMTk2LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiLi9hdG4vQVROXCI7XHJcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcIi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuL1BhcnNlclJ1bGVDb250ZXh0XCI7XHJcblxyXG4vKiogQSBoYW5keSBjbGFzcyBmb3IgdXNlIHdpdGhcclxuICpcclxuICogIG9wdGlvbnMge2NvbnRleHRTdXBlckNsYXNzPW9yZy5hbnRsci52NC5ydW50aW1lLlJ1bGVDb250ZXh0V2l0aEFsdE51bTt9XHJcbiAqXHJcbiAqICB0aGF0IHByb3ZpZGVzIGEgYmFja2luZyBmaWVsZCAvIGltcGwgZm9yIHRoZSBvdXRlciBhbHRlcm5hdGl2ZSBudW1iZXJcclxuICogIG1hdGNoZWQgZm9yIGFuIGludGVybmFsIHBhcnNlIHRyZWUgbm9kZS5cclxuICpcclxuICogIEknbSBvbmx5IHB1dHRpbmcgaW50byBKYXZhIHJ1bnRpbWUgYXMgSSdtIGNlcnRhaW4gSSdtIHRoZSBvbmx5IG9uZSB0aGF0XHJcbiAqICB3aWxsIHJlYWxseSBldmVyeSB1c2UgdGhpcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQ29udGV4dFdpdGhBbHROdW0gZXh0ZW5kcyBQYXJzZXJSdWxlQ29udGV4dCB7XHJcblx0cHJpdmF0ZSBfYWx0TnVtYmVyOiBudW1iZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCk7XHJcblx0Y29uc3RydWN0b3IocGFyZW50OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgaW52b2tpbmdTdGF0ZU51bWJlcjogbnVtYmVyKTtcclxuXHRjb25zdHJ1Y3RvcihwYXJlbnQ/OiBQYXJzZXJSdWxlQ29udGV4dCwgaW52b2tpbmdTdGF0ZU51bWJlcj86IG51bWJlcikge1xyXG5cdFx0aWYgKGludm9raW5nU3RhdGVOdW1iZXIgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGVOdW1iZXIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3VwZXIoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hbHROdW1iZXIgPSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xyXG5cdH1cclxuXHJcblx0QE92ZXJyaWRlXHJcblx0Z2V0IGFsdE51bWJlcigpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2FsdE51bWJlcjtcclxuXHR9XHJcblxyXG5cdC8vIEBPdmVycmlkZVxyXG5cdHNldCBhbHROdW1iZXIoYWx0TnVtOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuX2FsdE51bWJlciA9IGFsdE51bTtcclxuXHR9XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU3LjYyNzEyMjEtMDc6MDBcclxuXHJcbmltcG9ydCB7IERlcGVuZGVudHMgfSBmcm9tIFwiLi9EZXBlbmRlbnRzXCI7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL1BhcnNlclwiO1xyXG5cclxuLyoqXHJcbiAqIERlY2xhcmVzIGEgZGVwZW5kZW5jeSB1cG9uIGEgZ3JhbW1hciBydWxlLCBhbG9uZyB3aXRoIGEgc2V0IG9mIHplcm8gb3IgbW9yZSBkZXBlbmRlbnQgcnVsZXMuXHJcbiAqXHJcbiAqIFZlcnNpb24gbnVtYmVycyB3aXRoaW4gYSBncmFtbWFyIHNob3VsZCBiZSBhc3NpZ25lZCBvbiBhIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBiYXNpcyB0byBhbGxvdyBmb3IgYWNjdXJhdGVcclxuICogdHJhY2tpbmcgb2YgZGVwZW5kZW50IHJ1bGVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBIYXJ3ZWxsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gUnVsZURlcGVuZGVuY3koZGVwZW5kZW5jeTogRGVwZW5kZW5jeVNwZWNpZmljYXRpb24pIHtcclxuXHRyZXR1cm4gKHRhcmdldDogb2JqZWN0LCBwcm9wZXJ0eUtleTogUHJvcGVydHlLZXksIHByb3BlcnR5RGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSA9PiB7XHJcblx0XHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcblx0fTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEZXBlbmRlbmN5U3BlY2lmaWNhdGlvbiB7XHJcblx0cmVhZG9ubHkgcmVjb2duaXplcjogeyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogUGFyc2VyOyB9O1xyXG5cclxuXHRyZWFkb25seSBydWxlOiBudW1iZXI7XHJcblxyXG5cdHJlYWRvbmx5IHZlcnNpb246IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogU3BlY2lmaWVzIHRoZSBzZXQgb2YgZ3JhbW1hciBydWxlcyByZWxhdGVkIHRvIGBydWxlYCB3aGljaCB0aGUgYW5ub3RhdGVkIGVsZW1lbnQgZGVwZW5kcyBvbi4gRXZlbiB3aGVuIGFic2VudFxyXG5cdCAqIGZyb20gdGhpcyBzZXQsIHRoZSBhbm5vdGF0ZWQgZWxlbWVudCBpcyBpbXBsaWNpdGx5IGRlcGVuZGVudCB1cG9uIHRoZSBleHBsaWNpdGx5IHNwZWNpZmllZCBgcnVsZWAsIHdoaWNoXHJcblx0ICogY29ycmVzcG9uZHMgdG8gdGhlIGBEZXBlbmRlbnRzLlNFTEZgIGVsZW1lbnQuXHJcblx0ICpcclxuXHQgKiBCeSBkZWZhdWx0LCB0aGUgYW5ub3RhdGVkIGVsZW1lbnQgaXMgZGVwZW5kZW50IHVwb24gdGhlIHNwZWNpZmllZCBgcnVsZWAgYW5kIGl0cyBgRGVwZW5kZW50cy5QQVJFTlRTYCwgaS5lLiB0aGVcclxuXHQgKiBydWxlIHdpdGhpbiBvbmUgbGV2ZWwgb2YgY29udGV4dCBpbmZvcm1hdGlvbi4gVGhlIHBhcmVudHMgYXJlIGluY2x1ZGVkIHNpbmNlIHRoZSBtb3N0IGZyZXF1ZW50IGFzc3VtcHRpb24gYWJvdXQgYVxyXG5cdCAqIHJ1bGUgaXMgd2hlcmUgaXQncyB1c2VkIGluIHRoZSBncmFtbWFyLlxyXG5cdCAqL1xyXG5cdHJlYWRvbmx5IGRlcGVuZGVudHM/OiBEZXBlbmRlbnRzW107XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU3LjcxNzAwMjctMDc6MDBcclxuXHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL1BhcnNlclwiO1xyXG5pbXBvcnQgeyBQYXJzZXJSdWxlQ29udGV4dCB9IGZyb20gXCIuL1BhcnNlclJ1bGVDb250ZXh0XCI7XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBTYW0gSGFyd2VsbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFJ1bGVWZXJzaW9uKHZlcnNpb246IG51bWJlcikge1xyXG5cclxuXHRyZXR1cm4gPFQgZXh0ZW5kcyBQYXJzZXJSdWxlQ29udGV4dD4odGFyZ2V0OiBQYXJzZXIsIHByb3BlcnR5S2V5OiBQcm9wZXJ0eUtleSwgcHJvcGVydHlEZXNjcmlwdG9yOiBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjwoLi4uYXJnczogYW55W10pID0+IFQ+KSA9PiB7XHJcblx0XHQvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcblx0fTtcclxuXHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU3Ljg3ODM2NDAtMDc6MDBcclxuXHJcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiLi9DaGFyU3RyZWFtXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5Tb3VyY2UgfSBmcm9tIFwiLi9Ub2tlblNvdXJjZVwiO1xyXG5cclxuLyoqIFRoZSBkZWZhdWx0IG1lY2hhbmlzbSBmb3IgY3JlYXRpbmcgdG9rZW5zLiBJdCdzIHVzZWQgYnkgZGVmYXVsdCBpbiBMZXhlciBhbmRcclxuICogIHRoZSBlcnJvciBoYW5kbGluZyBzdHJhdGVneSAodG8gY3JlYXRlIG1pc3NpbmcgdG9rZW5zKS4gIE5vdGlmeWluZyB0aGUgcGFyc2VyXHJcbiAqICBvZiBhIG5ldyBmYWN0b3J5IG1lYW5zIHRoYXQgaXQgbm90aWZpZXMgaXRzIHRva2VuIHNvdXJjZSBhbmQgZXJyb3Igc3RyYXRlZ3kuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuRmFjdG9yeSB7XHJcblx0LyoqIFRoaXMgaXMgdGhlIG1ldGhvZCB1c2VkIHRvIGNyZWF0ZSB0b2tlbnMgaW4gdGhlIGxleGVyIGFuZCBpbiB0aGVcclxuXHQgKiAgZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ3kuIElmIHRleHQhPXVuZGVmaW5lZCwgdGhhbiB0aGUgc3RhcnQgYW5kIHN0b3AgcG9zaXRpb25zXHJcblx0ICogIGFyZSB3aXBlZCB0byAtMSBpbiB0aGUgdGV4dCBvdmVycmlkZSBpcyBzZXQgaW4gdGhlIENvbW1vblRva2VuLlxyXG5cdCAqL1xyXG5cdC8vQE5vdE51bGxcclxuXHRjcmVhdGUoXHJcblx0XHQvKkBOb3ROdWxsKi9cclxuXHRcdHNvdXJjZTogeyBzb3VyY2U/OiBUb2tlblNvdXJjZSwgc3RyZWFtPzogQ2hhclN0cmVhbSB9LFxyXG5cdFx0dHlwZTogbnVtYmVyLFxyXG5cdFx0dGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkLFxyXG5cdFx0Y2hhbm5lbDogbnVtYmVyLFxyXG5cdFx0c3RhcnQ6IG51bWJlcixcclxuXHRcdHN0b3A6IG51bWJlcixcclxuXHRcdGxpbmU6IG51bWJlcixcclxuXHRcdGNoYXJQb3NpdGlvbkluTGluZTogbnVtYmVyKTogVG9rZW47XHJcblxyXG5cdC8qKiBHZW5lcmljYWxseSB1c2VmdWwgKi9cclxuXHQvL0BOb3ROdWxsXHJcblx0Y3JlYXRlU2ltcGxlKHR5cGU6IG51bWJlciwgdGV4dDogc3RyaW5nKTogVG9rZW47XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU3Ljk2MDQyMDAtMDc6MDBcclxuXHJcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiLi9DaGFyU3RyZWFtXCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5GYWN0b3J5IH0gZnJvbSBcIi4vVG9rZW5GYWN0b3J5XCI7XHJcblxyXG4vKipcclxuICogQSBzb3VyY2Ugb2YgdG9rZW5zIG11c3QgcHJvdmlkZSBhIHNlcXVlbmNlIG9mIHRva2VucyB2aWEge0BsaW5rICNuZXh0VG9rZW4oKX1cclxuICogYW5kIGFsc28gbXVzdCByZXZlYWwgaXQncyBzb3VyY2Ugb2YgY2hhcmFjdGVyczsge0BsaW5rIENvbW1vblRva2VufSdzIHRleHQgaXNcclxuICogY29tcHV0ZWQgZnJvbSBhIHtAbGluayBDaGFyU3RyZWFtfTsgaXQgb25seSBzdG9yZSBpbmRpY2VzIGludG8gdGhlIGNoYXJcclxuICogc3RyZWFtLlxyXG4gKlxyXG4gKiBFcnJvcnMgZnJvbSB0aGUgbGV4ZXIgYXJlIG5ldmVyIHBhc3NlZCB0byB0aGUgcGFyc2VyLiBFaXRoZXIgeW91IHdhbnQgdG8ga2VlcFxyXG4gKiBnb2luZyBvciB5b3UgZG8gbm90IHVwb24gdG9rZW4gcmVjb2duaXRpb24gZXJyb3IuIElmIHlvdSBkbyBub3Qgd2FudCB0b1xyXG4gKiBjb250aW51ZSBsZXhpbmcgdGhlbiB5b3UgZG8gbm90IHdhbnQgdG8gY29udGludWUgcGFyc2luZy4gSnVzdCB0aHJvdyBhblxyXG4gKiBleGNlcHRpb24gbm90IHVuZGVyIHtAbGluayBSZWNvZ25pdGlvbkV4Y2VwdGlvbn0gYW5kIEphdmEgd2lsbCBuYXR1cmFsbHkgdG9zc1xyXG4gKiB5b3UgYWxsIHRoZSB3YXkgb3V0IG9mIHRoZSByZWNvZ25pemVycy4gSWYgeW91IHdhbnQgdG8gY29udGludWUgbGV4aW5nIHRoZW5cclxuICogeW91IHNob3VsZCBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIHRvIHRoZSBwYXJzZXItLWl0IGhhcyBhbHJlYWR5IHJlcXVlc3RlZCBhXHJcbiAqIHRva2VuLiBLZWVwIGxleGluZyB1bnRpbCB5b3UgZ2V0IGEgdmFsaWQgb25lLiBKdXN0IHJlcG9ydCBlcnJvcnMgYW5kIGtlZXBcclxuICogZ29pbmcsIGxvb2tpbmcgZm9yIGEgdmFsaWQgdG9rZW4uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuU291cmNlIHtcclxuXHQvKipcclxuXHQgKiBSZXR1cm4gYSB7QGxpbmsgVG9rZW59IG9iamVjdCBmcm9tIHlvdXIgaW5wdXQgc3RyZWFtICh1c3VhbGx5IGFcclxuXHQgKiB7QGxpbmsgQ2hhclN0cmVhbX0pLiBEbyBub3QgZmFpbC9yZXR1cm4gdXBvbiBsZXhpbmcgZXJyb3I7IGtlZXAgY2hld2luZ1xyXG5cdCAqIG9uIHRoZSBjaGFyYWN0ZXJzIHVudGlsIHlvdSBnZXQgYSBnb29kIG9uZTsgZXJyb3JzIGFyZSBub3QgcGFzc2VkIHRocm91Z2hcclxuXHQgKiB0byB0aGUgcGFyc2VyLlxyXG5cdCAqL1xyXG5cdC8vQE5vdE51bGxcclxuXHRuZXh0VG9rZW4oKTogVG9rZW47XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbGluZSBudW1iZXIgZm9yIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBpbnB1dCBzdHJlYW0uIFRoZVxyXG5cdCAqIGZpcnN0IGxpbmUgaW4gdGhlIGlucHV0IGlzIGxpbmUgMS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBsaW5lIG51bWJlciBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGlucHV0IHN0cmVhbSwgb3JcclxuXHQgKiAwIGlmIHRoZSBjdXJyZW50IHRva2VuIHNvdXJjZSBkb2VzIG5vdCB0cmFjayBsaW5lIG51bWJlcnMuXHJcblx0ICovXHJcblx0cmVhZG9ubHkgbGluZTogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGluZGV4IGludG8gdGhlIGN1cnJlbnQgbGluZSBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGlucHV0XHJcblx0ICogc3RyZWFtLiBUaGUgZmlyc3QgY2hhcmFjdGVyIG9uIGEgbGluZSBoYXMgcG9zaXRpb24gMC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBsaW5lIG51bWJlciBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGlucHV0IHN0cmVhbSwgb3JcclxuXHQgKiAtMSBpZiB0aGUgY3VycmVudCB0b2tlbiBzb3VyY2UgZG9lcyBub3QgdHJhY2sgY2hhcmFjdGVyIHBvc2l0aW9ucy5cclxuXHQgKi9cclxuXHRyZWFkb25seSBjaGFyUG9zaXRpb25JbkxpbmU6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSB7QGxpbmsgQ2hhclN0cmVhbX0gZnJvbSB3aGljaCB0aGlzIHRva2VuIHNvdXJjZSBpcyBjdXJyZW50bHlcclxuXHQgKiBwcm92aWRpbmcgdG9rZW5zLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIHtAbGluayBDaGFyU3RyZWFtfSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgcG9zaXRpb24gaW5cclxuXHQgKiB0aGUgaW5wdXQsIG9yIGB1bmRlZmluZWRgIGlmIG5vIGlucHV0IHN0cmVhbSBpcyBhdmFpbGFibGUgZm9yIHRoZSB0b2tlblxyXG5cdCAqIHNvdXJjZS5cclxuXHQgKi9cclxuXHRyZWFkb25seSBpbnB1dFN0cmVhbTogQ2hhclN0cmVhbSB8IHVuZGVmaW5lZDtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgdW5kZXJseWluZyBpbnB1dCBzb3VyY2UuIFRoaXMgbWV0aG9kIHJldHVybnMgYVxyXG5cdCAqIG5vbi11bmRlZmluZWQsIG5vbi1lbXB0eSBzdHJpbmcuIElmIHN1Y2ggYSBuYW1lIGlzIG5vdCBrbm93biwgdGhpcyBtZXRob2RcclxuXHQgKiByZXR1cm5zIHtAbGluayBJbnRTdHJlYW0jVU5LTk9XTl9TT1VSQ0VfTkFNRX0uXHJcblx0ICovXHJcblx0Ly9ATm90TnVsbFxyXG5cdHJlYWRvbmx5IHNvdXJjZU5hbWU6IHN0cmluZztcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyBvciBzZXRzIHRoZSBgVG9rZW5GYWN0b3J5YCB0aGlzIHRva2VuIHNvdXJjZSBpcyBjdXJyZW50bHkgdXNpbmcgZm9yXHJcblx0ICogY3JlYXRpbmcgYFRva2VuYCBvYmplY3RzIGZyb20gdGhlIGlucHV0LlxyXG5cdCAqL1xyXG5cdC8vQE5vdE51bGxcclxuXHR0b2tlbkZhY3Rvcnk6IFRva2VuRmFjdG9yeTtcclxufVxyXG4iLCAiLyohXHJcbiAqIENvcHlyaWdodCAyMDE2IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICovXHJcblxyXG4vLyBDb252ZXJ0VG8tVFMgcnVuIGF0IDIwMTYtMTAtMDRUMTE6MjY6NTguMDQzMzk5OC0wNzowMFxyXG5cclxuaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tIFwiLi9taXNjL0ludGVydmFsXCI7XHJcbmltcG9ydCB7IEludFN0cmVhbSB9IGZyb20gXCIuL0ludFN0cmVhbVwiO1xyXG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCIuL1J1bGVDb250ZXh0XCI7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4vVG9rZW5cIjtcclxuaW1wb3J0IHsgVG9rZW5Tb3VyY2UgfSBmcm9tIFwiLi9Ub2tlblNvdXJjZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIHtAbGluayBJbnRTdHJlYW19IHdob3NlIHN5bWJvbHMgYXJlIHtAbGluayBUb2tlbn0gaW5zdGFuY2VzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUb2tlblN0cmVhbSBleHRlbmRzIEludFN0cmVhbSB7XHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBgVG9rZW5gIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgYExBKGspYC4gVGhpcyBtZXRob2QgaGFzIHRoZSBzYW1lIHByZS0gYW5kXHJcblx0ICogcG9zdC1jb25kaXRpb25zIGFzIGBJbnRTdHJlYW0uTEFgLiBJbiBhZGRpdGlvbiwgd2hlbiB0aGUgcHJlY29uZGl0aW9ucyBvZiB0aGlzIG1ldGhvZCBhcmUgbWV0LCB0aGUgcmV0dXJuIHZhbHVlXHJcblx0ICogaXMgbm9uLXVuZGVmaW5lZCBhbmQgdGhlIHZhbHVlIG9mIGBMVChrKS50eXBlID09PSBMQShrKWAuXHJcblx0ICpcclxuXHQgKiBBIGBSYW5nZUVycm9yYCBpcyB0aHJvd24gaWYgYGs8MGAgYW5kIGZld2VyIHRoYW4gYC1rYCBjYWxscyB0byBgY29uc3VtZSgpYCBoYXZlIG9jY3VycmVkIGZyb20gdGhlIGJlZ2lubmluZyBvZlxyXG5cdCAqIHRoZSBzdHJlYW0gYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBTZWUgYEludFN0cmVhbS5MQWBcclxuXHQgKi9cclxuXHRMVChrOiBudW1iZXIpOiBUb2tlbjtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBgVG9rZW5gIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgYExBKGspYC4gVGhpcyBtZXRob2QgaGFzIHRoZSBzYW1lIHByZS0gYW5kXHJcblx0ICogcG9zdC1jb25kaXRpb25zIGFzIGBJbnRTdHJlYW0uTEFgLiBJbiBhZGRpdGlvbiwgd2hlbiB0aGUgcHJlY29uZGl0aW9ucyBvZiB0aGlzIG1ldGhvZCBhcmUgbWV0LCB0aGUgcmV0dXJuIHZhbHVlXHJcblx0ICogaXMgbm9uLXVuZGVmaW5lZCBhbmQgdGhlIHZhbHVlIG9mIGB0cnlMVChrKS50eXBlID09PSBMQShrKWAuXHJcblx0ICpcclxuXHQgKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGB1bmRlZmluZWRgIGlmIGBrPDBgIGFuZCBmZXdlciB0aGFuIGAta2AgY2FsbHMgdG8gYGNvbnN1bWUoKWAgaGF2ZSBvY2N1cnJlZCBmcm9tIHRoZVxyXG5cdCAqIGJlZ2lubmluZyBvZiB0aGUgc3RyZWFtIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxyXG5cdCAqXHJcblx0ICogU2VlIGBJbnRTdHJlYW0uTEFgXHJcblx0ICovXHJcblx0dHJ5TFQoazogbnVtYmVyKTogVG9rZW4gfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHtAbGluayBUb2tlbn0gYXQgdGhlIHNwZWNpZmllZCBgaW5kZXhgIGluIHRoZSBzdHJlYW0uIFdoZW5cclxuXHQgKiB0aGUgcHJlY29uZGl0aW9ucyBvZiB0aGlzIG1ldGhvZCBhcmUgbWV0LCB0aGUgcmV0dXJuIHZhbHVlIGlzIG5vbi11bmRlZmluZWQuXHJcblx0ICpcclxuXHQgKiBUaGUgcHJlY29uZGl0aW9ucyBmb3IgdGhpcyBtZXRob2QgYXJlIHRoZSBzYW1lIGFzIHRoZSBwcmVjb25kaXRpb25zIG9mXHJcblx0ICoge0BsaW5rIEludFN0cmVhbSNzZWVrfS4gSWYgdGhlIGJlaGF2aW9yIG9mIGBzZWVrKGluZGV4KWAgaXNcclxuXHQgKiB1bnNwZWNpZmllZCBmb3IgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGdpdmVuIGBpbmRleGAsIHRoZW4gdGhlXHJcblx0ICogYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgYWxzbyB1bnNwZWNpZmllZC5cclxuXHQgKlxyXG5cdCAqIFRoZSBzeW1ib2wgcmVmZXJyZWQgdG8gYnkgYGluZGV4YCBkaWZmZXJzIGZyb20gYHNlZWsoKWAgb25seVxyXG5cdCAqIGluIHRoZSBjYXNlIG9mIGZpbHRlcmluZyBzdHJlYW1zIHdoZXJlIGBpbmRleGAgbGllcyBiZWZvcmUgdGhlIGVuZFxyXG5cdCAqIG9mIHRoZSBzdHJlYW0uIFVubGlrZSBgc2VlaygpYCwgdGhpcyBtZXRob2QgZG9lcyBub3QgYWRqdXN0XHJcblx0ICogYGluZGV4YCB0byBwb2ludCB0byBhIG5vbi1pZ25vcmVkIHN5bWJvbC5cclxuXHQgKlxyXG5cdCAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIHtjb2RlIGluZGV4fSBpcyBsZXNzIHRoYW4gMFxyXG5cdCAqIEB0aHJvd3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gaWYgdGhlIHN0cmVhbSBkb2VzIG5vdCBzdXBwb3J0XHJcblx0ICogcmV0cmlldmluZyB0aGUgdG9rZW4gYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG5cdCAqL1xyXG5cdC8vQE5vdE51bGxcclxuXHRnZXQoaTogbnVtYmVyKTogVG9rZW47XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFRva2VuU291cmNlfSB3aGljaCBwcm92aWRlcyB0b2tlbnMgZm9yIHRoaXNcclxuXHQgKiBzdHJlYW0uXHJcblx0ICovXHJcblx0Ly9ATm90TnVsbFxyXG5cdHJlYWRvbmx5IHRva2VuU291cmNlOiBUb2tlblNvdXJjZTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIHRoZSB0ZXh0IG9mIGFsbCB0b2tlbnMgd2l0aGluIHRoZSBzcGVjaWZpZWQgYGludGVydmFsYC4gVGhpc1xyXG5cdCAqIG1ldGhvZCBiZWhhdmVzIGxpa2UgdGhlIGZvbGxvd2luZyBjb2RlIChpbmNsdWRpbmcgcG90ZW50aWFsIGV4Y2VwdGlvbnNcclxuXHQgKiBmb3IgdmlvbGF0aW5nIHByZWNvbmRpdGlvbnMgb2Yge0BsaW5rICNnZXR9LCBidXQgbWF5IGJlIG9wdGltaXplZCBieSB0aGVcclxuXHQgKiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbi5cclxuXHQgKlxyXG5cdCAqIGBgYFxyXG5cdCAqIFRva2VuU3RyZWFtIHN0cmVhbSA9IC4uLjtcclxuXHQgKiBTdHJpbmcgdGV4dCA9IFwiXCI7XHJcblx0ICogZm9yIChpbnQgaSA9IGludGVydmFsLmE7IGkgPD0gaW50ZXJ2YWwuYjsgaSsrKSB7XHJcblx0ICogICB0ZXh0ICs9IHN0cmVhbS5nZXQoaSkudGV4dDtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gaW50ZXJ2YWwgVGhlIGludGVydmFsIG9mIHRva2VucyB3aXRoaW4gdGhpcyBzdHJlYW0gdG8gZ2V0IHRleHRcclxuXHQgKiBmb3IuXHJcblx0ICogQHJldHVybnMgVGhlIHRleHQgb2YgYWxsIHRva2VucyB3aXRoaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbCBpbiB0aGlzXHJcblx0ICogc3RyZWFtLlxyXG5cdCAqXHJcblx0ICogQHRocm93cyBOdWxsUG9pbnRlckV4Y2VwdGlvbiBpZiBgaW50ZXJ2YWxgIGlzIGB1bmRlZmluZWRgXHJcblx0ICovXHJcblx0Ly9ATm90TnVsbFxyXG5cdGdldFRleHQoLypATm90TnVsbCovIGludGVydmFsOiBJbnRlcnZhbCk6IHN0cmluZztcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIHRoZSB0ZXh0IG9mIGFsbCB0b2tlbnMgaW4gdGhlIHN0cmVhbS4gVGhpcyBtZXRob2QgYmVoYXZlcyBsaWtlIHRoZVxyXG5cdCAqIGZvbGxvd2luZyBjb2RlLCBpbmNsdWRpbmcgcG90ZW50aWFsIGV4Y2VwdGlvbnMgZnJvbSB0aGUgY2FsbHMgdG9cclxuXHQgKiB7QGxpbmsgSW50U3RyZWFtI3NpemV9IGFuZCB7QGxpbmsgI2dldFRleHQoSW50ZXJ2YWwpfSwgYnV0IG1heSBiZVxyXG5cdCAqIG9wdGltaXplZCBieSB0aGUgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24uXHJcblx0ICpcclxuXHQgKiBgYGBcclxuXHQgKiBUb2tlblN0cmVhbSBzdHJlYW0gPSAuLi47XHJcblx0ICogU3RyaW5nIHRleHQgPSBzdHJlYW0uZ2V0VGV4dChuZXcgSW50ZXJ2YWwoMCwgc3RyZWFtLnNpemUpKTtcclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSB0ZXh0IG9mIGFsbCB0b2tlbnMgaW4gdGhlIHN0cmVhbS5cclxuXHQgKi9cclxuXHQvL0BOb3ROdWxsXHJcblx0Z2V0VGV4dCgpOiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiB0aGUgdGV4dCBvZiBhbGwgdG9rZW5zIGluIHRoZSBzb3VyY2UgaW50ZXJ2YWwgb2YgdGhlIHNwZWNpZmllZFxyXG5cdCAqIGNvbnRleHQuIFRoaXMgbWV0aG9kIGJlaGF2ZXMgbGlrZSB0aGUgZm9sbG93aW5nIGNvZGUsIGluY2x1ZGluZyBwb3RlbnRpYWxcclxuXHQgKiBleGNlcHRpb25zIGZyb20gdGhlIGNhbGwgdG8ge0BsaW5rICNnZXRUZXh0KEludGVydmFsKX0sIGJ1dCBtYXkgYmVcclxuXHQgKiBvcHRpbWl6ZWQgYnkgdGhlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uLlxyXG5cdCAqXHJcblx0ICogSWYgYGN0eC5zb3VyY2VJbnRlcnZhbGAgZG9lcyBub3QgcmV0dXJuIGEgdmFsaWQgaW50ZXJ2YWwgb2ZcclxuXHQgKiB0b2tlbnMgcHJvdmlkZWQgYnkgdGhpcyBzdHJlYW0sIHRoZSBiZWhhdmlvciBpcyB1bnNwZWNpZmllZC5cclxuXHQgKlxyXG5cdCAqIGBgYFxyXG5cdCAqIFRva2VuU3RyZWFtIHN0cmVhbSA9IC4uLjtcclxuXHQgKiBTdHJpbmcgdGV4dCA9IHN0cmVhbS5nZXRUZXh0KGN0eC5zb3VyY2VJbnRlcnZhbCk7XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gY3R4IFRoZSBjb250ZXh0IHByb3ZpZGluZyB0aGUgc291cmNlIGludGVydmFsIG9mIHRva2VucyB0byBnZXRcclxuXHQgKiB0ZXh0IGZvci5cclxuXHQgKiBAcmV0dXJucyBUaGUgdGV4dCBvZiBhbGwgdG9rZW5zIHdpdGhpbiB0aGUgc291cmNlIGludGVydmFsIG9mIGBjdHhgLlxyXG5cdCAqL1xyXG5cdC8vQE5vdE51bGxcclxuXHRnZXRUZXh0KC8qQE5vdE51bGwqLyBjdHg6IFJ1bGVDb250ZXh0KTogc3RyaW5nO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGhlIHRleHQgb2YgYWxsIHRva2VucyBpbiB0aGlzIHN0cmVhbSBiZXR3ZWVuIGBzdGFydGAgYW5kXHJcblx0ICogYHN0b3BgIChpbmNsdXNpdmUpLlxyXG5cdCAqXHJcblx0ICogSWYgdGhlIHNwZWNpZmllZCBgc3RhcnRgIG9yIGBzdG9wYCB0b2tlbiB3YXMgbm90IHByb3ZpZGVkIGJ5XHJcblx0ICogdGhpcyBzdHJlYW0sIG9yIGlmIHRoZSBgc3RvcGAgb2NjdXJyZWQgYmVmb3JlIHRoZSBgc3RhcnRgfVxyXG5cdCAqIHRva2VuLCB0aGUgYmVoYXZpb3IgaXMgdW5zcGVjaWZpZWQuXHJcblx0ICpcclxuXHQgKiBGb3Igc3RyZWFtcyB3aGljaCBlbnN1cmUgdGhhdCB0aGUgYFRva2VuLnRva2VuSW5kZXhgIG1ldGhvZCBpc1xyXG5cdCAqIGFjY3VyYXRlIGZvciBhbGwgb2YgaXRzIHByb3ZpZGVkIHRva2VucywgdGhpcyBtZXRob2QgYmVoYXZlcyBsaWtlIHRoZVxyXG5cdCAqIGZvbGxvd2luZyBjb2RlLiBPdGhlciBzdHJlYW1zIG1heSBpbXBsZW1lbnQgdGhpcyBtZXRob2QgaW4gb3RoZXIgd2F5c1xyXG5cdCAqIHByb3ZpZGVkIHRoZSBiZWhhdmlvciBpcyBjb25zaXN0ZW50IHdpdGggdGhpcyBhdCBhIGhpZ2ggbGV2ZWwuXHJcblx0ICpcclxuXHQgKiBgYGBcclxuXHQgKiBUb2tlblN0cmVhbSBzdHJlYW0gPSAuLi47XHJcblx0ICogU3RyaW5nIHRleHQgPSBcIlwiO1xyXG5cdCAqIGZvciAoaW50IGkgPSBzdGFydC50b2tlbkluZGV4OyBpIDw9IHN0b3AudG9rZW5JbmRleDsgaSsrKSB7XHJcblx0ICogICB0ZXh0ICs9IHN0cmVhbS5nZXQoaSkudGV4dDtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gc3RhcnQgVGhlIGZpcnN0IHRva2VuIGluIHRoZSBpbnRlcnZhbCB0byBnZXQgdGV4dCBmb3IuXHJcblx0ICogQHBhcmFtIHN0b3AgVGhlIGxhc3QgdG9rZW4gaW4gdGhlIGludGVydmFsIHRvIGdldCB0ZXh0IGZvciAoaW5jbHVzaXZlKS5cclxuXHQgKiBAcmV0dXJucyBUaGUgdGV4dCBvZiBhbGwgdG9rZW5zIGx5aW5nIGJldHdlZW4gdGhlIHNwZWNpZmllZCBgc3RhcnRgXHJcblx0ICogYW5kIGBzdG9wYCB0b2tlbnMuXHJcblx0ICpcclxuXHQgKiBAdGhyb3dzIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uIGlmIHRoaXMgc3RyZWFtIGRvZXMgbm90IHN1cHBvcnRcclxuXHQgKiB0aGlzIG1ldGhvZCBmb3IgdGhlIHNwZWNpZmllZCB0b2tlbnNcclxuXHQgKi9cclxuXHQvL0BOb3ROdWxsXHJcblx0Z2V0VGV4dEZyb21SYW5nZShzdGFydDogYW55LCBzdG9wOiBhbnkpOiBzdHJpbmc7XHJcbn1cclxuIiwgIi8qIVxyXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0zLUNsYXVzZSBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5cclxuLy8gQ29udmVydFRvLVRTIHJ1biBhdCAyMDE2LTEwLTA0VDExOjI2OjU4LjE3Njg4NTAtMDc6MDBcclxuXHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4vbWlzYy9JbnRlcnZhbFwiO1xyXG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCIuL0RlY29yYXRvcnNcIjtcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi9Ub2tlblwiO1xyXG5pbXBvcnQgeyBUb2tlblN0cmVhbSB9IGZyb20gXCIuL1Rva2VuU3RyZWFtXCI7XHJcblxyXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiLi9taXNjL1V0aWxzXCI7XHJcblxyXG4vKipcclxuICogVXNlZnVsIGZvciByZXdyaXRpbmcgb3V0IGEgYnVmZmVyZWQgaW5wdXQgdG9rZW4gc3RyZWFtIGFmdGVyIGRvaW5nIHNvbWVcclxuICogYXVnbWVudGF0aW9uIG9yIG90aGVyIG1hbmlwdWxhdGlvbnMgb24gaXQuXHJcbiAqXHJcbiAqIFlvdSBjYW4gaW5zZXJ0IHN0dWZmLCByZXBsYWNlLCBhbmQgZGVsZXRlIGNodW5rcy4gTm90ZSB0aGF0IHRoZSBvcGVyYXRpb25zXHJcbiAqIGFyZSBkb25lIGxhemlseS0tb25seSBpZiB5b3UgY29udmVydCB0aGUgYnVmZmVyIHRvIGEge0BsaW5rIFN0cmluZ30gd2l0aFxyXG4gKiB7QGxpbmsgVG9rZW5TdHJlYW0jZ2V0VGV4dCgpfS4gVGhpcyBpcyB2ZXJ5IGVmZmljaWVudCBiZWNhdXNlIHlvdSBhcmUgbm90XHJcbiAqIG1vdmluZyBkYXRhIGFyb3VuZCBhbGwgdGhlIHRpbWUuIEFzIHRoZSBidWZmZXIgb2YgdG9rZW5zIGlzIGNvbnZlcnRlZCB0b1xyXG4gKiBzdHJpbmdzLCB0aGUge0BsaW5rICNnZXRUZXh0KCl9IG1ldGhvZChzKSBzY2FuIHRoZSBpbnB1dCB0b2tlbiBzdHJlYW0gYW5kXHJcbiAqIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhbiBvcGVyYXRpb24gYXQgdGhlIGN1cnJlbnQgaW5kZXguIElmIHNvLCB0aGVcclxuICogb3BlcmF0aW9uIGlzIGRvbmUgYW5kIHRoZW4gbm9ybWFsIHtAbGluayBTdHJpbmd9IHJlbmRlcmluZyBjb250aW51ZXMgb24gdGhlXHJcbiAqIGJ1ZmZlci4gVGhpcyBpcyBsaWtlIGhhdmluZyBtdWx0aXBsZSBUdXJpbmcgbWFjaGluZSBpbnN0cnVjdGlvbiBzdHJlYW1zXHJcbiAqIChwcm9ncmFtcykgb3BlcmF0aW5nIG9uIGEgc2luZ2xlIGlucHV0IHRhcGUuIDopXHJcbiAqXHJcbiAqIFRoaXMgcmV3cml0ZXIgbWFrZXMgbm8gbW9kaWZpY2F0aW9ucyB0byB0aGUgdG9rZW4gc3RyZWFtLiBJdCBkb2VzIG5vdCBhc2sgdGhlXHJcbiAqIHN0cmVhbSB0byBmaWxsIGl0c2VsZiB1cCBub3IgZG9lcyBpdCBhZHZhbmNlIHRoZSBpbnB1dCBjdXJzb3IuIFRoZSB0b2tlblxyXG4gKiBzdHJlYW0gYFRva2VuU3RyZWFtLmluZGV4YCB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZSBiZWZvcmUgYW5kXHJcbiAqIGFmdGVyIGFueSB7QGxpbmsgI2dldFRleHQoKX0gY2FsbC5cclxuICpcclxuICogVGhlIHJld3JpdGVyIG9ubHkgd29ya3Mgb24gdG9rZW5zIHRoYXQgeW91IGhhdmUgaW4gdGhlIGJ1ZmZlciBhbmQgaWdub3JlcyB0aGVcclxuICogY3VycmVudCBpbnB1dCBjdXJzb3IuIElmIHlvdSBhcmUgYnVmZmVyaW5nIHRva2VucyBvbi1kZW1hbmQsIGNhbGxpbmdcclxuICoge0BsaW5rICNnZXRUZXh0KCl9IGhhbGZ3YXkgdGhyb3VnaCB0aGUgaW5wdXQgd2lsbCBvbmx5IGRvIHJld3JpdGVzIGZvciB0aG9zZVxyXG4gKiB0b2tlbnMgaW4gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIGZpbGUuXHJcbiAqXHJcbiAqIFNpbmNlIHRoZSBvcGVyYXRpb25zIGFyZSBkb25lIGxhemlseSBhdCB7QGxpbmsgI2dldFRleHR9LXRpbWUsIG9wZXJhdGlvbnMgZG9cclxuICogbm90IHNjcmV3IHVwIHRoZSB0b2tlbiBpbmRleCB2YWx1ZXMuIFRoYXQgaXMsIGFuIGluc2VydCBvcGVyYXRpb24gYXQgdG9rZW5cclxuICogaW5kZXggYGlgIGRvZXMgbm90IGNoYW5nZSB0aGUgaW5kZXggdmFsdWVzIGZvciB0b2tlbnNcclxuICogYGlgKzEuLm4tMS5cclxuICpcclxuICogQmVjYXVzZSBvcGVyYXRpb25zIG5ldmVyIGFjdHVhbGx5IGFsdGVyIHRoZSBidWZmZXIsIHlvdSBtYXkgYWx3YXlzIGdldCB0aGVcclxuICogb3JpZ2luYWwgdG9rZW4gc3RyZWFtIGJhY2sgd2l0aG91dCB1bmRvaW5nIGFueXRoaW5nLiBTaW5jZSB0aGUgaW5zdHJ1Y3Rpb25zXHJcbiAqIGFyZSBxdWV1ZWQgdXAsIHlvdSBjYW4gZWFzaWx5IHNpbXVsYXRlIHRyYW5zYWN0aW9ucyBhbmQgcm9sbCBiYWNrIGFueSBjaGFuZ2VzXHJcbiAqIGlmIHRoZXJlIGlzIGFuIGVycm9yIGp1c3QgYnkgcmVtb3ZpbmcgaW5zdHJ1Y3Rpb25zLiBGb3IgZXhhbXBsZSxcclxuICpcclxuICogYGBgXHJcbiAqIENoYXJTdHJlYW0gaW5wdXQgPSBuZXcgQU5UTFJGaWxlU3RyZWFtKFwiaW5wdXRcIik7XHJcbiAqIFRMZXhlciBsZXggPSBuZXcgVExleGVyKGlucHV0KTtcclxuICogQ29tbW9uVG9rZW5TdHJlYW0gdG9rZW5zID0gbmV3IENvbW1vblRva2VuU3RyZWFtKGxleCk7XHJcbiAqIFQgcGFyc2VyID0gbmV3IFQodG9rZW5zKTtcclxuICogVG9rZW5TdHJlYW1SZXdyaXRlciByZXdyaXRlciA9IG5ldyBUb2tlblN0cmVhbVJld3JpdGVyKHRva2Vucyk7XHJcbiAqIHBhcnNlci5zdGFydFJ1bGUoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZW4gaW4gdGhlIHJ1bGVzLCB5b3UgY2FuIGV4ZWN1dGUgKGFzc3VtaW5nIHJld3JpdGVyIGlzIHZpc2libGUpOlxyXG4gKlxyXG4gKiBgYGBcclxuICogVG9rZW4gdCx1O1xyXG4gKiAuLi5cclxuICogcmV3cml0ZXIuaW5zZXJ0QWZ0ZXIodCwgXCJ0ZXh0IHRvIHB1dCBhZnRlciB0XCIpO31cclxuICogcmV3cml0ZXIuaW5zZXJ0QWZ0ZXIodSwgXCJ0ZXh0IGFmdGVyIHVcIik7fVxyXG4gKiBTeXN0ZW0ub3V0LnByaW50bG4ocmV3cml0ZXIuZ2V0VGV4dCgpKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFlvdSBjYW4gYWxzbyBoYXZlIG11bHRpcGxlIFwiaW5zdHJ1Y3Rpb24gc3RyZWFtc1wiIGFuZCBnZXQgbXVsdGlwbGUgcmV3cml0ZXNcclxuICogZnJvbSBhIHNpbmdsZSBwYXNzIG92ZXIgdGhlIGlucHV0LiBKdXN0IG5hbWUgdGhlIGluc3RydWN0aW9uIHN0cmVhbXMgYW5kIHVzZVxyXG4gKiB0aGF0IG5hbWUgYWdhaW4gd2hlbiBwcmludGluZyB0aGUgYnVmZmVyLiBUaGlzIGNvdWxkIGJlIHVzZWZ1bCBmb3IgZ2VuZXJhdGluZ1xyXG4gKiBhIEMgZmlsZSBhbmQgYWxzbyBpdHMgaGVhZGVyIGZpbGUtLWFsbCBmcm9tIHRoZSBzYW1lIGJ1ZmZlcjpcclxuICpcclxuICogYGBgXHJcbiAqIHJld3JpdGVyLmluc2VydEFmdGVyKFwicGFzczFcIiwgdCwgXCJ0ZXh0IHRvIHB1dCBhZnRlciB0XCIpO31cclxuICogcmV3cml0ZXIuaW5zZXJ0QWZ0ZXIoXCJwYXNzMlwiLCB1LCBcInRleHQgYWZ0ZXIgdVwiKTt9XHJcbiAqIFN5c3RlbS5vdXQucHJpbnRsbihyZXdyaXRlci5nZXRUZXh0KFwicGFzczFcIikpO1xyXG4gKiBTeXN0ZW0ub3V0LnByaW50bG4ocmV3cml0ZXIuZ2V0VGV4dChcInBhc3MyXCIpKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIElmIHlvdSBkb24ndCB1c2UgbmFtZWQgcmV3cml0ZSBzdHJlYW1zLCBhIFwiZGVmYXVsdFwiIHN0cmVhbSBpcyB1c2VkIGFzIHRoZVxyXG4gKiBmaXJzdCBleGFtcGxlIHNob3dzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRva2VuU3RyZWFtUmV3cml0ZXIge1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9QUk9HUkFNX05BTUU6IHN0cmluZyA9ICBcImRlZmF1bHRcIjtcclxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBST0dSQU1fSU5JVF9TSVpFOiBudW1iZXIgPSAgMTAwO1xyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTUlOX1RPS0VOX0lOREVYOiBudW1iZXIgPSAgMDtcclxuXHJcblx0LyoqIE91ciBzb3VyY2Ugc3RyZWFtICovXHJcblx0cHJvdGVjdGVkIHRva2VuczogVG9rZW5TdHJlYW07XHJcblxyXG5cdC8qKiBZb3UgbWF5IGhhdmUgbXVsdGlwbGUsIG5hbWVkIHN0cmVhbXMgb2YgcmV3cml0ZSBvcGVyYXRpb25zLlxyXG5cdCAqICBJJ20gY2FsbGluZyB0aGVzZSB0aGluZ3MgXCJwcm9ncmFtcy5cIlxyXG5cdCAqICBNYXBzIFN0cmluZyAobmFtZSkgJnJhcnI7IHJld3JpdGUgKExpc3QpXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHByb2dyYW1zOiBNYXA8c3RyaW5nLCBSZXdyaXRlT3BlcmF0aW9uW10+O1xyXG5cclxuXHQvKiogTWFwIFN0cmluZyAocHJvZ3JhbSBuYW1lKSAmcmFycjsgSW50ZWdlciBpbmRleCAqL1xyXG5cdHByb3RlY3RlZCBsYXN0UmV3cml0ZVRva2VuSW5kZXhlczogTWFwPHN0cmluZywgbnVtYmVyPjtcclxuXHJcblx0Y29uc3RydWN0b3IodG9rZW5zOiBUb2tlblN0cmVhbSkgIHtcclxuXHRcdHRoaXMudG9rZW5zID0gdG9rZW5zO1xyXG5cdFx0dGhpcy5wcm9ncmFtcyA9IG5ldyBNYXA8c3RyaW5nLCBSZXdyaXRlT3BlcmF0aW9uW10+KCk7XHJcblx0XHR0aGlzLnByb2dyYW1zLnNldChUb2tlblN0cmVhbVJld3JpdGVyLkRFRkFVTFRfUFJPR1JBTV9OQU1FLCBbXSk7XHJcblx0XHR0aGlzLmxhc3RSZXdyaXRlVG9rZW5JbmRleGVzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRUb2tlblN0cmVhbSgpOiBUb2tlblN0cmVhbSB7XHJcblx0XHRyZXR1cm4gdGhpcy50b2tlbnM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcm9sbGJhY2soaW5zdHJ1Y3Rpb25JbmRleDogbnVtYmVyKTogdm9pZDtcclxuXHQvKiogUm9sbGJhY2sgdGhlIGluc3RydWN0aW9uIHN0cmVhbSBmb3IgYSBwcm9ncmFtIHNvIHRoYXRcclxuXHQgKiAgdGhlIGluZGljYXRlZCBpbnN0cnVjdGlvbiAodmlhIGluc3RydWN0aW9uSW5kZXgpIGlzIG5vXHJcblx0ICogIGxvbmdlciBpbiB0aGUgc3RyZWFtLiBVTlRFU1RFRCFcclxuXHQgKi9cclxuXHRwdWJsaWMgcm9sbGJhY2soaW5zdHJ1Y3Rpb25JbmRleDogbnVtYmVyLCBwcm9ncmFtTmFtZTogc3RyaW5nKTogdm9pZDtcclxuXHRwdWJsaWMgcm9sbGJhY2soaW5zdHJ1Y3Rpb25JbmRleDogbnVtYmVyLCBwcm9ncmFtTmFtZTogc3RyaW5nID0gVG9rZW5TdHJlYW1SZXdyaXRlci5ERUZBVUxUX1BST0dSQU1fTkFNRSk6IHZvaWQge1xyXG5cdFx0bGV0IGlzOiBSZXdyaXRlT3BlcmF0aW9uW10gfCB1bmRlZmluZWQgPSAgdGhpcy5wcm9ncmFtcy5nZXQocHJvZ3JhbU5hbWUpO1xyXG5cdFx0aWYgKCBpcyAhPSBudWxsICkge1xyXG5cdFx0XHR0aGlzLnByb2dyYW1zLnNldChwcm9ncmFtTmFtZSwgaXMuc2xpY2UoVG9rZW5TdHJlYW1SZXdyaXRlci5NSU5fVE9LRU5fSU5ERVgsIGluc3RydWN0aW9uSW5kZXgpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBkZWxldGVQcm9ncmFtKCk6IHZvaWQ7XHJcblxyXG5cdC8qKiBSZXNldCB0aGUgcHJvZ3JhbSBzbyB0aGF0IG5vIGluc3RydWN0aW9ucyBleGlzdCAqL1xyXG5cdHB1YmxpYyBkZWxldGVQcm9ncmFtKHByb2dyYW1OYW1lOiBzdHJpbmcpOiB2b2lkO1xyXG5cdHB1YmxpYyBkZWxldGVQcm9ncmFtKHByb2dyYW1OYW1lOiBzdHJpbmcgPSBUb2tlblN0cmVhbVJld3JpdGVyLkRFRkFVTFRfUFJPR1JBTV9OQU1FKTogdm9pZCB7XHJcblx0XHR0aGlzLnJvbGxiYWNrKFRva2VuU3RyZWFtUmV3cml0ZXIuTUlOX1RPS0VOX0lOREVYLCBwcm9ncmFtTmFtZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaW5zZXJ0QWZ0ZXIodDogVG9rZW4sIHRleHQ6IHt9KTogdm9pZDtcclxuXHRwdWJsaWMgaW5zZXJ0QWZ0ZXIoaW5kZXg6IG51bWJlciwgdGV4dDoge30pOiB2b2lkO1xyXG5cdHB1YmxpYyBpbnNlcnRBZnRlcih0OiBUb2tlbiwgdGV4dDoge30sIHByb2dyYW1OYW1lOiBzdHJpbmcpOiB2b2lkO1xyXG5cdHB1YmxpYyBpbnNlcnRBZnRlcihpbmRleDogbnVtYmVyLCB0ZXh0OiB7fSwgcHJvZ3JhbU5hbWU6IHN0cmluZyk6IHZvaWQ7XHJcblx0cHVibGljIGluc2VydEFmdGVyKHRva2VuT3JJbmRleDogVG9rZW4gfCBudW1iZXIsIHRleHQ6IHt9LCBwcm9ncmFtTmFtZTogc3RyaW5nID0gVG9rZW5TdHJlYW1SZXdyaXRlci5ERUZBVUxUX1BST0dSQU1fTkFNRSk6IHZvaWQge1xyXG5cdFx0bGV0IGluZGV4OiBudW1iZXI7XHJcblx0XHRpZiAodHlwZW9mIHRva2VuT3JJbmRleCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRpbmRleCA9IHRva2VuT3JJbmRleDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGluZGV4ID0gdG9rZW5PckluZGV4LnRva2VuSW5kZXg7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdG8gaW5zZXJ0IGFmdGVyLCBqdXN0IGluc2VydCBiZWZvcmUgbmV4dCBpbmRleCAoZXZlbiBpZiBwYXN0IGVuZClcclxuXHRcdGxldCByZXdyaXRlczogUmV3cml0ZU9wZXJhdGlvbltdID0gdGhpcy5nZXRQcm9ncmFtKHByb2dyYW1OYW1lKTtcclxuXHRcdGxldCBvcCA9IG5ldyBJbnNlcnRBZnRlck9wKHRoaXMudG9rZW5zLCBpbmRleCwgcmV3cml0ZXMubGVuZ3RoLCB0ZXh0KTtcclxuXHRcdHJld3JpdGVzLnB1c2gob3ApO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGluc2VydEJlZm9yZSh0OiBUb2tlbiwgdGV4dDoge30pOiB2b2lkO1xyXG5cdHB1YmxpYyBpbnNlcnRCZWZvcmUoaW5kZXg6IG51bWJlciwgdGV4dDoge30pOiB2b2lkO1xyXG5cdHB1YmxpYyBpbnNlcnRCZWZvcmUodDogVG9rZW4sIHRleHQ6IHt9LCBwcm9ncmFtTmFtZTogc3RyaW5nKTogdm9pZDtcclxuXHRwdWJsaWMgaW5zZXJ0QmVmb3JlKGluZGV4OiBudW1iZXIsIHRleHQ6IHt9LCBwcm9ncmFtTmFtZTogc3RyaW5nKTogdm9pZDtcclxuXHRwdWJsaWMgaW5zZXJ0QmVmb3JlKHRva2VuT3JJbmRleDogVG9rZW4gfCBudW1iZXIsIHRleHQ6IHt9LCBwcm9ncmFtTmFtZTogc3RyaW5nID0gVG9rZW5TdHJlYW1SZXdyaXRlci5ERUZBVUxUX1BST0dSQU1fTkFNRSk6IHZvaWQge1xyXG5cdFx0bGV0IGluZGV4OiBudW1iZXI7XHJcblx0XHRpZiAodHlwZW9mIHRva2VuT3JJbmRleCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRpbmRleCA9IHRva2VuT3JJbmRleDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGluZGV4ID0gdG9rZW5PckluZGV4LnRva2VuSW5kZXg7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJld3JpdGVzOiBSZXdyaXRlT3BlcmF0aW9uW10gPSB0aGlzLmdldFByb2dyYW0ocHJvZ3JhbU5hbWUpO1xyXG5cdFx0bGV0IG9wOiBSZXdyaXRlT3BlcmF0aW9uID0gbmV3IEluc2VydEJlZm9yZU9wKHRoaXMudG9rZW5zLCBpbmRleCwgcmV3cml0ZXMubGVuZ3RoLCB0ZXh0KTtcclxuXHRcdHJld3JpdGVzLnB1c2gob3ApO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlcGxhY2VTaW5nbGUoaW5kZXg6IG51bWJlciwgdGV4dDoge30pOiB2b2lkO1xyXG5cdHB1YmxpYyByZXBsYWNlU2luZ2xlKGluZGV4VDogVG9rZW4sIHRleHQ6IHt9KTogdm9pZDtcclxuXHRwdWJsaWMgcmVwbGFjZVNpbmdsZShpbmRleDogVG9rZW4gfCBudW1iZXIsIHRleHQ6IHt9KTogdm9pZCB7XHJcblx0XHRpZiAodHlwZW9mIGluZGV4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHRoaXMucmVwbGFjZShpbmRleCwgaW5kZXgsIHRleHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5yZXBsYWNlKGluZGV4LCBpbmRleCwgdGV4dCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVwbGFjZShmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIHRleHQ6IHt9KTogdm9pZDtcclxuXHJcblx0cHVibGljIHJlcGxhY2UoZnJvbTogVG9rZW4sIHRvOiBUb2tlbiwgdGV4dDoge30pOiB2b2lkO1xyXG5cclxuXHRwdWJsaWMgcmVwbGFjZShmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIHRleHQ6IHt9LCBwcm9ncmFtTmFtZTogc3RyaW5nKTogdm9pZDtcclxuXHJcblx0cHVibGljIHJlcGxhY2UoZnJvbTogVG9rZW4sIHRvOiBUb2tlbiwgdGV4dDoge30sIHByb2dyYW1OYW1lOiBzdHJpbmcpOiB2b2lkO1xyXG5cclxuXHRwdWJsaWMgcmVwbGFjZShmcm9tOiBUb2tlbiB8IG51bWJlciwgdG86IFRva2VuIHwgbnVtYmVyLCB0ZXh0OiB7fSwgcHJvZ3JhbU5hbWU6IHN0cmluZyA9IFRva2VuU3RyZWFtUmV3cml0ZXIuREVGQVVMVF9QUk9HUkFNX05BTUUpOiB2b2lkIHtcclxuXHRcdGlmICh0eXBlb2YgZnJvbSAhPT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRmcm9tID0gZnJvbS50b2tlbkluZGV4O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2YgdG8gIT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0dG8gPSB0by50b2tlbkluZGV4O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZnJvbSA+IHRvIHx8IGZyb20gPCAwIHx8IHRvIDwgMCB8fCB0byA+PSB0aGlzLnRva2Vucy5zaXplICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihgcmVwbGFjZTogcmFuZ2UgaW52YWxpZDogJHtmcm9tfS4uJHt0b30oc2l6ZT0ke3RoaXMudG9rZW5zLnNpemV9KWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZXdyaXRlczogUmV3cml0ZU9wZXJhdGlvbltdID0gdGhpcy5nZXRQcm9ncmFtKHByb2dyYW1OYW1lKTtcclxuXHRcdGxldCBvcDogUmV3cml0ZU9wZXJhdGlvbiA9ICBuZXcgUmVwbGFjZU9wKHRoaXMudG9rZW5zLCBmcm9tLCB0bywgcmV3cml0ZXMubGVuZ3RoLCB0ZXh0KTtcclxuXHRcdHJld3JpdGVzLnB1c2gob3ApO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGRlbGV0ZShpbmRleDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0cHVibGljIGRlbGV0ZShmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHRwdWJsaWMgZGVsZXRlKGluZGV4VDogVG9rZW4pOiB2b2lkO1xyXG5cclxuXHRwdWJsaWMgZGVsZXRlKGZyb206IFRva2VuLCB0bzogVG9rZW4pOiB2b2lkO1xyXG5cclxuXHRwdWJsaWMgZGVsZXRlKGZyb206IG51bWJlciwgdG86IG51bWJlciwgcHJvZ3JhbU5hbWU6IHN0cmluZyk6IHZvaWQ7XHJcblxyXG5cdHB1YmxpYyBkZWxldGUoZnJvbTogVG9rZW4sIHRvOiBUb2tlbiwgcHJvZ3JhbU5hbWU6IHN0cmluZyk6IHZvaWQ7XHJcblxyXG5cdHB1YmxpYyBkZWxldGUoZnJvbTogVG9rZW4gfCBudW1iZXIsIHRvPzogVG9rZW4gfCBudW1iZXIsIHByb2dyYW1OYW1lOiBzdHJpbmcgPSBUb2tlblN0cmVhbVJld3JpdGVyLkRFRkFVTFRfUFJPR1JBTV9OQU1FKTogdm9pZCB7XHJcblx0XHRpZiAodG8gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0byA9IGZyb207XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBmcm9tID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHRoaXMucmVwbGFjZShmcm9tLCB0byBhcyBudW1iZXIsIFwiXCIsIHByb2dyYW1OYW1lKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMucmVwbGFjZShmcm9tLCB0byBhcyBUb2tlbiwgXCJcIiwgcHJvZ3JhbU5hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldExhc3RSZXdyaXRlVG9rZW5JbmRleCgpOiBudW1iZXI7XHJcblxyXG5cdHByb3RlY3RlZCBnZXRMYXN0UmV3cml0ZVRva2VuSW5kZXgocHJvZ3JhbU5hbWU6IHN0cmluZyk6IG51bWJlcjtcclxuXHJcblx0cHJvdGVjdGVkIGdldExhc3RSZXdyaXRlVG9rZW5JbmRleChwcm9ncmFtTmFtZTogc3RyaW5nID0gVG9rZW5TdHJlYW1SZXdyaXRlci5ERUZBVUxUX1BST0dSQU1fTkFNRSk6IG51bWJlciB7XHJcblx0XHRsZXQgSTogbnVtYmVyIHwgdW5kZWZpbmVkID0gdGhpcy5sYXN0UmV3cml0ZVRva2VuSW5kZXhlcy5nZXQocHJvZ3JhbU5hbWUpO1xyXG5cdFx0aWYgKCBJID09IG51bGwgKSB7XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gSTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBzZXRMYXN0UmV3cml0ZVRva2VuSW5kZXgocHJvZ3JhbU5hbWU6IHN0cmluZywgaTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLmxhc3RSZXdyaXRlVG9rZW5JbmRleGVzLnNldChwcm9ncmFtTmFtZSwgaSk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZ2V0UHJvZ3JhbShuYW1lOiBzdHJpbmcpOiBSZXdyaXRlT3BlcmF0aW9uW10ge1xyXG5cdFx0bGV0IGlzOiBSZXdyaXRlT3BlcmF0aW9uW10gfCB1bmRlZmluZWQgPSB0aGlzLnByb2dyYW1zLmdldChuYW1lKTtcclxuXHRcdGlmICggaXMgPT0gbnVsbCApIHtcclxuXHRcdFx0aXMgPSB0aGlzLmluaXRpYWxpemVQcm9ncmFtKG5hbWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpcztcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgaW5pdGlhbGl6ZVByb2dyYW0obmFtZTogc3RyaW5nKTogUmV3cml0ZU9wZXJhdGlvbltdIHtcclxuXHRcdGxldCBpczogUmV3cml0ZU9wZXJhdGlvbltdID0gW107XHJcblx0XHR0aGlzLnByb2dyYW1zLnNldChuYW1lLCBpcyk7XHJcblx0XHRyZXR1cm4gaXM7XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIHRoZSB0ZXh0IGZyb20gdGhlIG9yaWdpbmFsIHRva2VucyBhbHRlcmVkIHBlciB0aGVcclxuXHQgKiAgaW5zdHJ1Y3Rpb25zIGdpdmVuIHRvIHRoaXMgcmV3cml0ZXIuXHJcblx0ICovXHJcblx0cHVibGljIGdldFRleHQoKTogc3RyaW5nO1xyXG5cclxuXHQvKiogUmV0dXJuIHRoZSB0ZXh0IGZyb20gdGhlIG9yaWdpbmFsIHRva2VucyBhbHRlcmVkIHBlciB0aGVcclxuXHQgKiAgaW5zdHJ1Y3Rpb25zIGdpdmVuIHRvIHRoaXMgcmV3cml0ZXIgaW4gcHJvZ3JhbU5hbWUuXHJcblx0ICpcclxuXHQgKiBAc2luY2UgNC41XHJcblx0ICovXHJcblx0cHVibGljIGdldFRleHQocHJvZ3JhbU5hbWU6IHN0cmluZyk6IHN0cmluZztcclxuXHJcblx0LyoqIFJldHVybiB0aGUgdGV4dCBhc3NvY2lhdGVkIHdpdGggdGhlIHRva2VucyBpbiB0aGUgaW50ZXJ2YWwgZnJvbSB0aGVcclxuXHQgKiAgb3JpZ2luYWwgdG9rZW4gc3RyZWFtIGJ1dCB3aXRoIHRoZSBhbHRlcmF0aW9ucyBnaXZlbiB0byB0aGlzIHJld3JpdGVyLlxyXG5cdCAqICBUaGUgaW50ZXJ2YWwgcmVmZXJzIHRvIHRoZSBpbmRleGVzIGluIHRoZSBvcmlnaW5hbCB0b2tlbiBzdHJlYW0uXHJcblx0ICogIFdlIGRvIG5vdCBhbHRlciB0aGUgdG9rZW4gc3RyZWFtIGluIGFueSB3YXksIHNvIHRoZSBpbmRleGVzXHJcblx0ICogIGFuZCBpbnRlcnZhbHMgYXJlIHN0aWxsIGNvbnNpc3RlbnQuIEluY2x1ZGVzIGFueSBvcGVyYXRpb25zIGRvbmVcclxuXHQgKiAgdG8gdGhlIGZpcnN0IGFuZCBsYXN0IHRva2VuIGluIHRoZSBpbnRlcnZhbC4gU28sIGlmIHlvdSBkaWQgYW5cclxuXHQgKiAgaW5zZXJ0QmVmb3JlIG9uIHRoZSBmaXJzdCB0b2tlbiwgeW91IHdvdWxkIGdldCB0aGF0IGluc2VydGlvbi5cclxuXHQgKiAgVGhlIHNhbWUgaXMgdHJ1ZSBpZiB5b3UgZG8gYW4gaW5zZXJ0QWZ0ZXIgdGhlIHN0b3AgdG9rZW4uXHJcblx0ICovXHJcblx0cHVibGljIGdldFRleHQoaW50ZXJ2YWw6IEludGVydmFsKTogc3RyaW5nO1xyXG5cclxuXHRwdWJsaWMgZ2V0VGV4dChpbnRlcnZhbDogSW50ZXJ2YWwsIHByb2dyYW1OYW1lOiBzdHJpbmcpOiBzdHJpbmc7XHJcblxyXG5cdHB1YmxpYyBnZXRUZXh0KGludGVydmFsT3JQcm9ncmFtPzogSW50ZXJ2YWwgfCBzdHJpbmcsIHByb2dyYW1OYW1lOiBzdHJpbmcgPSBUb2tlblN0cmVhbVJld3JpdGVyLkRFRkFVTFRfUFJPR1JBTV9OQU1FKTogc3RyaW5nIHtcclxuXHRcdGxldCBpbnRlcnZhbDogSW50ZXJ2YWw7XHJcblx0XHRpZiAoaW50ZXJ2YWxPclByb2dyYW0gaW5zdGFuY2VvZiBJbnRlcnZhbCkge1xyXG5cdFx0XHRpbnRlcnZhbCA9IGludGVydmFsT3JQcm9ncmFtO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW50ZXJ2YWwgPSBJbnRlcnZhbC5vZigwLCB0aGlzLnRva2Vucy5zaXplIC0gMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBpbnRlcnZhbE9yUHJvZ3JhbSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRwcm9ncmFtTmFtZSA9IGludGVydmFsT3JQcm9ncmFtO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZXdyaXRlczogUmV3cml0ZU9wZXJhdGlvbltdIHwgdW5kZWZpbmVkID0gdGhpcy5wcm9ncmFtcy5nZXQocHJvZ3JhbU5hbWUpO1xyXG5cdFx0bGV0IHN0YXJ0OiBudW1iZXIgPSAgaW50ZXJ2YWwuYTtcclxuXHRcdGxldCBzdG9wOiBudW1iZXIgPSAgaW50ZXJ2YWwuYjtcclxuXHJcblx0XHQvLyBlbnN1cmUgc3RhcnQvZW5kIGFyZSBpbiByYW5nZVxyXG5cdFx0aWYgKCBzdG9wID4gdGhpcy50b2tlbnMuc2l6ZSAtIDEgKSB7XHJcblx0XHRcdHN0b3AgPSB0aGlzLnRva2Vucy5zaXplIC0gMTtcclxuXHRcdH1cclxuXHRcdGlmICggc3RhcnQgPCAwICkge1xyXG5cdFx0XHRzdGFydCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCByZXdyaXRlcyA9PSBudWxsIHx8IHJld3JpdGVzLmxlbmd0aCA9PT0gMCApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9rZW5zLmdldFRleHQoaW50ZXJ2YWwpOyAvLyBubyBpbnN0cnVjdGlvbnMgdG8gZXhlY3V0ZVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBidWY6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0Ly8gRmlyc3QsIG9wdGltaXplIGluc3RydWN0aW9uIHN0cmVhbVxyXG5cdFx0bGV0IGluZGV4VG9PcDogTWFwPG51bWJlciwgUmV3cml0ZU9wZXJhdGlvbj4gPSB0aGlzLnJlZHVjZVRvU2luZ2xlT3BlcmF0aW9uUGVySW5kZXgocmV3cml0ZXMpO1xyXG5cclxuXHRcdC8vIFdhbGsgYnVmZmVyLCBleGVjdXRpbmcgaW5zdHJ1Y3Rpb25zIGFuZCBlbWl0dGluZyB0b2tlbnNcclxuXHRcdGxldCBpOiBudW1iZXIgPSAgc3RhcnQ7XHJcblx0XHR3aGlsZSAoIGkgPD0gc3RvcCAmJiBpIDwgdGhpcy50b2tlbnMuc2l6ZSApIHtcclxuXHRcdFx0bGV0IG9wOiBSZXdyaXRlT3BlcmF0aW9uIHwgdW5kZWZpbmVkID0gIGluZGV4VG9PcC5nZXQoaSk7XHJcblx0XHRcdGluZGV4VG9PcC5kZWxldGUoaSk7IC8vIHJlbW92ZSBzbyBhbnkgbGVmdCBoYXZlIGluZGV4IHNpemUtMVxyXG5cdFx0XHRsZXQgdDogVG9rZW4gPSB0aGlzLnRva2Vucy5nZXQoaSk7XHJcblx0XHRcdGlmICggb3AgPT0gbnVsbCApIHtcclxuXHRcdFx0XHQvLyBubyBvcGVyYXRpb24gYXQgdGhhdCBpbmRleCwganVzdCBkdW1wIHRva2VuXHJcblx0XHRcdFx0aWYgKCB0LnR5cGUgIT09IFRva2VuLkVPRiApIHtcclxuXHRcdFx0XHRcdGJ1Zi5wdXNoKFN0cmluZyh0LnRleHQpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSsrOyAvLyBtb3ZlIHRvIG5leHQgdG9rZW5cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRpID0gb3AuZXhlY3V0ZShidWYpOyAvLyBleGVjdXRlIG9wZXJhdGlvbiBhbmQgc2tpcFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaW5jbHVkZSBzdHVmZiBhZnRlciBlbmQgaWYgaXQncyBsYXN0IGluZGV4IGluIGJ1ZmZlclxyXG5cdFx0Ly8gU28sIGlmIHRoZXkgZGlkIGFuIGluc2VydEFmdGVyKGxhc3RWYWxpZEluZGV4LCBcImZvb1wiKSwgaW5jbHVkZVxyXG5cdFx0Ly8gZm9vIGlmIGVuZD09bGFzdFZhbGlkSW5kZXguXHJcblx0XHRpZiAoIHN0b3AgPT09IHRoaXMudG9rZW5zLnNpemUgLSAxICkge1xyXG5cdFx0XHQvLyBTY2FuIGFueSByZW1haW5pbmcgb3BlcmF0aW9ucyBhZnRlciBsYXN0IHRva2VuXHJcblx0XHRcdC8vIHNob3VsZCBiZSBpbmNsdWRlZCAodGhleSB3aWxsIGJlIGluc2VydHMpLlxyXG5cdFx0XHRmb3IgKGxldCBvcCBvZiBpbmRleFRvT3AudmFsdWVzKCkpIHtcclxuXHRcdFx0XHRpZiAoIG9wLmluZGV4ID49IHRoaXMudG9rZW5zLnNpemUgLSAxICkge1xyXG5cdFx0XHRcdFx0YnVmLnB1c2gob3AudGV4dC50b1N0cmluZygpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYnVmLmpvaW4oXCJcIik7XHJcblx0fVxyXG5cclxuXHQvKiogV2UgbmVlZCB0byBjb21iaW5lIG9wZXJhdGlvbnMgYW5kIHJlcG9ydCBpbnZhbGlkIG9wZXJhdGlvbnMgKGxpa2VcclxuXHQgKiAgb3ZlcmxhcHBpbmcgcmVwbGFjZXMgdGhhdCBhcmUgbm90IGNvbXBsZXRlZCBuZXN0ZWQpLiBJbnNlcnRzIHRvXHJcblx0ICogIHNhbWUgaW5kZXggbmVlZCB0byBiZSBjb21iaW5lZCBldGMuLi4gIEhlcmUgYXJlIHRoZSBjYXNlczpcclxuXHQgKlxyXG5cdCAqICBJLmkudSBJLmoudlx0XHRcdFx0XHRcdFx0XHRsZWF2ZSBhbG9uZSwgbm9ub3ZlcmxhcHBpbmdcclxuXHQgKiAgSS5pLnUgSS5pLnZcdFx0XHRcdFx0XHRcdFx0Y29tYmluZTogSWl2dVxyXG5cdCAqXHJcblx0ICogIFIuaS1qLnUgUi54LXkudlx0fCBpLWogaW4geC15XHRcdFx0ZGVsZXRlIGZpcnN0IFJcclxuXHQgKiAgUi5pLWoudSBSLmktai52XHRcdFx0XHRcdFx0XHRkZWxldGUgZmlyc3QgUlxyXG5cdCAqICBSLmktai51IFIueC15LnZcdHwgeC15IGluIGktalx0XHRcdEVSUk9SXHJcblx0ICogIFIuaS1qLnUgUi54LXkudlx0fCBib3VuZGFyaWVzIG92ZXJsYXBcdEVSUk9SXHJcblx0ICpcclxuXHQgKiAgRGVsZXRlIHNwZWNpYWwgY2FzZSBvZiByZXBsYWNlICh0ZXh0PT11bmRlZmluZWQpOlxyXG5cdCAqICBELmktai51IEQueC15LnZcdHwgYm91bmRhcmllcyBvdmVybGFwXHRjb21iaW5lIHRvIG1heChtaW4pLi5tYXgocmlnaHQpXHJcblx0ICpcclxuXHQgKiAgSS5pLnUgUi54LXkudiB8IGkgaW4gKHgrMSkteVx0XHRcdGRlbGV0ZSBJIChzaW5jZSBpbnNlcnQgYmVmb3JlXHJcblx0ICogXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdlJ3JlIG5vdCBkZWxldGluZyBpKVxyXG5cdCAqICBJLmkudSBSLngteS52IHwgaSBub3QgaW4gKHgrMSkteVx0XHRsZWF2ZSBhbG9uZSwgbm9ub3ZlcmxhcHBpbmdcclxuXHQgKiAgUi54LXkudiBJLmkudSB8IGkgaW4geC15XHRcdFx0XHRFUlJPUlxyXG5cdCAqICBSLngteS52IEkueC51IFx0XHRcdFx0XHRcdFx0Ui54LXkudXYgKGNvbWJpbmUsIGRlbGV0ZSBJKVxyXG5cdCAqICBSLngteS52IEkuaS51IHwgaSBub3QgaW4geC15XHRcdFx0bGVhdmUgYWxvbmUsIG5vbm92ZXJsYXBwaW5nXHJcblx0ICpcclxuXHQgKiAgSS5pLnUgPSBpbnNlcnQgdSBiZWZvcmUgb3AgQCBpbmRleCBpXHJcblx0ICogIFIueC15LnUgPSByZXBsYWNlIHgteSBpbmRleGVkIHRva2VucyB3aXRoIHVcclxuXHQgKlxyXG5cdCAqICBGaXJzdCB3ZSBuZWVkIHRvIGV4YW1pbmUgcmVwbGFjZXMuIEZvciBhbnkgcmVwbGFjZSBvcDpcclxuXHQgKlxyXG5cdCAqIFx0XHQxLiB3aXBlIG91dCBhbnkgaW5zZXJ0aW9ucyBiZWZvcmUgb3Agd2l0aGluIHRoYXQgcmFuZ2UuXHJcblx0ICogXHRcdDIuIERyb3AgYW55IHJlcGxhY2Ugb3AgYmVmb3JlIHRoYXQgaXMgY29udGFpbmVkIGNvbXBsZXRlbHkgd2l0aGluXHJcblx0ICogXHQgdGhhdCByYW5nZS5cclxuXHQgKiBcdFx0My4gVGhyb3cgZXhjZXB0aW9uIHVwb24gYm91bmRhcnkgb3ZlcmxhcCB3aXRoIGFueSBwcmV2aW91cyByZXBsYWNlLlxyXG5cdCAqXHJcblx0ICogIFRoZW4gd2UgY2FuIGRlYWwgd2l0aCBpbnNlcnRzOlxyXG5cdCAqXHJcblx0ICogXHRcdDEuIGZvciBhbnkgaW5zZXJ0cyB0byBzYW1lIGluZGV4LCBjb21iaW5lIGV2ZW4gaWYgbm90IGFkamFjZW50LlxyXG5cdCAqIFx0XHQyLiBmb3IgYW55IHByaW9yIHJlcGxhY2Ugd2l0aCBzYW1lIGxlZnQgYm91bmRhcnksIGNvbWJpbmUgdGhpc1xyXG5cdCAqIFx0IGluc2VydCB3aXRoIHJlcGxhY2UgYW5kIGRlbGV0ZSB0aGlzIHJlcGxhY2UuXHJcblx0ICogXHRcdDMuIHRocm93IGV4Y2VwdGlvbiBpZiBpbmRleCBpbiBzYW1lIHJhbmdlIGFzIHByZXZpb3VzIHJlcGxhY2VcclxuXHQgKlxyXG5cdCAqICBEb24ndCBhY3R1YWxseSBkZWxldGU7IG1ha2Ugb3AgdW5kZWZpbmVkIGluIGxpc3QuIEVhc2llciB0byB3YWxrIGxpc3QuXHJcblx0ICogIExhdGVyIHdlIGNhbiB0aHJvdyBhcyB3ZSBhZGQgdG8gaW5kZXggJnJhcnI7IG9wIG1hcC5cclxuXHQgKlxyXG5cdCAqICBOb3RlIHRoYXQgSS4yIFIuMi0yIHdpbGwgd2lwZSBvdXQgSS4yIGV2ZW4gdGhvdWdoLCB0ZWNobmljYWxseSwgdGhlXHJcblx0ICogIGluc2VydGVkIHN0dWZmIHdvdWxkIGJlIGJlZm9yZSB0aGUgcmVwbGFjZSByYW5nZS4gQnV0LCBpZiB5b3VcclxuXHQgKiAgYWRkIHRva2VucyBpbiBmcm9udCBvZiBhIG1ldGhvZCBib2R5ICd7JyBhbmQgdGhlbiBkZWxldGUgdGhlIG1ldGhvZFxyXG5cdCAqICBib2R5LCBJIHRoaW5rIHRoZSBzdHVmZiBiZWZvcmUgdGhlICd7JyB5b3UgYWRkZWQgc2hvdWxkIGRpc2FwcGVhciB0b28uXHJcblx0ICpcclxuXHQgKiAgUmV0dXJuIGEgbWFwIGZyb20gdG9rZW4gaW5kZXggdG8gb3BlcmF0aW9uLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCByZWR1Y2VUb1NpbmdsZU9wZXJhdGlvblBlckluZGV4KHJld3JpdGVzOiBBcnJheTxSZXdyaXRlT3BlcmF0aW9uIHwgdW5kZWZpbmVkPik6IE1hcDxudW1iZXIsIFJld3JpdGVPcGVyYXRpb24+IHtcclxuXHRcdC8vIGNvbnNvbGUubG9nKGByZXdyaXRlcz1bJHtVdGlscy5qb2luKHJld3JpdGVzLCBcIiwgXCIpfV1gKTtcclxuXHJcblx0XHQvLyBXQUxLIFJFUExBQ0VTXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJld3JpdGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBvcDogUmV3cml0ZU9wZXJhdGlvbiB8IHVuZGVmaW5lZCA9IHJld3JpdGVzW2ldO1xyXG5cdFx0XHRpZiAoIG9wID09IG51bGwgKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCAhKG9wIGluc3RhbmNlb2YgUmVwbGFjZU9wKSApIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgcm9wOiBSZXBsYWNlT3AgPSBvcDtcclxuXHRcdFx0Ly8gV2lwZSBwcmlvciBpbnNlcnRzIHdpdGhpbiByYW5nZVxyXG5cdFx0XHRsZXQgaW5zZXJ0czogSW5zZXJ0QmVmb3JlT3BbXSA9IHRoaXMuZ2V0S2luZE9mT3BzKHJld3JpdGVzLCBJbnNlcnRCZWZvcmVPcCwgaSk7XHJcblx0XHRcdGZvciAobGV0IGlvcCBvZiBpbnNlcnRzKSB7XHJcblx0XHRcdFx0aWYgKCBpb3AuaW5kZXggPT09IHJvcC5pbmRleCApIHtcclxuXHRcdFx0XHRcdC8vIEUuZy4sIGluc2VydCBiZWZvcmUgMiwgZGVsZXRlIDIuLjI7IHVwZGF0ZSByZXBsYWNlXHJcblx0XHRcdFx0XHQvLyB0ZXh0IHRvIGluY2x1ZGUgaW5zZXJ0IGJlZm9yZSwga2lsbCBpbnNlcnRcclxuXHRcdFx0XHRcdHJld3JpdGVzW2lvcC5pbnN0cnVjdGlvbkluZGV4XSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdHJvcC50ZXh0ID0gaW9wLnRleHQudG9TdHJpbmcoKSArIChyb3AudGV4dCAhPSBudWxsID8gcm9wLnRleHQudG9TdHJpbmcoKSA6IFwiXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmICggaW9wLmluZGV4ID4gcm9wLmluZGV4ICYmIGlvcC5pbmRleCA8PSByb3AubGFzdEluZGV4ICkge1xyXG5cdFx0XHRcdFx0Ly8gZGVsZXRlIGluc2VydCBhcyBpdCdzIGEgbm8tb3AuXHJcblx0XHRcdFx0XHRyZXdyaXRlc1tpb3AuaW5zdHJ1Y3Rpb25JbmRleF0gPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIERyb3AgYW55IHByaW9yIHJlcGxhY2VzIGNvbnRhaW5lZCB3aXRoaW5cclxuXHRcdFx0bGV0IHByZXZSZXBsYWNlczogUmVwbGFjZU9wW10gPSB0aGlzLmdldEtpbmRPZk9wcyhyZXdyaXRlcywgUmVwbGFjZU9wLCBpKTtcclxuXHRcdFx0Zm9yIChsZXQgcHJldlJvcCBvZiBwcmV2UmVwbGFjZXMpIHtcclxuXHRcdFx0XHRpZiAoIHByZXZSb3AuaW5kZXggPj0gcm9wLmluZGV4ICYmIHByZXZSb3AubGFzdEluZGV4IDw9IHJvcC5sYXN0SW5kZXggKSB7XHJcblx0XHRcdFx0XHQvLyBkZWxldGUgcmVwbGFjZSBhcyBpdCdzIGEgbm8tb3AuXHJcblx0XHRcdFx0XHRyZXdyaXRlc1twcmV2Um9wLmluc3RydWN0aW9uSW5kZXhdID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHRocm93IGV4Y2VwdGlvbiB1bmxlc3MgZGlzam9pbnQgb3IgaWRlbnRpY2FsXHJcblx0XHRcdFx0bGV0IGRpc2pvaW50OiBib29sZWFuID1cclxuXHRcdFx0XHRcdHByZXZSb3AubGFzdEluZGV4IDwgcm9wLmluZGV4IHx8IHByZXZSb3AuaW5kZXggPiByb3AubGFzdEluZGV4O1xyXG5cdFx0XHRcdC8vIERlbGV0ZSBzcGVjaWFsIGNhc2Ugb2YgcmVwbGFjZSAodGV4dD09bnVsbCk6XHJcblx0XHRcdFx0Ly8gRC5pLWoudSBELngteS52XHR8IGJvdW5kYXJpZXMgb3ZlcmxhcFx0Y29tYmluZSB0byBtYXgobWluKS4ubWF4KHJpZ2h0KVxyXG5cdFx0XHRcdGlmICggcHJldlJvcC50ZXh0ID09IG51bGwgJiYgcm9wLnRleHQgPT0gbnVsbCAmJiAhZGlzam9pbnQgKSB7XHJcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhgb3ZlcmxhcHBpbmcgZGVsZXRlczogJHtwcmV2Um9wfSwgJHtyb3B9YCk7XHJcblx0XHRcdFx0XHRyZXdyaXRlc1twcmV2Um9wLmluc3RydWN0aW9uSW5kZXhdID0gdW5kZWZpbmVkOyAvLyBraWxsIGZpcnN0IGRlbGV0ZVxyXG5cdFx0XHRcdFx0cm9wLmluZGV4ID0gTWF0aC5taW4ocHJldlJvcC5pbmRleCwgcm9wLmluZGV4KTtcclxuXHRcdFx0XHRcdHJvcC5sYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Um9wLmxhc3RJbmRleCwgcm9wLmxhc3RJbmRleCk7XHJcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhgbmV3IHJvcCAke3JvcH1gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoICFkaXNqb2ludCApIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgcmVwbGFjZSBvcCBib3VuZGFyaWVzIG9mICR7cm9wfSBvdmVybGFwIHdpdGggcHJldmlvdXMgJHtwcmV2Um9wfWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFdBTEsgSU5TRVJUU1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZXdyaXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgb3A6IFJld3JpdGVPcGVyYXRpb24gfCB1bmRlZmluZWQgPSByZXdyaXRlc1tpXTtcclxuXHRcdFx0aWYgKCBvcCA9PSBudWxsICkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICggIShvcCBpbnN0YW5jZW9mIEluc2VydEJlZm9yZU9wKSApIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgaW9wOiBJbnNlcnRCZWZvcmVPcCA9ICBvcDtcclxuXHRcdFx0Ly8gY29tYmluZSBjdXJyZW50IGluc2VydCB3aXRoIHByaW9yIGlmIGFueSBhdCBzYW1lIGluZGV4XHJcblx0XHRcdGxldCBwcmV2SW5zZXJ0czogSW5zZXJ0QmVmb3JlT3BbXSA9IHRoaXMuZ2V0S2luZE9mT3BzKHJld3JpdGVzLCBJbnNlcnRCZWZvcmVPcCwgaSk7XHJcblx0XHRcdGZvciAobGV0IHByZXZJb3Agb2YgcHJldkluc2VydHMpIHtcclxuXHRcdFx0XHRpZiAoIHByZXZJb3AuaW5kZXggPT09IGlvcC5pbmRleCApIHtcclxuXHRcdFx0XHRcdGlmIChwcmV2SW9wIGluc3RhbmNlb2YgSW5zZXJ0QWZ0ZXJPcCkge1xyXG5cdFx0XHRcdFx0XHRpb3AudGV4dCA9IHRoaXMuY2F0T3BUZXh0KHByZXZJb3AudGV4dCwgaW9wLnRleHQpO1xyXG5cdFx0XHRcdFx0XHRyZXdyaXRlc1twcmV2SW9wLmluc3RydWN0aW9uSW5kZXhdID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAocHJldklvcCBpbnN0YW5jZW9mIEluc2VydEJlZm9yZU9wKSB7IC8vIGNvbWJpbmUgb2JqZWN0c1xyXG5cdFx0XHRcdFx0XHQvLyBjb252ZXJ0IHRvIHN0cmluZ3MuLi53ZSdyZSBpbiBwcm9jZXNzIG9mIHRvU3RyaW5nJ2luZ1xyXG5cdFx0XHRcdFx0XHQvLyB3aG9sZSB0b2tlbiBidWZmZXIgc28gbm8gbGF6eSBldmFsIGlzc3VlIHdpdGggYW55IHRlbXBsYXRlc1xyXG5cdFx0XHRcdFx0XHRpb3AudGV4dCA9IHRoaXMuY2F0T3BUZXh0KGlvcC50ZXh0LCBwcmV2SW9wLnRleHQpO1xyXG5cdFx0XHRcdFx0XHQvLyBkZWxldGUgcmVkdW5kYW50IHByaW9yIGluc2VydFxyXG5cdFx0XHRcdFx0XHRyZXdyaXRlc1twcmV2SW9wLmluc3RydWN0aW9uSW5kZXhdID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBsb29rIGZvciByZXBsYWNlcyB3aGVyZSBpb3AuaW5kZXggaXMgaW4gcmFuZ2U7IGVycm9yXHJcblx0XHRcdGxldCBwcmV2UmVwbGFjZXM6IFJlcGxhY2VPcFtdID0gdGhpcy5nZXRLaW5kT2ZPcHMocmV3cml0ZXMsIFJlcGxhY2VPcCwgaSk7XHJcblx0XHRcdGZvciAobGV0IHJvcCBvZiBwcmV2UmVwbGFjZXMpIHtcclxuXHRcdFx0XHRpZiAoIGlvcC5pbmRleCA9PT0gcm9wLmluZGV4ICkge1xyXG5cdFx0XHRcdFx0cm9wLnRleHQgPSB0aGlzLmNhdE9wVGV4dChpb3AudGV4dCwgcm9wLnRleHQpO1xyXG5cdFx0XHRcdFx0cmV3cml0ZXNbaV0gPSB1bmRlZmluZWQ7XHQvLyBkZWxldGUgY3VycmVudCBpbnNlcnRcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIGlvcC5pbmRleCA+PSByb3AuaW5kZXggJiYgaW9wLmluZGV4IDw9IHJvcC5sYXN0SW5kZXggKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGluc2VydCBvcCAke2lvcH0gd2l0aGluIGJvdW5kYXJpZXMgb2YgcHJldmlvdXMgJHtyb3B9YCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyBjb25zb2xlLmxvZyhgcmV3cml0ZXMgYWZ0ZXI9WyR7VXRpbHMuam9pbihyZXdyaXRlcywgXCIsIFwiKX1dYCk7XHJcblx0XHRsZXQgbTogTWFwPG51bWJlciwgUmV3cml0ZU9wZXJhdGlvbj4gPSAgbmV3IE1hcDxudW1iZXIsIFJld3JpdGVPcGVyYXRpb24+KCk7XHJcblx0XHRmb3IgKGxldCBvcCBvZiByZXdyaXRlcykge1xyXG5cdFx0XHRpZiAoIG9wID09IG51bGwgKSB7XHJcblx0XHRcdFx0Ly8gaWdub3JlIGRlbGV0ZWQgb3BzXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCBtLmdldChvcC5pbmRleCkgIT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGQgb25seSBiZSBvbmUgb3AgcGVyIGluZGV4XCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG0uc2V0KG9wLmluZGV4LCBvcCk7XHJcblx0XHR9XHJcblx0XHQvLyBjb25zb2xlLmxvZyhgaW5kZXggdG8gb3A6ICR7bX1gKTtcclxuXHRcdHJldHVybiBtO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGNhdE9wVGV4dChhOiB7fSwgYjoge30pOiBzdHJpbmcge1xyXG5cdFx0bGV0IHg6IHN0cmluZyA9ICBcIlwiO1xyXG5cdFx0bGV0IHk6IHN0cmluZyA9ICBcIlwiO1xyXG5cdFx0aWYgKCBhICE9IG51bGwgKSB7XHJcblx0XHRcdHggPSBhLnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblx0XHRpZiAoIGIgIT0gbnVsbCApIHtcclxuXHRcdFx0eSA9IGIudG9TdHJpbmcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB4ICsgeTtcclxuXHR9XHJcblxyXG5cdC8qKiBHZXQgYWxsIG9wZXJhdGlvbnMgYmVmb3JlIGFuIGluZGV4IG9mIGEgcGFydGljdWxhciBraW5kICovXHJcblx0cHJvdGVjdGVkIGdldEtpbmRPZk9wczxUIGV4dGVuZHMgUmV3cml0ZU9wZXJhdGlvbj4ocmV3cml0ZXM6IEFycmF5PFJld3JpdGVPcGVyYXRpb24gfCB1bmRlZmluZWQ+LCBraW5kOiB7bmV3KC4uLmFyZ3M6IGFueVtdKTogVH0sIGJlZm9yZTogbnVtYmVyKTogVFtdIHtcclxuXHRcdGxldCBvcHM6IFRbXSA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiZWZvcmUgJiYgaSA8IHJld3JpdGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBvcDogUmV3cml0ZU9wZXJhdGlvbiB8IHVuZGVmaW5lZCA9ICByZXdyaXRlc1tpXTtcclxuXHRcdFx0aWYgKCBvcCA9PSBudWxsICkge1xyXG5cdFx0XHRcdC8vIGlnbm9yZSBkZWxldGVkXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCBvcCBpbnN0YW5jZW9mIGtpbmQgKSB7XHJcblx0XHRcdFx0b3BzLnB1c2gob3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb3BzO1xyXG5cdH1cclxufVxyXG5cclxuLy8gRGVmaW5lIHRoZSByZXdyaXRlIG9wZXJhdGlvbiBoaWVyYXJjaHlcclxuXHJcbmV4cG9ydCBjbGFzcyBSZXdyaXRlT3BlcmF0aW9uIHtcclxuXHRwcm90ZWN0ZWQgcmVhZG9ubHkgdG9rZW5zOiBUb2tlblN0cmVhbTtcclxuXHQvKiogV2hhdCBpbmRleCBpbnRvIHJld3JpdGVzIExpc3QgYXJlIHdlPyAqL1xyXG5cdHB1YmxpYyByZWFkb25seSBpbnN0cnVjdGlvbkluZGV4OiBudW1iZXI7XHJcblx0LyoqIFRva2VuIGJ1ZmZlciBpbmRleC4gKi9cclxuXHRwdWJsaWMgaW5kZXg6IG51bWJlcjtcclxuXHRwdWJsaWMgdGV4dDoge307XHJcblxyXG5cdGNvbnN0cnVjdG9yKHRva2VuczogVG9rZW5TdHJlYW0sIGluZGV4OiBudW1iZXIsIGluc3RydWN0aW9uSW5kZXg6IG51bWJlcik7XHJcblx0Y29uc3RydWN0b3IodG9rZW5zOiBUb2tlblN0cmVhbSwgaW5kZXg6IG51bWJlciwgaW5zdHJ1Y3Rpb25JbmRleDogbnVtYmVyLCB0ZXh0OiB7fSk7XHJcblx0Y29uc3RydWN0b3IodG9rZW5zOiBUb2tlblN0cmVhbSwgaW5kZXg6IG51bWJlciwgaW5zdHJ1Y3Rpb25JbmRleDogbnVtYmVyLCB0ZXh0Pzoge30pIHtcclxuXHRcdHRoaXMudG9rZW5zID0gdG9rZW5zO1xyXG5cdFx0dGhpcy5pbnN0cnVjdGlvbkluZGV4ID0gaW5zdHJ1Y3Rpb25JbmRleDtcclxuXHRcdHRoaXMuaW5kZXggPSBpbmRleDtcclxuXHRcdHRoaXMudGV4dCA9IHRleHQgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiB0ZXh0O1xyXG5cdH1cclxuXHJcblx0LyoqIEV4ZWN1dGUgdGhlIHJld3JpdGUgb3BlcmF0aW9uIGJ5IHBvc3NpYmx5IGFkZGluZyB0byB0aGUgYnVmZmVyLlxyXG5cdCAqICBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBuZXh0IHRva2VuIHRvIG9wZXJhdGUgb24uXHJcblx0ICovXHJcblx0cHVibGljIGV4ZWN1dGUoYnVmOiBzdHJpbmdbXSk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbmRleDtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0bGV0IG9wTmFtZTogc3RyaW5nID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG5cdFx0bGV0ICRpbmRleCA9IG9wTmFtZS5pbmRleE9mKFwiJFwiKTtcclxuXHRcdG9wTmFtZSA9IG9wTmFtZS5zdWJzdHJpbmcoJGluZGV4ICsgMSwgb3BOYW1lLmxlbmd0aCk7XHJcblx0XHRyZXR1cm4gXCI8XCIgKyBvcE5hbWUgKyBcIkBcIiArIHRoaXMudG9rZW5zLmdldCh0aGlzLmluZGV4KSArXHJcblx0XHRcdFx0XCI6XFxcIlwiICsgdGhpcy50ZXh0ICsgXCJcXFwiPlwiO1xyXG5cdH1cclxufVxyXG5cclxuY2xhc3MgSW5zZXJ0QmVmb3JlT3AgZXh0ZW5kcyBSZXdyaXRlT3BlcmF0aW9uIHtcclxuXHRjb25zdHJ1Y3Rvcih0b2tlbnM6IFRva2VuU3RyZWFtLCBpbmRleDogbnVtYmVyLCBpbnN0cnVjdGlvbkluZGV4OiBudW1iZXIsIHRleHQ6IHt9KSB7XHJcblx0XHRzdXBlcih0b2tlbnMsIGluZGV4LCBpbnN0cnVjdGlvbkluZGV4LCB0ZXh0KTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBleGVjdXRlKGJ1Zjogc3RyaW5nW10pOiBudW1iZXIge1xyXG5cdFx0YnVmLnB1c2godGhpcy50ZXh0LnRvU3RyaW5nKCkpO1xyXG5cdFx0aWYgKCB0aGlzLnRva2Vucy5nZXQodGhpcy5pbmRleCkudHlwZSAhPT0gVG9rZW4uRU9GICkge1xyXG5cdFx0XHRidWYucHVzaChTdHJpbmcodGhpcy50b2tlbnMuZ2V0KHRoaXMuaW5kZXgpLnRleHQpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmluZGV4ICsgMTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKiBEaXN0aW5ndWlzaCBiZXR3ZWVuIGluc2VydCBhZnRlci9iZWZvcmUgdG8gZG8gdGhlIFwiaW5zZXJ0IGFmdGVyc1wiXHJcbiAqICBmaXJzdCBhbmQgdGhlbiB0aGUgXCJpbnNlcnQgYmVmb3Jlc1wiIGF0IHNhbWUgaW5kZXguIEltcGxlbWVudGF0aW9uXHJcbiAqICBvZiBcImluc2VydCBhZnRlclwiIGlzIFwiaW5zZXJ0IGJlZm9yZSBpbmRleCsxXCIuXHJcbiAqL1xyXG5jbGFzcyBJbnNlcnRBZnRlck9wIGV4dGVuZHMgSW5zZXJ0QmVmb3JlT3Age1xyXG5cdGNvbnN0cnVjdG9yKHRva2VuczogVG9rZW5TdHJlYW0sIGluZGV4OiBudW1iZXIsIGluc3RydWN0aW9uSW5kZXg6IG51bWJlciwgdGV4dDoge30pIHtcclxuXHRcdHN1cGVyKHRva2VucywgaW5kZXggKyAxLCBpbnN0cnVjdGlvbkluZGV4LCB0ZXh0KTsgLy8gaW5zZXJ0IGFmdGVyIGlzIGluc2VydCBiZWZvcmUgaW5kZXgrMVxyXG5cdH1cclxufVxyXG5cclxuLyoqIEknbSBnb2luZyB0byB0cnkgcmVwbGFjaW5nIHJhbmdlIGZyb20geC4ueSB3aXRoICh5LXgpKzEgUmVwbGFjZU9wXHJcbiAqICBpbnN0cnVjdGlvbnMuXHJcbiAqL1xyXG5jbGFzcyBSZXBsYWNlT3AgZXh0ZW5kcyBSZXdyaXRlT3BlcmF0aW9uIHtcclxuXHRwdWJsaWMgbGFzdEluZGV4OiBudW1iZXI7XHJcblx0Y29uc3RydWN0b3IodG9rZW5zOiBUb2tlblN0cmVhbSwgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCBpbnN0cnVjdGlvbkluZGV4OiBudW1iZXIsIHRleHQ6IHt9KSB7XHJcblx0XHRzdXBlcih0b2tlbnMsIGZyb20sIGluc3RydWN0aW9uSW5kZXgsIHRleHQpO1xyXG5cdFx0dGhpcy5sYXN0SW5kZXggPSB0bztcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyBleGVjdXRlKGJ1Zjogc3RyaW5nW10pOiBudW1iZXIge1xyXG5cdFx0aWYgKCB0aGlzLnRleHQgIT0gbnVsbCApIHtcclxuXHRcdFx0YnVmLnB1c2godGhpcy50ZXh0LnRvU3RyaW5nKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGFzdEluZGV4ICsgMTtcclxuXHR9XHJcblxyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0aWYgKCB0aGlzLnRleHQgPT0gbnVsbCApIHtcclxuXHRcdFx0cmV0dXJuIFwiPERlbGV0ZU9wQFwiICsgdGhpcy50b2tlbnMuZ2V0KHRoaXMuaW5kZXgpICtcclxuXHRcdFx0XHRcdFwiLi5cIiArIHRoaXMudG9rZW5zLmdldCh0aGlzLmxhc3RJbmRleCkgKyBcIj5cIjtcclxuXHRcdH1cclxuXHRcdHJldHVybiBcIjxSZXBsYWNlT3BAXCIgKyB0aGlzLnRva2Vucy5nZXQodGhpcy5pbmRleCkgK1xyXG5cdFx0XHRcdFwiLi5cIiArIHRoaXMudG9rZW5zLmdldCh0aGlzLmxhc3RJbmRleCkgKyBcIjpcXFwiXCIgKyB0aGlzLnRleHQgKyBcIlxcXCI+XCI7XHJcblx0fVxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1OS40OTg2NjEwLTA3OjAwXHJcblxyXG4vKipcclxuICogVGhpcyBpbnRlcmZhY2UgcHJvdmlkZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZvY2FidWxhcnkgdXNlZCBieSBhXHJcbiAqIHJlY29nbml6ZXIuXHJcbiAqXHJcbiAqIEBzZWUgUmVjb2duaXplci52b2NhYnVsYXJ5XHJcbiAqIEBhdXRob3IgU2FtIEhhcndlbGxcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVm9jYWJ1bGFyeSB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGhpZ2hlc3QgdG9rZW4gdHlwZSB2YWx1ZS4gSXQgY2FuIGJlIHVzZWQgdG8gaXRlcmF0ZSBmcm9tXHJcblx0ICogemVybyB0byB0aGF0IG51bWJlciwgaW5jbHVzaXZlbHksIHRodXMgcXVlcnlpbmcgYWxsIHN0b3JlZCBlbnRyaWVzLlxyXG5cdCAqIEByZXR1cm5zIHRoZSBoaWdoZXN0IHRva2VuIHR5cGUgdmFsdWVcclxuXHQgKi9cclxuXHRyZWFkb25seSBtYXhUb2tlblR5cGU6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgc3RyaW5nIGxpdGVyYWwgYXNzb2NpYXRlZCB3aXRoIGEgdG9rZW4gdHlwZS4gVGhlIHN0cmluZyByZXR1cm5lZFxyXG5cdCAqIGJ5IHRoaXMgbWV0aG9kLCB3aGVuIG5vdCBgdW5kZWZpbmVkYCwgY2FuIGJlIHVzZWQgdW5hbHRlcmVkIGluIGEgcGFyc2VyXHJcblx0ICogZ3JhbW1hciB0byByZXByZXNlbnQgdGhpcyB0b2tlbiB0eXBlLlxyXG5cdCAqXHJcblx0ICogVGhlIGZvbGxvd2luZyB0YWJsZSBzaG93cyBleGFtcGxlcyBvZiBsZXhlciBydWxlcyBhbmQgdGhlIGxpdGVyYWxcclxuXHQgKiBuYW1lcyBhc3NpZ25lZCB0byB0aGUgY29ycmVzcG9uZGluZyB0b2tlbiB0eXBlcy5cclxuXHQgKlxyXG5cdCAqIDx0YWJsZT5cclxuXHQgKiAgPHRyPlxyXG5cdCAqICAgPHRoPlJ1bGU8L3RoPlxyXG5cdCAqICAgPHRoPkxpdGVyYWwgTmFtZTwvdGg+XHJcblx0ICogICA8dGg+SmF2YSBTdHJpbmcgTGl0ZXJhbDwvdGg+XHJcblx0ICogIDwvdHI+XHJcblx0ICogIDx0cj5cclxuXHQgKiAgIDx0ZD5gVEhJUyA6ICd0aGlzJztgPC90ZD5cclxuXHQgKiAgIDx0ZD5gJ3RoaXMnYDwvdGQ+XHJcblx0ICogICA8dGQ+YFwiJ3RoaXMnXCJgPC90ZD5cclxuXHQgKiAgPC90cj5cclxuXHQgKiAgPHRyPlxyXG5cdCAqICAgPHRkPmBTUVVPVEUgOiAnXFwnJztgPC90ZD5cclxuXHQgKiAgIDx0ZD5gJ1xcJydgPC90ZD5cclxuXHQgKiAgIDx0ZD5gXCInXFxcXCcnXCJgPC90ZD5cclxuXHQgKiAgPC90cj5cclxuXHQgKiAgPHRyPlxyXG5cdCAqICAgPHRkPmBJRCA6IFtBLVpdKztgPC90ZD5cclxuXHQgKiAgIDx0ZD5uL2E8L3RkPlxyXG5cdCAqICAgPHRkPmB1bmRlZmluZWRgPC90ZD5cclxuXHQgKiAgPC90cj5cclxuXHQgKiA8L3RhYmxlPlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHRva2VuVHlwZSBUaGUgdG9rZW4gdHlwZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBzdHJpbmcgbGl0ZXJhbCBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCB0b2tlbiB0eXBlLCBvclxyXG5cdCAqIGB1bmRlZmluZWRgIGlmIG5vIHN0cmluZyBsaXRlcmFsIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHlwZS5cclxuXHQgKi9cclxuXHRnZXRMaXRlcmFsTmFtZSh0b2tlblR5cGU6IG51bWJlcik6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgc3ltYm9saWMgbmFtZSBhc3NvY2lhdGVkIHdpdGggYSB0b2tlbiB0eXBlLiBUaGUgc3RyaW5nIHJldHVybmVkXHJcblx0ICogYnkgdGhpcyBtZXRob2QsIHdoZW4gbm90IGB1bmRlZmluZWRgLCBjYW4gYmUgdXNlZCB1bmFsdGVyZWQgaW4gYSBwYXJzZXJcclxuXHQgKiBncmFtbWFyIHRvIHJlcHJlc2VudCB0aGlzIHRva2VuIHR5cGUuXHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0b2tlbiB0eXBlcyBkZWZpbmVkIGJ5IGFueSBvZiB0aGUgZm9sbG93aW5nXHJcblx0ICogbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqICogVG9rZW5zIGNyZWF0ZWQgYnkgbGV4ZXIgcnVsZXMuXHJcblx0ICogKiBUb2tlbnMgZGVmaW5lZCBpbiBhIGB0b2tlbnN7fWAgYmxvY2sgaW4gYSBsZXhlciBvciBwYXJzZXJcclxuXHQgKiAgIGdyYW1tYXIuXHJcblx0ICogKiBUaGUgaW1wbGljaXRseSBkZWZpbmVkIGBFT0ZgIHRva2VuLCB3aGljaCBoYXMgdGhlIHRva2VuIHR5cGVcclxuXHQgKiAgIHtAbGluayBUb2tlbiNFT0Z9LlxyXG5cdCAqXHJcblx0ICogVGhlIGZvbGxvd2luZyB0YWJsZSBzaG93cyBleGFtcGxlcyBvZiBsZXhlciBydWxlcyBhbmQgdGhlIGxpdGVyYWxcclxuXHQgKiBuYW1lcyBhc3NpZ25lZCB0byB0aGUgY29ycmVzcG9uZGluZyB0b2tlbiB0eXBlcy5cclxuXHQgKlxyXG5cdCAqIDx0YWJsZT5cclxuXHQgKiAgPHRyPlxyXG5cdCAqICAgPHRoPlJ1bGU8L3RoPlxyXG5cdCAqICAgPHRoPlN5bWJvbGljIE5hbWU8L3RoPlxyXG5cdCAqICA8L3RyPlxyXG5cdCAqICA8dHI+XHJcblx0ICogICA8dGQ+YFRISVMgOiAndGhpcyc7YDwvdGQ+XHJcblx0ICogICA8dGQ+YFRISVNgPC90ZD5cclxuXHQgKiAgPC90cj5cclxuXHQgKiAgPHRyPlxyXG5cdCAqICAgPHRkPmBTUVVPVEUgOiAnXFwnJztgPC90ZD5cclxuXHQgKiAgIDx0ZD5gU1FVT1RFYDwvdGQ+XHJcblx0ICogIDwvdHI+XHJcblx0ICogIDx0cj5cclxuXHQgKiAgIDx0ZD5gSUQgOiBbQS1aXSs7YDwvdGQ+XHJcblx0ICogICA8dGQ+YElEYDwvdGQ+XHJcblx0ICogIDwvdHI+XHJcblx0ICogPC90YWJsZT5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0b2tlblR5cGUgVGhlIHRva2VuIHR5cGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgc3ltYm9saWMgbmFtZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCB0b2tlbiB0eXBlLCBvclxyXG5cdCAqIGB1bmRlZmluZWRgIGlmIG5vIHN5bWJvbGljIG5hbWUgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0eXBlLlxyXG5cdCAqL1xyXG5cdGdldFN5bWJvbGljTmFtZSh0b2tlblR5cGU6IG51bWJlcik6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgZGlzcGxheSBuYW1lIG9mIGEgdG9rZW4gdHlwZS5cclxuXHQgKlxyXG5cdCAqIEFOVExSIHByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCwgYnV0XHJcblx0ICogYXBwbGljYXRpb25zIGFyZSBmcmVlIHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvciBpbiBhbnkgbWFubmVyIHdoaWNoIG1ha2VzXHJcblx0ICogc2Vuc2UgZm9yIHRoZSBhcHBsaWNhdGlvbi4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0aGUgZmlyc3RcclxuXHQgKiByZXN1bHQgZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Qgd2hpY2ggcHJvZHVjZXMgYSBub24tYHVuZGVmaW5lZGBcclxuXHQgKiByZXN1bHQuXHJcblx0ICpcclxuXHQgKiAxLiBUaGUgcmVzdWx0IG9mIHtAbGluayAjZ2V0TGl0ZXJhbE5hbWV9XHJcblx0ICogMS4gVGhlIHJlc3VsdCBvZiB7QGxpbmsgI2dldFN5bWJvbGljTmFtZX1cclxuXHQgKiAxLiBUaGUgcmVzdWx0IG9mIHtAbGluayBJbnRlZ2VyI3RvU3RyaW5nfVxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHRva2VuVHlwZSBUaGUgdG9rZW4gdHlwZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHRva2VuIHR5cGUsIGZvciB1c2UgaW4gZXJyb3IgcmVwb3J0aW5nIG9yXHJcblx0ICogb3RoZXIgdXNlci12aXNpYmxlIG1lc3NhZ2VzIHdoaWNoIHJlZmVyZW5jZSBzcGVjaWZpYyB0b2tlbiB0eXBlcy5cclxuXHQgKi9cclxuXHQvL0BOb3ROdWxsXHJcblx0Z2V0RGlzcGxheU5hbWUodG9rZW5UeXBlOiBudW1iZXIpOiBzdHJpbmc7XHJcblxyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo1OS43MDE1NzUxLTA3OjAwXHJcblxyXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL1Rva2VuXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFdyaXRhYmxlVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XHJcblx0dGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG5cclxuXHR0eXBlOiBudW1iZXI7XHJcblxyXG5cdGxpbmU6IG51bWJlcjtcclxuXHJcblx0Y2hhclBvc2l0aW9uSW5MaW5lOiBudW1iZXI7XHJcblxyXG5cdGNoYW5uZWw6IG51bWJlcjtcclxuXHJcblx0dG9rZW5JbmRleDogbnVtYmVyO1xyXG59XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCAqIGZyb20gXCIuL0FOVExSRXJyb3JMaXN0ZW5lclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9BTlRMUkVycm9yU3RyYXRlZ3lcIjtcclxuLy8gZXhwb3J0ICogZnJvbSBcIi4vQU5UTFJGaWxlU3RyZWFtXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0FOVExSSW5wdXRTdHJlYW1cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vQmFpbEVycm9yU3RyYXRlZ3lcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vQnVmZmVyZWRUb2tlblN0cmVhbVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9DaGFyU3RyZWFtXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0NoYXJTdHJlYW1zXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0NvZGVQb2ludEJ1ZmZlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9Db2RlUG9pbnRDaGFyU3RyZWFtXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0NvbW1vblRva2VuXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0NvbW1vblRva2VuRmFjdG9yeVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9Db21tb25Ub2tlblN0cmVhbVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9Db25zb2xlRXJyb3JMaXN0ZW5lclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9EZWZhdWx0RXJyb3JTdHJhdGVneVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9EZXBlbmRlbnRzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0RpYWdub3N0aWNFcnJvckxpc3RlbmVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0ZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9JbnB1dE1pc21hdGNoRXhjZXB0aW9uXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0ludGVycHJldGVyUnVsZUNvbnRleHRcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vSW50U3RyZWFtXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0xleGVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0xleGVySW50ZXJwcmV0ZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9MaXN0VG9rZW5Tb3VyY2VcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vTm9WaWFibGVBbHRFeGNlcHRpb25cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vUGFyc2VyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1BhcnNlckVycm9yTGlzdGVuZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vUGFyc2VySW50ZXJwcmV0ZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vUGFyc2VyUnVsZUNvbnRleHRcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vUHJveHlFcnJvckxpc3RlbmVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1Byb3h5UGFyc2VyRXJyb3JMaXN0ZW5lclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9SZWNvZ25pdGlvbkV4Y2VwdGlvblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9SZWNvZ25pemVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1J1bGVDb250ZXh0XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1J1bGVDb250ZXh0V2l0aEFsdE51bVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9SdWxlRGVwZW5kZW5jeVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9SdWxlVmVyc2lvblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9Ub2tlblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9Ub2tlbkZhY3RvcnlcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vVG9rZW5Tb3VyY2VcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vVG9rZW5TdHJlYW1cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vVG9rZW5TdHJlYW1SZXdyaXRlclwiO1xyXG4vLyBleHBvcnQgKiBmcm9tIFwiLi9VbmJ1ZmZlcmVkQ2hhclN0cmVhbVwiO1xyXG4vLyBleHBvcnQgKiBmcm9tIFwiLi9VbmJ1ZmZlcmVkVG9rZW5TdHJlYW1cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vVm9jYWJ1bGFyeVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9Wb2NhYnVsYXJ5SW1wbFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9Xcml0YWJsZVRva2VuXCI7XHJcbiIsICIvKiFcclxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QtMy1DbGF1c2UgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuXHJcbi8vIENvbnZlcnRUby1UUyBydW4gYXQgMjAxNi0xMC0wNFQxMToyNjo0Ny4zMDkyMjc5LTA3OjAwXHJcblxyXG5pbXBvcnQgeyBFcnJvck5vZGUgfSBmcm9tIFwiLi9FcnJvck5vZGVcIjtcclxuaW1wb3J0IHsgTm90TnVsbCwgT3ZlcnJpZGUgfSBmcm9tIFwiLi4vRGVjb3JhdG9yc1wiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWUgfSBmcm9tIFwiLi9QYXJzZVRyZWVcIjtcclxuaW1wb3J0IHsgUGFyc2VUcmVlVmlzaXRvciB9IGZyb20gXCIuL1BhcnNlVHJlZVZpc2l0b3JcIjtcclxuaW1wb3J0IHsgUnVsZU5vZGUgfSBmcm9tIFwiLi9SdWxlTm9kZVwiO1xyXG5pbXBvcnQgeyBUZXJtaW5hbE5vZGUgfSBmcm9tIFwiLi9UZXJtaW5hbE5vZGVcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFBhcnNlVHJlZVZpc2l0b3I8UmVzdWx0PiBpbXBsZW1lbnRzIFBhcnNlVHJlZVZpc2l0b3I8UmVzdWx0PiB7XHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gY2FsbHMge0BsaW5rIFBhcnNlVHJlZSNhY2NlcHR9IG9uIHRoZVxyXG5cdCAqIHNwZWNpZmllZCB0cmVlLlxyXG5cdCAqL1xyXG5cdEBPdmVycmlkZVxyXG5cdHB1YmxpYyB2aXNpdChATm90TnVsbCB0cmVlOiBQYXJzZVRyZWUpOiBSZXN1bHQge1xyXG5cdFx0cmV0dXJuIHRyZWUuYWNjZXB0KHRoaXMpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICoge0Bpbmhlcml0RG9jfVxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaW5pdGlhbGl6ZXMgdGhlIGFnZ3JlZ2F0ZSByZXN1bHQgdG9cclxuXHQgKiB7QGxpbmsgI2RlZmF1bHRSZXN1bHQgZGVmYXVsdFJlc3VsdCgpfS4gQmVmb3JlIHZpc2l0aW5nIGVhY2ggY2hpbGQsIGl0XHJcblx0ICogY2FsbHMge0BsaW5rICNzaG91bGRWaXNpdE5leHRDaGlsZCBzaG91bGRWaXNpdE5leHRDaGlsZH07IGlmIHRoZSByZXN1bHRcclxuXHQgKiBpcyBgZmFsc2VgIG5vIG1vcmUgY2hpbGRyZW4gYXJlIHZpc2l0ZWQgYW5kIHRoZSBjdXJyZW50IGFnZ3JlZ2F0ZVxyXG5cdCAqIHJlc3VsdCBpcyByZXR1cm5lZC4gQWZ0ZXIgdmlzaXRpbmcgYSBjaGlsZCwgdGhlIGFnZ3JlZ2F0ZSByZXN1bHQgaXNcclxuXHQgKiB1cGRhdGVkIGJ5IGNhbGxpbmcge0BsaW5rICNhZ2dyZWdhdGVSZXN1bHQgYWdncmVnYXRlUmVzdWx0fSB3aXRoIHRoZVxyXG5cdCAqIHByZXZpb3VzIGFnZ3JlZ2F0ZSByZXN1bHQgYW5kIHRoZSByZXN1bHQgb2YgdmlzaXRpbmcgdGhlIGNoaWxkLlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgbm90IHNhZmUgZm9yIHVzZSBpbiB2aXNpdG9ycyB0aGF0IG1vZGlmeVxyXG5cdCAqIHRoZSB0cmVlIHN0cnVjdHVyZS4gVmlzaXRvcnMgdGhhdCBtb2RpZnkgdGhlIHRyZWUgc2hvdWxkIG92ZXJyaWRlIHRoaXNcclxuXHQgKiBtZXRob2QgdG8gYmVoYXZlIHByb3Blcmx5IGluIHJlc3BlY3QgdG8gdGhlIHNwZWNpZmljIGFsZ29yaXRobSBpbiB1c2UuXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHZpc2l0Q2hpbGRyZW4oQE5vdE51bGwgbm9kZTogUnVsZU5vZGUpOiBSZXN1bHQge1xyXG5cdFx0bGV0IHJlc3VsdDogUmVzdWx0ID0gdGhpcy5kZWZhdWx0UmVzdWx0KCk7XHJcblx0XHRsZXQgbjogbnVtYmVyID0gbm9kZS5jaGlsZENvdW50O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLnNob3VsZFZpc2l0TmV4dENoaWxkKG5vZGUsIHJlc3VsdCkpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGM6IFBhcnNlVHJlZSA9IG5vZGUuZ2V0Q2hpbGQoaSk7XHJcblx0XHRcdGxldCBjaGlsZFJlc3VsdDogUmVzdWx0ID0gYy5hY2NlcHQodGhpcyk7XHJcblx0XHRcdHJlc3VsdCA9IHRoaXMuYWdncmVnYXRlUmVzdWx0KHJlc3VsdCwgY2hpbGRSZXN1bHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiB7QGluaGVyaXREb2N9XHJcblx0ICpcclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIHRoZSByZXN1bHQgb2ZcclxuXHQgKiB7QGxpbmsgI2RlZmF1bHRSZXN1bHQgZGVmYXVsdFJlc3VsdH0uXHJcblx0ICovXHJcblx0QE92ZXJyaWRlXHJcblx0cHVibGljIHZpc2l0VGVybWluYWwoQE5vdE51bGwgbm9kZTogVGVybWluYWxOb2RlKTogUmVzdWx0IHtcclxuXHRcdHJldHVybiB0aGlzLmRlZmF1bHRSZXN1bHQoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHtAaW5oZXJpdERvY31cclxuXHQgKlxyXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdGhlIHJlc3VsdCBvZlxyXG5cdCAqIHtAbGluayAjZGVmYXVsdFJlc3VsdCBkZWZhdWx0UmVzdWx0fS5cclxuXHQgKi9cclxuXHRAT3ZlcnJpZGVcclxuXHRwdWJsaWMgdmlzaXRFcnJvck5vZGUoQE5vdE51bGwgbm9kZTogRXJyb3JOb2RlKTogUmVzdWx0IHtcclxuXHRcdHJldHVybiB0aGlzLmRlZmF1bHRSZXN1bHQoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgdmlzaXRvciBtZXRob2RzLiBUaGlzIHZhbHVlIGlzXHJcblx0ICogcmV0dXJuZWQgYnkgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zIG9mXHJcblx0ICoge0BsaW5rICN2aXNpdFRlcm1pbmFsIHZpc2l0VGVybWluYWx9LCB7QGxpbmsgI3Zpc2l0RXJyb3JOb2RlIHZpc2l0RXJyb3JOb2RlfS5cclxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgI3Zpc2l0Q2hpbGRyZW4gdmlzaXRDaGlsZHJlbn1cclxuXHQgKiBpbml0aWFsaXplcyBpdHMgYWdncmVnYXRlIHJlc3VsdCB0byB0aGlzIHZhbHVlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgdmlzaXRvciBtZXRob2RzLlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBkZWZhdWx0UmVzdWx0KCk6IFJlc3VsdDtcclxuXHJcblx0LyoqXHJcblx0ICogQWdncmVnYXRlcyB0aGUgcmVzdWx0cyBvZiB2aXNpdGluZyBtdWx0aXBsZSBjaGlsZHJlbiBvZiBhIG5vZGUuIEFmdGVyXHJcblx0ICogZWl0aGVyIGFsbCBjaGlsZHJlbiBhcmUgdmlzaXRlZCBvciB7QGxpbmsgI3Nob3VsZFZpc2l0TmV4dENoaWxkfSByZXR1cm5zXHJcblx0ICogYGZhbHNlYCwgdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBpcyByZXR1cm5lZCBhcyB0aGUgcmVzdWx0IG9mXHJcblx0ICoge0BsaW5rICN2aXNpdENoaWxkcmVufS5cclxuXHQgKlxyXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgYG5leHRSZXN1bHRgLCBtZWFuaW5nXHJcblx0ICoge0BsaW5rICN2aXNpdENoaWxkcmVufSB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGNoaWxkIHZpc2l0ZWRcclxuXHQgKiAob3IgcmV0dXJuIHRoZSBpbml0aWFsIHZhbHVlIGlmIHRoZSBub2RlIGhhcyBubyBjaGlsZHJlbikuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gYWdncmVnYXRlIFRoZSBwcmV2aW91cyBhZ2dyZWdhdGUgdmFsdWUuIEluIHRoZSBkZWZhdWx0XHJcblx0ICogaW1wbGVtZW50YXRpb24sIHRoZSBhZ2dyZWdhdGUgdmFsdWUgaXMgaW5pdGlhbGl6ZWQgdG9cclxuXHQgKiB7QGxpbmsgI2RlZmF1bHRSZXN1bHR9LCB3aGljaCBpcyBwYXNzZWQgYXMgdGhlIGBhZ2dyZWdhdGVgIGFyZ3VtZW50XHJcblx0ICogdG8gdGhpcyBtZXRob2QgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIG5vZGUgaXMgdmlzaXRlZC5cclxuXHQgKiBAcGFyYW0gbmV4dFJlc3VsdCBUaGUgcmVzdWx0IG9mIHRoZSBpbW1lZGlhdGVseSBwcmVjZWVkaW5nIGNhbGwgdG8gdmlzaXRcclxuXHQgKiBhIGNoaWxkIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBhZ2dyZWdhdGUgcmVzdWx0LlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBhZ2dyZWdhdGVSZXN1bHQoYWdncmVnYXRlOiBSZXN1bHQsIG5leHRSZXN1bHQ6IFJlc3VsdCk6IFJlc3VsdCB7XHJcblx0XHRyZXR1cm4gbmV4dFJlc3VsdDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBhZnRlciB2aXNpdGluZyBlYWNoIGNoaWxkIGluXHJcblx0ICoge0BsaW5rICN2aXNpdENoaWxkcmVufS4gVGhpcyBtZXRob2QgaXMgZmlyc3QgY2FsbGVkIGJlZm9yZSB0aGUgZmlyc3RcclxuXHQgKiBjaGlsZCBpcyB2aXNpdGVkOyBhdCB0aGF0IHBvaW50IGBjdXJyZW50UmVzdWx0YCB3aWxsIGJlIHRoZSBpbml0aWFsXHJcblx0ICogdmFsdWUgKGluIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyByZXR1cm5lZCBieSBhXHJcblx0ICogY2FsbCB0byB7QGxpbmsgI2RlZmF1bHRSZXN1bHR9LiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGFmdGVyIHRoZSBsYXN0XHJcblx0ICogY2hpbGQgaXMgdmlzaXRlZC5cclxuXHQgKlxyXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGFsd2F5cyByZXR1cm5zIGB0cnVlYCwgaW5kaWNhdGluZyB0aGF0XHJcblx0ICogYHZpc2l0Q2hpbGRyZW5gIHNob3VsZCBvbmx5IHJldHVybiBhZnRlciBhbGwgY2hpbGRyZW4gYXJlIHZpc2l0ZWQuXHJcblx0ICogT25lIHJlYXNvbiB0byBvdmVycmlkZSB0aGlzIG1ldGhvZCBpcyB0byBwcm92aWRlIGEgXCJzaG9ydCBjaXJjdWl0XCJcclxuXHQgKiBldmFsdWF0aW9uIG9wdGlvbiBmb3Igc2l0dWF0aW9ucyB3aGVyZSB0aGUgcmVzdWx0IG9mIHZpc2l0aW5nIGEgc2luZ2xlXHJcblx0ICogY2hpbGQgaGFzIHRoZSBwb3RlbnRpYWwgdG8gZGV0ZXJtaW5lIHRoZSByZXN1bHQgb2YgdGhlIHZpc2l0IG9wZXJhdGlvbiBhc1xyXG5cdCAqIGEgd2hvbGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUge0BsaW5rIFJ1bGVOb2RlfSB3aG9zZSBjaGlsZHJlbiBhcmUgY3VycmVudGx5IGJlaW5nXHJcblx0ICogdmlzaXRlZC5cclxuXHQgKiBAcGFyYW0gY3VycmVudFJlc3VsdCBUaGUgY3VycmVudCBhZ2dyZWdhdGUgcmVzdWx0IG9mIHRoZSBjaGlsZHJlbiB2aXNpdGVkXHJcblx0ICogdG8gdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyBgdHJ1ZWAgdG8gY29udGludWUgdmlzaXRpbmcgY2hpbGRyZW4uIE90aGVyd2lzZSByZXR1cm5cclxuXHQgKiBgZmFsc2VgIHRvIHN0b3AgdmlzaXRpbmcgY2hpbGRyZW4gYW5kIGltbWVkaWF0ZWx5IHJldHVybiB0aGVcclxuXHQgKiBjdXJyZW50IGFnZ3JlZ2F0ZSByZXN1bHQgZnJvbSB7QGxpbmsgI3Zpc2l0Q2hpbGRyZW59LlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBzaG91bGRWaXNpdE5leHRDaGlsZChATm90TnVsbCBub2RlOiBSdWxlTm9kZSwgY3VycmVudFJlc3VsdDogUmVzdWx0KTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7ZnJvbU1hcmtkb3dufSBmcm9tICdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nXG5pbXBvcnQge21hdGh9IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tbWF0aCdcbmltcG9ydCB7bWF0aEZyb21NYXJrZG93bn0gZnJvbSAnbWRhc3QtdXRpbC1tYXRoJ1xuaW1wb3J0IHtnZm1UYXNrTGlzdEl0ZW19IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXRhc2stbGlzdC1pdGVtJ1xuaW1wb3J0IHtnZm1UYXNrTGlzdEl0ZW1Gcm9tTWFya2Rvd259IGZyb20gJ21kYXN0LXV0aWwtZ2ZtLXRhc2stbGlzdC1pdGVtJ1xuaW1wb3J0IHtnZm1UYWJsZX0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUnXG5pbXBvcnQge2dmbVRhYmxlRnJvbU1hcmtkb3dufSBmcm9tICdtZGFzdC11dGlsLWdmbS10YWJsZSdcbmltcG9ydCB7Z2ZtU3RyaWtldGhyb3VnaH0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tc3RyaWtldGhyb3VnaCdcbmltcG9ydCB7Z2ZtU3RyaWtldGhyb3VnaEZyb21NYXJrZG93bn0gZnJvbSAnbWRhc3QtdXRpbC1nZm0tc3RyaWtldGhyb3VnaCdcbmltcG9ydCB7Z2ZtRm9vdG5vdGV9IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLWZvb3Rub3RlJ1xuaW1wb3J0IHtnZm1Gb290bm90ZUZyb21NYXJrZG93bn0gZnJvbSAnbWRhc3QtdXRpbC1nZm0tZm9vdG5vdGUnXG5pbXBvcnQge2dmbUF1dG9saW5rTGl0ZXJhbH0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tYXV0b2xpbmstbGl0ZXJhbCdcbmltcG9ydCB7Z2ZtQXV0b2xpbmtMaXRlcmFsRnJvbU1hcmtkb3dufSBmcm9tICdtZGFzdC11dGlsLWdmbS1hdXRvbGluay1saXRlcmFsJ1xuaW1wb3J0IHtnZm19IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtJ1xuaW1wb3J0IHtnZm1Gcm9tTWFya2Rvd259IGZyb20gJ21kYXN0LXV0aWwtZ2ZtJ1xuaW1wb3J0IHtmcm9udG1hdHRlcn0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1mcm9udG1hdHRlcidcbmltcG9ydCB7ZnJvbnRtYXR0ZXJGcm9tTWFya2Rvd259IGZyb20gJ21kYXN0LXV0aWwtZnJvbnRtYXR0ZXInXG4vLyBpbXBvcnQge3N5bnRheFRyZWV9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7RWRpdG9yLCBFZGl0b3JQb3NpdGlvbiwgTWFya2Rvd25WaWV3LCBQbHVnaW59IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7Q29udGVudCwgSGVhZGluZywgUGFyZW50LCBQb2ludCwgUm9vdH0gZnJvbSAnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duL2xpYidcbmltcG9ydCB7Tm9kZSBhcyBTaW1wbGVUZXh0Tm9kZSwgU2ltcGxlVGV4dH0gZnJvbSBcIi4vU2ltcGxlVGV4dFwiO1xuXG50eXBlIENvcHlEb2N1bWVudEFzSFRNTFNldHRpbmdzID0ge1xuXHQvKiogSWYgc2V0IHN2ZyBhcmUgY29udmVydGVkIHRvIGJpdG1hcCAqL1xuXHRjb252ZXJ0U3ZnVG9CaXRtYXA6IGJvb2xlYW47XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IENvcHlEb2N1bWVudEFzSFRNTFNldHRpbmdzID0ge1xuXHRjb252ZXJ0U3ZnVG9CaXRtYXA6IHRydWVcbn1cblxuLy8gMS1iYXNlZFxuY2xhc3MgUG9zIHtcblx0bGluZTogbnVtYmVyO1xuXHRjb2x1bW46IG51bWJlcjtcblxuXHRjb25zdHJ1Y3RvcihsaW5lOiBudW1iZXIsIGNvbHVtbjogbnVtYmVyKSB7XG5cdFx0dGhpcy5saW5lID0gbGluZTtcblx0XHR0aGlzLmNvbHVtbiA9IGNvbHVtbjtcblx0fVxuXG5cdHN0YXRpYyBmcm9tRWRpdG9yUG9zaXRpb24ocG9zOiBFZGl0b3JQb3NpdGlvbik6IFBvcyB7XG5cdFx0cmV0dXJuIG5ldyBQb3MocG9zLmxpbmUgKyAxLCBwb3MuY2ggKyAxKTtcblx0fVxuXG5cdHRvRWRpdG9yUG9zaXRpb24oKTogRWRpdG9yUG9zaXRpb24ge1xuXHRcdHJldHVybiB7XG5cdFx0XHRsaW5lOiB0aGlzLmxpbmUgLSAxLFxuXHRcdFx0Y2g6IHRoaXMuY29sdW1uIC0gMVxuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBmcm9tUG9pbnQocG9zOiBQb2ludCk6IFBvcyB7XG5cdFx0cmV0dXJuIG5ldyBQb3MocG9zLmxpbmUsIHBvcy5jb2x1bW4pO1xuXHR9XG5cblx0Y29tcGFyZVRvKG90aGVyOiBQb3MpOiBudW1iZXIge1xuXHRcdGlmICh0aGlzLmxpbmUgPCBvdGhlci5saW5lKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmxpbmUgPiBvdGhlci5saW5lKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY29sdW1uIDwgb3RoZXIuY29sdW1uKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmNvbHVtbiA+IG90aGVyLmNvbHVtbikge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0ZXF1YWxzKG90aGVyOiBQb3MpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID09PSAwO1xuXHR9XG5cblx0aW5SYW5nZShzdGFydDogUG9zLCBlbmQ6IFBvcyk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVUbyhzdGFydCkgPj0gMCAmJiB0aGlzLmNvbXBhcmVUbyhlbmQpIDw9IDA7XG5cdH1cblxuXHRzdGF0aWMgb3JkZXIoYTogUG9zLCBiOiBQb3MpOiBSYW5nZSB7XG5cdFx0aWYgKGEuY29tcGFyZVRvKGIpIDw9IDApIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN0YXJ0OiBhLFxuXHRcdFx0XHRlbmQ6IGJcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN0YXJ0OiBiLFxuXHRcdFx0XHRlbmQ6IGFcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRtaW51cyhvdGhlcjogUG9zKSA6IFBvcyB7XG5cdFx0cmV0dXJuIG5ldyBQb3ModGhpcy5saW5lIC0gb3RoZXIubGluZSwgdGhpcy5jb2x1bW4gLSBvdGhlci5jb2x1bW4pO1xuXHR9XG5cblx0cGx1cyhvdGhlcjogUG9zKSA6IFBvcyB7XG5cdFx0cmV0dXJuIG5ldyBQb3ModGhpcy5saW5lICsgb3RoZXIubGluZSwgdGhpcy5jb2x1bW4gLSBvdGhlci5jb2x1bW4pO1xuXHR9XG5cblxufVxuXG50eXBlIFJhbmdlID0ge1xuXHRzdGFydDogUG9zLFxuXHRlbmQ6IFBvc1xufVxuXG50eXBlIE1kYXN0Tm9kZSA9IHtcblx0cG9zaXRpb246IHtcblx0XHRzdGFydDogUG9pbnQsXG5cdFx0ZW5kOiBQb2ludFxuXHR9O1xuXHR0eXBlOiBzdHJpbmc7XG5cdGNoaWxkcmVuPzogTWRhc3ROb2RlW107XG5cdHBhcmVudD86IE1kYXN0Tm9kZTtcbn07XG5cbmNsYXNzIE1kYXN0IHtcblx0c3RhdGljIGluTm9kZShub2RlOiBNZGFzdE5vZGUsIHBvczogUG9zKSB7XG5cdFx0aWYgKCFub2RlLnBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvcy5pblJhbmdlKFBvcy5mcm9tUG9pbnQobm9kZS5wb3NpdGlvbi5zdGFydCksIFBvcy5mcm9tUG9pbnQobm9kZS5wb3NpdGlvbi5lbmQpKTtcblx0fVxuXG5cdHN0YXRpYyBmaWxsc05vZGUobm9kZTogTWRhc3ROb2RlLCB7c3RhcnQsIGVuZH06IFJhbmdlKTogYm9vbGVhbiB7XG5cdFx0aWYgKCFub2RlLnBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFBvcy5mcm9tUG9pbnQobm9kZS5wb3NpdGlvbi5zdGFydCkuY29tcGFyZVRvKHN0YXJ0KSA9PT0gMFxuXHRcdFx0JiYgUG9zLmZyb21Qb2ludChub2RlLnBvc2l0aW9uLmVuZCkuY29tcGFyZVRvKGVuZCkgPT09IDA7XG5cdH1cblxuXHRzdGF0aWMgZmluZE5vZGVXaXRoUmFuZ2Uocm9vdDogTWRhc3ROb2RlLCB7c3RhcnQsIGVuZH06IFJhbmdlKTogeyBub2RlOiBNZGFzdE5vZGUsIGFuY2VzdG9yczogTWRhc3ROb2RlW10gfSB7XG5cdFx0bGV0IGN1cnJlbnRQYXJlbnQ6IE1kYXN0Tm9kZSA9IHJvb3Q7XG5cblx0XHRjb25zdCBub2RlU3RhY2s6IE1kYXN0Tm9kZVtdID0gW107XG5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coYHRyeWluZyBub2RlYCwgY3VycmVudFBhcmVudCk7XG5cdFx0XHRub2RlU3RhY2sucHVzaChjdXJyZW50UGFyZW50KTtcblxuXHRcdFx0Y29uc3QgY2hpbGQ6IE1kYXN0Tm9kZSB8IHVuZGVmaW5lZCA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW5cblx0XHRcdFx0Py5maW5kKChub2RlKSA9PiB0aGlzLmluTm9kZShub2RlLCBzdGFydCkgJiYgdGhpcy5pbk5vZGUobm9kZSwgZW5kKSk7XG5cblx0XHRcdGlmICghY2hpbGQpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coYG5vIG1hdGNoaW5nIGNoaWxkYCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoJ2NoaWxkcmVuJyBpbiBjaGlsZCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhgY2hpbGQgd2l0aCBjaGlsZHJlbmApO1xuXHRcdFx0XHRjdXJyZW50UGFyZW50ID0gY2hpbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhgY2hpbGQgd2l0aCBubyBjaGlsZHJlbmApO1xuXHRcdFx0XHRub2RlU3RhY2sucHVzaChjaGlsZCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIG1vdmUgdXAgdG8gdGhlIGhpZ2hlc3Qgbm9kZSB0aGF0IGhhcyB0aGUgc2FtZSByYW5nZSBhcyB0aGUgbGFzdCBub2RlXG5cdFx0Y29uc3QgbGFzdE5vZGUgPSBub2RlU3RhY2tbbm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xuXHRcdGxldCBzYW1lTm9kZUluZGV4O1xuXHRcdGZvciAoc2FtZU5vZGVJbmRleCA9IG5vZGVTdGFjay5sZW5ndGggLSAyOyBzYW1lTm9kZUluZGV4ID49IDA7IC0tc2FtZU5vZGVJbmRleCkge1xuXHRcdFx0Y29uc3QgcGFyZW50Tm9kZSA9IG5vZGVTdGFja1tzYW1lTm9kZUluZGV4XTtcblx0XHRcdGlmIChQb3MuZnJvbVBvaW50KHBhcmVudE5vZGUucG9zaXRpb24hLnN0YXJ0KS5lcXVhbHMoUG9zLmZyb21Qb2ludChsYXN0Tm9kZS5wb3NpdGlvbiEuc3RhcnQpKVxuXHRcdFx0XHQmJiBQb3MuZnJvbVBvaW50KHBhcmVudE5vZGUucG9zaXRpb24hLmVuZCkuZXF1YWxzKFBvcy5mcm9tUG9pbnQobGFzdE5vZGUucG9zaXRpb24hLmVuZCkpKSB7XG5cdFx0XHRcdC8vXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bm9kZTogey4uLm5vZGVTdGFja1tzYW1lTm9kZUluZGV4ICsgMV0sIHBhcmVudDogbm9kZVN0YWNrW01hdGgubWF4KDAsIHNhbWVOb2RlSW5kZXgpXX0sXG5cdFx0XHRhbmNlc3RvcnM6IG5vZGVTdGFjay5zbGljZSgwLCBNYXRoLm1heCgwLCBzYW1lTm9kZUluZGV4ICsgMSkpXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGlzSW5QYXJhZ3JhcGgoYW5jZXN0b3JzOiBNZGFzdE5vZGVbXSk6IGJvb2xlYW4ge1xuXHRmb3IgKGxldCBpPWFuY2VzdG9ycy5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpIHtcblx0XHRpZiAoYW5jZXN0b3JzW2ldLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGlmIChhbmNlc3RvcnNbaV0udHlwZSA9PT0gJ3NlY3Rpb24nKSB7XG5cdFx0XHQvLyBzaG9ydGN1dCAtIHdlIGRvbid0ICBuZWVkIHRvIGxvb2sgYW55IGZhcnRoZXJcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIEFudGxyIHtcblx0c3RhdGljIGluTm9kZShub2RlOiBTaW1wbGVUZXh0Tm9kZSwgcG9zOiBQb3MpIHtcblx0XHRpZiAobm9kZS5zdGFydD8ubGluZSA9PT0gdW5kZWZpbmVkIHx8IG5vZGUuZW5kPy5saW5lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcG9zLmluUmFuZ2UoUG9zLmZyb21Qb2ludChub2RlLnN0YXJ0IGFzIFBvaW50KSwgUG9zLmZyb21Qb2ludChub2RlLmVuZCBhcyBQb2ludCkpO1xuXHR9XG5cblx0c3RhdGljIGZpbGxzTm9kZShub2RlOiBTaW1wbGVUZXh0Tm9kZSwge3N0YXJ0LCBlbmR9OiBSYW5nZSk6IGJvb2xlYW4ge1xuXHRcdGlmIChub2RlLnN0YXJ0Py5saW5lID09PSB1bmRlZmluZWQgfHwgbm9kZS5lbmQ/LmxpbmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBQb3MuZnJvbVBvaW50KG5vZGUuc3RhcnQgYXMgUG9pbnQpLmNvbXBhcmVUbyhzdGFydCkgPT09IDBcblx0XHRcdCYmIFBvcy5mcm9tUG9pbnQobm9kZS5lbmQgYXMgUG9pbnQpLmNvbXBhcmVUbyhlbmQpID09PSAwO1xuXHR9XG5cblx0c3RhdGljIGZpbmROb2RlV2l0aFJhbmdlKHJvb3Q6IFNpbXBsZVRleHROb2RlLCB7c3RhcnQsIGVuZH06IFJhbmdlKTogeyBub2RlOiBTaW1wbGVUZXh0Tm9kZSwgYW5jZXN0b3JzOiBTaW1wbGVUZXh0Tm9kZVtdIH0ge1xuXHRcdGxldCBjdXJyZW50UGFyZW50OiBTaW1wbGVUZXh0Tm9kZSA9IHJvb3Q7XG5cblx0XHRjb25zdCBub2RlU3RhY2s6IFNpbXBsZVRleHROb2RlW10gPSBbXTtcblxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhgdHJ5aW5nIG5vZGVgLCBjdXJyZW50UGFyZW50KTtcblx0XHRcdG5vZGVTdGFjay5wdXNoKGN1cnJlbnRQYXJlbnQpO1xuXG5cdFx0XHQvLyBGSVhNRTogd2UgYWxzbyBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgd2UgYXJlIGluIGEgXCJnYXBcIiwgaWUuIGJldHdlZW4gdHdvICBub2Rlcy4gSW4gdGhhdCBjYXNlIGNvbnNpZGVyXG5cdFx0XHQvLyAgICAgICAgd2UgYXJlIGluIHRoZSBmaXJzdCBub2RlLiBEbyB0aGUgc2FtZSBmb3IgdGhlIG1hcmtkb3duIHZlcnNpb24uIFRoaXMgYXZvaWRzIHNlbGVjdGluZyBcInVwXCIgdG9vIGZhc3Rcblx0XHRcdGNvbnN0IGNoaWxkOiBTaW1wbGVUZXh0Tm9kZSB8IHVuZGVmaW5lZCA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4/LmZpbmQoKG5vZGUpID0+XG5cdFx0XHRcdHRoaXMuaW5Ob2RlKG5vZGUsIHN0YXJ0KSAmJiB0aGlzLmluTm9kZShub2RlLCBlbmQpKTtcblxuXHRcdFx0aWYgKCFjaGlsZCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgbm8gbWF0Y2hpbmcgY2hpbGRgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgnY2hpbGRyZW4nIGluIGNoaWxkKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBjaGlsZCB3aXRoIGNoaWxkcmVuYCk7XG5cdFx0XHRcdGN1cnJlbnRQYXJlbnQgPSBjaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBjaGlsZCB3aXRoIG5vIGNoaWxkcmVuYCk7XG5cdFx0XHRcdG5vZGVTdGFjay5wdXNoKGNoaWxkKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZSB1cCB0byB0aGUgaGlnaGVzdCBub2RlIHRoYXQgaGFzIHRoZSBzYW1lIHJhbmdlIGFzIHRoZSBsYXN0IG5vZGVcblx0XHRjb25zdCBsYXN0Tm9kZSA9IG5vZGVTdGFja1tub2RlU3RhY2subGVuZ3RoIC0gMV07XG5cdFx0bGV0IHNhbWVOb2RlSW5kZXg7XG5cdFx0Zm9yIChzYW1lTm9kZUluZGV4ID0gbm9kZVN0YWNrLmxlbmd0aCAtIDI7IHNhbWVOb2RlSW5kZXggPj0gMDsgLS1zYW1lTm9kZUluZGV4KSB7XG5cdFx0XHRjb25zdCBwYXJlbnROb2RlID0gbm9kZVN0YWNrW3NhbWVOb2RlSW5kZXhdO1xuXHRcdFx0aWYgKFBvcy5mcm9tUG9pbnQocGFyZW50Tm9kZS5zdGFydCBhcyBQb2ludCkuZXF1YWxzKFBvcy5mcm9tUG9pbnQobGFzdE5vZGUuc3RhcnQgYXMgUG9pbnQpKVxuXHRcdFx0XHQmJiBQb3MuZnJvbVBvaW50KHBhcmVudE5vZGUuZW5kIGFzIFBvaW50KS5lcXVhbHMoUG9zLmZyb21Qb2ludChsYXN0Tm9kZS5lbmQgYXMgUG9pbnQpKSkge1xuXHRcdFx0XHQvL1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG5vZGU6IG5vZGVTdGFja1tzYW1lTm9kZUluZGV4ICsgMV0sXG5cdFx0XHRhbmNlc3RvcnM6IG5vZGVTdGFjay5zbGljZSgwLCBNYXRoLm1heCgwLCBzYW1lTm9kZUluZGV4ICsgMSkpXG5cdFx0fVxuXHR9XG59XG5cblxuLy8gQHRzLWlnbm9yZVxuaW50ZXJmYWNlIFNlY3Rpb24gZXh0ZW5kcyBQYXJlbnQge1xuXHR0eXBlOiAnc2VjdGlvbic7XG5cdGNoaWxkcmVuOiBbSGVhZGluZywgU2VjdGlvbkNvbnRlbnRdO1xuXHRwb3NpdGlvbjogUmFuZ2U7XG59XG5cbi8vIEB0cy1pZ25vcmVcbmludGVyZmFjZSBTZWN0aW9uQ29udGVudCBleHRlbmRzIFBhcmVudCB7XG5cdHR5cGU6ICdzZWN0aW9uLWNvbnRlbnQnO1xuXHRjaGlsZHJlbjogQ29udGVudFtdO1xuXHRwb3NpdGlvbjogUmFuZ2U7XG59XG5cbmZ1bmN0aW9uIG5lc3RTZWN0aW9ucyh0cmVlOiBSb290KTogdm9pZCB7XG5cdGZvciAobGV0IGRlcHRoID0gNjsgZGVwdGggPj0gMTsgLS1kZXB0aCkge1xuXHRcdGxldCBjdXJyZW50U2VjdGlvbjogU2VjdGlvbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuXHRcdFx0aWYgKHRyZWUuY2hpbGRyZW5baV0udHlwZSA9PT0gJ2hlYWRpbmcnKSB7XG5cdFx0XHRcdGxldCBoZWFkaW5nID0gdHJlZS5jaGlsZHJlbltpXSBhcyBIZWFkaW5nO1xuXHRcdFx0XHRpZiAoaGVhZGluZy5kZXB0aCA9PT0gZGVwdGgpIHtcblx0XHRcdFx0XHRjb25zdCBzZWN0aW9uQ29udGVudDogU2VjdGlvbkNvbnRlbnQgPSB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnc2VjdGlvbi1jb250ZW50Jyxcblx0XHRcdFx0XHRcdGNoaWxkcmVuOiBbXSxcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0OiBQb3MuZnJvbVBvaW50KGhlYWRpbmcucG9zaXRpb24hLmVuZCksXG5cdFx0XHRcdFx0XHRcdGVuZDogUG9zLmZyb21Qb2ludChoZWFkaW5nLnBvc2l0aW9uIS5lbmQpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y3VycmVudFNlY3Rpb24gPSB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnc2VjdGlvbicsXG5cdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0XHRjaGlsZHJlbjogW2hlYWRpbmcsIHNlY3Rpb25Db250ZW50XSxcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0OiBQb3MuZnJvbVBvaW50KGhlYWRpbmcucG9zaXRpb24hLnN0YXJ0KSxcblx0XHRcdFx0XHRcdFx0ZW5kOiBQb3MuZnJvbVBvaW50KGhlYWRpbmcucG9zaXRpb24hLmVuZClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0dHJlZS5jaGlsZHJlbltpXSA9IGN1cnJlbnRTZWN0aW9uO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGhlYWRpbmcuZGVwdGggPCBkZXB0aCkge1xuXHRcdFx0XHRcdGN1cnJlbnRTZWN0aW9uID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoY3VycmVudFNlY3Rpb24pIHtcblx0XHRcdFx0XHRjdXJyZW50U2VjdGlvbi5jaGlsZHJlblsxXS5jaGlsZHJlbi5wdXNoKHRyZWUuY2hpbGRyZW5baV0pXG5cblx0XHRcdFx0XHRsZXQgZW5kID0gUG9zLmZyb21Qb2ludCh0cmVlLmNoaWxkcmVuW2ldLnBvc2l0aW9uIS5lbmQpO1xuXHRcdFx0XHRcdGN1cnJlbnRTZWN0aW9uLnBvc2l0aW9uLmVuZCA9IGVuZDtcblx0XHRcdFx0XHRjdXJyZW50U2VjdGlvbi5jaGlsZHJlblsxXS5wb3NpdGlvbi5lbmQgPSBlbmQ7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdHRyZWUuY2hpbGRyZW5baV0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0cmVlLmNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbi5maWx0ZXIobm9kZSA9PiAhIW5vZGUpO1xuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29weURvY3VtZW50QXNIVE1MUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IENvcHlEb2N1bWVudEFzSFRNTFNldHRpbmdzO1xuXG5cdGFzeW5jIG9ubG9hZCgpIHtcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdFx0aWQ6ICdncm93LXNlbGVjdGlvbicsXG5cdFx0XHRcdG5hbWU6ICdHcm93IHNlbGVjdGlvbicsXG5cdFx0XHRcdGVkaXRvckNhbGxiYWNrOiBhc3luYyAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRcdC8vIC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhlZGl0b3IpXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyAvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0Ly8gc3ludGF4VHJlZShlZGl0b3IuY20udmlld1N0YXRlLnN0YXRlKVxuXHRcdFx0XHRcdC8vIFx0Lml0ZXJhdGUoe1xuXHRcdFx0XHRcdC8vIFx0XHRlbnRlcjogKG5vZGU6IGFueSkgPT4ge1xuXHRcdFx0XHRcdC8vIFx0XHRcdGNvbnNvbGUubG9nKG5vZGUpO1xuXHRcdFx0XHRcdC8vIFx0XHR9XG5cdFx0XHRcdFx0Ly8gXHR9KVxuXG5cdFx0XHRcdFx0Y29uc3QgdHJlZSA9IGZyb21NYXJrZG93bih2aWV3LmRhdGEsIHtcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0bWF0aCgpLFxuXHRcdFx0XHRcdFx0XHRnZm1UYXNrTGlzdEl0ZW0sXG5cdFx0XHRcdFx0XHRcdGdmbVRhYmxlLFxuXHRcdFx0XHRcdFx0XHRnZm1TdHJpa2V0aHJvdWdoKCksXG5cdFx0XHRcdFx0XHRcdGdmbUZvb3Rub3RlKCksXG5cdFx0XHRcdFx0XHRcdGdmbUF1dG9saW5rTGl0ZXJhbCxcblx0XHRcdFx0XHRcdFx0Z2ZtKCksXG5cdFx0XHRcdFx0XHRcdGZyb250bWF0dGVyKFsneWFtbCddKVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdG1kYXN0RXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRtYXRoRnJvbU1hcmtkb3duKCksXG5cdFx0XHRcdFx0XHRcdGdmbVRhc2tMaXN0SXRlbUZyb21NYXJrZG93bixcblx0XHRcdFx0XHRcdFx0Z2ZtVGFibGVGcm9tTWFya2Rvd24sXG5cdFx0XHRcdFx0XHRcdGdmbVN0cmlrZXRocm91Z2hGcm9tTWFya2Rvd24sXG5cdFx0XHRcdFx0XHRcdGdmbUZvb3Rub3RlRnJvbU1hcmtkb3duKCksXG5cdFx0XHRcdFx0XHRcdGdmbUF1dG9saW5rTGl0ZXJhbEZyb21NYXJrZG93bixcblx0XHRcdFx0XHRcdFx0Z2ZtRnJvbU1hcmtkb3duKCksXG5cdFx0XHRcdFx0XHRcdGZyb250bWF0dGVyRnJvbU1hcmtkb3duKFsneWFtbCddKVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2codHJlZSk7XG5cdFx0XHRcdFx0bmVzdFNlY3Rpb25zKHRyZWUpO1xuXG5cdFx0XHRcdFx0Y29uc3Qge2hlYWQsIGFuY2hvcn0gPSBlZGl0b3IubGlzdFNlbGVjdGlvbnMoKVswXTtcblx0XHRcdFx0XHRjb25zdCByYW5nZSA9IFBvcy5vcmRlcihQb3MuZnJvbUVkaXRvclBvc2l0aW9uKGhlYWQpLCBQb3MuZnJvbUVkaXRvclBvc2l0aW9uKGFuY2hvcikpO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdzZWxlY3Rpb24gc3RhcnQnLCByYW5nZS5zdGFydCk7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ3NlbGVjdGlvbiBlbmQnLCByYW5nZS5lbmQpO1xuXG5cdFx0XHRcdFx0bGV0IHJlc3VsdCA9IE1kYXN0LmZpbmROb2RlV2l0aFJhbmdlKHRyZWUgYXMgTWRhc3ROb2RlLCByYW5nZSk7XG5cdFx0XHRcdFx0bGV0IG5vZGVXaXRoU2VsZWN0aW9uID0gcmVzdWx0Lm5vZGU7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2cocmVzdWx0LmFuY2VzdG9ycy5tYXAoYSA9PiBhLnR5cGUpKTtcblxuXHRcdFx0XHRcdGlmICgobm9kZVdpdGhTZWxlY3Rpb24udHlwZSA9PT0gJ3BhcmFncmFwaCcgJiYgIU1kYXN0LmZpbGxzTm9kZShub2RlV2l0aFNlbGVjdGlvbiwgcmFuZ2UpKVxuXHRcdFx0XHRcdFx0fHwgaXNJblBhcmFncmFwaChyZXN1bHQuYW5jZXN0b3JzKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLyBnZXQgcGFyYWdyYXBoIGFuY2VzdG9yIChyZWZhY3RvciB0byBpbmNsdWRlIGNoZWNrIGFib3ZlKVxuXHRcdFx0XHRcdFx0bGV0IHBhcmFncmFwaE5vZGUgPSBub2RlV2l0aFNlbGVjdGlvbjtcblx0XHRcdFx0XHRcdGZvciAobGV0IGk9cmVzdWx0LmFuY2VzdG9ycy5sZW5ndGgtMTsgaT49MDsgLS1pKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChyZXN1bHQuYW5jZXN0b3JzW2ldLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFyYWdyYXBoTm9kZSA9IHJlc3VsdC5hbmNlc3RvcnNbaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gaW4gZG9jdW1lbnQgY29vcmRpbmF0ZXNcblx0XHRcdFx0XHRcdGNvbnN0IHBhcmFncmFwaFJhbmdlID0ge1xuXHRcdFx0XHRcdFx0XHRzdGFydDogcGFyYWdyYXBoTm9kZS5wb3NpdGlvbiEuc3RhcnQsXG5cdFx0XHRcdFx0XHRcdGVuZDogcGFyYWdyYXBoTm9kZS5wb3NpdGlvbiEuZW5kXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZygnPT09PT09PT09PT09PT09PT09PT0gVXNpbmcgc3ViLXBhcnNlciA9PT09PT09PT09PT09PT09PT09PSAnKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdwYXJhZ3JhcGggc3RhcnQnLCBwYXJhZ3JhcGhSYW5nZS5zdGFydCk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZygncGFyYWdyYXBoIGVuZCcsIHBhcmFncmFwaFJhbmdlLmVuZCk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHRleHQgPSB2aWV3LmRhdGEuc3Vic3RyaW5nKHBhcmFncmFwaFJhbmdlLnN0YXJ0Lm9mZnNldCEsIHBhcmFncmFwaFJhbmdlLmVuZCEub2Zmc2V0KVxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2codGV4dCk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHRyZWU6IFNpbXBsZVRleHROb2RlID0gU2ltcGxlVGV4dC5wYXJzZSh0ZXh0KTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKHRyZWUpO1xuXG5cdFx0XHRcdFx0XHQvLyB0cmFuc2xhdGUgc2VsZWN0aW9uIGludG8gcGFyYWdyYXBoIGNvb3JkaW5hdGVzIChtYWtlIHNlbGVjdGlvbiByZWxhdGl2ZSB0byB0ZXh0KVxuXHRcdFx0XHRcdFx0Y29uc3QgbWFwcGVkU2VsZWN0aW9uID0ge1xuXHRcdFx0XHRcdFx0XHRzdGFydDogcmFuZ2Uuc3RhcnQubWludXMoUG9zLmZyb21Qb2ludChwYXJhZ3JhcGhSYW5nZS5zdGFydCkpLFxuXHRcdFx0XHRcdFx0XHRlbmQ6IHJhbmdlLmVuZC5taW51cyhQb3MuZnJvbVBvaW50KHBhcmFncmFwaFJhbmdlLnN0YXJ0KSlcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRtYXBwZWRTZWxlY3Rpb24uc3RhcnQubGluZSsrO1xuXHRcdFx0XHRcdFx0bWFwcGVkU2VsZWN0aW9uLmVuZC5saW5lKys7XG5cdFx0XHRcdFx0XHRtYXBwZWRTZWxlY3Rpb24uc3RhcnQuY29sdW1uKys7XG5cdFx0XHRcdFx0XHRtYXBwZWRTZWxlY3Rpb24uZW5kLmNvbHVtbisrO1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgbWFwcGVkIHNlbGVjdGlvbjpgLCBtYXBwZWRTZWxlY3Rpb24pO1xuXG5cdFx0XHRcdFx0XHQvLyBmaW5kIG5vZGUgaW4gcmFuZ2Vcblx0XHRcdFx0XHRcdGxldCBhbnRsclRyZWUgPSBBbnRsci5maW5kTm9kZVdpdGhSYW5nZSh0cmVlLCBtYXBwZWRTZWxlY3Rpb24pO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ2FudGxyIHJlc3VsdCBub2RlJywgYW50bHJUcmVlKTtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgd2UgZG9uJ3QgZmlsbCBpdCBncm93IHRvIGZpbGwgaXRcblx0XHRcdFx0XHRcdC8vIGVsc2Ugc2VsZWN0IHBhcmVudFxuXHRcdFx0XHRcdFx0bGV0IHRleHROb2RlOiBTaW1wbGVUZXh0Tm9kZSA9IGFudGxyVHJlZS5ub2RlO1xuXHRcdFx0XHRcdFx0aWYgKEFudGxyLmZpbGxzTm9kZShub2RlV2l0aFNlbGVjdGlvbiwgcmFuZ2UpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdzZWxlY3Rpb24gYWxyZWFkeSBmaWxscyB0aGUgbm9kZSwgZ3Jvd2luZyAhJylcblx0XHRcdFx0XHRcdFx0dGV4dE5vZGUgPSBhbnRsclRyZWUuYW5jZXN0b3JzW2FudGxyVHJlZS5hbmNlc3RvcnMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGBzZWxlY3RpbmdgLCB0ZXh0Tm9kZSk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgc2VsZWN0aW5nIHRleHQgJHt0ZXh0Tm9kZS50ZXh0fWApO1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZygnbmV3IHNlbGVjdGlvbiBzdGFydCcsIHRleHROb2RlLnN0YXJ0KTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCduZXcgc2VsZWN0aW9uIGVuZCcsIHRleHROb2RlLmVuZCk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHJlbWFwcGVkU2VsZWN0aW9uID0ge1xuXHRcdFx0XHRcdFx0XHRzdGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdGxpbmU6IHBhcmFncmFwaFJhbmdlLnN0YXJ0LmxpbmUgLSAxICsgdGV4dE5vZGUuc3RhcnQhLmxpbmUgLSAxLFxuXHRcdFx0XHRcdFx0XHRcdGNoOiBwYXJhZ3JhcGhSYW5nZS5zdGFydC5jb2x1bW4gLSAxICsgdGV4dE5vZGUuc3RhcnQhLmNvbHVtbiAtIDEsXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdGxpbmU6IHBhcmFncmFwaFJhbmdlLnN0YXJ0LmxpbmUgLSAxICsgdGV4dE5vZGUuZW5kIS5saW5lIC0gMSAsXG5cdFx0XHRcdFx0XHRcdFx0Y2g6IHBhcmFncmFwaFJhbmdlLnN0YXJ0LmNvbHVtbiAtMSArIHRleHROb2RlLmVuZCEuY29sdW1uXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ21hcHBlZCBzZWxlY3Rpb24gc3RhcnQnLCByZW1hcHBlZFNlbGVjdGlvbi5zdGFydCk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZygnbWFwcGVkIHNlbGVjdGlvbiBlbmQnLCByZW1hcHBlZFNlbGVjdGlvbi5lbmQpO1xuXG5cdFx0XHRcdFx0XHRlZGl0b3Iuc2V0U2VsZWN0aW9uKHJlbWFwcGVkU2VsZWN0aW9uLnN0YXJ0LCByZW1hcHBlZFNlbGVjdGlvbi5lbmQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIElmIG5vZGUgaXMgYW4gdW5maWxsZWQgcGFyYWdyYXBoIG9yIHBhcmFncmFwaCBjb250ZW50ICh0ZXh0LCBlbXBoYXNpcywgLi4uKVxuXG5cdFx0XHRcdFx0XHRpZiAoTWRhc3QuZmlsbHNOb2RlKG5vZGVXaXRoU2VsZWN0aW9uLCByYW5nZSkgJiYgbm9kZVdpdGhTZWxlY3Rpb24ucGFyZW50KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdub2RlIGlzIGZpbGxlZCwgc2VsZWN0aW5nIHBhcmVudCcpO1xuXHRcdFx0XHRcdFx0XHRub2RlV2l0aFNlbGVjdGlvbiA9IG5vZGVXaXRoU2VsZWN0aW9uLnBhcmVudDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYGZpbGxpbmcgbm9kZSBvZiB0eXBlICR7bm9kZVdpdGhTZWxlY3Rpb24udHlwZX1gKTtcblxuXHRcdFx0XHRcdFx0ZWRpdG9yLnNldFNlbGVjdGlvbihcblx0XHRcdFx0XHRcdFx0UG9zLmZyb21Qb2ludChub2RlV2l0aFNlbGVjdGlvbi5wb3NpdGlvbiEuc3RhcnQpLnRvRWRpdG9yUG9zaXRpb24oKSxcblx0XHRcdFx0XHRcdFx0UG9zLmZyb21Qb2ludChub2RlV2l0aFNlbGVjdGlvbi5wb3NpdGlvbiEuZW5kKS50b0VkaXRvclBvc2l0aW9uKCkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGxldCBjaGlsZDogRWxlbWVudCA9IHRyZWUuY2hpbGRyZW5bMF07XG5cblx0XHRcdFx0XHQvLyBlZGl0b3IuZ2V0TGluZShoZWFkLmxpbmUpO1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGhlYWQpO1xuXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cobWFya2Rvd25pdCk7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdC8vIGNvbnN0IHJlc3VsdCA9IG1hcmtlZC5sZXhlcih2aWV3LmRhdGEsIHtcblx0XHRcdFx0XHQvLyBcdGdmbTogZmFsc2UsXG5cdFx0XHRcdFx0Ly8gfSlcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KTtcblx0fVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0fVxuXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuXHR9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbmNsdWRlSW1hZ2VBbHQ9dHJ1ZV1cbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgdGV4dCBjb250ZW50IG9mIGEgbm9kZS5cbiAqIFByZWZlciB0aGUgbm9kZVx1MjAxOXMgcGxhaW4tdGV4dCBmaWVsZHMsIG90aGVyd2lzZSBzZXJpYWxpemUgaXRzIGNoaWxkcmVuLFxuICogYW5kIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBhcnJheSwgc2VyaWFsaXplIHRoZSBub2RlcyBpbiBpdC5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IG5vZGVcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcobm9kZSwgb3B0aW9ucykge1xuICB2YXIge2luY2x1ZGVJbWFnZUFsdCA9IHRydWV9ID0gb3B0aW9ucyB8fCB7fVxuICByZXR1cm4gb25lKG5vZGUsIGluY2x1ZGVJbWFnZUFsdClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUltYWdlQWx0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBvbmUobm9kZSwgaW5jbHVkZUltYWdlQWx0KSB7XG4gIHJldHVybiAoXG4gICAgKG5vZGUgJiZcbiAgICAgIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJlxuICAgICAgLy8gQHRzLWlnbm9yZSBsb29rcyBsaWtlIGEgbGl0ZXJhbC5cbiAgICAgIChub2RlLnZhbHVlIHx8XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgbG9va3MgbGlrZSBhbiBpbWFnZS5cbiAgICAgICAgKGluY2x1ZGVJbWFnZUFsdCA/IG5vZGUuYWx0IDogJycpIHx8XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgbG9va3MgbGlrZSBhIHBhcmVudC5cbiAgICAgICAgKCdjaGlsZHJlbicgaW4gbm9kZSAmJiBhbGwobm9kZS5jaGlsZHJlbiwgaW5jbHVkZUltYWdlQWx0KSkgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkobm9kZSkgJiYgYWxsKG5vZGUsIGluY2x1ZGVJbWFnZUFsdCkpKSkgfHxcbiAgICAnJ1xuICApXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48dW5rbm93bj59IHZhbHVlc1xuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlSW1hZ2VBbHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGFsbCh2YWx1ZXMsIGluY2x1ZGVJbWFnZUFsdCkge1xuICAvKiogQHR5cGUge0FycmF5LjxzdHJpbmc+fSAqL1xuICB2YXIgcmVzdWx0ID0gW11cbiAgdmFyIGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gb25lKHZhbHVlc1tpbmRleF0sIGluY2x1ZGVJbWFnZUFsdClcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuam9pbignJylcbn1cbiIsICIvKipcbiAqIExpa2UgYEFycmF5I3NwbGljZWAsIGJ1dCBzbWFydGVyIGZvciBnaWFudCBhcnJheXMuXG4gKlxuICogYEFycmF5I3NwbGljZWAgdGFrZXMgYWxsIGl0ZW1zIHRvIGJlIGluc2VydGVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnQgd2hpY2hcbiAqIGNhdXNlcyBhIHN0YWNrIG92ZXJmbG93IGluIFY4IHdoZW4gdHJ5aW5nIHRvIGluc2VydCAxMDBrIGl0ZW1zIGZvciBpbnN0YW5jZS5cbiAqXG4gKiBPdGhlcndpc2UsIHRoaXMgZG9lcyBub3QgcmV0dXJuIHRoZSByZW1vdmVkIGl0ZW1zLCBhbmQgdGFrZXMgYGl0ZW1zYCBhcyBhblxuICogYXJyYXkgaW5zdGVhZCBvZiByZXN0IHBhcmFtZXRlcnMuXG4gKlxuICogQHRlbXBsYXRlIHt1bmtub3dufSBUXG4gKiBAcGFyYW0ge1RbXX0gbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gcmVtb3ZlXG4gKiBAcGFyYW0ge1RbXX0gaXRlbXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaWNlKGxpc3QsIHN0YXJ0LCByZW1vdmUsIGl0ZW1zKSB7XG4gIGNvbnN0IGVuZCA9IGxpc3QubGVuZ3RoXG4gIGxldCBjaHVua1N0YXJ0ID0gMFxuICAvKiogQHR5cGUge3Vua25vd25bXX0gKi9cblxuICBsZXQgcGFyYW1ldGVycyAvLyBNYWtlIHN0YXJ0IGJldHdlZW4gemVybyBhbmQgYGVuZGAgKGluY2x1ZGVkKS5cblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBlbmQgPyAwIDogZW5kICsgc3RhcnRcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IHN0YXJ0ID4gZW5kID8gZW5kIDogc3RhcnRcbiAgfVxuXG4gIHJlbW92ZSA9IHJlbW92ZSA+IDAgPyByZW1vdmUgOiAwIC8vIE5vIG5lZWQgdG8gY2h1bmsgdGhlIGl0ZW1zIGlmIHRoZXJlXHUyMDE5cyBvbmx5IGEgY291cGxlICgxMGspIGl0ZW1zLlxuXG4gIGlmIChpdGVtcy5sZW5ndGggPCAxMDAwMCkge1xuICAgIHBhcmFtZXRlcnMgPSBBcnJheS5mcm9tKGl0ZW1zKVxuICAgIHBhcmFtZXRlcnMudW5zaGlmdChzdGFydCwgcmVtb3ZlKSAvLyBAdHMtZXhwZWN0LWVycm9yIEh1c2gsIGl0XHUyMDE5cyBmaW5lLlxuICAgIDtbXS5zcGxpY2UuYXBwbHkobGlzdCwgcGFyYW1ldGVycylcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWxldGUgYHJlbW92ZWAgaXRlbXMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgXG4gICAgaWYgKHJlbW92ZSkgW10uc3BsaWNlLmFwcGx5KGxpc3QsIFtzdGFydCwgcmVtb3ZlXSkgLy8gSW5zZXJ0IHRoZSBpdGVtcyBpbiBjaHVua3MgdG8gbm90IGNhdXNlIHN0YWNrIG92ZXJmbG93cy5cblxuICAgIHdoaWxlIChjaHVua1N0YXJ0IDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgICBwYXJhbWV0ZXJzID0gaXRlbXMuc2xpY2UoY2h1bmtTdGFydCwgY2h1bmtTdGFydCArIDEwMDAwKVxuICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KHN0YXJ0LCAwKSAvLyBAdHMtZXhwZWN0LWVycm9yIEh1c2gsIGl0XHUyMDE5cyBmaW5lLlxuICAgICAgO1tdLnNwbGljZS5hcHBseShsaXN0LCBwYXJhbWV0ZXJzKVxuICAgICAgY2h1bmtTdGFydCArPSAxMDAwMFxuICAgICAgc3RhcnQgKz0gMTAwMDBcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQXBwZW5kIGBpdGVtc2AgKGFuIGFycmF5KSBhdCB0aGUgZW5kIG9mIGBsaXN0YCAoYW5vdGhlciBhcnJheSkuXG4gKiBXaGVuIGBsaXN0YCB3YXMgZW1wdHksIHJldHVybnMgYGl0ZW1zYCBpbnN0ZWFkLlxuICpcbiAqIFRoaXMgcHJldmVudHMgYSBwb3RlbnRpYWxseSBleHBlbnNpdmUgb3BlcmF0aW9uIHdoZW4gYGxpc3RgIGlzIGVtcHR5LFxuICogYW5kIGFkZHMgaXRlbXMgaW4gYmF0Y2hlcyB0byBwcmV2ZW50IFY4IGZyb20gaGFuZ2luZy5cbiAqXG4gKiBAdGVtcGxhdGUge3Vua25vd259IFRcbiAqIEBwYXJhbSB7VFtdfSBsaXN0XG4gKiBAcGFyYW0ge1RbXX0gaXRlbXNcbiAqIEByZXR1cm5zIHtUW119XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHB1c2gobGlzdCwgaXRlbXMpIHtcbiAgaWYgKGxpc3QubGVuZ3RoID4gMCkge1xuICAgIHNwbGljZShsaXN0LCBsaXN0Lmxlbmd0aCwgMCwgaXRlbXMpXG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuXG4gIHJldHVybiBpdGVtc1xufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ob3JtYWxpemVkRXh0ZW5zaW9ufSBOb3JtYWxpemVkRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4dGVuc2lvbn0gRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkh0bWxFeHRlbnNpb259IEh0bWxFeHRlbnNpb25cbiAqL1xuXG5pbXBvcnQge3NwbGljZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2h1bmtlZCdcblxuY29uc3QgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG4vKipcbiAqIENvbWJpbmUgc2V2ZXJhbCBzeW50YXggZXh0ZW5zaW9ucyBpbnRvIG9uZS5cbiAqXG4gKiBAcGFyYW0ge0V4dGVuc2lvbltdfSBleHRlbnNpb25zIExpc3Qgb2Ygc3ludGF4IGV4dGVuc2lvbnMuXG4gKiBAcmV0dXJucyB7Tm9ybWFsaXplZEV4dGVuc2lvbn0gQSBzaW5nbGUgY29tYmluZWQgZXh0ZW5zaW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xuICAvKiogQHR5cGUge05vcm1hbGl6ZWRFeHRlbnNpb259ICovXG4gIGNvbnN0IGFsbCA9IHt9XG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBleHRlbnNpb25zLmxlbmd0aCkge1xuICAgIHN5bnRheEV4dGVuc2lvbihhbGwsIGV4dGVuc2lvbnNbaW5kZXhdKVxuICB9XG5cbiAgcmV0dXJuIGFsbFxufVxuXG4vKipcbiAqIE1lcmdlIGBleHRlbnNpb25gIGludG8gYGFsbGAuXG4gKlxuICogQHBhcmFtIHtOb3JtYWxpemVkRXh0ZW5zaW9ufSBhbGwgRXh0ZW5zaW9uIHRvIG1lcmdlIGludG8uXG4gKiBAcGFyYW0ge0V4dGVuc2lvbn0gZXh0ZW5zaW9uIEV4dGVuc2lvbiB0byBtZXJnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBzeW50YXhFeHRlbnNpb24oYWxsLCBleHRlbnNpb24pIHtcbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGxldCBob29rXG5cbiAgZm9yIChob29rIGluIGV4dGVuc2lvbikge1xuICAgIGNvbnN0IG1heWJlID0gaGFzT3duUHJvcGVydHkuY2FsbChhbGwsIGhvb2spID8gYWxsW2hvb2tdIDogdW5kZWZpbmVkXG4gICAgY29uc3QgbGVmdCA9IG1heWJlIHx8IChhbGxbaG9va10gPSB7fSlcbiAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbltob29rXVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGxldCBjb2RlXG5cbiAgICBmb3IgKGNvZGUgaW4gcmlnaHQpIHtcbiAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsZWZ0LCBjb2RlKSkgbGVmdFtjb2RlXSA9IFtdXG4gICAgICBjb25zdCB2YWx1ZSA9IHJpZ2h0W2NvZGVdXG4gICAgICBjb25zdHJ1Y3RzKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIExvb2tzIGxpa2UgYSBsaXN0LlxuICAgICAgICBsZWZ0W2NvZGVdLFxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogdmFsdWUgPyBbdmFsdWVdIDogW11cbiAgICAgIClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSBgbGlzdGAgaW50byBgZXhpc3RpbmdgIChib3RoIGxpc3RzIG9mIGNvbnN0cnVjdHMpLlxuICogTXV0YXRlcyBgZXhpc3RpbmdgLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bltdfSBleGlzdGluZ1xuICogQHBhcmFtIHt1bmtub3duW119IGxpc3RcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RzKGV4aXN0aW5nLCBsaXN0KSB7XG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7dW5rbm93bltdfSAqL1xuICBjb25zdCBiZWZvcmUgPSBbXVxuXG4gIHdoaWxlICgrK2luZGV4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIExvb2tzIGxpa2UgYW4gb2JqZWN0LlxuICAgIDsobGlzdFtpbmRleF0uYWRkID09PSAnYWZ0ZXInID8gZXhpc3RpbmcgOiBiZWZvcmUpLnB1c2gobGlzdFtpbmRleF0pXG4gIH1cblxuICBzcGxpY2UoZXhpc3RpbmcsIDAsIDAsIGJlZm9yZSlcbn1cblxuLyoqXG4gKiBDb21iaW5lIHNldmVyYWwgSFRNTCBleHRlbnNpb25zIGludG8gb25lLlxuICpcbiAqIEBwYXJhbSB7SHRtbEV4dGVuc2lvbltdfSBodG1sRXh0ZW5zaW9ucyBMaXN0IG9mIEhUTUwgZXh0ZW5zaW9ucy5cbiAqIEByZXR1cm5zIHtIdG1sRXh0ZW5zaW9ufSBBIHNpbmdsZSBjb21iaW5lZCBleHRlbnNpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lSHRtbEV4dGVuc2lvbnMoaHRtbEV4dGVuc2lvbnMpIHtcbiAgLyoqIEB0eXBlIHtIdG1sRXh0ZW5zaW9ufSAqL1xuICBjb25zdCBoYW5kbGVycyA9IHt9XG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBodG1sRXh0ZW5zaW9ucy5sZW5ndGgpIHtcbiAgICBodG1sRXh0ZW5zaW9uKGhhbmRsZXJzLCBodG1sRXh0ZW5zaW9uc1tpbmRleF0pXG4gIH1cblxuICByZXR1cm4gaGFuZGxlcnNcbn1cblxuLyoqXG4gKiBNZXJnZSBgZXh0ZW5zaW9uYCBpbnRvIGBhbGxgLlxuICpcbiAqIEBwYXJhbSB7SHRtbEV4dGVuc2lvbn0gYWxsIEV4dGVuc2lvbiB0byBtZXJnZSBpbnRvLlxuICogQHBhcmFtIHtIdG1sRXh0ZW5zaW9ufSBleHRlbnNpb24gRXh0ZW5zaW9uIHRvIG1lcmdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGh0bWxFeHRlbnNpb24oYWxsLCBleHRlbnNpb24pIHtcbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGxldCBob29rXG5cbiAgZm9yIChob29rIGluIGV4dGVuc2lvbikge1xuICAgIGNvbnN0IG1heWJlID0gaGFzT3duUHJvcGVydHkuY2FsbChhbGwsIGhvb2spID8gYWxsW2hvb2tdIDogdW5kZWZpbmVkXG4gICAgY29uc3QgbGVmdCA9IG1heWJlIHx8IChhbGxbaG9va10gPSB7fSlcbiAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbltob29rXVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGxldCB0eXBlXG5cbiAgICBpZiAocmlnaHQpIHtcbiAgICAgIGZvciAodHlwZSBpbiByaWdodCkge1xuICAgICAgICBsZWZ0W3R5cGVdID0gcmlnaHRbdHlwZV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsICIvLyBUaGlzIG1vZHVsZSBpcyBnZW5lcmF0ZWQgYnkgYHNjcmlwdC9gLlxuLy9cbi8vIENvbW1vbk1hcmsgaGFuZGxlcyBhdHRlbnRpb24gKGVtcGhhc2lzLCBzdHJvbmcpIG1hcmtlcnMgYmFzZWQgb24gd2hhdCBjb21lc1xuLy8gYmVmb3JlIG9yIGFmdGVyIHRoZW0uXG4vLyBPbmUgc3VjaCBkaWZmZXJlbmNlIGlzIGlmIHRob3NlIGNoYXJhY3RlcnMgYXJlIFVuaWNvZGUgcHVuY3R1YXRpb24uXG4vLyBUaGlzIHNjcmlwdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgVW5pY29kZSBkYXRhLlxuZXhwb3J0IGNvbnN0IHVuaWNvZGVQdW5jdHVhdGlvblJlZ2V4ID1cbiAgL1shLS86LUBbLWB7LX5cXHUwMEExXFx1MDBBN1xcdTAwQUJcXHUwMEI2XFx1MDBCN1xcdTAwQkJcXHUwMEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTA5RkRcXHUwQTc2XFx1MEFGMFxcdTBDNzdcXHUwQzg0XFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNEZcXHUyRTUyXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV0vXG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvZGV9IENvZGVcbiAqL1xuaW1wb3J0IHt1bmljb2RlUHVuY3R1YXRpb25SZWdleH0gZnJvbSAnLi9saWIvdW5pY29kZS1wdW5jdHVhdGlvbi1yZWdleC5qcydcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgY2hhcmFjdGVyIGNvZGUgcmVwcmVzZW50cyBhbiBBU0NJSSBhbHBoYSAoYGFgIHRocm91Z2ggYHpgLFxuICogY2FzZSBpbnNlbnNpdGl2ZSkuXG4gKlxuICogQW4gKipBU0NJSSBhbHBoYSoqIGlzIGFuIEFTQ0lJIHVwcGVyIGFscGhhIG9yIEFTQ0lJIGxvd2VyIGFscGhhLlxuICpcbiAqIEFuICoqQVNDSUkgdXBwZXIgYWxwaGEqKiBpcyBhIGNoYXJhY3RlciBpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIFUrMDA0MSAoYEFgKVxuICogdG8gVSswMDVBIChgWmApLlxuICpcbiAqIEFuICoqQVNDSUkgbG93ZXIgYWxwaGEqKiBpcyBhIGNoYXJhY3RlciBpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIFUrMDA2MSAoYGFgKVxuICogdG8gVSswMDdBIChgemApLlxuICovXG5cbmV4cG9ydCBjb25zdCBhc2NpaUFscGhhID0gcmVnZXhDaGVjaygvW0EtWmEtel0vKVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBjaGFyYWN0ZXIgY29kZSByZXByZXNlbnRzIGFuIEFTQ0lJIGRpZ2l0IChgMGAgdGhyb3VnaCBgOWApLlxuICpcbiAqIEFuICoqQVNDSUkgZGlnaXQqKiBpcyBhIGNoYXJhY3RlciBpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIFUrMDAzMCAoYDBgKSB0b1xuICogVSswMDM5IChgOWApLlxuICovXG5cbmV4cG9ydCBjb25zdCBhc2NpaURpZ2l0ID0gcmVnZXhDaGVjaygvXFxkLylcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgY2hhcmFjdGVyIGNvZGUgcmVwcmVzZW50cyBhbiBBU0NJSSBoZXggZGlnaXQgKGBhYCB0aHJvdWdoXG4gKiBgZmAsIGNhc2UgaW5zZW5zaXRpdmUsIG9yIGAwYCB0aHJvdWdoIGA5YCkuXG4gKlxuICogQW4gKipBU0NJSSBoZXggZGlnaXQqKiBpcyBhbiBBU0NJSSBkaWdpdCAoc2VlIGBhc2NpaURpZ2l0YCksIEFTQ0lJIHVwcGVyIGhleFxuICogZGlnaXQsIG9yIGFuIEFTQ0lJIGxvd2VyIGhleCBkaWdpdC5cbiAqXG4gKiBBbiAqKkFTQ0lJIHVwcGVyIGhleCBkaWdpdCoqIGlzIGEgY2hhcmFjdGVyIGluIHRoZSBpbmNsdXNpdmUgcmFuZ2UgVSswMDQxXG4gKiAoYEFgKSB0byBVKzAwNDYgKGBGYCkuXG4gKlxuICogQW4gKipBU0NJSSBsb3dlciBoZXggZGlnaXQqKiBpcyBhIGNoYXJhY3RlciBpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIFUrMDA2MVxuICogKGBhYCkgdG8gVSswMDY2IChgZmApLlxuICovXG5cbmV4cG9ydCBjb25zdCBhc2NpaUhleERpZ2l0ID0gcmVnZXhDaGVjaygvW1xcZEEtRmEtZl0vKVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBjaGFyYWN0ZXIgY29kZSByZXByZXNlbnRzIGFuIEFTQ0lJIGFscGhhbnVtZXJpYyAoYGFgXG4gKiB0aHJvdWdoIGB6YCwgY2FzZSBpbnNlbnNpdGl2ZSwgb3IgYDBgIHRocm91Z2ggYDlgKS5cbiAqXG4gKiBBbiAqKkFTQ0lJIGFscGhhbnVtZXJpYyoqIGlzIGFuIEFTQ0lJIGRpZ2l0IChzZWUgYGFzY2lpRGlnaXRgKSBvciBBU0NJSSBhbHBoYVxuICogKHNlZSBgYXNjaWlBbHBoYWApLlxuICovXG5cbmV4cG9ydCBjb25zdCBhc2NpaUFscGhhbnVtZXJpYyA9IHJlZ2V4Q2hlY2soL1tcXGRBLVphLXpdLylcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgY2hhcmFjdGVyIGNvZGUgcmVwcmVzZW50cyBBU0NJSSBwdW5jdHVhdGlvbi5cbiAqXG4gKiBBbiAqKkFTQ0lJIHB1bmN0dWF0aW9uKiogaXMgYSBjaGFyYWN0ZXIgaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgVSswMDIxXG4gKiBFWENMQU1BVElPTiBNQVJLIChgIWApIHRvIFUrMDAyRiBTTEFTSCAoYC9gKSwgVSswMDNBIENPTE9OIChgOmApIHRvIFUrMDA0MCBBVFxuICogU0lHTiAoYEBgKSwgVSswMDVCIExFRlQgU1FVQVJFIEJSQUNLRVQgKGBbYCkgdG8gVSswMDYwIEdSQVZFIEFDQ0VOVFxuICogKGBgIGAgYGApLCBvciBVKzAwN0IgTEVGVCBDVVJMWSBCUkFDRSAoYHtgKSB0byBVKzAwN0UgVElMREUgKGB+YCkuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGFzY2lpUHVuY3R1YXRpb24gPSByZWdleENoZWNrKC9bIS0vOi1AWy1gey1+XS8pXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGNoYXJhY3RlciBjb2RlIHJlcHJlc2VudHMgYW4gQVNDSUkgYXRleHQuXG4gKlxuICogYXRleHQgaXMgYW4gQVNDSUkgYWxwaGFudW1lcmljIChzZWUgYGFzY2lpQWxwaGFudW1lcmljYCksIG9yIGEgY2hhcmFjdGVyIGluXG4gKiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBVKzAwMjMgTlVNQkVSIFNJR04gKGAjYCkgdG8gVSswMDI3IEFQT1NUUk9QSEUgKGAnYCksXG4gKiBVKzAwMkEgQVNURVJJU0sgKGAqYCksIFUrMDAyQiBQTFVTIFNJR04gKGArYCksIFUrMDAyRCBEQVNIIChgLWApLCBVKzAwMkZcbiAqIFNMQVNIIChgL2ApLCBVKzAwM0QgRVFVQUxTIFRPIChgPWApLCBVKzAwM0YgUVVFU1RJT04gTUFSSyAoYD9gKSwgVSswMDVFXG4gKiBDQVJFVCAoYF5gKSB0byBVKzAwNjAgR1JBVkUgQUNDRU5UIChgYCBgIGBgKSwgb3IgVSswMDdCIExFRlQgQ1VSTFkgQlJBQ0VcbiAqIChge2ApIHRvIFUrMDA3RSBUSUxERSAoYH5gKS5cbiAqXG4gKiBTZWU6XG4gKiAqKlxcW1JGQzUzMjJdKio6XG4gKiBbSW50ZXJuZXQgTWVzc2FnZSBGb3JtYXRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIyKS5cbiAqIFAuIFJlc25pY2suXG4gKiBJRVRGLlxuICovXG5cbmV4cG9ydCBjb25zdCBhc2NpaUF0ZXh0ID0gcmVnZXhDaGVjaygvWyMtJyorXFwtLTk9P0EtWl4tfl0vKVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgY2hhcmFjdGVyIGNvZGUgaXMgYW4gQVNDSUkgY29udHJvbCBjaGFyYWN0ZXIuXG4gKlxuICogQW4gKipBU0NJSSBjb250cm9sKiogaXMgYSBjaGFyYWN0ZXIgaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBVKzAwMDAgTlVMTCAoTlVMKVxuICogdG8gVSswMDFGIChVUyksIG9yIFUrMDA3RiAoREVMKS5cbiAqXG4gKiBAcGFyYW0ge0NvZGV9IGNvZGVcbiAqIEByZXR1cm5zIHtjb2RlIGlzIG51bWJlcn1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYXNjaWlDb250cm9sKGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBTcGVjaWFsIHdoaXRlc3BhY2UgY29kZXMgKHdoaWNoIGhhdmUgbmVnYXRpdmUgdmFsdWVzKSwgQzAgYW5kIENvbnRyb2xcbiAgICAvLyBjaGFyYWN0ZXIgREVMXG4gICAgY29kZSAhPT0gbnVsbCAmJiAoY29kZSA8IDMyIHx8IGNvZGUgPT09IDEyNylcbiAgKVxufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgY2hhcmFjdGVyIGNvZGUgaXMgYSBtYXJrZG93biBsaW5lIGVuZGluZyAoc2VlXG4gKiBgbWFya2Rvd25MaW5lRW5kaW5nYCkgb3IgbWFya2Rvd24gc3BhY2UgKHNlZSBgbWFya2Rvd25TcGFjZWApLlxuICpcbiAqIEBwYXJhbSB7Q29kZX0gY29kZVxuICogQHJldHVybnMge2NvZGUgaXMgbnVtYmVyfVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgIT09IG51bGwgJiYgKGNvZGUgPCAwIHx8IGNvZGUgPT09IDMyKVxufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgY2hhcmFjdGVyIGNvZGUgaXMgYSBtYXJrZG93biBsaW5lIGVuZGluZy5cbiAqXG4gKiBBICoqbWFya2Rvd24gbGluZSBlbmRpbmcqKiBpcyB0aGUgdmlydHVhbCBjaGFyYWN0ZXJzIE0tMDAwMyBDQVJSSUFHRSBSRVRVUk5cbiAqIExJTkUgRkVFRCAoQ1JMRiksIE0tMDAwNCBMSU5FIEZFRUQgKExGKSBhbmQgTS0wMDA1IENBUlJJQUdFIFJFVFVSTiAoQ1IpLlxuICpcbiAqIEluIG1pY3JvbWFyaywgdGhlIGFjdHVhbCBjaGFyYWN0ZXIgVSswMDBBIExJTkUgRkVFRCAoTEYpIGFuZCBVKzAwMEQgQ0FSUklBR0VcbiAqIFJFVFVSTiAoQ1IpIGFyZSByZXBsYWNlZCBieSB0aGVzZSB2aXJ0dWFsIGNoYXJhY3RlcnMgZGVwZW5kaW5nIG9uIHdoZXRoZXJcbiAqIHRoZXkgb2NjdXJyZWQgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtDb2RlfSBjb2RlXG4gKiBAcmV0dXJucyB7Y29kZSBpcyBudW1iZXJ9XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSB7XG4gIHJldHVybiBjb2RlICE9PSBudWxsICYmIGNvZGUgPCAtMlxufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgY2hhcmFjdGVyIGNvZGUgaXMgYSBtYXJrZG93biBzcGFjZS5cbiAqXG4gKiBBICoqbWFya2Rvd24gc3BhY2UqKiBpcyB0aGUgY29uY3JldGUgY2hhcmFjdGVyIFUrMDAyMCBTUEFDRSAoU1ApIGFuZCB0aGVcbiAqIHZpcnR1YWwgY2hhcmFjdGVycyBNLTAwMDEgVklSVFVBTCBTUEFDRSAoVlMpIGFuZCBNLTAwMDIgSE9SSVpPTlRBTCBUQUIgKEhUKS5cbiAqXG4gKiBJbiBtaWNyb21hcmssIHRoZSBhY3R1YWwgY2hhcmFjdGVyIFUrMDAwOSBDSEFSQUNURVIgVEFCVUxBVElPTiAoSFQpIGlzXG4gKiByZXBsYWNlZCBieSBvbmUgTS0wMDAyIEhPUklaT05UQUwgVEFCIChIVCkgYW5kIGJldHdlZW4gMCBhbmQgMyBNLTAwMDEgVklSVFVBTFxuICogU1BBQ0UgKFZTKSBjaGFyYWN0ZXJzLCBkZXBlbmRpbmcgb24gdGhlIGNvbHVtbiBhdCB3aGljaCB0aGUgdGFiIG9jY3VycmVkLlxuICpcbiAqIEBwYXJhbSB7Q29kZX0gY29kZVxuICogQHJldHVybnMge2NvZGUgaXMgbnVtYmVyfVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrZG93blNwYWNlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IC0yIHx8IGNvZGUgPT09IC0xIHx8IGNvZGUgPT09IDMyXG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGNoYXJhY3RlciBjb2RlIHJlcHJlc2VudHMgVW5pY29kZSB3aGl0ZXNwYWNlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGRvZXMgaGFuZGxlIG1pY3JvbWFyayBzcGVjaWZpYyBtYXJrZG93biB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gKiBTZWUgYG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2VgIHRvIGNoZWNrIHRoYXQuXG4gKlxuICogQSAqKlVuaWNvZGUgd2hpdGVzcGFjZSoqIGlzIGEgY2hhcmFjdGVyIGluIHRoZSBVbmljb2RlIGBac2AgKFNlcGFyYXRvcixcbiAqIFNwYWNlKSBjYXRlZ29yeSwgb3IgVSswMDA5IENIQVJBQ1RFUiBUQUJVTEFUSU9OIChIVCksIFUrMDAwQSBMSU5FIEZFRUQgKExGKSxcbiAqIFUrMDAwQyAoRkYpLCBvciBVKzAwMEQgQ0FSUklBR0UgUkVUVVJOIChDUikgKCoqXFxbVU5JQ09ERV0qKikuXG4gKlxuICogU2VlOlxuICogKipcXFtVTklDT0RFXSoqOlxuICogW1RoZSBVbmljb2RlIFN0YW5kYXJkXShodHRwczovL3d3dy51bmljb2RlLm9yZy92ZXJzaW9ucy8pLlxuICogVW5pY29kZSBDb25zb3J0aXVtLlxuICovXG5cbmV4cG9ydCBjb25zdCB1bmljb2RlV2hpdGVzcGFjZSA9IHJlZ2V4Q2hlY2soL1xccy8pXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGNoYXJhY3RlciBjb2RlIHJlcHJlc2VudHMgVW5pY29kZSBwdW5jdHVhdGlvbi5cbiAqXG4gKiBBICoqVW5pY29kZSBwdW5jdHVhdGlvbioqIGlzIGEgY2hhcmFjdGVyIGluIHRoZSBVbmljb2RlIGBQY2AgKFB1bmN0dWF0aW9uLFxuICogQ29ubmVjdG9yKSwgYFBkYCAoUHVuY3R1YXRpb24sIERhc2gpLCBgUGVgIChQdW5jdHVhdGlvbiwgQ2xvc2UpLCBgUGZgXG4gKiAoUHVuY3R1YXRpb24sIEZpbmFsIHF1b3RlKSwgYFBpYCAoUHVuY3R1YXRpb24sIEluaXRpYWwgcXVvdGUpLCBgUG9gXG4gKiAoUHVuY3R1YXRpb24sIE90aGVyKSwgb3IgYFBzYCAoUHVuY3R1YXRpb24sIE9wZW4pIGNhdGVnb3JpZXMsIG9yIGFuIEFTQ0lJXG4gKiBwdW5jdHVhdGlvbiAoc2VlIGBhc2NpaVB1bmN0dWF0aW9uYCkuXG4gKlxuICogU2VlOlxuICogKipcXFtVTklDT0RFXSoqOlxuICogW1RoZSBVbmljb2RlIFN0YW5kYXJkXShodHRwczovL3d3dy51bmljb2RlLm9yZy92ZXJzaW9ucy8pLlxuICogVW5pY29kZSBDb25zb3J0aXVtLlxuICovXG4vLyBTaXplIG5vdGU6IHJlbW92aW5nIEFTQ0lJIGZyb20gdGhlIHJlZ2V4IGFuZCB1c2luZyBgYXNjaWlQdW5jdHVhdGlvbmAgaGVyZVxuLy8gSW4gZmFjdCBhZGRzIHRvIHRoZSBidW5kbGUgc2l6ZS5cblxuZXhwb3J0IGNvbnN0IHVuaWNvZGVQdW5jdHVhdGlvbiA9IHJlZ2V4Q2hlY2sodW5pY29kZVB1bmN0dWF0aW9uUmVnZXgpXG4vKipcbiAqIENyZWF0ZSBhIGNvZGUgY2hlY2sgZnJvbSBhIHJlZ2V4LlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleFxuICogQHJldHVybnMgeyhjb2RlOiBDb2RlKSA9PiBjb2RlIGlzIG51bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiByZWdleENoZWNrKHJlZ2V4KSB7XG4gIHJldHVybiBjaGVja1xuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhIGNvZGUgbWF0Y2hlcyB0aGUgYm91bmQgcmVnZXguXG4gICAqXG4gICAqIEBwYXJhbSB7Q29kZX0gY29kZSBDaGFyYWN0ZXIgY29kZVxuICAgKiBAcmV0dXJucyB7Y29kZSBpcyBudW1iZXJ9IFdoZXRoZXIgdGhlIGNoYXJhY3RlciBjb2RlIG1hdGNoZXMgdGhlIGJvdW5kIHJlZ2V4XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNoZWNrKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSAhPT0gbnVsbCAmJiByZWdleC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRWZmZWN0c30gRWZmZWN0c1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHttYXJrZG93blNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0c30gZWZmZWN0c1xuICogQHBhcmFtIHtTdGF0ZX0gb2tcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gW21heD1JbmZpbml0eV1cbiAqIEByZXR1cm5zIHtTdGF0ZX1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIG9rLCB0eXBlLCBtYXgpIHtcbiAgY29uc3QgbGltaXQgPSBtYXggPyBtYXggLSAxIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIGxldCBzaXplID0gMFxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIodHlwZSlcbiAgICAgIHJldHVybiBwcmVmaXgoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHByZWZpeChjb2RlKSB7XG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkgJiYgc2l6ZSsrIDwgbGltaXQpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHByZWZpeFxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCh0eXBlKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkluaXRpYWxDb25zdHJ1Y3R9IEluaXRpYWxDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSW5pdGlhbGl6ZXJ9IEluaXRpYWxpemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHttYXJrZG93bkxpbmVFbmRpbmd9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqIEB0eXBlIHtJbml0aWFsQ29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IGNvbnRlbnQgPSB7XG4gIHRva2VuaXplOiBpbml0aWFsaXplQ29udGVudFxufVxuLyoqIEB0eXBlIHtJbml0aWFsaXplcn0gKi9cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbnRlbnQoZWZmZWN0cykge1xuICBjb25zdCBjb250ZW50U3RhcnQgPSBlZmZlY3RzLmF0dGVtcHQoXG4gICAgdGhpcy5wYXJzZXIuY29uc3RydWN0cy5jb250ZW50SW5pdGlhbCxcbiAgICBhZnRlckNvbnRlbnRTdGFydENvbnN0cnVjdCxcbiAgICBwYXJhZ3JhcGhJbml0aWFsXG4gIClcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cblxuICBsZXQgcHJldmlvdXNcbiAgcmV0dXJuIGNvbnRlbnRTdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyQ29udGVudFN0YXJ0Q29uc3RydWN0KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgY29udGVudFN0YXJ0LCAnbGluZVByZWZpeCcpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBwYXJhZ3JhcGhJbml0aWFsKGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdwYXJhZ3JhcGgnKVxuICAgIHJldHVybiBsaW5lU3RhcnQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGxpbmVTdGFydChjb2RlKSB7XG4gICAgY29uc3QgdG9rZW4gPSBlZmZlY3RzLmVudGVyKCdjaHVua1RleHQnLCB7XG4gICAgICBjb250ZW50VHlwZTogJ3RleHQnLFxuICAgICAgcHJldmlvdXNcbiAgICB9KVxuXG4gICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICBwcmV2aW91cy5uZXh0ID0gdG9rZW5cbiAgICB9XG5cbiAgICBwcmV2aW91cyA9IHRva2VuXG4gICAgcmV0dXJuIGRhdGEoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRhdGEoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2NodW5rVGV4dCcpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3BhcmFncmFwaCcpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1RleHQnKVxuICAgICAgcmV0dXJuIGxpbmVTdGFydFxuICAgIH0gLy8gRGF0YS5cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBkYXRhXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSW5pdGlhbENvbnN0cnVjdH0gSW5pdGlhbENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Jbml0aWFsaXplcn0gSW5pdGlhbGl6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVDb250ZXh0fSBUb2tlbml6ZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Qb2ludH0gUG9pbnRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gU3RhY2tTdGF0ZVxuICogQHR5cGVkZWYge1tDb25zdHJ1Y3QsIFN0YWNrU3RhdGVdfSBTdGFja0l0ZW1cbiAqL1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHttYXJrZG93bkxpbmVFbmRpbmd9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmltcG9ydCB7c3BsaWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaHVua2VkJ1xuLyoqIEB0eXBlIHtJbml0aWFsQ29uc3RydWN0fSAqL1xuXG5leHBvcnQgY29uc3QgZG9jdW1lbnQgPSB7XG4gIHRva2VuaXplOiBpbml0aWFsaXplRG9jdW1lbnRcbn1cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5jb25zdCBjb250YWluZXJDb25zdHJ1Y3QgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZUNvbnRhaW5lclxufVxuLyoqIEB0eXBlIHtJbml0aWFsaXplcn0gKi9cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZURvY3VtZW50KGVmZmVjdHMpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgLyoqIEB0eXBlIHtBcnJheTxTdGFja0l0ZW0+fSAqL1xuXG4gIGNvbnN0IHN0YWNrID0gW11cbiAgbGV0IGNvbnRpbnVlZCA9IDBcbiAgLyoqIEB0eXBlIHtUb2tlbml6ZUNvbnRleHR8dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBjaGlsZEZsb3dcbiAgLyoqIEB0eXBlIHtUb2tlbnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGNoaWxkVG9rZW5cbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgbGV0IGxpbmVTdGFydE9mZnNldFxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgLy8gRmlyc3Qgd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSBvcGVuIGJsb2Nrcywgc3RhcnRpbmcgd2l0aCB0aGUgcm9vdFxuICAgIC8vIGRvY3VtZW50LCBhbmQgZGVzY2VuZGluZyB0aHJvdWdoIGxhc3QgY2hpbGRyZW4gZG93biB0byB0aGUgbGFzdCBvcGVuXG4gICAgLy8gYmxvY2suXG4gICAgLy8gRWFjaCBibG9jayBpbXBvc2VzIGEgY29uZGl0aW9uIHRoYXQgdGhlIGxpbmUgbXVzdCBzYXRpc2Z5IGlmIHRoZSBibG9jayBpc1xuICAgIC8vIHRvIHJlbWFpbiBvcGVuLlxuICAgIC8vIEZvciBleGFtcGxlLCBhIGJsb2NrIHF1b3RlIHJlcXVpcmVzIGEgYD5gIGNoYXJhY3Rlci5cbiAgICAvLyBBIHBhcmFncmFwaCByZXF1aXJlcyBhIG5vbi1ibGFuayBsaW5lLlxuICAgIC8vIEluIHRoaXMgcGhhc2Ugd2UgbWF5IG1hdGNoIGFsbCBvciBqdXN0IHNvbWUgb2YgdGhlIG9wZW4gYmxvY2tzLlxuICAgIC8vIEJ1dCB3ZSBjYW5ub3QgY2xvc2UgdW5tYXRjaGVkIGJsb2NrcyB5ZXQsIGJlY2F1c2Ugd2UgbWF5IGhhdmUgYSBsYXp5XG4gICAgLy8gY29udGludWF0aW9uIGxpbmUuXG4gICAgaWYgKGNvbnRpbnVlZCA8IHN0YWNrLmxlbmd0aCkge1xuICAgICAgY29uc3QgaXRlbSA9IHN0YWNrW2NvbnRpbnVlZF1cbiAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUgPSBpdGVtWzFdXG4gICAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICBpdGVtWzBdLmNvbnRpbnVhdGlvbixcbiAgICAgICAgZG9jdW1lbnRDb250aW51ZSxcbiAgICAgICAgY2hlY2tOZXdDb250YWluZXJzXG4gICAgICApKGNvZGUpXG4gICAgfSAvLyBEb25lLlxuXG4gICAgcmV0dXJuIGNoZWNrTmV3Q29udGFpbmVycyhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZG9jdW1lbnRDb250aW51ZShjb2RlKSB7XG4gICAgY29udGludWVkKysgLy8gTm90ZTogdGhpcyBmaWVsZCBpcyBjYWxsZWQgYF9jbG9zZUZsb3dgIGJ1dCBpdCBhbHNvIGNsb3NlcyBjb250YWluZXJzLlxuICAgIC8vIFBlcmhhcHMgYSBnb29kIGlkZWEgdG8gcmVuYW1lIGl0IGJ1dCBpdFx1MjAxOXMgYWxyZWFkeSB1c2VkIGluIHRoZSB3aWxkIGJ5XG4gICAgLy8gZXh0ZW5zaW9ucy5cblxuICAgIGlmIChzZWxmLmNvbnRhaW5lclN0YXRlLl9jbG9zZUZsb3cpIHtcbiAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUuX2Nsb3NlRmxvdyA9IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoY2hpbGRGbG93KSB7XG4gICAgICAgIGNsb3NlRmxvdygpXG4gICAgICB9IC8vIE5vdGU6IHRoaXMgYWxnb3JpdGhtIGZvciBtb3ZpbmcgZXZlbnRzIGFyb3VuZCBpcyBzaW1pbGFyIHRvIHRoZVxuICAgICAgLy8gYWxnb3JpdGhtIHdoZW4gZGVhbGluZyB3aXRoIGxhenkgbGluZXMgaW4gYHdyaXRlVG9DaGlsZGAuXG5cbiAgICAgIGNvbnN0IGluZGV4QmVmb3JlRXhpdHMgPSBzZWxmLmV2ZW50cy5sZW5ndGhcbiAgICAgIGxldCBpbmRleEJlZm9yZUZsb3cgPSBpbmRleEJlZm9yZUV4aXRzXG4gICAgICAvKiogQHR5cGUge1BvaW50fHVuZGVmaW5lZH0gKi9cblxuICAgICAgbGV0IHBvaW50IC8vIEZpbmQgdGhlIGZsb3cgY2h1bmsuXG5cbiAgICAgIHdoaWxlIChpbmRleEJlZm9yZUZsb3ctLSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc2VsZi5ldmVudHNbaW5kZXhCZWZvcmVGbG93XVswXSA9PT0gJ2V4aXQnICYmXG4gICAgICAgICAgc2VsZi5ldmVudHNbaW5kZXhCZWZvcmVGbG93XVsxXS50eXBlID09PSAnY2h1bmtGbG93J1xuICAgICAgICApIHtcbiAgICAgICAgICBwb2ludCA9IHNlbGYuZXZlbnRzW2luZGV4QmVmb3JlRmxvd11bMV0uZW5kXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleGl0Q29udGFpbmVycyhjb250aW51ZWQpIC8vIEZpeCBwb3NpdGlvbnMuXG5cbiAgICAgIGxldCBpbmRleCA9IGluZGV4QmVmb3JlRXhpdHNcblxuICAgICAgd2hpbGUgKGluZGV4IDwgc2VsZi5ldmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHNlbGYuZXZlbnRzW2luZGV4XVsxXS5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBwb2ludClcbiAgICAgICAgaW5kZXgrK1xuICAgICAgfSAvLyBJbmplY3QgdGhlIGV4aXRzIGVhcmxpZXIgKHRoZXlcdTIwMTlyZSBzdGlsbCBhbHNvIGF0IHRoZSBlbmQpLlxuXG4gICAgICBzcGxpY2UoXG4gICAgICAgIHNlbGYuZXZlbnRzLFxuICAgICAgICBpbmRleEJlZm9yZUZsb3cgKyAxLFxuICAgICAgICAwLFxuICAgICAgICBzZWxmLmV2ZW50cy5zbGljZShpbmRleEJlZm9yZUV4aXRzKVxuICAgICAgKSAvLyBEaXNjYXJkIHRoZSBkdXBsaWNhdGUgZXhpdHMuXG5cbiAgICAgIHNlbGYuZXZlbnRzLmxlbmd0aCA9IGluZGV4XG4gICAgICByZXR1cm4gY2hlY2tOZXdDb250YWluZXJzKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXJ0KGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjaGVja05ld0NvbnRhaW5lcnMoY29kZSkge1xuICAgIC8vIE5leHQsIGFmdGVyIGNvbnN1bWluZyB0aGUgY29udGludWF0aW9uIG1hcmtlcnMgZm9yIGV4aXN0aW5nIGJsb2Nrcywgd2VcbiAgICAvLyBsb29rIGZvciBuZXcgYmxvY2sgc3RhcnRzIChlLmcuIGA+YCBmb3IgYSBibG9jayBxdW90ZSkuXG4gICAgLy8gSWYgd2UgZW5jb3VudGVyIGEgbmV3IGJsb2NrIHN0YXJ0LCB3ZSBjbG9zZSBhbnkgYmxvY2tzIHVubWF0Y2hlZCBpblxuICAgIC8vIHN0ZXAgMSBiZWZvcmUgY3JlYXRpbmcgdGhlIG5ldyBibG9jayBhcyBhIGNoaWxkIG9mIHRoZSBsYXN0IG1hdGNoZWRcbiAgICAvLyBibG9jay5cbiAgICBpZiAoY29udGludWVkID09PSBzdGFjay5sZW5ndGgpIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gYGNoZWNrYCB3aGV0aGVyIHRoZXJlXHUyMDE5cyBhIGNvbnRhaW5lciwgb2YgYGV4aXRDb250YWluZXJzYFxuICAgICAgLy8gd291bGQgYmUgbW9vdC5cbiAgICAgIC8vIFdlIGNhbiBpbnN0ZWFkIGltbWVkaWF0ZWx5IGBhdHRlbXB0YCB0byBwYXJzZSBvbmUuXG4gICAgICBpZiAoIWNoaWxkRmxvdykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRDb250aW51ZWQoY29kZSlcbiAgICAgIH0gLy8gSWYgd2UgaGF2ZSBjb25jcmV0ZSBjb250ZW50LCBzdWNoIGFzIGJsb2NrIEhUTUwgb3IgZmVuY2VkIGNvZGUsXG4gICAgICAvLyB3ZSBjYW5cdTIwMTl0IGhhdmUgY29udGFpbmVycyBcdTIwMUNwaWVyY2VcdTIwMUQgaW50byB0aGVtLCBzbyB3ZSBjYW4gaW1tZWRpYXRlbHlcbiAgICAgIC8vIHN0YXJ0LlxuXG4gICAgICBpZiAoY2hpbGRGbG93LmN1cnJlbnRDb25zdHJ1Y3QgJiYgY2hpbGRGbG93LmN1cnJlbnRDb25zdHJ1Y3QuY29uY3JldGUpIHtcbiAgICAgICAgcmV0dXJuIGZsb3dTdGFydChjb2RlKVxuICAgICAgfSAvLyBJZiB3ZSBkbyBoYXZlIGZsb3csIGl0IGNvdWxkIHN0aWxsIGJlIGEgYmxhbmsgbGluZSxcbiAgICAgIC8vIGJ1dCB3ZVx1MjAxOWQgYmUgaW50ZXJydXB0aW5nIGl0IHcvIGEgbmV3IGNvbnRhaW5lciBpZiB0aGVyZVx1MjAxOXMgYSBjdXJyZW50XG4gICAgICAvLyBjb25zdHJ1Y3QuXG5cbiAgICAgIHNlbGYuaW50ZXJydXB0ID0gQm9vbGVhbihcbiAgICAgICAgY2hpbGRGbG93LmN1cnJlbnRDb25zdHJ1Y3QgJiYgIWNoaWxkRmxvdy5fZ2ZtVGFibGVEeW5hbWljSW50ZXJydXB0SGFja1xuICAgICAgKVxuICAgIH0gLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgY29udGFpbmVyLlxuXG4gICAgc2VsZi5jb250YWluZXJTdGF0ZSA9IHt9XG4gICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICBjb250YWluZXJDb25zdHJ1Y3QsXG4gICAgICB0aGVyZUlzQU5ld0NvbnRhaW5lcixcbiAgICAgIHRoZXJlSXNOb05ld0NvbnRhaW5lclxuICAgICkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRoZXJlSXNBTmV3Q29udGFpbmVyKGNvZGUpIHtcbiAgICBpZiAoY2hpbGRGbG93KSBjbG9zZUZsb3coKVxuICAgIGV4aXRDb250YWluZXJzKGNvbnRpbnVlZClcbiAgICByZXR1cm4gZG9jdW1lbnRDb250aW51ZWQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRoZXJlSXNOb05ld0NvbnRhaW5lcihjb2RlKSB7XG4gICAgc2VsZi5wYXJzZXIubGF6eVtzZWxmLm5vdygpLmxpbmVdID0gY29udGludWVkICE9PSBzdGFjay5sZW5ndGhcbiAgICBsaW5lU3RhcnRPZmZzZXQgPSBzZWxmLm5vdygpLm9mZnNldFxuICAgIHJldHVybiBmbG93U3RhcnQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRvY3VtZW50Q29udGludWVkKGNvZGUpIHtcbiAgICAvLyBUcnkgbmV3IGNvbnRhaW5lcnMuXG4gICAgc2VsZi5jb250YWluZXJTdGF0ZSA9IHt9XG4gICAgcmV0dXJuIGVmZmVjdHMuYXR0ZW1wdChcbiAgICAgIGNvbnRhaW5lckNvbnN0cnVjdCxcbiAgICAgIGNvbnRhaW5lckNvbnRpbnVlLFxuICAgICAgZmxvd1N0YXJ0XG4gICAgKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29udGFpbmVyQ29udGludWUoY29kZSkge1xuICAgIGNvbnRpbnVlZCsrXG4gICAgc3RhY2sucHVzaChbc2VsZi5jdXJyZW50Q29uc3RydWN0LCBzZWxmLmNvbnRhaW5lclN0YXRlXSkgLy8gVHJ5IGFub3RoZXIuXG5cbiAgICByZXR1cm4gZG9jdW1lbnRDb250aW51ZWQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGZsb3dTdGFydChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZEZsb3cpIGNsb3NlRmxvdygpXG4gICAgICBleGl0Q29udGFpbmVycygwKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjaGlsZEZsb3cgPSBjaGlsZEZsb3cgfHwgc2VsZi5wYXJzZXIuZmxvdyhzZWxmLm5vdygpKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2NodW5rRmxvdycsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiAnZmxvdycsXG4gICAgICBwcmV2aW91czogY2hpbGRUb2tlbixcbiAgICAgIF90b2tlbml6ZXI6IGNoaWxkRmxvd1xuICAgIH0pXG4gICAgcmV0dXJuIGZsb3dDb250aW51ZShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZmxvd0NvbnRpbnVlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgd3JpdGVUb0NoaWxkKGVmZmVjdHMuZXhpdCgnY2h1bmtGbG93JyksIHRydWUpXG4gICAgICBleGl0Q29udGFpbmVycygwKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHdyaXRlVG9DaGlsZChlZmZlY3RzLmV4aXQoJ2NodW5rRmxvdycpKSAvLyBHZXQgcmVhZHkgZm9yIHRoZSBuZXh0IGxpbmUuXG5cbiAgICAgIGNvbnRpbnVlZCA9IDBcbiAgICAgIHNlbGYuaW50ZXJydXB0ID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm4gc3RhcnRcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gZmxvd0NvbnRpbnVlXG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VvZl1cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHdyaXRlVG9DaGlsZCh0b2tlbiwgZW9mKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gc2VsZi5zbGljZVN0cmVhbSh0b2tlbilcbiAgICBpZiAoZW9mKSBzdHJlYW0ucHVzaChudWxsKVxuICAgIHRva2VuLnByZXZpb3VzID0gY2hpbGRUb2tlblxuICAgIGlmIChjaGlsZFRva2VuKSBjaGlsZFRva2VuLm5leHQgPSB0b2tlblxuICAgIGNoaWxkVG9rZW4gPSB0b2tlblxuICAgIGNoaWxkRmxvdy5kZWZpbmVTa2lwKHRva2VuLnN0YXJ0KVxuICAgIGNoaWxkRmxvdy53cml0ZShzdHJlYW0pIC8vIEFscmlnaHQsIHNvIHdlIGp1c3QgYWRkZWQgYSBsYXp5IGxpbmU6XG4gICAgLy9cbiAgICAvLyBgYGBtYXJrZG93blxuICAgIC8vID4gYVxuICAgIC8vIGIuXG4gICAgLy9cbiAgICAvLyBPcjpcbiAgICAvL1xuICAgIC8vID4gfn5+Y1xuICAgIC8vIGRcbiAgICAvL1xuICAgIC8vIE9yOlxuICAgIC8vXG4gICAgLy8gPiB8IGUgfFxuICAgIC8vIGZcbiAgICAvLyBgYGBcbiAgICAvL1xuICAgIC8vIFRoZSBjb25zdHJ1Y3QgaW4gdGhlIHNlY29uZCBleGFtcGxlIChmZW5jZWQgY29kZSkgZG9lcyBub3QgYWNjZXB0IGxhenlcbiAgICAvLyBsaW5lcywgc28gaXQgbWFya2VkIGl0c2VsZiBhcyBkb25lIGF0IHRoZSBlbmQgb2YgaXRzIGZpcnN0IGxpbmUsIGFuZFxuICAgIC8vIHRoZW4gdGhlIGNvbnRlbnQgY29uc3RydWN0IHBhcnNlcyBgZGAuXG4gICAgLy8gTW9zdCBjb25zdHJ1Y3RzIGluIG1hcmtkb3duIG1hdGNoIG9uIHRoZSBmaXJzdCBsaW5lOiBpZiB0aGUgZmlyc3QgbGluZVxuICAgIC8vIGZvcm1zIGEgY29uc3RydWN0LCBhIG5vbi1sYXp5IGxpbmUgY2FuXHUyMDE5dCBcdTIwMUN1bm1ha2VcdTIwMUQgaXQuXG4gICAgLy9cbiAgICAvLyBUaGUgY29uc3RydWN0IGluIHRoZSB0aGlyZCBleGFtcGxlIGlzIHBvdGVudGlhbGx5IGEgR0ZNIHRhYmxlLCBhbmRcbiAgICAvLyB0aG9zZSBhcmUgKndlaXJkKi5cbiAgICAvLyBJdCAqY291bGQqIGJlIGEgdGFibGUsIGZyb20gdGhlIGZpcnN0IGxpbmUsIGlmIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgIC8vIG1hdGNoZXMgYSBjb25kaXRpb24uXG4gICAgLy8gSW4gdGhpcyBjYXNlLCB0aGF0IHNlY29uZCBsaW5lIGlzIGxhenksIHdoaWNoIFx1MjAxQ3VubWFrZXNcdTIwMUQgdGhlIGZpcnN0IGxpbmVcbiAgICAvLyBhbmQgdHVybnMgdGhlIHdob2xlIGludG8gb25lIGNvbnRlbnQgYmxvY2suXG4gICAgLy9cbiAgICAvLyBXZVx1MjAxOXZlIG5vdyBwYXJzZWQgdGhlIG5vbi1sYXp5IGFuZCB0aGUgbGF6eSBsaW5lLCBhbmQgY2FuIGZpZ3VyZSBvdXRcbiAgICAvLyB3aGV0aGVyIHRoZSBsYXp5IGxpbmUgc3RhcnRlZCBhIG5ldyBmbG93IGJsb2NrLlxuICAgIC8vIElmIGl0IGRpZCwgd2UgZXhpdCB0aGUgY3VycmVudCBjb250YWluZXJzIGJldHdlZW4gdGhlIHR3byBmbG93IGJsb2Nrcy5cblxuICAgIGlmIChzZWxmLnBhcnNlci5sYXp5W3Rva2VuLnN0YXJ0LmxpbmVdKSB7XG4gICAgICBsZXQgaW5kZXggPSBjaGlsZEZsb3cuZXZlbnRzLmxlbmd0aFxuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gVGhlIHRva2VuIHN0YXJ0cyBiZWZvcmUgdGhlIGxpbmUgZW5kaW5nXHUyMDI2XG4gICAgICAgICAgY2hpbGRGbG93LmV2ZW50c1tpbmRleF1bMV0uc3RhcnQub2Zmc2V0IDwgbGluZVN0YXJ0T2Zmc2V0ICYmIC8vIFx1MjAyNmFuZCBlaXRoZXIgaXMgbm90IGVuZGVkIHlldFx1MjAyNlxuICAgICAgICAgICghY2hpbGRGbG93LmV2ZW50c1tpbmRleF1bMV0uZW5kIHx8IC8vIFx1MjAyNm9yIGVuZHMgYWZ0ZXIgaXQuXG4gICAgICAgICAgICBjaGlsZEZsb3cuZXZlbnRzW2luZGV4XVsxXS5lbmQub2Zmc2V0ID4gbGluZVN0YXJ0T2Zmc2V0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBFeGl0OiB0aGVyZVx1MjAxOXMgc3RpbGwgc29tZXRoaW5nIG9wZW4sIHdoaWNoIG1lYW5zIGl0XHUyMDE5cyBhIGxhenkgbGluZVxuICAgICAgICAgIC8vIHBhcnQgb2Ygc29tZXRoaW5nLlxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9IC8vIE5vdGU6IHRoaXMgYWxnb3JpdGhtIGZvciBtb3ZpbmcgZXZlbnRzIGFyb3VuZCBpcyBzaW1pbGFyIHRvIHRoZVxuICAgICAgLy8gYWxnb3JpdGhtIHdoZW4gY2xvc2luZyBmbG93IGluIGBkb2N1bWVudENvbnRpbnVlYC5cblxuICAgICAgY29uc3QgaW5kZXhCZWZvcmVFeGl0cyA9IHNlbGYuZXZlbnRzLmxlbmd0aFxuICAgICAgbGV0IGluZGV4QmVmb3JlRmxvdyA9IGluZGV4QmVmb3JlRXhpdHNcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG5cbiAgICAgIGxldCBzZWVuXG4gICAgICAvKiogQHR5cGUge1BvaW50fHVuZGVmaW5lZH0gKi9cblxuICAgICAgbGV0IHBvaW50IC8vIEZpbmQgdGhlIHByZXZpb3VzIGNodW5rICh0aGUgb25lIGJlZm9yZSB0aGUgbGF6eSBsaW5lKS5cblxuICAgICAgd2hpbGUgKGluZGV4QmVmb3JlRmxvdy0tKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzZWxmLmV2ZW50c1tpbmRleEJlZm9yZUZsb3ddWzBdID09PSAnZXhpdCcgJiZcbiAgICAgICAgICBzZWxmLmV2ZW50c1tpbmRleEJlZm9yZUZsb3ddWzFdLnR5cGUgPT09ICdjaHVua0Zsb3cnXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBwb2ludCA9IHNlbGYuZXZlbnRzW2luZGV4QmVmb3JlRmxvd11bMV0uZW5kXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlZW4gPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXhpdENvbnRhaW5lcnMoY29udGludWVkKSAvLyBGaXggcG9zaXRpb25zLlxuXG4gICAgICBpbmRleCA9IGluZGV4QmVmb3JlRXhpdHNcblxuICAgICAgd2hpbGUgKGluZGV4IDwgc2VsZi5ldmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHNlbGYuZXZlbnRzW2luZGV4XVsxXS5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBwb2ludClcbiAgICAgICAgaW5kZXgrK1xuICAgICAgfSAvLyBJbmplY3QgdGhlIGV4aXRzIGVhcmxpZXIgKHRoZXlcdTIwMTlyZSBzdGlsbCBhbHNvIGF0IHRoZSBlbmQpLlxuXG4gICAgICBzcGxpY2UoXG4gICAgICAgIHNlbGYuZXZlbnRzLFxuICAgICAgICBpbmRleEJlZm9yZUZsb3cgKyAxLFxuICAgICAgICAwLFxuICAgICAgICBzZWxmLmV2ZW50cy5zbGljZShpbmRleEJlZm9yZUV4aXRzKVxuICAgICAgKSAvLyBEaXNjYXJkIHRoZSBkdXBsaWNhdGUgZXhpdHMuXG5cbiAgICAgIHNlbGYuZXZlbnRzLmxlbmd0aCA9IGluZGV4XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cbiAgZnVuY3Rpb24gZXhpdENvbnRhaW5lcnMoc2l6ZSkge1xuICAgIGxldCBpbmRleCA9IHN0YWNrLmxlbmd0aCAvLyBFeGl0IG9wZW4gY29udGFpbmVycy5cblxuICAgIHdoaWxlIChpbmRleC0tID4gc2l6ZSkge1xuICAgICAgY29uc3QgZW50cnkgPSBzdGFja1tpbmRleF1cbiAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUgPSBlbnRyeVsxXVxuICAgICAgZW50cnlbMF0uZXhpdC5jYWxsKHNlbGYsIGVmZmVjdHMpXG4gICAgfVxuXG4gICAgc3RhY2subGVuZ3RoID0gc2l6ZVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VGbG93KCkge1xuICAgIGNoaWxkRmxvdy53cml0ZShbbnVsbF0pXG4gICAgY2hpbGRUb2tlbiA9IHVuZGVmaW5lZFxuICAgIGNoaWxkRmxvdyA9IHVuZGVmaW5lZFxuICAgIHNlbGYuY29udGFpbmVyU3RhdGUuX2Nsb3NlRmxvdyA9IHVuZGVmaW5lZFxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVDb250YWluZXIoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgIGVmZmVjdHMsXG4gICAgZWZmZWN0cy5hdHRlbXB0KHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuZG9jdW1lbnQsIG9rLCBub2spLFxuICAgICdsaW5lUHJlZml4JyxcbiAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcygnY29kZUluZGVudGVkJykgPyB1bmRlZmluZWQgOiA0XG4gIClcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICovXG5pbXBvcnQge1xuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICB1bmljb2RlUHVuY3R1YXRpb24sXG4gIHVuaWNvZGVXaGl0ZXNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqXG4gKiBDbGFzc2lmeSB3aGV0aGVyIGEgY2hhcmFjdGVyIGNvZGUgcmVwcmVzZW50cyB3aGl0ZXNwYWNlLCBwdW5jdHVhdGlvbiwgb3JcbiAqIHNvbWV0aGluZyBlbHNlLlxuICpcbiAqIFVzZWQgZm9yIGF0dGVudGlvbiAoZW1waGFzaXMsIHN0cm9uZyksIHdob3NlIHNlcXVlbmNlcyBjYW4gb3BlbiBvciBjbG9zZVxuICogYmFzZWQgb24gdGhlIGNsYXNzIG9mIHN1cnJvdW5kaW5nIGNoYXJhY3RlcnMuXG4gKlxuICogTm90ZSB0aGF0IGVvZiAoYG51bGxgKSBpcyBzZWVuIGFzIHdoaXRlc3BhY2UuXG4gKlxuICogQHBhcmFtIHtDb2RlfSBjb2RlXG4gKiBAcmV0dXJucyB7bnVtYmVyfHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzaWZ5Q2hhcmFjdGVyKGNvZGUpIHtcbiAgaWYgKFxuICAgIGNvZGUgPT09IG51bGwgfHxcbiAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpIHx8XG4gICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSlcbiAgKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIGlmICh1bmljb2RlUHVuY3R1YXRpb24oY29kZSkpIHtcbiAgICByZXR1cm4gMlxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplQ29udGV4dH0gVG9rZW5pemVDb250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqL1xuXG4vKipcbiAqIENhbGwgYWxsIGByZXNvbHZlQWxsYHMuXG4gKlxuICogQHBhcmFtIHt7cmVzb2x2ZUFsbD86IFJlc29sdmVyfVtdfSBjb25zdHJ1Y3RzXG4gKiBAcGFyYW0ge0V2ZW50W119IGV2ZW50c1xuICogQHBhcmFtIHtUb2tlbml6ZUNvbnRleHR9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFdmVudFtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFsbChjb25zdHJ1Y3RzLCBldmVudHMsIGNvbnRleHQpIHtcbiAgLyoqIEB0eXBlIHtSZXNvbHZlcltdfSAqL1xuICBjb25zdCBjYWxsZWQgPSBbXVxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgY29uc3RydWN0cy5sZW5ndGgpIHtcbiAgICBjb25zdCByZXNvbHZlID0gY29uc3RydWN0c1tpbmRleF0ucmVzb2x2ZUFsbFxuXG4gICAgaWYgKHJlc29sdmUgJiYgIWNhbGxlZC5pbmNsdWRlcyhyZXNvbHZlKSkge1xuICAgICAgZXZlbnRzID0gcmVzb2x2ZShldmVudHMsIGNvbnRleHQpXG4gICAgICBjYWxsZWQucHVzaChyZXNvbHZlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudHNcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUmVzb2x2ZXJ9IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvZGV9IENvZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUG9pbnR9IFBvaW50XG4gKi9cbmltcG9ydCB7cHVzaCwgc3BsaWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaHVua2VkJ1xuaW1wb3J0IHtjbGFzc2lmeUNoYXJhY3Rlcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2xhc3NpZnktY2hhcmFjdGVyJ1xuaW1wb3J0IHtyZXNvbHZlQWxsfSBmcm9tICdtaWNyb21hcmstdXRpbC1yZXNvbHZlLWFsbCdcblxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5leHBvcnQgY29uc3QgYXR0ZW50aW9uID0ge1xuICBuYW1lOiAnYXR0ZW50aW9uJyxcbiAgdG9rZW5pemU6IHRva2VuaXplQXR0ZW50aW9uLFxuICByZXNvbHZlQWxsOiByZXNvbHZlQWxsQXR0ZW50aW9uXG59XG4vKipcbiAqIFRha2UgYWxsIGV2ZW50cyBhbmQgcmVzb2x2ZSBhdHRlbnRpb24gdG8gZW1waGFzaXMgb3Igc3Ryb25nLlxuICpcbiAqIEB0eXBlIHtSZXNvbHZlcn1cbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQWxsQXR0ZW50aW9uKGV2ZW50cywgY29udGV4dCkge1xuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICBsZXQgb3BlblxuICAvKiogQHR5cGUge1Rva2VufSAqL1xuXG4gIGxldCBncm91cFxuICAvKiogQHR5cGUge1Rva2VufSAqL1xuXG4gIGxldCB0ZXh0XG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG5cbiAgbGV0IG9wZW5pbmdTZXF1ZW5jZVxuICAvKiogQHR5cGUge1Rva2VufSAqL1xuXG4gIGxldCBjbG9zaW5nU2VxdWVuY2VcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgbGV0IHVzZVxuICAvKiogQHR5cGUge0V2ZW50W119ICovXG5cbiAgbGV0IG5leHRFdmVudHNcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgbGV0IG9mZnNldCAvLyBXYWxrIHRocm91Z2ggYWxsIGV2ZW50cy5cbiAgLy9cbiAgLy8gTm90ZTogcGVyZm9ybWFuY2Ugb2YgdGhpcyBpcyBmaW5lIG9uIGFuIG1iIG9mIG5vcm1hbCBtYXJrZG93biwgYnV0IGl0XHUyMDE5c1xuICAvLyBhIGJvdHRsZW5lY2sgZm9yIG1hbGljaW91cyBzdHVmZi5cblxuICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAvLyBGaW5kIGEgdG9rZW4gdGhhdCBjYW4gY2xvc2UuXG4gICAgaWYgKFxuICAgICAgZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJyAmJlxuICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnYXR0ZW50aW9uU2VxdWVuY2UnICYmXG4gICAgICBldmVudHNbaW5kZXhdWzFdLl9jbG9zZVxuICAgICkge1xuICAgICAgb3BlbiA9IGluZGV4IC8vIE5vdyB3YWxrIGJhY2sgdG8gZmluZCBhbiBvcGVuZXIuXG5cbiAgICAgIHdoaWxlIChvcGVuLS0pIHtcbiAgICAgICAgLy8gRmluZCBhIHRva2VuIHRoYXQgY2FuIG9wZW4gdGhlIGNsb3Nlci5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGV2ZW50c1tvcGVuXVswXSA9PT0gJ2V4aXQnICYmXG4gICAgICAgICAgZXZlbnRzW29wZW5dWzFdLnR5cGUgPT09ICdhdHRlbnRpb25TZXF1ZW5jZScgJiZcbiAgICAgICAgICBldmVudHNbb3Blbl1bMV0uX29wZW4gJiYgLy8gSWYgdGhlIG1hcmtlcnMgYXJlIHRoZSBzYW1lOlxuICAgICAgICAgIGNvbnRleHQuc2xpY2VTZXJpYWxpemUoZXZlbnRzW29wZW5dWzFdKS5jaGFyQ29kZUF0KDApID09PVxuICAgICAgICAgICAgY29udGV4dC5zbGljZVNlcmlhbGl6ZShldmVudHNbaW5kZXhdWzFdKS5jaGFyQ29kZUF0KDApXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIElmIHRoZSBvcGVuaW5nIGNhbiBjbG9zZSBvciB0aGUgY2xvc2luZyBjYW4gb3BlbixcbiAgICAgICAgICAvLyBhbmQgdGhlIGNsb3NlIHNpemUgKmlzIG5vdCogYSBtdWx0aXBsZSBvZiB0aHJlZSxcbiAgICAgICAgICAvLyBidXQgdGhlIHN1bSBvZiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBzaXplICppcyogbXVsdGlwbGUgb2YgdGhyZWUsXG4gICAgICAgICAgLy8gdGhlbiBkb25cdTIwMTl0IG1hdGNoLlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChldmVudHNbb3Blbl1bMV0uX2Nsb3NlIHx8IGV2ZW50c1tpbmRleF1bMV0uX29wZW4pICYmXG4gICAgICAgICAgICAoZXZlbnRzW2luZGV4XVsxXS5lbmQub2Zmc2V0IC0gZXZlbnRzW2luZGV4XVsxXS5zdGFydC5vZmZzZXQpICUgMyAmJlxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgKGV2ZW50c1tvcGVuXVsxXS5lbmQub2Zmc2V0IC1cbiAgICAgICAgICAgICAgICBldmVudHNbb3Blbl1bMV0uc3RhcnQub2Zmc2V0ICtcbiAgICAgICAgICAgICAgICBldmVudHNbaW5kZXhdWzFdLmVuZC5vZmZzZXQgLVxuICAgICAgICAgICAgICAgIGV2ZW50c1tpbmRleF1bMV0uc3RhcnQub2Zmc2V0KSAlXG4gICAgICAgICAgICAgIDNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSAvLyBOdW1iZXIgb2YgbWFya2VycyB0byB1c2UgZnJvbSB0aGUgc2VxdWVuY2UuXG5cbiAgICAgICAgICB1c2UgPVxuICAgICAgICAgICAgZXZlbnRzW29wZW5dWzFdLmVuZC5vZmZzZXQgLSBldmVudHNbb3Blbl1bMV0uc3RhcnQub2Zmc2V0ID4gMSAmJlxuICAgICAgICAgICAgZXZlbnRzW2luZGV4XVsxXS5lbmQub2Zmc2V0IC0gZXZlbnRzW2luZGV4XVsxXS5zdGFydC5vZmZzZXQgPiAxXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcbiAgICAgICAgICBjb25zdCBzdGFydCA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tvcGVuXVsxXS5lbmQpXG4gICAgICAgICAgY29uc3QgZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2luZGV4XVsxXS5zdGFydClcbiAgICAgICAgICBtb3ZlUG9pbnQoc3RhcnQsIC11c2UpXG4gICAgICAgICAgbW92ZVBvaW50KGVuZCwgdXNlKVxuICAgICAgICAgIG9wZW5pbmdTZXF1ZW5jZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHVzZSA+IDEgPyAnc3Ryb25nU2VxdWVuY2UnIDogJ2VtcGhhc2lzU2VxdWVuY2UnLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tvcGVuXVsxXS5lbmQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNsb3NpbmdTZXF1ZW5jZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHVzZSA+IDEgPyAnc3Ryb25nU2VxdWVuY2UnIDogJ2VtcGhhc2lzU2VxdWVuY2UnLFxuICAgICAgICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tpbmRleF1bMV0uc3RhcnQpLFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHQgPSB7XG4gICAgICAgICAgICB0eXBlOiB1c2UgPiAxID8gJ3N0cm9uZ1RleHQnIDogJ2VtcGhhc2lzVGV4dCcsXG4gICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW29wZW5dWzFdLmVuZCksXG4gICAgICAgICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tpbmRleF1bMV0uc3RhcnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGdyb3VwID0ge1xuICAgICAgICAgICAgdHlwZTogdXNlID4gMSA/ICdzdHJvbmcnIDogJ2VtcGhhc2lzJyxcbiAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBvcGVuaW5nU2VxdWVuY2Uuc3RhcnQpLFxuICAgICAgICAgICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBjbG9zaW5nU2VxdWVuY2UuZW5kKVxuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudHNbb3Blbl1bMV0uZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgb3BlbmluZ1NlcXVlbmNlLnN0YXJ0KVxuICAgICAgICAgIGV2ZW50c1tpbmRleF1bMV0uc3RhcnQgPSBPYmplY3QuYXNzaWduKHt9LCBjbG9zaW5nU2VxdWVuY2UuZW5kKVxuICAgICAgICAgIG5leHRFdmVudHMgPSBbXSAvLyBJZiB0aGVyZSBhcmUgbW9yZSBtYXJrZXJzIGluIHRoZSBvcGVuaW5nLCBhZGQgdGhlbSBiZWZvcmUuXG5cbiAgICAgICAgICBpZiAoZXZlbnRzW29wZW5dWzFdLmVuZC5vZmZzZXQgLSBldmVudHNbb3Blbl1bMV0uc3RhcnQub2Zmc2V0KSB7XG4gICAgICAgICAgICBuZXh0RXZlbnRzID0gcHVzaChuZXh0RXZlbnRzLCBbXG4gICAgICAgICAgICAgIFsnZW50ZXInLCBldmVudHNbb3Blbl1bMV0sIGNvbnRleHRdLFxuICAgICAgICAgICAgICBbJ2V4aXQnLCBldmVudHNbb3Blbl1bMV0sIGNvbnRleHRdXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIH0gLy8gT3BlbmluZy5cblxuICAgICAgICAgIG5leHRFdmVudHMgPSBwdXNoKG5leHRFdmVudHMsIFtcbiAgICAgICAgICAgIFsnZW50ZXInLCBncm91cCwgY29udGV4dF0sXG4gICAgICAgICAgICBbJ2VudGVyJywgb3BlbmluZ1NlcXVlbmNlLCBjb250ZXh0XSxcbiAgICAgICAgICAgIFsnZXhpdCcsIG9wZW5pbmdTZXF1ZW5jZSwgY29udGV4dF0sXG4gICAgICAgICAgICBbJ2VudGVyJywgdGV4dCwgY29udGV4dF1cbiAgICAgICAgICBdKSAvLyBCZXR3ZWVuLlxuXG4gICAgICAgICAgbmV4dEV2ZW50cyA9IHB1c2goXG4gICAgICAgICAgICBuZXh0RXZlbnRzLFxuICAgICAgICAgICAgcmVzb2x2ZUFsbChcbiAgICAgICAgICAgICAgY29udGV4dC5wYXJzZXIuY29uc3RydWN0cy5pbnNpZGVTcGFuLm51bGwsXG4gICAgICAgICAgICAgIGV2ZW50cy5zbGljZShvcGVuICsgMSwgaW5kZXgpLFxuICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICApXG4gICAgICAgICAgKSAvLyBDbG9zaW5nLlxuXG4gICAgICAgICAgbmV4dEV2ZW50cyA9IHB1c2gobmV4dEV2ZW50cywgW1xuICAgICAgICAgICAgWydleGl0JywgdGV4dCwgY29udGV4dF0sXG4gICAgICAgICAgICBbJ2VudGVyJywgY2xvc2luZ1NlcXVlbmNlLCBjb250ZXh0XSxcbiAgICAgICAgICAgIFsnZXhpdCcsIGNsb3NpbmdTZXF1ZW5jZSwgY29udGV4dF0sXG4gICAgICAgICAgICBbJ2V4aXQnLCBncm91cCwgY29udGV4dF1cbiAgICAgICAgICBdKSAvLyBJZiB0aGVyZSBhcmUgbW9yZSBtYXJrZXJzIGluIHRoZSBjbG9zaW5nLCBhZGQgdGhlbSBhZnRlci5cblxuICAgICAgICAgIGlmIChldmVudHNbaW5kZXhdWzFdLmVuZC5vZmZzZXQgLSBldmVudHNbaW5kZXhdWzFdLnN0YXJ0Lm9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMlxuICAgICAgICAgICAgbmV4dEV2ZW50cyA9IHB1c2gobmV4dEV2ZW50cywgW1xuICAgICAgICAgICAgICBbJ2VudGVyJywgZXZlbnRzW2luZGV4XVsxXSwgY29udGV4dF0sXG4gICAgICAgICAgICAgIFsnZXhpdCcsIGV2ZW50c1tpbmRleF1bMV0sIGNvbnRleHRdXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3BsaWNlKGV2ZW50cywgb3BlbiAtIDEsIGluZGV4IC0gb3BlbiArIDMsIG5leHRFdmVudHMpXG4gICAgICAgICAgaW5kZXggPSBvcGVuICsgbmV4dEV2ZW50cy5sZW5ndGggLSBvZmZzZXQgLSAyXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW1vdmUgcmVtYWluaW5nIHNlcXVlbmNlcy5cblxuICBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgaWYgKGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ2F0dGVudGlvblNlcXVlbmNlJykge1xuICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID0gJ2RhdGEnXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplQXR0ZW50aW9uKGVmZmVjdHMsIG9rKSB7XG4gIGNvbnN0IGF0dGVudGlvbk1hcmtlcnMgPSB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmF0dGVudGlvbk1hcmtlcnMubnVsbFxuICBjb25zdCBwcmV2aW91cyA9IHRoaXMucHJldmlvdXNcbiAgY29uc3QgYmVmb3JlID0gY2xhc3NpZnlDaGFyYWN0ZXIocHJldmlvdXMpXG4gIC8qKiBAdHlwZSB7Tm9uTnVsbGFibGU8Q29kZT59ICovXG5cbiAgbGV0IG1hcmtlclxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignYXR0ZW50aW9uU2VxdWVuY2UnKVxuICAgIG1hcmtlciA9IGNvZGVcbiAgICByZXR1cm4gc2VxdWVuY2UoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHNlcXVlbmNlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBzZXF1ZW5jZVxuICAgIH1cblxuICAgIGNvbnN0IHRva2VuID0gZWZmZWN0cy5leGl0KCdhdHRlbnRpb25TZXF1ZW5jZScpXG4gICAgY29uc3QgYWZ0ZXIgPSBjbGFzc2lmeUNoYXJhY3Rlcihjb2RlKVxuICAgIGNvbnN0IG9wZW4gPVxuICAgICAgIWFmdGVyIHx8IChhZnRlciA9PT0gMiAmJiBiZWZvcmUpIHx8IGF0dGVudGlvbk1hcmtlcnMuaW5jbHVkZXMoY29kZSlcbiAgICBjb25zdCBjbG9zZSA9XG4gICAgICAhYmVmb3JlIHx8IChiZWZvcmUgPT09IDIgJiYgYWZ0ZXIpIHx8IGF0dGVudGlvbk1hcmtlcnMuaW5jbHVkZXMocHJldmlvdXMpXG4gICAgdG9rZW4uX29wZW4gPSBCb29sZWFuKG1hcmtlciA9PT0gNDIgPyBvcGVuIDogb3BlbiAmJiAoYmVmb3JlIHx8ICFjbG9zZSkpXG4gICAgdG9rZW4uX2Nsb3NlID0gQm9vbGVhbihtYXJrZXIgPT09IDQyID8gY2xvc2UgOiBjbG9zZSAmJiAoYWZ0ZXIgfHwgIW9wZW4pKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG4vKipcbiAqIE1vdmUgYSBwb2ludCBhIGJpdC5cbiAqXG4gKiBOb3RlOiBgbW92ZWAgb25seSB3b3JrcyBpbnNpZGUgbGluZXMhIEl0XHUyMDE5cyBub3QgcG9zc2libGUgdG8gbW92ZSBwYXN0IG90aGVyXG4gKiBjaHVua3MgKHJlcGxhY2VtZW50IGNoYXJhY3RlcnMsIHRhYnMsIG9yIGxpbmUgZW5kaW5ncykuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cbmZ1bmN0aW9uIG1vdmVQb2ludChwb2ludCwgb2Zmc2V0KSB7XG4gIHBvaW50LmNvbHVtbiArPSBvZmZzZXRcbiAgcG9pbnQub2Zmc2V0ICs9IG9mZnNldFxuICBwb2ludC5fYnVmZmVySW5kZXggKz0gb2Zmc2V0XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge1xuICBhc2NpaUFscGhhLFxuICBhc2NpaUFscGhhbnVtZXJpYyxcbiAgYXNjaWlBdGV4dCxcbiAgYXNjaWlDb250cm9sXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5leHBvcnQgY29uc3QgYXV0b2xpbmsgPSB7XG4gIG5hbWU6ICdhdXRvbGluaycsXG4gIHRva2VuaXplOiB0b2tlbml6ZUF1dG9saW5rXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVBdXRvbGluayhlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGxldCBzaXplID0gMVxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignYXV0b2xpbmsnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2F1dG9saW5rTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2F1dG9saW5rTWFya2VyJylcbiAgICBlZmZlY3RzLmVudGVyKCdhdXRvbGlua1Byb3RvY29sJylcbiAgICByZXR1cm4gb3BlblxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb3Blbihjb2RlKSB7XG4gICAgaWYgKGFzY2lpQWxwaGEoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHNjaGVtZU9yRW1haWxBdGV4dFxuICAgIH1cblxuICAgIHJldHVybiBhc2NpaUF0ZXh0KGNvZGUpID8gZW1haWxBdGV4dChjb2RlKSA6IG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc2NoZW1lT3JFbWFpbEF0ZXh0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gNDMgfHwgY29kZSA9PT0gNDUgfHwgY29kZSA9PT0gNDYgfHwgYXNjaWlBbHBoYW51bWVyaWMoY29kZSlcbiAgICAgID8gc2NoZW1lSW5zaWRlT3JFbWFpbEF0ZXh0KGNvZGUpXG4gICAgICA6IGVtYWlsQXRleHQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHNjaGVtZUluc2lkZU9yRW1haWxBdGV4dChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDU4KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB1cmxJbnNpZGVcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAoY29kZSA9PT0gNDMgfHwgY29kZSA9PT0gNDUgfHwgY29kZSA9PT0gNDYgfHwgYXNjaWlBbHBoYW51bWVyaWMoY29kZSkpICYmXG4gICAgICBzaXplKysgPCAzMlxuICAgICkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gc2NoZW1lSW5zaWRlT3JFbWFpbEF0ZXh0XG4gICAgfVxuXG4gICAgcmV0dXJuIGVtYWlsQXRleHQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHVybEluc2lkZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDYyKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2F1dG9saW5rUHJvdG9jb2wnKVxuICAgICAgcmV0dXJuIGVuZChjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IDMyIHx8IGNvZGUgPT09IDYwIHx8IGFzY2lpQ29udHJvbChjb2RlKSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiB1cmxJbnNpZGVcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGVtYWlsQXRleHQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA2NCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBzaXplID0gMFxuICAgICAgcmV0dXJuIGVtYWlsQXRTaWduT3JEb3RcbiAgICB9XG5cbiAgICBpZiAoYXNjaWlBdGV4dChjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZW1haWxBdGV4dFxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGVtYWlsQXRTaWduT3JEb3QoY29kZSkge1xuICAgIHJldHVybiBhc2NpaUFscGhhbnVtZXJpYyhjb2RlKSA/IGVtYWlsTGFiZWwoY29kZSkgOiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGVtYWlsTGFiZWwoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0Nikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBzaXplID0gMFxuICAgICAgcmV0dXJuIGVtYWlsQXRTaWduT3JEb3RcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgIC8vIEV4aXQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlLlxuICAgICAgZWZmZWN0cy5leGl0KCdhdXRvbGlua1Byb3RvY29sJykudHlwZSA9ICdhdXRvbGlua0VtYWlsJ1xuICAgICAgcmV0dXJuIGVuZChjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBlbWFpbFZhbHVlKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBlbWFpbFZhbHVlKGNvZGUpIHtcbiAgICBpZiAoKGNvZGUgPT09IDQ1IHx8IGFzY2lpQWxwaGFudW1lcmljKGNvZGUpKSAmJiBzaXplKysgPCA2Mykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29kZSA9PT0gNDUgPyBlbWFpbFZhbHVlIDogZW1haWxMYWJlbFxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGVuZChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignYXV0b2xpbmtNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnYXV0b2xpbmtNYXJrZXInKVxuICAgIGVmZmVjdHMuZXhpdCgnYXV0b2xpbmsnKVxuICAgIHJldHVybiBva1xuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBibGFua0xpbmUgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZUJsYW5rTGluZSxcbiAgcGFydGlhbDogdHJ1ZVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplQmxhbmtMaW5lKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBhZnRlcldoaXRlc3BhY2UsICdsaW5lUHJlZml4JylcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlcldoaXRlc3BhY2UoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSA/IG9rKGNvZGUpIDogbm9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXhpdGVyfSBFeGl0ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25TcGFjZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBibG9ja1F1b3RlID0ge1xuICBuYW1lOiAnYmxvY2tRdW90ZScsXG4gIHRva2VuaXplOiB0b2tlbml6ZUJsb2NrUXVvdGVTdGFydCxcbiAgY29udGludWF0aW9uOiB7XG4gICAgdG9rZW5pemU6IHRva2VuaXplQmxvY2tRdW90ZUNvbnRpbnVhdGlvblxuICB9LFxuICBleGl0XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVCbG9ja1F1b3RlU3RhcnQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDYyKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHNlbGYuY29udGFpbmVyU3RhdGVcblxuICAgICAgaWYgKCFzdGF0ZS5vcGVuKSB7XG4gICAgICAgIGVmZmVjdHMuZW50ZXIoJ2Jsb2NrUXVvdGUnLCB7XG4gICAgICAgICAgX2NvbnRhaW5lcjogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICBzdGF0ZS5vcGVuID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBlZmZlY3RzLmVudGVyKCdibG9ja1F1b3RlUHJlZml4JylcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2Jsb2NrUXVvdGVNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2Jsb2NrUXVvdGVNYXJrZXInKVxuICAgICAgcmV0dXJuIGFmdGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdibG9ja1F1b3RlUHJlZml4V2hpdGVzcGFjZScpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnYmxvY2tRdW90ZVByZWZpeFdoaXRlc3BhY2UnKVxuICAgICAgZWZmZWN0cy5leGl0KCdibG9ja1F1b3RlUHJlZml4JylcbiAgICAgIHJldHVybiBva1xuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgnYmxvY2tRdW90ZVByZWZpeCcpXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUJsb2NrUXVvdGVDb250aW51YXRpb24oZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgIGVmZmVjdHMsXG4gICAgZWZmZWN0cy5hdHRlbXB0KGJsb2NrUXVvdGUsIG9rLCBub2spLFxuICAgICdsaW5lUHJlZml4JyxcbiAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcygnY29kZUluZGVudGVkJykgPyB1bmRlZmluZWQgOiA0XG4gIClcbn1cbi8qKiBAdHlwZSB7RXhpdGVyfSAqL1xuXG5mdW5jdGlvbiBleGl0KGVmZmVjdHMpIHtcbiAgZWZmZWN0cy5leGl0KCdibG9ja1F1b3RlJylcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7YXNjaWlQdW5jdHVhdGlvbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBjaGFyYWN0ZXJFc2NhcGUgPSB7XG4gIG5hbWU6ICdjaGFyYWN0ZXJFc2NhcGUnLFxuICB0b2tlbml6ZTogdG9rZW5pemVDaGFyYWN0ZXJFc2NhcGVcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUNoYXJhY3RlckVzY2FwZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdjaGFyYWN0ZXJFc2NhcGUnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2VzY2FwZU1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdlc2NhcGVNYXJrZXInKVxuICAgIHJldHVybiBvcGVuXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvcGVuKGNvZGUpIHtcbiAgICBpZiAoYXNjaWlQdW5jdHVhdGlvbihjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignY2hhcmFjdGVyRXNjYXBlVmFsdWUnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2NoYXJhY3RlckVzY2FwZVZhbHVlJylcbiAgICAgIGVmZmVjdHMuZXhpdCgnY2hhcmFjdGVyRXNjYXBlJylcbiAgICAgIHJldHVybiBva1xuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuIiwgIi8vLyA8cmVmZXJlbmNlIGxpYj1cImRvbVwiIC8+XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG5jb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfGZhbHNlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UodmFsdWUpIHtcbiAgY29uc3QgY2hhcmFjdGVyUmVmZXJlbmNlID0gJyYnICsgdmFsdWUgKyAnOydcbiAgZWxlbWVudC5pbm5lckhUTUwgPSBjaGFyYWN0ZXJSZWZlcmVuY2VcbiAgY29uc3QgY2hhciA9IGVsZW1lbnQudGV4dENvbnRlbnRcblxuICAvLyBTb21lIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIGRvIG5vdCByZXF1aXJlIHRoZSBjbG9zaW5nIHNlbWljb2xvblxuICAvLyAoYCZub3RgLCBmb3IgaW5zdGFuY2UpLCB3aGljaCBsZWFkcyB0byBzaXR1YXRpb25zIHdoZXJlIHBhcnNpbmcgdGhlIGFzc3VtZWRcbiAgLy8gbmFtZWQgcmVmZXJlbmNlIG9mIGAmbm90aXQ7YCB3aWxsIHJlc3VsdCBpbiB0aGUgc3RyaW5nIGBcdTAwQUNpdDtgLlxuICAvLyBXaGVuIHdlIGVuY291bnRlciBhIHRyYWlsaW5nIHNlbWljb2xvbiBhZnRlciBwYXJzaW5nLCBhbmQgdGhlIGNoYXJhY3RlclxuICAvLyByZWZlcmVuY2UgdG8gZGVjb2RlIHdhcyBub3QgYSBzZW1pY29sb24gKGAmc2VtaTtgKSwgd2UgY2FuIGFzc3VtZSB0aGF0IHRoZVxuICAvLyBtYXRjaGluZyB3YXMgbm90IGNvbXBsZXRlLlxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBUeXBlU2NyaXB0IGlzIHdyb25nIHRoYXQgYHRleHRDb250ZW50YCBvbiBlbGVtZW50cyBjYW5cbiAgLy8geWllbGQgYG51bGxgLlxuICBpZiAoY2hhci5jaGFyQ29kZUF0KGNoYXIubGVuZ3RoIC0gMSkgPT09IDU5IC8qIGA7YCAqLyAmJiB2YWx1ZSAhPT0gJ3NlbWknKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBJZiB0aGUgZGVjb2RlZCBzdHJpbmcgaXMgZXF1YWwgdG8gdGhlIGlucHV0LCB0aGUgY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXNcbiAgLy8gbm90IHZhbGlkLlxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBUeXBlU2NyaXB0IGlzIHdyb25nIHRoYXQgYHRleHRDb250ZW50YCBvbiBlbGVtZW50cyBjYW5cbiAgLy8geWllbGQgYG51bGxgLlxuICByZXR1cm4gY2hhciA9PT0gY2hhcmFjdGVyUmVmZXJlbmNlID8gZmFsc2UgOiBjaGFyXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICovXG5pbXBvcnQge2RlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlfSBmcm9tICdkZWNvZGUtbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZSdcbmltcG9ydCB7XG4gIGFzY2lpQWxwaGFudW1lcmljLFxuICBhc2NpaURpZ2l0LFxuICBhc2NpaUhleERpZ2l0XG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5leHBvcnQgY29uc3QgY2hhcmFjdGVyUmVmZXJlbmNlID0ge1xuICBuYW1lOiAnY2hhcmFjdGVyUmVmZXJlbmNlJyxcbiAgdG9rZW5pemU6IHRva2VuaXplQ2hhcmFjdGVyUmVmZXJlbmNlXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVDaGFyYWN0ZXJSZWZlcmVuY2UoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgc2l6ZSA9IDBcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgbGV0IG1heFxuICAvKiogQHR5cGUgeyhjb2RlOiBDb2RlKSA9PiBjb2RlIGlzIG51bWJlcn0gKi9cblxuICBsZXQgdGVzdFxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignY2hhcmFjdGVyUmVmZXJlbmNlJylcbiAgICBlZmZlY3RzLmVudGVyKCdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyJylcbiAgICByZXR1cm4gb3BlblxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDM1KSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljJylcbiAgICAgIHJldHVybiBudW1lcmljXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWUnKVxuICAgIG1heCA9IDMxXG4gICAgdGVzdCA9IGFzY2lpQWxwaGFudW1lcmljXG4gICAgcmV0dXJuIHZhbHVlKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBudW1lcmljKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gODggfHwgY29kZSA9PT0gMTIwKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbCcpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWwnKVxuICAgICAgZWZmZWN0cy5lbnRlcignY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWUnKVxuICAgICAgbWF4ID0gNlxuICAgICAgdGVzdCA9IGFzY2lpSGV4RGlnaXRcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2NoYXJhY3RlclJlZmVyZW5jZVZhbHVlJylcbiAgICBtYXggPSA3XG4gICAgdGVzdCA9IGFzY2lpRGlnaXRcbiAgICByZXR1cm4gdmFsdWUoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHZhbHVlKGNvZGUpIHtcbiAgICAvKiogQHR5cGUge1Rva2VufSAqL1xuICAgIGxldCB0b2tlblxuXG4gICAgaWYgKGNvZGUgPT09IDU5ICYmIHNpemUpIHtcbiAgICAgIHRva2VuID0gZWZmZWN0cy5leGl0KCdjaGFyYWN0ZXJSZWZlcmVuY2VWYWx1ZScpXG5cbiAgICAgIGlmIChcbiAgICAgICAgdGVzdCA9PT0gYXNjaWlBbHBoYW51bWVyaWMgJiZcbiAgICAgICAgIWRlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlKHNlbGYuc2xpY2VTZXJpYWxpemUodG9rZW4pKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cblxuICAgICAgZWZmZWN0cy5lbnRlcignY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXInKVxuICAgICAgZWZmZWN0cy5leGl0KCdjaGFyYWN0ZXJSZWZlcmVuY2UnKVxuICAgICAgcmV0dXJuIG9rXG4gICAgfVxuXG4gICAgaWYgKHRlc3QoY29kZSkgJiYgc2l6ZSsrIDwgbWF4KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge1xuICBtYXJrZG93bkxpbmVFbmRpbmcsXG4gIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2Vcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBjb2RlRmVuY2VkID0ge1xuICBuYW1lOiAnY29kZUZlbmNlZCcsXG4gIHRva2VuaXplOiB0b2tlbml6ZUNvZGVGZW5jZWQsXG4gIGNvbmNyZXRlOiB0cnVlXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVDb2RlRmVuY2VkKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbiAgY29uc3QgY2xvc2luZ0ZlbmNlQ29uc3RydWN0ID0ge1xuICAgIHRva2VuaXplOiB0b2tlbml6ZUNsb3NpbmdGZW5jZSxcbiAgICBwYXJ0aWFsOiB0cnVlXG4gIH1cbiAgLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbiAgY29uc3Qgbm9uTGF6eUxpbmUgPSB7XG4gICAgdG9rZW5pemU6IHRva2VuaXplTm9uTGF6eUxpbmUsXG4gICAgcGFydGlhbDogdHJ1ZVxuICB9XG4gIGNvbnN0IHRhaWwgPSB0aGlzLmV2ZW50c1t0aGlzLmV2ZW50cy5sZW5ndGggLSAxXVxuICBjb25zdCBpbml0aWFsUHJlZml4ID1cbiAgICB0YWlsICYmIHRhaWxbMV0udHlwZSA9PT0gJ2xpbmVQcmVmaXgnXG4gICAgICA/IHRhaWxbMl0uc2xpY2VTZXJpYWxpemUodGFpbFsxXSwgdHJ1ZSkubGVuZ3RoXG4gICAgICA6IDBcbiAgbGV0IHNpemVPcGVuID0gMFxuICAvKiogQHR5cGUge05vbk51bGxhYmxlPENvZGU+fSAqL1xuXG4gIGxldCBtYXJrZXJcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2NvZGVGZW5jZWQnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2NvZGVGZW5jZWRGZW5jZScpXG4gICAgZWZmZWN0cy5lbnRlcignY29kZUZlbmNlZEZlbmNlU2VxdWVuY2UnKVxuICAgIG1hcmtlciA9IGNvZGVcbiAgICByZXR1cm4gc2VxdWVuY2VPcGVuKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzZXF1ZW5jZU9wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSBtYXJrZXIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgc2l6ZU9wZW4rK1xuICAgICAgcmV0dXJuIHNlcXVlbmNlT3BlblxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgnY29kZUZlbmNlZEZlbmNlU2VxdWVuY2UnKVxuICAgIHJldHVybiBzaXplT3BlbiA8IDNcbiAgICAgID8gbm9rKGNvZGUpXG4gICAgICA6IGZhY3RvcnlTcGFjZShlZmZlY3RzLCBpbmZvT3BlbiwgJ3doaXRlc3BhY2UnKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5mb09wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIG9wZW5BZnRlcihjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2NvZGVGZW5jZWRGZW5jZUluZm8nKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2NodW5rU3RyaW5nJywge1xuICAgICAgY29udGVudFR5cGU6ICdzdHJpbmcnXG4gICAgfSlcbiAgICByZXR1cm4gaW5mbyhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5mbyhjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1N0cmluZycpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2NvZGVGZW5jZWRGZW5jZUluZm8nKVxuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBpbmZvQWZ0ZXIsICd3aGl0ZXNwYWNlJykoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gOTYgJiYgY29kZSA9PT0gbWFya2VyKSByZXR1cm4gbm9rKGNvZGUpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGluZm9cbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGluZm9BZnRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm4gb3BlbkFmdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignY29kZUZlbmNlZEZlbmNlTWV0YScpXG4gICAgZWZmZWN0cy5lbnRlcignY2h1bmtTdHJpbmcnLCB7XG4gICAgICBjb250ZW50VHlwZTogJ3N0cmluZydcbiAgICB9KVxuICAgIHJldHVybiBtZXRhKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBtZXRhKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnY2h1bmtTdHJpbmcnKVxuICAgICAgZWZmZWN0cy5leGl0KCdjb2RlRmVuY2VkRmVuY2VNZXRhJylcbiAgICAgIHJldHVybiBvcGVuQWZ0ZXIoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gOTYgJiYgY29kZSA9PT0gbWFya2VyKSByZXR1cm4gbm9rKGNvZGUpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIG1ldGFcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIG9wZW5BZnRlcihjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCdjb2RlRmVuY2VkRmVuY2UnKVxuICAgIHJldHVybiBzZWxmLmludGVycnVwdCA/IG9rKGNvZGUpIDogY29udGVudFN0YXJ0KGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250ZW50U3RhcnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYWZ0ZXIoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICBub25MYXp5TGluZSxcbiAgICAgICAgZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICAgIGNsb3NpbmdGZW5jZUNvbnN0cnVjdCxcbiAgICAgICAgICBhZnRlcixcbiAgICAgICAgICBpbml0aWFsUHJlZml4XG4gICAgICAgICAgICA/IGZhY3RvcnlTcGFjZShcbiAgICAgICAgICAgICAgICBlZmZlY3RzLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgICAgICAgICAgICAnbGluZVByZWZpeCcsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFByZWZpeCArIDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBjb250ZW50U3RhcnRcbiAgICAgICAgKSxcbiAgICAgICAgYWZ0ZXJcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdjb2RlRmxvd1ZhbHVlJylcbiAgICByZXR1cm4gY29udGVudENvbnRpbnVlKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250ZW50Q29udGludWUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdjb2RlRmxvd1ZhbHVlJylcbiAgICAgIHJldHVybiBjb250ZW50U3RhcnQoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29udGVudENvbnRpbnVlXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlcihjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCdjb2RlRmVuY2VkJylcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuICBmdW5jdGlvbiB0b2tlbml6ZU5vbkxhenlMaW5lKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIHJldHVybiBzdGFydFxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdsaW5lRW5kaW5nJylcbiAgICAgIHJldHVybiBsaW5lU3RhcnRcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydChjb2RlKSB7XG4gICAgICByZXR1cm4gc2VsZi5wYXJzZXIubGF6eVtzZWxmLm5vdygpLmxpbmVdID8gbm9rKGNvZGUpIDogb2soY29kZSlcbiAgICB9XG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVDbG9zaW5nRmVuY2UoZWZmZWN0cywgb2ssIG5vaykge1xuICAgIGxldCBzaXplID0gMFxuICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICBlZmZlY3RzLFxuICAgICAgY2xvc2luZ1NlcXVlbmNlU3RhcnQsXG4gICAgICAnbGluZVByZWZpeCcsXG4gICAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcygnY29kZUluZGVudGVkJylcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiA0XG4gICAgKVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBjbG9zaW5nU2VxdWVuY2VTdGFydChjb2RlKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdjb2RlRmVuY2VkRmVuY2UnKVxuICAgICAgZWZmZWN0cy5lbnRlcignY29kZUZlbmNlZEZlbmNlU2VxdWVuY2UnKVxuICAgICAgcmV0dXJuIGNsb3NpbmdTZXF1ZW5jZShjb2RlKVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gY2xvc2luZ1NlcXVlbmNlKGNvZGUpIHtcbiAgICAgIGlmIChjb2RlID09PSBtYXJrZXIpIHtcbiAgICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICAgIHNpemUrK1xuICAgICAgICByZXR1cm4gY2xvc2luZ1NlcXVlbmNlXG4gICAgICB9XG5cbiAgICAgIGlmIChzaXplIDwgc2l6ZU9wZW4pIHJldHVybiBub2soY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnY29kZUZlbmNlZEZlbmNlU2VxdWVuY2UnKVxuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBjbG9zaW5nU2VxdWVuY2VFbmQsICd3aGl0ZXNwYWNlJykoY29kZSlcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIGNsb3NpbmdTZXF1ZW5jZUVuZChjb2RlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgICAgZWZmZWN0cy5leGl0KCdjb2RlRmVuY2VkRmVuY2UnKVxuICAgICAgICByZXR1cm4gb2soY29kZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBjb2RlSW5kZW50ZWQgPSB7XG4gIG5hbWU6ICdjb2RlSW5kZW50ZWQnLFxuICB0b2tlbml6ZTogdG9rZW5pemVDb2RlSW5kZW50ZWRcbn1cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5jb25zdCBpbmRlbnRlZENvbnRlbnQgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZUluZGVudGVkQ29udGVudCxcbiAgcGFydGlhbDogdHJ1ZVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplQ29kZUluZGVudGVkKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2NvZGVJbmRlbnRlZCcpXG4gICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBhZnRlclN0YXJ0UHJlZml4LCAnbGluZVByZWZpeCcsIDQgKyAxKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJTdGFydFByZWZpeChjb2RlKSB7XG4gICAgY29uc3QgdGFpbCA9IHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIHRhaWwgJiZcbiAgICAgIHRhaWxbMV0udHlwZSA9PT0gJ2xpbmVQcmVmaXgnICYmXG4gICAgICB0YWlsWzJdLnNsaWNlU2VyaWFsaXplKHRhaWxbMV0sIHRydWUpLmxlbmd0aCA+PSA0XG4gICAgICA/IGFmdGVyUHJlZml4KGNvZGUpXG4gICAgICA6IG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJQcmVmaXgoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYWZ0ZXIoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KGluZGVudGVkQ29udGVudCwgYWZ0ZXJQcmVmaXgsIGFmdGVyKShjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2NvZGVGbG93VmFsdWUnKVxuICAgIHJldHVybiBjb250ZW50KGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250ZW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnY29kZUZsb3dWYWx1ZScpXG4gICAgICByZXR1cm4gYWZ0ZXJQcmVmaXgoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29udGVudFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnY29kZUluZGVudGVkJylcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplSW5kZW50ZWRDb250ZW50KGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIC8vIElmIHRoaXMgaXMgYSBsYXp5IGxpbmUsIGl0IGNhblx1MjAxOXQgYmUgY29kZS5cbiAgICBpZiAoc2VsZi5wYXJzZXIubGF6eVtzZWxmLm5vdygpLmxpbmVdKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignbGluZUVuZGluZycpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG4gICAgICByZXR1cm4gc3RhcnRcbiAgICB9XG5cbiAgICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGFmdGVyUHJlZml4LCAnbGluZVByZWZpeCcsIDQgKyAxKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJQcmVmaXgoY29kZSkge1xuICAgIGNvbnN0IHRhaWwgPSBzZWxmLmV2ZW50c1tzZWxmLmV2ZW50cy5sZW5ndGggLSAxXVxuICAgIHJldHVybiB0YWlsICYmXG4gICAgICB0YWlsWzFdLnR5cGUgPT09ICdsaW5lUHJlZml4JyAmJlxuICAgICAgdGFpbFsyXS5zbGljZVNlcmlhbGl6ZSh0YWlsWzFdLCB0cnVlKS5sZW5ndGggPj0gNFxuICAgICAgPyBvayhjb2RlKVxuICAgICAgOiBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSlcbiAgICAgID8gc3RhcnQoY29kZSlcbiAgICAgIDogbm9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUmVzb2x2ZXJ9IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlByZXZpb3VzfSBQcmV2aW91c1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IGNvZGVUZXh0ID0ge1xuICBuYW1lOiAnY29kZVRleHQnLFxuICB0b2tlbml6ZTogdG9rZW5pemVDb2RlVGV4dCxcbiAgcmVzb2x2ZTogcmVzb2x2ZUNvZGVUZXh0LFxuICBwcmV2aW91c1xufVxuLyoqIEB0eXBlIHtSZXNvbHZlcn0gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUNvZGVUZXh0KGV2ZW50cykge1xuICBsZXQgdGFpbEV4aXRJbmRleCA9IGV2ZW50cy5sZW5ndGggLSA0XG4gIGxldCBoZWFkRW50ZXJJbmRleCA9IDNcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgbGV0IGluZGV4XG4gIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cblxuICBsZXQgZW50ZXIgLy8gSWYgd2Ugc3RhcnQgYW5kIGVuZCB3aXRoIGFuIEVPTCBvciBhIHNwYWNlLlxuXG4gIGlmIChcbiAgICAoZXZlbnRzW2hlYWRFbnRlckluZGV4XVsxXS50eXBlID09PSAnbGluZUVuZGluZycgfHxcbiAgICAgIGV2ZW50c1toZWFkRW50ZXJJbmRleF1bMV0udHlwZSA9PT0gJ3NwYWNlJykgJiZcbiAgICAoZXZlbnRzW3RhaWxFeGl0SW5kZXhdWzFdLnR5cGUgPT09ICdsaW5lRW5kaW5nJyB8fFxuICAgICAgZXZlbnRzW3RhaWxFeGl0SW5kZXhdWzFdLnR5cGUgPT09ICdzcGFjZScpXG4gICkge1xuICAgIGluZGV4ID0gaGVhZEVudGVySW5kZXggLy8gQW5kIHdlIGhhdmUgZGF0YS5cblxuICAgIHdoaWxlICgrK2luZGV4IDwgdGFpbEV4aXRJbmRleCkge1xuICAgICAgaWYgKGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ2NvZGVUZXh0RGF0YScpIHtcbiAgICAgICAgLy8gVGhlbiB3ZSBoYXZlIHBhZGRpbmcuXG4gICAgICAgIGV2ZW50c1toZWFkRW50ZXJJbmRleF1bMV0udHlwZSA9ICdjb2RlVGV4dFBhZGRpbmcnXG4gICAgICAgIGV2ZW50c1t0YWlsRXhpdEluZGV4XVsxXS50eXBlID0gJ2NvZGVUZXh0UGFkZGluZydcbiAgICAgICAgaGVhZEVudGVySW5kZXggKz0gMlxuICAgICAgICB0YWlsRXhpdEluZGV4IC09IDJcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gTWVyZ2UgYWRqYWNlbnQgc3BhY2VzIGFuZCBkYXRhLlxuXG4gIGluZGV4ID0gaGVhZEVudGVySW5kZXggLSAxXG4gIHRhaWxFeGl0SW5kZXgrK1xuXG4gIHdoaWxlICgrK2luZGV4IDw9IHRhaWxFeGl0SW5kZXgpIHtcbiAgICBpZiAoZW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZGV4ICE9PSB0YWlsRXhpdEluZGV4ICYmIGV2ZW50c1tpbmRleF1bMV0udHlwZSAhPT0gJ2xpbmVFbmRpbmcnKSB7XG4gICAgICAgIGVudGVyID0gaW5kZXhcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaW5kZXggPT09IHRhaWxFeGl0SW5kZXggfHxcbiAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmcnXG4gICAgKSB7XG4gICAgICBldmVudHNbZW50ZXJdWzFdLnR5cGUgPSAnY29kZVRleHREYXRhJ1xuXG4gICAgICBpZiAoaW5kZXggIT09IGVudGVyICsgMikge1xuICAgICAgICBldmVudHNbZW50ZXJdWzFdLmVuZCA9IGV2ZW50c1tpbmRleCAtIDFdWzFdLmVuZFxuICAgICAgICBldmVudHMuc3BsaWNlKGVudGVyICsgMiwgaW5kZXggLSBlbnRlciAtIDIpXG4gICAgICAgIHRhaWxFeGl0SW5kZXggLT0gaW5kZXggLSBlbnRlciAtIDJcbiAgICAgICAgaW5kZXggPSBlbnRlciArIDJcbiAgICAgIH1cblxuICAgICAgZW50ZXIgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnRzXG59XG4vKiogQHR5cGUge1ByZXZpb3VzfSAqL1xuXG5mdW5jdGlvbiBwcmV2aW91cyhjb2RlKSB7XG4gIC8vIElmIHRoZXJlIGlzIGEgcHJldmlvdXMgY29kZSwgdGhlcmUgd2lsbCBhbHdheXMgYmUgYSB0YWlsLlxuICByZXR1cm4gKFxuICAgIGNvZGUgIT09IDk2IHx8XG4gICAgdGhpcy5ldmVudHNbdGhpcy5ldmVudHMubGVuZ3RoIC0gMV1bMV0udHlwZSA9PT0gJ2NoYXJhY3RlckVzY2FwZSdcbiAgKVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplQ29kZVRleHQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgc2l6ZU9wZW4gPSAwXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXG4gIGxldCBzaXplXG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG5cbiAgbGV0IHRva2VuXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdjb2RlVGV4dCcpXG4gICAgZWZmZWN0cy5lbnRlcignY29kZVRleHRTZXF1ZW5jZScpXG4gICAgcmV0dXJuIG9wZW5pbmdTZXF1ZW5jZShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb3BlbmluZ1NlcXVlbmNlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gOTYpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgc2l6ZU9wZW4rK1xuICAgICAgcmV0dXJuIG9wZW5pbmdTZXF1ZW5jZVxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgnY29kZVRleHRTZXF1ZW5jZScpXG4gICAgcmV0dXJuIGdhcChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZ2FwKGNvZGUpIHtcbiAgICAvLyBFT0YuXG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9IC8vIENsb3NpbmcgZmVuY2U/XG4gICAgLy8gQ291bGQgYWxzbyBiZSBkYXRhLlxuXG4gICAgaWYgKGNvZGUgPT09IDk2KSB7XG4gICAgICB0b2tlbiA9IGVmZmVjdHMuZW50ZXIoJ2NvZGVUZXh0U2VxdWVuY2UnKVxuICAgICAgc2l6ZSA9IDBcbiAgICAgIHJldHVybiBjbG9zaW5nU2VxdWVuY2UoY29kZSlcbiAgICB9IC8vIFRhYnMgZG9uXHUyMDE5dCB3b3JrLCBhbmQgdmlydHVhbCBzcGFjZXMgZG9uXHUyMDE5dCBtYWtlIHNlbnNlLlxuXG4gICAgaWYgKGNvZGUgPT09IDMyKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdzcGFjZScpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnc3BhY2UnKVxuICAgICAgcmV0dXJuIGdhcFxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgICAgcmV0dXJuIGdhcFxuICAgIH0gLy8gRGF0YS5cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2NvZGVUZXh0RGF0YScpXG4gICAgcmV0dXJuIGRhdGEoY29kZSlcbiAgfSAvLyBJbiBjb2RlLlxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGF0YShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgY29kZSA9PT0gMzIgfHxcbiAgICAgIGNvZGUgPT09IDk2IHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSlcbiAgICApIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnY29kZVRleHREYXRhJylcbiAgICAgIHJldHVybiBnYXAoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gZGF0YVxuICB9IC8vIENsb3NpbmcgZmVuY2UuXG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjbG9zaW5nU2VxdWVuY2UoY29kZSkge1xuICAgIC8vIE1vcmUuXG4gICAgaWYgKGNvZGUgPT09IDk2KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHNpemUrK1xuICAgICAgcmV0dXJuIGNsb3NpbmdTZXF1ZW5jZVxuICAgIH0gLy8gRG9uZSFcblxuICAgIGlmIChzaXplID09PSBzaXplT3Blbikge1xuICAgICAgZWZmZWN0cy5leGl0KCdjb2RlVGV4dFNlcXVlbmNlJylcbiAgICAgIGVmZmVjdHMuZXhpdCgnY29kZVRleHQnKVxuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfSAvLyBNb3JlIG9yIGxlc3MgYWNjZW50czogbWFyayBhcyBkYXRhLlxuXG4gICAgdG9rZW4udHlwZSA9ICdjb2RlVGV4dERhdGEnXG4gICAgcmV0dXJuIGRhdGEoY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ2h1bmt9IENodW5rXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICovXG5pbXBvcnQge3NwbGljZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2h1bmtlZCdcblxuLyoqXG4gKiBUb2tlbml6ZSBzdWJjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRbXX0gZXZlbnRzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRva2VuaXplKGV2ZW50cykge1xuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIG51bWJlcj59ICovXG4gIGNvbnN0IGp1bXBzID0ge31cbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtFdmVudH0gKi9cblxuICBsZXQgZXZlbnRcbiAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBsaW5lSW5kZXhcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgbGV0IG90aGVySW5kZXhcbiAgLyoqIEB0eXBlIHtFdmVudH0gKi9cblxuICBsZXQgb3RoZXJFdmVudFxuICAvKiogQHR5cGUge0V2ZW50W119ICovXG5cbiAgbGV0IHBhcmFtZXRlcnNcbiAgLyoqIEB0eXBlIHtFdmVudFtdfSAqL1xuXG4gIGxldCBzdWJldmVudHNcbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgbW9yZVxuXG4gIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgIHdoaWxlIChpbmRleCBpbiBqdW1wcykge1xuICAgICAgaW5kZXggPSBqdW1wc1tpbmRleF1cbiAgICB9XG5cbiAgICBldmVudCA9IGV2ZW50c1tpbmRleF0gLy8gQWRkIGEgaG9vayBmb3IgdGhlIEdGTSB0YXNrbGlzdCBleHRlbnNpb24sIHdoaWNoIG5lZWRzIHRvIGtub3cgaWYgdGV4dFxuICAgIC8vIGlzIGluIHRoZSBmaXJzdCBjb250ZW50IG9mIGEgbGlzdCBpdGVtLlxuXG4gICAgaWYgKFxuICAgICAgaW5kZXggJiZcbiAgICAgIGV2ZW50WzFdLnR5cGUgPT09ICdjaHVua0Zsb3cnICYmXG4gICAgICBldmVudHNbaW5kZXggLSAxXVsxXS50eXBlID09PSAnbGlzdEl0ZW1QcmVmaXgnXG4gICAgKSB7XG4gICAgICBzdWJldmVudHMgPSBldmVudFsxXS5fdG9rZW5pemVyLmV2ZW50c1xuICAgICAgb3RoZXJJbmRleCA9IDBcblxuICAgICAgaWYgKFxuICAgICAgICBvdGhlckluZGV4IDwgc3ViZXZlbnRzLmxlbmd0aCAmJlxuICAgICAgICBzdWJldmVudHNbb3RoZXJJbmRleF1bMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmdCbGFuaydcbiAgICAgICkge1xuICAgICAgICBvdGhlckluZGV4ICs9IDJcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBvdGhlckluZGV4IDwgc3ViZXZlbnRzLmxlbmd0aCAmJlxuICAgICAgICBzdWJldmVudHNbb3RoZXJJbmRleF1bMV0udHlwZSA9PT0gJ2NvbnRlbnQnXG4gICAgICApIHtcbiAgICAgICAgd2hpbGUgKCsrb3RoZXJJbmRleCA8IHN1YmV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoc3ViZXZlbnRzW290aGVySW5kZXhdWzFdLnR5cGUgPT09ICdjb250ZW50Jykge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3ViZXZlbnRzW290aGVySW5kZXhdWzFdLnR5cGUgPT09ICdjaHVua1RleHQnKSB7XG4gICAgICAgICAgICBzdWJldmVudHNbb3RoZXJJbmRleF1bMV0uX2lzSW5GaXJzdENvbnRlbnRPZkxpc3RJdGVtID0gdHJ1ZVxuICAgICAgICAgICAgb3RoZXJJbmRleCsrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBFbnRlci5cblxuICAgIGlmIChldmVudFswXSA9PT0gJ2VudGVyJykge1xuICAgICAgaWYgKGV2ZW50WzFdLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oanVtcHMsIHN1YmNvbnRlbnQoZXZlbnRzLCBpbmRleCkpXG4gICAgICAgIGluZGV4ID0ganVtcHNbaW5kZXhdXG4gICAgICAgIG1vcmUgPSB0cnVlXG4gICAgICB9XG4gICAgfSAvLyBFeGl0LlxuICAgIGVsc2UgaWYgKGV2ZW50WzFdLl9jb250YWluZXIpIHtcbiAgICAgIG90aGVySW5kZXggPSBpbmRleFxuICAgICAgbGluZUluZGV4ID0gdW5kZWZpbmVkXG5cbiAgICAgIHdoaWxlIChvdGhlckluZGV4LS0pIHtcbiAgICAgICAgb3RoZXJFdmVudCA9IGV2ZW50c1tvdGhlckluZGV4XVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBvdGhlckV2ZW50WzFdLnR5cGUgPT09ICdsaW5lRW5kaW5nJyB8fFxuICAgICAgICAgIG90aGVyRXZlbnRbMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmdCbGFuaydcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKG90aGVyRXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICAgIGlmIChsaW5lSW5kZXgpIHtcbiAgICAgICAgICAgICAgZXZlbnRzW2xpbmVJbmRleF1bMV0udHlwZSA9ICdsaW5lRW5kaW5nQmxhbmsnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG90aGVyRXZlbnRbMV0udHlwZSA9ICdsaW5lRW5kaW5nJ1xuICAgICAgICAgICAgbGluZUluZGV4ID0gb3RoZXJJbmRleFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5lSW5kZXgpIHtcbiAgICAgICAgLy8gRml4IHBvc2l0aW9uLlxuICAgICAgICBldmVudFsxXS5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbbGluZUluZGV4XVsxXS5zdGFydCkgLy8gU3dpdGNoIGNvbnRhaW5lciBleGl0IHcvIGxpbmUgZW5kaW5ncy5cblxuICAgICAgICBwYXJhbWV0ZXJzID0gZXZlbnRzLnNsaWNlKGxpbmVJbmRleCwgaW5kZXgpXG4gICAgICAgIHBhcmFtZXRlcnMudW5zaGlmdChldmVudClcbiAgICAgICAgc3BsaWNlKGV2ZW50cywgbGluZUluZGV4LCBpbmRleCAtIGxpbmVJbmRleCArIDEsIHBhcmFtZXRlcnMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICFtb3JlXG59XG4vKipcbiAqIFRva2VuaXplIGVtYmVkZGVkIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50W119IGV2ZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50SW5kZXhcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fVxuICovXG5cbmZ1bmN0aW9uIHN1YmNvbnRlbnQoZXZlbnRzLCBldmVudEluZGV4KSB7XG4gIGNvbnN0IHRva2VuID0gZXZlbnRzW2V2ZW50SW5kZXhdWzFdXG4gIGNvbnN0IGNvbnRleHQgPSBldmVudHNbZXZlbnRJbmRleF1bMl1cbiAgbGV0IHN0YXJ0UG9zaXRpb24gPSBldmVudEluZGV4IC0gMVxuICAvKiogQHR5cGUge251bWJlcltdfSAqL1xuXG4gIGNvbnN0IHN0YXJ0UG9zaXRpb25zID0gW11cbiAgY29uc3QgdG9rZW5pemVyID1cbiAgICB0b2tlbi5fdG9rZW5pemVyIHx8IGNvbnRleHQucGFyc2VyW3Rva2VuLmNvbnRlbnRUeXBlXSh0b2tlbi5zdGFydClcbiAgY29uc3QgY2hpbGRFdmVudHMgPSB0b2tlbml6ZXIuZXZlbnRzXG4gIC8qKiBAdHlwZSB7W251bWJlciwgbnVtYmVyXVtdfSAqL1xuXG4gIGNvbnN0IGp1bXBzID0gW11cbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSAqL1xuXG4gIGNvbnN0IGdhcHMgPSB7fVxuICAvKiogQHR5cGUge0NodW5rW119ICovXG5cbiAgbGV0IHN0cmVhbVxuICAvKiogQHR5cGUge1Rva2VufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgcHJldmlvdXNcbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtUb2tlbnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGN1cnJlbnQgPSB0b2tlblxuICBsZXQgYWRqdXN0ID0gMFxuICBsZXQgc3RhcnQgPSAwXG4gIGNvbnN0IGJyZWFrcyA9IFtzdGFydF0gLy8gTG9vcCBmb3J3YXJkIHRocm91Z2ggdGhlIGxpbmtlZCB0b2tlbnMgdG8gcGFzcyB0aGVtIGluIG9yZGVyIHRvIHRoZVxuICAvLyBzdWJ0b2tlbml6ZXIuXG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgZm9yIHRoaXMgdG9rZW4uXG4gICAgd2hpbGUgKGV2ZW50c1srK3N0YXJ0UG9zaXRpb25dWzFdICE9PSBjdXJyZW50KSB7XG4gICAgICAvLyBFbXB0eS5cbiAgICB9XG5cbiAgICBzdGFydFBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zaXRpb24pXG5cbiAgICBpZiAoIWN1cnJlbnQuX3Rva2VuaXplcikge1xuICAgICAgc3RyZWFtID0gY29udGV4dC5zbGljZVN0cmVhbShjdXJyZW50KVxuXG4gICAgICBpZiAoIWN1cnJlbnQubmV4dCkge1xuICAgICAgICBzdHJlYW0ucHVzaChudWxsKVxuICAgICAgfVxuXG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgdG9rZW5pemVyLmRlZmluZVNraXAoY3VycmVudC5zdGFydClcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQuX2lzSW5GaXJzdENvbnRlbnRPZkxpc3RJdGVtKSB7XG4gICAgICAgIHRva2VuaXplci5fZ2ZtVGFza2xpc3RGaXJzdENvbnRlbnRPZkxpc3RJdGVtID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICB0b2tlbml6ZXIud3JpdGUoc3RyZWFtKVxuXG4gICAgICBpZiAoY3VycmVudC5faXNJbkZpcnN0Q29udGVudE9mTGlzdEl0ZW0pIHtcbiAgICAgICAgdG9rZW5pemVyLl9nZm1UYXNrbGlzdEZpcnN0Q29udGVudE9mTGlzdEl0ZW0gPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9IC8vIFVucmF2ZWwgdGhlIG5leHQgdG9rZW4uXG5cbiAgICBwcmV2aW91cyA9IGN1cnJlbnRcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0XG4gIH0gLy8gTm93LCBsb29wIGJhY2sgdGhyb3VnaCBhbGwgZXZlbnRzIChhbmQgbGlua2VkIHRva2VucyksIHRvIGZpZ3VyZSBvdXQgd2hpY2hcbiAgLy8gcGFydHMgYmVsb25nIHdoZXJlLlxuXG4gIGN1cnJlbnQgPSB0b2tlblxuXG4gIHdoaWxlICgrK2luZGV4IDwgY2hpbGRFdmVudHMubGVuZ3RoKSB7XG4gICAgaWYgKFxuICAgICAgLy8gRmluZCBhIHZvaWQgdG9rZW4gdGhhdCBpbmNsdWRlcyBhIGJyZWFrLlxuICAgICAgY2hpbGRFdmVudHNbaW5kZXhdWzBdID09PSAnZXhpdCcgJiZcbiAgICAgIGNoaWxkRXZlbnRzW2luZGV4IC0gMV1bMF0gPT09ICdlbnRlcicgJiZcbiAgICAgIGNoaWxkRXZlbnRzW2luZGV4XVsxXS50eXBlID09PSBjaGlsZEV2ZW50c1tpbmRleCAtIDFdWzFdLnR5cGUgJiZcbiAgICAgIGNoaWxkRXZlbnRzW2luZGV4XVsxXS5zdGFydC5saW5lICE9PSBjaGlsZEV2ZW50c1tpbmRleF1bMV0uZW5kLmxpbmVcbiAgICApIHtcbiAgICAgIHN0YXJ0ID0gaW5kZXggKyAxXG4gICAgICBicmVha3MucHVzaChzdGFydCkgLy8gSGVscCBHQy5cblxuICAgICAgY3VycmVudC5fdG9rZW5pemVyID0gdW5kZWZpbmVkXG4gICAgICBjdXJyZW50LnByZXZpb3VzID0gdW5kZWZpbmVkXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0XG4gICAgfVxuICB9IC8vIEhlbHAgR0MuXG5cbiAgdG9rZW5pemVyLmV2ZW50cyA9IFtdIC8vIElmIHRoZXJlXHUyMDE5cyBvbmUgbW9yZSB0b2tlbiAod2hpY2ggaXMgdGhlIGNhc2VzIGZvciBsaW5lcyB0aGF0IGVuZCBpbiBhblxuICAvLyBFT0YpLCB0aGF0XHUyMDE5cyBwZXJmZWN0OiB0aGUgbGFzdCBwb2ludCB3ZSBmb3VuZCBzdGFydHMgaXQuXG4gIC8vIElmIHRoZXJlIGlzblx1MjAxOXQgdGhlbiBtYWtlIHN1cmUgYW55IHJlbWFpbmluZyBjb250ZW50IGlzIGFkZGVkIHRvIGl0LlxuXG4gIGlmIChjdXJyZW50KSB7XG4gICAgLy8gSGVscCBHQy5cbiAgICBjdXJyZW50Ll90b2tlbml6ZXIgPSB1bmRlZmluZWRcbiAgICBjdXJyZW50LnByZXZpb3VzID0gdW5kZWZpbmVkXG4gIH0gZWxzZSB7XG4gICAgYnJlYWtzLnBvcCgpXG4gIH0gLy8gTm93IHNwbGljZSB0aGUgZXZlbnRzIGZyb20gdGhlIHN1YnRva2VuaXplciBpbnRvIHRoZSBjdXJyZW50IGV2ZW50cyxcbiAgLy8gbW92aW5nIGJhY2sgdG8gZnJvbnQgc28gdGhhdCBzcGxpY2UgaW5kaWNlcyBhcmVuXHUyMDE5dCBhZmZlY3RlZC5cblxuICBpbmRleCA9IGJyZWFrcy5sZW5ndGhcblxuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIGNvbnN0IHNsaWNlID0gY2hpbGRFdmVudHMuc2xpY2UoYnJlYWtzW2luZGV4XSwgYnJlYWtzW2luZGV4ICsgMV0pXG4gICAgY29uc3Qgc3RhcnQgPSBzdGFydFBvc2l0aW9ucy5wb3AoKVxuICAgIGp1bXBzLnVuc2hpZnQoW3N0YXJ0LCBzdGFydCArIHNsaWNlLmxlbmd0aCAtIDFdKVxuICAgIHNwbGljZShldmVudHMsIHN0YXJ0LCAyLCBzbGljZSlcbiAgfVxuXG4gIGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGp1bXBzLmxlbmd0aCkge1xuICAgIGdhcHNbYWRqdXN0ICsganVtcHNbaW5kZXhdWzBdXSA9IGFkanVzdCArIGp1bXBzW2luZGV4XVsxXVxuICAgIGFkanVzdCArPSBqdW1wc1tpbmRleF1bMV0gLSBqdW1wc1tpbmRleF1bMF0gLSAxXG4gIH1cblxuICByZXR1cm4gZ2Fwc1xufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuaW1wb3J0IHtzdWJ0b2tlbml6ZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3VidG9rZW5pemUnXG5cbi8qKlxuICogTm8gbmFtZSBiZWNhdXNlIGl0IG11c3Qgbm90IGJlIHR1cm5lZCBvZmYuXG4gKiBAdHlwZSB7Q29uc3RydWN0fVxuICovXG5leHBvcnQgY29uc3QgY29udGVudCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplQ29udGVudCxcbiAgcmVzb2x2ZTogcmVzb2x2ZUNvbnRlbnRcbn1cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5jb25zdCBjb250aW51YXRpb25Db25zdHJ1Y3QgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZUNvbnRpbnVhdGlvbixcbiAgcGFydGlhbDogdHJ1ZVxufVxuLyoqXG4gKiBDb250ZW50IGlzIHRyYW5zcGFyZW50OiBpdFx1MjAxOXMgcGFyc2VkIHJpZ2h0IG5vdy4gVGhhdCB3YXksIGRlZmluaXRpb25zIGFyZSBhbHNvXG4gKiBwYXJzZWQgcmlnaHQgbm93OiBiZWZvcmUgdGV4dCBpbiBwYXJhZ3JhcGhzIChzcGVjaWZpY2FsbHksIG1lZGlhKSBhcmUgcGFyc2VkLlxuICpcbiAqIEB0eXBlIHtSZXNvbHZlcn1cbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQ29udGVudChldmVudHMpIHtcbiAgc3VidG9rZW5pemUoZXZlbnRzKVxuICByZXR1cm4gZXZlbnRzXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVDb250ZW50KGVmZmVjdHMsIG9rKSB7XG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG4gIGxldCBwcmV2aW91c1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignY29udGVudCcpXG4gICAgcHJldmlvdXMgPSBlZmZlY3RzLmVudGVyKCdjaHVua0NvbnRlbnQnLCB7XG4gICAgICBjb250ZW50VHlwZTogJ2NvbnRlbnQnXG4gICAgfSlcbiAgICByZXR1cm4gZGF0YShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGF0YShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb250ZW50RW5kKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICAgIGNvbnRpbnVhdGlvbkNvbnN0cnVjdCxcbiAgICAgICAgY29udGVudENvbnRpbnVlLFxuICAgICAgICBjb250ZW50RW5kXG4gICAgICApKGNvZGUpXG4gICAgfSAvLyBEYXRhLlxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRlbnRFbmQoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnY2h1bmtDb250ZW50JylcbiAgICBlZmZlY3RzLmV4aXQoJ2NvbnRlbnQnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29udGVudENvbnRpbnVlKGNvZGUpIHtcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2NodW5rQ29udGVudCcpXG4gICAgcHJldmlvdXMubmV4dCA9IGVmZmVjdHMuZW50ZXIoJ2NodW5rQ29udGVudCcsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiAnY29udGVudCcsXG4gICAgICBwcmV2aW91c1xuICAgIH0pXG4gICAgcHJldmlvdXMgPSBwcmV2aW91cy5uZXh0XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplQ29udGludWF0aW9uKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHN0YXJ0TG9va2FoZWFkXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnRMb29rYWhlYWQoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnY2h1bmtDb250ZW50JylcbiAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgcHJlZml4ZWQsICdsaW5lUHJlZml4JylcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHByZWZpeGVkKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBjb25zdCB0YWlsID0gc2VsZi5ldmVudHNbc2VsZi5ldmVudHMubGVuZ3RoIC0gMV1cblxuICAgIGlmIChcbiAgICAgICFzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcygnY29kZUluZGVudGVkJykgJiZcbiAgICAgIHRhaWwgJiZcbiAgICAgIHRhaWxbMV0udHlwZSA9PT0gJ2xpbmVQcmVmaXgnICYmXG4gICAgICB0YWlsWzJdLnNsaWNlU2VyaWFsaXplKHRhaWxbMV0sIHRydWUpLmxlbmd0aCA+PSA0XG4gICAgKSB7XG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gZWZmZWN0cy5pbnRlcnJ1cHQoc2VsZi5wYXJzZXIuY29uc3RydWN0cy5mbG93LCBub2ssIG9rKShjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkVmZmVjdHN9IEVmZmVjdHNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7XG4gIGFzY2lpQ29udHJvbCxcbiAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSxcbiAgbWFya2Rvd25MaW5lRW5kaW5nXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdHN9IGVmZmVjdHNcbiAqIEBwYXJhbSB7U3RhdGV9IG9rXG4gKiBAcGFyYW0ge1N0YXRlfSBub2tcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGl0ZXJhbFR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaXRlcmFsTWFya2VyVHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHJhd1R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdUeXBlXG4gKiBAcGFyYW0ge251bWJlcn0gW21heD1JbmZpbml0eV1cbiAqIEByZXR1cm5zIHtTdGF0ZX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbmV4cG9ydCBmdW5jdGlvbiBmYWN0b3J5RGVzdGluYXRpb24oXG4gIGVmZmVjdHMsXG4gIG9rLFxuICBub2ssXG4gIHR5cGUsXG4gIGxpdGVyYWxUeXBlLFxuICBsaXRlcmFsTWFya2VyVHlwZSxcbiAgcmF3VHlwZSxcbiAgc3RyaW5nVHlwZSxcbiAgbWF4XG4pIHtcbiAgY29uc3QgbGltaXQgPSBtYXggfHwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIGxldCBiYWxhbmNlID0gMFxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDYwKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKHR5cGUpXG4gICAgICBlZmZlY3RzLmVudGVyKGxpdGVyYWxUeXBlKVxuICAgICAgZWZmZWN0cy5lbnRlcihsaXRlcmFsTWFya2VyVHlwZSlcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KGxpdGVyYWxNYXJrZXJUeXBlKVxuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uRW5jbG9zZWRCZWZvcmVcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSA0MSB8fCBhc2NpaUNvbnRyb2woY29kZSkpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKHR5cGUpXG4gICAgZWZmZWN0cy5lbnRlcihyYXdUeXBlKVxuICAgIGVmZmVjdHMuZW50ZXIoc3RyaW5nVHlwZSlcbiAgICBlZmZlY3RzLmVudGVyKCdjaHVua1N0cmluZycsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiAnc3RyaW5nJ1xuICAgIH0pXG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uUmF3KGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkZXN0aW5hdGlvbkVuY2xvc2VkQmVmb3JlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIobGl0ZXJhbE1hcmtlclR5cGUpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdChsaXRlcmFsTWFya2VyVHlwZSlcbiAgICAgIGVmZmVjdHMuZXhpdChsaXRlcmFsVHlwZSlcbiAgICAgIGVmZmVjdHMuZXhpdCh0eXBlKVxuICAgICAgcmV0dXJuIG9rXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcihzdHJpbmdUeXBlKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2NodW5rU3RyaW5nJywge1xuICAgICAgY29udGVudFR5cGU6ICdzdHJpbmcnXG4gICAgfSlcbiAgICByZXR1cm4gZGVzdGluYXRpb25FbmNsb3NlZChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGVzdGluYXRpb25FbmNsb3NlZChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDYyKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2NodW5rU3RyaW5nJylcbiAgICAgIGVmZmVjdHMuZXhpdChzdHJpbmdUeXBlKVxuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uRW5jbG9zZWRCZWZvcmUoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSA2MCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29kZSA9PT0gOTIgPyBkZXN0aW5hdGlvbkVuY2xvc2VkRXNjYXBlIDogZGVzdGluYXRpb25FbmNsb3NlZFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGVzdGluYXRpb25FbmNsb3NlZEVzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDYwIHx8IGNvZGUgPT09IDYyIHx8IGNvZGUgPT09IDkyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBkZXN0aW5hdGlvbkVuY2xvc2VkXG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uRW5jbG9zZWQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRlc3RpbmF0aW9uUmF3KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDApIHtcbiAgICAgIGlmICgrK2JhbGFuY2UgPiBsaW1pdCkgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZGVzdGluYXRpb25SYXdcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNDEpIHtcbiAgICAgIGlmICghYmFsYW5jZS0tKSB7XG4gICAgICAgIGVmZmVjdHMuZXhpdCgnY2h1bmtTdHJpbmcnKVxuICAgICAgICBlZmZlY3RzLmV4aXQoc3RyaW5nVHlwZSlcbiAgICAgICAgZWZmZWN0cy5leGl0KHJhd1R5cGUpXG4gICAgICAgIGVmZmVjdHMuZXhpdCh0eXBlKVxuICAgICAgICByZXR1cm4gb2soY29kZSlcbiAgICAgIH1cblxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZGVzdGluYXRpb25SYXdcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICBpZiAoYmFsYW5jZSkgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1N0cmluZycpXG4gICAgICBlZmZlY3RzLmV4aXQoc3RyaW5nVHlwZSlcbiAgICAgIGVmZmVjdHMuZXhpdChyYXdUeXBlKVxuICAgICAgZWZmZWN0cy5leGl0KHR5cGUpXG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAoYXNjaWlDb250cm9sKGNvZGUpKSByZXR1cm4gbm9rKGNvZGUpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IDkyID8gZGVzdGluYXRpb25SYXdFc2NhcGUgOiBkZXN0aW5hdGlvblJhd1xuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGVzdGluYXRpb25SYXdFc2NhcGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0MCB8fCBjb2RlID09PSA0MSB8fCBjb2RlID09PSA5Mikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZGVzdGluYXRpb25SYXdcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdGluYXRpb25SYXcoY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FZmZlY3RzfSBFZmZlY3RzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplQ29udGV4dH0gVG9rZW5pemVDb250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZywgbWFya2Rvd25TcGFjZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKipcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAcGFyYW0ge0VmZmVjdHN9IGVmZmVjdHNcbiAqIEBwYXJhbSB7U3RhdGV9IG9rXG4gKiBAcGFyYW0ge1N0YXRlfSBub2tcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya2VyVHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1R5cGVcbiAqIEByZXR1cm5zIHtTdGF0ZX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbmV4cG9ydCBmdW5jdGlvbiBmYWN0b3J5TGFiZWwoZWZmZWN0cywgb2ssIG5vaywgdHlwZSwgbWFya2VyVHlwZSwgc3RyaW5nVHlwZSkge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgc2l6ZSA9IDBcbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuXG4gIGxldCBkYXRhXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKHR5cGUpXG4gICAgZWZmZWN0cy5lbnRlcihtYXJrZXJUeXBlKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdChtYXJrZXJUeXBlKVxuICAgIGVmZmVjdHMuZW50ZXIoc3RyaW5nVHlwZSlcbiAgICByZXR1cm4gYXRCcmVha1xuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYXRCcmVhayhjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgY29kZSA9PT0gOTEgfHxcbiAgICAgIChjb2RlID09PSA5MyAmJiAhZGF0YSkgfHxcbiAgICAgIC8qIFRvIGRvOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSBvbmNlIHdlXHUyMDE5dmUgc3dpdGNoZWQgZnJvbVxuICAgICAgICogYG1pY3JvbWFyay1leHRlbnNpb24tZm9vdG5vdGVgIHRvIGBtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1mb290bm90ZWAsXG4gICAgICAgKiB3aGljaCBkb2Vzblx1MjAxOXQgbmVlZCB0aGlzICovXG5cbiAgICAgIC8qIEhpZGRlbiBmb290bm90ZXMgaG9vayAqL1xuXG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgICAoY29kZSA9PT0gOTQgJiZcbiAgICAgICAgIXNpemUgJiZcbiAgICAgICAgJ19oaWRkZW5Gb290bm90ZVN1cHBvcnQnIGluIHNlbGYucGFyc2VyLmNvbnN0cnVjdHMpIHx8XG4gICAgICBzaXplID4gOTk5XG4gICAgKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDkzKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoc3RyaW5nVHlwZSlcbiAgICAgIGVmZmVjdHMuZW50ZXIobWFya2VyVHlwZSlcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KG1hcmtlclR5cGUpXG4gICAgICBlZmZlY3RzLmV4aXQodHlwZSlcbiAgICAgIHJldHVybiBva1xuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgICAgcmV0dXJuIGF0QnJlYWtcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdjaHVua1N0cmluZycsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiAnc3RyaW5nJ1xuICAgIH0pXG4gICAgcmV0dXJuIGxhYmVsKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBsYWJlbChjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgY29kZSA9PT0gOTEgfHxcbiAgICAgIGNvZGUgPT09IDkzIHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkgfHxcbiAgICAgIHNpemUrKyA+IDk5OVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1N0cmluZycpXG4gICAgICByZXR1cm4gYXRCcmVhayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGRhdGEgPSBkYXRhIHx8ICFtYXJrZG93blNwYWNlKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IDkyID8gbGFiZWxFc2NhcGUgOiBsYWJlbFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gbGFiZWxFc2NhcGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA5MSB8fCBjb2RlID09PSA5MiB8fCBjb2RlID09PSA5Mykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBzaXplKytcbiAgICAgIHJldHVybiBsYWJlbFxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbChjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkVmZmVjdHN9IEVmZmVjdHNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvZGV9IENvZGVcbiAqL1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHttYXJrZG93bkxpbmVFbmRpbmd9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdHN9IGVmZmVjdHNcbiAqIEBwYXJhbSB7U3RhdGV9IG9rXG4gKiBAcGFyYW0ge1N0YXRlfSBub2tcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya2VyVHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1R5cGVcbiAqIEByZXR1cm5zIHtTdGF0ZX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbmV4cG9ydCBmdW5jdGlvbiBmYWN0b3J5VGl0bGUoZWZmZWN0cywgb2ssIG5vaywgdHlwZSwgbWFya2VyVHlwZSwgc3RyaW5nVHlwZSkge1xuICAvKiogQHR5cGUge05vbk51bGxhYmxlPENvZGU+fSAqL1xuICBsZXQgbWFya2VyXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKHR5cGUpXG4gICAgZWZmZWN0cy5lbnRlcihtYXJrZXJUeXBlKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdChtYXJrZXJUeXBlKVxuICAgIG1hcmtlciA9IGNvZGUgPT09IDQwID8gNDEgOiBjb2RlXG4gICAgcmV0dXJuIGF0Rmlyc3RUaXRsZUJyZWFrXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhdEZpcnN0VGl0bGVCcmVhayhjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgZWZmZWN0cy5lbnRlcihtYXJrZXJUeXBlKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQobWFya2VyVHlwZSlcbiAgICAgIGVmZmVjdHMuZXhpdCh0eXBlKVxuICAgICAgcmV0dXJuIG9rXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcihzdHJpbmdUeXBlKVxuICAgIHJldHVybiBhdFRpdGxlQnJlYWsoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGF0VGl0bGVCcmVhayhjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgZWZmZWN0cy5leGl0KHN0cmluZ1R5cGUpXG4gICAgICByZXR1cm4gYXRGaXJzdFRpdGxlQnJlYWsobWFya2VyKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfSAvLyBOb3RlOiBibGFuayBsaW5lcyBjYW5cdTIwMTl0IGV4aXN0IGluIGNvbnRlbnQuXG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdsaW5lRW5kaW5nJylcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYXRUaXRsZUJyZWFrLCAnbGluZVByZWZpeCcpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignY2h1bmtTdHJpbmcnLCB7XG4gICAgICBjb250ZW50VHlwZTogJ3N0cmluZydcbiAgICB9KVxuICAgIHJldHVybiB0aXRsZShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGl0bGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBtYXJrZXIgfHwgY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnY2h1bmtTdHJpbmcnKVxuICAgICAgcmV0dXJuIGF0VGl0bGVCcmVhayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBjb2RlID09PSA5MiA/IHRpdGxlRXNjYXBlIDogdGl0bGVcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRpdGxlRXNjYXBlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyIHx8IGNvZGUgPT09IDkyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0aXRsZVxuICAgIH1cblxuICAgIHJldHVybiB0aXRsZShjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkVmZmVjdHN9IEVmZmVjdHNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nLCBtYXJrZG93blNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3RzfSBlZmZlY3RzXG4gKiBAcGFyYW0ge1N0YXRlfSBva1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmFjdG9yeVdoaXRlc3BhY2UoZWZmZWN0cywgb2spIHtcbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICBsZXQgc2VlblxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignbGluZUVuZGluZycpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG4gICAgICBzZWVuID0gdHJ1ZVxuICAgICAgcmV0dXJuIHN0YXJ0XG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBzZWVuID8gJ2xpbmVQcmVmaXgnIDogJ2xpbmVTdWZmaXgnXG4gICAgICApKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIE5vcm1hbGl6ZSBhbiBpZGVudGlmaWVyIChzdWNoIGFzIHVzZWQgaW4gZGVmaW5pdGlvbnMpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUlkZW50aWZpZXIodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAvLyBDb2xsYXBzZSBNYXJrZG93biB3aGl0ZXNwYWNlLlxuICAgICAgLnJlcGxhY2UoL1tcXHRcXG5cXHIgXSsvZywgJyAnKSAvLyBUcmltLlxuICAgICAgLnJlcGxhY2UoL14gfCAkL2csICcnKSAvLyBTb21lIGNoYXJhY3RlcnMgYXJlIGNvbnNpZGVyZWQgXHUyMDFDdXBwZXJjYXNlXHUyMDFELCBidXQgaWYgdGhlaXIgbG93ZXJjYXNlXG4gICAgICAvLyBjb3VudGVycGFydCBpcyB1cHBlcmNhc2VkIHdpbGwgcmVzdWx0IGluIGEgZGlmZmVyZW50IHVwcGVyY2FzZVxuICAgICAgLy8gY2hhcmFjdGVyLlxuICAgICAgLy8gSGVuY2UsIHRvIGdldCB0aGF0IGZvcm0sIHdlIHBlcmZvcm0gYm90aCBsb3dlci0gYW5kIHVwcGVyY2FzZS5cbiAgICAgIC8vIFVwcGVyIGNhc2UgbWFrZXMgc3VyZSBrZXlzIHdpbGwgbm90IGludGVyYWN0IHdpdGggZGVmYXVsdCBwcm90b3R5cGFsXG4gICAgICAvLyBtZXRob2RzOiBubyBtZXRob2QgaXMgdXBwZXJjYXNlLlxuICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgIC50b1VwcGVyQ2FzZSgpXG4gIClcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeURlc3RpbmF0aW9ufSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1kZXN0aW5hdGlvbidcbmltcG9ydCB7ZmFjdG9yeUxhYmVsfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1sYWJlbCdcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7ZmFjdG9yeVRpdGxlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS10aXRsZSdcbmltcG9ydCB7ZmFjdG9yeVdoaXRlc3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXdoaXRlc3BhY2UnXG5pbXBvcnQge25vcm1hbGl6ZUlkZW50aWZpZXJ9IGZyb20gJ21pY3JvbWFyay11dGlsLW5vcm1hbGl6ZS1pZGVudGlmaWVyJ1xuaW1wb3J0IHtcbiAgbWFya2Rvd25MaW5lRW5kaW5nLFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5leHBvcnQgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgbmFtZTogJ2RlZmluaXRpb24nLFxuICB0b2tlbml6ZTogdG9rZW5pemVEZWZpbml0aW9uXG59XG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cblxuY29uc3QgdGl0bGVDb25zdHJ1Y3QgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZVRpdGxlLFxuICBwYXJ0aWFsOiB0cnVlXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVEZWZpbml0aW9uKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cbiAgbGV0IGlkZW50aWZpZXJcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2RlZmluaXRpb24nKVxuICAgIHJldHVybiBmYWN0b3J5TGFiZWwuY2FsbChcbiAgICAgIHNlbGYsXG4gICAgICBlZmZlY3RzLFxuICAgICAgbGFiZWxBZnRlcixcbiAgICAgIG5vayxcbiAgICAgICdkZWZpbml0aW9uTGFiZWwnLFxuICAgICAgJ2RlZmluaXRpb25MYWJlbE1hcmtlcicsXG4gICAgICAnZGVmaW5pdGlvbkxhYmVsU3RyaW5nJ1xuICAgICkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGxhYmVsQWZ0ZXIoY29kZSkge1xuICAgIGlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgc2VsZi5zbGljZVNlcmlhbGl6ZShzZWxmLmV2ZW50c1tzZWxmLmV2ZW50cy5sZW5ndGggLSAxXVsxXSkuc2xpY2UoMSwgLTEpXG4gICAgKVxuXG4gICAgaWYgKGNvZGUgPT09IDU4KSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdkZWZpbml0aW9uTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdkZWZpbml0aW9uTWFya2VyJykgLy8gTm90ZTogYmxhbmsgbGluZXMgY2FuXHUyMDE5dCBleGlzdCBpbiBjb250ZW50LlxuXG4gICAgICByZXR1cm4gZmFjdG9yeVdoaXRlc3BhY2UoXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGZhY3RvcnlEZXN0aW5hdGlvbihcbiAgICAgICAgICBlZmZlY3RzLFxuICAgICAgICAgIGVmZmVjdHMuYXR0ZW1wdChcbiAgICAgICAgICAgIHRpdGxlQ29uc3RydWN0LFxuICAgICAgICAgICAgZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGFmdGVyLCAnd2hpdGVzcGFjZScpLFxuICAgICAgICAgICAgZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGFmdGVyLCAnd2hpdGVzcGFjZScpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBub2ssXG4gICAgICAgICAgJ2RlZmluaXRpb25EZXN0aW5hdGlvbicsXG4gICAgICAgICAgJ2RlZmluaXRpb25EZXN0aW5hdGlvbkxpdGVyYWwnLFxuICAgICAgICAgICdkZWZpbml0aW9uRGVzdGluYXRpb25MaXRlcmFsTWFya2VyJyxcbiAgICAgICAgICAnZGVmaW5pdGlvbkRlc3RpbmF0aW9uUmF3JyxcbiAgICAgICAgICAnZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nJ1xuICAgICAgICApXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdkZWZpbml0aW9uJylcblxuICAgICAgaWYgKCFzZWxmLnBhcnNlci5kZWZpbmVkLmluY2x1ZGVzKGlkZW50aWZpZXIpKSB7XG4gICAgICAgIHNlbGYucGFyc2VyLmRlZmluZWQucHVzaChpZGVudGlmaWVyKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZVRpdGxlKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIHJldHVybiBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgICA/IGZhY3RvcnlXaGl0ZXNwYWNlKGVmZmVjdHMsIGJlZm9yZSkoY29kZSlcbiAgICAgIDogbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBiZWZvcmUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSAzNCB8fCBjb2RlID09PSAzOSB8fCBjb2RlID09PSA0MCkge1xuICAgICAgcmV0dXJuIGZhY3RvcnlUaXRsZShcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGFmdGVyLCAnd2hpdGVzcGFjZScpLFxuICAgICAgICBub2ssXG4gICAgICAgICdkZWZpbml0aW9uVGl0bGUnLFxuICAgICAgICAnZGVmaW5pdGlvblRpdGxlTWFya2VyJyxcbiAgICAgICAgJ2RlZmluaXRpb25UaXRsZVN0cmluZydcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpID8gb2soY29kZSkgOiBub2soY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHttYXJrZG93bkxpbmVFbmRpbmd9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5leHBvcnQgY29uc3QgaGFyZEJyZWFrRXNjYXBlID0ge1xuICBuYW1lOiAnaGFyZEJyZWFrRXNjYXBlJyxcbiAgdG9rZW5pemU6IHRva2VuaXplSGFyZEJyZWFrRXNjYXBlXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVIYXJkQnJlYWtFc2NhcGUoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignaGFyZEJyZWFrRXNjYXBlJylcbiAgICBlZmZlY3RzLmVudGVyKCdlc2NhcGVNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBvcGVuXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvcGVuKGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2VzY2FwZU1hcmtlcicpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2hhcmRCcmVha0VzY2FwZScpXG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUmVzb2x2ZXJ9IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHtcbiAgbWFya2Rvd25MaW5lRW5kaW5nLFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICBtYXJrZG93blNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmltcG9ydCB7c3BsaWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaHVua2VkJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBoZWFkaW5nQXR4ID0ge1xuICBuYW1lOiAnaGVhZGluZ0F0eCcsXG4gIHRva2VuaXplOiB0b2tlbml6ZUhlYWRpbmdBdHgsXG4gIHJlc29sdmU6IHJlc29sdmVIZWFkaW5nQXR4XG59XG4vKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuXG5mdW5jdGlvbiByZXNvbHZlSGVhZGluZ0F0eChldmVudHMsIGNvbnRleHQpIHtcbiAgbGV0IGNvbnRlbnRFbmQgPSBldmVudHMubGVuZ3RoIC0gMlxuICBsZXQgY29udGVudFN0YXJ0ID0gM1xuICAvKiogQHR5cGUge1Rva2VufSAqL1xuXG4gIGxldCBjb250ZW50XG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG5cbiAgbGV0IHRleHQgLy8gUHJlZml4IHdoaXRlc3BhY2UsIHBhcnQgb2YgdGhlIG9wZW5pbmcuXG5cbiAgaWYgKGV2ZW50c1tjb250ZW50U3RhcnRdWzFdLnR5cGUgPT09ICd3aGl0ZXNwYWNlJykge1xuICAgIGNvbnRlbnRTdGFydCArPSAyXG4gIH0gLy8gU3VmZml4IHdoaXRlc3BhY2UsIHBhcnQgb2YgdGhlIGNsb3NpbmcuXG5cbiAgaWYgKFxuICAgIGNvbnRlbnRFbmQgLSAyID4gY29udGVudFN0YXJ0ICYmXG4gICAgZXZlbnRzW2NvbnRlbnRFbmRdWzFdLnR5cGUgPT09ICd3aGl0ZXNwYWNlJ1xuICApIHtcbiAgICBjb250ZW50RW5kIC09IDJcbiAgfVxuXG4gIGlmIChcbiAgICBldmVudHNbY29udGVudEVuZF1bMV0udHlwZSA9PT0gJ2F0eEhlYWRpbmdTZXF1ZW5jZScgJiZcbiAgICAoY29udGVudFN0YXJ0ID09PSBjb250ZW50RW5kIC0gMSB8fFxuICAgICAgKGNvbnRlbnRFbmQgLSA0ID4gY29udGVudFN0YXJ0ICYmXG4gICAgICAgIGV2ZW50c1tjb250ZW50RW5kIC0gMl1bMV0udHlwZSA9PT0gJ3doaXRlc3BhY2UnKSlcbiAgKSB7XG4gICAgY29udGVudEVuZCAtPSBjb250ZW50U3RhcnQgKyAxID09PSBjb250ZW50RW5kID8gMiA6IDRcbiAgfVxuXG4gIGlmIChjb250ZW50RW5kID4gY29udGVudFN0YXJ0KSB7XG4gICAgY29udGVudCA9IHtcbiAgICAgIHR5cGU6ICdhdHhIZWFkaW5nVGV4dCcsXG4gICAgICBzdGFydDogZXZlbnRzW2NvbnRlbnRTdGFydF1bMV0uc3RhcnQsXG4gICAgICBlbmQ6IGV2ZW50c1tjb250ZW50RW5kXVsxXS5lbmRcbiAgICB9XG4gICAgdGV4dCA9IHtcbiAgICAgIHR5cGU6ICdjaHVua1RleHQnLFxuICAgICAgc3RhcnQ6IGV2ZW50c1tjb250ZW50U3RhcnRdWzFdLnN0YXJ0LFxuICAgICAgZW5kOiBldmVudHNbY29udGVudEVuZF1bMV0uZW5kLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBDb25zdGFudHMgYXJlIGZpbmUgdG8gYXNzaWduLlxuICAgICAgY29udGVudFR5cGU6ICd0ZXh0J1xuICAgIH1cbiAgICBzcGxpY2UoZXZlbnRzLCBjb250ZW50U3RhcnQsIGNvbnRlbnRFbmQgLSBjb250ZW50U3RhcnQgKyAxLCBbXG4gICAgICBbJ2VudGVyJywgY29udGVudCwgY29udGV4dF0sXG4gICAgICBbJ2VudGVyJywgdGV4dCwgY29udGV4dF0sXG4gICAgICBbJ2V4aXQnLCB0ZXh0LCBjb250ZXh0XSxcbiAgICAgIFsnZXhpdCcsIGNvbnRlbnQsIGNvbnRleHRdXG4gICAgXSlcbiAgfVxuXG4gIHJldHVybiBldmVudHNcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUhlYWRpbmdBdHgoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgc2l6ZSA9IDBcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2F0eEhlYWRpbmcnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2F0eEhlYWRpbmdTZXF1ZW5jZScpXG4gICAgcmV0dXJuIGZlbmNlT3Blbkluc2lkZShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZmVuY2VPcGVuSW5zaWRlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gMzUgJiYgc2l6ZSsrIDwgNikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZmVuY2VPcGVuSW5zaWRlXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdhdHhIZWFkaW5nU2VxdWVuY2UnKVxuICAgICAgcmV0dXJuIHNlbGYuaW50ZXJydXB0ID8gb2soY29kZSkgOiBoZWFkaW5nQnJlYWsoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBoZWFkaW5nQnJlYWsoY29kZSkge1xuICAgIGlmIChjb2RlID09PSAzNSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignYXR4SGVhZGluZ1NlcXVlbmNlJylcbiAgICAgIHJldHVybiBzZXF1ZW5jZShjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdhdHhIZWFkaW5nJylcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGhlYWRpbmdCcmVhaywgJ3doaXRlc3BhY2UnKShjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2F0eEhlYWRpbmdUZXh0JylcbiAgICByZXR1cm4gZGF0YShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc2VxdWVuY2UoY29kZSkge1xuICAgIGlmIChjb2RlID09PSAzNSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gc2VxdWVuY2VcbiAgICB9XG5cbiAgICBlZmZlY3RzLmV4aXQoJ2F0eEhlYWRpbmdTZXF1ZW5jZScpXG4gICAgcmV0dXJuIGhlYWRpbmdCcmVhayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGF0YShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgY29kZSA9PT0gMzUgfHwgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdhdHhIZWFkaW5nVGV4dCcpXG4gICAgICByZXR1cm4gaGVhZGluZ0JyZWFrKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxufVxuIiwgIi8qKlxuICogTGlzdCBvZiBsb3dlcmNhc2UgSFRNTCB0YWcgbmFtZXMgd2hpY2ggd2hlbiBwYXJzaW5nIEhUTUwgKGZsb3cpLCByZXN1bHRcbiAqIGluIG1vcmUgcmVsYXhlZCBydWxlcyAoY29uZGl0aW9uIDYpOiBiZWNhdXNlIHRoZXkgYXJlIGtub3duIGJsb2NrcywgdGhlXG4gKiBIVE1MLWxpa2Ugc3ludGF4IGRvZXNuXHUyMDE5dCBoYXZlIHRvIGJlIHN0cmljdGx5IHBhcnNlZC5cbiAqIEZvciB0YWcgbmFtZXMgbm90IGluIHRoaXMgbGlzdCwgYSBtb3JlIHN0cmljdCBhbGdvcml0aG0gKGNvbmRpdGlvbiA3KSBpcyB1c2VkXG4gKiB0byBkZXRlY3Qgd2hldGhlciB0aGUgSFRNTC1saWtlIHN5bnRheCBpcyBzZWVuIGFzIEhUTUwgKGZsb3cpIG9yIG5vdC5cbiAqXG4gKiBUaGlzIGlzIGNvcGllZCBmcm9tOlxuICogPGh0dHBzOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjMwLyNodG1sLWJsb2Nrcz4uXG4gKi9cbmV4cG9ydCBjb25zdCBodG1sQmxvY2tOYW1lcyA9IFtcbiAgJ2FkZHJlc3MnLFxuICAnYXJ0aWNsZScsXG4gICdhc2lkZScsXG4gICdiYXNlJyxcbiAgJ2Jhc2Vmb250JyxcbiAgJ2Jsb2NrcXVvdGUnLFxuICAnYm9keScsXG4gICdjYXB0aW9uJyxcbiAgJ2NlbnRlcicsXG4gICdjb2wnLFxuICAnY29sZ3JvdXAnLFxuICAnZGQnLFxuICAnZGV0YWlscycsXG4gICdkaWFsb2cnLFxuICAnZGlyJyxcbiAgJ2RpdicsXG4gICdkbCcsXG4gICdkdCcsXG4gICdmaWVsZHNldCcsXG4gICdmaWdjYXB0aW9uJyxcbiAgJ2ZpZ3VyZScsXG4gICdmb290ZXInLFxuICAnZm9ybScsXG4gICdmcmFtZScsXG4gICdmcmFtZXNldCcsXG4gICdoMScsXG4gICdoMicsXG4gICdoMycsXG4gICdoNCcsXG4gICdoNScsXG4gICdoNicsXG4gICdoZWFkJyxcbiAgJ2hlYWRlcicsXG4gICdocicsXG4gICdodG1sJyxcbiAgJ2lmcmFtZScsXG4gICdsZWdlbmQnLFxuICAnbGknLFxuICAnbGluaycsXG4gICdtYWluJyxcbiAgJ21lbnUnLFxuICAnbWVudWl0ZW0nLFxuICAnbmF2JyxcbiAgJ25vZnJhbWVzJyxcbiAgJ29sJyxcbiAgJ29wdGdyb3VwJyxcbiAgJ29wdGlvbicsXG4gICdwJyxcbiAgJ3BhcmFtJyxcbiAgJ3NlY3Rpb24nLFxuICAnc3VtbWFyeScsXG4gICd0YWJsZScsXG4gICd0Ym9keScsXG4gICd0ZCcsXG4gICd0Zm9vdCcsXG4gICd0aCcsXG4gICd0aGVhZCcsXG4gICd0aXRsZScsXG4gICd0cicsXG4gICd0cmFjaycsXG4gICd1bCdcbl1cblxuLyoqXG4gKiBMaXN0IG9mIGxvd2VyY2FzZSBIVE1MIHRhZyBuYW1lcyB3aGljaCB3aGVuIHBhcnNpbmcgSFRNTCAoZmxvdyksIHJlc3VsdCBpblxuICogSFRNTCB0aGF0IGNhbiBpbmNsdWRlIGxpbmVzIHcvbyBleGl0aW5nLCB1bnRpbCBhIGNsb3NpbmcgdGFnIGFsc28gaW4gdGhpc1xuICogbGlzdCBpcyBmb3VuZCAoY29uZGl0aW9uIDEpLlxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIGNvcGllZCBmcm9tOlxuICogPGh0dHBzOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjMwLyNodG1sLWJsb2Nrcz4uXG4gKlxuICogTm90ZSB0aGF0IGB0ZXh0YXJlYWAgd2FzIGFkZGVkIGluIGBDb21tb25NYXJrQDAuMzBgLlxuICovXG5leHBvcnQgY29uc3QgaHRtbFJhd05hbWVzID0gWydwcmUnLCAnc2NyaXB0JywgJ3N0eWxlJywgJ3RleHRhcmVhJ11cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUmVzb2x2ZXJ9IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKi9cbmltcG9ydCB7XG4gIGFzY2lpQWxwaGEsXG4gIGFzY2lpQWxwaGFudW1lcmljLFxuICBtYXJrZG93bkxpbmVFbmRpbmcsXG4gIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UsXG4gIG1hcmtkb3duU3BhY2Vcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuaW1wb3J0IHtodG1sQmxvY2tOYW1lcywgaHRtbFJhd05hbWVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1odG1sLXRhZy1uYW1lJ1xuaW1wb3J0IHtibGFua0xpbmV9IGZyb20gJy4vYmxhbmstbGluZS5qcydcbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5leHBvcnQgY29uc3QgaHRtbEZsb3cgPSB7XG4gIG5hbWU6ICdodG1sRmxvdycsXG4gIHRva2VuaXplOiB0b2tlbml6ZUh0bWxGbG93LFxuICByZXNvbHZlVG86IHJlc29sdmVUb0h0bWxGbG93LFxuICBjb25jcmV0ZTogdHJ1ZVxufVxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbmNvbnN0IG5leHRCbGFua0NvbnN0cnVjdCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplTmV4dEJsYW5rLFxuICBwYXJ0aWFsOiB0cnVlXG59XG4vKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVG9IdG1sRmxvdyhldmVudHMpIHtcbiAgbGV0IGluZGV4ID0gZXZlbnRzLmxlbmd0aFxuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgaWYgKGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcicgJiYgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnaHRtbEZsb3cnKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRleCA+IDEgJiYgZXZlbnRzW2luZGV4IC0gMl1bMV0udHlwZSA9PT0gJ2xpbmVQcmVmaXgnKSB7XG4gICAgLy8gQWRkIHRoZSBwcmVmaXggc3RhcnQgdG8gdGhlIEhUTUwgdG9rZW4uXG4gICAgZXZlbnRzW2luZGV4XVsxXS5zdGFydCA9IGV2ZW50c1tpbmRleCAtIDJdWzFdLnN0YXJ0IC8vIEFkZCB0aGUgcHJlZml4IHN0YXJ0IHRvIHRoZSBIVE1MIGxpbmUgdG9rZW4uXG5cbiAgICBldmVudHNbaW5kZXggKyAxXVsxXS5zdGFydCA9IGV2ZW50c1tpbmRleCAtIDJdWzFdLnN0YXJ0IC8vIFJlbW92ZSB0aGUgbGluZSBwcmVmaXguXG5cbiAgICBldmVudHMuc3BsaWNlKGluZGV4IC0gMiwgMilcbiAgfVxuXG4gIHJldHVybiBldmVudHNcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUh0bWxGbG93KGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgbGV0IGtpbmRcbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuXG4gIGxldCBzdGFydFRhZ1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cblxuICBsZXQgYnVmZmVyXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXG4gIGxldCBpbmRleFxuICAvKiogQHR5cGUge0NvZGV9ICovXG5cbiAgbGV0IG1hcmtlclxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignaHRtbEZsb3cnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2h0bWxGbG93RGF0YScpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIG9wZW5cbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIG9wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSAzMykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZGVjbGFyYXRpb25TdGFydFxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdGFnQ2xvc2VTdGFydFxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA2Mykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBraW5kID0gMyAvLyBXaGlsZSB3ZVx1MjAxOXJlIGluIGFuIGluc3RydWN0aW9uIGluc3RlYWQgb2YgYSBkZWNsYXJhdGlvbiwgd2VcdTIwMTlyZSBvbiBhIGA/YFxuICAgICAgLy8gcmlnaHQgbm93LCBzbyB3ZSBkbyBuZWVkIHRvIHNlYXJjaCBmb3IgYD5gLCBzaW1pbGFyIHRvIGRlY2xhcmF0aW9ucy5cblxuICAgICAgcmV0dXJuIHNlbGYuaW50ZXJydXB0ID8gb2sgOiBjb250aW51YXRpb25EZWNsYXJhdGlvbkluc2lkZVxuICAgIH1cblxuICAgIGlmIChhc2NpaUFscGhhKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGJ1ZmZlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgIHN0YXJ0VGFnID0gdHJ1ZVxuICAgICAgcmV0dXJuIHRhZ05hbWVcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkZWNsYXJhdGlvblN0YXJ0KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDUpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAga2luZCA9IDJcbiAgICAgIHJldHVybiBjb21tZW50T3Blbkluc2lkZVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA5MSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBraW5kID0gNVxuICAgICAgYnVmZmVyID0gJ0NEQVRBWydcbiAgICAgIGluZGV4ID0gMFxuICAgICAgcmV0dXJuIGNkYXRhT3Blbkluc2lkZVxuICAgIH1cblxuICAgIGlmIChhc2NpaUFscGhhKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGtpbmQgPSA0XG4gICAgICByZXR1cm4gc2VsZi5pbnRlcnJ1cHQgPyBvayA6IGNvbnRpbnVhdGlvbkRlY2xhcmF0aW9uSW5zaWRlXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29tbWVudE9wZW5JbnNpZGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0NSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gc2VsZi5pbnRlcnJ1cHQgPyBvayA6IGNvbnRpbnVhdGlvbkRlY2xhcmF0aW9uSW5zaWRlXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY2RhdGFPcGVuSW5zaWRlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gYnVmZmVyLmNoYXJDb2RlQXQoaW5kZXgrKykpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluZGV4ID09PSBidWZmZXIubGVuZ3RoXG4gICAgICAgID8gc2VsZi5pbnRlcnJ1cHRcbiAgICAgICAgICA/IG9rXG4gICAgICAgICAgOiBjb250aW51YXRpb25cbiAgICAgICAgOiBjZGF0YU9wZW5JbnNpZGVcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB0YWdDbG9zZVN0YXJ0KGNvZGUpIHtcbiAgICBpZiAoYXNjaWlBbHBoYShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBidWZmZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICByZXR1cm4gdGFnTmFtZVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhZ05hbWUoY29kZSkge1xuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IG51bGwgfHxcbiAgICAgIGNvZGUgPT09IDQ3IHx8XG4gICAgICBjb2RlID09PSA2MiB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBjb2RlICE9PSA0NyAmJlxuICAgICAgICBzdGFydFRhZyAmJlxuICAgICAgICBodG1sUmF3TmFtZXMuaW5jbHVkZXMoYnVmZmVyLnRvTG93ZXJDYXNlKCkpXG4gICAgICApIHtcbiAgICAgICAga2luZCA9IDFcbiAgICAgICAgcmV0dXJuIHNlbGYuaW50ZXJydXB0ID8gb2soY29kZSkgOiBjb250aW51YXRpb24oY29kZSlcbiAgICAgIH1cblxuICAgICAgaWYgKGh0bWxCbG9ja05hbWVzLmluY2x1ZGVzKGJ1ZmZlci50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBraW5kID0gNlxuXG4gICAgICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgICAgIHJldHVybiBiYXNpY1NlbGZDbG9zaW5nXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi5pbnRlcnJ1cHQgPyBvayhjb2RlKSA6IGNvbnRpbnVhdGlvbihjb2RlKVxuICAgICAgfVxuXG4gICAgICBraW5kID0gNyAvLyBEbyBub3Qgc3VwcG9ydCBjb21wbGV0ZSBIVE1MIHdoZW4gaW50ZXJydXB0aW5nXG5cbiAgICAgIHJldHVybiBzZWxmLmludGVycnVwdCAmJiAhc2VsZi5wYXJzZXIubGF6eVtzZWxmLm5vdygpLmxpbmVdXG4gICAgICAgID8gbm9rKGNvZGUpXG4gICAgICAgIDogc3RhcnRUYWdcbiAgICAgICAgPyBjb21wbGV0ZUF0dHJpYnV0ZU5hbWVCZWZvcmUoY29kZSlcbiAgICAgICAgOiBjb21wbGV0ZUNsb3NpbmdUYWdBZnRlcihjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA0NSB8fCBhc2NpaUFscGhhbnVtZXJpYyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBidWZmZXIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgcmV0dXJuIHRhZ05hbWVcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBiYXNpY1NlbGZDbG9zaW5nKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHNlbGYuaW50ZXJydXB0ID8gb2sgOiBjb250aW51YXRpb25cbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21wbGV0ZUNsb3NpbmdUYWdBZnRlcihjb2RlKSB7XG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbXBsZXRlQ2xvc2luZ1RhZ0FmdGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBsZXRlRW5kKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21wbGV0ZUF0dHJpYnV0ZU5hbWVCZWZvcmUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tcGxldGVFbmRcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNTggfHwgY29kZSA9PT0gOTUgfHwgYXNjaWlBbHBoYShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tcGxldGVBdHRyaWJ1dGVOYW1lXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlTmFtZUJlZm9yZVxuICAgIH1cblxuICAgIHJldHVybiBjb21wbGV0ZUVuZChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29tcGxldGVBdHRyaWJ1dGVOYW1lKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSA0NSB8fFxuICAgICAgY29kZSA9PT0gNDYgfHxcbiAgICAgIGNvZGUgPT09IDU4IHx8XG4gICAgICBjb2RlID09PSA5NSB8fFxuICAgICAgYXNjaWlBbHBoYW51bWVyaWMoY29kZSlcbiAgICApIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlTmFtZVxuICAgIH1cblxuICAgIHJldHVybiBjb21wbGV0ZUF0dHJpYnV0ZU5hbWVBZnRlcihjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29tcGxldGVBdHRyaWJ1dGVOYW1lQWZ0ZXIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA2MSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tcGxldGVBdHRyaWJ1dGVWYWx1ZUJlZm9yZVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb21wbGV0ZUF0dHJpYnV0ZU5hbWVBZnRlclxuICAgIH1cblxuICAgIHJldHVybiBjb21wbGV0ZUF0dHJpYnV0ZU5hbWVCZWZvcmUoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlQXR0cmlidXRlVmFsdWVCZWZvcmUoY29kZSkge1xuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IG51bGwgfHxcbiAgICAgIGNvZGUgPT09IDYwIHx8XG4gICAgICBjb2RlID09PSA2MSB8fFxuICAgICAgY29kZSA9PT0gNjIgfHxcbiAgICAgIGNvZGUgPT09IDk2XG4gICAgKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDM0IHx8IGNvZGUgPT09IDM5KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIG1hcmtlciA9IGNvZGVcbiAgICAgIHJldHVybiBjb21wbGV0ZUF0dHJpYnV0ZVZhbHVlUXVvdGVkXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlVmFsdWVCZWZvcmVcbiAgICB9XG5cbiAgICBtYXJrZXIgPSBudWxsXG4gICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlVmFsdWVVbnF1b3RlZChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29tcGxldGVBdHRyaWJ1dGVWYWx1ZVF1b3RlZChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tcGxldGVBdHRyaWJ1dGVWYWx1ZVF1b3RlZEFmdGVyXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlVmFsdWVRdW90ZWRcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlQXR0cmlidXRlVmFsdWVVbnF1b3RlZChjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgY29kZSA9PT0gMzQgfHxcbiAgICAgIGNvZGUgPT09IDM5IHx8XG4gICAgICBjb2RlID09PSA2MCB8fFxuICAgICAgY29kZSA9PT0gNjEgfHxcbiAgICAgIGNvZGUgPT09IDYyIHx8XG4gICAgICBjb2RlID09PSA5NiB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlTmFtZUFmdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlVmFsdWVVbnF1b3RlZFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29tcGxldGVBdHRyaWJ1dGVWYWx1ZVF1b3RlZEFmdGVyKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDcgfHwgY29kZSA9PT0gNjIgfHwgbWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgcmV0dXJuIGNvbXBsZXRlQXR0cmlidXRlTmFtZUJlZm9yZShjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlRW5kKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbXBsZXRlQWZ0ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21wbGV0ZUFmdGVyKGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tcGxldGVBZnRlclxuICAgIH1cblxuICAgIHJldHVybiBjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKVxuICAgICAgPyBjb250aW51YXRpb24oY29kZSlcbiAgICAgIDogbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250aW51YXRpb24oY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0NSAmJiBraW5kID09PSAyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb250aW51YXRpb25Db21tZW50SW5zaWRlXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDYwICYmIGtpbmQgPT09IDEpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbnRpbnVhdGlvblJhd1RhZ09wZW5cbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNjIgJiYga2luZCA9PT0gNCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29udGludWF0aW9uQ2xvc2VcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNjMgJiYga2luZCA9PT0gMykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29udGludWF0aW9uRGVjbGFyYXRpb25JbnNpZGVcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gOTMgJiYga2luZCA9PT0gNSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29udGludWF0aW9uQ2hhcmFjdGVyRGF0YUluc2lkZVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkgJiYgKGtpbmQgPT09IDYgfHwga2luZCA9PT0gNykpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKFxuICAgICAgICBuZXh0QmxhbmtDb25zdHJ1Y3QsXG4gICAgICAgIGNvbnRpbnVhdGlvbkNsb3NlLFxuICAgICAgICBjb250aW51YXRpb25BdExpbmVFbmRpbmdcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBjb250aW51YXRpb25BdExpbmVFbmRpbmcoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29udGludWF0aW9uXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250aW51YXRpb25BdExpbmVFbmRpbmcoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnaHRtbEZsb3dEYXRhJylcbiAgICByZXR1cm4gaHRtbENvbnRpbnVlU3RhcnQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGh0bWxDb250aW51ZVN0YXJ0KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRvbmUoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICB7XG4gICAgICAgICAgdG9rZW5pemU6IGh0bWxMaW5lRW5kLFxuICAgICAgICAgIHBhcnRpYWw6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgaHRtbENvbnRpbnVlU3RhcnQsXG4gICAgICAgIGRvbmVcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdodG1sRmxvd0RhdGEnKVxuICAgIHJldHVybiBjb250aW51YXRpb24oY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuICBmdW5jdGlvbiBodG1sTGluZUVuZChlZmZlY3RzLCBvaywgbm9rKSB7XG4gICAgcmV0dXJuIHN0YXJ0XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgICAgcmV0dXJuIGxpbmVTdGFydFxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KGNvZGUpIHtcbiAgICAgIHJldHVybiBzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0gPyBub2soY29kZSkgOiBvayhjb2RlKVxuICAgIH1cbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRpbnVhdGlvbkNvbW1lbnRJbnNpZGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0NSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29udGludWF0aW9uRGVjbGFyYXRpb25JbnNpZGVcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGludWF0aW9uKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250aW51YXRpb25SYXdUYWdPcGVuKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgYnVmZmVyID0gJydcbiAgICAgIHJldHVybiBjb250aW51YXRpb25SYXdFbmRUYWdcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGludWF0aW9uKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250aW51YXRpb25SYXdFbmRUYWcoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA2MiAmJiBodG1sUmF3TmFtZXMuaW5jbHVkZXMoYnVmZmVyLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb250aW51YXRpb25DbG9zZVxuICAgIH1cblxuICAgIGlmIChhc2NpaUFscGhhKGNvZGUpICYmIGJ1ZmZlci5sZW5ndGggPCA4KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGJ1ZmZlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICByZXR1cm4gY29udGludWF0aW9uUmF3RW5kVGFnXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRpbnVhdGlvbihjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29udGludWF0aW9uQ2hhcmFjdGVyRGF0YUluc2lkZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDkzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb250aW51YXRpb25EZWNsYXJhdGlvbkluc2lkZVxuICAgIH1cblxuICAgIHJldHVybiBjb250aW51YXRpb24oY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRpbnVhdGlvbkRlY2xhcmF0aW9uSW5zaWRlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNvbnRpbnVhdGlvbkNsb3NlXG4gICAgfSAvLyBNb3JlIGRhc2hlcy5cblxuICAgIGlmIChjb2RlID09PSA0NSAmJiBraW5kID09PSAyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb250aW51YXRpb25EZWNsYXJhdGlvbkluc2lkZVxuICAgIH1cblxuICAgIHJldHVybiBjb250aW51YXRpb24oY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRpbnVhdGlvbkNsb3NlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnaHRtbEZsb3dEYXRhJylcbiAgICAgIHJldHVybiBkb25lKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvbnRpbnVhdGlvbkNsb3NlXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkb25lKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ2h0bWxGbG93JylcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplTmV4dEJsYW5rKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnaHRtbEZsb3dEYXRhJylcbiAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nQmxhbmsnKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZ0JsYW5rJylcbiAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KGJsYW5rTGluZSwgb2ssIG5vaylcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge1xuICBhc2NpaUFscGhhLFxuICBhc2NpaUFscGhhbnVtZXJpYyxcbiAgbWFya2Rvd25MaW5lRW5kaW5nLFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICBtYXJrZG93blNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5leHBvcnQgY29uc3QgaHRtbFRleHQgPSB7XG4gIG5hbWU6ICdodG1sVGV4dCcsXG4gIHRva2VuaXplOiB0b2tlbml6ZUh0bWxUZXh0XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVIdG1sVGV4dChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8qKiBAdHlwZSB7Tm9uTnVsbGFibGU8Q29kZT58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBtYXJrZXJcbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cbiAgbGV0IGJ1ZmZlclxuICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICBsZXQgaW5kZXhcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBsZXQgcmV0dXJuU3RhdGVcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2h0bWxUZXh0JylcbiAgICBlZmZlY3RzLmVudGVyKCdodG1sVGV4dERhdGEnKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBvcGVuXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBvcGVuKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gMzMpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uT3BlblxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdGFnQ2xvc2VTdGFydFxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA2Mykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25cbiAgICB9XG5cbiAgICBpZiAoYXNjaWlBbHBoYShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdGFnT3BlblxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRlY2xhcmF0aW9uT3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ1KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjb21tZW50T3BlblxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA5MSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBidWZmZXIgPSAnQ0RBVEFbJ1xuICAgICAgaW5kZXggPSAwXG4gICAgICByZXR1cm4gY2RhdGFPcGVuXG4gICAgfVxuXG4gICAgaWYgKGFzY2lpQWxwaGEoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29tbWVudE9wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0NSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tbWVudFN0YXJ0XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29tbWVudFN0YXJ0KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSA2Mikge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA0NSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tbWVudFN0YXJ0RGFzaFxuICAgIH1cblxuICAgIHJldHVybiBjb21tZW50KGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21tZW50U3RhcnREYXNoKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSA2Mikge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBjb21tZW50KGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb21tZW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA0NSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29tbWVudENsb3NlXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuU3RhdGUgPSBjb21tZW50XG4gICAgICByZXR1cm4gYXRMaW5lRW5kaW5nKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvbW1lbnRcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbW1lbnRDbG9zZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ1KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBlbmRcbiAgICB9XG5cbiAgICByZXR1cm4gY29tbWVudChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY2RhdGFPcGVuKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gYnVmZmVyLmNoYXJDb2RlQXQoaW5kZXgrKykpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluZGV4ID09PSBidWZmZXIubGVuZ3RoID8gY2RhdGEgOiBjZGF0YU9wZW5cbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjZGF0YShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gOTMpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNkYXRhQ2xvc2VcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm5TdGF0ZSA9IGNkYXRhXG4gICAgICByZXR1cm4gYXRMaW5lRW5kaW5nKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNkYXRhXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjZGF0YUNsb3NlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gOTMpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNkYXRhRW5kXG4gICAgfVxuXG4gICAgcmV0dXJuIGNkYXRhKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjZGF0YUVuZChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDYyKSB7XG4gICAgICByZXR1cm4gZW5kKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDkzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBjZGF0YUVuZFxuICAgIH1cblxuICAgIHJldHVybiBjZGF0YShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGVjbGFyYXRpb24oY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IDYyKSB7XG4gICAgICByZXR1cm4gZW5kKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuU3RhdGUgPSBkZWNsYXJhdGlvblxuICAgICAgcmV0dXJuIGF0TGluZUVuZGluZyhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBkZWNsYXJhdGlvblxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5zdHJ1Y3Rpb24oY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDYzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbnN0cnVjdGlvbkNsb3NlXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuU3RhdGUgPSBpbnN0cnVjdGlvblxuICAgICAgcmV0dXJuIGF0TGluZUVuZGluZyhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBpbnN0cnVjdGlvblxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5zdHJ1Y3Rpb25DbG9zZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IDYyID8gZW5kKGNvZGUpIDogaW5zdHJ1Y3Rpb24oY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhZ0Nsb3NlU3RhcnQoY29kZSkge1xuICAgIGlmIChhc2NpaUFscGhhKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0YWdDbG9zZVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhZ0Nsb3NlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDUgfHwgYXNjaWlBbHBoYW51bWVyaWMoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRhZ0Nsb3NlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZ0Nsb3NlQmV0d2Vlbihjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGFnQ2xvc2VCZXR3ZWVuKGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm5TdGF0ZSA9IHRhZ0Nsb3NlQmV0d2VlblxuICAgICAgcmV0dXJuIGF0TGluZUVuZGluZyhjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0YWdDbG9zZUJldHdlZW5cbiAgICB9XG5cbiAgICByZXR1cm4gZW5kKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB0YWdPcGVuKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDUgfHwgYXNjaWlBbHBoYW51bWVyaWMoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRhZ09wZW5cbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNDcgfHwgY29kZSA9PT0gNjIgfHwgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgcmV0dXJuIHRhZ09wZW5CZXR3ZWVuKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGFnT3BlbkJldHdlZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZW5kXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDU4IHx8IGNvZGUgPT09IDk1IHx8IGFzY2lpQWxwaGEoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRhZ09wZW5BdHRyaWJ1dGVOYW1lXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuU3RhdGUgPSB0YWdPcGVuQmV0d2VlblxuICAgICAgcmV0dXJuIGF0TGluZUVuZGluZyhjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0YWdPcGVuQmV0d2VlblxuICAgIH1cblxuICAgIHJldHVybiBlbmQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhZ09wZW5BdHRyaWJ1dGVOYW1lKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSA0NSB8fFxuICAgICAgY29kZSA9PT0gNDYgfHxcbiAgICAgIGNvZGUgPT09IDU4IHx8XG4gICAgICBjb2RlID09PSA5NSB8fFxuICAgICAgYXNjaWlBbHBoYW51bWVyaWMoY29kZSlcbiAgICApIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRhZ09wZW5BdHRyaWJ1dGVOYW1lXG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZ09wZW5BdHRyaWJ1dGVOYW1lQWZ0ZXIoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhZ09wZW5BdHRyaWJ1dGVOYW1lQWZ0ZXIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA2MSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdGFnT3BlbkF0dHJpYnV0ZVZhbHVlQmVmb3JlXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuU3RhdGUgPSB0YWdPcGVuQXR0cmlidXRlTmFtZUFmdGVyXG4gICAgICByZXR1cm4gYXRMaW5lRW5kaW5nKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRhZ09wZW5BdHRyaWJ1dGVOYW1lQWZ0ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gdGFnT3BlbkJldHdlZW4oY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhZ09wZW5BdHRyaWJ1dGVWYWx1ZUJlZm9yZShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgY29kZSA9PT0gNjAgfHxcbiAgICAgIGNvZGUgPT09IDYxIHx8XG4gICAgICBjb2RlID09PSA2MiB8fFxuICAgICAgY29kZSA9PT0gOTZcbiAgICApIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMzQgfHwgY29kZSA9PT0gMzkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgbWFya2VyID0gY29kZVxuICAgICAgcmV0dXJuIHRhZ09wZW5BdHRyaWJ1dGVWYWx1ZVF1b3RlZFxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVyblN0YXRlID0gdGFnT3BlbkF0dHJpYnV0ZVZhbHVlQmVmb3JlXG4gICAgICByZXR1cm4gYXRMaW5lRW5kaW5nKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRhZ09wZW5BdHRyaWJ1dGVWYWx1ZUJlZm9yZVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIG1hcmtlciA9IHVuZGVmaW5lZFxuICAgIHJldHVybiB0YWdPcGVuQXR0cmlidXRlVmFsdWVVbnF1b3RlZFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdGFnT3BlbkF0dHJpYnV0ZVZhbHVlUXVvdGVkKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0YWdPcGVuQXR0cmlidXRlVmFsdWVRdW90ZWRBZnRlclxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuU3RhdGUgPSB0YWdPcGVuQXR0cmlidXRlVmFsdWVRdW90ZWRcbiAgICAgIHJldHVybiBhdExpbmVFbmRpbmcoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gdGFnT3BlbkF0dHJpYnV0ZVZhbHVlUXVvdGVkXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB0YWdPcGVuQXR0cmlidXRlVmFsdWVRdW90ZWRBZnRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDYyIHx8IGNvZGUgPT09IDQ3IHx8IG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiB0YWdPcGVuQmV0d2Vlbihjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhZ09wZW5BdHRyaWJ1dGVWYWx1ZVVucXVvdGVkKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBudWxsIHx8XG4gICAgICBjb2RlID09PSAzNCB8fFxuICAgICAgY29kZSA9PT0gMzkgfHxcbiAgICAgIGNvZGUgPT09IDYwIHx8XG4gICAgICBjb2RlID09PSA2MSB8fFxuICAgICAgY29kZSA9PT0gOTZcbiAgICApIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNjIgfHwgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgcmV0dXJuIHRhZ09wZW5CZXR3ZWVuKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIHRhZ09wZW5BdHRyaWJ1dGVWYWx1ZVVucXVvdGVkXG4gIH0gLy8gV2UgY2FuXHUyMDE5dCBoYXZlIGJsYW5rIGxpbmVzIGluIGNvbnRlbnQsIHNvIG5vIG5lZWQgdG8gd29ycnkgYWJvdXQgZW1wdHlcbiAgLy8gdG9rZW5zLlxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYXRMaW5lRW5kaW5nKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ2h0bWxUZXh0RGF0YScpXG4gICAgZWZmZWN0cy5lbnRlcignbGluZUVuZGluZycpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdsaW5lRW5kaW5nJylcbiAgICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgICAgZWZmZWN0cyxcbiAgICAgIGFmdGVyUHJlZml4LFxuICAgICAgJ2xpbmVQcmVmaXgnLFxuICAgICAgc2VsZi5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoJ2NvZGVJbmRlbnRlZCcpXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogNFxuICAgIClcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyUHJlZml4KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdodG1sVGV4dERhdGEnKVxuICAgIHJldHVybiByZXR1cm5TdGF0ZShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZW5kKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdodG1sVGV4dERhdGEnKVxuICAgICAgZWZmZWN0cy5leGl0KCdodG1sVGV4dCcpXG4gICAgICByZXR1cm4gb2tcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUmVzb2x2ZXJ9IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvZGV9IENvZGVcbiAqL1xuaW1wb3J0IHtmYWN0b3J5RGVzdGluYXRpb259IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LWRlc3RpbmF0aW9uJ1xuaW1wb3J0IHtmYWN0b3J5TGFiZWx9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LWxhYmVsJ1xuaW1wb3J0IHtmYWN0b3J5VGl0bGV9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXRpdGxlJ1xuaW1wb3J0IHtmYWN0b3J5V2hpdGVzcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktd2hpdGVzcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuaW1wb3J0IHtwdXNoLCBzcGxpY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNodW5rZWQnXG5pbXBvcnQge25vcm1hbGl6ZUlkZW50aWZpZXJ9IGZyb20gJ21pY3JvbWFyay11dGlsLW5vcm1hbGl6ZS1pZGVudGlmaWVyJ1xuaW1wb3J0IHtyZXNvbHZlQWxsfSBmcm9tICdtaWNyb21hcmstdXRpbC1yZXNvbHZlLWFsbCdcblxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5leHBvcnQgY29uc3QgbGFiZWxFbmQgPSB7XG4gIG5hbWU6ICdsYWJlbEVuZCcsXG4gIHRva2VuaXplOiB0b2tlbml6ZUxhYmVsRW5kLFxuICByZXNvbHZlVG86IHJlc29sdmVUb0xhYmVsRW5kLFxuICByZXNvbHZlQWxsOiByZXNvbHZlQWxsTGFiZWxFbmRcbn1cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5jb25zdCByZXNvdXJjZUNvbnN0cnVjdCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplUmVzb3VyY2Vcbn1cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5jb25zdCBmdWxsUmVmZXJlbmNlQ29uc3RydWN0ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVGdWxsUmVmZXJlbmNlXG59XG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cblxuY29uc3QgY29sbGFwc2VkUmVmZXJlbmNlQ29uc3RydWN0ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVDb2xsYXBzZWRSZWZlcmVuY2Vcbn1cbi8qKiBAdHlwZSB7UmVzb2x2ZXJ9ICovXG5cbmZ1bmN0aW9uIHJlc29sdmVBbGxMYWJlbEVuZChldmVudHMpIHtcbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cblxuICBsZXQgdG9rZW5cblxuICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICB0b2tlbiA9IGV2ZW50c1tpbmRleF1bMV1cblxuICAgIGlmIChcbiAgICAgIHRva2VuLnR5cGUgPT09ICdsYWJlbEltYWdlJyB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2xhYmVsTGluaycgfHxcbiAgICAgIHRva2VuLnR5cGUgPT09ICdsYWJlbEVuZCdcbiAgICApIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbWFya2VyLlxuICAgICAgZXZlbnRzLnNwbGljZShpbmRleCArIDEsIHRva2VuLnR5cGUgPT09ICdsYWJlbEltYWdlJyA/IDQgOiAyKVxuICAgICAgdG9rZW4udHlwZSA9ICdkYXRhJ1xuICAgICAgaW5kZXgrK1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudHNcbn1cbi8qKiBAdHlwZSB7UmVzb2x2ZXJ9ICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUb0xhYmVsRW5kKGV2ZW50cywgY29udGV4dCkge1xuICBsZXQgaW5kZXggPSBldmVudHMubGVuZ3RoXG4gIGxldCBvZmZzZXQgPSAwXG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG5cbiAgbGV0IHRva2VuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cblxuICBsZXQgb3BlblxuICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGNsb3NlXG4gIC8qKiBAdHlwZSB7RXZlbnRbXX0gKi9cblxuICBsZXQgbWVkaWEgLy8gRmluZCBhbiBvcGVuaW5nLlxuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdG9rZW4gPSBldmVudHNbaW5kZXhdWzFdXG5cbiAgICBpZiAob3Blbikge1xuICAgICAgLy8gSWYgd2Ugc2VlIGFub3RoZXIgbGluaywgb3IgaW5hY3RpdmUgbGluayBsYWJlbCwgd2VcdTIwMTl2ZSBiZWVuIGhlcmUgYmVmb3JlLlxuICAgICAgaWYgKFxuICAgICAgICB0b2tlbi50eXBlID09PSAnbGluaycgfHxcbiAgICAgICAgKHRva2VuLnR5cGUgPT09ICdsYWJlbExpbmsnICYmIHRva2VuLl9pbmFjdGl2ZSlcbiAgICAgICkge1xuICAgICAgICBicmVha1xuICAgICAgfSAvLyBNYXJrIG90aGVyIGxpbmsgb3BlbmluZ3MgYXMgaW5hY3RpdmUsIGFzIHdlIGNhblx1MjAxOXQgaGF2ZSBsaW5rcyBpblxuICAgICAgLy8gbGlua3MuXG5cbiAgICAgIGlmIChldmVudHNbaW5kZXhdWzBdID09PSAnZW50ZXInICYmIHRva2VuLnR5cGUgPT09ICdsYWJlbExpbmsnKSB7XG4gICAgICAgIHRva2VuLl9pbmFjdGl2ZSA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNsb3NlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcicgJiZcbiAgICAgICAgKHRva2VuLnR5cGUgPT09ICdsYWJlbEltYWdlJyB8fCB0b2tlbi50eXBlID09PSAnbGFiZWxMaW5rJykgJiZcbiAgICAgICAgIXRva2VuLl9iYWxhbmNlZFxuICAgICAgKSB7XG4gICAgICAgIG9wZW4gPSBpbmRleFxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnbGFiZWxMaW5rJykge1xuICAgICAgICAgIG9mZnNldCA9IDJcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSAnbGFiZWxFbmQnKSB7XG4gICAgICBjbG9zZSA9IGluZGV4XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZ3JvdXAgPSB7XG4gICAgdHlwZTogZXZlbnRzW29wZW5dWzFdLnR5cGUgPT09ICdsYWJlbExpbmsnID8gJ2xpbmsnIDogJ2ltYWdlJyxcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW29wZW5dWzFdLnN0YXJ0KSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV1bMV0uZW5kKVxuICB9XG4gIGNvbnN0IGxhYmVsID0ge1xuICAgIHR5cGU6ICdsYWJlbCcsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tvcGVuXVsxXS5zdGFydCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbY2xvc2VdWzFdLmVuZClcbiAgfVxuICBjb25zdCB0ZXh0ID0ge1xuICAgIHR5cGU6ICdsYWJlbFRleHQnLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbb3BlbiArIG9mZnNldCArIDJdWzFdLmVuZCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbY2xvc2UgLSAyXVsxXS5zdGFydClcbiAgfVxuICBtZWRpYSA9IFtcbiAgICBbJ2VudGVyJywgZ3JvdXAsIGNvbnRleHRdLFxuICAgIFsnZW50ZXInLCBsYWJlbCwgY29udGV4dF1cbiAgXSAvLyBPcGVuaW5nIG1hcmtlci5cblxuICBtZWRpYSA9IHB1c2gobWVkaWEsIGV2ZW50cy5zbGljZShvcGVuICsgMSwgb3BlbiArIG9mZnNldCArIDMpKSAvLyBUZXh0IG9wZW4uXG5cbiAgbWVkaWEgPSBwdXNoKG1lZGlhLCBbWydlbnRlcicsIHRleHQsIGNvbnRleHRdXSkgLy8gQmV0d2Vlbi5cblxuICBtZWRpYSA9IHB1c2goXG4gICAgbWVkaWEsXG4gICAgcmVzb2x2ZUFsbChcbiAgICAgIGNvbnRleHQucGFyc2VyLmNvbnN0cnVjdHMuaW5zaWRlU3Bhbi5udWxsLFxuICAgICAgZXZlbnRzLnNsaWNlKG9wZW4gKyBvZmZzZXQgKyA0LCBjbG9zZSAtIDMpLFxuICAgICAgY29udGV4dFxuICAgIClcbiAgKSAvLyBUZXh0IGNsb3NlLCBtYXJrZXIgY2xvc2UsIGxhYmVsIGNsb3NlLlxuXG4gIG1lZGlhID0gcHVzaChtZWRpYSwgW1xuICAgIFsnZXhpdCcsIHRleHQsIGNvbnRleHRdLFxuICAgIGV2ZW50c1tjbG9zZSAtIDJdLFxuICAgIGV2ZW50c1tjbG9zZSAtIDFdLFxuICAgIFsnZXhpdCcsIGxhYmVsLCBjb250ZXh0XVxuICBdKSAvLyBSZWZlcmVuY2UsIHJlc291cmNlLCBvciBzby5cblxuICBtZWRpYSA9IHB1c2gobWVkaWEsIGV2ZW50cy5zbGljZShjbG9zZSArIDEpKSAvLyBNZWRpYSBjbG9zZS5cblxuICBtZWRpYSA9IHB1c2gobWVkaWEsIFtbJ2V4aXQnLCBncm91cCwgY29udGV4dF1dKVxuICBzcGxpY2UoZXZlbnRzLCBvcGVuLCBldmVudHMubGVuZ3RoLCBtZWRpYSlcbiAgcmV0dXJuIGV2ZW50c1xufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplTGFiZWxFbmQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgaW5kZXggPSBzZWxmLmV2ZW50cy5sZW5ndGhcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cblxuICBsZXQgbGFiZWxTdGFydFxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cbiAgbGV0IGRlZmluZWQgLy8gRmluZCBhbiBvcGVuaW5nLlxuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgaWYgKFxuICAgICAgKHNlbGYuZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnbGFiZWxJbWFnZScgfHxcbiAgICAgICAgc2VsZi5ldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdsYWJlbExpbmsnKSAmJlxuICAgICAgIXNlbGYuZXZlbnRzW2luZGV4XVsxXS5fYmFsYW5jZWRcbiAgICApIHtcbiAgICAgIGxhYmVsU3RhcnQgPSBzZWxmLmV2ZW50c1tpbmRleF1bMV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGlmICghbGFiZWxTdGFydCkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH0gLy8gSXRcdTIwMTlzIGEgYmFsYW5jZWQgYnJhY2tldCwgYnV0IGNvbnRhaW5zIGEgbGluay5cblxuICAgIGlmIChsYWJlbFN0YXJ0Ll9pbmFjdGl2ZSkgcmV0dXJuIGJhbGFuY2VkKGNvZGUpXG4gICAgZGVmaW5lZCA9IHNlbGYucGFyc2VyLmRlZmluZWQuaW5jbHVkZXMoXG4gICAgICBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgICBzZWxmLnNsaWNlU2VyaWFsaXplKHtcbiAgICAgICAgICBzdGFydDogbGFiZWxTdGFydC5lbmQsXG4gICAgICAgICAgZW5kOiBzZWxmLm5vdygpXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2xhYmVsRW5kJylcbiAgICBlZmZlY3RzLmVudGVyKCdsYWJlbE1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdsYWJlbE1hcmtlcicpXG4gICAgZWZmZWN0cy5leGl0KCdsYWJlbEVuZCcpXG4gICAgcmV0dXJuIGFmdGVyTGFiZWxFbmRcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyTGFiZWxFbmQoY29kZSkge1xuICAgIC8vIFJlc291cmNlOiBgW2FzZF0oZmdoKWAuXG4gICAgaWYgKGNvZGUgPT09IDQwKSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICByZXNvdXJjZUNvbnN0cnVjdCxcbiAgICAgICAgb2ssXG4gICAgICAgIGRlZmluZWQgPyBvayA6IGJhbGFuY2VkXG4gICAgICApKGNvZGUpXG4gICAgfSAvLyBDb2xsYXBzZWQgKGBbYXNkXVtdYCkgb3IgZnVsbCAoYFthc2RdW2ZnaF1gKSByZWZlcmVuY2U/XG5cbiAgICBpZiAoY29kZSA9PT0gOTEpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgIGZ1bGxSZWZlcmVuY2VDb25zdHJ1Y3QsXG4gICAgICAgIG9rLFxuICAgICAgICBkZWZpbmVkXG4gICAgICAgICAgPyBlZmZlY3RzLmF0dGVtcHQoY29sbGFwc2VkUmVmZXJlbmNlQ29uc3RydWN0LCBvaywgYmFsYW5jZWQpXG4gICAgICAgICAgOiBiYWxhbmNlZFxuICAgICAgKShjb2RlKVxuICAgIH0gLy8gU2hvcnRjdXQgcmVmZXJlbmNlOiBgW2FzZF1gP1xuXG4gICAgcmV0dXJuIGRlZmluZWQgPyBvayhjb2RlKSA6IGJhbGFuY2VkKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBiYWxhbmNlZChjb2RlKSB7XG4gICAgbGFiZWxTdGFydC5fYmFsYW5jZWQgPSB0cnVlXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVSZXNvdXJjZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdyZXNvdXJjZScpXG4gICAgZWZmZWN0cy5lbnRlcigncmVzb3VyY2VNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgncmVzb3VyY2VNYXJrZXInKVxuICAgIHJldHVybiBmYWN0b3J5V2hpdGVzcGFjZShlZmZlY3RzLCBvcGVuKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQxKSB7XG4gICAgICByZXR1cm4gZW5kKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhY3RvcnlEZXN0aW5hdGlvbihcbiAgICAgIGVmZmVjdHMsXG4gICAgICBkZXN0aW5hdGlvbkFmdGVyLFxuICAgICAgbm9rLFxuICAgICAgJ3Jlc291cmNlRGVzdGluYXRpb24nLFxuICAgICAgJ3Jlc291cmNlRGVzdGluYXRpb25MaXRlcmFsJyxcbiAgICAgICdyZXNvdXJjZURlc3RpbmF0aW9uTGl0ZXJhbE1hcmtlcicsXG4gICAgICAncmVzb3VyY2VEZXN0aW5hdGlvblJhdycsXG4gICAgICAncmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZycsXG4gICAgICAzMlxuICAgICkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRlc3RpbmF0aW9uQWZ0ZXIoY29kZSkge1xuICAgIHJldHVybiBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgICA/IGZhY3RvcnlXaGl0ZXNwYWNlKGVmZmVjdHMsIGJldHdlZW4pKGNvZGUpXG4gICAgICA6IGVuZChjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYmV0d2Vlbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDM0IHx8IGNvZGUgPT09IDM5IHx8IGNvZGUgPT09IDQwKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeVRpdGxlKFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBmYWN0b3J5V2hpdGVzcGFjZShlZmZlY3RzLCBlbmQpLFxuICAgICAgICBub2ssXG4gICAgICAgICdyZXNvdXJjZVRpdGxlJyxcbiAgICAgICAgJ3Jlc291cmNlVGl0bGVNYXJrZXInLFxuICAgICAgICAncmVzb3VyY2VUaXRsZVN0cmluZydcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gZW5kKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBlbmQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0MSkge1xuICAgICAgZWZmZWN0cy5lbnRlcigncmVzb3VyY2VNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3Jlc291cmNlTWFya2VyJylcbiAgICAgIGVmZmVjdHMuZXhpdCgncmVzb3VyY2UnKVxuICAgICAgcmV0dXJuIG9rXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVGdWxsUmVmZXJlbmNlKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIHJldHVybiBmYWN0b3J5TGFiZWwuY2FsbChcbiAgICAgIHNlbGYsXG4gICAgICBlZmZlY3RzLFxuICAgICAgYWZ0ZXJMYWJlbCxcbiAgICAgIG5vayxcbiAgICAgICdyZWZlcmVuY2UnLFxuICAgICAgJ3JlZmVyZW5jZU1hcmtlcicsXG4gICAgICAncmVmZXJlbmNlU3RyaW5nJ1xuICAgICkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyTGFiZWwoY29kZSkge1xuICAgIHJldHVybiBzZWxmLnBhcnNlci5kZWZpbmVkLmluY2x1ZGVzKFxuICAgICAgbm9ybWFsaXplSWRlbnRpZmllcihcbiAgICAgICAgc2VsZi5zbGljZVNlcmlhbGl6ZShzZWxmLmV2ZW50c1tzZWxmLmV2ZW50cy5sZW5ndGggLSAxXVsxXSkuc2xpY2UoMSwgLTEpXG4gICAgICApXG4gICAgKVxuICAgICAgPyBvayhjb2RlKVxuICAgICAgOiBub2soY29kZSlcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplQ29sbGFwc2VkUmVmZXJlbmNlKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ3JlZmVyZW5jZScpXG4gICAgZWZmZWN0cy5lbnRlcigncmVmZXJlbmNlTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ3JlZmVyZW5jZU1hcmtlcicpXG4gICAgcmV0dXJuIG9wZW5cbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIG9wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSA5Mykge1xuICAgICAgZWZmZWN0cy5lbnRlcigncmVmZXJlbmNlTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdyZWZlcmVuY2VNYXJrZXInKVxuICAgICAgZWZmZWN0cy5leGl0KCdyZWZlcmVuY2UnKVxuICAgICAgcmV0dXJuIG9rXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge2xhYmVsRW5kfSBmcm9tICcuL2xhYmVsLWVuZC5qcydcbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5leHBvcnQgY29uc3QgbGFiZWxTdGFydEltYWdlID0ge1xuICBuYW1lOiAnbGFiZWxTdGFydEltYWdlJyxcbiAgdG9rZW5pemU6IHRva2VuaXplTGFiZWxTdGFydEltYWdlLFxuICByZXNvbHZlQWxsOiBsYWJlbEVuZC5yZXNvbHZlQWxsXG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVMYWJlbFN0YXJ0SW1hZ2UoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignbGFiZWxJbWFnZScpXG4gICAgZWZmZWN0cy5lbnRlcignbGFiZWxJbWFnZU1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdsYWJlbEltYWdlTWFya2VyJylcbiAgICByZXR1cm4gb3BlblxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDkxKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdsYWJlbE1hcmtlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnbGFiZWxNYXJrZXInKVxuICAgICAgZWZmZWN0cy5leGl0KCdsYWJlbEltYWdlJylcbiAgICAgIHJldHVybiBhZnRlclxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICAvKiBUbyBkbzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgb25jZSB3ZVx1MjAxOXZlIHN3aXRjaGVkIGZyb21cbiAgICAgKiBgbWljcm9tYXJrLWV4dGVuc2lvbi1mb290bm90ZWAgdG8gYG1pY3JvbWFyay1leHRlbnNpb24tZ2ZtLWZvb3Rub3RlYCxcbiAgICAgKiB3aGljaCBkb2Vzblx1MjAxOXQgbmVlZCB0aGlzICovXG5cbiAgICAvKiBIaWRkZW4gZm9vdG5vdGVzIGhvb2sgKi9cblxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICByZXR1cm4gY29kZSA9PT0gOTQgJiYgJ19oaWRkZW5Gb290bm90ZVN1cHBvcnQnIGluIHNlbGYucGFyc2VyLmNvbnN0cnVjdHNcbiAgICAgID8gbm9rKGNvZGUpXG4gICAgICA6IG9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKi9cbmltcG9ydCB7bGFiZWxFbmR9IGZyb20gJy4vbGFiZWwtZW5kLmpzJ1xuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbmV4cG9ydCBjb25zdCBsYWJlbFN0YXJ0TGluayA9IHtcbiAgbmFtZTogJ2xhYmVsU3RhcnRMaW5rJyxcbiAgdG9rZW5pemU6IHRva2VuaXplTGFiZWxTdGFydExpbmssXG4gIHJlc29sdmVBbGw6IGxhYmVsRW5kLnJlc29sdmVBbGxcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUxhYmVsU3RhcnRMaW5rKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2xhYmVsTGluaycpXG4gICAgZWZmZWN0cy5lbnRlcignbGFiZWxNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnbGFiZWxNYXJrZXInKVxuICAgIGVmZmVjdHMuZXhpdCgnbGFiZWxMaW5rJylcbiAgICByZXR1cm4gYWZ0ZXJcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICAvKiBUbyBkbzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgb25jZSB3ZVx1MjAxOXZlIHN3aXRjaGVkIGZyb21cbiAgICAgKiBgbWljcm9tYXJrLWV4dGVuc2lvbi1mb290bm90ZWAgdG8gYG1pY3JvbWFyay1leHRlbnNpb24tZ2ZtLWZvb3Rub3RlYCxcbiAgICAgKiB3aGljaCBkb2Vzblx1MjAxOXQgbmVlZCB0aGlzICovXG5cbiAgICAvKiBIaWRkZW4gZm9vdG5vdGVzIGhvb2suICovXG5cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgcmV0dXJuIGNvZGUgPT09IDk0ICYmICdfaGlkZGVuRm9vdG5vdGVTdXBwb3J0JyBpbiBzZWxmLnBhcnNlci5jb25zdHJ1Y3RzXG4gICAgICA/IG5vayhjb2RlKVxuICAgICAgOiBvayhjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBsaW5lRW5kaW5nID0ge1xuICBuYW1lOiAnbGluZUVuZGluZycsXG4gIHRva2VuaXplOiB0b2tlbml6ZUxpbmVFbmRpbmdcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUxpbmVFbmRpbmcoZWZmZWN0cywgb2spIHtcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG4gICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBvaywgJ2xpbmVQcmVmaXgnKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKi9cbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nLCBtYXJrZG93blNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IHRoZW1hdGljQnJlYWsgPSB7XG4gIG5hbWU6ICd0aGVtYXRpY0JyZWFrJyxcbiAgdG9rZW5pemU6IHRva2VuaXplVGhlbWF0aWNCcmVha1xufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplVGhlbWF0aWNCcmVhayhlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGxldCBzaXplID0gMFxuICAvKiogQHR5cGUge05vbk51bGxhYmxlPENvZGU+fSAqL1xuXG4gIGxldCBtYXJrZXJcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ3RoZW1hdGljQnJlYWsnKVxuICAgIG1hcmtlciA9IGNvZGVcbiAgICByZXR1cm4gYXRCcmVhayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYXRCcmVhayhjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGhlbWF0aWNCcmVha1NlcXVlbmNlJylcbiAgICAgIHJldHVybiBzZXF1ZW5jZShjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGF0QnJlYWssICd3aGl0ZXNwYWNlJykoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoc2l6ZSA8IDMgfHwgKGNvZGUgIT09IG51bGwgJiYgIW1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmV4aXQoJ3RoZW1hdGljQnJlYWsnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc2VxdWVuY2UoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBtYXJrZXIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgc2l6ZSsrXG4gICAgICByZXR1cm4gc2VxdWVuY2VcbiAgICB9XG5cbiAgICBlZmZlY3RzLmV4aXQoJ3RoZW1hdGljQnJlYWtTZXF1ZW5jZScpXG4gICAgcmV0dXJuIGF0QnJlYWsoY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZUNvbnRleHR9IFRva2VuaXplQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeGl0ZXJ9IEV4aXRlclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIHVua25vd24+ICYge21hcmtlcjogQ29kZSwgdHlwZTogc3RyaW5nLCBzaXplOiBudW1iZXJ9fSBMaXN0Q29udGFpbmVyU3RhdGVcbiAqIEB0eXBlZGVmIHtUb2tlbml6ZUNvbnRleHQgJiB7Y29udGFpbmVyU3RhdGU6IExpc3RDb250YWluZXJTdGF0ZX19IFRva2VuaXplQ29udGV4dFdpdGhTdGF0ZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge2FzY2lpRGlnaXQsIG1hcmtkb3duU3BhY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmltcG9ydCB7YmxhbmtMaW5lfSBmcm9tICcuL2JsYW5rLWxpbmUuanMnXG5pbXBvcnQge3RoZW1hdGljQnJlYWt9IGZyb20gJy4vdGhlbWF0aWMtYnJlYWsuanMnXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cblxuZXhwb3J0IGNvbnN0IGxpc3QgPSB7XG4gIG5hbWU6ICdsaXN0JyxcbiAgdG9rZW5pemU6IHRva2VuaXplTGlzdFN0YXJ0LFxuICBjb250aW51YXRpb246IHtcbiAgICB0b2tlbml6ZTogdG9rZW5pemVMaXN0Q29udGludWF0aW9uXG4gIH0sXG4gIGV4aXQ6IHRva2VuaXplTGlzdEVuZFxufVxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbmNvbnN0IGxpc3RJdGVtUHJlZml4V2hpdGVzcGFjZUNvbnN0cnVjdCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplTGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlLFxuICBwYXJ0aWFsOiB0cnVlXG59XG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cblxuY29uc3QgaW5kZW50Q29uc3RydWN0ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVJbmRlbnQsXG4gIHBhcnRpYWw6IHRydWVcbn1cbi8qKlxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHRXaXRoU3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVMaXN0U3RhcnQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBjb25zdCB0YWlsID0gc2VsZi5ldmVudHNbc2VsZi5ldmVudHMubGVuZ3RoIC0gMV1cbiAgbGV0IGluaXRpYWxTaXplID1cbiAgICB0YWlsICYmIHRhaWxbMV0udHlwZSA9PT0gJ2xpbmVQcmVmaXgnXG4gICAgICA/IHRhaWxbMl0uc2xpY2VTZXJpYWxpemUodGFpbFsxXSwgdHJ1ZSkubGVuZ3RoXG4gICAgICA6IDBcbiAgbGV0IHNpemUgPSAwXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBjb25zdCBraW5kID1cbiAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUudHlwZSB8fFxuICAgICAgKGNvZGUgPT09IDQyIHx8IGNvZGUgPT09IDQzIHx8IGNvZGUgPT09IDQ1XG4gICAgICAgID8gJ2xpc3RVbm9yZGVyZWQnXG4gICAgICAgIDogJ2xpc3RPcmRlcmVkJylcblxuICAgIGlmIChcbiAgICAgIGtpbmQgPT09ICdsaXN0VW5vcmRlcmVkJ1xuICAgICAgICA/ICFzZWxmLmNvbnRhaW5lclN0YXRlLm1hcmtlciB8fCBjb2RlID09PSBzZWxmLmNvbnRhaW5lclN0YXRlLm1hcmtlclxuICAgICAgICA6IGFzY2lpRGlnaXQoY29kZSlcbiAgICApIHtcbiAgICAgIGlmICghc2VsZi5jb250YWluZXJTdGF0ZS50eXBlKSB7XG4gICAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUudHlwZSA9IGtpbmRcbiAgICAgICAgZWZmZWN0cy5lbnRlcihraW5kLCB7XG4gICAgICAgICAgX2NvbnRhaW5lcjogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAoa2luZCA9PT0gJ2xpc3RVbm9yZGVyZWQnKSB7XG4gICAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpc3RJdGVtUHJlZml4JylcbiAgICAgICAgcmV0dXJuIGNvZGUgPT09IDQyIHx8IGNvZGUgPT09IDQ1XG4gICAgICAgICAgPyBlZmZlY3RzLmNoZWNrKHRoZW1hdGljQnJlYWssIG5vaywgYXRNYXJrZXIpKGNvZGUpXG4gICAgICAgICAgOiBhdE1hcmtlcihjb2RlKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuaW50ZXJydXB0IHx8IGNvZGUgPT09IDQ5KSB7XG4gICAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpc3RJdGVtUHJlZml4JylcbiAgICAgICAgZWZmZWN0cy5lbnRlcignbGlzdEl0ZW1WYWx1ZScpXG4gICAgICAgIHJldHVybiBpbnNpZGUoY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBpbnNpZGUoY29kZSkge1xuICAgIGlmIChhc2NpaURpZ2l0KGNvZGUpICYmICsrc2l6ZSA8IDEwKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbnNpZGVcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAoIXNlbGYuaW50ZXJydXB0IHx8IHNpemUgPCAyKSAmJlxuICAgICAgKHNlbGYuY29udGFpbmVyU3RhdGUubWFya2VyXG4gICAgICAgID8gY29kZSA9PT0gc2VsZi5jb250YWluZXJTdGF0ZS5tYXJrZXJcbiAgICAgICAgOiBjb2RlID09PSA0MSB8fCBjb2RlID09PSA0NilcbiAgICApIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnbGlzdEl0ZW1WYWx1ZScpXG4gICAgICByZXR1cm4gYXRNYXJrZXIoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICoqL1xuXG4gIGZ1bmN0aW9uIGF0TWFya2VyKGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdsaXN0SXRlbU1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdsaXN0SXRlbU1hcmtlcicpXG4gICAgc2VsZi5jb250YWluZXJTdGF0ZS5tYXJrZXIgPSBzZWxmLmNvbnRhaW5lclN0YXRlLm1hcmtlciB8fCBjb2RlXG4gICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICBibGFua0xpbmUsIC8vIENhblx1MjAxOXQgYmUgZW1wdHkgd2hlbiBpbnRlcnJ1cHRpbmcuXG4gICAgICBzZWxmLmludGVycnVwdCA/IG5vayA6IG9uQmxhbmssXG4gICAgICBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgIGxpc3RJdGVtUHJlZml4V2hpdGVzcGFjZUNvbnN0cnVjdCxcbiAgICAgICAgZW5kT2ZQcmVmaXgsXG4gICAgICAgIG90aGVyUHJlZml4XG4gICAgICApXG4gICAgKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb25CbGFuayhjb2RlKSB7XG4gICAgc2VsZi5jb250YWluZXJTdGF0ZS5pbml0aWFsQmxhbmtMaW5lID0gdHJ1ZVxuICAgIGluaXRpYWxTaXplKytcbiAgICByZXR1cm4gZW5kT2ZQcmVmaXgoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIG90aGVyUHJlZml4KGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignbGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdsaXN0SXRlbVByZWZpeFdoaXRlc3BhY2UnKVxuICAgICAgcmV0dXJuIGVuZE9mUHJlZml4XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZW5kT2ZQcmVmaXgoY29kZSkge1xuICAgIHNlbGYuY29udGFpbmVyU3RhdGUuc2l6ZSA9XG4gICAgICBpbml0aWFsU2l6ZSArXG4gICAgICBzZWxmLnNsaWNlU2VyaWFsaXplKGVmZmVjdHMuZXhpdCgnbGlzdEl0ZW1QcmVmaXgnKSwgdHJ1ZSkubGVuZ3RoXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbn1cbi8qKlxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHRXaXRoU3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVMaXN0Q29udGludWF0aW9uKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgc2VsZi5jb250YWluZXJTdGF0ZS5fY2xvc2VGbG93ID0gdW5kZWZpbmVkXG4gIHJldHVybiBlZmZlY3RzLmNoZWNrKGJsYW5rTGluZSwgb25CbGFuaywgbm90QmxhbmspXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb25CbGFuayhjb2RlKSB7XG4gICAgc2VsZi5jb250YWluZXJTdGF0ZS5mdXJ0aGVyQmxhbmtMaW5lcyA9XG4gICAgICBzZWxmLmNvbnRhaW5lclN0YXRlLmZ1cnRoZXJCbGFua0xpbmVzIHx8XG4gICAgICBzZWxmLmNvbnRhaW5lclN0YXRlLmluaXRpYWxCbGFua0xpbmUgLy8gV2UgaGF2ZSBhIGJsYW5rIGxpbmUuXG4gICAgLy8gU3RpbGwsIHRyeSB0byBjb25zdW1lIGF0IG1vc3QgdGhlIGl0ZW1zIHNpemUuXG5cbiAgICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgICAgZWZmZWN0cyxcbiAgICAgIG9rLFxuICAgICAgJ2xpc3RJdGVtSW5kZW50JyxcbiAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUuc2l6ZSArIDFcbiAgICApKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBub3RCbGFuayhjb2RlKSB7XG4gICAgaWYgKHNlbGYuY29udGFpbmVyU3RhdGUuZnVydGhlckJsYW5rTGluZXMgfHwgIW1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUuZnVydGhlckJsYW5rTGluZXMgPSB1bmRlZmluZWRcbiAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUuaW5pdGlhbEJsYW5rTGluZSA9IHVuZGVmaW5lZFxuICAgICAgcmV0dXJuIG5vdEluQ3VycmVudEl0ZW0oY29kZSlcbiAgICB9XG5cbiAgICBzZWxmLmNvbnRhaW5lclN0YXRlLmZ1cnRoZXJCbGFua0xpbmVzID0gdW5kZWZpbmVkXG4gICAgc2VsZi5jb250YWluZXJTdGF0ZS5pbml0aWFsQmxhbmtMaW5lID0gdW5kZWZpbmVkXG4gICAgcmV0dXJuIGVmZmVjdHMuYXR0ZW1wdChpbmRlbnRDb25zdHJ1Y3QsIG9rLCBub3RJbkN1cnJlbnRJdGVtKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gbm90SW5DdXJyZW50SXRlbShjb2RlKSB7XG4gICAgLy8gV2hpbGUgd2UgZG8gY29udGludWUsIHdlIHNpZ25hbCB0aGF0IHRoZSBmbG93IHNob3VsZCBiZSBjbG9zZWQuXG4gICAgc2VsZi5jb250YWluZXJTdGF0ZS5fY2xvc2VGbG93ID0gdHJ1ZSAvLyBBcyB3ZVx1MjAxOXJlIGNsb3NpbmcgZmxvdywgd2VcdTIwMTlyZSBubyBsb25nZXIgaW50ZXJydXB0aW5nLlxuXG4gICAgc2VsZi5pbnRlcnJ1cHQgPSB1bmRlZmluZWRcbiAgICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgICAgZWZmZWN0cyxcbiAgICAgIGVmZmVjdHMuYXR0ZW1wdChsaXN0LCBvaywgbm9rKSxcbiAgICAgICdsaW5lUHJlZml4JyxcbiAgICAgIHNlbGYucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKCdjb2RlSW5kZW50ZWQnKVxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IDRcbiAgICApKGNvZGUpXG4gIH1cbn1cbi8qKlxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHRXaXRoU3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVJbmRlbnQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgIGVmZmVjdHMsXG4gICAgYWZ0ZXJQcmVmaXgsXG4gICAgJ2xpc3RJdGVtSW5kZW50JyxcbiAgICBzZWxmLmNvbnRhaW5lclN0YXRlLnNpemUgKyAxXG4gIClcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlclByZWZpeChjb2RlKSB7XG4gICAgY29uc3QgdGFpbCA9IHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIHRhaWwgJiZcbiAgICAgIHRhaWxbMV0udHlwZSA9PT0gJ2xpc3RJdGVtSW5kZW50JyAmJlxuICAgICAgdGFpbFsyXS5zbGljZVNlcmlhbGl6ZSh0YWlsWzFdLCB0cnVlKS5sZW5ndGggPT09IHNlbGYuY29udGFpbmVyU3RhdGUuc2l6ZVxuICAgICAgPyBvayhjb2RlKVxuICAgICAgOiBub2soY29kZSlcbiAgfVxufVxuLyoqXG4gKiBAdHlwZSB7RXhpdGVyfVxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dFdpdGhTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUxpc3RFbmQoZWZmZWN0cykge1xuICBlZmZlY3RzLmV4aXQodGhpcy5jb250YWluZXJTdGF0ZS50eXBlKVxufVxuLyoqXG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dFdpdGhTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUxpc3RJdGVtUHJlZml4V2hpdGVzcGFjZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgZWZmZWN0cyxcbiAgICBhZnRlclByZWZpeCxcbiAgICAnbGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlJyxcbiAgICBzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcygnY29kZUluZGVudGVkJylcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IDQgKyAxXG4gIClcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlclByZWZpeChjb2RlKSB7XG4gICAgY29uc3QgdGFpbCA9IHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdXG4gICAgcmV0dXJuICFtYXJrZG93blNwYWNlKGNvZGUpICYmXG4gICAgICB0YWlsICYmXG4gICAgICB0YWlsWzFdLnR5cGUgPT09ICdsaXN0SXRlbVByZWZpeFdoaXRlc3BhY2UnXG4gICAgICA/IG9rKGNvZGUpXG4gICAgICA6IG5vayhjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlJlc29sdmVyfSBSZXNvbHZlclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBzZXRleHRVbmRlcmxpbmUgPSB7XG4gIG5hbWU6ICdzZXRleHRVbmRlcmxpbmUnLFxuICB0b2tlbml6ZTogdG9rZW5pemVTZXRleHRVbmRlcmxpbmUsXG4gIHJlc29sdmVUbzogcmVzb2x2ZVRvU2V0ZXh0VW5kZXJsaW5lXG59XG4vKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVG9TZXRleHRVbmRlcmxpbmUoZXZlbnRzLCBjb250ZXh0KSB7XG4gIGxldCBpbmRleCA9IGV2ZW50cy5sZW5ndGhcbiAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBjb250ZW50XG4gIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cblxuICBsZXQgdGV4dFxuICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGRlZmluaXRpb24gLy8gRmluZCB0aGUgb3BlbmluZyBvZiB0aGUgY29udGVudC5cbiAgLy8gSXRcdTIwMTlsbCBhbHdheXMgZXhpc3Q6IHdlIGRvblx1MjAxOXQgdG9rZW5pemUgaWYgaXQgaXNuXHUyMDE5dCB0aGVyZS5cblxuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIGlmIChldmVudHNbaW5kZXhdWzBdID09PSAnZW50ZXInKSB7XG4gICAgICBpZiAoZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnY29udGVudCcpIHtcbiAgICAgICAgY29udGVudCA9IGluZGV4XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgIHRleHQgPSBpbmRleFxuICAgICAgfVxuICAgIH0gLy8gRXhpdFxuICAgIGVsc2Uge1xuICAgICAgaWYgKGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgY29udGVudCBlbmQgKGlmIG5lZWRlZCB3ZVx1MjAxOWxsIGFkZCBpdCBsYXRlcilcbiAgICAgICAgZXZlbnRzLnNwbGljZShpbmRleCwgMSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFkZWZpbml0aW9uICYmIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ2RlZmluaXRpb24nKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBpbmRleFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGhlYWRpbmcgPSB7XG4gICAgdHlwZTogJ3NldGV4dEhlYWRpbmcnLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbdGV4dF1bMV0uc3RhcnQpLFxuICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXVsxXS5lbmQpXG4gIH0gLy8gQ2hhbmdlIHRoZSBwYXJhZ3JhcGggdG8gc2V0ZXh0IGhlYWRpbmcgdGV4dC5cblxuICBldmVudHNbdGV4dF1bMV0udHlwZSA9ICdzZXRleHRIZWFkaW5nVGV4dCcgLy8gSWYgd2UgaGF2ZSBkZWZpbml0aW9ucyBpbiB0aGUgY29udGVudCwgd2VcdTIwMTlsbCBrZWVwIG9uIGhhdmluZyBjb250ZW50LFxuICAvLyBidXQgd2UgbmVlZCBtb3ZlIGl0LlxuXG4gIGlmIChkZWZpbml0aW9uKSB7XG4gICAgZXZlbnRzLnNwbGljZSh0ZXh0LCAwLCBbJ2VudGVyJywgaGVhZGluZywgY29udGV4dF0pXG4gICAgZXZlbnRzLnNwbGljZShkZWZpbml0aW9uICsgMSwgMCwgWydleGl0JywgZXZlbnRzW2NvbnRlbnRdWzFdLCBjb250ZXh0XSlcbiAgICBldmVudHNbY29udGVudF1bMV0uZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2RlZmluaXRpb25dWzFdLmVuZClcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbY29udGVudF1bMV0gPSBoZWFkaW5nXG4gIH0gLy8gQWRkIHRoZSBoZWFkaW5nIGV4aXQgYXQgdGhlIGVuZC5cblxuICBldmVudHMucHVzaChbJ2V4aXQnLCBoZWFkaW5nLCBjb250ZXh0XSlcbiAgcmV0dXJuIGV2ZW50c1xufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplU2V0ZXh0VW5kZXJsaW5lKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgbGV0IGluZGV4ID0gc2VsZi5ldmVudHMubGVuZ3RoXG4gIC8qKiBAdHlwZSB7Tm9uTnVsbGFibGU8Q29kZT59ICovXG5cbiAgbGV0IG1hcmtlclxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cbiAgbGV0IHBhcmFncmFwaCAvLyBGaW5kIGFuIG9wZW5pbmcuXG5cbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAvLyBTa2lwIGVudGVyL2V4aXQgb2YgbGluZSBlbmRpbmcsIGxpbmUgcHJlZml4LCBhbmQgY29udGVudC5cbiAgICAvLyBXZSBjYW4gbm93IGVpdGhlciBoYXZlIGEgZGVmaW5pdGlvbiBvciBhIHBhcmFncmFwaC5cbiAgICBpZiAoXG4gICAgICBzZWxmLmV2ZW50c1tpbmRleF1bMV0udHlwZSAhPT0gJ2xpbmVFbmRpbmcnICYmXG4gICAgICBzZWxmLmV2ZW50c1tpbmRleF1bMV0udHlwZSAhPT0gJ2xpbmVQcmVmaXgnICYmXG4gICAgICBzZWxmLmV2ZW50c1tpbmRleF1bMV0udHlwZSAhPT0gJ2NvbnRlbnQnXG4gICAgKSB7XG4gICAgICBwYXJhZ3JhcGggPSBzZWxmLmV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ3BhcmFncmFwaCdcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGlmICghc2VsZi5wYXJzZXIubGF6eVtzZWxmLm5vdygpLmxpbmVdICYmIChzZWxmLmludGVycnVwdCB8fCBwYXJhZ3JhcGgpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdzZXRleHRIZWFkaW5nTGluZScpXG4gICAgICBlZmZlY3RzLmVudGVyKCdzZXRleHRIZWFkaW5nTGluZVNlcXVlbmNlJylcbiAgICAgIG1hcmtlciA9IGNvZGVcbiAgICAgIHJldHVybiBjbG9zaW5nU2VxdWVuY2UoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjbG9zaW5nU2VxdWVuY2UoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBtYXJrZXIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGNsb3NpbmdTZXF1ZW5jZVxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgnc2V0ZXh0SGVhZGluZ0xpbmVTZXF1ZW5jZScpXG4gICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBjbG9zaW5nU2VxdWVuY2VFbmQsICdsaW5lU3VmZml4JykoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNsb3NpbmdTZXF1ZW5jZUVuZChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ3NldGV4dEhlYWRpbmdMaW5lJylcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Jbml0aWFsQ29uc3RydWN0fSBJbml0aWFsQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkluaXRpYWxpemVyfSBJbml0aWFsaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuaW1wb3J0IHtibGFua0xpbmUsIGNvbnRlbnR9IGZyb20gJ21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsnXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0luaXRpYWxDb25zdHJ1Y3R9ICovXG5leHBvcnQgY29uc3QgZmxvdyA9IHtcbiAgdG9rZW5pemU6IGluaXRpYWxpemVGbG93XG59XG4vKiogQHR5cGUge0luaXRpYWxpemVyfSAqL1xuXG5mdW5jdGlvbiBpbml0aWFsaXplRmxvdyhlZmZlY3RzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGNvbnN0IGluaXRpYWwgPSBlZmZlY3RzLmF0dGVtcHQoXG4gICAgLy8gVHJ5IHRvIHBhcnNlIGEgYmxhbmsgbGluZS5cbiAgICBibGFua0xpbmUsXG4gICAgYXRCbGFua0VuZGluZywgLy8gVHJ5IHRvIHBhcnNlIGluaXRpYWwgZmxvdyAoZXNzZW50aWFsbHksIG9ubHkgY29kZSkuXG4gICAgZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgdGhpcy5wYXJzZXIuY29uc3RydWN0cy5mbG93SW5pdGlhbCxcbiAgICAgIGFmdGVyQ29uc3RydWN0LFxuICAgICAgZmFjdG9yeVNwYWNlKFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgICAgdGhpcy5wYXJzZXIuY29uc3RydWN0cy5mbG93LFxuICAgICAgICAgIGFmdGVyQ29uc3RydWN0LFxuICAgICAgICAgIGVmZmVjdHMuYXR0ZW1wdChjb250ZW50LCBhZnRlckNvbnN0cnVjdClcbiAgICAgICAgKSxcbiAgICAgICAgJ2xpbmVQcmVmaXgnXG4gICAgICApXG4gICAgKVxuICApXG4gIHJldHVybiBpbml0aWFsXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYXRCbGFua0VuZGluZyhjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignbGluZUVuZGluZ0JsYW5rJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmdCbGFuaycpXG4gICAgc2VsZi5jdXJyZW50Q29uc3RydWN0ID0gdW5kZWZpbmVkXG4gICAgcmV0dXJuIGluaXRpYWxcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyQ29uc3RydWN0KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgIHNlbGYuY3VycmVudENvbnN0cnVjdCA9IHVuZGVmaW5lZFxuICAgIHJldHVybiBpbml0aWFsXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUmVzb2x2ZXJ9IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkluaXRpYWxpemVyfSBJbml0aWFsaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Jbml0aWFsQ29uc3RydWN0fSBJbml0aWFsQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlciA9IHtcbiAgcmVzb2x2ZUFsbDogY3JlYXRlUmVzb2x2ZXIoKVxufVxuZXhwb3J0IGNvbnN0IHN0cmluZyA9IGluaXRpYWxpemVGYWN0b3J5KCdzdHJpbmcnKVxuZXhwb3J0IGNvbnN0IHRleHQgPSBpbml0aWFsaXplRmFjdG9yeSgndGV4dCcpXG4vKipcbiAqIEBwYXJhbSB7J3N0cmluZyd8J3RleHQnfSBmaWVsZFxuICogQHJldHVybnMge0luaXRpYWxDb25zdHJ1Y3R9XG4gKi9cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUZhY3RvcnkoZmllbGQpIHtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbml6ZTogaW5pdGlhbGl6ZVRleHQsXG4gICAgcmVzb2x2ZUFsbDogY3JlYXRlUmVzb2x2ZXIoXG4gICAgICBmaWVsZCA9PT0gJ3RleHQnID8gcmVzb2x2ZUFsbExpbmVTdWZmaXhlcyA6IHVuZGVmaW5lZFxuICAgIClcbiAgfVxuICAvKiogQHR5cGUge0luaXRpYWxpemVyfSAqL1xuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVUZXh0KGVmZmVjdHMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGNvbnN0IGNvbnN0cnVjdHMgPSB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzW2ZpZWxkXVxuICAgIGNvbnN0IHRleHQgPSBlZmZlY3RzLmF0dGVtcHQoY29uc3RydWN0cywgc3RhcnQsIG5vdFRleHQpXG4gICAgcmV0dXJuIHN0YXJ0XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAgIHJldHVybiBhdEJyZWFrKGNvZGUpID8gdGV4dChjb2RlKSA6IG5vdFRleHQoY29kZSlcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIG5vdFRleHQoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBlZmZlY3RzLmVudGVyKCdkYXRhJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIGRhdGEoY29kZSkge1xuICAgICAgaWYgKGF0QnJlYWsoY29kZSkpIHtcbiAgICAgICAgZWZmZWN0cy5leGl0KCdkYXRhJylcbiAgICAgICAgcmV0dXJuIHRleHQoY29kZSlcbiAgICAgIH0gLy8gRGF0YS5cblxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NvZGV9IGNvZGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGF0QnJlYWsoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGlzdCA9IGNvbnN0cnVjdHNbY29kZV1cbiAgICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpbmRleF1cblxuICAgICAgICAgIGlmICghaXRlbS5wcmV2aW91cyB8fCBpdGVtLnByZXZpb3VzLmNhbGwoc2VsZiwgc2VsZi5wcmV2aW91cykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge1Jlc29sdmVyfSBbZXh0cmFSZXNvbHZlcl1cbiAqIEByZXR1cm5zIHtSZXNvbHZlcn1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZlcihleHRyYVJlc29sdmVyKSB7XG4gIHJldHVybiByZXNvbHZlQWxsVGV4dFxuICAvKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVBbGxUZXh0KGV2ZW50cywgY29udGV4dCkge1xuICAgIGxldCBpbmRleCA9IC0xXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuXG4gICAgbGV0IGVudGVyIC8vIEEgcmF0aGVyIGJvcmluZyBjb21wdXRhdGlvbiAodG8gbWVyZ2UgYWRqYWNlbnQgYGRhdGFgIGV2ZW50cykgd2hpY2hcbiAgICAvLyBpbXByb3ZlcyBtbSBwZXJmb3JtYW5jZSBieSAyOSUuXG5cbiAgICB3aGlsZSAoKytpbmRleCA8PSBldmVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAoZW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZXZlbnRzW2luZGV4XSAmJiBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdkYXRhJykge1xuICAgICAgICAgIGVudGVyID0gaW5kZXhcbiAgICAgICAgICBpbmRleCsrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWV2ZW50c1tpbmRleF0gfHwgZXZlbnRzW2luZGV4XVsxXS50eXBlICE9PSAnZGF0YScpIHtcbiAgICAgICAgLy8gRG9uXHUyMDE5dCBkbyBhbnl0aGluZyBpZiB0aGVyZSBpcyBvbmUgZGF0YSB0b2tlbi5cbiAgICAgICAgaWYgKGluZGV4ICE9PSBlbnRlciArIDIpIHtcbiAgICAgICAgICBldmVudHNbZW50ZXJdWzFdLmVuZCA9IGV2ZW50c1tpbmRleCAtIDFdWzFdLmVuZFxuICAgICAgICAgIGV2ZW50cy5zcGxpY2UoZW50ZXIgKyAyLCBpbmRleCAtIGVudGVyIC0gMilcbiAgICAgICAgICBpbmRleCA9IGVudGVyICsgMlxuICAgICAgICB9XG5cbiAgICAgICAgZW50ZXIgPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0cmFSZXNvbHZlciA/IGV4dHJhUmVzb2x2ZXIoZXZlbnRzLCBjb250ZXh0KSA6IGV2ZW50c1xuICB9XG59XG4vKipcbiAqIEEgcmF0aGVyIHVnbHkgc2V0IG9mIGluc3RydWN0aW9ucyB3aGljaCBhZ2FpbiBsb29rcyBhdCBjaHVua3MgaW4gdGhlIGlucHV0XG4gKiBzdHJlYW0uXG4gKiBUaGUgcmVhc29uIHRvIGRvIHRoaXMgaGVyZSBpcyB0aGF0IGl0IGlzICptdWNoKiBmYXN0ZXIgdG8gcGFyc2UgaW4gcmV2ZXJzZS5cbiAqIEFuZCB0aGF0IHdlIGNhblx1MjAxOXQgaG9vayBpbnRvIGBudWxsYCB0byBzcGxpdCB0aGUgbGluZSBzdWZmaXggYmVmb3JlIGFuIEVPRi5cbiAqIFRvIGRvOiBmaWd1cmUgb3V0IGlmIHdlIGNhbiBtYWtlIHRoaXMgaW50byBhIGNsZWFuIHV0aWxpdHksIG9yIGV2ZW4gaW4gY29yZS5cbiAqIEFzIGl0IHdpbGwgYmUgdXNlZnVsIGZvciBHRk1zIGxpdGVyYWwgYXV0b2xpbmsgZXh0ZW5zaW9uIChhbmQgbWF5YmUgZXZlblxuICogdGFibGVzPylcbiAqXG4gKiBAdHlwZSB7UmVzb2x2ZXJ9XG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUFsbExpbmVTdWZmaXhlcyhldmVudHMsIGNvbnRleHQpIHtcbiAgbGV0IGV2ZW50SW5kZXggPSAwIC8vIFNraXAgZmlyc3QuXG5cbiAgd2hpbGUgKCsrZXZlbnRJbmRleCA8PSBldmVudHMubGVuZ3RoKSB7XG4gICAgaWYgKFxuICAgICAgKGV2ZW50SW5kZXggPT09IGV2ZW50cy5sZW5ndGggfHxcbiAgICAgICAgZXZlbnRzW2V2ZW50SW5kZXhdWzFdLnR5cGUgPT09ICdsaW5lRW5kaW5nJykgJiZcbiAgICAgIGV2ZW50c1tldmVudEluZGV4IC0gMV1bMV0udHlwZSA9PT0gJ2RhdGEnXG4gICAgKSB7XG4gICAgICBjb25zdCBkYXRhID0gZXZlbnRzW2V2ZW50SW5kZXggLSAxXVsxXVxuICAgICAgY29uc3QgY2h1bmtzID0gY29udGV4dC5zbGljZVN0cmVhbShkYXRhKVxuICAgICAgbGV0IGluZGV4ID0gY2h1bmtzLmxlbmd0aFxuICAgICAgbGV0IGJ1ZmZlckluZGV4ID0gLTFcbiAgICAgIGxldCBzaXplID0gMFxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICAgICAgbGV0IHRhYnNcblxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaW5kZXhdXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBidWZmZXJJbmRleCA9IGNodW5rLmxlbmd0aFxuXG4gICAgICAgICAgd2hpbGUgKGNodW5rLmNoYXJDb2RlQXQoYnVmZmVySW5kZXggLSAxKSA9PT0gMzIpIHtcbiAgICAgICAgICAgIHNpemUrK1xuICAgICAgICAgICAgYnVmZmVySW5kZXgtLVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChidWZmZXJJbmRleCkgYnJlYWtcbiAgICAgICAgICBidWZmZXJJbmRleCA9IC0xXG4gICAgICAgIH0gLy8gTnVtYmVyXG4gICAgICAgIGVsc2UgaWYgKGNodW5rID09PSAtMikge1xuICAgICAgICAgIHRhYnMgPSB0cnVlXG4gICAgICAgICAgc2l6ZSsrXG4gICAgICAgIH0gZWxzZSBpZiAoY2h1bmsgPT09IC0xKSB7XG4gICAgICAgICAgLy8gRW1wdHlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXBsYWNlbWVudCBjaGFyYWN0ZXIsIGV4aXQuXG4gICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgdHlwZTpcbiAgICAgICAgICAgIGV2ZW50SW5kZXggPT09IGV2ZW50cy5sZW5ndGggfHwgdGFicyB8fCBzaXplIDwgMlxuICAgICAgICAgICAgICA/ICdsaW5lU3VmZml4J1xuICAgICAgICAgICAgICA6ICdoYXJkQnJlYWtUcmFpbGluZycsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZW5kLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGRhdGEuZW5kLmNvbHVtbiAtIHNpemUsXG4gICAgICAgICAgICBvZmZzZXQ6IGRhdGEuZW5kLm9mZnNldCAtIHNpemUsXG4gICAgICAgICAgICBfaW5kZXg6IGRhdGEuc3RhcnQuX2luZGV4ICsgaW5kZXgsXG4gICAgICAgICAgICBfYnVmZmVySW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgID8gYnVmZmVySW5kZXhcbiAgICAgICAgICAgICAgOiBkYXRhLnN0YXJ0Ll9idWZmZXJJbmRleCArIGJ1ZmZlckluZGV4XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGRhdGEuZW5kKVxuICAgICAgICB9XG4gICAgICAgIGRhdGEuZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgdG9rZW4uc3RhcnQpXG5cbiAgICAgICAgaWYgKGRhdGEuc3RhcnQub2Zmc2V0ID09PSBkYXRhLmVuZC5vZmZzZXQpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEsIHRva2VuKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50cy5zcGxpY2UoXG4gICAgICAgICAgICBldmVudEluZGV4LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIFsnZW50ZXInLCB0b2tlbiwgY29udGV4dF0sXG4gICAgICAgICAgICBbJ2V4aXQnLCB0b2tlbiwgY29udGV4dF1cbiAgICAgICAgICApXG4gICAgICAgICAgZXZlbnRJbmRleCArPSAyXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZlbnRJbmRleCsrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNodW5rfSBDaHVua1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Qb2ludH0gUG9pbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkVmZmVjdHN9IEVmZmVjdHNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkluaXRpYWxDb25zdHJ1Y3R9IEluaXRpYWxDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0UmVjb3JkfSBDb25zdHJ1Y3RSZWNvcmRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVDb250ZXh0fSBUb2tlbml6ZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUGFyc2VDb250ZXh0fSBQYXJzZUNvbnRleHRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIEluZm9cbiAqIEBwcm9wZXJ0eSB7KCkgPT4gdm9pZH0gcmVzdG9yZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZyb21cbiAqXG4gKiBAY2FsbGJhY2sgUmV0dXJuSGFuZGxlXG4gKiAgIEhhbmRsZSBhIHN1Y2Nlc3NmdWwgcnVuLlxuICogQHBhcmFtIHtDb25zdHJ1Y3R9IGNvbnN0cnVjdFxuICogQHBhcmFtIHtJbmZvfSBpbmZvXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuaW1wb3J0IHttYXJrZG93bkxpbmVFbmRpbmd9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmltcG9ydCB7cHVzaCwgc3BsaWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaHVua2VkJ1xuaW1wb3J0IHtyZXNvbHZlQWxsfSBmcm9tICdtaWNyb21hcmstdXRpbC1yZXNvbHZlLWFsbCdcblxuLyoqXG4gKiBDcmVhdGUgYSB0b2tlbml6ZXIuXG4gKiBUb2tlbml6ZXJzIGRlYWwgd2l0aCBvbmUgdHlwZSBvZiBkYXRhIChlLmcuLCBjb250YWluZXJzLCBmbG93LCB0ZXh0KS5cbiAqIFRoZSBwYXJzZXIgaXMgdGhlIG9iamVjdCBkZWFsaW5nIHdpdGggaXQgYWxsLlxuICogYGluaXRpYWxpemVgIHdvcmtzIGxpa2Ugb3RoZXIgY29uc3RydWN0cywgZXhjZXB0IHRoYXQgb25seSBpdHMgYHRva2VuaXplYFxuICogZnVuY3Rpb24gaXMgdXNlZCwgaW4gd2hpY2ggY2FzZSBpdCBkb2Vzblx1MjAxOXQgcmVjZWl2ZSBhbiBgb2tgIG9yIGBub2tgLlxuICogYGZyb21gIGNhbiBiZSBnaXZlbiB0byBzZXQgdGhlIHBvaW50IGJlZm9yZSB0aGUgZmlyc3QgY2hhcmFjdGVyLCBhbHRob3VnaFxuICogd2hlbiBmdXJ0aGVyIGxpbmVzIGFyZSBpbmRlbnRlZCwgdGhleSBtdXN0IGJlIHNldCB3aXRoIGBkZWZpbmVTa2lwYC5cbiAqXG4gKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gcGFyc2VyXG4gKiBAcGFyYW0ge0luaXRpYWxDb25zdHJ1Y3R9IGluaXRpYWxpemVcbiAqIEBwYXJhbSB7T21pdDxQb2ludCwgJ19pbmRleCd8J19idWZmZXJJbmRleCc+fSBbZnJvbV1cbiAqIEByZXR1cm5zIHtUb2tlbml6ZUNvbnRleHR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUb2tlbml6ZXIocGFyc2VyLCBpbml0aWFsaXplLCBmcm9tKSB7XG4gIC8qKiBAdHlwZSB7UG9pbnR9ICovXG4gIGxldCBwb2ludCA9IE9iamVjdC5hc3NpZ24oXG4gICAgZnJvbVxuICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCBmcm9tKVxuICAgICAgOiB7XG4gICAgICAgICAgbGluZTogMSxcbiAgICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAge1xuICAgICAgX2luZGV4OiAwLFxuICAgICAgX2J1ZmZlckluZGV4OiAtMVxuICAgIH1cbiAgKVxuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIG51bWJlcj59ICovXG5cbiAgY29uc3QgY29sdW1uU3RhcnQgPSB7fVxuICAvKiogQHR5cGUge0FycmF5PENvbnN0cnVjdD59ICovXG5cbiAgY29uc3QgcmVzb2x2ZUFsbENvbnN0cnVjdHMgPSBbXVxuICAvKiogQHR5cGUge0FycmF5PENodW5rPn0gKi9cblxuICBsZXQgY2h1bmtzID0gW11cbiAgLyoqIEB0eXBlIHtBcnJheTxUb2tlbj59ICovXG5cbiAgbGV0IHN0YWNrID0gW11cbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgY29uc3VtZWQgPSB0cnVlXG4gIC8qKlxuICAgKiBUb29scyB1c2VkIGZvciB0b2tlbml6aW5nLlxuICAgKlxuICAgKiBAdHlwZSB7RWZmZWN0c31cbiAgICovXG5cbiAgY29uc3QgZWZmZWN0cyA9IHtcbiAgICBjb25zdW1lLFxuICAgIGVudGVyLFxuICAgIGV4aXQsXG4gICAgYXR0ZW1wdDogY29uc3RydWN0RmFjdG9yeShvbnN1Y2Nlc3NmdWxjb25zdHJ1Y3QpLFxuICAgIGNoZWNrOiBjb25zdHJ1Y3RGYWN0b3J5KG9uc3VjY2Vzc2Z1bGNoZWNrKSxcbiAgICBpbnRlcnJ1cHQ6IGNvbnN0cnVjdEZhY3Rvcnkob25zdWNjZXNzZnVsY2hlY2ssIHtcbiAgICAgIGludGVycnVwdDogdHJ1ZVxuICAgIH0pXG4gIH1cbiAgLyoqXG4gICAqIFN0YXRlIGFuZCB0b29scyBmb3IgcmVzb2x2aW5nIGFuZCBzZXJpYWxpemluZy5cbiAgICpcbiAgICogQHR5cGUge1Rva2VuaXplQ29udGV4dH1cbiAgICovXG5cbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBwcmV2aW91czogbnVsbCxcbiAgICBjb2RlOiBudWxsLFxuICAgIGNvbnRhaW5lclN0YXRlOiB7fSxcbiAgICBldmVudHM6IFtdLFxuICAgIHBhcnNlcixcbiAgICBzbGljZVN0cmVhbSxcbiAgICBzbGljZVNlcmlhbGl6ZSxcbiAgICBub3csXG4gICAgZGVmaW5lU2tpcCxcbiAgICB3cml0ZVxuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RhdGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZXx2b2lkfVxuICAgKi9cblxuICBsZXQgc3RhdGUgPSBpbml0aWFsaXplLnRva2VuaXplLmNhbGwoY29udGV4dCwgZWZmZWN0cylcbiAgLyoqXG4gICAqIFRyYWNrIHdoaWNoIGNoYXJhY3RlciB3ZSBleHBlY3QgdG8gYmUgY29uc3VtZWQsIHRvIGNhdGNoIGJ1Z3MuXG4gICAqXG4gICAqIEB0eXBlIHtDb2RlfVxuICAgKi9cblxuICBsZXQgZXhwZWN0ZWRDb2RlXG5cbiAgaWYgKGluaXRpYWxpemUucmVzb2x2ZUFsbCkge1xuICAgIHJlc29sdmVBbGxDb25zdHJ1Y3RzLnB1c2goaW5pdGlhbGl6ZSlcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0XG4gIC8qKiBAdHlwZSB7VG9rZW5pemVDb250ZXh0Wyd3cml0ZSddfSAqL1xuXG4gIGZ1bmN0aW9uIHdyaXRlKHNsaWNlKSB7XG4gICAgY2h1bmtzID0gcHVzaChjaHVua3MsIHNsaWNlKVxuICAgIG1haW4oKSAvLyBFeGl0IGlmIHdlXHUyMDE5cmUgbm90IGRvbmUsIHJlc29sdmUgbWlnaHQgY2hhbmdlIHN0dWZmLlxuXG4gICAgaWYgKGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV0gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGFkZFJlc3VsdChpbml0aWFsaXplLCAwKSAvLyBPdGhlcndpc2UsIHJlc29sdmUsIGFuZCBleGl0LlxuXG4gICAgY29udGV4dC5ldmVudHMgPSByZXNvbHZlQWxsKHJlc29sdmVBbGxDb25zdHJ1Y3RzLCBjb250ZXh0LmV2ZW50cywgY29udGV4dClcbiAgICByZXR1cm4gY29udGV4dC5ldmVudHNcbiAgfSAvL1xuICAvLyBUb29scy5cbiAgLy9cblxuICAvKiogQHR5cGUge1Rva2VuaXplQ29udGV4dFsnc2xpY2VTZXJpYWxpemUnXX0gKi9cblxuICBmdW5jdGlvbiBzbGljZVNlcmlhbGl6ZSh0b2tlbiwgZXhwYW5kVGFicykge1xuICAgIHJldHVybiBzZXJpYWxpemVDaHVua3Moc2xpY2VTdHJlYW0odG9rZW4pLCBleHBhbmRUYWJzKVxuICB9XG4gIC8qKiBAdHlwZSB7VG9rZW5pemVDb250ZXh0WydzbGljZVN0cmVhbSddfSAqL1xuXG4gIGZ1bmN0aW9uIHNsaWNlU3RyZWFtKHRva2VuKSB7XG4gICAgcmV0dXJuIHNsaWNlQ2h1bmtzKGNodW5rcywgdG9rZW4pXG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbml6ZUNvbnRleHRbJ25vdyddfSAqL1xuXG4gIGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcG9pbnQpXG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbml6ZUNvbnRleHRbJ2RlZmluZVNraXAnXX0gKi9cblxuICBmdW5jdGlvbiBkZWZpbmVTa2lwKHZhbHVlKSB7XG4gICAgY29sdW1uU3RhcnRbdmFsdWUubGluZV0gPSB2YWx1ZS5jb2x1bW5cbiAgICBhY2NvdW50Rm9yUG90ZW50aWFsU2tpcCgpXG4gIH0gLy9cbiAgLy8gU3RhdGUgbWFuYWdlbWVudC5cbiAgLy9cblxuICAvKipcbiAgICogTWFpbiBsb29wIChub3RlIHRoYXQgYF9pbmRleGAgYW5kIGBfYnVmZmVySW5kZXhgIGluIGBwb2ludGAgYXJlIG1vZGlmaWVkIGJ5XG4gICAqIGBjb25zdW1lYCkuXG4gICAqIEhlcmUgaXMgd2hlcmUgd2Ugd2FsayB0aHJvdWdoIHRoZSBjaHVua3MsIHdoaWNoIGVpdGhlciBpbmNsdWRlIHN0cmluZ3Mgb2ZcbiAgICogc2V2ZXJhbCBjaGFyYWN0ZXJzLCBvciBudW1lcmljYWwgY2hhcmFjdGVyIGNvZGVzLlxuICAgKiBUaGUgcmVhc29uIHRvIGRvIHRoaXMgaW4gYSBsb29wIGluc3RlYWQgb2YgYSBjYWxsIGlzIHNvIHRoZSBzdGFjayBjYW5cbiAgICogZHJhaW4uXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuICBmdW5jdGlvbiBtYWluKCkge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIGxldCBjaHVua0luZGV4XG5cbiAgICB3aGlsZSAocG9pbnQuX2luZGV4IDwgY2h1bmtzLmxlbmd0aCkge1xuICAgICAgY29uc3QgY2h1bmsgPSBjaHVua3NbcG9pbnQuX2luZGV4XSAvLyBJZiB3ZVx1MjAxOXJlIGluIGEgYnVmZmVyIGNodW5rLCBsb29wIHRocm91Z2ggaXQuXG5cbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNodW5rSW5kZXggPSBwb2ludC5faW5kZXhcblxuICAgICAgICBpZiAocG9pbnQuX2J1ZmZlckluZGV4IDwgMCkge1xuICAgICAgICAgIHBvaW50Ll9idWZmZXJJbmRleCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICBwb2ludC5faW5kZXggPT09IGNodW5rSW5kZXggJiZcbiAgICAgICAgICBwb2ludC5fYnVmZmVySW5kZXggPCBjaHVuay5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgZ28oY2h1bmsuY2hhckNvZGVBdChwb2ludC5fYnVmZmVySW5kZXgpKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbyhjaHVuaylcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlYWwgd2l0aCBvbmUgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtDb2RlfSBjb2RlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuICBmdW5jdGlvbiBnbyhjb2RlKSB7XG4gICAgY29uc3VtZWQgPSB1bmRlZmluZWRcbiAgICBleHBlY3RlZENvZGUgPSBjb2RlXG4gICAgc3RhdGUgPSBzdGF0ZShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7RWZmZWN0c1snY29uc3VtZSddfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbnN1bWUoY29kZSkge1xuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHBvaW50LmxpbmUrK1xuICAgICAgcG9pbnQuY29sdW1uID0gMVxuICAgICAgcG9pbnQub2Zmc2V0ICs9IGNvZGUgPT09IC0zID8gMiA6IDFcbiAgICAgIGFjY291bnRGb3JQb3RlbnRpYWxTa2lwKClcbiAgICB9IGVsc2UgaWYgKGNvZGUgIT09IC0xKSB7XG4gICAgICBwb2ludC5jb2x1bW4rK1xuICAgICAgcG9pbnQub2Zmc2V0KytcbiAgICB9IC8vIE5vdCBpbiBhIHN0cmluZyBjaHVuay5cblxuICAgIGlmIChwb2ludC5fYnVmZmVySW5kZXggPCAwKSB7XG4gICAgICBwb2ludC5faW5kZXgrK1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludC5fYnVmZmVySW5kZXgrKyAvLyBBdCBlbmQgb2Ygc3RyaW5nIGNodW5rLlxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQb2ludHMgdy8gbm9uLW5lZ2F0aXZlIGBfYnVmZmVySW5kZXhgIHJlZmVyZW5jZVxuICAgICAgLy8gc3RyaW5ncy5cblxuICAgICAgaWYgKHBvaW50Ll9idWZmZXJJbmRleCA9PT0gY2h1bmtzW3BvaW50Ll9pbmRleF0ubGVuZ3RoKSB7XG4gICAgICAgIHBvaW50Ll9idWZmZXJJbmRleCA9IC0xXG4gICAgICAgIHBvaW50Ll9pbmRleCsrXG4gICAgICB9XG4gICAgfSAvLyBFeHBvc2UgdGhlIHByZXZpb3VzIGNoYXJhY3Rlci5cblxuICAgIGNvbnRleHQucHJldmlvdXMgPSBjb2RlIC8vIE1hcmsgYXMgY29uc3VtZWQuXG5cbiAgICBjb25zdW1lZCA9IHRydWVcbiAgfVxuICAvKiogQHR5cGUge0VmZmVjdHNbJ2VudGVyJ119ICovXG5cbiAgZnVuY3Rpb24gZW50ZXIodHlwZSwgZmllbGRzKSB7XG4gICAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhdGNoIGluc3RlYWQgb2YgYXNzaWduIHJlcXVpcmVkIGZpZWxkcyB0byBoZWxwIEdDLlxuICAgIGNvbnN0IHRva2VuID0gZmllbGRzIHx8IHt9XG4gICAgdG9rZW4udHlwZSA9IHR5cGVcbiAgICB0b2tlbi5zdGFydCA9IG5vdygpXG4gICAgY29udGV4dC5ldmVudHMucHVzaChbJ2VudGVyJywgdG9rZW4sIGNvbnRleHRdKVxuICAgIHN0YWNrLnB1c2godG9rZW4pXG4gICAgcmV0dXJuIHRva2VuXG4gIH1cbiAgLyoqIEB0eXBlIHtFZmZlY3RzWydleGl0J119ICovXG5cbiAgZnVuY3Rpb24gZXhpdCh0eXBlKSB7XG4gICAgY29uc3QgdG9rZW4gPSBzdGFjay5wb3AoKVxuICAgIHRva2VuLmVuZCA9IG5vdygpXG4gICAgY29udGV4dC5ldmVudHMucHVzaChbJ2V4aXQnLCB0b2tlbiwgY29udGV4dF0pXG4gICAgcmV0dXJuIHRva2VuXG4gIH1cbiAgLyoqXG4gICAqIFVzZSByZXN1bHRzLlxuICAgKlxuICAgKiBAdHlwZSB7UmV0dXJuSGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbnN1Y2Nlc3NmdWxjb25zdHJ1Y3QoY29uc3RydWN0LCBpbmZvKSB7XG4gICAgYWRkUmVzdWx0KGNvbnN0cnVjdCwgaW5mby5mcm9tKVxuICB9XG4gIC8qKlxuICAgKiBEaXNjYXJkIHJlc3VsdHMuXG4gICAqXG4gICAqIEB0eXBlIHtSZXR1cm5IYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uc3VjY2Vzc2Z1bGNoZWNrKF8sIGluZm8pIHtcbiAgICBpbmZvLnJlc3RvcmUoKVxuICB9XG4gIC8qKlxuICAgKiBGYWN0b3J5IHRvIGF0dGVtcHQvY2hlY2svaW50ZXJydXB0LlxuICAgKlxuICAgKiBAcGFyYW0ge1JldHVybkhhbmRsZX0gb25yZXR1cm5cbiAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gW2ZpZWxkc11cbiAgICovXG5cbiAgZnVuY3Rpb24gY29uc3RydWN0RmFjdG9yeShvbnJldHVybiwgZmllbGRzKSB7XG4gICAgcmV0dXJuIGhvb2tcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZWl0aGVyIGFuIG9iamVjdCBtYXBwaW5nIGNvZGVzIHRvIGNvbnN0cnVjdHMsIGEgbGlzdCBvZlxuICAgICAqIGNvbnN0cnVjdHMsIG9yIGEgc2luZ2xlIGNvbnN0cnVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29uc3RydWN0fEFycmF5PENvbnN0cnVjdD58Q29uc3RydWN0UmVjb3JkfSBjb25zdHJ1Y3RzXG4gICAgICogQHBhcmFtIHtTdGF0ZX0gcmV0dXJuU3RhdGVcbiAgICAgKiBAcGFyYW0ge1N0YXRlfSBbYm9ndXNTdGF0ZV1cbiAgICAgKiBAcmV0dXJucyB7U3RhdGV9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBob29rKGNvbnN0cnVjdHMsIHJldHVyblN0YXRlLCBib2d1c1N0YXRlKSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PENvbnN0cnVjdD59ICovXG4gICAgICBsZXQgbGlzdE9mQ29uc3RydWN0c1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgICAgIGxldCBjb25zdHJ1Y3RJbmRleFxuICAgICAgLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5cbiAgICAgIGxldCBjdXJyZW50Q29uc3RydWN0XG4gICAgICAvKiogQHR5cGUge0luZm99ICovXG5cbiAgICAgIGxldCBpbmZvXG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjb25zdHJ1Y3RzKVxuICAgICAgICA/IC8qIGM4IGlnbm9yZSBuZXh0IDEgKi9cbiAgICAgICAgICBoYW5kbGVMaXN0T2ZDb25zdHJ1Y3RzKGNvbnN0cnVjdHMpXG4gICAgICAgIDogJ3Rva2VuaXplJyBpbiBjb25zdHJ1Y3RzIC8vIEB0cy1leHBlY3QtZXJyb3IgTG9va3MgbGlrZSBhIGNvbnN0cnVjdC5cbiAgICAgICAgPyBoYW5kbGVMaXN0T2ZDb25zdHJ1Y3RzKFtjb25zdHJ1Y3RzXSlcbiAgICAgICAgOiBoYW5kbGVNYXBPZkNvbnN0cnVjdHMoY29uc3RydWN0cylcbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIGEgbGlzdCBvZiBjb25zdHJ1Y3QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtDb25zdHJ1Y3RSZWNvcmR9IG1hcFxuICAgICAgICogQHJldHVybnMge1N0YXRlfVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1hcE9mQ29uc3RydWN0cyhtYXApIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0XG4gICAgICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICAgICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgICAgIGNvbnN0IGRlZiA9IGNvZGUgIT09IG51bGwgJiYgbWFwW2NvZGVdXG4gICAgICAgICAgY29uc3QgYWxsID0gY29kZSAhPT0gbnVsbCAmJiBtYXAubnVsbFxuICAgICAgICAgIGNvbnN0IGxpc3QgPSBbXG4gICAgICAgICAgICAvLyBUbyBkbzogYWRkIG1vcmUgZXh0ZW5zaW9uIHRlc3RzLlxuXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAyICovXG4gICAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShkZWYpID8gZGVmIDogZGVmID8gW2RlZl0gOiBbXSksXG4gICAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShhbGwpID8gYWxsIDogYWxsID8gW2FsbF0gOiBbXSlcbiAgICAgICAgICBdXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUxpc3RPZkNvbnN0cnVjdHMobGlzdCkoY29kZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgYSBsaXN0IG9mIGNvbnN0cnVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5PENvbnN0cnVjdD59IGxpc3RcbiAgICAgICAqIEByZXR1cm5zIHtTdGF0ZX1cbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVMaXN0T2ZDb25zdHJ1Y3RzKGxpc3QpIHtcbiAgICAgICAgbGlzdE9mQ29uc3RydWN0cyA9IGxpc3RcbiAgICAgICAgY29uc3RydWN0SW5kZXggPSAwXG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGJvZ3VzU3RhdGVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYW5kbGVDb25zdHJ1Y3QobGlzdFtjb25zdHJ1Y3RJbmRleF0pXG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBhIHNpbmdsZSBjb25zdHJ1Y3QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtDb25zdHJ1Y3R9IGNvbnN0cnVjdFxuICAgICAgICogQHJldHVybnMge1N0YXRlfVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNvbnN0cnVjdChjb25zdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0XG4gICAgICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICAgICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgICAgIC8vIFRvIGRvOiBub3QgbmVlZGVkIHRvIHN0b3JlIGlmIHRoZXJlIGlzIG5vIGJvZ3VzIHN0YXRlLCBwcm9iYWJseT9cbiAgICAgICAgICAvLyBDdXJyZW50bHkgZG9lc25cdTIwMTl0IHdvcmsgYmVjYXVzZSBgaW5zcGVjdGAgaW4gZG9jdW1lbnQgZG9lcyBhIGNoZWNrXG4gICAgICAgICAgLy8gdy9vIGEgYm9ndXMsIHdoaWNoIGRvZXNuXHUyMDE5dCBtYWtlIHNlbnNlLiBCdXQgaXQgZG9lcyBzZWVtIHRvIGhlbHAgcGVyZlxuICAgICAgICAgIC8vIGJ5IG5vdCBzdG9yaW5nLlxuICAgICAgICAgIGluZm8gPSBzdG9yZSgpXG4gICAgICAgICAgY3VycmVudENvbnN0cnVjdCA9IGNvbnN0cnVjdFxuXG4gICAgICAgICAgaWYgKCFjb25zdHJ1Y3QucGFydGlhbCkge1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Q29uc3RydWN0ID0gY29uc3RydWN0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29uc3RydWN0Lm5hbWUgJiZcbiAgICAgICAgICAgIGNvbnRleHQucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKGNvbnN0cnVjdC5uYW1lKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3QudG9rZW5pemUuY2FsbChcbiAgICAgICAgICAgIC8vIElmIHdlIGRvIGhhdmUgZmllbGRzLCBjcmVhdGUgYW4gb2JqZWN0IHcvIGBjb250ZXh0YCBhcyBpdHNcbiAgICAgICAgICAgIC8vIHByb3RvdHlwZS5cbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIGEgXHUyMDFDbGl2ZSBiaW5kaW5nXHUyMDFELCB3aGljaCBpcyBuZWVkZWQgZm9yIGBpbnRlcnJ1cHRgLlxuICAgICAgICAgICAgZmllbGRzID8gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGNvbnRleHQpLCBmaWVsZHMpIDogY29udGV4dCxcbiAgICAgICAgICAgIGVmZmVjdHMsXG4gICAgICAgICAgICBvayxcbiAgICAgICAgICAgIG5va1xuICAgICAgICAgICkoY29kZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgICAgZnVuY3Rpb24gb2soY29kZSkge1xuICAgICAgICBjb25zdW1lZCA9IHRydWVcbiAgICAgICAgb25yZXR1cm4oY3VycmVudENvbnN0cnVjdCwgaW5mbylcbiAgICAgICAgcmV0dXJuIHJldHVyblN0YXRlXG4gICAgICB9XG4gICAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgICBmdW5jdGlvbiBub2soY29kZSkge1xuICAgICAgICBjb25zdW1lZCA9IHRydWVcbiAgICAgICAgaW5mby5yZXN0b3JlKClcblxuICAgICAgICBpZiAoKytjb25zdHJ1Y3RJbmRleCA8IGxpc3RPZkNvbnN0cnVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUNvbnN0cnVjdChsaXN0T2ZDb25zdHJ1Y3RzW2NvbnN0cnVjdEluZGV4XSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2d1c1N0YXRlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdH0gY29uc3RydWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuICBmdW5jdGlvbiBhZGRSZXN1bHQoY29uc3RydWN0LCBmcm9tKSB7XG4gICAgaWYgKGNvbnN0cnVjdC5yZXNvbHZlQWxsICYmICFyZXNvbHZlQWxsQ29uc3RydWN0cy5pbmNsdWRlcyhjb25zdHJ1Y3QpKSB7XG4gICAgICByZXNvbHZlQWxsQ29uc3RydWN0cy5wdXNoKGNvbnN0cnVjdClcbiAgICB9XG5cbiAgICBpZiAoY29uc3RydWN0LnJlc29sdmUpIHtcbiAgICAgIHNwbGljZShcbiAgICAgICAgY29udGV4dC5ldmVudHMsXG4gICAgICAgIGZyb20sXG4gICAgICAgIGNvbnRleHQuZXZlbnRzLmxlbmd0aCAtIGZyb20sXG4gICAgICAgIGNvbnN0cnVjdC5yZXNvbHZlKGNvbnRleHQuZXZlbnRzLnNsaWNlKGZyb20pLCBjb250ZXh0KVxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChjb25zdHJ1Y3QucmVzb2x2ZVRvKSB7XG4gICAgICBjb250ZXh0LmV2ZW50cyA9IGNvbnN0cnVjdC5yZXNvbHZlVG8oY29udGV4dC5ldmVudHMsIGNvbnRleHQpXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdG9yZSBzdGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMge0luZm99XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHN0b3JlKCkge1xuICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSBub3coKVxuICAgIGNvbnN0IHN0YXJ0UHJldmlvdXMgPSBjb250ZXh0LnByZXZpb3VzXG4gICAgY29uc3Qgc3RhcnRDdXJyZW50Q29uc3RydWN0ID0gY29udGV4dC5jdXJyZW50Q29uc3RydWN0XG4gICAgY29uc3Qgc3RhcnRFdmVudHNJbmRleCA9IGNvbnRleHQuZXZlbnRzLmxlbmd0aFxuICAgIGNvbnN0IHN0YXJ0U3RhY2sgPSBBcnJheS5mcm9tKHN0YWNrKVxuICAgIHJldHVybiB7XG4gICAgICByZXN0b3JlLFxuICAgICAgZnJvbTogc3RhcnRFdmVudHNJbmRleFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgcG9pbnQgPSBzdGFydFBvaW50XG4gICAgICBjb250ZXh0LnByZXZpb3VzID0gc3RhcnRQcmV2aW91c1xuICAgICAgY29udGV4dC5jdXJyZW50Q29uc3RydWN0ID0gc3RhcnRDdXJyZW50Q29uc3RydWN0XG4gICAgICBjb250ZXh0LmV2ZW50cy5sZW5ndGggPSBzdGFydEV2ZW50c0luZGV4XG4gICAgICBzdGFjayA9IHN0YXJ0U3RhY2tcbiAgICAgIGFjY291bnRGb3JQb3RlbnRpYWxTa2lwKClcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGN1cnJlbnQgcG9pbnQgYSBiaXQgZm9yd2FyZCBpbiB0aGUgbGluZSB3aGVuIGl0XHUyMDE5cyBvbiBhIGNvbHVtblxuICAgKiBza2lwLlxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cbiAgZnVuY3Rpb24gYWNjb3VudEZvclBvdGVudGlhbFNraXAoKSB7XG4gICAgaWYgKHBvaW50LmxpbmUgaW4gY29sdW1uU3RhcnQgJiYgcG9pbnQuY29sdW1uIDwgMikge1xuICAgICAgcG9pbnQuY29sdW1uID0gY29sdW1uU3RhcnRbcG9pbnQubGluZV1cbiAgICAgIHBvaW50Lm9mZnNldCArPSBjb2x1bW5TdGFydFtwb2ludC5saW5lXSAtIDFcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2V0IHRoZSBjaHVua3MgZnJvbSBhIHNsaWNlIG9mIGNodW5rcyBpbiB0aGUgcmFuZ2Ugb2YgYSB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PENodW5rPn0gY2h1bmtzXG4gKiBAcGFyYW0ge1BpY2s8VG9rZW4sICdzdGFydCd8J2VuZCc+fSB0b2tlblxuICogQHJldHVybnMge0FycmF5PENodW5rPn1cbiAqL1xuXG5mdW5jdGlvbiBzbGljZUNodW5rcyhjaHVua3MsIHRva2VuKSB7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSB0b2tlbi5zdGFydC5faW5kZXhcbiAgY29uc3Qgc3RhcnRCdWZmZXJJbmRleCA9IHRva2VuLnN0YXJ0Ll9idWZmZXJJbmRleFxuICBjb25zdCBlbmRJbmRleCA9IHRva2VuLmVuZC5faW5kZXhcbiAgY29uc3QgZW5kQnVmZmVySW5kZXggPSB0b2tlbi5lbmQuX2J1ZmZlckluZGV4XG4gIC8qKiBAdHlwZSB7QXJyYXk8Q2h1bms+fSAqL1xuXG4gIGxldCB2aWV3XG5cbiAgaWYgKHN0YXJ0SW5kZXggPT09IGVuZEluZGV4KSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgX2J1ZmZlckluZGV4YCBpcyB1c2VkIG9uIHN0cmluZyBjaHVua3MuXG4gICAgdmlldyA9IFtjaHVua3Nbc3RhcnRJbmRleF0uc2xpY2Uoc3RhcnRCdWZmZXJJbmRleCwgZW5kQnVmZmVySW5kZXgpXVxuICB9IGVsc2Uge1xuICAgIHZpZXcgPSBjaHVua3Muc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpXG5cbiAgICBpZiAoc3RhcnRCdWZmZXJJbmRleCA+IC0xKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBfYnVmZmVySW5kZXhgIGlzIHVzZWQgb24gc3RyaW5nIGNodW5rcy5cbiAgICAgIHZpZXdbMF0gPSB2aWV3WzBdLnNsaWNlKHN0YXJ0QnVmZmVySW5kZXgpXG4gICAgfVxuXG4gICAgaWYgKGVuZEJ1ZmZlckluZGV4ID4gMCkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgX2J1ZmZlckluZGV4YCBpcyB1c2VkIG9uIHN0cmluZyBjaHVua3MuXG4gICAgICB2aWV3LnB1c2goY2h1bmtzW2VuZEluZGV4XS5zbGljZSgwLCBlbmRCdWZmZXJJbmRleCkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZpZXdcbn1cbi8qKlxuICogR2V0IHRoZSBzdHJpbmcgdmFsdWUgb2YgYSBzbGljZSBvZiBjaHVua3MuXG4gKlxuICogQHBhcmFtIHtBcnJheTxDaHVuaz59IGNodW5rc1xuICogQHBhcmFtIHtib29sZWFufSBbZXhwYW5kVGFicz1mYWxzZV1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplQ2h1bmtzKGNodW5rcywgZXhwYW5kVGFicykge1xuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG5cbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgYXRUYWJcblxuICB3aGlsZSAoKytpbmRleCA8IGNodW5rcy5sZW5ndGgpIHtcbiAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpbmRleF1cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cblxuICAgIGxldCB2YWx1ZVxuXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gY2h1bmtcbiAgICB9IGVsc2VcbiAgICAgIHN3aXRjaCAoY2h1bmspIHtcbiAgICAgICAgY2FzZSAtNToge1xuICAgICAgICAgIHZhbHVlID0gJ1xccidcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAtNDoge1xuICAgICAgICAgIHZhbHVlID0gJ1xcbidcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAtMzoge1xuICAgICAgICAgIHZhbHVlID0gJ1xccicgKyAnXFxuJ1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIC0yOiB7XG4gICAgICAgICAgdmFsdWUgPSBleHBhbmRUYWJzID8gJyAnIDogJ1xcdCdcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAtMToge1xuICAgICAgICAgIGlmICghZXhwYW5kVGFicyAmJiBhdFRhYikgY29udGludWVcbiAgICAgICAgICB2YWx1ZSA9ICcgJ1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgLy8gQ3VycmVudGx5IG9ubHkgcmVwbGFjZW1lbnQgY2hhcmFjdGVyLlxuICAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHVuaylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgYXRUYWIgPSBjaHVuayA9PT0gLTJcbiAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuam9pbignJylcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXh0ZW5zaW9ufSBFeHRlbnNpb25cbiAqL1xuaW1wb3J0IHtcbiAgYXR0ZW50aW9uLFxuICBhdXRvbGluayxcbiAgYmxvY2tRdW90ZSxcbiAgY2hhcmFjdGVyRXNjYXBlLFxuICBjaGFyYWN0ZXJSZWZlcmVuY2UsXG4gIGNvZGVGZW5jZWQsXG4gIGNvZGVJbmRlbnRlZCxcbiAgY29kZVRleHQsXG4gIGRlZmluaXRpb24sXG4gIGhhcmRCcmVha0VzY2FwZSxcbiAgaGVhZGluZ0F0eCxcbiAgaHRtbEZsb3csXG4gIGh0bWxUZXh0LFxuICBsYWJlbEVuZCxcbiAgbGFiZWxTdGFydEltYWdlLFxuICBsYWJlbFN0YXJ0TGluayxcbiAgbGluZUVuZGluZyxcbiAgbGlzdCxcbiAgc2V0ZXh0VW5kZXJsaW5lLFxuICB0aGVtYXRpY0JyZWFrXG59IGZyb20gJ21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsnXG5pbXBvcnQge3Jlc29sdmVyIGFzIHJlc29sdmVUZXh0fSBmcm9tICcuL2luaXRpYWxpemUvdGV4dC5qcydcbi8qKiBAdHlwZSB7RXh0ZW5zaW9uWydkb2N1bWVudCddfSAqL1xuXG5leHBvcnQgY29uc3QgZG9jdW1lbnQgPSB7XG4gIFs0Ml06IGxpc3QsXG4gIFs0M106IGxpc3QsXG4gIFs0NV06IGxpc3QsXG4gIFs0OF06IGxpc3QsXG4gIFs0OV06IGxpc3QsXG4gIFs1MF06IGxpc3QsXG4gIFs1MV06IGxpc3QsXG4gIFs1Ml06IGxpc3QsXG4gIFs1M106IGxpc3QsXG4gIFs1NF06IGxpc3QsXG4gIFs1NV06IGxpc3QsXG4gIFs1Nl06IGxpc3QsXG4gIFs1N106IGxpc3QsXG4gIFs2Ml06IGJsb2NrUXVvdGVcbn1cbi8qKiBAdHlwZSB7RXh0ZW5zaW9uWydjb250ZW50SW5pdGlhbCddfSAqL1xuXG5leHBvcnQgY29uc3QgY29udGVudEluaXRpYWwgPSB7XG4gIFs5MV06IGRlZmluaXRpb25cbn1cbi8qKiBAdHlwZSB7RXh0ZW5zaW9uWydmbG93SW5pdGlhbCddfSAqL1xuXG5leHBvcnQgY29uc3QgZmxvd0luaXRpYWwgPSB7XG4gIFstMl06IGNvZGVJbmRlbnRlZCxcbiAgWy0xXTogY29kZUluZGVudGVkLFxuICBbMzJdOiBjb2RlSW5kZW50ZWRcbn1cbi8qKiBAdHlwZSB7RXh0ZW5zaW9uWydmbG93J119ICovXG5cbmV4cG9ydCBjb25zdCBmbG93ID0ge1xuICBbMzVdOiBoZWFkaW5nQXR4LFxuICBbNDJdOiB0aGVtYXRpY0JyZWFrLFxuICBbNDVdOiBbc2V0ZXh0VW5kZXJsaW5lLCB0aGVtYXRpY0JyZWFrXSxcbiAgWzYwXTogaHRtbEZsb3csXG4gIFs2MV06IHNldGV4dFVuZGVybGluZSxcbiAgWzk1XTogdGhlbWF0aWNCcmVhayxcbiAgWzk2XTogY29kZUZlbmNlZCxcbiAgWzEyNl06IGNvZGVGZW5jZWRcbn1cbi8qKiBAdHlwZSB7RXh0ZW5zaW9uWydzdHJpbmcnXX0gKi9cblxuZXhwb3J0IGNvbnN0IHN0cmluZyA9IHtcbiAgWzM4XTogY2hhcmFjdGVyUmVmZXJlbmNlLFxuICBbOTJdOiBjaGFyYWN0ZXJFc2NhcGVcbn1cbi8qKiBAdHlwZSB7RXh0ZW5zaW9uWyd0ZXh0J119ICovXG5cbmV4cG9ydCBjb25zdCB0ZXh0ID0ge1xuICBbLTVdOiBsaW5lRW5kaW5nLFxuICBbLTRdOiBsaW5lRW5kaW5nLFxuICBbLTNdOiBsaW5lRW5kaW5nLFxuICBbMzNdOiBsYWJlbFN0YXJ0SW1hZ2UsXG4gIFszOF06IGNoYXJhY3RlclJlZmVyZW5jZSxcbiAgWzQyXTogYXR0ZW50aW9uLFxuICBbNjBdOiBbYXV0b2xpbmssIGh0bWxUZXh0XSxcbiAgWzkxXTogbGFiZWxTdGFydExpbmssXG4gIFs5Ml06IFtoYXJkQnJlYWtFc2NhcGUsIGNoYXJhY3RlckVzY2FwZV0sXG4gIFs5M106IGxhYmVsRW5kLFxuICBbOTVdOiBhdHRlbnRpb24sXG4gIFs5Nl06IGNvZGVUZXh0XG59XG4vKiogQHR5cGUge0V4dGVuc2lvblsnaW5zaWRlU3BhbiddfSAqL1xuXG5leHBvcnQgY29uc3QgaW5zaWRlU3BhbiA9IHtcbiAgbnVsbDogW2F0dGVudGlvbiwgcmVzb2x2ZVRleHRdXG59XG4vKiogQHR5cGUge0V4dGVuc2lvblsnYXR0ZW50aW9uTWFya2VycyddfSAqL1xuXG5leHBvcnQgY29uc3QgYXR0ZW50aW9uTWFya2VycyA9IHtcbiAgbnVsbDogWzQyLCA5NV1cbn1cbi8qKiBAdHlwZSB7RXh0ZW5zaW9uWydkaXNhYmxlJ119ICovXG5cbmV4cG9ydCBjb25zdCBkaXNhYmxlID0ge1xuICBudWxsOiBbXVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Jbml0aWFsQ29uc3RydWN0fSBJbml0aWFsQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkZ1bGxOb3JtYWxpemVkRXh0ZW5zaW9ufSBGdWxsTm9ybWFsaXplZEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5QYXJzZU9wdGlvbnN9IFBhcnNlT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5QYXJzZUNvbnRleHR9IFBhcnNlQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5DcmVhdGV9IENyZWF0ZVxuICovXG5pbXBvcnQge2NvbWJpbmVFeHRlbnNpb25zfSBmcm9tICdtaWNyb21hcmstdXRpbC1jb21iaW5lLWV4dGVuc2lvbnMnXG5pbXBvcnQge2NvbnRlbnR9IGZyb20gJy4vaW5pdGlhbGl6ZS9jb250ZW50LmpzJ1xuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSAnLi9pbml0aWFsaXplL2RvY3VtZW50LmpzJ1xuaW1wb3J0IHtmbG93fSBmcm9tICcuL2luaXRpYWxpemUvZmxvdy5qcydcbmltcG9ydCB7dGV4dCwgc3RyaW5nfSBmcm9tICcuL2luaXRpYWxpemUvdGV4dC5qcydcbmltcG9ydCB7Y3JlYXRlVG9rZW5pemVyfSBmcm9tICcuL2NyZWF0ZS10b2tlbml6ZXIuanMnXG5pbXBvcnQgKiBhcyBkZWZhdWx0Q29uc3RydWN0cyBmcm9tICcuL2NvbnN0cnVjdHMuanMnXG4vKipcbiAqIEBwYXJhbSB7UGFyc2VPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQYXJzZUNvbnRleHR9XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKG9wdGlvbnMgPSB7fSkge1xuICAvKiogQHR5cGUge0Z1bGxOb3JtYWxpemVkRXh0ZW5zaW9ufSAqL1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIGBkZWZhdWx0Q29uc3RydWN0c2AgaXMgZnVsbCwgc28gdGhlIHJlc3VsdCB3aWxsIGJlIHRvby5cbiAgY29uc3QgY29uc3RydWN0cyA9IGNvbWJpbmVFeHRlbnNpb25zKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgU2FtZSBhcyBhYm92ZS5cbiAgICBbZGVmYXVsdENvbnN0cnVjdHNdLmNvbmNhdChvcHRpb25zLmV4dGVuc2lvbnMgfHwgW10pXG4gIClcbiAgLyoqIEB0eXBlIHtQYXJzZUNvbnRleHR9ICovXG5cbiAgY29uc3QgcGFyc2VyID0ge1xuICAgIGRlZmluZWQ6IFtdLFxuICAgIGxhenk6IHt9LFxuICAgIGNvbnN0cnVjdHMsXG4gICAgY29udGVudDogY3JlYXRlKGNvbnRlbnQpLFxuICAgIGRvY3VtZW50OiBjcmVhdGUoZG9jdW1lbnQpLFxuICAgIGZsb3c6IGNyZWF0ZShmbG93KSxcbiAgICBzdHJpbmc6IGNyZWF0ZShzdHJpbmcpLFxuICAgIHRleHQ6IGNyZWF0ZSh0ZXh0KVxuICB9XG4gIHJldHVybiBwYXJzZXJcbiAgLyoqXG4gICAqIEBwYXJhbSB7SW5pdGlhbENvbnN0cnVjdH0gaW5pdGlhbFxuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGUoaW5pdGlhbCkge1xuICAgIHJldHVybiBjcmVhdG9yXG4gICAgLyoqIEB0eXBlIHtDcmVhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBjcmVhdG9yKGZyb20pIHtcbiAgICAgIHJldHVybiBjcmVhdGVUb2tlbml6ZXIocGFyc2VyLCBpbml0aWFsLCBmcm9tKVxuICAgIH1cbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FbmNvZGluZ30gRW5jb2RpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVmFsdWV9IFZhbHVlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNodW5rfSBDaHVua1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgUHJlcHJvY2Vzc29yXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZVxuICogQHBhcmFtIHtFbmNvZGluZ30gW2VuY29kaW5nXVxuICogQHBhcmFtIHtib29sZWFufSBbZW5kPWZhbHNlXVxuICogQHJldHVybnMge0FycmF5PENodW5rPn1cbiAqL1xuY29uc3Qgc2VhcmNoID0gL1tcXDBcXHRcXG5cXHJdL2dcbi8qKlxuICogQHJldHVybnMge1ByZXByb2Nlc3Nvcn1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2VzcygpIHtcbiAgbGV0IGNvbHVtbiA9IDFcbiAgbGV0IGJ1ZmZlciA9ICcnXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IHN0YXJ0ID0gdHJ1ZVxuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBhdENhcnJpYWdlUmV0dXJuXG4gIHJldHVybiBwcmVwcm9jZXNzb3JcbiAgLyoqIEB0eXBlIHtQcmVwcm9jZXNzb3J9ICovXG5cbiAgZnVuY3Rpb24gcHJlcHJvY2Vzc29yKHZhbHVlLCBlbmNvZGluZywgZW5kKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxDaHVuaz59ICovXG4gICAgY29uc3QgY2h1bmtzID0gW11cbiAgICAvKiogQHR5cGUge1JlZ0V4cE1hdGNoQXJyYXl8bnVsbH0gKi9cblxuICAgIGxldCBtYXRjaFxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXG4gICAgbGV0IG5leHRcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICAgIGxldCBzdGFydFBvc2l0aW9uXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgICBsZXQgZW5kUG9zaXRpb25cbiAgICAvKiogQHR5cGUge0NvZGV9ICovXG5cbiAgICBsZXQgY29kZSAvLyBAdHMtZXhwZWN0LWVycm9yIGBCdWZmZXJgIGRvZXMgYWxsb3cgYW4gZW5jb2RpbmcuXG5cbiAgICB2YWx1ZSA9IGJ1ZmZlciArIHZhbHVlLnRvU3RyaW5nKGVuY29kaW5nKVxuICAgIHN0YXJ0UG9zaXRpb24gPSAwXG4gICAgYnVmZmVyID0gJydcblxuICAgIGlmIChzdGFydCkge1xuICAgICAgaWYgKHZhbHVlLmNoYXJDb2RlQXQoMCkgPT09IDY1Mjc5KSB7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24rK1xuICAgICAgfVxuXG4gICAgICBzdGFydCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHdoaWxlIChzdGFydFBvc2l0aW9uIDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICBzZWFyY2gubGFzdEluZGV4ID0gc3RhcnRQb3NpdGlvblxuICAgICAgbWF0Y2ggPSBzZWFyY2guZXhlYyh2YWx1ZSlcbiAgICAgIGVuZFBvc2l0aW9uID1cbiAgICAgICAgbWF0Y2ggJiYgbWF0Y2guaW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGNoLmluZGV4IDogdmFsdWUubGVuZ3RoXG4gICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChlbmRQb3NpdGlvbilcblxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBidWZmZXIgPSB2YWx1ZS5zbGljZShzdGFydFBvc2l0aW9uKVxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA9PT0gMTAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gZW5kUG9zaXRpb24gJiYgYXRDYXJyaWFnZVJldHVybikge1xuICAgICAgICBjaHVua3MucHVzaCgtMylcbiAgICAgICAgYXRDYXJyaWFnZVJldHVybiA9IHVuZGVmaW5lZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGF0Q2FycmlhZ2VSZXR1cm4pIHtcbiAgICAgICAgICBjaHVua3MucHVzaCgtNSlcbiAgICAgICAgICBhdENhcnJpYWdlUmV0dXJuID0gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRQb3NpdGlvbiA8IGVuZFBvc2l0aW9uKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2godmFsdWUuc2xpY2Uoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pKVxuICAgICAgICAgIGNvbHVtbiArPSBlbmRQb3NpdGlvbiAtIHN0YXJ0UG9zaXRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goNjU1MzMpXG4gICAgICAgICAgICBjb2x1bW4rK1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIDk6IHtcbiAgICAgICAgICAgIG5leHQgPSBNYXRoLmNlaWwoY29sdW1uIC8gNCkgKiA0XG4gICAgICAgICAgICBjaHVua3MucHVzaCgtMilcblxuICAgICAgICAgICAgd2hpbGUgKGNvbHVtbisrIDwgbmV4dCkgY2h1bmtzLnB1c2goLTEpXG5cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAxMDoge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goLTQpXG4gICAgICAgICAgICBjb2x1bW4gPSAxXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGF0Q2FycmlhZ2VSZXR1cm4gPSB0cnVlXG4gICAgICAgICAgICBjb2x1bW4gPSAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0UG9zaXRpb24gPSBlbmRQb3NpdGlvbiArIDFcbiAgICB9XG5cbiAgICBpZiAoZW5kKSB7XG4gICAgICBpZiAoYXRDYXJyaWFnZVJldHVybikgY2h1bmtzLnB1c2goLTUpXG4gICAgICBpZiAoYnVmZmVyKSBjaHVua3MucHVzaChidWZmZXIpXG4gICAgICBjaHVua3MucHVzaChudWxsKVxuICAgIH1cblxuICAgIHJldHVybiBjaHVua3NcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FdmVudH0gRXZlbnRcbiAqL1xuaW1wb3J0IHtzdWJ0b2tlbml6ZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3VidG9rZW5pemUnXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAqIEByZXR1cm5zIHtBcnJheTxFdmVudD59XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBvc3Rwcm9jZXNzKGV2ZW50cykge1xuICB3aGlsZSAoIXN1YnRva2VuaXplKGV2ZW50cykpIHtcbiAgICAvLyBFbXB0eVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuIiwgIi8qKlxuICogVHVybiB0aGUgbnVtYmVyIChpbiBzdHJpbmcgZm9ybSBhcyBlaXRoZXIgaGV4YS0gb3IgcGxhaW4gZGVjaW1hbCkgY29taW5nIGZyb21cbiAqIGEgbnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlIGludG8gYSBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgIFZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXG4gKiAgIE51bWVyaWMgYmFzZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlKHZhbHVlLCBiYXNlKSB7XG4gIGNvbnN0IGNvZGUgPSBOdW1iZXIucGFyc2VJbnQodmFsdWUsIGJhc2UpXG5cbiAgaWYgKFxuICAgIC8vIEMwIGV4Y2VwdCBmb3IgSFQsIExGLCBGRiwgQ1IsIHNwYWNlXG4gICAgY29kZSA8IDkgfHxcbiAgICBjb2RlID09PSAxMSB8fFxuICAgIChjb2RlID4gMTMgJiYgY29kZSA8IDMyKSB8fCAvLyBDb250cm9sIGNoYXJhY3RlciAoREVMKSBvZiB0aGUgYmFzaWMgYmxvY2sgYW5kIEMxIGNvbnRyb2xzLlxuICAgIChjb2RlID4gMTI2ICYmIGNvZGUgPCAxNjApIHx8IC8vIExvbmUgaGlnaCBzdXJyb2dhdGVzIGFuZCBsb3cgc3Vycm9nYXRlcy5cbiAgICAoY29kZSA+IDU1Mjk1ICYmIGNvZGUgPCA1NzM0NCkgfHwgLy8gTm9uY2hhcmFjdGVycy5cbiAgICAoY29kZSA+IDY0OTc1ICYmIGNvZGUgPCA2NTAwOCkgfHxcbiAgICAoY29kZSAmIDY1NTM1KSA9PT0gNjU1MzUgfHxcbiAgICAoY29kZSAmIDY1NTM1KSA9PT0gNjU1MzQgfHwgLy8gT3V0IG9mIHJhbmdlXG4gICAgY29kZSA+IDExMTQxMTFcbiAgKSB7XG4gICAgcmV0dXJuICdcXHVGRkZEJ1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbn1cbiIsICJpbXBvcnQge2RlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlfSBmcm9tICdkZWNvZGUtbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZSdcbmltcG9ydCB7ZGVjb2RlTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtZGVjb2RlLW51bWVyaWMtY2hhcmFjdGVyLXJlZmVyZW5jZSdcbmNvbnN0IGNoYXJhY3RlckVzY2FwZU9yUmVmZXJlbmNlID1cbiAgL1xcXFwoWyEtLzotQFstYHstfl0pfCYoIyg/OlxcZHsxLDd9fHhbXFxkYS1mXXsxLDZ9KXxbXFxkYS16XXsxLDMxfSk7L2dpXG4vKipcbiAqIFV0aWxpdHkgdG8gZGVjb2RlIG1hcmtkb3duIHN0cmluZ3MgKHdoaWNoIG9jY3VyIGluIHBsYWNlcyBzdWNoIGFzIGZlbmNlZFxuICogY29kZSBpbmZvIHN0cmluZ3MsIGRlc3RpbmF0aW9ucywgbGFiZWxzLCBhbmQgdGl0bGVzKS5cbiAqIFRoZSBcdTIwMUNzdHJpbmdcdTIwMUQgY29udGVudCB0eXBlIGFsbG93cyBjaGFyYWN0ZXIgZXNjYXBlcyBhbmQgLXJlZmVyZW5jZXMuXG4gKiBUaGlzIGRlY29kZXMgdGhvc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoY2hhcmFjdGVyRXNjYXBlT3JSZWZlcmVuY2UsIGRlY29kZSlcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9ICQwXG4gKiBAcGFyYW0ge3N0cmluZ30gJDFcbiAqIEBwYXJhbSB7c3RyaW5nfSAkMlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGUoJDAsICQxLCAkMikge1xuICBpZiAoJDEpIHtcbiAgICAvLyBFc2NhcGUuXG4gICAgcmV0dXJuICQxXG4gIH0gLy8gUmVmZXJlbmNlLlxuXG4gIGNvbnN0IGhlYWQgPSAkMi5jaGFyQ29kZUF0KDApXG5cbiAgaWYgKGhlYWQgPT09IDM1KSB7XG4gICAgY29uc3QgaGVhZCA9ICQyLmNoYXJDb2RlQXQoMSlcbiAgICBjb25zdCBoZXggPSBoZWFkID09PSAxMjAgfHwgaGVhZCA9PT0gODhcbiAgICByZXR1cm4gZGVjb2RlTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZSgkMi5zbGljZShoZXggPyAyIDogMSksIGhleCA/IDE2IDogMTApXG4gIH1cblxuICByZXR1cm4gZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UoJDIpIHx8ICQwXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBvaW50fSBQb2ludFxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Ob2RlfSBOb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBvc2l0aW9ufSBQb3NpdGlvblxuICogQHR5cGVkZWYge29iamVjdCAmIHt0eXBlOiBzdHJpbmcsIHBvc2l0aW9uPzogUG9zaXRpb258dW5kZWZpbmVkfX0gTm9kZUxpa2VcbiAqL1xuXG4vKipcbiAqIFN0cmluZ2lmeSBvbmUgcG9pbnQsIGEgcG9zaXRpb24gKHN0YXJ0IGFuZCBlbmQgcG9pbnRzKSwgb3IgYSBub2RlXHUyMDE5c1xuICogcG9zaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge05vZGV8Tm9kZUxpa2V8UG9zaXRpb258UG9pbnR8bnVsbH0gW3ZhbHVlXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeVBvc2l0aW9uKHZhbHVlKSB7XG4gIC8vIE5vdGhpbmcuXG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gTm9kZS5cbiAgaWYgKCdwb3NpdGlvbicgaW4gdmFsdWUgfHwgJ3R5cGUnIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uKHZhbHVlLnBvc2l0aW9uKVxuICB9XG5cbiAgLy8gUG9zaXRpb24uXG4gIGlmICgnc3RhcnQnIGluIHZhbHVlIHx8ICdlbmQnIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uKHZhbHVlKVxuICB9XG5cbiAgLy8gUG9pbnQuXG4gIGlmICgnbGluZScgaW4gdmFsdWUgfHwgJ2NvbHVtbicgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gcG9pbnQodmFsdWUpXG4gIH1cblxuICAvLyA/XG4gIHJldHVybiAnJ1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UG9pbnR8dW5kZWZpbmVkfSBwb2ludFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcG9pbnQocG9pbnQpIHtcbiAgcmV0dXJuIGluZGV4KHBvaW50ICYmIHBvaW50LmxpbmUpICsgJzonICsgaW5kZXgocG9pbnQgJiYgcG9pbnQuY29sdW1uKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UG9zaXRpb258dW5kZWZpbmVkfSBwb3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHBvc2l0aW9uKHBvcykge1xuICByZXR1cm4gcG9pbnQocG9zICYmIHBvcy5zdGFydCkgKyAnLScgKyBwb2ludChwb3MgJiYgcG9zLmVuZClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBpbmRleCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogMVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FbmNvZGluZ30gRW5jb2RpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlBhcnNlT3B0aW9uc30gUGFyc2VPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZUNvbnRleHR9IFRva2VuaXplQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5WYWx1ZX0gVmFsdWVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUGFyZW50fSBVbmlzdFBhcmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Qb2ludH0gUG9pbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUGhyYXNpbmdDb250ZW50fSBQaHJhc2luZ0NvbnRlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQ29udGVudH0gQ29udGVudFxuICogQHR5cGVkZWYge1Jvb3R8Q29udGVudH0gTm9kZVxuICogQHR5cGVkZWYge0V4dHJhY3Q8Tm9kZSwgVW5pc3RQYXJlbnQ+fSBQYXJlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQnJlYWt9IEJyZWFrXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkJsb2NrcXVvdGV9IEJsb2NrcXVvdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQ29kZX0gQ29kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5EZWZpbml0aW9ufSBEZWZpbml0aW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkVtcGhhc2lzfSBFbXBoYXNpc1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5IZWFkaW5nfSBIZWFkaW5nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkhUTUx9IEhUTUxcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSW1hZ2V9IEltYWdlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkltYWdlUmVmZXJlbmNlfSBJbWFnZVJlZmVyZW5jZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5JbmxpbmVDb2RlfSBJbmxpbmVDb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpbmt9IExpbmtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGlua1JlZmVyZW5jZX0gTGlua1JlZmVyZW5jZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaXN0fSBMaXN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpc3RJdGVtfSBMaXN0SXRlbVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QYXJhZ3JhcGh9IFBhcmFncmFwaFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Sb290fSBSb290XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlN0cm9uZ30gU3Ryb25nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlRleHR9IFRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGhlbWF0aWNCcmVha30gVGhlbWF0aWNCcmVha1xuICpcbiAqIEB0eXBlZGVmIHtVbmlzdFBhcmVudCAmIHt0eXBlOiAnZnJhZ21lbnQnLCBjaGlsZHJlbjogQXJyYXk8UGhyYXNpbmdDb250ZW50Pn19IEZyYWdtZW50XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBfQ29tcGlsZURhdGFGaWVsZHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnx1bmRlZmluZWR9IGV4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZVxuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gZmxvd0NvZGVJbnNpZGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnx1bmRlZmluZWR9IHNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmdcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnx1bmRlZmluZWR9IGF0SGFyZEJyZWFrXG4gKiBAcHJvcGVydHkgeydjb2xsYXBzZWQnfCdmdWxsJ30gcmVmZXJlbmNlVHlwZVxuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gaW5SZWZlcmVuY2VcbiAqIEBwcm9wZXJ0eSB7J2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlckhleGFkZWNpbWFsJ3wnY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpYyd9IGNoYXJhY3RlclJlZmVyZW5jZVR5cGVcbiAqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgdW5rbm93bj4gJiBQYXJ0aWFsPF9Db21waWxlRGF0YUZpZWxkcz59IENvbXBpbGVEYXRhXG4gKlxuICogQHR5cGVkZWYgeyh0cmVlOiBSb290KSA9PiBSb290fHZvaWR9IFRyYW5zZm9ybVxuICogQHR5cGVkZWYgeyh0aGlzOiBDb21waWxlQ29udGV4dCwgdG9rZW46IFRva2VuKSA9PiB2b2lkfSBIYW5kbGVcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8c3RyaW5nLCBIYW5kbGU+fSBIYW5kbGVzXG4gKiAgIFRva2VuIHR5cGVzIG1hcHBpbmcgdG8gaGFuZGxlc1xuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHVua25vd24+fEFycmF5PHVua25vd24+PiAmIHtjYW5Db250YWluRW9sczogQXJyYXk8c3RyaW5nPiwgdHJhbnNmb3JtczogQXJyYXk8VHJhbnNmb3JtPiwgZW50ZXI6IEhhbmRsZXMsIGV4aXQ6IEhhbmRsZXN9fSBOb3JtYWxpemVkRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7UGFydGlhbDxOb3JtYWxpemVkRXh0ZW5zaW9uPn0gRXh0ZW5zaW9uXG4gKiAgIEFuIG1kYXN0IGV4dGVuc2lvbiBjaGFuZ2VzIGhvdyBtYXJrZG93biB0b2tlbnMgYXJlIHR1cm5lZCBpbnRvIG1kYXN0LlxuICpcbiAqIEB0eXBlZGVmIHsodGhpczogT21pdDxDb21waWxlQ29udGV4dCwgJ3NsaWNlU2VyaWFsaXplJz4sIGxlZnQ6IFRva2VufHVuZGVmaW5lZCwgcmlnaHQ6IFRva2VuKSA9PiB2b2lkfSBPbkVudGVyRXJyb3JcbiAqIEB0eXBlZGVmIHsodGhpczogT21pdDxDb21waWxlQ29udGV4dCwgJ3NsaWNlU2VyaWFsaXplJz4sIGxlZnQ6IFRva2VuLCByaWdodDogVG9rZW4pID0+IHZvaWR9IE9uRXhpdEVycm9yXG4gKlxuICogQHR5cGVkZWYgQ29tcGlsZUNvbnRleHRcbiAqICAgbWRhc3QgY29tcGlsZXIgY29udGV4dFxuICogQHByb3BlcnR5IHtBcnJheTxOb2RlIHwgRnJhZ21lbnQ+fSBzdGFja1xuICogQHByb3BlcnR5IHtBcnJheTxbVG9rZW4sIE9uRW50ZXJFcnJvcnx1bmRlZmluZWRdPn0gdG9rZW5TdGFja1xuICogQHByb3BlcnR5IHsoa2V5OiBzdHJpbmcsIHZhbHVlPzogdW5rbm93bikgPT4gdm9pZH0gc2V0RGF0YVxuICogICBTZXQgZGF0YSBpbnRvIHRoZSBrZXktdmFsdWUgc3RvcmUuXG4gKiBAcHJvcGVydHkgezxLIGV4dGVuZHMgc3RyaW5nPihrZXk6IEspID0+IENvbXBpbGVEYXRhW0tdfSBnZXREYXRhXG4gKiAgIEdldCBkYXRhIGZyb20gdGhlIGtleS12YWx1ZSBzdG9yZS5cbiAqIEBwcm9wZXJ0eSB7KHRoaXM6IENvbXBpbGVDb250ZXh0KSA9PiB2b2lkfSBidWZmZXJcbiAqICAgQ2FwdHVyZSBzb21lIG9mIHRoZSBvdXRwdXQgZGF0YS5cbiAqIEBwcm9wZXJ0eSB7KHRoaXM6IENvbXBpbGVDb250ZXh0KSA9PiBzdHJpbmd9IHJlc3VtZVxuICogICBTdG9wIGNhcHR1cmluZyBhbmQgYWNjZXNzIHRoZSBvdXRwdXQgZGF0YS5cbiAqIEBwcm9wZXJ0eSB7PE4gZXh0ZW5kcyBOb2RlPih0aGlzOiBDb21waWxlQ29udGV4dCwgbm9kZTogTiwgdG9rZW46IFRva2VuLCBvbkVycm9yPzogT25FbnRlckVycm9yKSA9PiBOfSBlbnRlclxuICogICBFbnRlciBhIHRva2VuLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQsIHRva2VuOiBUb2tlbiwgb25FcnJvcj86IE9uRXhpdEVycm9yKSA9PiBOb2RlfSBleGl0XG4gKiAgIEV4aXQgYSB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVDb250ZXh0WydzbGljZVNlcmlhbGl6ZSddfSBzbGljZVNlcmlhbGl6ZVxuICogICBHZXQgdGhlIHN0cmluZyB2YWx1ZSBvZiBhIHRva2VuLlxuICogQHByb3BlcnR5IHtOb3JtYWxpemVkRXh0ZW5zaW9ufSBjb25maWdcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqXG4gKiBAdHlwZWRlZiB7e21kYXN0RXh0ZW5zaW9ucz86IEFycmF5PEV4dGVuc2lvbnxBcnJheTxFeHRlbnNpb24+Pn19IEZyb21NYXJrZG93bk9wdGlvbnNcbiAqIEB0eXBlZGVmIHtQYXJzZU9wdGlvbnMgJiBGcm9tTWFya2Rvd25PcHRpb25zfSBPcHRpb25zXG4gKi9cbmltcG9ydCB7dG9TdHJpbmd9IGZyb20gJ21kYXN0LXV0aWwtdG8tc3RyaW5nJ1xuaW1wb3J0IHtwYXJzZX0gZnJvbSAnbWljcm9tYXJrL2xpYi9wYXJzZS5qcydcbmltcG9ydCB7cHJlcHJvY2Vzc30gZnJvbSAnbWljcm9tYXJrL2xpYi9wcmVwcm9jZXNzLmpzJ1xuaW1wb3J0IHtwb3N0cHJvY2Vzc30gZnJvbSAnbWljcm9tYXJrL2xpYi9wb3N0cHJvY2Vzcy5qcydcbmltcG9ydCB7ZGVjb2RlTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtZGVjb2RlLW51bWVyaWMtY2hhcmFjdGVyLXJlZmVyZW5jZSdcbmltcG9ydCB7ZGVjb2RlU3RyaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1kZWNvZGUtc3RyaW5nJ1xuaW1wb3J0IHtub3JtYWxpemVJZGVudGlmaWVyfSBmcm9tICdtaWNyb21hcmstdXRpbC1ub3JtYWxpemUtaWRlbnRpZmllcidcbmltcG9ydCB7ZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2V9IGZyb20gJ2RlY29kZS1uYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlJ1xuaW1wb3J0IHtzdHJpbmdpZnlQb3NpdGlvbn0gZnJvbSAndW5pc3QtdXRpbC1zdHJpbmdpZnktcG9zaXRpb24nXG5jb25zdCBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuLyoqXG4gKiBAcGFyYW0gdmFsdWUgTWFya2Rvd24gdG8gcGFyc2UgKGBzdHJpbmdgIG9yIGBCdWZmZXJgKS5cbiAqIEBwYXJhbSBbZW5jb2RpbmddIENoYXJhY3RlciBlbmNvZGluZyB0byB1bmRlcnN0YW5kIGB2YWx1ZWAgYXMgd2hlbiBpdFx1MjAxOXMgYSBgQnVmZmVyYCAoYHN0cmluZ2AsIGRlZmF1bHQ6IGAndXRmOCdgKS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gQ29uZmlndXJhdGlvblxuICovXG5cbmV4cG9ydCBjb25zdCBmcm9tTWFya2Rvd24gPVxuICAvKipcbiAgICogQHR5cGUgeyhcbiAgICogICAoKHZhbHVlOiBWYWx1ZSwgZW5jb2Rpbmc6IEVuY29kaW5nLCBvcHRpb25zPzogT3B0aW9ucykgPT4gUm9vdCkgJlxuICAgKiAgICgodmFsdWU6IFZhbHVlLCBvcHRpb25zPzogT3B0aW9ucykgPT4gUm9vdClcbiAgICogKX1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlXG4gICAqIEBwYXJhbSB7RW5jb2Rpbmd9IFtlbmNvZGluZ11cbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Jvb3R9XG4gICAqL1xuICBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMgPSBlbmNvZGluZ1xuICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGlsZXIob3B0aW9ucykoXG4gICAgICBwb3N0cHJvY2VzcyhcbiAgICAgICAgcGFyc2Uob3B0aW9ucykuZG9jdW1lbnQoKS53cml0ZShwcmVwcm9jZXNzKCkodmFsdWUsIGVuY29kaW5nLCB0cnVlKSlcbiAgICAgIClcbiAgICApXG4gIH1cbi8qKlxuICogTm90ZSB0aGlzIGNvbXBpbGVyIG9ubHkgdW5kZXJzdGFuZCBjb21wbGV0ZSBidWZmZXJpbmcsIG5vdCBzdHJlYW1pbmcuXG4gKlxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlcihvcHRpb25zID0ge30pIHtcbiAgLyoqIEB0eXBlIHtOb3JtYWxpemVkRXh0ZW5zaW9ufSAqL1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBvdXIgYmFzZSBoYXMgYWxsIHJlcXVpcmVkIGZpZWxkcywgc28gdGhlIHJlc3VsdCB3aWxsIHRvby5cbiAgY29uc3QgY29uZmlnID0gY29uZmlndXJlKFxuICAgIHtcbiAgICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgICAgY2FuQ29udGFpbkVvbHM6IFtcbiAgICAgICAgJ2VtcGhhc2lzJyxcbiAgICAgICAgJ2ZyYWdtZW50JyxcbiAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAgICAncGFyYWdyYXBoJyxcbiAgICAgICAgJ3N0cm9uZydcbiAgICAgIF0sXG4gICAgICBlbnRlcjoge1xuICAgICAgICBhdXRvbGluazogb3BlbmVyKGxpbmspLFxuICAgICAgICBhdXRvbGlua1Byb3RvY29sOiBvbmVudGVyZGF0YSxcbiAgICAgICAgYXV0b2xpbmtFbWFpbDogb25lbnRlcmRhdGEsXG4gICAgICAgIGF0eEhlYWRpbmc6IG9wZW5lcihoZWFkaW5nKSxcbiAgICAgICAgYmxvY2tRdW90ZTogb3BlbmVyKGJsb2NrUXVvdGUpLFxuICAgICAgICBjaGFyYWN0ZXJFc2NhcGU6IG9uZW50ZXJkYXRhLFxuICAgICAgICBjaGFyYWN0ZXJSZWZlcmVuY2U6IG9uZW50ZXJkYXRhLFxuICAgICAgICBjb2RlRmVuY2VkOiBvcGVuZXIoY29kZUZsb3cpLFxuICAgICAgICBjb2RlRmVuY2VkRmVuY2VJbmZvOiBidWZmZXIsXG4gICAgICAgIGNvZGVGZW5jZWRGZW5jZU1ldGE6IGJ1ZmZlcixcbiAgICAgICAgY29kZUluZGVudGVkOiBvcGVuZXIoY29kZUZsb3csIGJ1ZmZlciksXG4gICAgICAgIGNvZGVUZXh0OiBvcGVuZXIoY29kZVRleHQsIGJ1ZmZlciksXG4gICAgICAgIGNvZGVUZXh0RGF0YTogb25lbnRlcmRhdGEsXG4gICAgICAgIGRhdGE6IG9uZW50ZXJkYXRhLFxuICAgICAgICBjb2RlRmxvd1ZhbHVlOiBvbmVudGVyZGF0YSxcbiAgICAgICAgZGVmaW5pdGlvbjogb3BlbmVyKGRlZmluaXRpb24pLFxuICAgICAgICBkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmc6IGJ1ZmZlcixcbiAgICAgICAgZGVmaW5pdGlvbkxhYmVsU3RyaW5nOiBidWZmZXIsXG4gICAgICAgIGRlZmluaXRpb25UaXRsZVN0cmluZzogYnVmZmVyLFxuICAgICAgICBlbXBoYXNpczogb3BlbmVyKGVtcGhhc2lzKSxcbiAgICAgICAgaGFyZEJyZWFrRXNjYXBlOiBvcGVuZXIoaGFyZEJyZWFrKSxcbiAgICAgICAgaGFyZEJyZWFrVHJhaWxpbmc6IG9wZW5lcihoYXJkQnJlYWspLFxuICAgICAgICBodG1sRmxvdzogb3BlbmVyKGh0bWwsIGJ1ZmZlciksXG4gICAgICAgIGh0bWxGbG93RGF0YTogb25lbnRlcmRhdGEsXG4gICAgICAgIGh0bWxUZXh0OiBvcGVuZXIoaHRtbCwgYnVmZmVyKSxcbiAgICAgICAgaHRtbFRleHREYXRhOiBvbmVudGVyZGF0YSxcbiAgICAgICAgaW1hZ2U6IG9wZW5lcihpbWFnZSksXG4gICAgICAgIGxhYmVsOiBidWZmZXIsXG4gICAgICAgIGxpbms6IG9wZW5lcihsaW5rKSxcbiAgICAgICAgbGlzdEl0ZW06IG9wZW5lcihsaXN0SXRlbSksXG4gICAgICAgIGxpc3RJdGVtVmFsdWU6IG9uZW50ZXJsaXN0aXRlbXZhbHVlLFxuICAgICAgICBsaXN0T3JkZXJlZDogb3BlbmVyKGxpc3QsIG9uZW50ZXJsaXN0b3JkZXJlZCksXG4gICAgICAgIGxpc3RVbm9yZGVyZWQ6IG9wZW5lcihsaXN0KSxcbiAgICAgICAgcGFyYWdyYXBoOiBvcGVuZXIocGFyYWdyYXBoKSxcbiAgICAgICAgcmVmZXJlbmNlOiBvbmVudGVycmVmZXJlbmNlLFxuICAgICAgICByZWZlcmVuY2VTdHJpbmc6IGJ1ZmZlcixcbiAgICAgICAgcmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZzogYnVmZmVyLFxuICAgICAgICByZXNvdXJjZVRpdGxlU3RyaW5nOiBidWZmZXIsXG4gICAgICAgIHNldGV4dEhlYWRpbmc6IG9wZW5lcihoZWFkaW5nKSxcbiAgICAgICAgc3Ryb25nOiBvcGVuZXIoc3Ryb25nKSxcbiAgICAgICAgdGhlbWF0aWNCcmVhazogb3BlbmVyKHRoZW1hdGljQnJlYWspXG4gICAgICB9LFxuICAgICAgZXhpdDoge1xuICAgICAgICBhdHhIZWFkaW5nOiBjbG9zZXIoKSxcbiAgICAgICAgYXR4SGVhZGluZ1NlcXVlbmNlOiBvbmV4aXRhdHhoZWFkaW5nc2VxdWVuY2UsXG4gICAgICAgIGF1dG9saW5rOiBjbG9zZXIoKSxcbiAgICAgICAgYXV0b2xpbmtFbWFpbDogb25leGl0YXV0b2xpbmtlbWFpbCxcbiAgICAgICAgYXV0b2xpbmtQcm90b2NvbDogb25leGl0YXV0b2xpbmtwcm90b2NvbCxcbiAgICAgICAgYmxvY2tRdW90ZTogY2xvc2VyKCksXG4gICAgICAgIGNoYXJhY3RlckVzY2FwZVZhbHVlOiBvbmV4aXRkYXRhLFxuICAgICAgICBjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbDogb25leGl0Y2hhcmFjdGVycmVmZXJlbmNlbWFya2VyLFxuICAgICAgICBjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljOiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIsXG4gICAgICAgIGNoYXJhY3RlclJlZmVyZW5jZVZhbHVlOiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2V2YWx1ZSxcbiAgICAgICAgY29kZUZlbmNlZDogY2xvc2VyKG9uZXhpdGNvZGVmZW5jZWQpLFxuICAgICAgICBjb2RlRmVuY2VkRmVuY2U6IG9uZXhpdGNvZGVmZW5jZWRmZW5jZSxcbiAgICAgICAgY29kZUZlbmNlZEZlbmNlSW5mbzogb25leGl0Y29kZWZlbmNlZGZlbmNlaW5mbyxcbiAgICAgICAgY29kZUZlbmNlZEZlbmNlTWV0YTogb25leGl0Y29kZWZlbmNlZGZlbmNlbWV0YSxcbiAgICAgICAgY29kZUZsb3dWYWx1ZTogb25leGl0ZGF0YSxcbiAgICAgICAgY29kZUluZGVudGVkOiBjbG9zZXIob25leGl0Y29kZWluZGVudGVkKSxcbiAgICAgICAgY29kZVRleHQ6IGNsb3NlcihvbmV4aXRjb2RldGV4dCksXG4gICAgICAgIGNvZGVUZXh0RGF0YTogb25leGl0ZGF0YSxcbiAgICAgICAgZGF0YTogb25leGl0ZGF0YSxcbiAgICAgICAgZGVmaW5pdGlvbjogY2xvc2VyKCksXG4gICAgICAgIGRlZmluaXRpb25EZXN0aW5hdGlvblN0cmluZzogb25leGl0ZGVmaW5pdGlvbmRlc3RpbmF0aW9uc3RyaW5nLFxuICAgICAgICBkZWZpbml0aW9uTGFiZWxTdHJpbmc6IG9uZXhpdGRlZmluaXRpb25sYWJlbHN0cmluZyxcbiAgICAgICAgZGVmaW5pdGlvblRpdGxlU3RyaW5nOiBvbmV4aXRkZWZpbml0aW9udGl0bGVzdHJpbmcsXG4gICAgICAgIGVtcGhhc2lzOiBjbG9zZXIoKSxcbiAgICAgICAgaGFyZEJyZWFrRXNjYXBlOiBjbG9zZXIob25leGl0aGFyZGJyZWFrKSxcbiAgICAgICAgaGFyZEJyZWFrVHJhaWxpbmc6IGNsb3NlcihvbmV4aXRoYXJkYnJlYWspLFxuICAgICAgICBodG1sRmxvdzogY2xvc2VyKG9uZXhpdGh0bWxmbG93KSxcbiAgICAgICAgaHRtbEZsb3dEYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgICBodG1sVGV4dDogY2xvc2VyKG9uZXhpdGh0bWx0ZXh0KSxcbiAgICAgICAgaHRtbFRleHREYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgICBpbWFnZTogY2xvc2VyKG9uZXhpdGltYWdlKSxcbiAgICAgICAgbGFiZWw6IG9uZXhpdGxhYmVsLFxuICAgICAgICBsYWJlbFRleHQ6IG9uZXhpdGxhYmVsdGV4dCxcbiAgICAgICAgbGluZUVuZGluZzogb25leGl0bGluZWVuZGluZyxcbiAgICAgICAgbGluazogY2xvc2VyKG9uZXhpdGxpbmspLFxuICAgICAgICBsaXN0SXRlbTogY2xvc2VyKCksXG4gICAgICAgIGxpc3RPcmRlcmVkOiBjbG9zZXIoKSxcbiAgICAgICAgbGlzdFVub3JkZXJlZDogY2xvc2VyKCksXG4gICAgICAgIHBhcmFncmFwaDogY2xvc2VyKCksXG4gICAgICAgIHJlZmVyZW5jZVN0cmluZzogb25leGl0cmVmZXJlbmNlc3RyaW5nLFxuICAgICAgICByZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nOiBvbmV4aXRyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nLFxuICAgICAgICByZXNvdXJjZVRpdGxlU3RyaW5nOiBvbmV4aXRyZXNvdXJjZXRpdGxlc3RyaW5nLFxuICAgICAgICByZXNvdXJjZTogb25leGl0cmVzb3VyY2UsXG4gICAgICAgIHNldGV4dEhlYWRpbmc6IGNsb3NlcihvbmV4aXRzZXRleHRoZWFkaW5nKSxcbiAgICAgICAgc2V0ZXh0SGVhZGluZ0xpbmVTZXF1ZW5jZTogb25leGl0c2V0ZXh0aGVhZGluZ2xpbmVzZXF1ZW5jZSxcbiAgICAgICAgc2V0ZXh0SGVhZGluZ1RleHQ6IG9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0LFxuICAgICAgICBzdHJvbmc6IGNsb3NlcigpLFxuICAgICAgICB0aGVtYXRpY0JyZWFrOiBjbG9zZXIoKVxuICAgICAgfVxuICAgIH0sXG4gICAgb3B0aW9ucy5tZGFzdEV4dGVuc2lvbnMgfHwgW11cbiAgKVxuICAvKiogQHR5cGUge0NvbXBpbGVEYXRhfSAqL1xuXG4gIGNvbnN0IGRhdGEgPSB7fVxuICByZXR1cm4gY29tcGlsZVxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICAgKiBAcmV0dXJucyB7Um9vdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gY29tcGlsZShldmVudHMpIHtcbiAgICAvKiogQHR5cGUge1Jvb3R9ICovXG4gICAgbGV0IHRyZWUgPSB7XG4gICAgICB0eXBlOiAncm9vdCcsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9XG4gICAgLyoqIEB0eXBlIHtDb21waWxlQ29udGV4dFsnc3RhY2snXX0gKi9cblxuICAgIGNvbnN0IHN0YWNrID0gW3RyZWVdXG4gICAgLyoqIEB0eXBlIHtDb21waWxlQ29udGV4dFsndG9rZW5TdGFjayddfSAqL1xuXG4gICAgY29uc3QgdG9rZW5TdGFjayA9IFtdXG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuXG4gICAgY29uc3QgbGlzdFN0YWNrID0gW11cbiAgICAvKiogQHR5cGUge09taXQ8Q29tcGlsZUNvbnRleHQsICdzbGljZVNlcmlhbGl6ZSc+fSAqL1xuXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIHN0YWNrLFxuICAgICAgdG9rZW5TdGFjayxcbiAgICAgIGNvbmZpZyxcbiAgICAgIGVudGVyLFxuICAgICAgZXhpdCxcbiAgICAgIGJ1ZmZlcixcbiAgICAgIHJlc3VtZSxcbiAgICAgIHNldERhdGEsXG4gICAgICBnZXREYXRhXG4gICAgfVxuICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIFdlIHByZXByb2Nlc3MgbGlzdHMgdG8gYWRkIGBsaXN0SXRlbWAgdG9rZW5zLCBhbmQgdG8gaW5mZXIgd2hldGhlclxuICAgICAgLy8gaXRlbXMgdGhlIGxpc3QgaXRzZWxmIGFyZSBzcHJlYWQgb3V0LlxuICAgICAgaWYgKFxuICAgICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdsaXN0T3JkZXJlZCcgfHxcbiAgICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnbGlzdFVub3JkZXJlZCdcbiAgICAgICkge1xuICAgICAgICBpZiAoZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgIGxpc3RTdGFjay5wdXNoKGluZGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRhaWwgPSBsaXN0U3RhY2sucG9wKClcbiAgICAgICAgICBpbmRleCA9IHByZXBhcmVMaXN0KGV2ZW50cywgdGFpbCwgaW5kZXgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBjb25maWdbZXZlbnRzW2luZGV4XVswXV1cblxuICAgICAgaWYgKG93bi5jYWxsKGhhbmRsZXIsIGV2ZW50c1tpbmRleF1bMV0udHlwZSkpIHtcbiAgICAgICAgaGFuZGxlcltldmVudHNbaW5kZXhdWzFdLnR5cGVdLmNhbGwoXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2xpY2VTZXJpYWxpemU6IGV2ZW50c1tpbmRleF1bMl0uc2xpY2VTZXJpYWxpemVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgKSxcbiAgICAgICAgICBldmVudHNbaW5kZXhdWzFdXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rZW5TdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0YWlsID0gdG9rZW5TdGFja1t0b2tlblN0YWNrLmxlbmd0aCAtIDFdXG4gICAgICBjb25zdCBoYW5kbGVyID0gdGFpbFsxXSB8fCBkZWZhdWx0T25FcnJvclxuICAgICAgaGFuZGxlci5jYWxsKGNvbnRleHQsIHVuZGVmaW5lZCwgdGFpbFswXSlcbiAgICB9IC8vIEZpZ3VyZSBvdXQgYHJvb3RgIHBvc2l0aW9uLlxuXG4gICAgdHJlZS5wb3NpdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBwb2ludChcbiAgICAgICAgZXZlbnRzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IGV2ZW50c1swXVsxXS5zdGFydFxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBsaW5lOiAxLFxuICAgICAgICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIGVuZDogcG9pbnQoXG4gICAgICAgIGV2ZW50cy5sZW5ndGggPiAwXG4gICAgICAgICAgPyBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDJdWzFdLmVuZFxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBsaW5lOiAxLFxuICAgICAgICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgICBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGNvbmZpZy50cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgICAgdHJlZSA9IGNvbmZpZy50cmFuc2Zvcm1zW2luZGV4XSh0cmVlKSB8fCB0cmVlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cblxuICBmdW5jdGlvbiBwcmVwYXJlTGlzdChldmVudHMsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICBsZXQgaW5kZXggPSBzdGFydCAtIDFcbiAgICBsZXQgY29udGFpbmVyQmFsYW5jZSA9IC0xXG4gICAgbGV0IGxpc3RTcHJlYWQgPSBmYWxzZVxuICAgIC8qKiBAdHlwZSB7VG9rZW58dW5kZWZpbmVkfSAqL1xuXG4gICAgbGV0IGxpc3RJdGVtXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuXG4gICAgbGV0IGxpbmVJbmRleFxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cblxuICAgIGxldCBmaXJzdEJsYW5rTGluZUluZGV4XG4gICAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICAgIGxldCBhdE1hcmtlclxuXG4gICAgd2hpbGUgKCsraW5kZXggPD0gbGVuZ3RoKSB7XG4gICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpbmRleF1cblxuICAgICAgaWYgKFxuICAgICAgICBldmVudFsxXS50eXBlID09PSAnbGlzdFVub3JkZXJlZCcgfHxcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gJ2xpc3RPcmRlcmVkJyB8fFxuICAgICAgICBldmVudFsxXS50eXBlID09PSAnYmxvY2tRdW90ZSdcbiAgICAgICkge1xuICAgICAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICBjb250YWluZXJCYWxhbmNlKytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250YWluZXJCYWxhbmNlLS1cbiAgICAgICAgfVxuXG4gICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50WzFdLnR5cGUgPT09ICdsaW5lRW5kaW5nQmxhbmsnKSB7XG4gICAgICAgIGlmIChldmVudFswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxpc3RJdGVtICYmXG4gICAgICAgICAgICAhYXRNYXJrZXIgJiZcbiAgICAgICAgICAgICFjb250YWluZXJCYWxhbmNlICYmXG4gICAgICAgICAgICAhZmlyc3RCbGFua0xpbmVJbmRleFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZmlyc3RCbGFua0xpbmVJbmRleCA9IGluZGV4XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXRNYXJrZXIgPSB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gJ2xpbmVQcmVmaXgnIHx8XG4gICAgICAgIGV2ZW50WzFdLnR5cGUgPT09ICdsaXN0SXRlbVZhbHVlJyB8fFxuICAgICAgICBldmVudFsxXS50eXBlID09PSAnbGlzdEl0ZW1NYXJrZXInIHx8XG4gICAgICAgIGV2ZW50WzFdLnR5cGUgPT09ICdsaXN0SXRlbVByZWZpeCcgfHxcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gJ2xpc3RJdGVtUHJlZml4V2hpdGVzcGFjZSdcbiAgICAgICkge1xuICAgICAgICAvLyBFbXB0eS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgKCFjb250YWluZXJCYWxhbmNlICYmXG4gICAgICAgICAgZXZlbnRbMF0gPT09ICdlbnRlcicgJiZcbiAgICAgICAgICBldmVudFsxXS50eXBlID09PSAnbGlzdEl0ZW1QcmVmaXgnKSB8fFxuICAgICAgICAoY29udGFpbmVyQmFsYW5jZSA9PT0gLTEgJiZcbiAgICAgICAgICBldmVudFswXSA9PT0gJ2V4aXQnICYmXG4gICAgICAgICAgKGV2ZW50WzFdLnR5cGUgPT09ICdsaXN0VW5vcmRlcmVkJyB8fFxuICAgICAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gJ2xpc3RPcmRlcmVkJykpXG4gICAgICApIHtcbiAgICAgICAgaWYgKGxpc3RJdGVtKSB7XG4gICAgICAgICAgbGV0IHRhaWxJbmRleCA9IGluZGV4XG4gICAgICAgICAgbGluZUluZGV4ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICB3aGlsZSAodGFpbEluZGV4LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRhaWxFdmVudCA9IGV2ZW50c1t0YWlsSW5kZXhdXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09ICdsaW5lRW5kaW5nJyB8fFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmdCbGFuaydcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAodGFpbEV2ZW50WzBdID09PSAnZXhpdCcpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgaWYgKGxpbmVJbmRleCkge1xuICAgICAgICAgICAgICAgIGV2ZW50c1tsaW5lSW5kZXhdWzFdLnR5cGUgPSAnbGluZUVuZGluZ0JsYW5rJ1xuICAgICAgICAgICAgICAgIGxpc3RTcHJlYWQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9ICdsaW5lRW5kaW5nJ1xuICAgICAgICAgICAgICBsaW5lSW5kZXggPSB0YWlsSW5kZXhcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSAnbGluZVByZWZpeCcgfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09ICdibG9ja1F1b3RlUHJlZml4JyB8fFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gJ2Jsb2NrUXVvdGVQcmVmaXhXaGl0ZXNwYWNlJyB8fFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gJ2Jsb2NrUXVvdGVNYXJrZXInIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSAnbGlzdEl0ZW1JbmRlbnQnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gRW1wdHlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmlyc3RCbGFua0xpbmVJbmRleCAmJlxuICAgICAgICAgICAgKCFsaW5lSW5kZXggfHwgZmlyc3RCbGFua0xpbmVJbmRleCA8IGxpbmVJbmRleClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgUGF0Y2hlZC5cbiAgICAgICAgICAgIGxpc3RJdGVtLl9zcHJlYWQgPSB0cnVlXG4gICAgICAgICAgfSAvLyBGaXggcG9zaXRpb24uXG5cbiAgICAgICAgICBsaXN0SXRlbS5lbmQgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBsaW5lSW5kZXggPyBldmVudHNbbGluZUluZGV4XVsxXS5zdGFydCA6IGV2ZW50WzFdLmVuZFxuICAgICAgICAgIClcbiAgICAgICAgICBldmVudHMuc3BsaWNlKGxpbmVJbmRleCB8fCBpbmRleCwgMCwgWydleGl0JywgbGlzdEl0ZW0sIGV2ZW50WzJdXSlcbiAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgbGVuZ3RoKytcbiAgICAgICAgfSAvLyBDcmVhdGUgYSBuZXcgbGlzdCBpdGVtLlxuXG4gICAgICAgIGlmIChldmVudFsxXS50eXBlID09PSAnbGlzdEl0ZW1QcmVmaXgnKSB7XG4gICAgICAgICAgbGlzdEl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdEl0ZW0nLFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQYXRjaGVkXG4gICAgICAgICAgICBfc3ByZWFkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudFsxXS5zdGFydClcbiAgICAgICAgICB9IC8vIEB0cy1leHBlY3QtZXJyb3I6IGBsaXN0SXRlbWAgaXMgbW9zdCBkZWZpbml0ZWx5IGRlZmluZWQsIFRTLi4uXG5cbiAgICAgICAgICBldmVudHMuc3BsaWNlKGluZGV4LCAwLCBbJ2VudGVyJywgbGlzdEl0ZW0sIGV2ZW50WzJdXSlcbiAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgbGVuZ3RoKytcbiAgICAgICAgICBmaXJzdEJsYW5rTGluZUluZGV4ID0gdW5kZWZpbmVkXG4gICAgICAgICAgYXRNYXJrZXIgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEB0cy1leHBlY3QtZXJyb3IgUGF0Y2hlZC5cblxuICAgIGV2ZW50c1tzdGFydF1bMV0uX3NwcmVhZCA9IGxpc3RTcHJlYWRcbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtDb21waWxlQ29udGV4dFsnc2V0RGF0YSddfVxuICAgKiBAcGFyYW0gW3ZhbHVlXVxuICAgKi9cblxuICBmdW5jdGlvbiBzZXREYXRhKGtleSwgdmFsdWUpIHtcbiAgICBkYXRhW2tleV0gPSB2YWx1ZVxuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7Q29tcGlsZUNvbnRleHRbJ2dldERhdGEnXX1cbiAgICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAgICogQHBhcmFtIHtLfSBrZXlcbiAgICogQHJldHVybnMge0NvbXBpbGVEYXRhW0tdfVxuICAgKi9cblxuICBmdW5jdGlvbiBnZXREYXRhKGtleSkge1xuICAgIHJldHVybiBkYXRhW2tleV1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtQb2ludH0gZFxuICAgKiBAcmV0dXJucyB7UG9pbnR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBvaW50KGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogZC5saW5lLFxuICAgICAgY29sdW1uOiBkLmNvbHVtbixcbiAgICAgIG9mZnNldDogZC5vZmZzZXRcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7KHRva2VuOiBUb2tlbikgPT4gTm9kZX0gY3JlYXRlXG4gICAqIEBwYXJhbSB7SGFuZGxlfSBbYW5kXVxuICAgKiBAcmV0dXJucyB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvcGVuZXIoY3JlYXRlLCBhbmQpIHtcbiAgICByZXR1cm4gb3BlblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gb3Blbih0b2tlbikge1xuICAgICAgZW50ZXIuY2FsbCh0aGlzLCBjcmVhdGUodG9rZW4pLCB0b2tlbilcbiAgICAgIGlmIChhbmQpIGFuZC5jYWxsKHRoaXMsIHRva2VuKVxuICAgIH1cbiAgfVxuICAvKiogQHR5cGUge0NvbXBpbGVDb250ZXh0WydidWZmZXInXX0gKi9cblxuICBmdW5jdGlvbiBidWZmZXIoKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgIHR5cGU6ICdmcmFnbWVudCcsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9KVxuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7Q29tcGlsZUNvbnRleHRbJ2VudGVyJ119XG4gICAqIEB0ZW1wbGF0ZSB7Tm9kZX0gTlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEBwYXJhbSB7Tn0gbm9kZVxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiBAcGFyYW0ge09uRW50ZXJFcnJvcn0gW2Vycm9ySGFuZGxlcl1cbiAgICogQHJldHVybnMge059XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVudGVyKG5vZGUsIHRva2VuLCBlcnJvckhhbmRsZXIpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBBc3N1bWUgYE5vZGVgIGNhbiBleGlzdCBhcyBhIGNoaWxkIG9mIGBwYXJlbnRgLlxuICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpXG4gICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpXG4gICAgdGhpcy50b2tlblN0YWNrLnB1c2goW3Rva2VuLCBlcnJvckhhbmRsZXJdKSAvLyBAdHMtZXhwZWN0LWVycm9yOiBgZW5kYCB3aWxsIGJlIHBhdGNoZWQgbGF0ZXIuXG5cbiAgICBub2RlLnBvc2l0aW9uID0ge1xuICAgICAgc3RhcnQ6IHBvaW50KHRva2VuLnN0YXJ0KVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hhbmRsZX0gW2FuZF1cbiAgICogQHJldHVybnMge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xvc2VyKGFuZCkge1xuICAgIHJldHVybiBjbG9zZVxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY2xvc2UodG9rZW4pIHtcbiAgICAgIGlmIChhbmQpIGFuZC5jYWxsKHRoaXMsIHRva2VuKVxuICAgICAgZXhpdC5jYWxsKHRoaXMsIHRva2VuKVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHR5cGUge0NvbXBpbGVDb250ZXh0WydleGl0J119XG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICogQHBhcmFtIHtPbkV4aXRFcnJvcn0gW29uRXhpdEVycm9yXVxuICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gZXhpdCh0b2tlbiwgb25FeGl0RXJyb3IpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFjay5wb3AoKVxuICAgIGNvbnN0IG9wZW4gPSB0aGlzLnRva2VuU3RhY2sucG9wKClcblxuICAgIGlmICghb3Blbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IGNsb3NlIGAnICtcbiAgICAgICAgICB0b2tlbi50eXBlICtcbiAgICAgICAgICAnYCAoJyArXG4gICAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe1xuICAgICAgICAgICAgc3RhcnQ6IHRva2VuLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiB0b2tlbi5lbmRcbiAgICAgICAgICB9KSArXG4gICAgICAgICAgJyk6IGl0XHUyMDE5cyBub3Qgb3BlbidcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKG9wZW5bMF0udHlwZSAhPT0gdG9rZW4udHlwZSkge1xuICAgICAgaWYgKG9uRXhpdEVycm9yKSB7XG4gICAgICAgIG9uRXhpdEVycm9yLmNhbGwodGhpcywgdG9rZW4sIG9wZW5bMF0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gb3BlblsxXSB8fCBkZWZhdWx0T25FcnJvclxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgdG9rZW4sIG9wZW5bMF0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZS5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuICBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMuc3RhY2sucG9wKCkpXG4gIH0gLy9cbiAgLy8gSGFuZGxlcnMuXG4gIC8vXG5cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25lbnRlcmxpc3RvcmRlcmVkKCkge1xuICAgIHNldERhdGEoJ2V4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZScsIHRydWUpXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25lbnRlcmxpc3RpdGVtdmFsdWUodG9rZW4pIHtcbiAgICBpZiAoZ2V0RGF0YSgnZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlJykpIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9yID1cbiAgICAgICAgLyoqIEB0eXBlIHtMaXN0fSAqL1xuICAgICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl1cbiAgICAgIGFuY2VzdG9yLnN0YXJ0ID0gTnVtYmVyLnBhcnNlSW50KHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLCAxMClcbiAgICAgIHNldERhdGEoJ2V4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZScpXG4gICAgfVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGVmZW5jZWRmZW5jZWluZm8oKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7Q29kZX0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUubGFuZyA9IGRhdGFcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VtZXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9XG4gICAgICAvKiogQHR5cGUge0NvZGV9ICovXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBub2RlLm1ldGEgPSBkYXRhXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlKCkge1xuICAgIC8vIEV4aXQgaWYgdGhpcyBpcyB0aGUgY2xvc2luZyBmZW5jZS5cbiAgICBpZiAoZ2V0RGF0YSgnZmxvd0NvZGVJbnNpZGUnKSkgcmV0dXJuXG4gICAgdGhpcy5idWZmZXIoKVxuICAgIHNldERhdGEoJ2Zsb3dDb2RlSW5zaWRlJywgdHJ1ZSlcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9XG4gICAgICAvKiogQHR5cGUge0NvZGV9ICovXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBub2RlLnZhbHVlID0gZGF0YS5yZXBsYWNlKC9eKFxccj9cXG58XFxyKXwoXFxyP1xcbnxcXHIpJC9nLCAnJylcbiAgICBzZXREYXRhKCdmbG93Q29kZUluc2lkZScpXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0Y29kZWluZGVudGVkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9XG4gICAgICAvKiogQHR5cGUge0NvZGV9ICovXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBub2RlLnZhbHVlID0gZGF0YS5yZXBsYWNlKC8oXFxyP1xcbnxcXHIpJC9nLCAnJylcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRkZWZpbml0aW9ubGFiZWxzdHJpbmcodG9rZW4pIHtcbiAgICAvLyBEaXNjYXJkIGxhYmVsLCB1c2UgdGhlIHNvdXJjZSBjb250ZW50IGluc3RlYWQuXG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9XG4gICAgICAvKiogQHR5cGUge0RlZmluaXRpb259ICovXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBub2RlLmxhYmVsID0gbGFiZWxcbiAgICBub2RlLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICApLnRvTG93ZXJDYXNlKClcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRkZWZpbml0aW9udGl0bGVzdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7RGVmaW5pdGlvbn0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUudGl0bGUgPSBkYXRhXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0ZGVmaW5pdGlvbmRlc3RpbmF0aW9uc3RyaW5nKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9XG4gICAgICAvKiogQHR5cGUge0RlZmluaXRpb259ICovXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBub2RlLnVybCA9IGRhdGFcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRhdHhoZWFkaW5nc2VxdWVuY2UodG9rZW4pIHtcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7SGVhZGluZ30gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuXG4gICAgaWYgKCFub2RlLmRlcHRoKSB7XG4gICAgICBjb25zdCBkZXB0aCA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLmxlbmd0aFxuICAgICAgbm9kZS5kZXB0aCA9IGRlcHRoXG4gICAgfVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0KCkge1xuICAgIHNldERhdGEoJ3NldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcnLCB0cnVlKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmdsaW5lc2VxdWVuY2UodG9rZW4pIHtcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7SGVhZGluZ30gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUuZGVwdGggPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKS5jaGFyQ29kZUF0KDApID09PSA2MSA/IDEgOiAyXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0c2V0ZXh0aGVhZGluZygpIHtcbiAgICBzZXREYXRhKCdzZXRleHRIZWFkaW5nU2x1cnBMaW5lRW5kaW5nJylcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmVudGVyZGF0YSh0b2tlbikge1xuICAgIGNvbnN0IHBhcmVudCA9XG4gICAgICAvKiogQHR5cGUge1BhcmVudH0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cblxuICAgIGxldCB0YWlsID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXVxuXG4gICAgaWYgKCF0YWlsIHx8IHRhaWwudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAvLyBBZGQgYSBuZXcgdGV4dCBub2RlLlxuICAgICAgdGFpbCA9IHRleHQoKSAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZVx1MjAxOWxsIGFkZCBgZW5kYCBsYXRlci5cblxuICAgICAgdGFpbC5wb3NpdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IHBvaW50KHRva2VuLnN0YXJ0KVxuICAgICAgfSAvLyBAdHMtZXhwZWN0LWVycm9yOiBBc3N1bWUgYHBhcmVudGAgYWNjZXB0cyBgdGV4dGAuXG5cbiAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKHRhaWwpXG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5wdXNoKHRhaWwpXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0ZGF0YSh0b2tlbikge1xuICAgIGNvbnN0IHRhaWwgPSB0aGlzLnN0YWNrLnBvcCgpXG4gICAgdGFpbC52YWx1ZSArPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIHRhaWwucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGxpbmVlbmRpbmcodG9rZW4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG5cbiAgICAvLyBJZiB3ZVx1MjAxOXJlIGF0IGEgaGFyZCBicmVhaywgaW5jbHVkZSB0aGUgbGluZSBlbmRpbmcgaW4gdGhlcmUuXG4gICAgaWYgKGdldERhdGEoJ2F0SGFyZEJyZWFrJykpIHtcbiAgICAgIGNvbnN0IHRhaWwgPSBjb250ZXh0LmNoaWxkcmVuW2NvbnRleHQuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cbiAgICAgIHRhaWwucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICAgICAgc2V0RGF0YSgnYXRIYXJkQnJlYWsnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIWdldERhdGEoJ3NldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcnKSAmJlxuICAgICAgY29uZmlnLmNhbkNvbnRhaW5Fb2xzLmluY2x1ZGVzKGNvbnRleHQudHlwZSlcbiAgICApIHtcbiAgICAgIG9uZW50ZXJkYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gICAgICBvbmV4aXRkYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gICAgfVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGhhcmRicmVhaygpIHtcbiAgICBzZXREYXRhKCdhdEhhcmRCcmVhaycsIHRydWUpXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0aHRtbGZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7SFRNTH0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUudmFsdWUgPSBkYXRhXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0aHRtbHRleHQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7SFRNTH0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUudmFsdWUgPSBkYXRhXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0Y29kZXRleHQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7SW5saW5lQ29kZX0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUudmFsdWUgPSBkYXRhXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGluaygpIHtcbiAgICBjb25zdCBjb250ZXh0ID1cbiAgICAgIC8qKiBAdHlwZSB7TGluayAmIHtpZGVudGlmaWVyOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmd9fSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdIC8vIFRvIGRvOiBjbGVhbi5cblxuICAgIGlmIChnZXREYXRhKCdpblJlZmVyZW5jZScpKSB7XG4gICAgICBjb250ZXh0LnR5cGUgKz0gJ1JlZmVyZW5jZScgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuXG4gICAgICBjb250ZXh0LnJlZmVyZW5jZVR5cGUgPSBnZXREYXRhKCdyZWZlcmVuY2VUeXBlJykgfHwgJ3Nob3J0Y3V0JyAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG5cbiAgICAgIGRlbGV0ZSBjb250ZXh0LnVybFxuICAgICAgZGVsZXRlIGNvbnRleHQudGl0bGVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgZGVsZXRlIGNvbnRleHQuaWRlbnRpZmllciAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG5cbiAgICAgIGRlbGV0ZSBjb250ZXh0LmxhYmVsXG4gICAgfVxuXG4gICAgc2V0RGF0YSgncmVmZXJlbmNlVHlwZScpXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0aW1hZ2UoKSB7XG4gICAgY29uc3QgY29udGV4dCA9XG4gICAgICAvKiogQHR5cGUge0ltYWdlICYge2lkZW50aWZpZXI6IHN0cmluZywgbGFiZWw6IHN0cmluZ319ICovXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gLy8gVG8gZG86IGNsZWFuLlxuXG4gICAgaWYgKGdldERhdGEoJ2luUmVmZXJlbmNlJykpIHtcbiAgICAgIGNvbnRleHQudHlwZSArPSAnUmVmZXJlbmNlJyAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG5cbiAgICAgIGNvbnRleHQucmVmZXJlbmNlVHlwZSA9IGdldERhdGEoJ3JlZmVyZW5jZVR5cGUnKSB8fCAnc2hvcnRjdXQnIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cblxuICAgICAgZGVsZXRlIGNvbnRleHQudXJsXG4gICAgICBkZWxldGUgY29udGV4dC50aXRsZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgY29udGV4dC5pZGVudGlmaWVyIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cblxuICAgICAgZGVsZXRlIGNvbnRleHQubGFiZWxcbiAgICB9XG5cbiAgICBzZXREYXRhKCdyZWZlcmVuY2VUeXBlJylcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRsYWJlbHRleHQodG9rZW4pIHtcbiAgICBjb25zdCBhbmNlc3RvciA9XG4gICAgICAvKiogQHR5cGUgeyhMaW5rfEltYWdlKSAmIHtpZGVudGlmaWVyOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmd9fSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdXG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICBhbmNlc3Rvci5sYWJlbCA9IGRlY29kZVN0cmluZyhzdHJpbmcpXG4gICAgYW5jZXN0b3IuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoc3RyaW5nKS50b0xvd2VyQ2FzZSgpXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGFiZWwoKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPVxuICAgICAgLyoqIEB0eXBlIHtGcmFnbWVudH0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHsoTGlua3xJbWFnZSkgJiB7aWRlbnRpZmllcjogc3RyaW5nLCBsYWJlbDogc3RyaW5nfX0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSAvLyBBc3N1bWUgYSByZWZlcmVuY2UuXG5cbiAgICBzZXREYXRhKCdpblJlZmVyZW5jZScsIHRydWUpXG5cbiAgICBpZiAobm9kZS50eXBlID09PSAnbGluaycpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEFzc3VtZSBzdGF0aWMgcGhyYXNpbmcgY29udGVudC5cbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBmcmFnbWVudC5jaGlsZHJlblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmFsdCA9IHZhbHVlXG4gICAgfVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlc291cmNlZGVzdGluYXRpb25zdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7TGlua3xJbWFnZX0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUudXJsID0gZGF0YVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlc291cmNldGl0bGVzdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7TGlua3xJbWFnZX0gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUudGl0bGUgPSBkYXRhXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVzb3VyY2UoKSB7XG4gICAgc2V0RGF0YSgnaW5SZWZlcmVuY2UnKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZW50ZXJyZWZlcmVuY2UoKSB7XG4gICAgc2V0RGF0YSgncmVmZXJlbmNlVHlwZScsICdjb2xsYXBzZWQnKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlZmVyZW5jZXN0cmluZyh0b2tlbikge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPVxuICAgICAgLyoqIEB0eXBlIHtMaW5rUmVmZXJlbmNlfEltYWdlUmVmZXJlbmNlfSAqL1xuICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgbm9kZS5sYWJlbCA9IGxhYmVsXG4gICAgbm9kZS5pZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcihcbiAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgKS50b0xvd2VyQ2FzZSgpXG4gICAgc2V0RGF0YSgncmVmZXJlbmNlVHlwZScsICdmdWxsJylcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIodG9rZW4pIHtcbiAgICBzZXREYXRhKCdjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlJywgdG9rZW4udHlwZSlcbiAgfVxuICAvKiogQHR5cGUge0hhbmRsZX0gKi9cblxuICBmdW5jdGlvbiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2V2YWx1ZSh0b2tlbikge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIGNvbnN0IHR5cGUgPSBnZXREYXRhKCdjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlJylcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cblxuICAgIGxldCB2YWx1ZVxuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHZhbHVlID0gZGVjb2RlTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZShcbiAgICAgICAgZGF0YSxcbiAgICAgICAgdHlwZSA9PT0gJ2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWMnID8gMTAgOiAxNlxuICAgICAgKVxuICAgICAgc2V0RGF0YSgnY2hhcmFjdGVyUmVmZXJlbmNlVHlwZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGRlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlYCBjYW4gcmV0dXJuIGZhbHNlIGZvclxuICAgICAgLy8gaW52YWxpZCBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcywgYnV0IGV2ZXJ5dGhpbmcgd2VcdTIwMTl2ZSB0b2tlbml6ZWQgaXNcbiAgICAgIC8vIHZhbGlkLlxuICAgICAgdmFsdWUgPSBkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZShkYXRhKVxuICAgIH1cblxuICAgIGNvbnN0IHRhaWwgPSB0aGlzLnN0YWNrLnBvcCgpXG4gICAgdGFpbC52YWx1ZSArPSB2YWx1ZVxuICAgIHRhaWwucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICB9XG4gIC8qKiBAdHlwZSB7SGFuZGxlfSAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGF1dG9saW5rcHJvdG9jb2wodG9rZW4pIHtcbiAgICBvbmV4aXRkYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gICAgY29uc3Qgbm9kZSA9XG4gICAgICAvKiogQHR5cGUge0xpbmt9ICovXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBub2RlLnVybCA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gIH1cbiAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG5cbiAgZnVuY3Rpb24gb25leGl0YXV0b2xpbmtlbWFpbCh0b2tlbikge1xuICAgIG9uZXhpdGRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICBjb25zdCBub2RlID1cbiAgICAgIC8qKiBAdHlwZSB7TGlua30gKi9cbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIG5vZGUudXJsID0gJ21haWx0bzonICsgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgfSAvL1xuICAvLyBDcmVhdGVycy5cbiAgLy9cblxuICAvKiogQHJldHVybnMge0Jsb2NrcXVvdGV9ICovXG5cbiAgZnVuY3Rpb24gYmxvY2tRdW90ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG4gIC8qKiBAcmV0dXJucyB7Q29kZX0gKi9cblxuICBmdW5jdGlvbiBjb2RlRmxvdygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgbGFuZzogbnVsbCxcbiAgICAgIG1ldGE6IG51bGwsXG4gICAgICB2YWx1ZTogJydcbiAgICB9XG4gIH1cbiAgLyoqIEByZXR1cm5zIHtJbmxpbmVDb2RlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvZGVUZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnaW5saW5lQ29kZScsXG4gICAgICB2YWx1ZTogJydcbiAgICB9XG4gIH1cbiAgLyoqIEByZXR1cm5zIHtEZWZpbml0aW9ufSAqL1xuXG4gIGZ1bmN0aW9uIGRlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdkZWZpbml0aW9uJyxcbiAgICAgIGlkZW50aWZpZXI6ICcnLFxuICAgICAgbGFiZWw6IG51bGwsXG4gICAgICB0aXRsZTogbnVsbCxcbiAgICAgIHVybDogJydcbiAgICB9XG4gIH1cbiAgLyoqIEByZXR1cm5zIHtFbXBoYXNpc30gKi9cblxuICBmdW5jdGlvbiBlbXBoYXNpcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2VtcGhhc2lzJyxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuICAvKiogQHJldHVybnMge0hlYWRpbmd9ICovXG5cbiAgZnVuY3Rpb24gaGVhZGluZygpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBkZXB0aGAgd2lsbCBiZSBzZXQgbGF0ZXIuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgIGRlcHRoOiB1bmRlZmluZWQsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9XG4gIH1cbiAgLyoqIEByZXR1cm5zIHtCcmVha30gKi9cblxuICBmdW5jdGlvbiBoYXJkQnJlYWsoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdicmVhaydcbiAgICB9XG4gIH1cbiAgLyoqIEByZXR1cm5zIHtIVE1MfSAqL1xuXG4gIGZ1bmN0aW9uIGh0bWwoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgIHZhbHVlOiAnJ1xuICAgIH1cbiAgfVxuICAvKiogQHJldHVybnMge0ltYWdlfSAqL1xuXG4gIGZ1bmN0aW9uIGltYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgdGl0bGU6IG51bGwsXG4gICAgICB1cmw6ICcnLFxuICAgICAgYWx0OiBudWxsXG4gICAgfVxuICB9XG4gIC8qKiBAcmV0dXJucyB7TGlua30gKi9cblxuICBmdW5jdGlvbiBsaW5rKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnbGluaycsXG4gICAgICB0aXRsZTogbnVsbCxcbiAgICAgIHVybDogJycsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqIEByZXR1cm5zIHtMaXN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBsaXN0KHRva2VuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgIG9yZGVyZWQ6IHRva2VuLnR5cGUgPT09ICdsaXN0T3JkZXJlZCcsXG4gICAgICBzdGFydDogbnVsbCxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgUGF0Y2hlZC5cbiAgICAgIHNwcmVhZDogdG9rZW4uX3NwcmVhZCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICogQHJldHVybnMge0xpc3RJdGVtfVxuICAgKi9cblxuICBmdW5jdGlvbiBsaXN0SXRlbSh0b2tlbikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnbGlzdEl0ZW0nLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQYXRjaGVkLlxuICAgICAgc3ByZWFkOiB0b2tlbi5fc3ByZWFkLFxuICAgICAgY2hlY2tlZDogbnVsbCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuICAvKiogQHJldHVybnMge1BhcmFncmFwaH0gKi9cblxuICBmdW5jdGlvbiBwYXJhZ3JhcGgoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG4gIC8qKiBAcmV0dXJucyB7U3Ryb25nfSAqL1xuXG4gIGZ1bmN0aW9uIHN0cm9uZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3N0cm9uZycsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9XG4gIH1cbiAgLyoqIEByZXR1cm5zIHtUZXh0fSAqL1xuXG4gIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgIHZhbHVlOiAnJ1xuICAgIH1cbiAgfVxuICAvKiogQHJldHVybnMge1RoZW1hdGljQnJlYWt9ICovXG5cbiAgZnVuY3Rpb24gdGhlbWF0aWNCcmVhaygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3RoZW1hdGljQnJlYWsnXG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7RXh0ZW5zaW9ufSBjb21iaW5lZFxuICogQHBhcmFtIHtBcnJheTxFeHRlbnNpb258QXJyYXk8RXh0ZW5zaW9uPj59IGV4dGVuc2lvbnNcbiAqIEByZXR1cm5zIHtFeHRlbnNpb259XG4gKi9cblxuZnVuY3Rpb24gY29uZmlndXJlKGNvbWJpbmVkLCBleHRlbnNpb25zKSB7XG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBleHRlbnNpb25zLmxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uc1tpbmRleF1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY29uZmlndXJlKGNvbWJpbmVkLCB2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5zaW9uKGNvbWJpbmVkLCB2YWx1ZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29tYmluZWRcbn1cbi8qKlxuICogQHBhcmFtIHtFeHRlbnNpb259IGNvbWJpbmVkXG4gKiBAcGFyYW0ge0V4dGVuc2lvbn0gZXh0ZW5zaW9uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG5mdW5jdGlvbiBleHRlbnNpb24oY29tYmluZWQsIGV4dGVuc2lvbikge1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgbGV0IGtleVxuXG4gIGZvciAoa2V5IGluIGV4dGVuc2lvbikge1xuICAgIGlmIChvd24uY2FsbChleHRlbnNpb24sIGtleSkpIHtcbiAgICAgIGNvbnN0IGxpc3QgPSBrZXkgPT09ICdjYW5Db250YWluRW9scycgfHwga2V5ID09PSAndHJhbnNmb3JtcydcbiAgICAgIGNvbnN0IG1heWJlID0gb3duLmNhbGwoY29tYmluZWQsIGtleSkgPyBjb21iaW5lZFtrZXldIDogdW5kZWZpbmVkXG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICBjb25zdCBsZWZ0ID0gbWF5YmUgfHwgKGNvbWJpbmVkW2tleV0gPSBsaXN0ID8gW10gOiB7fSlcbiAgICAgIGNvbnN0IHJpZ2h0ID0gZXh0ZW5zaW9uW2tleV1cblxuICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGxlZnRgIGlzIGFuIGFycmF5LlxuICAgICAgICAgIGNvbWJpbmVkW2tleV0gPSBbLi4ubGVmdCwgLi4ucmlnaHRdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihsZWZ0LCByaWdodClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqIEB0eXBlIHtPbkVudGVyRXJyb3J9ICovXG5cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGxlZnQsIHJpZ2h0KSB7XG4gIGlmIChsZWZ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBjbG9zZSBgJyArXG4gICAgICAgIGxlZnQudHlwZSArXG4gICAgICAgICdgICgnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe1xuICAgICAgICAgIHN0YXJ0OiBsZWZ0LnN0YXJ0LFxuICAgICAgICAgIGVuZDogbGVmdC5lbmRcbiAgICAgICAgfSkgK1xuICAgICAgICAnKTogYSBkaWZmZXJlbnQgdG9rZW4gKGAnICtcbiAgICAgICAgcmlnaHQudHlwZSArXG4gICAgICAgICdgLCAnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe1xuICAgICAgICAgIHN0YXJ0OiByaWdodC5zdGFydCxcbiAgICAgICAgICBlbmQ6IHJpZ2h0LmVuZFxuICAgICAgICB9KSArXG4gICAgICAgICcpIGlzIG9wZW4nXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3QgY2xvc2UgZG9jdW1lbnQsIGEgdG9rZW4gKGAnICtcbiAgICAgICAgcmlnaHQudHlwZSArXG4gICAgICAgICdgLCAnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe1xuICAgICAgICAgIHN0YXJ0OiByaWdodC5zdGFydCxcbiAgICAgICAgICBlbmQ6IHJpZ2h0LmVuZFxuICAgICAgICB9KSArXG4gICAgICAgICcpIGlzIHN0aWxsIG9wZW4nXG4gICAgKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBtYXRoRmxvdyA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplTWF0aEZlbmNlZCxcbiAgY29uY3JldGU6IHRydWVcbn1cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuXG5jb25zdCBub25MYXp5TGluZSA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplTm9uTGF6eUxpbmUsXG4gIHBhcnRpYWw6IHRydWVcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZU1hdGhGZW5jZWQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBjb25zdCB0YWlsID0gc2VsZi5ldmVudHNbc2VsZi5ldmVudHMubGVuZ3RoIC0gMV1cbiAgY29uc3QgaW5pdGlhbFNpemUgPVxuICAgIHRhaWwgJiYgdGFpbFsxXS50eXBlID09PSAnbGluZVByZWZpeCdcbiAgICAgID8gdGFpbFsyXS5zbGljZVNlcmlhbGl6ZSh0YWlsWzFdLCB0cnVlKS5sZW5ndGhcbiAgICAgIDogMFxuICBsZXQgc2l6ZU9wZW4gPSAwXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdtYXRoRmxvdycpXG4gICAgZWZmZWN0cy5lbnRlcignbWF0aEZsb3dGZW5jZScpXG4gICAgZWZmZWN0cy5lbnRlcignbWF0aEZsb3dGZW5jZVNlcXVlbmNlJylcbiAgICByZXR1cm4gc2VxdWVuY2VPcGVuKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzZXF1ZW5jZU9wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSAzNikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBzaXplT3BlbisrXG4gICAgICByZXR1cm4gc2VxdWVuY2VPcGVuXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCdtYXRoRmxvd0ZlbmNlU2VxdWVuY2UnKVxuICAgIHJldHVybiBzaXplT3BlbiA8IDJcbiAgICAgID8gbm9rKGNvZGUpXG4gICAgICA6IGZhY3RvcnlTcGFjZShlZmZlY3RzLCBtZXRhT3BlbiwgJ3doaXRlc3BhY2UnKShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gbWV0YU9wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIG9wZW5BZnRlcihjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ21hdGhGbG93RmVuY2VNZXRhJylcbiAgICBlZmZlY3RzLmVudGVyKCdjaHVua1N0cmluZycsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiAnc3RyaW5nJ1xuICAgIH0pXG4gICAgcmV0dXJuIG1ldGEoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIG1ldGEoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1N0cmluZycpXG4gICAgICBlZmZlY3RzLmV4aXQoJ21hdGhGbG93RmVuY2VNZXRhJylcbiAgICAgIHJldHVybiBvcGVuQWZ0ZXIoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMzYpIHJldHVybiBub2soY29kZSlcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gbWV0YVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb3BlbkFmdGVyKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ21hdGhGbG93RmVuY2UnKVxuICAgIHJldHVybiBzZWxmLmludGVycnVwdCA/IG9rKGNvZGUpIDogY29udGVudFN0YXJ0KGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250ZW50U3RhcnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYWZ0ZXIoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICBub25MYXp5TGluZSxcbiAgICAgICAgZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRva2VuaXplOiB0b2tlbml6ZUNsb3NpbmdGZW5jZSxcbiAgICAgICAgICAgIHBhcnRpYWw6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFmdGVyLFxuICAgICAgICAgIGluaXRpYWxTaXplXG4gICAgICAgICAgICA/IGZhY3RvcnlTcGFjZShlZmZlY3RzLCBjb250ZW50U3RhcnQsICdsaW5lUHJlZml4JywgaW5pdGlhbFNpemUgKyAxKVxuICAgICAgICAgICAgOiBjb250ZW50U3RhcnRcbiAgICAgICAgKSxcbiAgICAgICAgYWZ0ZXJcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdtYXRoRmxvd1ZhbHVlJylcbiAgICByZXR1cm4gY29udGVudENvbnRpbnVlKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjb250ZW50Q29udGludWUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdtYXRoRmxvd1ZhbHVlJylcbiAgICAgIHJldHVybiBjb250ZW50U3RhcnQoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29udGVudENvbnRpbnVlXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlcihjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCdtYXRoRmxvdycpXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVDbG9zaW5nRmVuY2UoZWZmZWN0cywgb2ssIG5vaykge1xuICAgIGxldCBzaXplID0gMFxuICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgY2xvc2luZ1ByZWZpeEFmdGVyLCAnbGluZVByZWZpeCcsIDQpXG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIGNsb3NpbmdQcmVmaXhBZnRlcihjb2RlKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdtYXRoRmxvd0ZlbmNlJylcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ21hdGhGbG93RmVuY2VTZXF1ZW5jZScpXG4gICAgICByZXR1cm4gY2xvc2luZ1NlcXVlbmNlKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBjbG9zaW5nU2VxdWVuY2UoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IDM2KSB7XG4gICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgICBzaXplKytcbiAgICAgICAgcmV0dXJuIGNsb3NpbmdTZXF1ZW5jZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSA8IHNpemVPcGVuKSByZXR1cm4gbm9rKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ21hdGhGbG93RmVuY2VTZXF1ZW5jZScpXG4gICAgICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGNsb3NpbmdTZXF1ZW5jZUVuZCwgJ3doaXRlc3BhY2UnKShjb2RlKVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gY2xvc2luZ1NlcXVlbmNlRW5kKGNvZGUpIHtcbiAgICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgICBlZmZlY3RzLmV4aXQoJ21hdGhGbG93RmVuY2UnKVxuICAgICAgICByZXR1cm4gb2soY29kZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplTm9uTGF6eUxpbmUoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignbGluZUVuZGluZycpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdsaW5lRW5kaW5nJylcbiAgICByZXR1cm4gbGluZVN0YXJ0XG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBsaW5lU3RhcnQoY29kZSkge1xuICAgIHJldHVybiBzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0gPyBub2soY29kZSkgOiBvayhjb2RlKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlJlc29sdmVyfSBSZXNvbHZlclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5QcmV2aW91c30gUHJldmlvdXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICpcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NpbmdsZURvbGxhclRleHRNYXRoPXRydWVdXG4gKiAgIFdoZXRoZXIgdG8gc3VwcG9ydCBtYXRoICh0ZXh0KSB3aXRoIGEgc2luZ2xlIGRvbGxhciAoYGJvb2xlYW5gLCBkZWZhdWx0OlxuICogICBgdHJ1ZWApLlxuICogICBTaW5nbGUgZG9sbGFycyB3b3JrIGluIFBhbmRvYyBhbmQgbWFueSBvdGhlciBwbGFjZXMsIGJ1dCBvZnRlbiBpbnRlcmZlcmVcbiAqICAgd2l0aCBcdTIwMUNub3JtYWxcdTIwMUQgZG9sbGFycyBpbiB0ZXh0LlxuICovXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuXG4vKipcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0aFRleHQob3B0aW9ucyA9IHt9KSB7XG4gIGxldCBzaW5nbGUgPSBvcHRpb25zLnNpbmdsZURvbGxhclRleHRNYXRoXG5cbiAgaWYgKHNpbmdsZSA9PT0gbnVsbCB8fCBzaW5nbGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNpbmdsZSA9IHRydWVcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9rZW5pemU6IHRva2VuaXplTWF0aFRleHQsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZU1hdGhUZXh0LFxuICAgIHByZXZpb3VzXG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVNYXRoVGV4dChlZmZlY3RzLCBvaywgbm9rKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBsZXQgc2l6ZU9wZW4gPSAwXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cbiAgICBsZXQgc2l6ZVxuICAgIC8qKiBAdHlwZSB7VG9rZW59ICovXG5cbiAgICBsZXQgdG9rZW5cbiAgICByZXR1cm4gc3RhcnRcbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignbWF0aFRleHQnKVxuICAgICAgZWZmZWN0cy5lbnRlcignbWF0aFRleHRTZXF1ZW5jZScpXG4gICAgICByZXR1cm4gb3BlbmluZ1NlcXVlbmNlKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBvcGVuaW5nU2VxdWVuY2UoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IDM2KSB7XG4gICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgICBzaXplT3BlbisrXG4gICAgICAgIHJldHVybiBvcGVuaW5nU2VxdWVuY2VcbiAgICAgIH1cblxuICAgICAgaWYgKHNpemVPcGVuIDwgMiAmJiAhc2luZ2xlKSByZXR1cm4gbm9rKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ21hdGhUZXh0U2VxdWVuY2UnKVxuICAgICAgcmV0dXJuIGdhcChjb2RlKVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gZ2FwKGNvZGUpIHtcbiAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH0gLy8gQ2xvc2luZyBmZW5jZT9cbiAgICAgIC8vIENvdWxkIGFsc28gYmUgZGF0YS5cblxuICAgICAgaWYgKGNvZGUgPT09IDM2KSB7XG4gICAgICAgIHRva2VuID0gZWZmZWN0cy5lbnRlcignbWF0aFRleHRTZXF1ZW5jZScpXG4gICAgICAgIHNpemUgPSAwXG4gICAgICAgIHJldHVybiBjbG9zaW5nU2VxdWVuY2UoY29kZSlcbiAgICAgIH0gLy8gVGFicyBkb25cdTIwMTl0IHdvcmssIGFuZCB2aXJ0dWFsIHNwYWNlcyBkb25cdTIwMTl0IG1ha2Ugc2Vuc2UuXG5cbiAgICAgIGlmIChjb2RlID09PSAzMikge1xuICAgICAgICBlZmZlY3RzLmVudGVyKCdzcGFjZScpXG4gICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgICBlZmZlY3RzLmV4aXQoJ3NwYWNlJylcbiAgICAgICAgcmV0dXJuIGdhcFxuICAgICAgfVxuXG4gICAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgZWZmZWN0cy5leGl0KCdsaW5lRW5kaW5nJylcbiAgICAgICAgcmV0dXJuIGdhcFxuICAgICAgfSAvLyBEYXRhLlxuXG4gICAgICBlZmZlY3RzLmVudGVyKCdtYXRoVGV4dERhdGEnKVxuICAgICAgcmV0dXJuIGRhdGEoY29kZSlcbiAgICB9IC8vIEluIG1hdGguXG5cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gZGF0YShjb2RlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNvZGUgPT09IG51bGwgfHxcbiAgICAgICAgY29kZSA9PT0gMzIgfHxcbiAgICAgICAgY29kZSA9PT0gMzYgfHxcbiAgICAgICAgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpXG4gICAgICApIHtcbiAgICAgICAgZWZmZWN0cy5leGl0KCdtYXRoVGV4dERhdGEnKVxuICAgICAgICByZXR1cm4gZ2FwKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IC8vIENsb3NpbmcgZmVuY2UuXG5cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gY2xvc2luZ1NlcXVlbmNlKGNvZGUpIHtcbiAgICAgIC8vIE1vcmUuXG4gICAgICBpZiAoY29kZSA9PT0gMzYpIHtcbiAgICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICAgIHNpemUrK1xuICAgICAgICByZXR1cm4gY2xvc2luZ1NlcXVlbmNlXG4gICAgICB9IC8vIERvbmUhXG5cbiAgICAgIGlmIChzaXplID09PSBzaXplT3Blbikge1xuICAgICAgICBlZmZlY3RzLmV4aXQoJ21hdGhUZXh0U2VxdWVuY2UnKVxuICAgICAgICBlZmZlY3RzLmV4aXQoJ21hdGhUZXh0JylcbiAgICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgICB9IC8vIE1vcmUgb3IgbGVzcyBhY2NlbnRzOiBtYXJrIGFzIGRhdGEuXG5cbiAgICAgIHRva2VuLnR5cGUgPSAnbWF0aFRleHREYXRhJ1xuICAgICAgcmV0dXJuIGRhdGEoY29kZSlcbiAgICB9XG4gIH1cbn1cbi8qKiBAdHlwZSB7UmVzb2x2ZXJ9ICovXG5cbmZ1bmN0aW9uIHJlc29sdmVNYXRoVGV4dChldmVudHMpIHtcbiAgbGV0IHRhaWxFeGl0SW5kZXggPSBldmVudHMubGVuZ3RoIC0gNFxuICBsZXQgaGVhZEVudGVySW5kZXggPSAzXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXG4gIGxldCBpbmRleFxuICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGVudGVyIC8vIElmIHdlIHN0YXJ0IGFuZCBlbmQgd2l0aCBhbiBFT0wgb3IgYSBzcGFjZS5cblxuICBpZiAoXG4gICAgKGV2ZW50c1toZWFkRW50ZXJJbmRleF1bMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmcnIHx8XG4gICAgICBldmVudHNbaGVhZEVudGVySW5kZXhdWzFdLnR5cGUgPT09ICdzcGFjZScpICYmXG4gICAgKGV2ZW50c1t0YWlsRXhpdEluZGV4XVsxXS50eXBlID09PSAnbGluZUVuZGluZycgfHxcbiAgICAgIGV2ZW50c1t0YWlsRXhpdEluZGV4XVsxXS50eXBlID09PSAnc3BhY2UnKVxuICApIHtcbiAgICBpbmRleCA9IGhlYWRFbnRlckluZGV4IC8vIEFuZCB3ZSBoYXZlIGRhdGEuXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IHRhaWxFeGl0SW5kZXgpIHtcbiAgICAgIGlmIChldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdtYXRoVGV4dERhdGEnKSB7XG4gICAgICAgIC8vIFRoZW4gd2UgaGF2ZSBwYWRkaW5nLlxuICAgICAgICBldmVudHNbdGFpbEV4aXRJbmRleF1bMV0udHlwZSA9ICdtYXRoVGV4dFBhZGRpbmcnXG4gICAgICAgIGV2ZW50c1toZWFkRW50ZXJJbmRleF1bMV0udHlwZSA9ICdtYXRoVGV4dFBhZGRpbmcnXG4gICAgICAgIGhlYWRFbnRlckluZGV4ICs9IDJcbiAgICAgICAgdGFpbEV4aXRJbmRleCAtPSAyXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9IC8vIE1lcmdlIGFkamFjZW50IHNwYWNlcyBhbmQgZGF0YS5cblxuICBpbmRleCA9IGhlYWRFbnRlckluZGV4IC0gMVxuICB0YWlsRXhpdEluZGV4KytcblxuICB3aGlsZSAoKytpbmRleCA8PSB0YWlsRXhpdEluZGV4KSB7XG4gICAgaWYgKGVudGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbmRleCAhPT0gdGFpbEV4aXRJbmRleCAmJiBldmVudHNbaW5kZXhdWzFdLnR5cGUgIT09ICdsaW5lRW5kaW5nJykge1xuICAgICAgICBlbnRlciA9IGluZGV4XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGluZGV4ID09PSB0YWlsRXhpdEluZGV4IHx8XG4gICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdsaW5lRW5kaW5nJ1xuICAgICkge1xuICAgICAgZXZlbnRzW2VudGVyXVsxXS50eXBlID0gJ21hdGhUZXh0RGF0YSdcblxuICAgICAgaWYgKGluZGV4ICE9PSBlbnRlciArIDIpIHtcbiAgICAgICAgZXZlbnRzW2VudGVyXVsxXS5lbmQgPSBldmVudHNbaW5kZXggLSAxXVsxXS5lbmRcbiAgICAgICAgZXZlbnRzLnNwbGljZShlbnRlciArIDIsIGluZGV4IC0gZW50ZXIgLSAyKVxuICAgICAgICB0YWlsRXhpdEluZGV4IC09IGluZGV4IC0gZW50ZXIgLSAyXG4gICAgICAgIGluZGV4ID0gZW50ZXIgKyAyXG4gICAgICB9XG5cbiAgICAgIGVudGVyID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuLyoqIEB0eXBlIHtQcmV2aW91c30gKi9cblxuZnVuY3Rpb24gcHJldmlvdXMoY29kZSkge1xuICAvLyBJZiB0aGVyZSBpcyBhIHByZXZpb3VzIGNvZGUsIHRoZXJlIHdpbGwgYWx3YXlzIGJlIGEgdGFpbC5cbiAgcmV0dXJuIChcbiAgICBjb2RlICE9PSAzNiB8fFxuICAgIHRoaXMuZXZlbnRzW3RoaXMuZXZlbnRzLmxlbmd0aCAtIDFdWzFdLnR5cGUgPT09ICdjaGFyYWN0ZXJFc2NhcGUnXG4gIClcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXh0ZW5zaW9ufSBFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbWF0aC10ZXh0JykuT3B0aW9uc30gT3B0aW9uc1xuICovXG5pbXBvcnQge21hdGhGbG93fSBmcm9tICcuL21hdGgtZmxvdy5qcydcbmltcG9ydCB7bWF0aFRleHR9IGZyb20gJy4vbWF0aC10ZXh0LmpzJ1xuLyoqXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge0V4dGVuc2lvbn1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF0aChvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgZmxvdzoge1xuICAgICAgWzM2XTogbWF0aEZsb3dcbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIFszNl06IG1hdGhUZXh0KG9wdGlvbnMpXG4gICAgfVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBvaW50fSBQb2ludFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5UcmFja0ZpZWxkc30gVHJhY2tGaWVsZHNcbiAqL1xuXG4vKipcbiAqIEZ1bmN0aW9ucyB0byB0cmFjayBvdXRwdXQgcG9zaXRpb25zLlxuICogVGhpcyBpbmZvIGlzblx1MjAxOXQgdXNlZCB5ZXQgYnV0IHN1Y2hzIGZ1bmN0aW9uYWxpdHkgYWxsb3dzIGxpbmUgd3JhcHBpbmcsXG4gKiBhbmQgdGhlb3JldGljYWxseSBzb3VyY2UgbWFwcyAodGhvdWdoLCBpcyB0aGVyZSBwcmFjdGljYWwgdXNlIGluIHRoYXQ/KS5cbiAqXG4gKiBAcGFyYW0ge1RyYWNrRmllbGRzfSBvcHRpb25zX1xuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhY2sob3B0aW9uc18pIHtcbiAgLy8gRGVmYXVsdHMgYXJlIHVzZWQgdG8gcHJldmVudCBjcmFzaGVzIHdoZW4gb2xkZXIgdXRpbGl0aWVzIHNvbWVob3cgYWN0aXZhdGVcbiAgLy8gdGhpcyBjb2RlLlxuICAvKiBjOCBpZ25vcmUgbmV4dCA1ICovXG4gIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25zXyB8fCB7fVxuICBjb25zdCBub3cgPSBvcHRpb25zLm5vdyB8fCB7fVxuICBsZXQgbGluZVNoaWZ0ID0gb3B0aW9ucy5saW5lU2hpZnQgfHwgMFxuICBsZXQgbGluZSA9IG5vdy5saW5lIHx8IDFcbiAgbGV0IGNvbHVtbiA9IG5vdy5jb2x1bW4gfHwgMVxuXG4gIHJldHVybiB7bW92ZSwgY3VycmVudCwgc2hpZnR9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB0cmFja2VkIGluZm8uXG4gICAqXG4gICAqIEByZXR1cm5zIHt7bm93OiBQb2ludCwgbGluZVNoaWZ0OiBudW1iZXJ9fVxuICAgKi9cbiAgZnVuY3Rpb24gY3VycmVudCgpIHtcbiAgICByZXR1cm4ge25vdzoge2xpbmUsIGNvbHVtbn0sIGxpbmVTaGlmdH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYW4gaW5jcmVhc2VkIGxpbmUgc2hpZnQgKHRoZSB0eXBpY2FsIGluZGVudCBmb3IgbGluZXMpLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIHNoaWZ0KHZhbHVlKSB7XG4gICAgbGluZVNoaWZ0ICs9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogTW92ZSBwYXN0IGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIG1vdmUodmFsdWUgPSAnJykge1xuICAgIGNvbnN0IGNodW5rcyA9IHZhbHVlLnNwbGl0KC9cXHI/XFxufFxcci9nKVxuICAgIGNvbnN0IHRhaWwgPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdXG4gICAgbGluZSArPSBjaHVua3MubGVuZ3RoIC0gMVxuICAgIGNvbHVtbiA9XG4gICAgICBjaHVua3MubGVuZ3RoID09PSAxID8gY29sdW1uICsgdGFpbC5sZW5ndGggOiAxICsgdGFpbC5sZW5ndGggKyBsaW5lU2hpZnRcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuRXh0ZW5zaW9ufSBGcm9tTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkhhbmRsZX0gRnJvbU1hcmtkb3duSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuT3B0aW9uc30gVG9NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkhhbmRsZX0gVG9NYXJrZG93bkhhbmRsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9jb21wbGV4LXR5cGVzJykuTWF0aH0gTWF0aFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9jb21wbGV4LXR5cGVzJykuSW5saW5lTWF0aH0gSW5saW5lTWF0aFxuICpcbiAqIEB0eXBlZGVmIFRvT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbc2luZ2xlRG9sbGFyVGV4dE1hdGg9dHJ1ZV1cbiAqICAgV2hldGhlciB0byBzdXBwb3J0IG1hdGggKHRleHQpIHdpdGggYSBzaW5nbGUgZG9sbGFyIChgYm9vbGVhbmAsIGRlZmF1bHQ6XG4gKiAgIGB0cnVlYCkuXG4gKiAgIFNpbmdsZSBkb2xsYXJzIHdvcmsgaW4gUGFuZG9jIGFuZCBtYW55IG90aGVyIHBsYWNlcywgYnV0IG9mdGVuIGludGVyZmVyZVxuICogICB3aXRoIFx1MjAxQ25vcm1hbFx1MjAxRCBkb2xsYXJzIGluIHRleHQuXG4gKi9cblxuaW1wb3J0IHtsb25nZXN0U3RyZWFrfSBmcm9tICdsb25nZXN0LXN0cmVhaydcbmltcG9ydCB7c2FmZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9zYWZlLmpzJ1xuaW1wb3J0IHt0cmFja30gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC90cmFjay5qcydcblxuLyoqXG4gKiBAcmV0dXJucyB7RnJvbU1hcmtkb3duRXh0ZW5zaW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0aEZyb21NYXJrZG93bigpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlcjoge1xuICAgICAgbWF0aEZsb3c6IGVudGVyTWF0aEZsb3csXG4gICAgICBtYXRoRmxvd0ZlbmNlTWV0YTogZW50ZXJNYXRoRmxvd01ldGEsXG4gICAgICBtYXRoVGV4dDogZW50ZXJNYXRoVGV4dFxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgbWF0aEZsb3c6IGV4aXRNYXRoRmxvdyxcbiAgICAgIG1hdGhGbG93RmVuY2U6IGV4aXRNYXRoRmxvd0ZlbmNlLFxuICAgICAgbWF0aEZsb3dGZW5jZU1ldGE6IGV4aXRNYXRoRmxvd01ldGEsXG4gICAgICBtYXRoRmxvd1ZhbHVlOiBleGl0TWF0aERhdGEsXG4gICAgICBtYXRoVGV4dDogZXhpdE1hdGhUZXh0LFxuICAgICAgbWF0aFRleHREYXRhOiBleGl0TWF0aERhdGFcbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbiAgZnVuY3Rpb24gZW50ZXJNYXRoRmxvdyh0b2tlbikge1xuICAgIHRoaXMuZW50ZXIoXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdtYXRoJyxcbiAgICAgICAgbWV0YTogbnVsbCxcbiAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaE5hbWU6ICdkaXYnLFxuICAgICAgICAgIGhQcm9wZXJ0aWVzOiB7Y2xhc3NOYW1lOiBbJ21hdGgnLCAnbWF0aC1kaXNwbGF5J119LFxuICAgICAgICAgIGhDaGlsZHJlbjogW3t0eXBlOiAndGV4dCcsIHZhbHVlOiAnJ31dXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblxuICAgIClcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBlbnRlck1hdGhGbG93TWV0YSgpIHtcbiAgICB0aGlzLmJ1ZmZlcigpXG4gIH1cblxuICAvKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbiAgZnVuY3Rpb24gZXhpdE1hdGhGbG93TWV0YSgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSAvKiogQHR5cGUge01hdGh9ICovICh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0pXG4gICAgbm9kZS5tZXRhID0gZGF0YVxuICB9XG5cbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGV4aXRNYXRoRmxvd0ZlbmNlKCkge1xuICAgIC8vIEV4aXQgaWYgdGhpcyBpcyB0aGUgY2xvc2luZyBmZW5jZS5cbiAgICBpZiAodGhpcy5nZXREYXRhKCdtYXRoRmxvd0luc2lkZScpKSByZXR1cm5cbiAgICB0aGlzLmJ1ZmZlcigpXG4gICAgdGhpcy5zZXREYXRhKCdtYXRoRmxvd0luc2lkZScsIHRydWUpXG4gIH1cblxuICAvKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbiAgZnVuY3Rpb24gZXhpdE1hdGhGbG93KHRva2VuKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKCkucmVwbGFjZSgvXihcXHI/XFxufFxccil8KFxccj9cXG58XFxyKSQvZywgJycpXG4gICAgY29uc3Qgbm9kZSA9IC8qKiBAdHlwZSB7TWF0aH0gKi8gKHRoaXMuZXhpdCh0b2tlbikpXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBkZWZpbmVkIGl0LlxuICAgIG5vZGUuZGF0YS5oQ2hpbGRyZW5bMF0udmFsdWUgPSBkYXRhXG4gICAgdGhpcy5zZXREYXRhKCdtYXRoRmxvd0luc2lkZScpXG4gIH1cblxuICAvKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbiAgZnVuY3Rpb24gZW50ZXJNYXRoVGV4dCh0b2tlbikge1xuICAgIHRoaXMuZW50ZXIoXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdpbmxpbmVNYXRoJyxcbiAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaE5hbWU6ICdzcGFuJyxcbiAgICAgICAgICBoUHJvcGVydGllczoge2NsYXNzTmFtZTogWydtYXRoJywgJ21hdGgtaW5saW5lJ119LFxuICAgICAgICAgIGhDaGlsZHJlbjogW3t0eXBlOiAndGV4dCcsIHZhbHVlOiAnJ31dXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblxuICAgIClcbiAgICB0aGlzLmJ1ZmZlcigpXG4gIH1cblxuICAvKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbiAgZnVuY3Rpb24gZXhpdE1hdGhUZXh0KHRva2VuKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtNYXRofSAqLyAodGhpcy5leGl0KHRva2VuKSlcbiAgICBub2RlLnZhbHVlID0gZGF0YVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlIGRlZmluZWQgaXQuXG4gICAgbm9kZS5kYXRhLmhDaGlsZHJlblswXS52YWx1ZSA9IGRhdGFcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBleGl0TWF0aERhdGEodG9rZW4pIHtcbiAgICB0aGlzLmNvbmZpZy5lbnRlci5kYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gICAgdGhpcy5jb25maWcuZXhpdC5kYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RvT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7VG9NYXJrZG93bkV4dGVuc2lvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGhUb01hcmtkb3duKG9wdGlvbnMgPSB7fSkge1xuICBsZXQgc2luZ2xlID0gb3B0aW9ucy5zaW5nbGVEb2xsYXJUZXh0TWF0aFxuXG4gIGlmIChzaW5nbGUgPT09IG51bGwgfHwgc2luZ2xlID09PSB1bmRlZmluZWQpIHtcbiAgICBzaW5nbGUgPSB0cnVlXG4gIH1cblxuICBpbmxpbmVNYXRoLnBlZWsgPSBpbmxpbmVNYXRoUGVla1xuXG4gIHJldHVybiB7XG4gICAgdW5zYWZlOiBbXG4gICAgICB7Y2hhcmFjdGVyOiAnXFxyJywgaW5Db25zdHJ1Y3Q6IFsnbWF0aEZsb3dNZXRhJ119LFxuICAgICAge2NoYXJhY3RlcjogJ1xccicsIGluQ29uc3RydWN0OiBbJ21hdGhGbG93TWV0YSddfSxcbiAgICAgIHNpbmdsZVxuICAgICAgICA/IHtjaGFyYWN0ZXI6ICckJywgaW5Db25zdHJ1Y3Q6IFsnbWF0aEZsb3dNZXRhJywgJ3BocmFzaW5nJ119XG4gICAgICAgIDoge1xuICAgICAgICAgICAgY2hhcmFjdGVyOiAnJCcsXG4gICAgICAgICAgICBhZnRlcjogJ1xcXFwkJyxcbiAgICAgICAgICAgIGluQ29uc3RydWN0OiBbJ21hdGhGbG93TWV0YScsICdwaHJhc2luZyddXG4gICAgICAgICAgfSxcbiAgICAgIHthdEJyZWFrOiB0cnVlLCBjaGFyYWN0ZXI6ICckJywgYWZ0ZXI6ICdcXFxcJCd9XG4gICAgXSxcbiAgICBoYW5kbGVyczoge21hdGgsIGlubGluZU1hdGh9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gICAqIEBwYXJhbSB7TWF0aH0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gbWF0aChub2RlLCBfLCBjb250ZXh0LCBzYWZlT3B0aW9ucykge1xuICAgIGNvbnN0IHJhdyA9IG5vZGUudmFsdWUgfHwgJydcbiAgICBjb25zdCBzZXF1ZW5jZSA9ICckJy5yZXBlYXQoTWF0aC5tYXgobG9uZ2VzdFN0cmVhayhyYXcsICckJykgKyAxLCAyKSlcbiAgICBjb25zdCBleGl0ID0gY29udGV4dC5lbnRlcignbWF0aEZsb3cnKVxuICAgIGNvbnN0IHRyYWNrZXIgPSB0cmFjayhzYWZlT3B0aW9ucylcbiAgICBsZXQgdmFsdWUgPSB0cmFja2VyLm1vdmUoc2VxdWVuY2UpXG5cbiAgICBpZiAobm9kZS5tZXRhKSB7XG4gICAgICBjb25zdCBzdWJleGl0ID0gY29udGV4dC5lbnRlcignbWF0aEZsb3dNZXRhJylcbiAgICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgICAgc2FmZShjb250ZXh0LCBub2RlLm1ldGEsIHtcbiAgICAgICAgICAuLi50cmFja2VyLmN1cnJlbnQoKSxcbiAgICAgICAgICBiZWZvcmU6IHZhbHVlLFxuICAgICAgICAgIGFmdGVyOiAnICcsXG4gICAgICAgICAgZW5jb2RlOiBbJyQnXVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgc3ViZXhpdCgpXG4gICAgfVxuXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCdcXG4nKVxuXG4gICAgaWYgKHJhdykge1xuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKHJhdyArICdcXG4nKVxuICAgIH1cblxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShzZXF1ZW5jZSlcbiAgICBleGl0KClcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtJbmxpbmVNYXRofSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBpbmxpbmVNYXRoKG5vZGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG5vZGUudmFsdWUgfHwgJydcbiAgICBsZXQgc2l6ZSA9IDFcbiAgICBsZXQgcGFkID0gJydcblxuICAgIGlmICghc2luZ2xlKSBzaXplKytcblxuICAgIC8vIElmIHRoZXJlIGlzIGEgc2luZ2xlIGRvbGxhciBzaWduIG9uIGl0cyBvd24gaW4gdGhlIG1hdGgsIHVzZSBhIGZlbmNlIG9mXG4gICAgLy8gdHdvLlxuICAgIC8vIElmIHRoZXJlIGFyZSB0d28gaW4gYSByb3csIHVzZSBvbmUuXG4gICAgd2hpbGUgKFxuICAgICAgbmV3IFJlZ0V4cCgnKF58W14kXSknICsgJ1xcXFwkJy5yZXBlYXQoc2l6ZSkgKyAnKFteJF18JCknKS50ZXN0KHZhbHVlKVxuICAgICkge1xuICAgICAgc2l6ZSsrXG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBpcyBub3QganVzdCBzcGFjZXMgb3IgZW9scyAodGFicyBkb25cdTIwMTl0IGNvdW50KSwgYW5kIGVpdGhlciB0aGUgZmlyc3RcbiAgICAvLyBvciBsYXN0IGNoYXJhY3RlciBhcmUgYSBzcGFjZSwgZW9sLCBvciBkb2xsYXIgc2lnbiwgdGhlbiBwYWQgd2l0aCBzcGFjZXMuXG4gICAgaWYgKFxuICAgICAgL1teIFxcclxcbl0vLnRlc3QodmFsdWUpICYmXG4gICAgICAoL1sgXFxyXFxuJF0vLnRlc3QodmFsdWUuY2hhckF0KDApKSB8fFxuICAgICAgICAvWyBcXHJcXG4kXS8udGVzdCh2YWx1ZS5jaGFyQXQodmFsdWUubGVuZ3RoIC0gMSkpKVxuICAgICkge1xuICAgICAgcGFkID0gJyAnXG4gICAgfVxuXG4gICAgY29uc3Qgc2VxdWVuY2UgPSAnJCcucmVwZWF0KHNpemUpXG4gICAgcmV0dXJuIHNlcXVlbmNlICsgcGFkICsgdmFsdWUgKyBwYWQgKyBzZXF1ZW5jZVxuICB9XG5cbiAgLyoqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBpbmxpbmVNYXRoUGVlaygpIHtcbiAgICByZXR1cm4gJyQnXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXh0ZW5zaW9ufSBFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0UmVjb3JkfSBDb25zdHJ1Y3RSZWNvcmRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUHJldmlvdXN9IFByZXZpb3VzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FdmVudH0gRXZlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29kZX0gQ29kZVxuICovXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge1xuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICBtYXJrZG93bkxpbmVFbmRpbmdcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuY29uc3QgdGFza2xpc3RDaGVjayA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplVGFza2xpc3RDaGVja1xufVxuZXhwb3J0IGNvbnN0IGdmbVRhc2tMaXN0SXRlbSA9IHtcbiAgdGV4dDoge1xuICAgIFs5MV06IHRhc2tsaXN0Q2hlY2tcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplVGFza2xpc3RDaGVjayhlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHJldHVybiBvcGVuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gb3Blbihjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgLy8gRXhpdCBpZiB0aGVyZVx1MjAxOXMgc3R1ZmYgYmVmb3JlLlxuICAgICAgc2VsZi5wcmV2aW91cyAhPT0gbnVsbCB8fCAvLyBFeGl0IGlmIG5vdCBpbiB0aGUgZmlyc3QgY29udGVudCB0aGF0IGlzIHRoZSBmaXJzdCBjaGlsZCBvZiBhIGxpc3RcbiAgICAgIC8vIGl0ZW0uXG4gICAgICAhc2VsZi5fZ2ZtVGFza2xpc3RGaXJzdENvbnRlbnRPZkxpc3RJdGVtXG4gICAgKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcigndGFza0xpc3RDaGVjaycpXG4gICAgZWZmZWN0cy5lbnRlcigndGFza0xpc3RDaGVja01hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCd0YXNrTGlzdENoZWNrTWFya2VyJylcbiAgICByZXR1cm4gaW5zaWRlXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBpbnNpZGUoY29kZSkge1xuICAgIC8vIFRvIG1hdGNoIGhvdyBHSCB3b3JrcyBpbiBjb21tZW50cywgdXNlIGBtYXJrZG93blNwYWNlYCAoYFsgXFx0XWApIGluc3RlYWRcbiAgICAvLyBvZiBgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZWAgKGBbIFxcdFxcclxcbl1gKS5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFza0xpc3RDaGVja1ZhbHVlVW5jaGVja2VkJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YXNrTGlzdENoZWNrVmFsdWVVbmNoZWNrZWQnKVxuICAgICAgcmV0dXJuIGNsb3NlXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDg4IHx8IGNvZGUgPT09IDEyMCkge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFza0xpc3RDaGVja1ZhbHVlQ2hlY2tlZCcpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFza0xpc3RDaGVja1ZhbHVlQ2hlY2tlZCcpXG4gICAgICByZXR1cm4gY2xvc2VcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjbG9zZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDkzKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YXNrTGlzdENoZWNrTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YXNrTGlzdENoZWNrTWFya2VyJylcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFza0xpc3RDaGVjaycpXG4gICAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgICAge1xuICAgICAgICAgIHRva2VuaXplOiBzcGFjZVRoZW5Ob25TcGFjZVxuICAgICAgICB9LFxuICAgICAgICBvayxcbiAgICAgICAgbm9rXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gc3BhY2VUaGVuTm9uU3BhY2UoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGFmdGVyLCAnd2hpdGVzcGFjZScpXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgIGNvbnN0IHRhaWwgPSBzZWxmLmV2ZW50c1tzZWxmLmV2ZW50cy5sZW5ndGggLSAxXVxuICAgIHJldHVybiAoXG4gICAgICAvLyBXZSBlaXRoZXIgZm91bmQgc3BhY2VzXHUyMDI2XG4gICAgICAoKHRhaWwgJiYgdGFpbFsxXS50eXBlID09PSAnd2hpdGVzcGFjZScpIHx8IC8vIFx1MjAyNm9yIGl0IHdhcyBmb2xsb3dlZCBieSBhIGxpbmUgZW5kaW5nLCBpbiB3aGljaCBjYXNlLCB0aGVyZSBoYXMgdG8gYmVcbiAgICAgICAgLy8gbm9uLXdoaXRlc3BhY2UgYWZ0ZXIgdGhhdCBsaW5lIGVuZGluZywgYmVjYXVzZSBvdGhlcndpc2Ugd2VcdTIwMTlkIGdldCBhblxuICAgICAgICAvLyBFT0YgYXMgdGhlIGNvbnRlbnQgaXMgY2xvc2VkIHdpdGggYmxhbmsgbGluZXMuXG4gICAgICAgIG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkgJiZcbiAgICAgICAgY29kZSAhPT0gbnVsbFxuICAgICAgICA/IG9rKGNvZGUpXG4gICAgICAgIDogbm9rKGNvZGUpXG4gICAgKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7RXh0cmFjdDxpbXBvcnQoJ21kYXN0JykuUm9vdHxpbXBvcnQoJ21kYXN0JykuQ29udGVudCwgaW1wb3J0KCd1bmlzdCcpLlBhcmVudD59IFBhcmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaXN0SXRlbX0gTGlzdEl0ZW1cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUGFyYWdyYXBofSBQYXJhZ3JhcGhcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQmxvY2tDb250ZW50fSBCbG9ja0NvbnRlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkV4dGVuc2lvbn0gRnJvbU1hcmtkb3duRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5IYW5kbGV9IEZyb21NYXJrZG93bkhhbmRsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLk9wdGlvbnN9IFRvTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5IYW5kbGV9IFRvTWFya2Rvd25IYW5kbGVcbiAqL1xuXG5pbXBvcnQge2xpc3RJdGVtfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvbGlzdC1pdGVtLmpzJ1xuaW1wb3J0IHt0cmFja30gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC90cmFjay5qcydcblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25FeHRlbnNpb259ICovXG5leHBvcnQgY29uc3QgZ2ZtVGFza0xpc3RJdGVtRnJvbU1hcmtkb3duID0ge1xuICBleGl0OiB7XG4gICAgdGFza0xpc3RDaGVja1ZhbHVlQ2hlY2tlZDogZXhpdENoZWNrLFxuICAgIHRhc2tMaXN0Q2hlY2tWYWx1ZVVuY2hlY2tlZDogZXhpdENoZWNrLFxuICAgIHBhcmFncmFwaDogZXhpdFBhcmFncmFwaFdpdGhUYXNrTGlzdEl0ZW1cbiAgfVxufVxuXG4vKiogQHR5cGUge1RvTWFya2Rvd25FeHRlbnNpb259ICovXG5leHBvcnQgY29uc3QgZ2ZtVGFza0xpc3RJdGVtVG9NYXJrZG93biA9IHtcbiAgdW5zYWZlOiBbe2F0QnJlYWs6IHRydWUsIGNoYXJhY3RlcjogJy0nLCBhZnRlcjogJ1s6fC1dJ31dLFxuICBoYW5kbGVyczoge2xpc3RJdGVtOiBsaXN0SXRlbVdpdGhUYXNrTGlzdEl0ZW19XG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZXhpdENoZWNrKHRva2VuKSB7XG4gIGNvbnN0IG5vZGUgPSAvKiogQHR5cGUge0xpc3RJdGVtfSAqLyAodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdKVxuICAvLyBXZVx1MjAxOXJlIGFsd2F5cyBpbiBhIHBhcmFncmFwaCwgaW4gYSBsaXN0IGl0ZW0uXG4gIG5vZGUuY2hlY2tlZCA9IHRva2VuLnR5cGUgPT09ICd0YXNrTGlzdENoZWNrVmFsdWVDaGVja2VkJ1xufVxuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbmZ1bmN0aW9uIGV4aXRQYXJhZ3JhcGhXaXRoVGFza0xpc3RJdGVtKHRva2VuKSB7XG4gIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7UGFyZW50fSAqLyAodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdKVxuICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtQYXJhZ3JhcGh9ICovICh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0pXG4gIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuXG4gIGNvbnN0IGhlYWQgPSBub2RlLmNoaWxkcmVuWzBdXG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7UGFyYWdyYXBofHVuZGVmaW5lZH0gKi9cbiAgbGV0IGZpcnN0UGFyYWdocmFwaFxuXG4gIGlmIChcbiAgICBwYXJlbnQgJiZcbiAgICBwYXJlbnQudHlwZSA9PT0gJ2xpc3RJdGVtJyAmJlxuICAgIHR5cGVvZiBwYXJlbnQuY2hlY2tlZCA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgaGVhZCAmJlxuICAgIGhlYWQudHlwZSA9PT0gJ3RleHQnXG4gICkge1xuICAgIHdoaWxlICgrK2luZGV4IDwgc2libGluZ3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaW5kZXhdXG4gICAgICBpZiAoc2libGluZy50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICBmaXJzdFBhcmFnaHJhcGggPSBzaWJsaW5nXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0UGFyYWdocmFwaCA9PT0gbm9kZSkge1xuICAgICAgLy8gTXVzdCBzdGFydCB3aXRoIGEgc3BhY2Ugb3IgYSB0YWIuXG4gICAgICBoZWFkLnZhbHVlID0gaGVhZC52YWx1ZS5zbGljZSgxKVxuXG4gICAgICBpZiAoaGVhZC52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zaGlmdCgpXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBub2RlLnBvc2l0aW9uICYmXG4gICAgICAgIGhlYWQucG9zaXRpb24gJiZcbiAgICAgICAgdHlwZW9mIGhlYWQucG9zaXRpb24uc3RhcnQub2Zmc2V0ID09PSAnbnVtYmVyJ1xuICAgICAgKSB7XG4gICAgICAgIGhlYWQucG9zaXRpb24uc3RhcnQuY29sdW1uKytcbiAgICAgICAgaGVhZC5wb3NpdGlvbi5zdGFydC5vZmZzZXQrK1xuICAgICAgICBub2RlLnBvc2l0aW9uLnN0YXJ0ID0gT2JqZWN0LmFzc2lnbih7fSwgaGVhZC5wb3NpdGlvbi5zdGFydClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmV4aXQodG9rZW4pXG59XG5cbi8qKlxuICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gKiBAcGFyYW0ge0xpc3RJdGVtfSBub2RlXG4gKi9cbmZ1bmN0aW9uIGxpc3RJdGVtV2l0aFRhc2tMaXN0SXRlbShub2RlLCBwYXJlbnQsIGNvbnRleHQsIHNhZmVPcHRpb25zKSB7XG4gIGNvbnN0IGhlYWQgPSBub2RlLmNoaWxkcmVuWzBdXG4gIGNvbnN0IGNoZWNrYWJsZSA9XG4gICAgdHlwZW9mIG5vZGUuY2hlY2tlZCA9PT0gJ2Jvb2xlYW4nICYmIGhlYWQgJiYgaGVhZC50eXBlID09PSAncGFyYWdyYXBoJ1xuICBjb25zdCBjaGVja2JveCA9ICdbJyArIChub2RlLmNoZWNrZWQgPyAneCcgOiAnICcpICsgJ10gJ1xuICBjb25zdCB0cmFja2VyID0gdHJhY2soc2FmZU9wdGlvbnMpXG5cbiAgaWYgKGNoZWNrYWJsZSkge1xuICAgIHRyYWNrZXIubW92ZShjaGVja2JveClcbiAgfVxuXG4gIGxldCB2YWx1ZSA9IGxpc3RJdGVtKG5vZGUsIHBhcmVudCwgY29udGV4dCwge1xuICAgIC4uLnNhZmVPcHRpb25zLFxuICAgIC4uLnRyYWNrZXIuY3VycmVudCgpXG4gIH0pXG5cbiAgaWYgKGNoZWNrYWJsZSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXig/OlsqKy1dfFxcZCtcXC4pKFtcXHJcXG5dfCB7MSwzfSkvLCBjaGVjaylcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gJDBcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIGNoZWNrKCQwKSB7XG4gICAgcmV0dXJuICQwICsgY2hlY2tib3hcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeHRlbnNpb259IEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydsZWZ0J3wnY2VudGVyJ3wncmlnaHQnfCdub25lJ30gQWxpZ25cbiAqL1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHtcbiAgbWFya2Rvd25MaW5lRW5kaW5nLFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICBtYXJrZG93blNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcblxuLyoqIEB0eXBlIHtFeHRlbnNpb259ICovXG5leHBvcnQgY29uc3QgZ2ZtVGFibGUgPSB7XG4gIGZsb3c6IHtcbiAgICBudWxsOiB7XG4gICAgICB0b2tlbml6ZTogdG9rZW5pemVUYWJsZSxcbiAgICAgIHJlc29sdmU6IHJlc29sdmVUYWJsZVxuICAgIH1cbiAgfVxufVxuY29uc3QgbmV4dFByZWZpeGVkT3JCbGFuayA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplTmV4dFByZWZpeGVkT3JCbGFuayxcbiAgcGFydGlhbDogdHJ1ZVxufVxuLyoqIEB0eXBlIHtSZXNvbHZlcn0gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRhYmxlKGV2ZW50cywgY29udGV4dCkge1xuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBpbkhlYWRcbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgaW5EZWxpbWl0ZXJSb3dcbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgaW5Sb3dcbiAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBjb250ZW50U3RhcnRcbiAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBjb250ZW50RW5kXG4gIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cblxuICBsZXQgY2VsbFN0YXJ0XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IHNlZW5DZWxsSW5Sb3dcblxuICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICBjb25zdCB0b2tlbiA9IGV2ZW50c1tpbmRleF1bMV1cblxuICAgIGlmIChpblJvdykge1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50Jykge1xuICAgICAgICBjb250ZW50U3RhcnQgPSBjb250ZW50U3RhcnQgfHwgaW5kZXhcbiAgICAgICAgY29udGVudEVuZCA9IGluZGV4XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgLy8gQ29tYmluZSBzZXBhcmF0ZSBjb250ZW50IHBhcnRzIGludG8gb25lLlxuICAgICAgICAodG9rZW4udHlwZSA9PT0gJ3RhYmxlQ2VsbERpdmlkZXInIHx8IHRva2VuLnR5cGUgPT09ICd0YWJsZVJvdycpICYmXG4gICAgICAgIGNvbnRlbnRFbmRcbiAgICAgICkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZUNvbnRlbnQnLFxuICAgICAgICAgIHN0YXJ0OiBldmVudHNbY29udGVudFN0YXJ0XVsxXS5zdGFydCxcbiAgICAgICAgICBlbmQ6IGV2ZW50c1tjb250ZW50RW5kXVsxXS5lbmRcbiAgICAgICAgfVxuICAgICAgICAvKiogQHR5cGUge1Rva2VufSAqL1xuXG4gICAgICAgIGNvbnN0IHRleHQgPSB7XG4gICAgICAgICAgdHlwZTogJ2NodW5rVGV4dCcsXG4gICAgICAgICAgc3RhcnQ6IGNvbnRlbnQuc3RhcnQsXG4gICAgICAgICAgZW5kOiBjb250ZW50LmVuZCxcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEl0XHUyMDE5cyBmaW5lLlxuICAgICAgICAgIGNvbnRlbnRUeXBlOiAndGV4dCdcbiAgICAgICAgfVxuICAgICAgICBldmVudHMuc3BsaWNlKFxuICAgICAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgICAgICBjb250ZW50RW5kIC0gY29udGVudFN0YXJ0ICsgMSxcbiAgICAgICAgICBbJ2VudGVyJywgY29udGVudCwgY29udGV4dF0sXG4gICAgICAgICAgWydlbnRlcicsIHRleHQsIGNvbnRleHRdLFxuICAgICAgICAgIFsnZXhpdCcsIHRleHQsIGNvbnRleHRdLFxuICAgICAgICAgIFsnZXhpdCcsIGNvbnRlbnQsIGNvbnRleHRdXG4gICAgICAgIClcbiAgICAgICAgaW5kZXggLT0gY29udGVudEVuZCAtIGNvbnRlbnRTdGFydCAtIDNcbiAgICAgICAgY29udGVudFN0YXJ0ID0gdW5kZWZpbmVkXG4gICAgICAgIGNvbnRlbnRFbmQgPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBldmVudHNbaW5kZXhdWzBdID09PSAnZXhpdCcgJiZcbiAgICAgIGNlbGxTdGFydCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBjZWxsU3RhcnQgKyAoc2VlbkNlbGxJblJvdyA/IDAgOiAxKSA8IGluZGV4ICYmXG4gICAgICAodG9rZW4udHlwZSA9PT0gJ3RhYmxlQ2VsbERpdmlkZXInIHx8XG4gICAgICAgICh0b2tlbi50eXBlID09PSAndGFibGVSb3cnICYmXG4gICAgICAgICAgKGNlbGxTdGFydCArIDMgPCBpbmRleCB8fFxuICAgICAgICAgICAgZXZlbnRzW2NlbGxTdGFydF1bMV0udHlwZSAhPT0gJ3doaXRlc3BhY2UnKSkpXG4gICAgKSB7XG4gICAgICBjb25zdCBjZWxsID0ge1xuICAgICAgICB0eXBlOiBpbkRlbGltaXRlclJvd1xuICAgICAgICAgID8gJ3RhYmxlRGVsaW1pdGVyJ1xuICAgICAgICAgIDogaW5IZWFkXG4gICAgICAgICAgPyAndGFibGVIZWFkZXInXG4gICAgICAgICAgOiAndGFibGVEYXRhJyxcbiAgICAgICAgc3RhcnQ6IGV2ZW50c1tjZWxsU3RhcnRdWzFdLnN0YXJ0LFxuICAgICAgICBlbmQ6IGV2ZW50c1tpbmRleF1bMV0uZW5kXG4gICAgICB9XG4gICAgICBldmVudHMuc3BsaWNlKGluZGV4ICsgKHRva2VuLnR5cGUgPT09ICd0YWJsZUNlbGxEaXZpZGVyJyA/IDEgOiAwKSwgMCwgW1xuICAgICAgICAnZXhpdCcsXG4gICAgICAgIGNlbGwsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIF0pXG4gICAgICBldmVudHMuc3BsaWNlKGNlbGxTdGFydCwgMCwgWydlbnRlcicsIGNlbGwsIGNvbnRleHRdKVxuICAgICAgaW5kZXggKz0gMlxuICAgICAgY2VsbFN0YXJ0ID0gaW5kZXggKyAxXG4gICAgICBzZWVuQ2VsbEluUm93ID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGFibGVSb3cnKSB7XG4gICAgICBpblJvdyA9IGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcidcblxuICAgICAgaWYgKGluUm93KSB7XG4gICAgICAgIGNlbGxTdGFydCA9IGluZGV4ICsgMVxuICAgICAgICBzZWVuQ2VsbEluUm93ID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyUm93Jykge1xuICAgICAgaW5EZWxpbWl0ZXJSb3cgPSBldmVudHNbaW5kZXhdWzBdID09PSAnZW50ZXInXG5cbiAgICAgIGlmIChpbkRlbGltaXRlclJvdykge1xuICAgICAgICBjZWxsU3RhcnQgPSBpbmRleCArIDFcbiAgICAgICAgc2VlbkNlbGxJblJvdyA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0YWJsZUhlYWQnKSB7XG4gICAgICBpbkhlYWQgPSBldmVudHNbaW5kZXhdWzBdID09PSAnZW50ZXInXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplVGFibGUoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvKiogQHR5cGUge0FycmF5PEFsaWduPn0gKi9cblxuICBjb25zdCBhbGlnbiA9IFtdXG4gIGxldCB0YWJsZUhlYWRlckNvdW50ID0gMFxuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBzZWVuRGVsaW1pdGVyXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGhhc0Rhc2hcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQ3VzdG9tLlxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlJykuX2FsaWduID0gYWxpZ25cbiAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUhlYWQnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlUm93JykgLy8gSWYgd2Ugc3RhcnQgd2l0aCBhIHBpcGUsIHdlIG9wZW4gYSBjZWxsIG1hcmtlci5cblxuICAgIGlmIChjb2RlID09PSAxMjQpIHtcbiAgICAgIHJldHVybiBjZWxsRGl2aWRlckhlYWQoY29kZSlcbiAgICB9XG5cbiAgICB0YWJsZUhlYWRlckNvdW50KytcbiAgICBlZmZlY3RzLmVudGVyKCd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50JykgLy8gQ2FuXHUyMDE5dCBiZSBzcGFjZSBvciBlb2xzIGF0IHRoZSBzdGFydCBvZiBhIGNvbnN0cnVjdCwgc28gd2VcdTIwMTlyZSBpbiBhIGNlbGwuXG5cbiAgICByZXR1cm4gaW5DZWxsQ29udGVudEhlYWQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNlbGxEaXZpZGVySGVhZChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVDZWxsRGl2aWRlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICBzZWVuRGVsaW1pdGVyID0gdHJ1ZVxuICAgIHJldHVybiBjZWxsQnJlYWtIZWFkXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjZWxsQnJlYWtIZWFkKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBhdFJvd0VuZEhlYWQoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignd2hpdGVzcGFjZScpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbldoaXRlc3BhY2VIZWFkXG4gICAgfVxuXG4gICAgaWYgKHNlZW5EZWxpbWl0ZXIpIHtcbiAgICAgIHNlZW5EZWxpbWl0ZXIgPSB1bmRlZmluZWRcbiAgICAgIHRhYmxlSGVhZGVyQ291bnQrK1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAxMjQpIHtcbiAgICAgIHJldHVybiBjZWxsRGl2aWRlckhlYWQoY29kZSlcbiAgICB9IC8vIEFueXRoaW5nIGVsc2UgaXMgY2VsbCBjb250ZW50LlxuXG4gICAgZWZmZWN0cy5lbnRlcigndGVtcG9yYXJ5VGFibGVDZWxsQ29udGVudCcpXG4gICAgcmV0dXJuIGluQ2VsbENvbnRlbnRIZWFkKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBpbldoaXRlc3BhY2VIZWFkKGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5XaGl0ZXNwYWNlSGVhZFxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgnd2hpdGVzcGFjZScpXG4gICAgcmV0dXJuIGNlbGxCcmVha0hlYWQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGluQ2VsbENvbnRlbnRIZWFkKGNvZGUpIHtcbiAgICAvLyBFT0YsIHdoaXRlc3BhY2UsIHBpcGVcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSAxMjQgfHwgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50JylcbiAgICAgIHJldHVybiBjZWxsQnJlYWtIZWFkKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IDkyID8gaW5DZWxsQ29udGVudEVzY2FwZUhlYWQgOiBpbkNlbGxDb250ZW50SGVhZFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5DZWxsQ29udGVudEVzY2FwZUhlYWQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA5MiB8fCBjb2RlID09PSAxMjQpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluQ2VsbENvbnRlbnRIZWFkXG4gICAgfSAvLyBBbnl0aGluZyBlbHNlLlxuXG4gICAgcmV0dXJuIGluQ2VsbENvbnRlbnRIZWFkKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhdFJvd0VuZEhlYWQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZVJvdycpXG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZUhlYWQnKVxuICAgIGNvbnN0IG9yaWdpbmFsSW50ZXJydXB0ID0gc2VsZi5pbnRlcnJ1cHRcbiAgICBzZWxmLmludGVycnVwdCA9IHRydWVcbiAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KFxuICAgICAge1xuICAgICAgICB0b2tlbml6ZTogdG9rZW5pemVSb3dFbmQsXG4gICAgICAgIHBhcnRpYWw6IHRydWVcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBzZWxmLmludGVycnVwdCA9IG9yaWdpbmFsSW50ZXJydXB0XG4gICAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyUm93JylcbiAgICAgICAgcmV0dXJuIGF0RGVsaW1pdGVyUm93QnJlYWsoY29kZSlcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBzZWxmLmludGVycnVwdCA9IG9yaWdpbmFsSW50ZXJydXB0XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cbiAgICApKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhdERlbGltaXRlclJvd0JyZWFrKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiByb3dFbmREZWxpbWl0ZXIoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignd2hpdGVzcGFjZScpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbldoaXRlc3BhY2VEZWxpbWl0ZXJcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNDUpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgaGFzRGFzaCA9IHRydWVcbiAgICAgIGFsaWduLnB1c2goJ25vbmUnKVxuICAgICAgcmV0dXJuIGluRmlsbGVyRGVsaW1pdGVyXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDU4KSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZURlbGltaXRlckFsaWdubWVudCcpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVEZWxpbWl0ZXJBbGlnbm1lbnQnKVxuICAgICAgYWxpZ24ucHVzaCgnbGVmdCcpXG4gICAgICByZXR1cm4gYWZ0ZXJMZWZ0QWxpZ25tZW50XG4gICAgfSAvLyBJZiB3ZSBzdGFydCB3aXRoIGEgcGlwZSwgd2Ugb3BlbiBhIGNlbGwgbWFya2VyLlxuXG4gICAgaWYgKGNvZGUgPT09IDEyNCkge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICByZXR1cm4gYXREZWxpbWl0ZXJSb3dCcmVha1xuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGluV2hpdGVzcGFjZURlbGltaXRlcihjb2RlKSB7XG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluV2hpdGVzcGFjZURlbGltaXRlclxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgnd2hpdGVzcGFjZScpXG4gICAgcmV0dXJuIGF0RGVsaW1pdGVyUm93QnJlYWsoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGluRmlsbGVyRGVsaW1pdGVyKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDUpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluRmlsbGVyRGVsaW1pdGVyXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZURlbGltaXRlckZpbGxlcicpXG5cbiAgICBpZiAoY29kZSA9PT0gNTgpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyQWxpZ25tZW50JylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZURlbGltaXRlckFsaWdubWVudCcpXG4gICAgICBhbGlnblthbGlnbi5sZW5ndGggLSAxXSA9XG4gICAgICAgIGFsaWduW2FsaWduLmxlbmd0aCAtIDFdID09PSAnbGVmdCcgPyAnY2VudGVyJyA6ICdyaWdodCdcbiAgICAgIHJldHVybiBhZnRlclJpZ2h0QWxpZ25tZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0RGVsaW1pdGVyUm93QnJlYWsoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyTGVmdEFsaWdubWVudChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ1KSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZURlbGltaXRlckZpbGxlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGhhc0Rhc2ggPSB0cnVlXG4gICAgICByZXR1cm4gaW5GaWxsZXJEZWxpbWl0ZXJcbiAgICB9IC8vIEFueXRoaW5nIGVsc2UgaXMgbm90IG9rLlxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJSaWdodEFsaWdubWVudChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICByZXR1cm4gcm93RW5kRGVsaW1pdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3doaXRlc3BhY2UnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5XaGl0ZXNwYWNlRGVsaW1pdGVyXG4gICAgfSAvLyBgfGBcblxuICAgIGlmIChjb2RlID09PSAxMjQpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgICAgcmV0dXJuIGF0RGVsaW1pdGVyUm93QnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiByb3dFbmREZWxpbWl0ZXIoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgndGFibGVEZWxpbWl0ZXJSb3cnKSAvLyBFeGl0IGlmIHRoZXJlIHdhcyBubyBkYXNoIGF0IGFsbCwgb3IgaWYgdGhlIGhlYWRlciBjZWxsIGNvdW50IGlzIG5vdCB0aGVcbiAgICAvLyBkZWxpbWl0ZXIgY2VsbCBjb3VudC5cblxuICAgIGlmICghaGFzRGFzaCB8fCB0YWJsZUhlYWRlckNvdW50ICE9PSBhbGlnbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRhYmxlQ2xvc2UoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgIG5leHRQcmVmaXhlZE9yQmxhbmssXG4gICAgICB0YWJsZUNsb3NlLFxuICAgICAgZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICB7XG4gICAgICAgICAgdG9rZW5pemU6IHRva2VuaXplUm93RW5kLFxuICAgICAgICAgIHBhcnRpYWw6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGJvZHlTdGFydCwgJ2xpbmVQcmVmaXgnLCA0KSxcbiAgICAgICAgdGFibGVDbG9zZVxuICAgICAgKVxuICAgICkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHRhYmxlQ2xvc2UoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgndGFibGUnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYm9keVN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUJvZHknKVxuICAgIHJldHVybiByb3dTdGFydEJvZHkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHJvd1N0YXJ0Qm9keShjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVSb3cnKSAvLyBJZiB3ZSBzdGFydCB3aXRoIGEgcGlwZSwgd2Ugb3BlbiBhIGNlbGwgbWFya2VyLlxuXG4gICAgaWYgKGNvZGUgPT09IDEyNCkge1xuICAgICAgcmV0dXJuIGNlbGxEaXZpZGVyQm9keShjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ3RlbXBvcmFyeVRhYmxlQ2VsbENvbnRlbnQnKSAvLyBDYW5cdTIwMTl0IGJlIHNwYWNlIG9yIGVvbHMgYXQgdGhlIHN0YXJ0IG9mIGEgY29uc3RydWN0LCBzbyB3ZVx1MjAxOXJlIGluIGEgY2VsbC5cblxuICAgIHJldHVybiBpbkNlbGxDb250ZW50Qm9keShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY2VsbERpdmlkZXJCb2R5KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgIHJldHVybiBjZWxsQnJlYWtCb2R5XG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBjZWxsQnJlYWtCb2R5KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBhdFJvd0VuZEJvZHkoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcignd2hpdGVzcGFjZScpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbldoaXRlc3BhY2VCb2R5XG4gICAgfSAvLyBgfGBcblxuICAgIGlmIChjb2RlID09PSAxMjQpIHtcbiAgICAgIHJldHVybiBjZWxsRGl2aWRlckJvZHkoY29kZSlcbiAgICB9IC8vIEFueXRoaW5nIGVsc2UgaXMgY2VsbCBjb250ZW50LlxuXG4gICAgZWZmZWN0cy5lbnRlcigndGVtcG9yYXJ5VGFibGVDZWxsQ29udGVudCcpXG4gICAgcmV0dXJuIGluQ2VsbENvbnRlbnRCb2R5KGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBpbldoaXRlc3BhY2VCb2R5KGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5XaGl0ZXNwYWNlQm9keVxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgnd2hpdGVzcGFjZScpXG4gICAgcmV0dXJuIGNlbGxCcmVha0JvZHkoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGluQ2VsbENvbnRlbnRCb2R5KGNvZGUpIHtcbiAgICAvLyBFT0YsIHdoaXRlc3BhY2UsIHBpcGVcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSAxMjQgfHwgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50JylcbiAgICAgIHJldHVybiBjZWxsQnJlYWtCb2R5KGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IDkyID8gaW5DZWxsQ29udGVudEVzY2FwZUJvZHkgOiBpbkNlbGxDb250ZW50Qm9keVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gaW5DZWxsQ29udGVudEVzY2FwZUJvZHkoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA5MiB8fCBjb2RlID09PSAxMjQpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluQ2VsbENvbnRlbnRCb2R5XG4gICAgfSAvLyBBbnl0aGluZyBlbHNlLlxuXG4gICAgcmV0dXJuIGluQ2VsbENvbnRlbnRCb2R5KGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhdFJvd0VuZEJvZHkoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgndGFibGVSb3cnKVxuXG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0YWJsZUJvZHlDbG9zZShjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKFxuICAgICAgbmV4dFByZWZpeGVkT3JCbGFuayxcbiAgICAgIHRhYmxlQm9keUNsb3NlLFxuICAgICAgZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICB7XG4gICAgICAgICAgdG9rZW5pemU6IHRva2VuaXplUm93RW5kLFxuICAgICAgICAgIHBhcnRpYWw6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZmFjdG9yeVNwYWNlKGVmZmVjdHMsIHJvd1N0YXJ0Qm9keSwgJ2xpbmVQcmVmaXgnLCA0KSxcbiAgICAgICAgdGFibGVCb2R5Q2xvc2VcbiAgICAgIClcbiAgICApKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiB0YWJsZUJvZHlDbG9zZShjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZUJvZHknKVxuICAgIHJldHVybiB0YWJsZUNsb3NlKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVSb3dFbmQoZWZmZWN0cywgb2ssIG5vaykge1xuICAgIHJldHVybiBzdGFydFxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdsaW5lRW5kaW5nJylcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgcHJlZml4ZWQsICdsaW5lUHJlZml4JylcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIHByZWZpeGVkKGNvZGUpIHtcbiAgICAgIC8vIEJsYW5rIG9yIGludGVycnVwdGluZyBsaW5lLlxuICAgICAgaWYgKFxuICAgICAgICBzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0gfHxcbiAgICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgICBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhaWwgPSBzZWxmLmV2ZW50c1tzZWxmLmV2ZW50cy5sZW5ndGggLSAxXSAvLyBJbmRlbnRlZCBjb2RlIGNhbiBpbnRlcnJ1cHQgZGVsaW1pdGVyIGFuZCBib2R5IHJvd3MuXG5cbiAgICAgIGlmIChcbiAgICAgICAgIXNlbGYucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKCdjb2RlSW5kZW50ZWQnKSAmJlxuICAgICAgICB0YWlsICYmXG4gICAgICAgIHRhaWxbMV0udHlwZSA9PT0gJ2xpbmVQcmVmaXgnICYmXG4gICAgICAgIHRhaWxbMl0uc2xpY2VTZXJpYWxpemUodGFpbFsxXSwgdHJ1ZSkubGVuZ3RoID49IDRcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIHNlbGYuX2dmbVRhYmxlRHluYW1pY0ludGVycnVwdEhhY2sgPSB0cnVlXG4gICAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgICAgc2VsZi5wYXJzZXIuY29uc3RydWN0cy5mbG93LFxuICAgICAgICBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIHNlbGYuX2dmbVRhYmxlRHluYW1pY0ludGVycnVwdEhhY2sgPSBmYWxzZVxuICAgICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICBzZWxmLl9nZm1UYWJsZUR5bmFtaWNJbnRlcnJ1cHRIYWNrID0gZmFsc2VcbiAgICAgICAgICByZXR1cm4gb2soY29kZSlcbiAgICAgICAgfVxuICAgICAgKShjb2RlKVxuICAgIH1cbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplTmV4dFByZWZpeGVkT3JCbGFuayhlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGxldCBzaXplID0gMFxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgLy8gVGhpcyBpcyBhIGNoZWNrLCBzbyB3ZSBkb25cdTIwMTl0IGNhcmUgYWJvdXQgdG9rZW5zLCBidXQgd2Ugb3BlbiBhIGJvZ3VzIG9uZVxuICAgIC8vIHNvIHdlXHUyMDE5cmUgdmFsaWQuXG4gICAgZWZmZWN0cy5lbnRlcignY2hlY2snKSAvLyBFT0wuXG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gd2hpdGVzcGFjZVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gd2hpdGVzcGFjZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IC0xIHx8IGNvZGUgPT09IDMyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHNpemUrK1xuICAgICAgcmV0dXJuIHNpemUgPT09IDQgPyBvayA6IHdoaXRlc3BhY2VcbiAgICB9IC8vIEVPRiBvciB3aGl0ZXNwYWNlXG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9IC8vIEFueXRoaW5nIGVsc2UuXG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzLmpzJykuTm9kZX0gTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5QYXJlbnR9IFBhcmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5TYWZlT3B0aW9uc30gU2FmZU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzLmpzJykuQ29udGV4dH0gQ29udGV4dFxuICovXG5cbmltcG9ydCB7dHJhY2t9IGZyb20gJy4vdHJhY2suanMnXG5cbi8qKlxuICogQHBhcmFtIHtQYXJlbnR9IHBhcmVudFxuICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0XG4gKiBAcGFyYW0ge1NhZmVPcHRpb25zfSBzYWZlT3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5lclBocmFzaW5nKHBhcmVudCwgY29udGV4dCwgc2FmZU9wdGlvbnMpIHtcbiAgY29uc3QgaW5kZXhTdGFjayA9IGNvbnRleHQuaW5kZXhTdGFja1xuICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbiB8fCBbXVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IHJlc3VsdHMgPSBbXVxuICBsZXQgaW5kZXggPSAtMVxuICBsZXQgYmVmb3JlID0gc2FmZU9wdGlvbnMuYmVmb3JlXG5cbiAgaW5kZXhTdGFjay5wdXNoKC0xKVxuICBsZXQgdHJhY2tlciA9IHRyYWNrKHNhZmVPcHRpb25zKVxuXG4gIHdoaWxlICgrK2luZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpbmRleF1cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQgYWZ0ZXJcblxuICAgIGluZGV4U3RhY2tbaW5kZXhTdGFjay5sZW5ndGggLSAxXSA9IGluZGV4XG5cbiAgICBpZiAoaW5kZXggKyAxIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBodXNoLCBpdFx1MjAxOXMgYWN0dWFsbHkgYSBgendpdGNoYC5cbiAgICAgIGxldCBoYW5kbGUgPSBjb250ZXh0LmhhbmRsZS5oYW5kbGVyc1tjaGlsZHJlbltpbmRleCArIDFdLnR5cGVdXG4gICAgICBpZiAoaGFuZGxlICYmIGhhbmRsZS5wZWVrKSBoYW5kbGUgPSBoYW5kbGUucGVla1xuICAgICAgYWZ0ZXIgPSBoYW5kbGVcbiAgICAgICAgPyBoYW5kbGUoY2hpbGRyZW5baW5kZXggKyAxXSwgcGFyZW50LCBjb250ZXh0LCB7XG4gICAgICAgICAgICBiZWZvcmU6ICcnLFxuICAgICAgICAgICAgYWZ0ZXI6ICcnLFxuICAgICAgICAgICAgLi4udHJhY2tlci5jdXJyZW50KClcbiAgICAgICAgICB9KS5jaGFyQXQoMClcbiAgICAgICAgOiAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlciA9IHNhZmVPcHRpb25zLmFmdGVyXG4gICAgfVxuXG4gICAgLy8gSW4gc29tZSBjYXNlcywgaHRtbCAodGV4dCkgY2FuIGJlIGZvdW5kIGluIHBocmFzaW5nIHJpZ2h0IGFmdGVyIGFuIGVvbC5cbiAgICAvLyBXaGVuIHdlXHUyMDE5ZCBzZXJpYWxpemUgdGhhdCwgaW4gbW9zdCBjYXNlcyB0aGF0IHdvdWxkIGJlIHNlZW4gYXMgaHRtbFxuICAgIC8vIChmbG93KS5cbiAgICAvLyBBcyB3ZSBjYW5cdTIwMTl0IGVzY2FwZSBvciBzbyB0byBwcmV2ZW50IGl0IGZyb20gaGFwcGVuaW5nLCB3ZSB0YWtlIGEgc29tZXdoYXRcbiAgICAvLyByZWFzb25hYmxlIGFwcHJvYWNoOiByZXBsYWNlIHRoYXQgZW9sIHdpdGggYSBzcGFjZS5cbiAgICAvLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vc3ludGF4LXRyZWUvbWRhc3QtdXRpbC10by1tYXJrZG93bi9pc3N1ZXMvMTU+XG4gICAgaWYgKFxuICAgICAgcmVzdWx0cy5sZW5ndGggPiAwICYmXG4gICAgICAoYmVmb3JlID09PSAnXFxyJyB8fCBiZWZvcmUgPT09ICdcXG4nKSAmJlxuICAgICAgY2hpbGQudHlwZSA9PT0gJ2h0bWwnXG4gICAgKSB7XG4gICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV0gPSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV0ucmVwbGFjZShcbiAgICAgICAgLyhcXHI/XFxufFxccikkLyxcbiAgICAgICAgJyAnXG4gICAgICApXG4gICAgICBiZWZvcmUgPSAnICdcblxuICAgICAgLy8gVG8gZG86IGRvZXMgdGhpcyB3b3JrIHRvIHJlc2V0IHRyYWNrZXI/XG4gICAgICB0cmFja2VyID0gdHJhY2soc2FmZU9wdGlvbnMpXG4gICAgICB0cmFja2VyLm1vdmUocmVzdWx0cy5qb2luKCcnKSlcbiAgICB9XG5cbiAgICByZXN1bHRzLnB1c2goXG4gICAgICB0cmFja2VyLm1vdmUoXG4gICAgICAgIGNvbnRleHQuaGFuZGxlKGNoaWxkLCBwYXJlbnQsIGNvbnRleHQsIHtcbiAgICAgICAgICAuLi50cmFja2VyLmN1cnJlbnQoKSxcbiAgICAgICAgICBiZWZvcmUsXG4gICAgICAgICAgYWZ0ZXJcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApXG5cbiAgICBiZWZvcmUgPSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV0uc2xpY2UoLTEpXG4gIH1cblxuICBpbmRleFN0YWNrLnBvcCgpXG5cbiAgcmV0dXJuIHJlc3VsdHMuam9pbignJylcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQWxpZ25UeXBlfSBBbGlnblR5cGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGFibGV9IFRhYmxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlRhYmxlUm93fSBUYWJsZVJvd1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UYWJsZUNlbGx9IFRhYmxlQ2VsbFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5JbmxpbmVDb2RlfSBJbmxpbmVDb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtYXJrZG93bi10YWJsZScpLk1hcmtkb3duVGFibGVPcHRpb25zfSBNYXJrZG93blRhYmxlT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuRXh0ZW5zaW9ufSBGcm9tTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkhhbmRsZX0gRnJvbU1hcmtkb3duSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuT3B0aW9uc30gVG9NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkhhbmRsZX0gVG9NYXJrZG93bkhhbmRsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkNvbnRleHR9IFRvTWFya2Rvd25Db250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuU2FmZU9wdGlvbnN9IFNhZmVPcHRpb25zXG4gKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbdGFibGVDZWxsUGFkZGluZz10cnVlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbdGFibGVQaXBlQWxpZ249dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7TWFya2Rvd25UYWJsZU9wdGlvbnNbJ3N0cmluZ0xlbmd0aCddfSBbc3RyaW5nTGVuZ3RoXVxuICovXG5cbmltcG9ydCB7Y29udGFpbmVyUGhyYXNpbmd9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvY29udGFpbmVyLXBocmFzaW5nLmpzJ1xuaW1wb3J0IHtpbmxpbmVDb2RlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvaW5saW5lLWNvZGUuanMnXG5pbXBvcnQge21hcmtkb3duVGFibGV9IGZyb20gJ21hcmtkb3duLXRhYmxlJ1xuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93bkV4dGVuc2lvbn0gKi9cbmV4cG9ydCBjb25zdCBnZm1UYWJsZUZyb21NYXJrZG93biA9IHtcbiAgZW50ZXI6IHtcbiAgICB0YWJsZTogZW50ZXJUYWJsZSxcbiAgICB0YWJsZURhdGE6IGVudGVyQ2VsbCxcbiAgICB0YWJsZUhlYWRlcjogZW50ZXJDZWxsLFxuICAgIHRhYmxlUm93OiBlbnRlclJvd1xuICB9LFxuICBleGl0OiB7XG4gICAgY29kZVRleHQ6IGV4aXRDb2RlVGV4dCxcbiAgICB0YWJsZTogZXhpdFRhYmxlLFxuICAgIHRhYmxlRGF0YTogZXhpdCxcbiAgICB0YWJsZUhlYWRlcjogZXhpdCxcbiAgICB0YWJsZVJvdzogZXhpdFxuICB9XG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZW50ZXJUYWJsZSh0b2tlbikge1xuICAvKiogQHR5cGUge0FycmF5PCdsZWZ0J3wncmlnaHQnfCdjZW50ZXInfCdub25lJz59ICovXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBhbGlnbmAgaXMgY3VzdG9tLlxuICBjb25zdCBhbGlnbiA9IHRva2VuLl9hbGlnblxuICB0aGlzLmVudGVyKFxuICAgIHtcbiAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICBhbGlnbjogYWxpZ24ubWFwKChkKSA9PiAoZCA9PT0gJ25vbmUnID8gbnVsbCA6IGQpKSxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0sXG4gICAgdG9rZW5cbiAgKVxuICB0aGlzLnNldERhdGEoJ2luVGFibGUnLCB0cnVlKVxufVxuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbmZ1bmN0aW9uIGV4aXRUYWJsZSh0b2tlbikge1xuICB0aGlzLmV4aXQodG9rZW4pXG4gIHRoaXMuc2V0RGF0YSgnaW5UYWJsZScpXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZW50ZXJSb3codG9rZW4pIHtcbiAgdGhpcy5lbnRlcih7dHlwZTogJ3RhYmxlUm93JywgY2hpbGRyZW46IFtdfSwgdG9rZW4pXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZXhpdCh0b2tlbikge1xuICB0aGlzLmV4aXQodG9rZW4pXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZW50ZXJDZWxsKHRva2VuKSB7XG4gIHRoaXMuZW50ZXIoe3R5cGU6ICd0YWJsZUNlbGwnLCBjaGlsZHJlbjogW119LCB0b2tlbilcbn1cblxuLy8gT3ZlcndyaXRlIHRoZSBkZWZhdWx0IGNvZGUgdGV4dCBkYXRhIGhhbmRsZXIgdG8gdW5lc2NhcGUgZXNjYXBlZCBwaXBlcyB3aGVuXG4vLyB0aGV5IGFyZSBpbiB0YWJsZXMuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbmZ1bmN0aW9uIGV4aXRDb2RlVGV4dCh0b2tlbikge1xuICBsZXQgdmFsdWUgPSB0aGlzLnJlc3VtZSgpXG5cbiAgaWYgKHRoaXMuZ2V0RGF0YSgnaW5UYWJsZScpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcKFtcXFxcfF0pL2csIHJlcGxhY2UpXG4gIH1cblxuICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtJbmxpbmVDb2RlfSAqLyAodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdKVxuICBub2RlLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5leGl0KHRva2VuKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSAkMFxuICogQHBhcmFtIHtzdHJpbmd9ICQxXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXBsYWNlKCQwLCAkMSkge1xuICAvLyBQaXBlcyB3b3JrLCBiYWNrc2xhc2hlcyBkb25cdTIwMTl0IChidXQgY2FuXHUyMDE5dCBlc2NhcGUgcGlwZXMpLlxuICByZXR1cm4gJDEgPT09ICd8JyA/ICQxIDogJDBcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1RvTWFya2Rvd25FeHRlbnNpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1UYWJsZVRvTWFya2Rvd24ob3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG9wdGlvbnMgfHwge31cbiAgY29uc3QgcGFkZGluZyA9IHNldHRpbmdzLnRhYmxlQ2VsbFBhZGRpbmdcbiAgY29uc3QgYWxpZ25EZWxpbWl0ZXJzID0gc2V0dGluZ3MudGFibGVQaXBlQWxpZ25cbiAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gc2V0dGluZ3Muc3RyaW5nTGVuZ3RoXG4gIGNvbnN0IGFyb3VuZCA9IHBhZGRpbmcgPyAnICcgOiAnfCdcblxuICByZXR1cm4ge1xuICAgIHVuc2FmZTogW1xuICAgICAge2NoYXJhY3RlcjogJ1xccicsIGluQ29uc3RydWN0OiAndGFibGVDZWxsJ30sXG4gICAgICB7Y2hhcmFjdGVyOiAnXFxuJywgaW5Db25zdHJ1Y3Q6ICd0YWJsZUNlbGwnfSxcbiAgICAgIC8vIEEgcGlwZSwgd2hlbiBmb2xsb3dlZCBieSBhIHRhYiBvciBzcGFjZSAocGFkZGluZyksIG9yIGEgZGFzaCBvciBjb2xvblxuICAgICAgLy8gKHVucGFkZGVkIGRlbGltaXRlciByb3cpLCBjb3VsZCByZXN1bHQgaW4gYSB0YWJsZS5cbiAgICAgIHthdEJyZWFrOiB0cnVlLCBjaGFyYWN0ZXI6ICd8JywgYWZ0ZXI6ICdbXFx0IDotXSd9LFxuICAgICAgLy8gQSBwaXBlIGluIGEgY2VsbCBtdXN0IGJlIGVuY29kZWQuXG4gICAgICB7Y2hhcmFjdGVyOiAnfCcsIGluQ29uc3RydWN0OiAndGFibGVDZWxsJ30sXG4gICAgICAvLyBBIGNvbG9uIG11c3QgYmUgZm9sbG93ZWQgYnkgYSBkYXNoLCBpbiB3aGljaCBjYXNlIGl0IGNvdWxkIHN0YXJ0IGFcbiAgICAgIC8vIGRlbGltaXRlciByb3cuXG4gICAgICB7YXRCcmVhazogdHJ1ZSwgY2hhcmFjdGVyOiAnOicsIGFmdGVyOiAnLSd9LFxuICAgICAgLy8gQSBkZWxpbWl0ZXIgcm93IGNhbiBhbHNvIHN0YXJ0IHdpdGggYSBkYXNoLCB3aGVuIGZvbGxvd2VkIGJ5IG1vcmVcbiAgICAgIC8vIGRhc2hlcywgYSBjb2xvbiwgb3IgYSBwaXBlLlxuICAgICAgLy8gVGhpcyBpcyBhIHN0cmljdGVyIHZlcnNpb24gdGhhbiB0aGUgYnVpbHQgaW4gY2hlY2sgZm9yIGxpc3RzLCB0aGVtYXRpY1xuICAgICAgLy8gYnJlYWtzLCBhbmQgc2V0ZXggaGVhZGluZyB1bmRlcmxpbmVzIHRob3VnaDpcbiAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vc3ludGF4LXRyZWUvbWRhc3QtdXRpbC10by1tYXJrZG93bi9ibG9iLzUxYTIwMzgvbGliL3Vuc2FmZS5qcyNMNTc+XG4gICAgICB7YXRCcmVhazogdHJ1ZSwgY2hhcmFjdGVyOiAnLScsIGFmdGVyOiAnWzp8LV0nfVxuICAgIF0sXG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIHRhYmxlOiBoYW5kbGVUYWJsZSxcbiAgICAgIHRhYmxlUm93OiBoYW5kbGVUYWJsZVJvdyxcbiAgICAgIHRhYmxlQ2VsbDogaGFuZGxlVGFibGVDZWxsLFxuICAgICAgaW5saW5lQ29kZTogaW5saW5lQ29kZVdpdGhUYWJsZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtUYWJsZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlVGFibGUobm9kZSwgXywgY29udGV4dCwgc2FmZU9wdGlvbnMpIHtcbiAgICByZXR1cm4gc2VyaWFsaXplRGF0YShcbiAgICAgIGhhbmRsZVRhYmxlQXNEYXRhKG5vZGUsIGNvbnRleHQsIHNhZmVPcHRpb25zKSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGZpeGVkIGluIGBtYXJrZG93bi10YWJsZUAzLjAuMWAuXG4gICAgICBub2RlLmFsaWduXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXNuXHUyMDE5dCByZWFsbHkgdXNlZCBub3JtYWxseSwgYmVjYXVzZSB3ZSBoYW5kbGUgcm93cyBhdCB0aGVcbiAgICogdGFibGUgbGV2ZWwuXG4gICAqIEJ1dCwgaWYgc29tZW9uZSBwYXNzZXMgaW4gYSB0YWJsZSByb3csIHRoaXMgZW5zdXJlcyB3ZSBtYWtlIHNvbWV3aGF0IHNlbnNlLlxuICAgKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtUYWJsZVJvd30gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlVGFibGVSb3cobm9kZSwgXywgY29udGV4dCwgc2FmZU9wdGlvbnMpIHtcbiAgICBjb25zdCByb3cgPSBoYW5kbGVUYWJsZVJvd0FzRGF0YShub2RlLCBjb250ZXh0LCBzYWZlT3B0aW9ucylcbiAgICAvLyBgbWFya2Rvd24tdGFibGVgIHdpbGwgYWx3YXlzIGFkZCBhbiBhbGlnbiByb3dcbiAgICBjb25zdCB2YWx1ZSA9IHNlcmlhbGl6ZURhdGEoW3Jvd10pXG4gICAgcmV0dXJuIHZhbHVlLnNsaWNlKDAsIHZhbHVlLmluZGV4T2YoJ1xcbicpKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfVxuICAgKiBAcGFyYW0ge1RhYmxlQ2VsbH0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlVGFibGVDZWxsKG5vZGUsIF8sIGNvbnRleHQsIHNhZmVPcHRpb25zKSB7XG4gICAgY29uc3QgZXhpdCA9IGNvbnRleHQuZW50ZXIoJ3RhYmxlQ2VsbCcpXG4gICAgY29uc3Qgc3ViZXhpdCA9IGNvbnRleHQuZW50ZXIoJ3BocmFzaW5nJylcbiAgICBjb25zdCB2YWx1ZSA9IGNvbnRhaW5lclBocmFzaW5nKG5vZGUsIGNvbnRleHQsIHtcbiAgICAgIC4uLnNhZmVPcHRpb25zLFxuICAgICAgYmVmb3JlOiBhcm91bmQsXG4gICAgICBhZnRlcjogYXJvdW5kXG4gICAgfSlcbiAgICBzdWJleGl0KClcbiAgICBleGl0KClcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PEFycmF5PHN0cmluZz4+fSBtYXRyaXhcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbYWxpZ25dXG4gICAqL1xuICBmdW5jdGlvbiBzZXJpYWxpemVEYXRhKG1hdHJpeCwgYWxpZ24pIHtcbiAgICByZXR1cm4gbWFya2Rvd25UYWJsZShtYXRyaXgsIHtcbiAgICAgIGFsaWduLFxuICAgICAgYWxpZ25EZWxpbWl0ZXJzLFxuICAgICAgcGFkZGluZyxcbiAgICAgIHN0cmluZ0xlbmd0aFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUYWJsZX0gbm9kZVxuICAgKiBAcGFyYW0ge1RvTWFya2Rvd25Db250ZXh0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7U2FmZU9wdGlvbnN9IHNhZmVPcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVUYWJsZUFzRGF0YShub2RlLCBjb250ZXh0LCBzYWZlT3B0aW9ucykge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlblxuICAgIGxldCBpbmRleCA9IC0xXG4gICAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxzdHJpbmc+Pn0gKi9cbiAgICBjb25zdCByZXN1bHQgPSBbXVxuICAgIGNvbnN0IHN1YmV4aXQgPSBjb250ZXh0LmVudGVyKCd0YWJsZScpXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGhhbmRsZVRhYmxlUm93QXNEYXRhKFxuICAgICAgICBjaGlsZHJlbltpbmRleF0sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHNhZmVPcHRpb25zXG4gICAgICApXG4gICAgfVxuXG4gICAgc3ViZXhpdCgpXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUYWJsZVJvd30gbm9kZVxuICAgKiBAcGFyYW0ge1RvTWFya2Rvd25Db250ZXh0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7U2FmZU9wdGlvbnN9IHNhZmVPcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVUYWJsZVJvd0FzRGF0YShub2RlLCBjb250ZXh0LCBzYWZlT3B0aW9ucykge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlblxuICAgIGxldCBpbmRleCA9IC0xXG4gICAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdXG4gICAgY29uc3Qgc3ViZXhpdCA9IGNvbnRleHQuZW50ZXIoJ3RhYmxlUm93JylcblxuICAgIHdoaWxlICgrK2luZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBOb3RlOiB0aGUgcG9zaXRpb25hbCBpbmZvIGFzIHVzZWQgaGVyZSBpcyBpbmNvcnJlY3QuXG4gICAgICAvLyBNYWtpbmcgaXQgY29ycmVjdCB3b3VsZCBiZSBpbXBvc3NpYmxlIGR1ZSB0byBhbGlnbmluZyBjZWxscz9cbiAgICAgIC8vIEFuZCBpdCB3b3VsZCBuZWVkIGNvcHkvcGFzdGluZyBgbWFya2Rvd24tdGFibGVgIGludG8gdGhpcyBwcm9qZWN0LlxuICAgICAgcmVzdWx0W2luZGV4XSA9IGhhbmRsZVRhYmxlQ2VsbChcbiAgICAgICAgY2hpbGRyZW5baW5kZXhdLFxuICAgICAgICBub2RlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBzYWZlT3B0aW9uc1xuICAgICAgKVxuICAgIH1cblxuICAgIHN1YmV4aXQoKVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfVxuICAgKiBAcGFyYW0ge0lubGluZUNvZGV9IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIGlubGluZUNvZGVXaXRoVGFibGUobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgbGV0IHZhbHVlID0gaW5saW5lQ29kZShub2RlLCBwYXJlbnQsIGNvbnRleHQpXG5cbiAgICBpZiAoY29udGV4dC5zdGFjay5pbmNsdWRlcygndGFibGVDZWxsJykpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFx8L2csICdcXFxcJCYnKVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4dGVuc2lvbn0gRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlJlc29sdmVyfSBSZXNvbHZlclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaW5nbGVUaWxkZT10cnVlXVxuICogICBXaGV0aGVyIHRvIHN1cHBvcnQgc3RyaWtldGhyb3VnaCB3aXRoIGEgc2luZ2xlIHRpbGRlIChgYm9vbGVhbmAsIGRlZmF1bHQ6XG4gKiAgIGB0cnVlYCkuXG4gKiAgIFNpbmdsZSB0aWxkZXMgd29yayBvbiBnaXRodWIuY29tLCBidXQgYXJlIHRlY2huaWNhbGx5IHByb2hpYml0ZWQgYnkgdGhlXG4gKiAgIEdGTSBzcGVjLlxuICovXG5pbXBvcnQge3NwbGljZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2h1bmtlZCdcbmltcG9ydCB7Y2xhc3NpZnlDaGFyYWN0ZXJ9IGZyb20gJ21pY3JvbWFyay11dGlsLWNsYXNzaWZ5LWNoYXJhY3RlcidcbmltcG9ydCB7cmVzb2x2ZUFsbH0gZnJvbSAnbWljcm9tYXJrLXV0aWwtcmVzb2x2ZS1hbGwnXG5cbi8qKlxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtFeHRlbnNpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1TdHJpa2V0aHJvdWdoKG9wdGlvbnMgPSB7fSkge1xuICBsZXQgc2luZ2xlID0gb3B0aW9ucy5zaW5nbGVUaWxkZVxuICBjb25zdCB0b2tlbml6ZXIgPSB7XG4gICAgdG9rZW5pemU6IHRva2VuaXplU3RyaWtldGhyb3VnaCxcbiAgICByZXNvbHZlQWxsOiByZXNvbHZlQWxsU3RyaWtldGhyb3VnaFxuICB9XG5cbiAgaWYgKHNpbmdsZSA9PT0gbnVsbCB8fCBzaW5nbGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNpbmdsZSA9IHRydWVcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGV4dDoge1xuICAgICAgWzEyNl06IHRva2VuaXplclxuICAgIH0sXG4gICAgaW5zaWRlU3Bhbjoge1xuICAgICAgbnVsbDogW3Rva2VuaXplcl1cbiAgICB9LFxuICAgIGF0dGVudGlvbk1hcmtlcnM6IHtcbiAgICAgIG51bGw6IFsxMjZdXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUYWtlIGV2ZW50cyBhbmQgcmVzb2x2ZSBzdHJpa2V0aHJvdWdoLlxuICAgKlxuICAgKiBAdHlwZSB7UmVzb2x2ZXJ9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVBbGxTdHJpa2V0aHJvdWdoKGV2ZW50cywgY29udGV4dCkge1xuICAgIGxldCBpbmRleCA9IC0xIC8vIFdhbGsgdGhyb3VnaCBhbGwgZXZlbnRzLlxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBGaW5kIGEgdG9rZW4gdGhhdCBjYW4gY2xvc2UuXG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcicgJiZcbiAgICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnc3RyaWtldGhyb3VnaFNlcXVlbmNlVGVtcG9yYXJ5JyAmJlxuICAgICAgICBldmVudHNbaW5kZXhdWzFdLl9jbG9zZVxuICAgICAgKSB7XG4gICAgICAgIGxldCBvcGVuID0gaW5kZXggLy8gTm93IHdhbGsgYmFjayB0byBmaW5kIGFuIG9wZW5lci5cblxuICAgICAgICB3aGlsZSAob3Blbi0tKSB7XG4gICAgICAgICAgLy8gRmluZCBhIHRva2VuIHRoYXQgY2FuIG9wZW4gdGhlIGNsb3Nlci5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBldmVudHNbb3Blbl1bMF0gPT09ICdleGl0JyAmJlxuICAgICAgICAgICAgZXZlbnRzW29wZW5dWzFdLnR5cGUgPT09ICdzdHJpa2V0aHJvdWdoU2VxdWVuY2VUZW1wb3JhcnknICYmXG4gICAgICAgICAgICBldmVudHNbb3Blbl1bMV0uX29wZW4gJiYgLy8gSWYgdGhlIHNpemVzIGFyZSB0aGUgc2FtZTpcbiAgICAgICAgICAgIGV2ZW50c1tpbmRleF1bMV0uZW5kLm9mZnNldCAtIGV2ZW50c1tpbmRleF1bMV0uc3RhcnQub2Zmc2V0ID09PVxuICAgICAgICAgICAgICBldmVudHNbb3Blbl1bMV0uZW5kLm9mZnNldCAtIGV2ZW50c1tvcGVuXVsxXS5zdGFydC5vZmZzZXRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9ICdzdHJpa2V0aHJvdWdoU2VxdWVuY2UnXG4gICAgICAgICAgICBldmVudHNbb3Blbl1bMV0udHlwZSA9ICdzdHJpa2V0aHJvdWdoU2VxdWVuY2UnXG4gICAgICAgICAgICBjb25zdCBzdHJpa2V0aHJvdWdoID0ge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaWtldGhyb3VnaCcsXG4gICAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbb3Blbl1bMV0uc3RhcnQpLFxuICAgICAgICAgICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tpbmRleF1bMV0uZW5kKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmlrZXRocm91Z2hUZXh0JyxcbiAgICAgICAgICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tvcGVuXVsxXS5lbmQpLFxuICAgICAgICAgICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tpbmRleF1bMV0uc3RhcnQpXG4gICAgICAgICAgICB9IC8vIE9wZW5pbmcuXG5cbiAgICAgICAgICAgIGNvbnN0IG5leHRFdmVudHMgPSBbXG4gICAgICAgICAgICAgIFsnZW50ZXInLCBzdHJpa2V0aHJvdWdoLCBjb250ZXh0XSxcbiAgICAgICAgICAgICAgWydlbnRlcicsIGV2ZW50c1tvcGVuXVsxXSwgY29udGV4dF0sXG4gICAgICAgICAgICAgIFsnZXhpdCcsIGV2ZW50c1tvcGVuXVsxXSwgY29udGV4dF0sXG4gICAgICAgICAgICAgIFsnZW50ZXInLCB0ZXh0LCBjb250ZXh0XVxuICAgICAgICAgICAgXSAvLyBCZXR3ZWVuLlxuXG4gICAgICAgICAgICBzcGxpY2UoXG4gICAgICAgICAgICAgIG5leHRFdmVudHMsXG4gICAgICAgICAgICAgIG5leHRFdmVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICByZXNvbHZlQWxsKFxuICAgICAgICAgICAgICAgIGNvbnRleHQucGFyc2VyLmNvbnN0cnVjdHMuaW5zaWRlU3Bhbi5udWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50cy5zbGljZShvcGVuICsgMSwgaW5kZXgpLFxuICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSAvLyBDbG9zaW5nLlxuXG4gICAgICAgICAgICBzcGxpY2UobmV4dEV2ZW50cywgbmV4dEV2ZW50cy5sZW5ndGgsIDAsIFtcbiAgICAgICAgICAgICAgWydleGl0JywgdGV4dCwgY29udGV4dF0sXG4gICAgICAgICAgICAgIFsnZW50ZXInLCBldmVudHNbaW5kZXhdWzFdLCBjb250ZXh0XSxcbiAgICAgICAgICAgICAgWydleGl0JywgZXZlbnRzW2luZGV4XVsxXSwgY29udGV4dF0sXG4gICAgICAgICAgICAgIFsnZXhpdCcsIHN0cmlrZXRocm91Z2gsIGNvbnRleHRdXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICAgc3BsaWNlKGV2ZW50cywgb3BlbiAtIDEsIGluZGV4IC0gb3BlbiArIDMsIG5leHRFdmVudHMpXG4gICAgICAgICAgICBpbmRleCA9IG9wZW4gKyBuZXh0RXZlbnRzLmxlbmd0aCAtIDJcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAoZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnc3RyaWtldGhyb3VnaFNlcXVlbmNlVGVtcG9yYXJ5Jykge1xuICAgICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPSAnZGF0YSdcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRzXG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVTdHJpa2V0aHJvdWdoKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMucHJldmlvdXNcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmV2ZW50c1xuICAgIGxldCBzaXplID0gMFxuICAgIHJldHVybiBzdGFydFxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHByZXZpb3VzID09PSAxMjYgJiZcbiAgICAgICAgZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXVsxXS50eXBlICE9PSAnY2hhcmFjdGVyRXNjYXBlJ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cblxuICAgICAgZWZmZWN0cy5lbnRlcignc3RyaWtldGhyb3VnaFNlcXVlbmNlVGVtcG9yYXJ5JylcbiAgICAgIHJldHVybiBtb3JlKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBtb3JlKGNvZGUpIHtcbiAgICAgIGNvbnN0IGJlZm9yZSA9IGNsYXNzaWZ5Q2hhcmFjdGVyKHByZXZpb3VzKVxuXG4gICAgICBpZiAoY29kZSA9PT0gMTI2KSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIHRoaXJkIG1hcmtlciwgZXhpdC5cbiAgICAgICAgaWYgKHNpemUgPiAxKSByZXR1cm4gbm9rKGNvZGUpXG4gICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgICBzaXplKytcbiAgICAgICAgcmV0dXJuIG1vcmVcbiAgICAgIH1cblxuICAgICAgaWYgKHNpemUgPCAyICYmICFzaW5nbGUpIHJldHVybiBub2soY29kZSlcbiAgICAgIGNvbnN0IHRva2VuID0gZWZmZWN0cy5leGl0KCdzdHJpa2V0aHJvdWdoU2VxdWVuY2VUZW1wb3JhcnknKVxuICAgICAgY29uc3QgYWZ0ZXIgPSBjbGFzc2lmeUNoYXJhY3Rlcihjb2RlKVxuICAgICAgdG9rZW4uX29wZW4gPSAhYWZ0ZXIgfHwgKGFmdGVyID09PSAyICYmIEJvb2xlYW4oYmVmb3JlKSlcbiAgICAgIHRva2VuLl9jbG9zZSA9ICFiZWZvcmUgfHwgKGJlZm9yZSA9PT0gMiAmJiBCb29sZWFuKGFmdGVyKSlcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5EZWxldGV9IERlbGV0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuRXh0ZW5zaW9ufSBGcm9tTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkhhbmRsZX0gRnJvbU1hcmtkb3duSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuT3B0aW9uc30gVG9NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkhhbmRsZX0gVG9NYXJrZG93bkhhbmRsZVxuICovXG5cbmltcG9ydCB7Y29udGFpbmVyUGhyYXNpbmd9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvY29udGFpbmVyLXBocmFzaW5nLmpzJ1xuaW1wb3J0IHt0cmFja30gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC90cmFjay5qcydcblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25FeHRlbnNpb259ICovXG5leHBvcnQgY29uc3QgZ2ZtU3RyaWtldGhyb3VnaEZyb21NYXJrZG93biA9IHtcbiAgY2FuQ29udGFpbkVvbHM6IFsnZGVsZXRlJ10sXG4gIGVudGVyOiB7c3RyaWtldGhyb3VnaDogZW50ZXJTdHJpa2V0aHJvdWdofSxcbiAgZXhpdDoge3N0cmlrZXRocm91Z2g6IGV4aXRTdHJpa2V0aHJvdWdofVxufVxuXG4vKipcbiAqIExpc3Qgb2YgY29uc3RydWN0cyB0aGF0IG9jY3VyIGluIHBocmFzaW5nIChwYXJhZ3JhcGhzLCBoZWFkaW5ncyksIGJ1dCBjYW5ub3RcbiAqIGNvbnRhaW4gc3RyaWtldGhyb3VnaHMuIFNvIHRoZXkgc29ydCBvZiBjYW5jZWwgZWFjaCBvdGhlciBvdXQuXG4gKlxuICogTm90ZToga2VlcCBpbiBzeW5jIHdpdGg6IDxodHRwczovL2dpdGh1Yi5jb20vc3ludGF4LXRyZWUvbWRhc3QtdXRpbC10by1tYXJrZG93bi9ibG9iL2M0Nzc0M2IvbGliL3Vuc2FmZS5qcyNMMTE+XG4gKi9cbmNvbnN0IGNvbnN0cnVjdHNXaXRob3V0U3RyaWtldGhyb3VnaCA9IFtcbiAgJ2F1dG9saW5rJyxcbiAgJ2Rlc3RpbmF0aW9uTGl0ZXJhbCcsXG4gICdkZXN0aW5hdGlvblJhdycsXG4gICdyZWZlcmVuY2UnLFxuICAndGl0bGVRdW90ZScsXG4gICd0aXRsZUFwb3N0cm9waGUnXG5dXG5cbi8qKiBAdHlwZSB7VG9NYXJrZG93bkV4dGVuc2lvbn0gKi9cbmV4cG9ydCBjb25zdCBnZm1TdHJpa2V0aHJvdWdoVG9NYXJrZG93biA9IHtcbiAgdW5zYWZlOiBbXG4gICAge1xuICAgICAgY2hhcmFjdGVyOiAnficsXG4gICAgICBpbkNvbnN0cnVjdDogJ3BocmFzaW5nJyxcbiAgICAgIG5vdEluQ29uc3RydWN0OiBjb25zdHJ1Y3RzV2l0aG91dFN0cmlrZXRocm91Z2hcbiAgICB9XG4gIF0sXG4gIGhhbmRsZXJzOiB7ZGVsZXRlOiBoYW5kbGVEZWxldGV9XG59XG5cbmhhbmRsZURlbGV0ZS5wZWVrID0gcGVla0RlbGV0ZVxuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbmZ1bmN0aW9uIGVudGVyU3RyaWtldGhyb3VnaCh0b2tlbikge1xuICB0aGlzLmVudGVyKHt0eXBlOiAnZGVsZXRlJywgY2hpbGRyZW46IFtdfSwgdG9rZW4pXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZXhpdFN0cmlrZXRocm91Z2godG9rZW4pIHtcbiAgdGhpcy5leGl0KHRva2VuKVxufVxuXG4vKipcbiAqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfVxuICogQHBhcmFtIHtEZWxldGV9IG5vZGVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlRGVsZXRlKG5vZGUsIF8sIGNvbnRleHQsIHNhZmVPcHRpb25zKSB7XG4gIGNvbnN0IHRyYWNrZXIgPSB0cmFjayhzYWZlT3B0aW9ucylcbiAgY29uc3QgZXhpdCA9IGNvbnRleHQuZW50ZXIoJ2VtcGhhc2lzJylcbiAgbGV0IHZhbHVlID0gdHJhY2tlci5tb3ZlKCd+ficpXG4gIHZhbHVlICs9IGNvbnRhaW5lclBocmFzaW5nKG5vZGUsIGNvbnRleHQsIHtcbiAgICAuLi50cmFja2VyLmN1cnJlbnQoKSxcbiAgICBiZWZvcmU6IHZhbHVlLFxuICAgIGFmdGVyOiAnfidcbiAgfSlcbiAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCd+ficpXG4gIGV4aXQoKVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gcGVla0RlbGV0ZSgpIHtcbiAgcmV0dXJuICd+J1xufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeHRlbnNpb259IEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4aXRlcn0gRXhpdGVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FdmVudH0gRXZlbnRcbiAqL1xuaW1wb3J0IHtibGFua0xpbmV9IGZyb20gJ21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsnXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge1xuICBtYXJrZG93bkxpbmVFbmRpbmcsXG4gIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2Vcbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuaW1wb3J0IHtub3JtYWxpemVJZGVudGlmaWVyfSBmcm9tICdtaWNyb21hcmstdXRpbC1ub3JtYWxpemUtaWRlbnRpZmllcidcbmNvbnN0IGluZGVudCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplSW5kZW50LFxuICBwYXJ0aWFsOiB0cnVlXG59XG4vKipcbiAqIEByZXR1cm5zIHtFeHRlbnNpb259XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdmbUZvb3Rub3RlKCkge1xuICAvKiogQHR5cGUge0V4dGVuc2lvbn0gKi9cbiAgcmV0dXJuIHtcbiAgICBkb2N1bWVudDoge1xuICAgICAgWzkxXToge1xuICAgICAgICB0b2tlbml6ZTogdG9rZW5pemVEZWZpbml0aW9uU3RhcnQsXG4gICAgICAgIGNvbnRpbnVhdGlvbjoge1xuICAgICAgICAgIHRva2VuaXplOiB0b2tlbml6ZURlZmluaXRpb25Db250aW51YXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgZXhpdDogZ2ZtRm9vdG5vdGVEZWZpbml0aW9uRW5kXG4gICAgICB9XG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICBbOTFdOiB7XG4gICAgICAgIHRva2VuaXplOiB0b2tlbml6ZUdmbUZvb3Rub3RlQ2FsbFxuICAgICAgfSxcbiAgICAgIFs5M106IHtcbiAgICAgICAgYWRkOiAnYWZ0ZXInLFxuICAgICAgICB0b2tlbml6ZTogdG9rZW5pemVQb3RlbnRpYWxHZm1Gb290bm90ZUNhbGwsXG4gICAgICAgIHJlc29sdmVUbzogcmVzb2x2ZVRvUG90ZW50aWFsR2ZtRm9vdG5vdGVDYWxsXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVQb3RlbnRpYWxHZm1Gb290bm90ZUNhbGwoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgaW5kZXggPSBzZWxmLmV2ZW50cy5sZW5ndGhcbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIEl0XHUyMDE5cyBmaW5lIVxuXG4gIGNvbnN0IGRlZmluZWQgPSBzZWxmLnBhcnNlci5nZm1Gb290bm90ZXMgfHwgKHNlbGYucGFyc2VyLmdmbUZvb3Rub3RlcyA9IFtdKVxuICAvKiogQHR5cGUge1Rva2VufSAqL1xuXG4gIGxldCBsYWJlbFN0YXJ0IC8vIEZpbmQgYW4gb3BlbmluZy5cblxuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIGNvbnN0IHRva2VuID0gc2VsZi5ldmVudHNbaW5kZXhdWzFdXG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xhYmVsSW1hZ2UnKSB7XG4gICAgICBsYWJlbFN0YXJ0ID0gdG9rZW5cbiAgICAgIGJyZWFrXG4gICAgfSAvLyBFeGl0IGlmIHdlXHUyMDE5dmUgd2Fsa2VkIGZhciBlbm91Z2guXG5cbiAgICBpZiAoXG4gICAgICB0b2tlbi50eXBlID09PSAnZ2ZtRm9vdG5vdGVDYWxsJyB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2xhYmVsTGluaycgfHxcbiAgICAgIHRva2VuLnR5cGUgPT09ICdsYWJlbCcgfHxcbiAgICAgIHRva2VuLnR5cGUgPT09ICdpbWFnZScgfHxcbiAgICAgIHRva2VuLnR5cGUgPT09ICdsaW5rJ1xuICAgICkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKCFsYWJlbFN0YXJ0IHx8ICFsYWJlbFN0YXJ0Ll9iYWxhbmNlZCkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGNvbnN0IGlkID0gbm9ybWFsaXplSWRlbnRpZmllcihcbiAgICAgIHNlbGYuc2xpY2VTZXJpYWxpemUoe1xuICAgICAgICBzdGFydDogbGFiZWxTdGFydC5lbmQsXG4gICAgICAgIGVuZDogc2VsZi5ub3coKVxuICAgICAgfSlcbiAgICApXG5cbiAgICBpZiAoaWQuY2hhckNvZGVBdCgwKSAhPT0gOTQgfHwgIWRlZmluZWQuaW5jbHVkZXMoaWQuc2xpY2UoMSkpKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVDYWxsTGFiZWxNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVDYWxsTGFiZWxNYXJrZXInKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG4vKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVG9Qb3RlbnRpYWxHZm1Gb290bm90ZUNhbGwoZXZlbnRzLCBjb250ZXh0KSB7XG4gIGxldCBpbmRleCA9IGV2ZW50cy5sZW5ndGhcbiAgLyoqIEB0eXBlIHtUb2tlbnx1bmRlZmluZWR9ICovXG5cbiAgbGV0IGxhYmVsU3RhcnQgLy8gRmluZCBhbiBvcGVuaW5nLlxuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgaWYgKFxuICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnbGFiZWxJbWFnZScgJiZcbiAgICAgIGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcidcbiAgICApIHtcbiAgICAgIGxhYmVsU3RhcnQgPSBldmVudHNbaW5kZXhdWzFdXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENoYW5nZSB0aGUgYGxhYmVsSW1hZ2VNYXJrZXJgIHRvIGEgYGRhdGFgLlxuICBldmVudHNbaW5kZXggKyAxXVsxXS50eXBlID0gJ2RhdGEnXG4gIGV2ZW50c1tpbmRleCArIDNdWzFdLnR5cGUgPSAnZ2ZtRm9vdG5vdGVDYWxsTGFiZWxNYXJrZXInIC8vIFRoZSB3aG9sZSAod2l0aG91dCBgIWApOlxuXG4gIGNvbnN0IGNhbGwgPSB7XG4gICAgdHlwZTogJ2dmbUZvb3Rub3RlQ2FsbCcsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tpbmRleCArIDNdWzFdLnN0YXJ0KSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV1bMV0uZW5kKVxuICB9IC8vIFRoZSBgXmAgbWFya2VyXG5cbiAgY29uc3QgbWFya2VyID0ge1xuICAgIHR5cGU6ICdnZm1Gb290bm90ZUNhbGxNYXJrZXInLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbaW5kZXggKyAzXVsxXS5lbmQpLFxuICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2luZGV4ICsgM11bMV0uZW5kKVxuICB9IC8vIEluY3JlbWVudCB0aGUgZW5kIDEgY2hhcmFjdGVyLlxuXG4gIG1hcmtlci5lbmQuY29sdW1uKytcbiAgbWFya2VyLmVuZC5vZmZzZXQrK1xuICBtYXJrZXIuZW5kLl9idWZmZXJJbmRleCsrXG4gIGNvbnN0IHN0cmluZyA9IHtcbiAgICB0eXBlOiAnZ2ZtRm9vdG5vdGVDYWxsU3RyaW5nJyxcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgbWFya2VyLmVuZCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdWzFdLnN0YXJ0KVxuICB9XG4gIGNvbnN0IGNodW5rID0ge1xuICAgIHR5cGU6ICdjaHVua1N0cmluZycsXG4gICAgY29udGVudFR5cGU6ICdzdHJpbmcnLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBzdHJpbmcuc3RhcnQpLFxuICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgc3RyaW5nLmVuZClcbiAgfVxuICAvKiogQHR5cGUge0FycmF5PEV2ZW50Pn0gKi9cblxuICBjb25zdCByZXBsYWNlbWVudCA9IFtcbiAgICAvLyBUYWtlIHRoZSBgbGFiZWxJbWFnZU1hcmtlcmAgKG5vdyBgZGF0YWAsIHRoZSBgIWApXG4gICAgZXZlbnRzW2luZGV4ICsgMV0sXG4gICAgZXZlbnRzW2luZGV4ICsgMl0sXG4gICAgWydlbnRlcicsIGNhbGwsIGNvbnRleHRdLCAvLyBUaGUgYFtgXG4gICAgZXZlbnRzW2luZGV4ICsgM10sXG4gICAgZXZlbnRzW2luZGV4ICsgNF0sIC8vIFRoZSBgXmAuXG4gICAgWydlbnRlcicsIG1hcmtlciwgY29udGV4dF0sXG4gICAgWydleGl0JywgbWFya2VyLCBjb250ZXh0XSwgLy8gRXZlcnl0aGluZyBpbiBiZXR3ZWVuLlxuICAgIFsnZW50ZXInLCBzdHJpbmcsIGNvbnRleHRdLFxuICAgIFsnZW50ZXInLCBjaHVuaywgY29udGV4dF0sXG4gICAgWydleGl0JywgY2h1bmssIGNvbnRleHRdLFxuICAgIFsnZXhpdCcsIHN0cmluZywgY29udGV4dF0sIC8vIFRoZSBlbmRpbmcgKGBdYCwgcHJvcGVybHkgcGFyc2VkIGFuZCBsYWJlbGxlZCkuXG4gICAgZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAyXSxcbiAgICBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdLFxuICAgIFsnZXhpdCcsIGNhbGwsIGNvbnRleHRdXG4gIF1cbiAgZXZlbnRzLnNwbGljZShpbmRleCwgZXZlbnRzLmxlbmd0aCAtIGluZGV4ICsgMSwgLi4ucmVwbGFjZW1lbnQpXG4gIHJldHVybiBldmVudHNcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUdmbUZvb3Rub3RlQ2FsbChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBJdFx1MjAxOXMgZmluZSFcblxuICBjb25zdCBkZWZpbmVkID0gc2VsZi5wYXJzZXIuZ2ZtRm9vdG5vdGVzIHx8IChzZWxmLnBhcnNlci5nZm1Gb290bm90ZXMgPSBbXSlcbiAgbGV0IHNpemUgPSAwXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblxuICBsZXQgZGF0YVxuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVDYWxsJylcbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZUNhbGxMYWJlbE1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZUNhbGxMYWJlbE1hcmtlcicpXG4gICAgcmV0dXJuIGNhbGxTdGFydFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY2FsbFN0YXJ0KGNvZGUpIHtcbiAgICBpZiAoY29kZSAhPT0gOTQpIHJldHVybiBub2soY29kZSlcbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZUNhbGxNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVDYWxsTWFya2VyJylcbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZUNhbGxTdHJpbmcnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2NodW5rU3RyaW5nJykuY29udGVudFR5cGUgPSAnc3RyaW5nJ1xuICAgIHJldHVybiBjYWxsRGF0YVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY2FsbERhdGEoY29kZSkge1xuICAgIC8qKiBAdHlwZSB7VG9rZW59ICovXG4gICAgbGV0IHRva2VuXG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSA5MSB8fCBzaXplKysgPiA5OTkpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gOTMpIHtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIGVmZmVjdHMuZXhpdCgnY2h1bmtTdHJpbmcnKVxuICAgICAgdG9rZW4gPSBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlQ2FsbFN0cmluZycpXG4gICAgICByZXR1cm4gZGVmaW5lZC5pbmNsdWRlcyhub3JtYWxpemVJZGVudGlmaWVyKHNlbGYuc2xpY2VTZXJpYWxpemUodG9rZW4pKSlcbiAgICAgICAgPyBlbmQoY29kZSlcbiAgICAgICAgOiBub2soY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcblxuICAgIGlmICghbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgZGF0YSA9IHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gY29kZSA9PT0gOTIgPyBjYWxsRXNjYXBlIDogY2FsbERhdGFcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNhbGxFc2NhcGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA5MSB8fCBjb2RlID09PSA5MiB8fCBjb2RlID09PSA5Mykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBzaXplKytcbiAgICAgIHJldHVybiBjYWxsRGF0YVxuICAgIH1cblxuICAgIHJldHVybiBjYWxsRGF0YShjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZW5kKGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZUNhbGxMYWJlbE1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZUNhbGxMYWJlbE1hcmtlcicpXG4gICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZUNhbGwnKVxuICAgIHJldHVybiBva1xuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVEZWZpbml0aW9uU3RhcnQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgSXRcdTIwMTlzIGZpbmUhXG5cbiAgY29uc3QgZGVmaW5lZCA9IHNlbGYucGFyc2VyLmdmbUZvb3Rub3RlcyB8fCAoc2VsZi5wYXJzZXIuZ2ZtRm9vdG5vdGVzID0gW10pXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXG4gIGxldCBpZGVudGlmaWVyXG4gIGxldCBzaXplID0gMFxuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBkYXRhXG4gIHJldHVybiBzdGFydFxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZURlZmluaXRpb24nKS5fY29udGFpbmVyID0gdHJ1ZVxuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsJylcbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbE1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbE1hcmtlcicpXG4gICAgcmV0dXJuIGxhYmVsU3RhcnRcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGxhYmVsU3RhcnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA5NCkge1xuICAgICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZURlZmluaXRpb25NYXJrZXInKVxuICAgICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxTdHJpbmcnKVxuICAgICAgcmV0dXJuIGF0QnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhdEJyZWFrKGNvZGUpIHtcbiAgICAvKiogQHR5cGUge1Rva2VufSAqL1xuICAgIGxldCB0b2tlblxuXG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgY29kZSA9PT0gOTEgfHwgc2l6ZSA+IDk5OSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA5Mykge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cblxuICAgICAgdG9rZW4gPSBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsU3RyaW5nJylcbiAgICAgIGlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKHNlbGYuc2xpY2VTZXJpYWxpemUodG9rZW4pKVxuICAgICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsTWFya2VyJylcbiAgICAgIGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWwnKVxuICAgICAgcmV0dXJuIGxhYmVsQWZ0ZXJcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdsaW5lRW5kaW5nJylcbiAgICAgIHNpemUrK1xuICAgICAgcmV0dXJuIGF0QnJlYWtcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdjaHVua1N0cmluZycpLmNvbnRlbnRUeXBlID0gJ3N0cmluZydcbiAgICByZXR1cm4gbGFiZWwoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGxhYmVsKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBudWxsIHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkgfHxcbiAgICAgIGNvZGUgPT09IDkxIHx8XG4gICAgICBjb2RlID09PSA5MyB8fFxuICAgICAgc2l6ZSA+IDk5OVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1N0cmluZycpXG4gICAgICByZXR1cm4gYXRCcmVhayhjb2RlKVxuICAgIH1cblxuICAgIGlmICghbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgZGF0YSA9IHRydWVcbiAgICB9XG5cbiAgICBzaXplKytcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29kZSA9PT0gOTIgPyBsYWJlbEVzY2FwZSA6IGxhYmVsXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBsYWJlbEVzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDkxIHx8IGNvZGUgPT09IDkyIHx8IGNvZGUgPT09IDkzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHNpemUrK1xuICAgICAgcmV0dXJuIGxhYmVsXG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBsYWJlbEFmdGVyKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNTgpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2RlZmluaXRpb25NYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2RlZmluaXRpb25NYXJrZXInKSAvLyBBbnkgd2hpdGVzcGFjZSBhZnRlciB0aGUgbWFya2VyIGlzIGVhdGVuLCBmb3JtaW5nIGluZGVudGVkIGNvZGVcbiAgICAgIC8vIGlzIG5vdCBwb3NzaWJsZS5cbiAgICAgIC8vIE5vIHNwYWNlIGlzIGFsc28gZmluZSwganVzdCBsaWtlIGEgYmxvY2sgcXVvdGUgbWFya2VyLlxuXG4gICAgICByZXR1cm4gZmFjdG9yeVNwYWNlKGVmZmVjdHMsIGRvbmUsICdnZm1Gb290bm90ZURlZmluaXRpb25XaGl0ZXNwYWNlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkb25lKGNvZGUpIHtcbiAgICBpZiAoIWRlZmluZWQuaW5jbHVkZXMoaWRlbnRpZmllcikpIHtcbiAgICAgIGRlZmluZWQucHVzaChpZGVudGlmaWVyKVxuICAgIH1cblxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVEZWZpbml0aW9uQ29udGludWF0aW9uKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgLy8gRWl0aGVyIGEgYmxhbmsgbGluZSwgd2hpY2ggaXMgb2theSwgb3IgYW4gaW5kZW50ZWQgdGhpbmcuXG4gIHJldHVybiBlZmZlY3RzLmNoZWNrKGJsYW5rTGluZSwgb2ssIGVmZmVjdHMuYXR0ZW1wdChpbmRlbnQsIG9rLCBub2spKVxufVxuLyoqIEB0eXBlIHtFeGl0ZXJ9ICovXG5cbmZ1bmN0aW9uIGdmbUZvb3Rub3RlRGVmaW5pdGlvbkVuZChlZmZlY3RzKSB7XG4gIGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVEZWZpbml0aW9uJylcbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUluZGVudChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgZWZmZWN0cyxcbiAgICBhZnRlclByZWZpeCxcbiAgICAnZ2ZtRm9vdG5vdGVEZWZpbml0aW9uSW5kZW50JyxcbiAgICA0ICsgMVxuICApXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJQcmVmaXgoY29kZSkge1xuICAgIGNvbnN0IHRhaWwgPSBzZWxmLmV2ZW50c1tzZWxmLmV2ZW50cy5sZW5ndGggLSAxXVxuICAgIHJldHVybiB0YWlsICYmXG4gICAgICB0YWlsWzFdLnR5cGUgPT09ICdnZm1Gb290bm90ZURlZmluaXRpb25JbmRlbnQnICYmXG4gICAgICB0YWlsWzJdLnNsaWNlU2VyaWFsaXplKHRhaWxbMV0sIHRydWUpLmxlbmd0aCA9PT0gNFxuICAgICAgPyBvayhjb2RlKVxuICAgICAgOiBub2soY29kZSlcbiAgfVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Gb290bm90ZVJlZmVyZW5jZX0gRm9vdG5vdGVSZWZlcmVuY2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuRm9vdG5vdGVEZWZpbml0aW9ufSBGb290bm90ZURlZmluaXRpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkV4dGVuc2lvbn0gRnJvbU1hcmtkb3duRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5IYW5kbGV9IEZyb21NYXJrZG93bkhhbmRsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLk9wdGlvbnN9IFRvTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5IYW5kbGV9IFRvTWFya2Rvd25IYW5kbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5NYXB9IE1hcFxuICovXG5cbmltcG9ydCB7bm9ybWFsaXplSWRlbnRpZmllcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtbm9ybWFsaXplLWlkZW50aWZpZXInXG5pbXBvcnQge2Fzc29jaWF0aW9ufSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2Fzc29jaWF0aW9uLmpzJ1xuaW1wb3J0IHtjb250YWluZXJGbG93fSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NvbnRhaW5lci1mbG93LmpzJ1xuaW1wb3J0IHtpbmRlbnRMaW5lc30gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9pbmRlbnQtbGluZXMuanMnXG5pbXBvcnQge3NhZmV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvc2FmZS5qcydcbmltcG9ydCB7dHJhY2t9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvdHJhY2suanMnXG5cbi8qKlxuICogQHJldHVybnMge0Zyb21NYXJrZG93bkV4dGVuc2lvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbUZvb3Rub3RlRnJvbU1hcmtkb3duKCkge1xuICByZXR1cm4ge1xuICAgIGVudGVyOiB7XG4gICAgICBnZm1Gb290bm90ZURlZmluaXRpb246IGVudGVyRm9vdG5vdGVEZWZpbml0aW9uLFxuICAgICAgZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxTdHJpbmc6IGVudGVyRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxTdHJpbmcsXG4gICAgICBnZm1Gb290bm90ZUNhbGw6IGVudGVyRm9vdG5vdGVDYWxsLFxuICAgICAgZ2ZtRm9vdG5vdGVDYWxsU3RyaW5nOiBlbnRlckZvb3Rub3RlQ2FsbFN0cmluZ1xuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgZ2ZtRm9vdG5vdGVEZWZpbml0aW9uOiBleGl0Rm9vdG5vdGVEZWZpbml0aW9uLFxuICAgICAgZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxTdHJpbmc6IGV4aXRGb290bm90ZURlZmluaXRpb25MYWJlbFN0cmluZyxcbiAgICAgIGdmbUZvb3Rub3RlQ2FsbDogZXhpdEZvb3Rub3RlQ2FsbCxcbiAgICAgIGdmbUZvb3Rub3RlQ2FsbFN0cmluZzogZXhpdEZvb3Rub3RlQ2FsbFN0cmluZ1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBlbnRlckZvb3Rub3RlRGVmaW5pdGlvbih0b2tlbikge1xuICAgIHRoaXMuZW50ZXIoXG4gICAgICB7dHlwZTogJ2Zvb3Rub3RlRGVmaW5pdGlvbicsIGlkZW50aWZpZXI6ICcnLCBsYWJlbDogJycsIGNoaWxkcmVuOiBbXX0sXG4gICAgICB0b2tlblxuICAgIClcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBlbnRlckZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsU3RyaW5nKCkge1xuICAgIHRoaXMuYnVmZmVyKClcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBleGl0Rm9vdG5vdGVEZWZpbml0aW9uTGFiZWxTdHJpbmcodG9rZW4pIHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtGb290bm90ZURlZmluaXRpb259ICovIChcbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIClcbiAgICBub2RlLmxhYmVsID0gbGFiZWxcbiAgICBub2RlLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICApLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBleGl0Rm9vdG5vdGVEZWZpbml0aW9uKHRva2VuKSB7XG4gICAgdGhpcy5leGl0KHRva2VuKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGVudGVyRm9vdG5vdGVDYWxsKHRva2VuKSB7XG4gICAgdGhpcy5lbnRlcih7dHlwZTogJ2Zvb3Rub3RlUmVmZXJlbmNlJywgaWRlbnRpZmllcjogJycsIGxhYmVsOiAnJ30sIHRva2VuKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGVudGVyRm9vdG5vdGVDYWxsU3RyaW5nKCkge1xuICAgIHRoaXMuYnVmZmVyKClcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuICBmdW5jdGlvbiBleGl0Rm9vdG5vdGVDYWxsU3RyaW5nKHRva2VuKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IC8qKiBAdHlwZSB7Rm9vdG5vdGVEZWZpbml0aW9ufSAqLyAoXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICApXG4gICAgbm9kZS5sYWJlbCA9IGxhYmVsXG4gICAgbm9kZS5pZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcihcbiAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgKS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICAvKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbiAgZnVuY3Rpb24gZXhpdEZvb3Rub3RlQ2FsbCh0b2tlbikge1xuICAgIHRoaXMuZXhpdCh0b2tlbilcbiAgfVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHtUb01hcmtkb3duRXh0ZW5zaW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtRm9vdG5vdGVUb01hcmtkb3duKCkge1xuICBmb290bm90ZVJlZmVyZW5jZS5wZWVrID0gZm9vdG5vdGVSZWZlcmVuY2VQZWVrXG5cbiAgcmV0dXJuIHtcbiAgICAvLyBUaGlzIGlzIG9uIGJ5IGRlZmF1bHQgYWxyZWFkeS5cbiAgICB1bnNhZmU6IFt7Y2hhcmFjdGVyOiAnWycsIGluQ29uc3RydWN0OiBbJ3BocmFzaW5nJywgJ2xhYmVsJywgJ3JlZmVyZW5jZSddfV0sXG4gICAgaGFuZGxlcnM6IHtmb290bm90ZURlZmluaXRpb24sIGZvb3Rub3RlUmVmZXJlbmNlfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfVxuICAgKiBAcGFyYW0ge0Zvb3Rub3RlUmVmZXJlbmNlfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBmb290bm90ZVJlZmVyZW5jZShub2RlLCBfLCBjb250ZXh0LCBzYWZlT3B0aW9ucykge1xuICAgIGNvbnN0IHRyYWNrZXIgPSB0cmFjayhzYWZlT3B0aW9ucylcbiAgICBsZXQgdmFsdWUgPSB0cmFja2VyLm1vdmUoJ1teJylcbiAgICBjb25zdCBleGl0ID0gY29udGV4dC5lbnRlcignZm9vdG5vdGVSZWZlcmVuY2UnKVxuICAgIGNvbnN0IHN1YmV4aXQgPSBjb250ZXh0LmVudGVyKCdyZWZlcmVuY2UnKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgIHNhZmUoY29udGV4dCwgYXNzb2NpYXRpb24obm9kZSksIHtcbiAgICAgICAgLi4udHJhY2tlci5jdXJyZW50KCksXG4gICAgICAgIGJlZm9yZTogdmFsdWUsXG4gICAgICAgIGFmdGVyOiAnXSdcbiAgICAgIH0pXG4gICAgKVxuICAgIHN1YmV4aXQoKVxuICAgIGV4aXQoKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZSgnXScpXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvKiogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9ICovXG4gIGZ1bmN0aW9uIGZvb3Rub3RlUmVmZXJlbmNlUGVlaygpIHtcbiAgICByZXR1cm4gJ1snXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gICAqIEBwYXJhbSB7Rm9vdG5vdGVEZWZpbml0aW9ufSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBmb290bm90ZURlZmluaXRpb24obm9kZSwgXywgY29udGV4dCwgc2FmZU9wdGlvbnMpIHtcbiAgICBjb25zdCB0cmFja2VyID0gdHJhY2soc2FmZU9wdGlvbnMpXG4gICAgbGV0IHZhbHVlID0gdHJhY2tlci5tb3ZlKCdbXicpXG4gICAgY29uc3QgZXhpdCA9IGNvbnRleHQuZW50ZXIoJ2Zvb3Rub3RlRGVmaW5pdGlvbicpXG4gICAgY29uc3Qgc3ViZXhpdCA9IGNvbnRleHQuZW50ZXIoJ2xhYmVsJylcbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoXG4gICAgICBzYWZlKGNvbnRleHQsIGFzc29jaWF0aW9uKG5vZGUpLCB7XG4gICAgICAgIC4uLnRyYWNrZXIuY3VycmVudCgpLFxuICAgICAgICBiZWZvcmU6IHZhbHVlLFxuICAgICAgICBhZnRlcjogJ10nXG4gICAgICB9KVxuICAgIClcbiAgICBzdWJleGl0KClcbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoXG4gICAgICAnXTonICsgKG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwID8gJyAnIDogJycpXG4gICAgKVxuICAgIHRyYWNrZXIuc2hpZnQoNClcbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoXG4gICAgICBpbmRlbnRMaW5lcyhjb250YWluZXJGbG93KG5vZGUsIGNvbnRleHQsIHRyYWNrZXIuY3VycmVudCgpKSwgbWFwKVxuICAgIClcbiAgICBleGl0KClcblxuICAgIHJldHVybiB2YWx1ZVxuXG4gICAgLyoqIEB0eXBlIHtNYXB9ICovXG4gICAgZnVuY3Rpb24gbWFwKGxpbmUsIGluZGV4LCBibGFuaykge1xuICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgIHJldHVybiAoYmxhbmsgPyAnJyA6ICcgICAgJykgKyBsaW5lXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lXG4gICAgfVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4dGVuc2lvbn0gRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdFJlY29yZH0gQ29uc3RydWN0UmVjb3JkXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlByZXZpb3VzfSBQcmV2aW91c1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvZGV9IENvZGVcbiAqL1xuaW1wb3J0IHtcbiAgYXNjaWlBbHBoYSxcbiAgYXNjaWlBbHBoYW51bWVyaWMsXG4gIGFzY2lpQ29udHJvbCxcbiAgYXNjaWlEaWdpdCxcbiAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSxcbiAgbWFya2Rvd25MaW5lRW5kaW5nLFxuICB1bmljb2RlUHVuY3R1YXRpb24sXG4gIHVuaWNvZGVXaGl0ZXNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmNvbnN0IHd3dyA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplV3d3LFxuICBwYXJ0aWFsOiB0cnVlXG59XG5jb25zdCBkb21haW4gPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZURvbWFpbixcbiAgcGFydGlhbDogdHJ1ZVxufVxuY29uc3QgcGF0aCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplUGF0aCxcbiAgcGFydGlhbDogdHJ1ZVxufVxuY29uc3QgcHVuY3R1YXRpb24gPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZVB1bmN0dWF0aW9uLFxuICBwYXJ0aWFsOiB0cnVlXG59XG5jb25zdCBuYW1lZENoYXJhY3RlclJlZmVyZW5jZSA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UsXG4gIHBhcnRpYWw6IHRydWVcbn1cbmNvbnN0IHd3d0F1dG9saW5rID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVXd3dBdXRvbGluayxcbiAgcHJldmlvdXM6IHByZXZpb3VzV3d3XG59XG5jb25zdCBodHRwQXV0b2xpbmsgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZUh0dHBBdXRvbGluayxcbiAgcHJldmlvdXM6IHByZXZpb3VzSHR0cFxufVxuY29uc3QgZW1haWxBdXRvbGluayA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplRW1haWxBdXRvbGluayxcbiAgcHJldmlvdXM6IHByZXZpb3VzRW1haWxcbn1cbi8qKiBAdHlwZSB7Q29uc3RydWN0UmVjb3JkfSAqL1xuXG5jb25zdCB0ZXh0ID0ge31cbi8qKiBAdHlwZSB7RXh0ZW5zaW9ufSAqL1xuXG5leHBvcnQgY29uc3QgZ2ZtQXV0b2xpbmtMaXRlcmFsID0ge1xuICB0ZXh0XG59XG5sZXQgY29kZSA9IDQ4IC8vIEFkZCBhbHBoYW51bWVyaWNzLlxuXG53aGlsZSAoY29kZSA8IDEyMykge1xuICB0ZXh0W2NvZGVdID0gZW1haWxBdXRvbGlua1xuICBjb2RlKytcbiAgaWYgKGNvZGUgPT09IDU4KSBjb2RlID0gNjVcbiAgZWxzZSBpZiAoY29kZSA9PT0gOTEpIGNvZGUgPSA5N1xufVxuXG50ZXh0WzQzXSA9IGVtYWlsQXV0b2xpbmtcbnRleHRbNDVdID0gZW1haWxBdXRvbGlua1xudGV4dFs0Nl0gPSBlbWFpbEF1dG9saW5rXG50ZXh0Wzk1XSA9IGVtYWlsQXV0b2xpbmtcbnRleHRbNzJdID0gW2VtYWlsQXV0b2xpbmssIGh0dHBBdXRvbGlua11cbnRleHRbMTA0XSA9IFtlbWFpbEF1dG9saW5rLCBodHRwQXV0b2xpbmtdXG50ZXh0Wzg3XSA9IFtlbWFpbEF1dG9saW5rLCB3d3dBdXRvbGlua11cbnRleHRbMTE5XSA9IFtlbWFpbEF1dG9saW5rLCB3d3dBdXRvbGlua11cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZUVtYWlsQXV0b2xpbmsoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cbiAgbGV0IGhhc0RvdFxuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuXG4gIGxldCBoYXNEaWdpdEluTGFzdFNlZ21lbnRcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGlmIChcbiAgICAgICFnZm1BdGV4dChjb2RlKSB8fFxuICAgICAgIXByZXZpb3VzRW1haWwoc2VsZi5wcmV2aW91cykgfHxcbiAgICAgIHByZXZpb3VzVW5iYWxhbmNlZChzZWxmLmV2ZW50cylcbiAgICApIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpdGVyYWxBdXRvbGlua0VtYWlsJylcbiAgICByZXR1cm4gYXRleHQoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGF0ZXh0KGNvZGUpIHtcbiAgICBpZiAoZ2ZtQXRleHQoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGF0ZXh0XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDY0KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBsYWJlbFxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGxhYmVsKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDYpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKHB1bmN0dWF0aW9uLCBkb25lLCBkb3RDb250aW51YXRpb24pKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDQ1IHx8IGNvZGUgPT09IDk1KSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhwdW5jdHVhdGlvbiwgbm9rLCBkYXNoT3JVbmRlcnNjb3JlQ29udGludWF0aW9uKShjb2RlKVxuICAgIH1cblxuICAgIGlmIChhc2NpaUFscGhhbnVtZXJpYyhjb2RlKSkge1xuICAgICAgaWYgKCFoYXNEaWdpdEluTGFzdFNlZ21lbnQgJiYgYXNjaWlEaWdpdChjb2RlKSkge1xuICAgICAgICBoYXNEaWdpdEluTGFzdFNlZ21lbnQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGxhYmVsXG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbmUoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRvdENvbnRpbnVhdGlvbihjb2RlKSB7XG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgaGFzRG90ID0gdHJ1ZVxuICAgIGhhc0RpZ2l0SW5MYXN0U2VnbWVudCA9IHVuZGVmaW5lZFxuICAgIHJldHVybiBsYWJlbFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZGFzaE9yVW5kZXJzY29yZUNvbnRpbnVhdGlvbihjb2RlKSB7XG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGFmdGVyRGFzaE9yVW5kZXJzY29yZVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXJEYXNoT3JVbmRlcnNjb3JlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDYpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKHB1bmN0dWF0aW9uLCBub2ssIGRvdENvbnRpbnVhdGlvbikoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWwoY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRvbmUoY29kZSkge1xuICAgIGlmIChoYXNEb3QgJiYgIWhhc0RpZ2l0SW5MYXN0U2VnbWVudCkge1xuICAgICAgZWZmZWN0cy5leGl0KCdsaXRlcmFsQXV0b2xpbmtFbWFpbCcpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpdGVyYWxBdXRvbGluaycpXG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZVd3d0F1dG9saW5rKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGlmIChcbiAgICAgIChjb2RlICE9PSA4NyAmJiBjb2RlICE9PSAxMTkpIHx8XG4gICAgICAhcHJldmlvdXNXd3coc2VsZi5wcmV2aW91cykgfHxcbiAgICAgIHByZXZpb3VzVW5iYWxhbmNlZChzZWxmLmV2ZW50cylcbiAgICApIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpdGVyYWxBdXRvbGlua1d3dycpIC8vIEZvciBgd3d3LmAgd2UgY2hlY2sgaW5zdGVhZCBvZiBhdHRlbXB0LCBiZWNhdXNlIHdoZW4gaXQgbWF0Y2hlcywgR0hcbiAgICAvLyB0cmVhdHMgaXQgYXMgcGFydCBvZiBhIGRvbWFpbiAoeWVzLCBpdCBzYXlzIGEgdmFsaWQgZG9tYWluIG11c3QgY29tZVxuICAgIC8vIGFmdGVyIGB3d3cuYCwgYnV0IHRoYXRcdTIwMTlzIG5vdCBob3cgaXRcdTIwMTlzIGltcGxlbWVudGVkIGJ5IHRoZW0pLlxuXG4gICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICB3d3csXG4gICAgICBlZmZlY3RzLmF0dGVtcHQoZG9tYWluLCBlZmZlY3RzLmF0dGVtcHQocGF0aCwgZG9uZSksIG5vayksXG4gICAgICBub2tcbiAgICApKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkb25lKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ2xpdGVyYWxBdXRvbGlua1d3dycpXG4gICAgZWZmZWN0cy5leGl0KCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVIdHRwQXV0b2xpbmsoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gc3RhcnRcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgKGNvZGUgIT09IDcyICYmIGNvZGUgIT09IDEwNCkgfHxcbiAgICAgICFwcmV2aW91c0h0dHAoc2VsZi5wcmV2aW91cykgfHxcbiAgICAgIHByZXZpb3VzVW5iYWxhbmNlZChzZWxmLmV2ZW50cylcbiAgICApIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpdGVyYWxBdXRvbGlua0h0dHAnKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiB0MVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdDEoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA4NCB8fCBjb2RlID09PSAxMTYpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHQyXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdDIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA4NCB8fCBjb2RlID09PSAxMTYpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHBcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBwKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gODAgfHwgY29kZSA9PT0gMTEyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBzXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gcyhjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDgzIHx8IGNvZGUgPT09IDExNSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gY29sb25cbiAgICB9XG5cbiAgICByZXR1cm4gY29sb24oY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGNvbG9uKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNTgpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHNsYXNoMVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHNsYXNoMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBzbGFzaDJcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBzbGFzaDIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gYWZ0ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IG51bGwgfHxcbiAgICAgIGFzY2lpQ29udHJvbChjb2RlKSB8fFxuICAgICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSkgfHxcbiAgICAgIHVuaWNvZGVQdW5jdHVhdGlvbihjb2RlKVxuICAgICAgPyBub2soY29kZSlcbiAgICAgIDogZWZmZWN0cy5hdHRlbXB0KGRvbWFpbiwgZWZmZWN0cy5hdHRlbXB0KHBhdGgsIGRvbmUpLCBub2spKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkb25lKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ2xpdGVyYWxBdXRvbGlua0h0dHAnKVxuICAgIGVmZmVjdHMuZXhpdCgnbGl0ZXJhbEF1dG9saW5rJylcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxufVxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5cbmZ1bmN0aW9uIHRva2VuaXplV3d3KGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiB3MlxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdzIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA4NyB8fCBjb2RlID09PSAxMTkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHczXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gdzMoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA4NyB8fCBjb2RlID09PSAxMTkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGRvdFxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGRvdChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ2KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBhZnRlclxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gbnVsbCB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkgPyBub2soY29kZSkgOiBvayhjb2RlKVxuICB9XG59XG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cblxuZnVuY3Rpb24gdG9rZW5pemVEb21haW4oZWZmZWN0cywgb2ssIG5vaykge1xuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuICBsZXQgaGFzVW5kZXJzY29yZUluTGFzdFNlZ21lbnRcbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cblxuICBsZXQgaGFzVW5kZXJzY29yZUluTGFzdExhc3RTZWdtZW50XG4gIHJldHVybiBkb21haW5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBkb21haW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSAzOCkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICAgIG5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlLFxuICAgICAgICBkb25lLFxuICAgICAgICBwdW5jdHVhdGlvbkNvbnRpbnVhdGlvblxuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA0NiB8fCBjb2RlID09PSA5NSkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2socHVuY3R1YXRpb24sIGRvbmUsIHB1bmN0dWF0aW9uQ29udGludWF0aW9uKShjb2RlKVxuICAgIH0gLy8gR0ggZG9jdW1lbnRzIHRoYXQgb25seSBhbHBoYW51bWVyaWNzIChvdGhlciB0aGFuIGAtYCwgYC5gLCBhbmQgYF9gKSBjYW5cbiAgICAvLyBvY2N1ciwgd2hpY2ggc291bmRzIGxpa2UgQVNDSUkgb25seSwgYnV0IHRoZXkgYWxzbyBzdXBwb3J0IGB3d3cuXHU5RURFXHU3NzBCLmNvbWAsXG4gICAgLy8gc28gdGhhdFx1MjAxOXMgVW5pY29kZS5cbiAgICAvLyBJbnN0ZWFkIG9mIHNvbWUgbmV3IHByb2R1Y3Rpb24gZm9yIFVuaWNvZGUgYWxwaGFudW1lcmljcywgbWFya2Rvd25cbiAgICAvLyBhbHJlYWR5IGhhcyB0aGF0IGZvciBVbmljb2RlIHB1bmN0dWF0aW9uIGFuZCB3aGl0ZXNwYWNlLCBzbyB1c2UgdGhvc2UuXG5cbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBudWxsIHx8XG4gICAgICBhc2NpaUNvbnRyb2woY29kZSkgfHxcbiAgICAgIHVuaWNvZGVXaGl0ZXNwYWNlKGNvZGUpIHx8XG4gICAgICAoY29kZSAhPT0gNDUgJiYgdW5pY29kZVB1bmN0dWF0aW9uKGNvZGUpKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRvbmUoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gZG9tYWluXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBwdW5jdHVhdGlvbkNvbnRpbnVhdGlvbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ2KSB7XG4gICAgICBoYXNVbmRlcnNjb3JlSW5MYXN0TGFzdFNlZ21lbnQgPSBoYXNVbmRlcnNjb3JlSW5MYXN0U2VnbWVudFxuICAgICAgaGFzVW5kZXJzY29yZUluTGFzdFNlZ21lbnQgPSB1bmRlZmluZWRcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGRvbWFpblxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA5NSkgaGFzVW5kZXJzY29yZUluTGFzdFNlZ21lbnQgPSB0cnVlXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGRvbWFpblxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gZG9uZShjb2RlKSB7XG4gICAgaWYgKCFoYXNVbmRlcnNjb3JlSW5MYXN0TGFzdFNlZ21lbnQgJiYgIWhhc1VuZGVyc2NvcmVJbkxhc3RTZWdtZW50KSB7XG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZVBhdGgoZWZmZWN0cywgb2spIHtcbiAgbGV0IGJhbGFuY2UgPSAwXG4gIHJldHVybiBpblBhdGhcbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBpblBhdGgoY29kZSkge1xuICAgIGlmIChjb2RlID09PSAzOCkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICAgIG5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlLFxuICAgICAgICBvayxcbiAgICAgICAgY29udGludWVkUHVuY3R1YXRpb25cbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gNDApIHtcbiAgICAgIGJhbGFuY2UrK1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA0MSkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICAgIHB1bmN0dWF0aW9uLFxuICAgICAgICBwYXJlbkF0UGF0aEVuZCxcbiAgICAgICAgY29udGludWVkUHVuY3R1YXRpb25cbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICBpZiAocGF0aEVuZChjb2RlKSkge1xuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKHRyYWlsaW5nUHVuY3R1YXRpb24oY29kZSkpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKHB1bmN0dWF0aW9uLCBvaywgY29udGludWVkUHVuY3R1YXRpb24pKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGluUGF0aFxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gY29udGludWVkUHVuY3R1YXRpb24oY29kZSkge1xuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBpblBhdGhcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIHBhcmVuQXRQYXRoRW5kKGNvZGUpIHtcbiAgICBiYWxhbmNlLS1cbiAgICByZXR1cm4gYmFsYW5jZSA8IDAgPyBvayhjb2RlKSA6IGNvbnRpbnVlZFB1bmN0dWF0aW9uKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBpbnNpZGVcbiAgfVxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gIGZ1bmN0aW9uIGluc2lkZShjb2RlKSB7XG4gICAgaWYgKGFzY2lpQWxwaGEoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluc2lkZVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA1OSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gYWZ0ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICBmdW5jdGlvbiBhZnRlcihjb2RlKSB7XG4gICAgLy8gSWYgdGhlIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2UgaXMgZm9sbG93ZWQgYnkgdGhlIGVuZCBvZiB0aGUgcGF0aCwgaXRcdTIwMTlzXG4gICAgLy8gbm90IGNvbnRpbnVlZCBwdW5jdHVhdGlvbi5cbiAgICByZXR1cm4gcGF0aEVuZChjb2RlKSA/IG9rKGNvZGUpIDogbm9rKGNvZGUpXG4gIH1cbn1cbi8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZVB1bmN0dWF0aW9uKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIHN0YXJ0XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBhZnRlclxuICB9XG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgIC8vIENoZWNrIHRoZSBuZXh0LlxuICAgIGlmICh0cmFpbGluZ1B1bmN0dWF0aW9uKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBhZnRlclxuICAgIH0gLy8gSWYgdGhlIHB1bmN0dWF0aW9uIG1hcmtlciBpcyBmb2xsb3dlZCBieSB0aGUgZW5kIG9mIHRoZSBwYXRoLCBpdFx1MjAxOXMgbm90XG4gICAgLy8gY29udGludWVkIHB1bmN0dWF0aW9uLlxuXG4gICAgcmV0dXJuIHBhdGhFbmQoY29kZSkgPyBvayhjb2RlKSA6IG5vayhjb2RlKVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7Q29kZX0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gdHJhaWxpbmdQdW5jdHVhdGlvbihjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgY29kZSA9PT0gMzMgfHxcbiAgICBjb2RlID09PSAzNCB8fFxuICAgIGNvZGUgPT09IDM5IHx8XG4gICAgY29kZSA9PT0gNDEgfHxcbiAgICBjb2RlID09PSA0MiB8fFxuICAgIGNvZGUgPT09IDQ0IHx8XG4gICAgY29kZSA9PT0gNDYgfHxcbiAgICBjb2RlID09PSA1OCB8fFxuICAgIGNvZGUgPT09IDU5IHx8XG4gICAgY29kZSA9PT0gNjAgfHxcbiAgICBjb2RlID09PSA2MyB8fFxuICAgIGNvZGUgPT09IDk1IHx8XG4gICAgY29kZSA9PT0gMTI2XG4gIClcbn1cbi8qKlxuICogQHBhcmFtIHtDb2RlfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBwYXRoRW5kKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IG51bGwgfHwgY29kZSA9PT0gNjAgfHwgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxufVxuLyoqXG4gKiBAcGFyYW0ge0NvZGV9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGdmbUF0ZXh0KGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICBjb2RlID09PSA0MyB8fFxuICAgIGNvZGUgPT09IDQ1IHx8XG4gICAgY29kZSA9PT0gNDYgfHxcbiAgICBjb2RlID09PSA5NSB8fFxuICAgIGFzY2lpQWxwaGFudW1lcmljKGNvZGUpXG4gIClcbn1cbi8qKiBAdHlwZSB7UHJldmlvdXN9ICovXG5cbmZ1bmN0aW9uIHByZXZpb3VzV3d3KGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICBjb2RlID09PSBudWxsIHx8XG4gICAgY29kZSA9PT0gNDAgfHxcbiAgICBjb2RlID09PSA0MiB8fFxuICAgIGNvZGUgPT09IDk1IHx8XG4gICAgY29kZSA9PT0gMTI2IHx8XG4gICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICApXG59XG4vKiogQHR5cGUge1ByZXZpb3VzfSAqL1xuXG5mdW5jdGlvbiBwcmV2aW91c0h0dHAoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gbnVsbCB8fCAhYXNjaWlBbHBoYShjb2RlKVxufVxuLyoqIEB0eXBlIHtQcmV2aW91c30gKi9cblxuZnVuY3Rpb24gcHJldmlvdXNFbWFpbChjb2RlKSB7XG4gIHJldHVybiBjb2RlICE9PSA0NyAmJiBwcmV2aW91c0h0dHAoY29kZSlcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gcHJldmlvdXNVbmJhbGFuY2VkKGV2ZW50cykge1xuICBsZXQgaW5kZXggPSBldmVudHMubGVuZ3RoXG4gIGxldCByZXN1bHQgPSBmYWxzZVxuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgY29uc3QgdG9rZW4gPSBldmVudHNbaW5kZXhdWzFdXG5cbiAgICBpZiAoXG4gICAgICAodG9rZW4udHlwZSA9PT0gJ2xhYmVsTGluaycgfHwgdG9rZW4udHlwZSA9PT0gJ2xhYmVsSW1hZ2UnKSAmJlxuICAgICAgIXRva2VuLl9iYWxhbmNlZFxuICAgICkge1xuICAgICAgcmVzdWx0ID0gdHJ1ZVxuICAgICAgYnJlYWtcbiAgICB9IC8vIEB0cy1leHBlY3QtZXJyb3IgSWYgd2VcdTIwMTl2ZSBzZWVuIHRoaXMgdG9rZW4sIGFuZCBpdCB3YXMgbWFya2VkIGFzIG5vdFxuICAgIC8vIGhhdmluZyBhbnkgdW5iYWxhbmNlZCBicmFja2V0IGJlZm9yZSBpdCwgd2UgY2FuIGV4aXQuXG5cbiAgICBpZiAodG9rZW4uX2dmbUF1dG9saW5rTGl0ZXJhbFdhbGtlZEludG8pIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmIChldmVudHMubGVuZ3RoID4gMCAmJiAhcmVzdWx0KSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBNYXJrIHRoZSBsYXN0IHRva2VuIGFzIFx1MjAxQ3dhbGtlZCBpbnRvXHUyMDFEIHcvbyBmaW5kaW5nXG4gICAgLy8gYW55dGhpbmcuXG4gICAgZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXVsxXS5fZ2ZtQXV0b2xpbmtMaXRlcmFsV2Fsa2VkSW50byA9IHRydWVcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsICIvKipcbiAqIENvdW50IGhvdyBvZnRlbiBhIGNoYXJhY3RlciAob3Igc3Vic3RyaW5nKSBpcyB1c2VkIGluIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogICBWYWx1ZSB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyXG4gKiAgIENoYXJhY3RlciAob3Igc3Vic3RyaW5nKSB0byBsb29rIGZvci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgTnVtYmVyIG9mIHRpbWVzIGBjaGFyYWN0ZXJgIG9jY3VycmVkIGluIGB2YWx1ZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjY291bnQodmFsdWUsIGNoYXJhY3Rlcikge1xuICBjb25zdCBzb3VyY2UgPSBTdHJpbmcodmFsdWUpXG5cbiAgaWYgKHR5cGVvZiBjaGFyYWN0ZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgY2hhcmFjdGVyJylcbiAgfVxuXG4gIGxldCBjb3VudCA9IDBcbiAgbGV0IGluZGV4ID0gc291cmNlLmluZGV4T2YoY2hhcmFjdGVyKVxuXG4gIHdoaWxlIChpbmRleCAhPT0gLTEpIHtcbiAgICBjb3VudCsrXG4gICAgaW5kZXggPSBzb3VyY2UuaW5kZXhPZihjaGFyYWN0ZXIsIGluZGV4ICsgY2hhcmFjdGVyLmxlbmd0aClcbiAgfVxuXG4gIHJldHVybiBjb3VudFxufVxuIiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVzY2FwZVN0cmluZ1JlZ2V4cChzdHJpbmcpIHtcblx0aWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHdpdGggc3BlY2lhbCBtZWFuaW5nIGVpdGhlciBpbnNpZGUgb3Igb3V0c2lkZSBjaGFyYWN0ZXIgc2V0cy5cblx0Ly8gVXNlIGEgc2ltcGxlIGJhY2tzbGFzaCBlc2NhcGUgd2hlbiBpdFx1MjAxOXMgYWx3YXlzIHZhbGlkLCBhbmQgYSBgXFx4bm5gIGVzY2FwZSB3aGVuIHRoZSBzaW1wbGVyIGZvcm0gd291bGQgYmUgZGlzYWxsb3dlZCBieSBVbmljb2RlIHBhdHRlcm5zXHUyMDE5IHN0cmljdGVyIGdyYW1tYXIuXG5cdHJldHVybiBzdHJpbmdcblx0XHQucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy5dL2csICdcXFxcJCYnKVxuXHRcdC5yZXBsYWNlKC8tL2csICdcXFxceDJkJyk7XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLk5vZGV9IE5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUGFyZW50fSBQYXJlbnRcbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBUeXBlXG4gKiBAdHlwZWRlZiB7T2JqZWN0PHN0cmluZywgdW5rbm93bj59IFByb3BzXG4gKlxuICogQHR5cGVkZWYge251bGx8dW5kZWZpbmVkfFR5cGV8UHJvcHN8VGVzdEZ1bmN0aW9uQW55dGhpbmd8QXJyYXkuPFR5cGV8UHJvcHN8VGVzdEZ1bmN0aW9uQW55dGhpbmc+fSBUZXN0XG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgcGFzc2VzIGEgdGVzdFxuICpcbiAqIEBjYWxsYmFjayBUZXN0RnVuY3Rpb25Bbnl0aGluZ1xuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge251bWJlcnxudWxsfHVuZGVmaW5lZH0gW2luZGV4XVxuICogQHBhcmFtIHtQYXJlbnR8bnVsbHx1bmRlZmluZWR9IFtwYXJlbnRdXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnx2b2lkfVxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIHBhc3NlcyBhIGNlcnRhaW4gbm9kZSB0ZXN0XG4gKlxuICogQHRlbXBsYXRlIHtOb2RlfSBYXG4gKiBAY2FsbGJhY2sgVGVzdEZ1bmN0aW9uUHJlZGljYXRlXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfG51bGx8dW5kZWZpbmVkfSBbaW5kZXhdXG4gKiBAcGFyYW0ge1BhcmVudHxudWxsfHVuZGVmaW5lZH0gW3BhcmVudF1cbiAqIEByZXR1cm5zIHtub2RlIGlzIFh9XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQXNzZXJ0QW55dGhpbmdcbiAqIEBwYXJhbSB7dW5rbm93bn0gW25vZGVdXG4gKiBAcGFyYW0ge251bWJlcnxudWxsfHVuZGVmaW5lZH0gW2luZGV4XVxuICogQHBhcmFtIHtQYXJlbnR8bnVsbHx1bmRlZmluZWR9IFtwYXJlbnRdXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBwYXNzZXMgYSBjZXJ0YWluIG5vZGUgdGVzdFxuICpcbiAqIEB0ZW1wbGF0ZSB7Tm9kZX0gWVxuICogQGNhbGxiYWNrIEFzc2VydFByZWRpY2F0ZVxuICogQHBhcmFtIHt1bmtub3dufSBbbm9kZV1cbiAqIEBwYXJhbSB7bnVtYmVyfG51bGx8dW5kZWZpbmVkfSBbaW5kZXhdXG4gKiBAcGFyYW0ge1BhcmVudHxudWxsfHVuZGVmaW5lZH0gW3BhcmVudF1cbiAqIEByZXR1cm5zIHtub2RlIGlzIFl9XG4gKi9cblxuZXhwb3J0IGNvbnN0IGlzID1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgbm9kZSBwYXNzZXMgYSB0ZXN0LlxuICAgKiBXaGVuIGEgYHBhcmVudGAgbm9kZSBpcyBrbm93biB0aGUgYGluZGV4YCBvZiBub2RlIHNob3VsZCBhbHNvIGJlIGdpdmVuLlxuICAgKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8VCBleHRlbmRzIE5vZGU+KG5vZGU6IHVua25vd24sIHRlc3Q6IFRbJ3R5cGUnXXxQYXJ0aWFsPFQ+fFRlc3RGdW5jdGlvblByZWRpY2F0ZTxUPnxBcnJheS48VFsndHlwZSddfFBhcnRpYWw8VD58VGVzdEZ1bmN0aW9uUHJlZGljYXRlPFQ+PiwgaW5kZXg/OiBudW1iZXJ8bnVsbHx1bmRlZmluZWQsIHBhcmVudD86IFBhcmVudHxudWxsfHVuZGVmaW5lZCwgY29udGV4dD86IHVua25vd24pID0+IG5vZGUgaXMgVCkgJlxuICAgKiAgICgobm9kZT86IHVua25vd24sIHRlc3Q/OiBUZXN0LCBpbmRleD86IG51bWJlcnxudWxsfHVuZGVmaW5lZCwgcGFyZW50PzogUGFyZW50fG51bGx8dW5kZWZpbmVkLCBjb250ZXh0PzogdW5rbm93bikgPT4gYm9vbGVhbilcbiAgICogKX1cbiAgICovXG4gIChcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIG5vZGUgcGFzc2VzIGEgdGVzdC5cbiAgICAgKiBXaGVuIGEgYHBhcmVudGAgbm9kZSBpcyBrbm93biB0aGUgYGluZGV4YCBvZiBub2RlIHNob3VsZCBhbHNvIGJlIGdpdmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt1bmtub3dufSBbbm9kZV0gTm9kZSB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7VGVzdH0gW3Rlc3RdXG4gICAgICogV2hlbiBudWxsaXNoLCBjaGVja3MgaWYgYG5vZGVgIGlzIGEgYE5vZGVgLlxuICAgICAqIFdoZW4gYHN0cmluZ2AsIHdvcmtzIGxpa2UgcGFzc2luZyBgZnVuY3Rpb24gKG5vZGUpIHtyZXR1cm4gbm9kZS50eXBlID09PSB0ZXN0fWAuXG4gICAgICogV2hlbiBgZnVuY3Rpb25gIGNoZWNrcyBpZiBmdW5jdGlvbiBwYXNzZWQgdGhlIG5vZGUgaXMgdHJ1ZS5cbiAgICAgKiBXaGVuIGBvYmplY3RgLCBjaGVja3MgdGhhdCBhbGwga2V5cyBpbiB0ZXN0IGFyZSBpbiBub2RlLCBhbmQgdGhhdCB0aGV5IGhhdmUgKHN0cmljdGx5KSBlcXVhbCB2YWx1ZXMuXG4gICAgICogV2hlbiBgYXJyYXlgLCBjaGVja3MgYW55IG9uZSBvZiB0aGUgc3VidGVzdHMgcGFzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxudWxsfHVuZGVmaW5lZH0gW2luZGV4XSBQb3NpdGlvbiBvZiBgbm9kZWAgaW4gYHBhcmVudGBcbiAgICAgKiBAcGFyYW0ge1BhcmVudHxudWxsfHVuZGVmaW5lZH0gW3BhcmVudF0gUGFyZW50IG9mIGBub2RlYFxuICAgICAqIEBwYXJhbSB7dW5rbm93bn0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0IHRvIGludm9rZSBgdGVzdGAgd2l0aFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRlc3QgcGFzc2VkIGFuZCBgbm9kZWAgaXMgYSBgTm9kZWAgKG9iamVjdCB3aXRoIGB0eXBlYCBzZXQgdG8gbm9uLWVtcHR5IGBzdHJpbmdgKS5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuICAgIGZ1bmN0aW9uIGlzKG5vZGUsIHRlc3QsIGluZGV4LCBwYXJlbnQsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGNoZWNrID0gY29udmVydCh0ZXN0KVxuXG4gICAgICBpZiAoXG4gICAgICAgIGluZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgaW5kZXggIT09IG51bGwgJiZcbiAgICAgICAgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICBpbmRleCA8IDAgfHxcbiAgICAgICAgICBpbmRleCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG9zaXRpdmUgZmluaXRlIGluZGV4JylcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBwYXJlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwYXJlbnQgIT09IG51bGwgJiZcbiAgICAgICAgKCFpcyhwYXJlbnQpIHx8ICFwYXJlbnQuY2hpbGRyZW4pXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwYXJlbnQgbm9kZScpXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgKHBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IHBhcmVudCA9PT0gbnVsbCkgIT09XG4gICAgICAgIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID09PSBudWxsKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYm90aCBwYXJlbnQgYW5kIGluZGV4JylcbiAgICAgIH1cblxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBMb29rcyBsaWtlIGEgbm9kZS5cbiAgICAgIHJldHVybiBub2RlICYmIG5vZGUudHlwZSAmJiB0eXBlb2Ygbm9kZS50eXBlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IEJvb2xlYW4oY2hlY2suY2FsbChjb250ZXh0LCBub2RlLCBpbmRleCwgcGFyZW50KSlcbiAgICAgICAgOiBmYWxzZVxuICAgIH1cbiAgKVxuXG5leHBvcnQgY29uc3QgY29udmVydCA9XG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8VCBleHRlbmRzIE5vZGU+KHRlc3Q6IFRbJ3R5cGUnXXxQYXJ0aWFsPFQ+fFRlc3RGdW5jdGlvblByZWRpY2F0ZTxUPikgPT4gQXNzZXJ0UHJlZGljYXRlPFQ+KSAmXG4gICAqICAgKCh0ZXN0PzogVGVzdCkgPT4gQXNzZXJ0QW55dGhpbmcpXG4gICAqICl9XG4gICAqL1xuICAoXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gYXNzZXJ0aW9uIGZyb20gYSBjaGVjay5cbiAgICAgKiBAcGFyYW0ge1Rlc3R9IFt0ZXN0XVxuICAgICAqIFdoZW4gbnVsbGlzaCwgY2hlY2tzIGlmIGBub2RlYCBpcyBhIGBOb2RlYC5cbiAgICAgKiBXaGVuIGBzdHJpbmdgLCB3b3JrcyBsaWtlIHBhc3NpbmcgYGZ1bmN0aW9uIChub2RlKSB7cmV0dXJuIG5vZGUudHlwZSA9PT0gdGVzdH1gLlxuICAgICAqIFdoZW4gYGZ1bmN0aW9uYCBjaGVja3MgaWYgZnVuY3Rpb24gcGFzc2VkIHRoZSBub2RlIGlzIHRydWUuXG4gICAgICogV2hlbiBgb2JqZWN0YCwgY2hlY2tzIHRoYXQgYWxsIGtleXMgaW4gdGVzdCBhcmUgaW4gbm9kZSwgYW5kIHRoYXQgdGhleSBoYXZlIChzdHJpY3RseSkgZXF1YWwgdmFsdWVzLlxuICAgICAqIFdoZW4gYGFycmF5YCwgY2hlY2tzIGFueSBvbmUgb2YgdGhlIHN1YnRlc3RzIHBhc3MuXG4gICAgICogQHJldHVybnMge0Fzc2VydEFueXRoaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgICBpZiAodGVzdCA9PT0gdW5kZWZpbmVkIHx8IHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9rXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVGYWN0b3J5KHRlc3QpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGVzdCkgPyBhbnlGYWN0b3J5KHRlc3QpIDogcHJvcHNGYWN0b3J5KHRlc3QpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY2FzdEZhY3RvcnkodGVzdClcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBmdW5jdGlvbiwgc3RyaW5nLCBvciBvYmplY3QgYXMgdGVzdCcpXG4gICAgfVxuICApXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPFR5cGV8UHJvcHN8VGVzdEZ1bmN0aW9uQW55dGhpbmc+fSB0ZXN0c1xuICogQHJldHVybnMge0Fzc2VydEFueXRoaW5nfVxuICovXG5mdW5jdGlvbiBhbnlGYWN0b3J5KHRlc3RzKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXkuPEFzc2VydEFueXRoaW5nPn0gKi9cbiAgY29uc3QgY2hlY2tzID0gW11cbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IHRlc3RzLmxlbmd0aCkge1xuICAgIGNoZWNrc1tpbmRleF0gPSBjb252ZXJ0KHRlc3RzW2luZGV4XSlcbiAgfVxuXG4gIHJldHVybiBjYXN0RmFjdG9yeShhbnkpXG5cbiAgLyoqXG4gICAqIEB0aGlzIHt1bmtub3dufVxuICAgKiBAcGFyYW0ge3Vua25vd25bXX0gcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGFueSguLi5wYXJhbWV0ZXJzKSB7XG4gICAgbGV0IGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgY2hlY2tzLmxlbmd0aCkge1xuICAgICAgaWYgKGNoZWNrc1tpbmRleF0uY2FsbCh0aGlzLCAuLi5wYXJhbWV0ZXJzKSkgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFV0aWxpdHkgdG8gYXNzZXJ0IGVhY2ggcHJvcGVydHkgaW4gYHRlc3RgIGlzIHJlcHJlc2VudGVkIGluIGBub2RlYCwgYW5kIGVhY2hcbiAqIHZhbHVlcyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKlxuICogQHBhcmFtIHtQcm9wc30gY2hlY2tcbiAqIEByZXR1cm5zIHtBc3NlcnRBbnl0aGluZ31cbiAqL1xuZnVuY3Rpb24gcHJvcHNGYWN0b3J5KGNoZWNrKSB7XG4gIHJldHVybiBjYXN0RmFjdG9yeShhbGwpXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGFsbChub2RlKSB7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbGV0IGtleVxuXG4gICAgZm9yIChrZXkgaW4gY2hlY2spIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGh1c2gsIGl0IHN1cmUgd29ya3MgYXMgYW4gaW5kZXguXG4gICAgICBpZiAobm9kZVtrZXldICE9PSBjaGVja1trZXldKSByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbi8qKlxuICogVXRpbGl0eSB0byBjb252ZXJ0IGEgc3RyaW5nIGludG8gYSBmdW5jdGlvbiB3aGljaCBjaGVja3MgYSBnaXZlbiBub2RlXHUyMDE5cyB0eXBlXG4gKiBmb3Igc2FpZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtUeXBlfSBjaGVja1xuICogQHJldHVybnMge0Fzc2VydEFueXRoaW5nfVxuICovXG5mdW5jdGlvbiB0eXBlRmFjdG9yeShjaGVjaykge1xuICByZXR1cm4gY2FzdEZhY3RvcnkodHlwZSlcblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiB0eXBlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLnR5cGUgPT09IGNoZWNrXG4gIH1cbn1cblxuLyoqXG4gKiBVdGlsaXR5IHRvIGNvbnZlcnQgYSBzdHJpbmcgaW50byBhIGZ1bmN0aW9uIHdoaWNoIGNoZWNrcyBhIGdpdmVuIG5vZGVcdTIwMTlzIHR5cGVcbiAqIGZvciBzYWlkIHN0cmluZy5cbiAqIEBwYXJhbSB7VGVzdEZ1bmN0aW9uQW55dGhpbmd9IGNoZWNrXG4gKiBAcmV0dXJucyB7QXNzZXJ0QW55dGhpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhc3RGYWN0b3J5KGNoZWNrKSB7XG4gIHJldHVybiBhc3NlcnRpb25cblxuICAvKipcbiAgICogQHRoaXMge3Vua25vd259XG4gICAqIEBwYXJhbSB7QXJyYXkuPHVua25vd24+fSBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gYXNzZXJ0aW9uKC4uLnBhcmFtZXRlcnMpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzcHJlYWRpbmcgaXMgZmluZS5cbiAgICByZXR1cm4gQm9vbGVhbihjaGVjay5jYWxsKHRoaXMsIC4uLnBhcmFtZXRlcnMpKVxuICB9XG59XG5cbi8vIFV0aWxpdHkgdG8gcmV0dXJuIHRydWUuXG5mdW5jdGlvbiBvaygpIHtcbiAgcmV0dXJuIHRydWVcbn1cbiIsICIvKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29sb3IoZCkge1xuICByZXR1cm4gZFxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Ob2RlfSBOb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBhcmVudH0gUGFyZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdC11dGlsLWlzJykuVGVzdH0gVGVzdFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9jb21wbGV4LXR5cGVzLmpzJykuQWN0aW9ufSBBY3Rpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29tcGxleC10eXBlcy5qcycpLkluZGV4fSBJbmRleFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9jb21wbGV4LXR5cGVzLmpzJykuQWN0aW9uVHVwbGV9IEFjdGlvblR1cGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvbXBsZXgtdHlwZXMuanMnKS5WaXNpdG9yUmVzdWx0fSBWaXNpdG9yUmVzdWx0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvbXBsZXgtdHlwZXMuanMnKS5WaXNpdG9yfSBWaXNpdG9yXG4gKi9cblxuaW1wb3J0IHtjb252ZXJ0fSBmcm9tICd1bmlzdC11dGlsLWlzJ1xuaW1wb3J0IHtjb2xvcn0gZnJvbSAnLi9jb2xvci5qcydcblxuLyoqXG4gKiBDb250aW51ZSB0cmF2ZXJzaW5nIGFzIG5vcm1hbFxuICovXG5leHBvcnQgY29uc3QgQ09OVElOVUUgPSB0cnVlXG4vKipcbiAqIERvIG5vdCB0cmF2ZXJzZSB0aGlzIG5vZGVcdTIwMTlzIGNoaWxkcmVuXG4gKi9cbmV4cG9ydCBjb25zdCBTS0lQID0gJ3NraXAnXG4vKipcbiAqIFN0b3AgdHJhdmVyc2luZyBpbW1lZGlhdGVseVxuICovXG5leHBvcnQgY29uc3QgRVhJVCA9IGZhbHNlXG5cbi8qKlxuICogVmlzaXQgY2hpbGRyZW4gb2YgdHJlZSB3aGljaCBwYXNzIHRlc3QuXG4gKlxuICogQHBhcmFtIHRyZWVcbiAqICAgVHJlZSB0byB3YWxrXG4gKiBAcGFyYW0gW3Rlc3RdXG4gKiAgIGB1bmlzdC11dGlsLWlzYC1jb21wYXRpYmxlIHRlc3RcbiAqIEBwYXJhbSB2aXNpdG9yXG4gKiAgIEZ1bmN0aW9uIGNhbGxlZCBmb3Igbm9kZXMgdGhhdCBwYXNzIGB0ZXN0YC5cbiAqIEBwYXJhbSBbcmV2ZXJzZT1mYWxzZV1cbiAqICAgVHJhdmVyc2UgaW4gcmV2ZXJzZSBwcmVvcmRlciAoTlJMKSBpbnN0ZWFkIG9mIHByZW9yZGVyIChOTFIpIChkZWZhdWx0KS5cbiAqL1xuZXhwb3J0IGNvbnN0IHZpc2l0UGFyZW50cyA9XG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8VHJlZSBleHRlbmRzIE5vZGUsIENoZWNrIGV4dGVuZHMgVGVzdD4odHJlZTogVHJlZSwgdGVzdDogQ2hlY2ssIHZpc2l0b3I6IGltcG9ydCgnLi9jb21wbGV4LXR5cGVzLmpzJykuQnVpbGRWaXNpdG9yPFRyZWUsIENoZWNrPiwgcmV2ZXJzZT86IGJvb2xlYW4pID0+IHZvaWQpICZcbiAgICogICAoPFRyZWUgZXh0ZW5kcyBOb2RlPih0cmVlOiBUcmVlLCB2aXNpdG9yOiBpbXBvcnQoJy4vY29tcGxleC10eXBlcy5qcycpLkJ1aWxkVmlzaXRvcjxUcmVlPiwgcmV2ZXJzZT86IGJvb2xlYW4pID0+IHZvaWQpXG4gICAqICl9XG4gICAqL1xuICAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSB0cmVlXG4gICAgICogQHBhcmFtIHtUZXN0fSB0ZXN0XG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4vY29tcGxleC10eXBlcy5qcycpLlZpc2l0b3I8Tm9kZT59IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlPWZhbHNlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0cmVlLCB0ZXN0LCB2aXNpdG9yLCByZXZlcnNlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZpc2l0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV2ZXJzZSA9IHZpc2l0b3JcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBubyB2aXNpdG9yIGdpdmVuLCBzbyBgdmlzaXRvcmAgaXMgdGVzdC5cbiAgICAgICAgdmlzaXRvciA9IHRlc3RcbiAgICAgICAgdGVzdCA9IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXMgPSBjb252ZXJ0KHRlc3QpXG4gICAgICBjb25zdCBzdGVwID0gcmV2ZXJzZSA/IC0xIDogMVxuXG4gICAgICBmYWN0b3J5KHRyZWUsIG51bGwsIFtdKSgpXG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICAgKiBAcGFyYW0ge251bWJlcj99IGluZGV4XG4gICAgICAgKiBAcGFyYW0ge0FycmF5PFBhcmVudD59IHBhcmVudHNcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZmFjdG9yeShub2RlLCBpbmRleCwgcGFyZW50cykge1xuICAgICAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAqL1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBodXNoXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGUgIT09IG51bGwgPyBub2RlIDoge31cbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICAgICAgICBsZXQgbmFtZVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBuYW1lID1cbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50YWdOYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICA/IHZhbHVlLnRhZ05hbWVcbiAgICAgICAgICAgICAgOiB0eXBlb2YgdmFsdWUubmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgPyB2YWx1ZS5uYW1lXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmlzaXQsICduYW1lJywge1xuICAgICAgICAgICAgdmFsdWU6XG4gICAgICAgICAgICAgICdub2RlICgnICtcbiAgICAgICAgICAgICAgY29sb3IodmFsdWUudHlwZSArIChuYW1lID8gJzwnICsgbmFtZSArICc+JyA6ICcnKSkgK1xuICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZpc2l0XG5cbiAgICAgICAgZnVuY3Rpb24gdmlzaXQoKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtBY3Rpb25UdXBsZX0gKi9cbiAgICAgICAgICBsZXQgcmVzdWx0ID0gW11cbiAgICAgICAgICAvKiogQHR5cGUge0FjdGlvblR1cGxlfSAqL1xuICAgICAgICAgIGxldCBzdWJyZXN1bHRcbiAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICBsZXQgb2Zmc2V0XG4gICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxQYXJlbnQ+fSAqL1xuICAgICAgICAgIGxldCBncmFuZHBhcmVudHNcblxuICAgICAgICAgIGlmICghdGVzdCB8fCBpcyhub2RlLCBpbmRleCwgcGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdIHx8IG51bGwpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0b1Jlc3VsdCh2aXNpdG9yKG5vZGUsIHBhcmVudHMpKVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0WzBdID09PSBFWElUKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2tzIGxpa2UgYSBwYXJlbnQuXG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4gJiYgcmVzdWx0WzBdICE9PSBTS0lQKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2tzIGxpa2UgYSBwYXJlbnQuXG4gICAgICAgICAgICBvZmZzZXQgPSAocmV2ZXJzZSA/IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIDogLTEpICsgc3RlcFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29rcyBsaWtlIGEgcGFyZW50LlxuICAgICAgICAgICAgZ3JhbmRwYXJlbnRzID0gcGFyZW50cy5jb25jYXQobm9kZSlcblxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29rcyBsaWtlIGEgcGFyZW50LlxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA+IC0xICYmIG9mZnNldCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3MgbGlrZSBhIHBhcmVudC5cbiAgICAgICAgICAgICAgc3VicmVzdWx0ID0gZmFjdG9yeShub2RlLmNoaWxkcmVuW29mZnNldF0sIG9mZnNldCwgZ3JhbmRwYXJlbnRzKSgpXG5cbiAgICAgICAgICAgICAgaWYgKHN1YnJlc3VsdFswXSA9PT0gRVhJVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJyZXN1bHRcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9mZnNldCA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIHN1YnJlc3VsdFsxXSA9PT0gJ251bWJlcicgPyBzdWJyZXN1bHRbMV0gOiBvZmZzZXQgKyBzdGVwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApXG5cbi8qKlxuICogQHBhcmFtIHtWaXNpdG9yUmVzdWx0fSB2YWx1ZVxuICogQHJldHVybnMge0FjdGlvblR1cGxlfVxuICovXG5mdW5jdGlvbiB0b1Jlc3VsdCh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIFtDT05USU5VRSwgdmFsdWVdXG4gIH1cblxuICByZXR1cm4gW3ZhbHVlXVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge1Rlc3R9IFtpZ25vcmVdXG4gKiAgIGB1bmlzdC11dGlsLWlzYCB0ZXN0IHVzZWQgdG8gYXNzZXJ0IHBhcmVudHNcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQ29udGVudH0gQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QaHJhc2luZ0NvbnRlbnR9IFBocmFzaW5nQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UZXh0fSBUZXh0XG4gKiBAdHlwZWRlZiB7Q29udGVudHxSb290fSBOb2RlXG4gKiBAdHlwZWRlZiB7RXhjbHVkZTxFeHRyYWN0PE5vZGUsIGltcG9ydCgnbWRhc3QnKS5QYXJlbnQ+LCBSb290Pn0gUGFyZW50XG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzJykuVGVzdH0gVGVzdFxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzJykuVmlzaXRvclJlc3VsdH0gVmlzaXRvclJlc3VsdFxuICpcbiAqIEB0eXBlZGVmIFJlZ0V4cE1hdGNoT2JqZWN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbnB1dFxuICogQHByb3BlcnR5IHtbUm9vdCwgLi4uQXJyYXk8UGFyZW50PiwgVGV4dF19IHN0YWNrXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ3xSZWdFeHB9IEZpbmRcbiAqIEB0eXBlZGVmIHtzdHJpbmd8UmVwbGFjZUZ1bmN0aW9ufSBSZXBsYWNlXG4gKlxuICogQHR5cGVkZWYge1tGaW5kLCBSZXBsYWNlXX0gRmluZEFuZFJlcGxhY2VUdXBsZVxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIFJlcGxhY2U+fSBGaW5kQW5kUmVwbGFjZVNjaGVtYVxuICogQHR5cGVkZWYge0FycmF5PEZpbmRBbmRSZXBsYWNlVHVwbGU+fSBGaW5kQW5kUmVwbGFjZUxpc3RcbiAqXG4gKiBAdHlwZWRlZiB7W1JlZ0V4cCwgUmVwbGFjZUZ1bmN0aW9uXX0gUGFpclxuICogQHR5cGVkZWYge0FycmF5PFBhaXI+fSBQYWlyc1xuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFJlcGxhY2VGdW5jdGlvblxuICogQHBhcmFtIHsuLi5hbnl9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtBcnJheTxQaHJhc2luZ0NvbnRlbnQ+fFBocmFzaW5nQ29udGVudHxzdHJpbmd8ZmFsc2V8dW5kZWZpbmVkfG51bGx9XG4gKi9cblxuaW1wb3J0IGVzY2FwZSBmcm9tICdlc2NhcGUtc3RyaW5nLXJlZ2V4cCdcbmltcG9ydCB7dmlzaXRQYXJlbnRzfSBmcm9tICd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnXG5pbXBvcnQge2NvbnZlcnR9IGZyb20gJ3VuaXN0LXV0aWwtaXMnXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKlxuICogQHBhcmFtIHRyZWUgbWRhc3QgdHJlZVxuICogQHBhcmFtIGZpbmQgVmFsdWUgdG8gZmluZCBhbmQgcmVtb3ZlLiBXaGVuIGBzdHJpbmdgLCBlc2NhcGVkIGFuZCBtYWRlIGludG8gYSBnbG9iYWwgYFJlZ0V4cGBcbiAqIEBwYXJhbSBbcmVwbGFjZV0gVmFsdWUgdG8gaW5zZXJ0LlxuICogICAqIFdoZW4gYHN0cmluZ2AsIHR1cm5lZCBpbnRvIGEgVGV4dCBub2RlLlxuICogICAqIFdoZW4gYEZ1bmN0aW9uYCwgY2FsbGVkIHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBgUmVnRXhwLmV4ZWNgIGFzXG4gKiAgICAgYXJndW1lbnRzLCBpbiB3aGljaCBjYXNlIGl0IGNhbiByZXR1cm4gYSBzaW5nbGUgb3IgYSBsaXN0IG9mIGBOb2RlYCxcbiAqICAgICBhIGBzdHJpbmdgICh3aGljaCBpcyB3cmFwcGVkIGluIGEgYFRleHRgIG5vZGUpLCBvciBgZmFsc2VgIHRvIG5vdCByZXBsYWNlXG4gKiBAcGFyYW0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kQW5kUmVwbGFjZSA9XG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICgodHJlZTogTm9kZSwgZmluZDogRmluZCwgcmVwbGFjZT86IFJlcGxhY2UsIG9wdGlvbnM/OiBPcHRpb25zKSA9PiBOb2RlKSAmXG4gICAqICAgKCh0cmVlOiBOb2RlLCBzY2hlbWE6IEZpbmRBbmRSZXBsYWNlU2NoZW1hfEZpbmRBbmRSZXBsYWNlTGlzdCwgb3B0aW9ucz86IE9wdGlvbnMpID0+IE5vZGUpXG4gICAqICl9XG4gICAqKi9cbiAgKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdHJlZVxuICAgICAqIEBwYXJhbSB7RmluZHxGaW5kQW5kUmVwbGFjZVNjaGVtYXxGaW5kQW5kUmVwbGFjZUxpc3R9IGZpbmRcbiAgICAgKiBAcGFyYW0ge1JlcGxhY2V8T3B0aW9uc30gW3JlcGxhY2VdXG4gICAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodHJlZSwgZmluZCwgcmVwbGFjZSwgb3B0aW9ucykge1xuICAgICAgLyoqIEB0eXBlIHtPcHRpb25zfHVuZGVmaW5lZH0gKi9cbiAgICAgIGxldCBzZXR0aW5nc1xuICAgICAgLyoqIEB0eXBlIHtGaW5kQW5kUmVwbGFjZVNjaGVtYXxGaW5kQW5kUmVwbGFjZUxpc3R9ICovXG4gICAgICBsZXQgc2NoZW1hXG5cbiAgICAgIGlmICh0eXBlb2YgZmluZCA9PT0gJ3N0cmluZycgfHwgZmluZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGRvblx1MjAxOXQgZXhwZWN0IG9wdGlvbnMgdHdpY2UuXG4gICAgICAgIHNjaGVtYSA9IFtbZmluZCwgcmVwbGFjZV1dXG4gICAgICAgIHNldHRpbmdzID0gb3B0aW9uc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hID0gZmluZFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGRvblx1MjAxOXQgZXhwZWN0IHJlcGxhY2UgdHdpY2UuXG4gICAgICAgIHNldHRpbmdzID0gcmVwbGFjZVxuICAgICAgfVxuXG4gICAgICBpZiAoIXNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzID0ge31cbiAgICAgIH1cblxuICAgICAgY29uc3QgaWdub3JlZCA9IGNvbnZlcnQoc2V0dGluZ3MuaWdub3JlIHx8IFtdKVxuICAgICAgY29uc3QgcGFpcnMgPSB0b1BhaXJzKHNjaGVtYSlcbiAgICAgIGxldCBwYWlySW5kZXggPSAtMVxuXG4gICAgICB3aGlsZSAoKytwYWlySW5kZXggPCBwYWlycy5sZW5ndGgpIHtcbiAgICAgICAgdmlzaXRQYXJlbnRzKHRyZWUsICd0ZXh0JywgdmlzaXRvcilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyZWVcblxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoJ3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cy9jb21wbGV4LXR5cGVzJykuQnVpbGRWaXNpdG9yPFJvb3QsICd0ZXh0Jz59ICovXG4gICAgICBmdW5jdGlvbiB2aXNpdG9yKG5vZGUsIHBhcmVudHMpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gLTFcbiAgICAgICAgLyoqIEB0eXBlIHtQYXJlbnR8dW5kZWZpbmVkfSAqL1xuICAgICAgICBsZXQgZ3JhbmRwYXJlbnRcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtQYXJlbnR9ICovIChwYXJlbnRzW2luZGV4XSlcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlnbm9yZWQoXG4gICAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBtZGFzdCB2cy4gdW5pc3QgcGFyZW50LlxuICAgICAgICAgICAgICBncmFuZHBhcmVudCA/IGdyYW5kcGFyZW50LmNoaWxkcmVuLmluZGV4T2YocGFyZW50KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZ3JhbmRwYXJlbnRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGdyYW5kcGFyZW50ID0gcGFyZW50XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JhbmRwYXJlbnQpIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzdGFjayBpcyBmaW5lLlxuICAgICAgICAgIHJldHVybiBoYW5kbGVyKG5vZGUsIHBhcmVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7W1Jvb3QsIC4uLkFycmF5PFBhcmVudD5dfSBwYXJlbnRzXG4gICAgICAgKiBAcmV0dXJucyB7VmlzaXRvclJlc3VsdH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gaGFuZGxlcihub2RlLCBwYXJlbnRzKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXVxuICAgICAgICBjb25zdCBmaW5kID0gcGFpcnNbcGFpckluZGV4XVswXVxuICAgICAgICBjb25zdCByZXBsYWNlID0gcGFpcnNbcGFpckluZGV4XVsxXVxuICAgICAgICBsZXQgc3RhcnQgPSAwXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFRTIGlzIHdyb25nLCBzb21lIG9mIHRoZXNlIGNoaWxkcmVuIGNhbiBiZSB0ZXh0LlxuICAgICAgICBjb25zdCBpbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKG5vZGUpXG4gICAgICAgIGxldCBjaGFuZ2UgPSBmYWxzZVxuICAgICAgICAvKiogQHR5cGUge0FycmF5PFBocmFzaW5nQ29udGVudD59ICovXG4gICAgICAgIGxldCBub2RlcyA9IFtdXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgbGV0IHBvc2l0aW9uXG5cbiAgICAgICAgZmluZC5sYXN0SW5kZXggPSAwXG5cbiAgICAgICAgbGV0IG1hdGNoID0gZmluZC5leGVjKG5vZGUudmFsdWUpXG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBtYXRjaC5pbmRleFxuICAgICAgICAgIC8qKiBAdHlwZSB7UmVnRXhwTWF0Y2hPYmplY3R9ICovXG4gICAgICAgICAgY29uc3QgbWF0Y2hPYmplY3QgPSB7XG4gICAgICAgICAgICBpbmRleDogbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICBpbnB1dDogbWF0Y2guaW5wdXQsXG4gICAgICAgICAgICBzdGFjazogWy4uLnBhcmVudHMsIG5vZGVdXG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB2YWx1ZSA9IHJlcGxhY2UoLi4ubWF0Y2gsIG1hdGNoT2JqZWN0KVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubGVuZ3RoID4gMCA/IHt0eXBlOiAndGV4dCcsIHZhbHVlfSA6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCAhPT0gcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlLnZhbHVlLnNsaWNlKHN0YXJ0LCBwb3NpdGlvbilcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIG5vZGVzLnB1c2goLi4udmFsdWUpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgIG5vZGVzLnB1c2godmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXJ0ID0gcG9zaXRpb24gKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgICAgIGNoYW5nZSA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZpbmQuZ2xvYmFsKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hdGNoID0gZmluZC5leGVjKG5vZGUudmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0IDwgbm9kZS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goe3R5cGU6ICd0ZXh0JywgdmFsdWU6IG5vZGUudmFsdWUuc2xpY2Uoc3RhcnQpfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxLCAuLi5ub2RlcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlcyA9IFtub2RlXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4ICsgbm9kZXMubGVuZ3RoXG4gICAgICB9XG4gICAgfVxuICApXG5cbi8qKlxuICogQHBhcmFtIHtGaW5kQW5kUmVwbGFjZVNjaGVtYXxGaW5kQW5kUmVwbGFjZUxpc3R9IHNjaGVtYVxuICogQHJldHVybnMge1BhaXJzfVxuICovXG5mdW5jdGlvbiB0b1BhaXJzKHNjaGVtYSkge1xuICAvKiogQHR5cGUge1BhaXJzfSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIGlmICh0eXBlb2Ygc2NoZW1hICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFycmF5IG9yIG9iamVjdCBhcyBzY2hlbWEnKVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IHNjaGVtYS5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFtcbiAgICAgICAgdG9FeHByZXNzaW9uKHNjaGVtYVtpbmRleF1bMF0pLFxuICAgICAgICB0b0Z1bmN0aW9uKHNjaGVtYVtpbmRleF1bMV0pXG4gICAgICBdKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQga2V5XG5cbiAgICBmb3IgKGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIGlmIChvd24uY2FsbChzY2hlbWEsIGtleSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW3RvRXhwcmVzc2lvbihrZXkpLCB0b0Z1bmN0aW9uKHNjaGVtYVtrZXldKV0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEBwYXJhbSB7RmluZH0gZmluZFxuICogQHJldHVybnMge1JlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9FeHByZXNzaW9uKGZpbmQpIHtcbiAgcmV0dXJuIHR5cGVvZiBmaW5kID09PSAnc3RyaW5nJyA/IG5ldyBSZWdFeHAoZXNjYXBlKGZpbmQpLCAnZycpIDogZmluZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVwbGFjZX0gcmVwbGFjZVxuICogQHJldHVybnMge1JlcGxhY2VGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gdG9GdW5jdGlvbihyZXBsYWNlKSB7XG4gIHJldHVybiB0eXBlb2YgcmVwbGFjZSA9PT0gJ2Z1bmN0aW9uJyA/IHJlcGxhY2UgOiAoKSA9PiByZXBsYWNlXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpbmt9IExpbmtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkV4dGVuc2lvbn0gRnJvbU1hcmtkb3duRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5UcmFuc2Zvcm19IEZyb21NYXJrZG93blRyYW5zZm9ybVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuSGFuZGxlfSBGcm9tTWFya2Rvd25IYW5kbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3R5cGVzLmpzJykuT3B0aW9uc30gVG9NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlJykuUmVwbGFjZUZ1bmN0aW9ufSBSZXBsYWNlRnVuY3Rpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZmluZC1hbmQtcmVwbGFjZScpLlJlZ0V4cE1hdGNoT2JqZWN0fSBSZWdFeHBNYXRjaE9iamVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlJykuUGhyYXNpbmdDb250ZW50fSBQaHJhc2luZ0NvbnRlbnRcbiAqL1xuXG5pbXBvcnQge2Njb3VudH0gZnJvbSAnY2NvdW50J1xuaW1wb3J0IHtmaW5kQW5kUmVwbGFjZX0gZnJvbSAnbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlJ1xuaW1wb3J0IHt1bmljb2RlUHVuY3R1YXRpb24sIHVuaWNvZGVXaGl0ZXNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5cbmNvbnN0IGluQ29uc3RydWN0ID0gJ3BocmFzaW5nJ1xuY29uc3Qgbm90SW5Db25zdHJ1Y3QgPSBbJ2F1dG9saW5rJywgJ2xpbmsnLCAnaW1hZ2UnLCAnbGFiZWwnXVxuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93bkV4dGVuc2lvbn0gKi9cbmV4cG9ydCBjb25zdCBnZm1BdXRvbGlua0xpdGVyYWxGcm9tTWFya2Rvd24gPSB7XG4gIHRyYW5zZm9ybXM6IFt0cmFuc2Zvcm1HZm1BdXRvbGlua0xpdGVyYWxzXSxcbiAgZW50ZXI6IHtcbiAgICBsaXRlcmFsQXV0b2xpbms6IGVudGVyTGl0ZXJhbEF1dG9saW5rLFxuICAgIGxpdGVyYWxBdXRvbGlua0VtYWlsOiBlbnRlckxpdGVyYWxBdXRvbGlua1ZhbHVlLFxuICAgIGxpdGVyYWxBdXRvbGlua0h0dHA6IGVudGVyTGl0ZXJhbEF1dG9saW5rVmFsdWUsXG4gICAgbGl0ZXJhbEF1dG9saW5rV3d3OiBlbnRlckxpdGVyYWxBdXRvbGlua1ZhbHVlXG4gIH0sXG4gIGV4aXQ6IHtcbiAgICBsaXRlcmFsQXV0b2xpbms6IGV4aXRMaXRlcmFsQXV0b2xpbmssXG4gICAgbGl0ZXJhbEF1dG9saW5rRW1haWw6IGV4aXRMaXRlcmFsQXV0b2xpbmtFbWFpbCxcbiAgICBsaXRlcmFsQXV0b2xpbmtIdHRwOiBleGl0TGl0ZXJhbEF1dG9saW5rSHR0cCxcbiAgICBsaXRlcmFsQXV0b2xpbmtXd3c6IGV4aXRMaXRlcmFsQXV0b2xpbmtXd3dcbiAgfVxufVxuXG4vKiogQHR5cGUge1RvTWFya2Rvd25FeHRlbnNpb259ICovXG5leHBvcnQgY29uc3QgZ2ZtQXV0b2xpbmtMaXRlcmFsVG9NYXJrZG93biA9IHtcbiAgdW5zYWZlOiBbXG4gICAge1xuICAgICAgY2hhcmFjdGVyOiAnQCcsXG4gICAgICBiZWZvcmU6ICdbK1xcXFwtLlxcXFx3XScsXG4gICAgICBhZnRlcjogJ1tcXFxcLS5cXFxcd10nLFxuICAgICAgaW5Db25zdHJ1Y3QsXG4gICAgICBub3RJbkNvbnN0cnVjdFxuICAgIH0sXG4gICAge1xuICAgICAgY2hhcmFjdGVyOiAnLicsXG4gICAgICBiZWZvcmU6ICdbV3ddJyxcbiAgICAgIGFmdGVyOiAnW1xcXFwtLlxcXFx3XScsXG4gICAgICBpbkNvbnN0cnVjdCxcbiAgICAgIG5vdEluQ29uc3RydWN0XG4gICAgfSxcbiAgICB7Y2hhcmFjdGVyOiAnOicsIGJlZm9yZTogJ1twc10nLCBhZnRlcjogJ1xcXFwvJywgaW5Db25zdHJ1Y3QsIG5vdEluQ29uc3RydWN0fVxuICBdXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZW50ZXJMaXRlcmFsQXV0b2xpbmsodG9rZW4pIHtcbiAgdGhpcy5lbnRlcih7dHlwZTogJ2xpbmsnLCB0aXRsZTogbnVsbCwgdXJsOiAnJywgY2hpbGRyZW46IFtdfSwgdG9rZW4pXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZW50ZXJMaXRlcmFsQXV0b2xpbmtWYWx1ZSh0b2tlbikge1xuICB0aGlzLmNvbmZpZy5lbnRlci5hdXRvbGlua1Byb3RvY29sLmNhbGwodGhpcywgdG9rZW4pXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZXhpdExpdGVyYWxBdXRvbGlua0h0dHAodG9rZW4pIHtcbiAgdGhpcy5jb25maWcuZXhpdC5hdXRvbGlua1Byb3RvY29sLmNhbGwodGhpcywgdG9rZW4pXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZXhpdExpdGVyYWxBdXRvbGlua1d3dyh0b2tlbikge1xuICB0aGlzLmNvbmZpZy5leGl0LmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgY29uc3Qgbm9kZSA9IC8qKiBAdHlwZSB7TGlua30gKi8gKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSlcbiAgbm9kZS51cmwgPSAnaHR0cDovLycgKyB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxufVxuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbmZ1bmN0aW9uIGV4aXRMaXRlcmFsQXV0b2xpbmtFbWFpbCh0b2tlbikge1xuICB0aGlzLmNvbmZpZy5leGl0LmF1dG9saW5rRW1haWwuY2FsbCh0aGlzLCB0b2tlbilcbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBleGl0TGl0ZXJhbEF1dG9saW5rKHRva2VuKSB7XG4gIHRoaXMuZXhpdCh0b2tlbilcbn1cblxuLyoqIEB0eXBlIHtGcm9tTWFya2Rvd25UcmFuc2Zvcm19ICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1HZm1BdXRvbGlua0xpdGVyYWxzKHRyZWUpIHtcbiAgZmluZEFuZFJlcGxhY2UoXG4gICAgdHJlZSxcbiAgICBbXG4gICAgICBbLyhodHRwcz86XFwvXFwvfHd3dyg/PVxcLikpKFstLlxcd10rKShbXiBcXHRcXHJcXG5dKikvZ2ksIGZpbmRVcmxdLFxuICAgICAgWy8oWy0uXFx3K10rKUAoWy1cXHddKyg/OlxcLlstXFx3XSspKykvZywgZmluZEVtYWlsXVxuICAgIF0sXG4gICAge2lnbm9yZTogWydsaW5rJywgJ2xpbmtSZWZlcmVuY2UnXX1cbiAgKVxufVxuXG4vKipcbiAqIEB0eXBlIHtSZXBsYWNlRnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ30gX1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtSZWdFeHBNYXRjaE9iamVjdH0gbWF0Y2hcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbmZ1bmN0aW9uIGZpbmRVcmwoXywgcHJvdG9jb2wsIGRvbWFpbiwgcGF0aCwgbWF0Y2gpIHtcbiAgbGV0IHByZWZpeCA9ICcnXG5cbiAgLy8gTm90IGFuIGV4cGVjdGVkIHByZXZpb3VzIGNoYXJhY3Rlci5cbiAgaWYgKCFwcmV2aW91cyhtYXRjaCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFRyZWF0IGB3d3dgIGFzIHBhcnQgb2YgdGhlIGRvbWFpbi5cbiAgaWYgKC9edy9pLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgZG9tYWluID0gcHJvdG9jb2wgKyBkb21haW5cbiAgICBwcm90b2NvbCA9ICcnXG4gICAgcHJlZml4ID0gJ2h0dHA6Ly8nXG4gIH1cblxuICBpZiAoIWlzQ29ycmVjdERvbWFpbihkb21haW4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBwYXJ0cyA9IHNwbGl0VXJsKGRvbWFpbiArIHBhdGgpXG5cbiAgaWYgKCFwYXJ0c1swXSkgcmV0dXJuIGZhbHNlXG5cbiAgLyoqIEB0eXBlIHtQaHJhc2luZ0NvbnRlbnR9ICovXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB0eXBlOiAnbGluaycsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdXJsOiBwcmVmaXggKyBwcm90b2NvbCArIHBhcnRzWzBdLFxuICAgIGNoaWxkcmVuOiBbe3R5cGU6ICd0ZXh0JywgdmFsdWU6IHByb3RvY29sICsgcGFydHNbMF19XVxuICB9XG5cbiAgaWYgKHBhcnRzWzFdKSB7XG4gICAgcmV0dXJuIFtyZXN1bHQsIHt0eXBlOiAndGV4dCcsIHZhbHVlOiBwYXJ0c1sxXX1dXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQHR5cGUge1JlcGxhY2VGdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfSBfXG4gKiBAcGFyYW0ge3N0cmluZ30gYXRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuICogQHBhcmFtIHtSZWdFeHBNYXRjaE9iamVjdH0gbWF0Y2hcbiAqL1xuZnVuY3Rpb24gZmluZEVtYWlsKF8sIGF0ZXh0LCBsYWJlbCwgbWF0Y2gpIHtcbiAgaWYgKFxuICAgIC8vIE5vdCBhbiBleHBlY3RlZCBwcmV2aW91cyBjaGFyYWN0ZXIuXG4gICAgIXByZXZpb3VzKG1hdGNoLCB0cnVlKSB8fFxuICAgIC8vIExhYmVsIGVuZHMgaW4gbm90IGFsbG93ZWQgY2hhcmFjdGVyLlxuICAgIC9bXy1cXGRdJC8udGVzdChsYWJlbClcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdsaW5rJyxcbiAgICB0aXRsZTogbnVsbCxcbiAgICB1cmw6ICdtYWlsdG86JyArIGF0ZXh0ICsgJ0AnICsgbGFiZWwsXG4gICAgY2hpbGRyZW46IFt7dHlwZTogJ3RleHQnLCB2YWx1ZTogYXRleHQgKyAnQCcgKyBsYWJlbH1dXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDb3JyZWN0RG9tYWluKGRvbWFpbikge1xuICBjb25zdCBwYXJ0cyA9IGRvbWFpbi5zcGxpdCgnLicpXG5cbiAgaWYgKFxuICAgIHBhcnRzLmxlbmd0aCA8IDIgfHxcbiAgICAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0gJiZcbiAgICAgICgvXy8udGVzdChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSkgfHxcbiAgICAgICAgIS9bYS16QS1aXFxkXS8udGVzdChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSkpKSB8fFxuICAgIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAyXSAmJlxuICAgICAgKC9fLy50ZXN0KHBhcnRzW3BhcnRzLmxlbmd0aCAtIDJdKSB8fFxuICAgICAgICAhL1thLXpBLVpcXGRdLy50ZXN0KHBhcnRzW3BhcnRzLmxlbmd0aCAtIDJdKSkpXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7W3N0cmluZywgc3RyaW5nfHVuZGVmaW5lZF19XG4gKi9cbmZ1bmN0aW9uIHNwbGl0VXJsKHVybCkge1xuICBjb25zdCB0cmFpbEV4ZWMgPSAvWyFcIiYnKSwuOjs8Pj9cXF19XSskLy5leGVjKHVybClcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIGxldCBjbG9zaW5nUGFyZW5JbmRleFxuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgbGV0IG9wZW5pbmdQYXJlbnNcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIGxldCBjbG9zaW5nUGFyZW5zXG4gIC8qKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH0gKi9cbiAgbGV0IHRyYWlsXG5cbiAgaWYgKHRyYWlsRXhlYykge1xuICAgIHVybCA9IHVybC5zbGljZSgwLCB0cmFpbEV4ZWMuaW5kZXgpXG4gICAgdHJhaWwgPSB0cmFpbEV4ZWNbMF1cbiAgICBjbG9zaW5nUGFyZW5JbmRleCA9IHRyYWlsLmluZGV4T2YoJyknKVxuICAgIG9wZW5pbmdQYXJlbnMgPSBjY291bnQodXJsLCAnKCcpXG4gICAgY2xvc2luZ1BhcmVucyA9IGNjb3VudCh1cmwsICcpJylcblxuICAgIHdoaWxlIChjbG9zaW5nUGFyZW5JbmRleCAhPT0gLTEgJiYgb3BlbmluZ1BhcmVucyA+IGNsb3NpbmdQYXJlbnMpIHtcbiAgICAgIHVybCArPSB0cmFpbC5zbGljZSgwLCBjbG9zaW5nUGFyZW5JbmRleCArIDEpXG4gICAgICB0cmFpbCA9IHRyYWlsLnNsaWNlKGNsb3NpbmdQYXJlbkluZGV4ICsgMSlcbiAgICAgIGNsb3NpbmdQYXJlbkluZGV4ID0gdHJhaWwuaW5kZXhPZignKScpXG4gICAgICBjbG9zaW5nUGFyZW5zKytcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW3VybCwgdHJhaWxdXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHBNYXRjaE9iamVjdH0gbWF0Y2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VtYWlsPWZhbHNlXVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzKG1hdGNoLCBlbWFpbCkge1xuICBjb25zdCBjb2RlID0gbWF0Y2guaW5wdXQuY2hhckNvZGVBdChtYXRjaC5pbmRleCAtIDEpXG5cbiAgcmV0dXJuIChcbiAgICAobWF0Y2guaW5kZXggPT09IDAgfHxcbiAgICAgIHVuaWNvZGVXaGl0ZXNwYWNlKGNvZGUpIHx8XG4gICAgICB1bmljb2RlUHVuY3R1YXRpb24oY29kZSkpICYmXG4gICAgKCFlbWFpbCB8fCBjb2RlICE9PSA0NylcbiAgKVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeHRlbnNpb259IEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5IdG1sRXh0ZW5zaW9ufSBIdG1sRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1zdHJpa2V0aHJvdWdoJykuT3B0aW9uc30gT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tZm9vdG5vdGUnKS5IdG1sT3B0aW9uc30gSHRtbE9wdGlvbnNcbiAqL1xuXG5pbXBvcnQge1xuICBjb21iaW5lRXh0ZW5zaW9ucyxcbiAgY29tYmluZUh0bWxFeHRlbnNpb25zXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNvbWJpbmUtZXh0ZW5zaW9ucydcbmltcG9ydCB7XG4gIGdmbUF1dG9saW5rTGl0ZXJhbCxcbiAgZ2ZtQXV0b2xpbmtMaXRlcmFsSHRtbFxufSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsJ1xuaW1wb3J0IHtnZm1Gb290bm90ZSwgZ2ZtRm9vdG5vdGVIdG1sfSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1mb290bm90ZSdcbmltcG9ydCB7XG4gIGdmbVN0cmlrZXRocm91Z2gsXG4gIGdmbVN0cmlrZXRocm91Z2hIdG1sXG59IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXN0cmlrZXRocm91Z2gnXG5pbXBvcnQge2dmbVRhYmxlLCBnZm1UYWJsZUh0bWx9IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXRhYmxlJ1xuaW1wb3J0IHtnZm1UYWdmaWx0ZXJIdG1sfSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWdmaWx0ZXInXG5pbXBvcnQge1xuICBnZm1UYXNrTGlzdEl0ZW0sXG4gIGdmbVRhc2tMaXN0SXRlbUh0bWxcbn0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFzay1saXN0LWl0ZW0nXG5cbi8qKlxuICogU3VwcG9ydCBHRk0gb3IgbWFya2Rvd24gb24gZ2l0aHViLmNvbS5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge0V4dGVuc2lvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbShvcHRpb25zKSB7XG4gIHJldHVybiBjb21iaW5lRXh0ZW5zaW9ucyhbXG4gICAgZ2ZtQXV0b2xpbmtMaXRlcmFsLFxuICAgIGdmbUZvb3Rub3RlKCksXG4gICAgZ2ZtU3RyaWtldGhyb3VnaChvcHRpb25zKSxcbiAgICBnZm1UYWJsZSxcbiAgICBnZm1UYXNrTGlzdEl0ZW1cbiAgXSlcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRvIGNvbXBpbGUgR0ZNIHRvIEhUTUwuXG4gKlxuICogQHBhcmFtIHtIdG1sT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7SHRtbEV4dGVuc2lvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbUh0bWwob3B0aW9ucykge1xuICByZXR1cm4gY29tYmluZUh0bWxFeHRlbnNpb25zKFtcbiAgICBnZm1BdXRvbGlua0xpdGVyYWxIdG1sLFxuICAgIGdmbUZvb3Rub3RlSHRtbChvcHRpb25zKSxcbiAgICBnZm1TdHJpa2V0aHJvdWdoSHRtbCxcbiAgICBnZm1UYWJsZUh0bWwsXG4gICAgZ2ZtVGFnZmlsdGVySHRtbCxcbiAgICBnZm1UYXNrTGlzdEl0ZW1IdG1sXG4gIF0pXG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5FeHRlbnNpb259IEZyb21NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLk9wdGlvbnN9IFRvTWFya2Rvd25FeHRlbnNpb25cbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWdmbS10YWJsZScpLk9wdGlvbnN9IE9wdGlvbnNcbiAqL1xuXG5pbXBvcnQge1xuICBnZm1BdXRvbGlua0xpdGVyYWxGcm9tTWFya2Rvd24sXG4gIGdmbUF1dG9saW5rTGl0ZXJhbFRvTWFya2Rvd25cbn0gZnJvbSAnbWRhc3QtdXRpbC1nZm0tYXV0b2xpbmstbGl0ZXJhbCdcbmltcG9ydCB7XG4gIGdmbUZvb3Rub3RlRnJvbU1hcmtkb3duLFxuICBnZm1Gb290bm90ZVRvTWFya2Rvd25cbn0gZnJvbSAnbWRhc3QtdXRpbC1nZm0tZm9vdG5vdGUnXG5pbXBvcnQge1xuICBnZm1TdHJpa2V0aHJvdWdoRnJvbU1hcmtkb3duLFxuICBnZm1TdHJpa2V0aHJvdWdoVG9NYXJrZG93blxufSBmcm9tICdtZGFzdC11dGlsLWdmbS1zdHJpa2V0aHJvdWdoJ1xuaW1wb3J0IHtnZm1UYWJsZUZyb21NYXJrZG93biwgZ2ZtVGFibGVUb01hcmtkb3dufSBmcm9tICdtZGFzdC11dGlsLWdmbS10YWJsZSdcbmltcG9ydCB7XG4gIGdmbVRhc2tMaXN0SXRlbUZyb21NYXJrZG93bixcbiAgZ2ZtVGFza0xpc3RJdGVtVG9NYXJrZG93blxufSBmcm9tICdtZGFzdC11dGlsLWdmbS10YXNrLWxpc3QtaXRlbSdcblxuLyoqXG4gKiBAcmV0dXJucyB7QXJyYXk8RnJvbU1hcmtkb3duRXh0ZW5zaW9uPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbUZyb21NYXJrZG93bigpIHtcbiAgcmV0dXJuIFtcbiAgICBnZm1BdXRvbGlua0xpdGVyYWxGcm9tTWFya2Rvd24sXG4gICAgZ2ZtRm9vdG5vdGVGcm9tTWFya2Rvd24oKSxcbiAgICBnZm1TdHJpa2V0aHJvdWdoRnJvbU1hcmtkb3duLFxuICAgIGdmbVRhYmxlRnJvbU1hcmtkb3duLFxuICAgIGdmbVRhc2tMaXN0SXRlbUZyb21NYXJrZG93blxuICBdXG59XG5cbi8qKlxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtUb01hcmtkb3duRXh0ZW5zaW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtVG9NYXJrZG93bihvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgZXh0ZW5zaW9uczogW1xuICAgICAgZ2ZtQXV0b2xpbmtMaXRlcmFsVG9NYXJrZG93bixcbiAgICAgIGdmbUZvb3Rub3RlVG9NYXJrZG93bigpLFxuICAgICAgZ2ZtU3RyaWtldGhyb3VnaFRvTWFya2Rvd24sXG4gICAgICBnZm1UYWJsZVRvTWFya2Rvd24ob3B0aW9ucyksXG4gICAgICBnZm1UYXNrTGlzdEl0ZW1Ub01hcmtkb3duXG4gICAgXVxuICB9XG59XG4iLCAiLy8gQHRzLWV4cGVjdC1lcnJvclxuaW1wb3J0IGZvcm1hdHRlciBmcm9tICdmb3JtYXQnXG5cbmV4cG9ydCBjb25zdCBmYXVsdCA9IE9iamVjdC5hc3NpZ24oY3JlYXRlKEVycm9yKSwge1xuICBldmFsOiBjcmVhdGUoRXZhbEVycm9yKSxcbiAgcmFuZ2U6IGNyZWF0ZShSYW5nZUVycm9yKSxcbiAgcmVmZXJlbmNlOiBjcmVhdGUoUmVmZXJlbmNlRXJyb3IpLFxuICBzeW50YXg6IGNyZWF0ZShTeW50YXhFcnJvciksXG4gIHR5cGU6IGNyZWF0ZShUeXBlRXJyb3IpLFxuICB1cmk6IGNyZWF0ZShVUklFcnJvcilcbn0pXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGBFQ29uc3RydWN0b3JgLCB3aXRoIHRoZSBmb3JtYXR0ZWQgYGZvcm1hdGAgYXMgYSBmaXJzdCBhcmd1bWVudC5cbiAqXG4gKiBAdGVtcGxhdGUge0Vycm9yfSBGYXVsdFxuICogQHRlbXBsYXRlIHtuZXcgKHJlYXNvbjogc3RyaW5nKSA9PiBGYXVsdH0gQ2xhc3NcbiAqIEBwYXJhbSB7Q2xhc3N9IENvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoQ29uc3RydWN0b3IpIHtcbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgRm9ybWF0dGVkRXJyb3IuZGlzcGxheU5hbWUgPSBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBDb25zdHJ1Y3Rvci5uYW1lXG5cbiAgcmV0dXJuIEZvcm1hdHRlZEVycm9yXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlcnJvciB3aXRoIGEgcHJpbnRmLWxpa2UgZm9ybWF0dGVkIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IFtmb3JtYXRdXG4gICAqICAgVGVtcGxhdGUgc3RyaW5nLlxuICAgKiBAcGFyYW0gey4uLnVua25vd259IHZhbHVlc1xuICAgKiAgIFZhbHVlcyB0byByZW5kZXIgaW4gYGZvcm1hdGAuXG4gICAqIEByZXR1cm5zIHtGYXVsdH1cbiAgICovXG4gIGZ1bmN0aW9uIEZvcm1hdHRlZEVycm9yKGZvcm1hdCwgLi4udmFsdWVzKSB7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgY29uc3QgcmVhc29uID0gZm9ybWF0ID8gZm9ybWF0dGVyKGZvcm1hdCwgLi4udmFsdWVzKSA6IGZvcm1hdFxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IocmVhc29uKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7J3lhbWwnfCd0b21sJ30gUHJlc2V0XG4gKiAgIEVpdGhlciBgJ3lhbWwnYCBvciBgJ3RvbWwnYFxuICpcbiAqIEB0eXBlZGVmIEluZm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvcGVuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2xvc2VcbiAqXG4gKiBAdHlwZWRlZiBNYXR0ZXJQcm9wc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqICAgVHlwZSB0byB0b2tlbml6ZSBhc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbYW55d2hlcmU9ZmFsc2VdXG4gKiAgIElmIGB0cnVlYCwgbWF0dGVyIGNhbiBiZSBmb3VuZCBhbnl3aGVyZSBpbiB0aGUgZG9jdW1lbnQuXG4gKiAgIElmIGBmYWxzZWAgKGRlZmF1bHQpLCBvbmx5IG1hdHRlciBhdCB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50IGlzXG4gKiAgIHJlY29nbml6ZWQuXG4gKlxuICogQHR5cGVkZWYgTWFya2VyUHJvcHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEluZm99IG1hcmtlclxuICogICBDaGFyYWN0ZXIgdXNlZCB0byBjb25zdHJ1Y3QgZmVuY2VzLlxuICogICBCeSBwcm92aWRpbmcgYW4gb2JqZWN0IHdpdGggYG9wZW5gIGFuZCBgY2xvc2VgIGRpZmZlcmVudCBjaGFyYWN0ZXJzIGNhbiBiZVxuICogICB1c2VkIGZvciBvcGVuaW5nIGFuZCBjbG9zaW5nIGZlbmNlcy5cbiAqICAgRm9yIGV4YW1wbGUgdGhlIGNoYXJhY3RlciBgJy0nYCB3aWxsIHJlc3VsdCBpbiBgJy0tLSdgIGJlaW5nIHVzZWQgYXMgdGhlXG4gKiAgIGZlbmNlXG4gKiBAcHJvcGVydHkge25ldmVyfSBbZmVuY2VdXG4gKlxuICogQHR5cGVkZWYgRmVuY2VQcm9wc1xuICogQHByb3BlcnR5IHtzdHJpbmd8SW5mb30gZmVuY2VcbiAqICAgU3RyaW5nIHVzZWQgYXMgdGhlIGNvbXBsZXRlIGZlbmNlLlxuICogICBCeSBwcm92aWRpbmcgYW4gb2JqZWN0IHdpdGggYG9wZW5gIGFuZCBgY2xvc2VgIGRpZmZlcmVudCB2YWx1ZXMgY2FuIGJlIHVzZWRcbiAqICAgZm9yIG9wZW5pbmcgYW5kIGNsb3NpbmcgZmVuY2VzLlxuICogICBUaGlzIGNhbiBiZSB1c2VkIHRvbyBpZiBmZW5jZXMgY29udGFpbiBkaWZmZXJlbnQgY2hhcmFjdGVycyBvciBsZW5ndGhzXG4gKiAgIG90aGVyIHRoYW4gMy5cbiAqIEBwcm9wZXJ0eSB7bmV2ZXJ9IFttYXJrZXJdXG4gKlxuICogQHR5cGVkZWYgeyhNYXR0ZXJQcm9wcyAmIEZlbmNlUHJvcHMpfChNYXR0ZXJQcm9wcyAmIE1hcmtlclByb3BzKX0gTWF0dGVyXG4gKlxuICogQHR5cGVkZWYge1ByZXNldHxNYXR0ZXJ8QXJyYXkuPFByZXNldHxNYXR0ZXI+fSBPcHRpb25zXG4gKi9cbmltcG9ydCB7ZmF1bHR9IGZyb20gJ2ZhdWx0J1xuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcbmNvbnN0IG1hcmtlcnMgPSB7XG4gIHlhbWw6ICctJyxcbiAgdG9tbDogJysnXG59XG4vKipcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnM9J3lhbWwnXVxuICogQHJldHVybnMge0FycmF5PE1hdHRlcj59XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdHRlcnMob3B0aW9ucyA9ICd5YW1sJykge1xuICAvKiogQHR5cGUge0FycmF5PE1hdHRlcj59ICovXG4gIGNvbnN0IHJlc3VsdHMgPSBbXVxuICBsZXQgaW5kZXggPSAtMSAvLyBPbmUgcHJlc2V0IG9yIG1hdHRlci5cblxuICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICBvcHRpb25zID0gW29wdGlvbnNdXG4gIH1cblxuICB3aGlsZSAoKytpbmRleCA8IG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0c1tpbmRleF0gPSBtYXR0ZXIob3B0aW9uc1tpbmRleF0pXG4gIH1cblxuICByZXR1cm4gcmVzdWx0c1xufVxuLyoqXG4gKiBAcGFyYW0ge1ByZXNldHxNYXR0ZXJ9IG9wdGlvblxuICogQHJldHVybnMge01hdHRlcn1cbiAqL1xuXG5mdW5jdGlvbiBtYXR0ZXIob3B0aW9uKSB7XG4gIGxldCByZXN1bHQgPSBvcHRpb25cblxuICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIW93bi5jYWxsKG1hcmtlcnMsIHJlc3VsdCkpIHtcbiAgICAgIHRocm93IGZhdWx0KCdNaXNzaW5nIG1hdHRlciBkZWZpbml0aW9uIGZvciBgJXNgJywgcmVzdWx0KVxuICAgIH1cblxuICAgIHJlc3VsdCA9IHtcbiAgICAgIHR5cGU6IHJlc3VsdCxcbiAgICAgIG1hcmtlcjogbWFya2Vyc1tyZXN1bHRdXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgZmF1bHQoJ0V4cGVjdGVkIG1hdHRlciB0byBiZSBhbiBvYmplY3QsIG5vdCBgJWpgJywgcmVzdWx0KVxuICB9XG5cbiAgaWYgKCFvd24uY2FsbChyZXN1bHQsICd0eXBlJykpIHtcbiAgICB0aHJvdyBmYXVsdCgnTWlzc2luZyBgdHlwZWAgaW4gbWF0dGVyIGAlamAnLCByZXN1bHQpXG4gIH1cblxuICBpZiAoIW93bi5jYWxsKHJlc3VsdCwgJ2ZlbmNlJykgJiYgIW93bi5jYWxsKHJlc3VsdCwgJ21hcmtlcicpKSB7XG4gICAgdGhyb3cgZmF1bHQoJ01pc3NpbmcgYG1hcmtlcmAgb3IgYGZlbmNlYCBpbiBtYXR0ZXIgYCVqYCcsIHJlc3VsdClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXh0ZW5zaW9ufSBFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0UmVjb3JkfSBDb25zdHJ1Y3RSZWNvcmRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0fSBDb25zdHJ1Y3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tYXR0ZXJzLmpzJykuT3B0aW9uc30gT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vbWF0dGVycy5qcycpLk1hdHRlcn0gTWF0dGVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tYXR0ZXJzLmpzJykuSW5mb30gSW5mb1xuICovXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZywgbWFya2Rvd25TcGFjZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuaW1wb3J0IHttYXR0ZXJzfSBmcm9tICcuLi9tYXR0ZXJzLmpzJ1xuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRvIHN1cHBvcnQgZnJvbnRtYXR0ZXIgKFlBTUwsIFRPTUwsIGFuZCBtb3JlKS5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zPSd5YW1sJ10gT25lIHByZXNldCBvciBtYXR0ZXIsIG9yIGFuIGFycmF5IG9mIHRoZW0uXG4gKiBAcmV0dXJucyB7RXh0ZW5zaW9ufVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9udG1hdHRlcihvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gbWF0dGVycyhvcHRpb25zKVxuICAvKiogQHR5cGUge0NvbnN0cnVjdFJlY29yZH0gKi9cblxuICBjb25zdCBmbG93ID0ge31cbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtNYXR0ZXJ9ICovXG5cbiAgbGV0IG1hdHRlclxuICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICBsZXQgY29kZVxuXG4gIHdoaWxlICgrK2luZGV4IDwgc2V0dGluZ3MubGVuZ3RoKSB7XG4gICAgbWF0dGVyID0gc2V0dGluZ3NbaW5kZXhdXG4gICAgY29kZSA9IGZlbmNlKG1hdHRlciwgJ29wZW4nKS5jaGFyQ29kZUF0KDApXG5cbiAgICBpZiAoY29kZSBpbiBmbG93KSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGl0IGNsZWFybHkgZG9lcyBleGlzdC5cbiAgICAgIGZsb3dbY29kZV0ucHVzaChwYXJzZShtYXR0ZXIpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmbG93W2NvZGVdID0gW3BhcnNlKG1hdHRlcildXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmbG93XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtNYXR0ZXJ9IG1hdHRlclxuICogQHJldHVybnMge0NvbnN0cnVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShtYXR0ZXIpIHtcbiAgY29uc3QgbmFtZSA9IG1hdHRlci50eXBlXG4gIGNvbnN0IGFueXdoZXJlID0gbWF0dGVyLmFueXdoZXJlXG4gIGNvbnN0IHZhbHVlVHlwZSA9IG5hbWUgKyAnVmFsdWUnXG4gIGNvbnN0IGZlbmNlVHlwZSA9IG5hbWUgKyAnRmVuY2UnXG4gIGNvbnN0IHNlcXVlbmNlVHlwZSA9IGZlbmNlVHlwZSArICdTZXF1ZW5jZSdcbiAgY29uc3QgZmVuY2VDb25zdHJ1Y3QgPSB7XG4gICAgdG9rZW5pemU6IHRva2VuaXplRmVuY2UsXG4gICAgcGFydGlhbDogdHJ1ZVxuICB9XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXG4gIGxldCBidWZmZXJcbiAgcmV0dXJuIHtcbiAgICB0b2tlbml6ZTogdG9rZW5pemVGcm9udG1hdHRlcixcbiAgICBjb25jcmV0ZTogdHJ1ZVxuICB9XG4gIC8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG4gIGZ1bmN0aW9uIHRva2VuaXplRnJvbnRtYXR0ZXIoZWZmZWN0cywgb2ssIG5vaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgcmV0dXJuIHN0YXJ0XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gc2VsZi5ub3coKVxuXG4gICAgICBpZiAocG9zaXRpb24uY29sdW1uICE9PSAxIHx8ICghYW55d2hlcmUgJiYgcG9zaXRpb24ubGluZSAhPT0gMSkpIHtcbiAgICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgfVxuXG4gICAgICBlZmZlY3RzLmVudGVyKG5hbWUpXG4gICAgICBidWZmZXIgPSBmZW5jZShtYXR0ZXIsICdvcGVuJylcbiAgICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoZmVuY2VDb25zdHJ1Y3QsIGFmdGVyT3BlbmluZ0ZlbmNlLCBub2spKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBhZnRlck9wZW5pbmdGZW5jZShjb2RlKSB7XG4gICAgICBidWZmZXIgPSBmZW5jZShtYXR0ZXIsICdjbG9zZScpXG4gICAgICByZXR1cm4gbGluZUVuZChjb2RlKVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KGNvZGUpIHtcbiAgICAgIGlmIChjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgICByZXR1cm4gbGluZUVuZChjb2RlKVxuICAgICAgfVxuXG4gICAgICBlZmZlY3RzLmVudGVyKHZhbHVlVHlwZSlcbiAgICAgIHJldHVybiBsaW5lRGF0YShjb2RlKVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gbGluZURhdGEoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICAgIGVmZmVjdHMuZXhpdCh2YWx1ZVR5cGUpXG4gICAgICAgIHJldHVybiBsaW5lRW5kKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGxpbmVEYXRhXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKGNvZGUpIHtcbiAgICAgIC8vIFJlcXVpcmUgYSBjbG9zaW5nIGZlbmNlLlxuICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgfSAvLyBDYW4gb25seSBiZSBhbiBlb2wuXG5cbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgICAgcmV0dXJuIGVmZmVjdHMuYXR0ZW1wdChmZW5jZUNvbnN0cnVjdCwgYWZ0ZXIsIGxpbmVTdGFydClcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cblxuICAgIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICAgIGVmZmVjdHMuZXhpdChuYW1lKVxuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuICB9XG4gIC8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuXG4gIGZ1bmN0aW9uIHRva2VuaXplRmVuY2UoZWZmZWN0cywgb2ssIG5vaykge1xuICAgIGxldCBidWZmZXJJbmRleCA9IDBcbiAgICByZXR1cm4gc3RhcnRcbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IGJ1ZmZlci5jaGFyQ29kZUF0KGJ1ZmZlckluZGV4KSkge1xuICAgICAgICBlZmZlY3RzLmVudGVyKGZlbmNlVHlwZSlcbiAgICAgICAgZWZmZWN0cy5lbnRlcihzZXF1ZW5jZVR5cGUpXG4gICAgICAgIHJldHVybiBpbnNpZGVTZXF1ZW5jZShjb2RlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBmdW5jdGlvbiBpbnNpZGVTZXF1ZW5jZShjb2RlKSB7XG4gICAgICBpZiAoYnVmZmVySW5kZXggPT09IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgZWZmZWN0cy5leGl0KHNlcXVlbmNlVHlwZSlcblxuICAgICAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgICAgIGVmZmVjdHMuZW50ZXIoJ3doaXRlc3BhY2UnKVxuICAgICAgICAgIHJldHVybiBpbnNpZGVXaGl0ZXNwYWNlKGNvZGUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmVuY2VFbmQoY29kZSlcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUgPT09IGJ1ZmZlci5jaGFyQ29kZUF0KGJ1ZmZlckluZGV4KyspKSB7XG4gICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgICByZXR1cm4gaW5zaWRlU2VxdWVuY2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gaW5zaWRlV2hpdGVzcGFjZShjb2RlKSB7XG4gICAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgcmV0dXJuIGluc2lkZVdoaXRlc3BhY2VcbiAgICAgIH1cblxuICAgICAgZWZmZWN0cy5leGl0KCd3aGl0ZXNwYWNlJylcbiAgICAgIHJldHVybiBmZW5jZUVuZChjb2RlKVxuICAgIH1cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuXG4gICAgZnVuY3Rpb24gZmVuY2VFbmQoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICAgIGVmZmVjdHMuZXhpdChmZW5jZVR5cGUpXG4gICAgICAgIHJldHVybiBvayhjb2RlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7TWF0dGVyfSBtYXR0ZXJcbiAqIEBwYXJhbSB7J29wZW4nfCdjbG9zZSd9IHByb3BcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZmVuY2UobWF0dGVyLCBwcm9wKSB7XG4gIHJldHVybiBtYXR0ZXIubWFya2VyXG4gICAgPyBwaWNrKG1hdHRlci5tYXJrZXIsIHByb3ApLnJlcGVhdCgzKSAvLyBAdHMtZXhwZWN0LWVycm9yOiBUaGV5XHUyMDE5cmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgIDogcGljayhtYXR0ZXIuZmVuY2UsIHByb3ApXG59XG4vKipcbiAqIEBwYXJhbSB7SW5mb3xzdHJpbmd9IHNjaGVtYVxuICogQHBhcmFtIHsnb3Blbid8J2Nsb3NlJ30gcHJvcFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBwaWNrKHNjaGVtYSwgcHJvcCkge1xuICByZXR1cm4gdHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycgPyBzY2hlbWEgOiBzY2hlbWFbcHJvcF1cbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGl0ZXJhbH0gTGl0ZXJhbFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuRXh0ZW5zaW9ufSBGcm9tTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkhhbmRsZX0gRnJvbU1hcmtkb3duSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi90eXBlcy5qcycpLk9wdGlvbnN9IFRvTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3R5cGVzLmpzJykuSGFuZGxlfSBUb01hcmtkb3duSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2luZGVudC1saW5lcy5qcycpLk1hcH0gTWFwXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLWV4dGVuc2lvbi1mcm9udG1hdHRlci9tYXR0ZXJzLmpzJykuT3B0aW9uc30gT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLWV4dGVuc2lvbi1mcm9udG1hdHRlci9tYXR0ZXJzLmpzJykuTWF0dGVyfSBNYXR0ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay1leHRlbnNpb24tZnJvbnRtYXR0ZXIvbWF0dGVycy5qcycpLkluZm99IEluZm9cbiAqL1xuXG5pbXBvcnQge21hdHRlcnN9IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tZnJvbnRtYXR0ZXIvbWF0dGVycy5qcydcblxuLyoqXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge0Zyb21NYXJrZG93bkV4dGVuc2lvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb250bWF0dGVyRnJvbU1hcmtkb3duKG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBtYXR0ZXJzKG9wdGlvbnMpXG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duRXh0ZW5zaW9uWydlbnRlciddfSAqL1xuICBjb25zdCBlbnRlciA9IHt9XG4gIC8qKiBAdHlwZSB7RnJvbU1hcmtkb3duRXh0ZW5zaW9uWydleGl0J119ICovXG4gIGNvbnN0IGV4aXQgPSB7fVxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgc2V0dGluZ3MubGVuZ3RoKSB7XG4gICAgY29uc3QgbWF0dGVyID0gc2V0dGluZ3NbaW5kZXhdXG4gICAgZW50ZXJbbWF0dGVyLnR5cGVdID0gb3BlbmVyKG1hdHRlcilcbiAgICBleGl0W21hdHRlci50eXBlXSA9IGNsb3NlXG4gICAgZXhpdFttYXR0ZXIudHlwZSArICdWYWx1ZSddID0gdmFsdWVcbiAgfVxuXG4gIHJldHVybiB7ZW50ZXIsIGV4aXR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtNYXR0ZXJ9IG1hdHRlclxuICogQHJldHVybnMge0Zyb21NYXJrZG93bkhhbmRsZX0gZW50ZXJcbiAqL1xuZnVuY3Rpb24gb3BlbmVyKG1hdHRlcikge1xuICByZXR1cm4gb3BlblxuICAvKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbiAgZnVuY3Rpb24gb3Blbih0b2tlbikge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGN1c3RvbS5cbiAgICB0aGlzLmVudGVyKHt0eXBlOiBtYXR0ZXIudHlwZSwgdmFsdWU6ICcnfSwgdG9rZW4pXG4gICAgdGhpcy5idWZmZXIoKVxuICB9XG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gY2xvc2UodG9rZW4pIHtcbiAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgLy8gUmVtb3ZlIHRoZSBpbml0aWFsIGFuZCBmaW5hbCBlb2wuXG4gIHRoaXMuZXhpdCh0b2tlbikudmFsdWUgPSBkYXRhLnJlcGxhY2UoL14oXFxyP1xcbnxcXHIpfChcXHI/XFxufFxccikkL2csICcnKVxufVxuXG4vKiogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX0gKi9cbmZ1bmN0aW9uIHZhbHVlKHRva2VuKSB7XG4gIHRoaXMuY29uZmlnLmVudGVyLmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgdGhpcy5jb25maWcuZXhpdC5kYXRhLmNhbGwodGhpcywgdG9rZW4pXG59XG5cbi8qKlxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtUb01hcmtkb3duRXh0ZW5zaW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbnRtYXR0ZXJUb01hcmtkb3duKG9wdGlvbnMpIHtcbiAgLyoqIEB0eXBlIHtUb01hcmtkb3duRXh0ZW5zaW9uWyd1bnNhZmUnXX0gKi9cbiAgY29uc3QgdW5zYWZlID0gW11cbiAgLyoqIEB0eXBlIHtUb01hcmtkb3duRXh0ZW5zaW9uWydoYW5kbGVycyddfSAqL1xuICBjb25zdCBoYW5kbGVycyA9IHt9XG4gIGNvbnN0IHNldHRpbmdzID0gbWF0dGVycyhvcHRpb25zKVxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgc2V0dGluZ3MubGVuZ3RoKSB7XG4gICAgY29uc3QgbWF0dGVyID0gc2V0dGluZ3NbaW5kZXhdXG4gICAgaGFuZGxlcnNbbWF0dGVyLnR5cGVdID0gaGFuZGxlcihtYXR0ZXIpXG4gICAgdW5zYWZlLnB1c2goe2F0QnJlYWs6IHRydWUsIGNoYXJhY3RlcjogZmVuY2UobWF0dGVyLCAnb3BlbicpLmNoYXJBdCgwKX0pXG4gIH1cblxuICByZXR1cm4ge3Vuc2FmZSwgaGFuZGxlcnN9XG59XG5cbi8qKlxuICogQHBhcmFtIHtNYXR0ZXJ9IG1hdHRlclxuICogQHJldHVybnMgeyhub2RlOiBMaXRlcmFsKSA9PiBzdHJpbmd9IGVudGVyXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZXIobWF0dGVyKSB7XG4gIGNvbnN0IG9wZW4gPSBmZW5jZShtYXR0ZXIsICdvcGVuJylcbiAgY29uc3QgY2xvc2UgPSBmZW5jZShtYXR0ZXIsICdjbG9zZScpXG5cbiAgcmV0dXJuIGhhbmRsZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtMaXRlcmFsfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGUobm9kZSkge1xuICAgIHJldHVybiBvcGVuICsgKG5vZGUudmFsdWUgPyAnXFxuJyArIG5vZGUudmFsdWUgOiAnJykgKyAnXFxuJyArIGNsb3NlXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge01hdHRlcn0gbWF0dGVyXG4gKiBAcGFyYW0geydvcGVuJ3wnY2xvc2UnfSBwcm9wXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmZW5jZShtYXR0ZXIsIHByb3ApIHtcbiAgcmV0dXJuIG1hdHRlci5tYXJrZXJcbiAgICA/IHBpY2sobWF0dGVyLm1hcmtlciwgcHJvcCkucmVwZWF0KDMpXG4gICAgOiAvLyBAdHMtZXhwZWN0LWVycm9yOiBUaGV5XHUyMDE5cmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgICAgcGljayhtYXR0ZXIuZmVuY2UsIHByb3ApXG59XG5cbi8qKlxuICogQHBhcmFtIHtJbmZvfHN0cmluZ30gc2NoZW1hXG4gKiBAcGFyYW0geydvcGVuJ3wnY2xvc2UnfSBwcm9wXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBwaWNrKHNjaGVtYSwgcHJvcCkge1xuICByZXR1cm4gdHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycgPyBzY2hlbWEgOiBzY2hlbWFbcHJvcF1cbn1cbiIsICJpbXBvcnQge0FOVExSSW5wdXRTdHJlYW0sIENvbW1vblRva2VuU3RyZWFtLCBQYXJzZXJSdWxlQ29udGV4dH0gZnJvbSAnYW50bHI0dHMnO1xuaW1wb3J0IHtBYnN0cmFjdFBhcnNlVHJlZVZpc2l0b3J9IGZyb20gJ2FudGxyNHRzL3RyZWUvQWJzdHJhY3RQYXJzZVRyZWVWaXNpdG9yJztcbmltcG9ydCB7VGVybWluYWxOb2RlfSBmcm9tICdhbnRscjR0cy90cmVlL1Rlcm1pbmFsTm9kZSc7XG5pbXBvcnQge1NpbXBsZVRleHRWaXNpdG9yfSBmcm9tICcuL2dyYW1tYXIvU2ltcGxlVGV4dFZpc2l0b3InO1xuaW1wb3J0IHtcblx0RW5kUHVuY3R1YXRpb25Db250ZXh0LFxuXHRFeHByZXNzaW9uQ29udGV4dCwgTWlkUHVuY3R1YXRpb25Db250ZXh0LFxuXHRQYXJhZ3JhcGhDb250ZXh0LCBQcm9wb3NpdGlvbkNvbnRleHQsXG5cdFNlbnRlbmNlQ29udGV4dCxcblx0U2ltcGxlVGV4dFBhcnNlcixcblx0V29yZENvbnRleHQsXG59IGZyb20gJy4vZ3JhbW1hci9TaW1wbGVUZXh0UGFyc2VyJztcbmltcG9ydCB7U2ltcGxlVGV4dExleGVyfSBmcm9tIFwiLi9ncmFtbWFyL1NpbXBsZVRleHRMZXhlclwiO1xuXG5leHBvcnQgdHlwZSBQb3NpdGlvbiA9IHtcblx0bGluZTogbnVtYmVyO1xuXHRjb2x1bW46IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIE5vZGUgPSB7XG5cdHR5cGU6IHN0cmluZztcblx0c3RhcnQ/OiBQb3NpdGlvbjtcblx0ZW5kPzogUG9zaXRpb247XG5cdHRleHQ/OiBzdHJpbmc7XG5cdGNoaWxkcmVuPzogTm9kZVtdO1xufTtcblxuY2xhc3MgQnVpbGRBU1RWaXNpdG9yIGV4dGVuZHMgQWJzdHJhY3RQYXJzZVRyZWVWaXNpdG9yPE5vZGU+IGltcGxlbWVudHMgU2ltcGxlVGV4dFZpc2l0b3I8Tm9kZT4ge1xuXHRkZWZhdWx0UmVzdWx0KCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiAnZGVmYXVsdCcsXG5cdFx0fTtcblx0fVxuXG5cdHZpc2l0UGFyYWdyYXBoKGN0eDogUGFyYWdyYXBoQ29udGV4dCk6IE5vZGUge1xuXHRcdHJldHVybiB0aGlzLnByb2Nlc3NHcm91cChjdHgsICdwYXJhZ3JhcGgnKTtcblx0fVxuXG5cdHZpc2l0U2VudGVuY2UoY3R4OiBTZW50ZW5jZUNvbnRleHQpOiBOb2RlIHtcblx0XHRyZXR1cm4gdGhpcy5wcm9jZXNzR3JvdXAoY3R4LCAnc2VudGVuY2UnKTtcblx0fVxuXG5cdHZpc2l0UHJvcG9zaXRpb24oY3R4OiBQcm9wb3NpdGlvbkNvbnRleHQpOiBOb2RlIHtcblx0XHRyZXR1cm4gdGhpcy5wcm9jZXNzR3JvdXAoY3R4LCAncHJvcG9zaXRpb24nKTtcblx0fVxuXG5cdHZpc2l0RXhwcmVzc2lvbihjdHg6IEV4cHJlc3Npb25Db250ZXh0KTogTm9kZSB7XG5cdFx0cmV0dXJuIHRoaXMucHJvY2Vzc0dyb3VwKGN0eCwgJ2V4cHJlc3Npb24nKTtcblx0fVxuXG5cdHByb2Nlc3NHcm91cChjdHg6IFBhcnNlclJ1bGVDb250ZXh0LCB0eXBlOiBzdHJpbmcpIHtcblx0XHRjb25zdCBjaGlsZHJlbiA9IGN0eC5jaGlsZHJlbj8ubWFwKChjaGlsZCkgPT4gdGhpcy52aXNpdChjaGlsZCkpO1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZU5vZGUoY3R4LCB0eXBlLCBjaGlsZHJlbiA/PyBbXSk7XG5cdH1cblxuXHR2aXNpdFdvcmQoY3R4OiBXb3JkQ29udGV4dCk6IE5vZGUge1xuXHRcdHJldHVybiB0aGlzLnByb2Nlc3NUZXJtaW5hbChjdHgsICd3b3JkJyk7XG5cdH1cblxuXHR2aXNpdEVuZFB1bmN0dWF0aW9uKGN0eDogRW5kUHVuY3R1YXRpb25Db250ZXh0KTogTm9kZSB7XG5cdFx0cmV0dXJuIHRoaXMucHJvY2Vzc1Rlcm1pbmFsKGN0eCwgJ3B1bmN0dWF0aW9uJyk7XG5cdH1cblxuXHR2aXNpdE1pZFB1bmN0dWF0aW9uKGN0eDogTWlkUHVuY3R1YXRpb25Db250ZXh0KTogTm9kZSB7XG5cdFx0cmV0dXJuIHRoaXMucHJvY2Vzc1Rlcm1pbmFsKGN0eCwgJ21pZC1wdW5jdHVhdGlvbicpO1xuXHR9XG5cblx0cHJvY2Vzc1Rlcm1pbmFsKGN0eDogUGFyc2VyUnVsZUNvbnRleHQsIHR5cGU6IHN0cmluZyk6IE5vZGUge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0c3RhcnQ6IHtcblx0XHRcdFx0bGluZTogY3R4LnN0YXJ0LmxpbmUsXG5cdFx0XHRcdGNvbHVtbjogY3R4LnN0YXJ0LmNoYXJQb3NpdGlvbkluTGluZSArIDFcblx0XHRcdH0sXG5cdFx0XHRlbmQ6IHtcblx0XHRcdFx0bGluZTogY3R4LnN0YXJ0LmxpbmUsXG5cdFx0XHRcdGNvbHVtbjogY3R4LnN0YXJ0LmNoYXJQb3NpdGlvbkluTGluZSArIGN0eC50ZXh0Lmxlbmd0aCxcblx0XHRcdH0sXG5cdFx0XHR0ZXh0OiBjdHgudGV4dCxcblx0XHRcdGNoaWxkcmVuOiBbXSxcblx0XHR9O1xuXHR9XG5cblx0Y3JlYXRlTm9kZShjdHg6IFBhcnNlclJ1bGVDb250ZXh0LCB0eXBlOiBzdHJpbmcsIGNoaWxkcmVuOiBOb2RlW10pIHtcblx0XHRjb25zdCBlbmRUb2tlbiA9IGN0eC5zdG9wID8/IGN0eC5zdGFydDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZSxcblx0XHRcdHN0YXJ0OiB7bGluZTogY3R4LnN0YXJ0LmxpbmUsIGNvbHVtbjogMSArIGN0eC5zdGFydC5jaGFyUG9zaXRpb25JbkxpbmV9LFxuXHRcdFx0ZW5kOiB7bGluZTogZW5kVG9rZW4ubGluZSwgY29sdW1uOiBlbmRUb2tlbi5jaGFyUG9zaXRpb25JbkxpbmV9LFxuXHRcdFx0dGV4dDogY3R4LnRleHQsXG5cdFx0XHRjaGlsZHJlbixcblx0XHR9O1xuXHR9XG59XG5cbmZ1bmN0aW9uIGZpeHVwQXN0KG5vZGU6IE5vZGUpIHtcblx0Ly8gRklYTUUgLSBkZXVnbGlmeVxuXHRub2RlLmNoaWxkcmVuPy5mb3JFYWNoKGNoaWxkID0+IGZpeHVwQXN0KGNoaWxkKSk7XG5cdGNvbnN0IGxhc3RDaGlsZCA9IG5vZGUuY2hpbGRyZW4gPyBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cdG5vZGUuZW5kID0gbGFzdENoaWxkPy5lbmQgPz8gbm9kZS5lbmQ7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgU2ltcGxlVGV4dCB7XG5cdGV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0ZXh0OiBzdHJpbmcpOiBOb2RlIHtcblx0XHQvLyBDcmVhdGUgdGhlIGxleGVyIGFuZCBwYXJzZXJcblx0XHRjb25zdCBpbnB1dFN0cmVhbSA9IG5ldyBBTlRMUklucHV0U3RyZWFtKHRleHQpO1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IFNpbXBsZVRleHRMZXhlcihpbnB1dFN0cmVhbSk7XG5cdFx0Y29uc3QgdG9rZW5TdHJlYW0gPSBuZXcgQ29tbW9uVG9rZW5TdHJlYW0obGV4ZXIpO1xuXHRcdGNvbnN0IHBhcnNlciA9IG5ldyBTaW1wbGVUZXh0UGFyc2VyKHRva2VuU3RyZWFtKTtcblxuXHRcdC8vIGxldCB0aGUgQU5UTFIgZ2VuZXJhdGVkIHBhcnNlciBwYXJzZVxuXHRcdGNvbnN0IHRyZWUgPSBwYXJzZXIucGFyYWdyYXBoKCk7XG5cblx0XHQvLyBjb25zdHJ1Y3QgYW4gQVNUXG5cdFx0Y29uc3QgYnVpbGRlciA9IG5ldyBCdWlsZEFTVFZpc2l0b3IoKTtcblx0XHRjb25zdCBhc3QgPSBidWlsZGVyLnZpc2l0KHRyZWUpO1xuXG5cdFx0Zml4dXBBc3QoYXN0KTtcblxuXHRcdHJldHVybiBhc3Q7XG5cdH1cbn1cbiIsICIvLyBHZW5lcmF0ZWQgZnJvbSBncmFtbWFyL1NpbXBsZVRleHQuZzQgYnkgQU5UTFIgNC45LjAtU05BUFNIT1RcblxuXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiYW50bHI0dHMvYXRuL0FUTlwiO1xuaW1wb3J0IHsgQVRORGVzZXJpYWxpemVyIH0gZnJvbSBcImFudGxyNHRzL2F0bi9BVE5EZXNlcmlhbGl6ZXJcIjtcbmltcG9ydCB7IEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbiB9IGZyb20gXCJhbnRscjR0cy9GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb25cIjtcbmltcG9ydCB7IE5vdE51bGwgfSBmcm9tIFwiYW50bHI0dHMvRGVjb3JhdG9yc1wiO1xuaW1wb3J0IHsgTm9WaWFibGVBbHRFeGNlcHRpb24gfSBmcm9tIFwiYW50bHI0dHMvTm9WaWFibGVBbHRFeGNlcHRpb25cIjtcbmltcG9ydCB7IE92ZXJyaWRlIH0gZnJvbSBcImFudGxyNHRzL0RlY29yYXRvcnNcIjtcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gXCJhbnRscjR0cy9QYXJzZXJcIjtcbmltcG9ydCB7IFBhcnNlclJ1bGVDb250ZXh0IH0gZnJvbSBcImFudGxyNHRzL1BhcnNlclJ1bGVDb250ZXh0XCI7XG5pbXBvcnQgeyBQYXJzZXJBVE5TaW11bGF0b3IgfSBmcm9tIFwiYW50bHI0dHMvYXRuL1BhcnNlckFUTlNpbXVsYXRvclwiO1xuaW1wb3J0IHsgUGFyc2VUcmVlTGlzdGVuZXIgfSBmcm9tIFwiYW50bHI0dHMvdHJlZS9QYXJzZVRyZWVMaXN0ZW5lclwiO1xuaW1wb3J0IHsgUGFyc2VUcmVlVmlzaXRvciB9IGZyb20gXCJhbnRscjR0cy90cmVlL1BhcnNlVHJlZVZpc2l0b3JcIjtcbmltcG9ydCB7IFJlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcImFudGxyNHRzL1JlY29nbml0aW9uRXhjZXB0aW9uXCI7XG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCJhbnRscjR0cy9SdWxlQ29udGV4dFwiO1xuLy9pbXBvcnQgeyBSdWxlVmVyc2lvbiB9IGZyb20gXCJhbnRscjR0cy9SdWxlVmVyc2lvblwiO1xuaW1wb3J0IHsgVGVybWluYWxOb2RlIH0gZnJvbSBcImFudGxyNHRzL3RyZWUvVGVybWluYWxOb2RlXCI7XG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCJhbnRscjR0cy9Ub2tlblwiO1xuaW1wb3J0IHsgVG9rZW5TdHJlYW0gfSBmcm9tIFwiYW50bHI0dHMvVG9rZW5TdHJlYW1cIjtcbmltcG9ydCB7IFZvY2FidWxhcnkgfSBmcm9tIFwiYW50bHI0dHMvVm9jYWJ1bGFyeVwiO1xuaW1wb3J0IHsgVm9jYWJ1bGFyeUltcGwgfSBmcm9tIFwiYW50bHI0dHMvVm9jYWJ1bGFyeUltcGxcIjtcblxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcImFudGxyNHRzL21pc2MvVXRpbHNcIjtcblxuaW1wb3J0IHsgU2ltcGxlVGV4dExpc3RlbmVyIH0gZnJvbSBcIi4vU2ltcGxlVGV4dExpc3RlbmVyXCI7XG5pbXBvcnQgeyBTaW1wbGVUZXh0VmlzaXRvciB9IGZyb20gXCIuL1NpbXBsZVRleHRWaXNpdG9yXCI7XG5cblxuZXhwb3J0IGNsYXNzIFNpbXBsZVRleHRQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFdvcmQgPSAxO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNtaWxleSA9IDI7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVXJsID0gMztcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBET1QgPSA0O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFFVRVNUSU9OX01BUksgPSA1O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEVYQ0xBTUFUSU9OX01BUksgPSA2O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExQQVJFTiA9IDc7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUlBBUkVOID0gODtcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBMQUNDT0wgPSA5O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJBQ0NPTCA9IDEwO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExCUkFDSyA9IDExO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJCUkFDSyA9IDEyO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFFVT1RFID0gMTM7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRFFVT1RFID0gMTQ7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQ09MT04gPSAxNTtcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBDT01NQSA9IDE2O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNFTUlDT0xPTiA9IDE3O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNNSUxFWSA9IDE4O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFdTID0gMTk7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUlVMRV9wYXJhZ3JhcGggPSAwO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJVTEVfc2VudGVuY2UgPSAxO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJVTEVfcHJvcG9zaXRpb24gPSAyO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJVTEVfbWlkUHVuY3R1YXRpb24gPSAzO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJVTEVfZW5kUHVuY3R1YXRpb24gPSA0O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJVTEVfd29yZCA9IDU7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUlVMRV9leHByZXNzaW9uID0gNjtcblx0Ly8gdHNsaW50OmRpc2FibGU6bm8tdHJhaWxpbmctd2hpdGVzcGFjZVxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHJ1bGVOYW1lczogc3RyaW5nW10gPSBbXG5cdFx0XCJwYXJhZ3JhcGhcIiwgXCJzZW50ZW5jZVwiLCBcInByb3Bvc2l0aW9uXCIsIFwibWlkUHVuY3R1YXRpb25cIiwgXCJlbmRQdW5jdHVhdGlvblwiLCBcblx0XHRcIndvcmRcIiwgXCJleHByZXNzaW9uXCIsXG5cdF07XG5cblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgX0xJVEVSQUxfTkFNRVM6IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZD4gPSBbXG5cdFx0dW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIicuJ1wiLCBcIic/J1wiLCBcIichJ1wiLCBcIicoJ1wiLCBcblx0XHRcIicpJ1wiLCBcIid7J1wiLCBcIid9J1wiLCBcIidbJ1wiLCBcIiddJ1wiLCB1bmRlZmluZWQsIFwiJ1xcXCInXCIsIFwiJzonXCIsIFwiJywnXCIsIFwiJzsnXCIsXG5cdF07XG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IF9TWU1CT0xJQ19OQU1FUzogQXJyYXk8c3RyaW5nIHwgdW5kZWZpbmVkPiA9IFtcblx0XHR1bmRlZmluZWQsIFwiV29yZFwiLCBcIlNtaWxleVwiLCBcIlVybFwiLCBcIkRPVFwiLCBcIlFVRVNUSU9OX01BUktcIiwgXCJFWENMQU1BVElPTl9NQVJLXCIsIFxuXHRcdFwiTFBBUkVOXCIsIFwiUlBBUkVOXCIsIFwiTEFDQ09MXCIsIFwiUkFDQ09MXCIsIFwiTEJSQUNLXCIsIFwiUkJSQUNLXCIsIFwiUVVPVEVcIiwgXCJEUVVPVEVcIiwgXG5cdFx0XCJDT0xPTlwiLCBcIkNPTU1BXCIsIFwiU0VNSUNPTE9OXCIsIFwiU01JTEVZXCIsIFwiV1NcIixcblx0XTtcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBWT0NBQlVMQVJZOiBWb2NhYnVsYXJ5ID0gbmV3IFZvY2FidWxhcnlJbXBsKFNpbXBsZVRleHRQYXJzZXIuX0xJVEVSQUxfTkFNRVMsIFNpbXBsZVRleHRQYXJzZXIuX1NZTUJPTElDX05BTUVTLCBbXSk7XG5cblx0Ly8gQE92ZXJyaWRlXG5cdC8vIEBOb3ROdWxsXG5cdHB1YmxpYyBnZXQgdm9jYWJ1bGFyeSgpOiBWb2NhYnVsYXJ5IHtcblx0XHRyZXR1cm4gU2ltcGxlVGV4dFBhcnNlci5WT0NBQlVMQVJZO1xuXHR9XG5cdC8vIHRzbGludDplbmFibGU6bm8tdHJhaWxpbmctd2hpdGVzcGFjZVxuXG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZ2V0IGdyYW1tYXJGaWxlTmFtZSgpOiBzdHJpbmcgeyByZXR1cm4gXCJTaW1wbGVUZXh0Lmc0XCI7IH1cblxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBydWxlTmFtZXMoKTogc3RyaW5nW10geyByZXR1cm4gU2ltcGxlVGV4dFBhcnNlci5ydWxlTmFtZXM7IH1cblxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBzZXJpYWxpemVkQVROKCk6IHN0cmluZyB7IHJldHVybiBTaW1wbGVUZXh0UGFyc2VyLl9zZXJpYWxpemVkQVROOyB9XG5cblx0cHJvdGVjdGVkIGNyZWF0ZUZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbihwcmVkaWNhdGU/OiBzdHJpbmcsIG1lc3NhZ2U/OiBzdHJpbmcpOiBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24ge1xuXHRcdHJldHVybiBuZXcgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIHByZWRpY2F0ZSwgbWVzc2FnZSk7XG5cdH1cblxuXHRjb25zdHJ1Y3RvcihpbnB1dDogVG9rZW5TdHJlYW0pIHtcblx0XHRzdXBlcihpbnB1dCk7XG5cdFx0dGhpcy5faW50ZXJwID0gbmV3IFBhcnNlckFUTlNpbXVsYXRvcihTaW1wbGVUZXh0UGFyc2VyLl9BVE4sIHRoaXMpO1xuXHR9XG5cdC8vIEBSdWxlVmVyc2lvbigwKVxuXHRwdWJsaWMgcGFyYWdyYXBoKCk6IFBhcmFncmFwaENvbnRleHQge1xuXHRcdGxldCBfbG9jYWxjdHg6IFBhcmFncmFwaENvbnRleHQgPSBuZXcgUGFyYWdyYXBoQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHRcdHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMCwgU2ltcGxlVGV4dFBhcnNlci5SVUxFX3BhcmFncmFwaCk7XG5cdFx0bGV0IF9sYTogbnVtYmVyO1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcblx0XHRcdHtcblx0XHRcdHRoaXMuc3RhdGUgPSAxNztcblx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHRcdFx0d2hpbGUgKCgoKF9sYSkgJiB+MHgxRikgPT09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5Xb3JkKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuU21pbGV5KSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuVXJsKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuTFBBUkVOKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuTEFDQ09MKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuTEJSQUNLKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuUVVPVEUpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5EUVVPVEUpKSkgIT09IDApKSB7XG5cdFx0XHRcdHtcblx0XHRcdFx0e1xuXHRcdFx0XHR0aGlzLnN0YXRlID0gMTQ7XG5cdFx0XHRcdHRoaXMuc2VudGVuY2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSAxOTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0XHRfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc3RhdGUgPSAyMDtcblx0XHRcdHRoaXMubWF0Y2goU2ltcGxlVGV4dFBhcnNlci5FT0YpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAocmUpIHtcblx0XHRcdGlmIChyZSBpbnN0YW5jZW9mIFJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0XHRcdF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyByZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHR0aGlzLmV4aXRSdWxlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfbG9jYWxjdHg7XG5cdH1cblx0Ly8gQFJ1bGVWZXJzaW9uKDApXG5cdHB1YmxpYyBzZW50ZW5jZSgpOiBTZW50ZW5jZUNvbnRleHQge1xuXHRcdGxldCBfbG9jYWxjdHg6IFNlbnRlbmNlQ29udGV4dCA9IG5ldyBTZW50ZW5jZUNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcblx0XHR0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDIsIFNpbXBsZVRleHRQYXJzZXIuUlVMRV9zZW50ZW5jZSk7XG5cdFx0bGV0IF9sYTogbnVtYmVyO1xuXHRcdHRyeSB7XG5cdFx0XHRsZXQgX2FsdDogbnVtYmVyO1xuXHRcdFx0dGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG5cdFx0XHR7XG5cdFx0XHR0aGlzLnN0YXRlID0gMjM7XG5cdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRfYWx0ID0gMTtcblx0XHRcdGRvIHtcblx0XHRcdFx0c3dpdGNoIChfYWx0KSB7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUgPSAyMjtcblx0XHRcdFx0XHR0aGlzLnByb3Bvc2l0aW9uKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDI1O1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRcdF9hbHQgPSB0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgMSwgdGhpcy5fY3R4KTtcblx0XHRcdH0gd2hpbGUgKF9hbHQgIT09IDIgJiYgX2FsdCAhPT0gQVROLklOVkFMSURfQUxUX05VTUJFUik7XG5cdFx0XHR0aGlzLnN0YXRlID0gMjg7XG5cdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0XHRcdGlmICgoKChfbGEpICYgfjB4MUYpID09PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IFNpbXBsZVRleHRQYXJzZXIuRE9UKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuUVVFU1RJT05fTUFSSykgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkVYQ0xBTUFUSU9OX01BUkspKSkgIT09IDApKSB7XG5cdFx0XHRcdHtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDI3O1xuXHRcdFx0XHR0aGlzLmVuZFB1bmN0dWF0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAocmUpIHtcblx0XHRcdGlmIChyZSBpbnN0YW5jZW9mIFJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0XHRcdF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyByZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHR0aGlzLmV4aXRSdWxlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfbG9jYWxjdHg7XG5cdH1cblx0Ly8gQFJ1bGVWZXJzaW9uKDApXG5cdHB1YmxpYyBwcm9wb3NpdGlvbigpOiBQcm9wb3NpdGlvbkNvbnRleHQge1xuXHRcdGxldCBfbG9jYWxjdHg6IFByb3Bvc2l0aW9uQ29udGV4dCA9IG5ldyBQcm9wb3NpdGlvbkNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcblx0XHR0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDQsIFNpbXBsZVRleHRQYXJzZXIuUlVMRV9wcm9wb3NpdGlvbik7XG5cdFx0bGV0IF9sYTogbnVtYmVyO1xuXHRcdHRyeSB7XG5cdFx0XHRsZXQgX2FsdDogbnVtYmVyO1xuXHRcdFx0dGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG5cdFx0XHR7XG5cdFx0XHR0aGlzLnN0YXRlID0gMzI7XG5cdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRfYWx0ID0gMTtcblx0XHRcdGRvIHtcblx0XHRcdFx0c3dpdGNoIChfYWx0KSB7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDMyO1xuXHRcdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0XHRzd2l0Y2ggKHRoaXMuX2lucHV0LkxBKDEpKSB7XG5cdFx0XHRcdFx0Y2FzZSBTaW1wbGVUZXh0UGFyc2VyLldvcmQ6XG5cdFx0XHRcdFx0Y2FzZSBTaW1wbGVUZXh0UGFyc2VyLlNtaWxleTpcblx0XHRcdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuVXJsOlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDMwO1xuXHRcdFx0XHRcdFx0dGhpcy53b3JkKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuTFBBUkVOOlxuXHRcdFx0XHRcdGNhc2UgU2ltcGxlVGV4dFBhcnNlci5MQUNDT0w6XG5cdFx0XHRcdFx0Y2FzZSBTaW1wbGVUZXh0UGFyc2VyLkxCUkFDSzpcblx0XHRcdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuUVVPVEU6XG5cdFx0XHRcdFx0Y2FzZSBTaW1wbGVUZXh0UGFyc2VyLkRRVU9URTpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUgPSAzMTtcblx0XHRcdFx0XHRcdHRoaXMuZXhwcmVzc2lvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHRocm93IG5ldyBOb1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBOb1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnN0YXRlID0gMzQ7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0X2FsdCA9IHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCA0LCB0aGlzLl9jdHgpO1xuXHRcdFx0fSB3aGlsZSAoX2FsdCAhPT0gMiAmJiBfYWx0ICE9PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSKTtcblx0XHRcdHRoaXMuc3RhdGUgPSAzNztcblx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHRcdFx0aWYgKCgoKF9sYSkgJiB+MHgxRikgPT09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5DT0xPTikgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkNPTU1BKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuU0VNSUNPTE9OKSkpICE9PSAwKSkge1xuXHRcdFx0XHR7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSAzNjtcblx0XHRcdFx0dGhpcy5taWRQdW5jdHVhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cdFx0Y2F0Y2ggKHJlKSB7XG5cdFx0XHRpZiAocmUgaW5zdGFuY2VvZiBSZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuXHRcdFx0XHRfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgcmU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0dGhpcy5leGl0UnVsZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gX2xvY2FsY3R4O1xuXHR9XG5cdC8vIEBSdWxlVmVyc2lvbigwKVxuXHRwdWJsaWMgbWlkUHVuY3R1YXRpb24oKTogTWlkUHVuY3R1YXRpb25Db250ZXh0IHtcblx0XHRsZXQgX2xvY2FsY3R4OiBNaWRQdW5jdHVhdGlvbkNvbnRleHQgPSBuZXcgTWlkUHVuY3R1YXRpb25Db250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG5cdFx0dGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA2LCBTaW1wbGVUZXh0UGFyc2VyLlJVTEVfbWlkUHVuY3R1YXRpb24pO1xuXHRcdGxldCBfbGE6IG51bWJlcjtcblx0XHR0cnkge1xuXHRcdFx0dGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG5cdFx0XHR7XG5cdFx0XHR0aGlzLnN0YXRlID0gMzk7XG5cdFx0XHRfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0XHRcdGlmICghKCgoKF9sYSkgJiB+MHgxRikgPT09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5DT0xPTikgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkNPTU1BKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuU0VNSUNPTE9OKSkpICE9PSAwKSkpIHtcblx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9pbnB1dC5MQSgxKSA9PT0gVG9rZW4uRU9GKSB7XG5cdFx0XHRcdFx0dGhpcy5tYXRjaGVkRU9GID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG5cdFx0XHRcdHRoaXMuY29uc3VtZSgpO1xuXHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAocmUpIHtcblx0XHRcdGlmIChyZSBpbnN0YW5jZW9mIFJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0XHRcdF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyByZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHR0aGlzLmV4aXRSdWxlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfbG9jYWxjdHg7XG5cdH1cblx0Ly8gQFJ1bGVWZXJzaW9uKDApXG5cdHB1YmxpYyBlbmRQdW5jdHVhdGlvbigpOiBFbmRQdW5jdHVhdGlvbkNvbnRleHQge1xuXHRcdGxldCBfbG9jYWxjdHg6IEVuZFB1bmN0dWF0aW9uQ29udGV4dCA9IG5ldyBFbmRQdW5jdHVhdGlvbkNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcblx0XHR0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDgsIFNpbXBsZVRleHRQYXJzZXIuUlVMRV9lbmRQdW5jdHVhdGlvbik7XG5cdFx0bGV0IF9sYTogbnVtYmVyO1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLnN0YXRlID0gNDg7XG5cdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRzd2l0Y2ggKHRoaXMuX2lucHV0LkxBKDEpKSB7XG5cdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuRE9UOlxuXHRcdFx0XHR0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcblx0XHRcdFx0e1xuXHRcdFx0XHR0aGlzLnN0YXRlID0gNDI7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0X2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUgPSA0MTtcblx0XHRcdFx0XHR0aGlzLm1hdGNoKFNpbXBsZVRleHRQYXJzZXIuRE9UKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuc3RhdGUgPSA0NDtcblx0XHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRcdFx0X2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdFx0XHRcdH0gd2hpbGUgKF9sYSA9PT0gU2ltcGxlVGV4dFBhcnNlci5ET1QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBTaW1wbGVUZXh0UGFyc2VyLlFVRVNUSU9OX01BUks6XG5cdFx0XHRcdHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDIpO1xuXHRcdFx0XHR7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA0Njtcblx0XHRcdFx0dGhpcy5tYXRjaChTaW1wbGVUZXh0UGFyc2VyLlFVRVNUSU9OX01BUkspO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBTaW1wbGVUZXh0UGFyc2VyLkVYQ0xBTUFUSU9OX01BUks6XG5cdFx0XHRcdHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDMpO1xuXHRcdFx0XHR7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA0Nztcblx0XHRcdFx0dGhpcy5tYXRjaChTaW1wbGVUZXh0UGFyc2VyLkVYQ0xBTUFUSU9OX01BUkspO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IE5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAocmUpIHtcblx0XHRcdGlmIChyZSBpbnN0YW5jZW9mIFJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0XHRcdF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyByZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHR0aGlzLmV4aXRSdWxlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfbG9jYWxjdHg7XG5cdH1cblx0Ly8gQFJ1bGVWZXJzaW9uKDApXG5cdHB1YmxpYyB3b3JkKCk6IFdvcmRDb250ZXh0IHtcblx0XHRsZXQgX2xvY2FsY3R4OiBXb3JkQ29udGV4dCA9IG5ldyBXb3JkQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuXHRcdHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTAsIFNpbXBsZVRleHRQYXJzZXIuUlVMRV93b3JkKTtcblx0XHRsZXQgX2xhOiBudW1iZXI7XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuXHRcdFx0e1xuXHRcdFx0dGhpcy5zdGF0ZSA9IDUwO1xuXHRcdFx0X2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdFx0XHRpZiAoISgoKChfbGEpICYgfjB4MUYpID09PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IFNpbXBsZVRleHRQYXJzZXIuV29yZCkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLlNtaWxleSkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLlVybCkpKSAhPT0gMCkpKSB7XG5cdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5faW5wdXQuTEEoMSkgPT09IFRva2VuLkVPRikge1xuXHRcdFx0XHRcdHRoaXMubWF0Y2hlZEVPRiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuXHRcdFx0XHR0aGlzLmNvbnN1bWUoKTtcblx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Y2F0Y2ggKHJlKSB7XG5cdFx0XHRpZiAocmUgaW5zdGFuY2VvZiBSZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuXHRcdFx0XHRfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgcmU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0dGhpcy5leGl0UnVsZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gX2xvY2FsY3R4O1xuXHR9XG5cdC8vIEBSdWxlVmVyc2lvbigwKVxuXHRwdWJsaWMgZXhwcmVzc2lvbigpOiBFeHByZXNzaW9uQ29udGV4dCB7XG5cdFx0bGV0IF9sb2NhbGN0eDogRXhwcmVzc2lvbkNvbnRleHQgPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcblx0XHR0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDEyLCBTaW1wbGVUZXh0UGFyc2VyLlJVTEVfZXhwcmVzc2lvbik7XG5cdFx0bGV0IF9sYTogbnVtYmVyO1xuXHRcdHRyeSB7XG5cdFx0XHRsZXQgX2FsdDogbnVtYmVyO1xuXHRcdFx0dGhpcy5zdGF0ZSA9IDkyO1xuXHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0c3dpdGNoICh0aGlzLl9pbnB1dC5MQSgxKSkge1xuXHRcdFx0Y2FzZSBTaW1wbGVUZXh0UGFyc2VyLkxQQVJFTjpcblx0XHRcdFx0dGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG5cdFx0XHRcdHtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDUyO1xuXHRcdFx0XHR0aGlzLm1hdGNoKFNpbXBsZVRleHRQYXJzZXIuTFBBUkVOKTtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDU2O1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRcdF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHRcdFx0XHR3aGlsZSAoKCgoX2xhKSAmIH4weDFGKSA9PT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLldvcmQpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5TbWlsZXkpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5VcmwpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5MUEFSRU4pIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5MQUNDT0wpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5MQlJBQ0spIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5RVU9URSkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkRRVU9URSkpKSAhPT0gMCkpIHtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUgPSA1Mztcblx0XHRcdFx0XHR0aGlzLnNlbnRlbmNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnN0YXRlID0gNTg7XG5cdFx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0XHRcdF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA1OTtcblx0XHRcdFx0dGhpcy5tYXRjaChTaW1wbGVUZXh0UGFyc2VyLlJQQVJFTik7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuUVVPVEU6XG5cdFx0XHRcdHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDIpO1xuXHRcdFx0XHR7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA2MDtcblx0XHRcdFx0dGhpcy5tYXRjaChTaW1wbGVUZXh0UGFyc2VyLlFVT1RFKTtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDY0O1xuXHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRcdF9hbHQgPSB0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgOSwgdGhpcy5fY3R4KTtcblx0XHRcdFx0d2hpbGUgKF9hbHQgIT09IDIgJiYgX2FsdCAhPT0gQVROLklOVkFMSURfQUxUX05VTUJFUikge1xuXHRcdFx0XHRcdGlmIChfYWx0ID09PSAxKSB7XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlID0gNjE7XG5cdFx0XHRcdFx0XHR0aGlzLnNlbnRlbmNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuc3RhdGUgPSA2Njtcblx0XHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRcdFx0X2FsdCA9IHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCA5LCB0aGlzLl9jdHgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA2Nztcblx0XHRcdFx0dGhpcy5tYXRjaChTaW1wbGVUZXh0UGFyc2VyLlFVT1RFKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgU2ltcGxlVGV4dFBhcnNlci5EUVVPVEU6XG5cdFx0XHRcdHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDMpO1xuXHRcdFx0XHR7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA2ODtcblx0XHRcdFx0dGhpcy5tYXRjaChTaW1wbGVUZXh0UGFyc2VyLkRRVU9URSk7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA3Mjtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0XHRfYWx0ID0gdGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDEwLCB0aGlzLl9jdHgpO1xuXHRcdFx0XHR3aGlsZSAoX2FsdCAhPT0gMiAmJiBfYWx0ICE9PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG5cdFx0XHRcdFx0aWYgKF9hbHQgPT09IDEpIHtcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUgPSA2OTtcblx0XHRcdFx0XHRcdHRoaXMuc2VudGVuY2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDc0O1xuXHRcdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0XHRfYWx0ID0gdGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDEwLCB0aGlzLl9jdHgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA3NTtcblx0XHRcdFx0dGhpcy5tYXRjaChTaW1wbGVUZXh0UGFyc2VyLkRRVU9URSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFNpbXBsZVRleHRQYXJzZXIuTEJSQUNLOlxuXHRcdFx0XHR0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCA0KTtcblx0XHRcdFx0e1xuXHRcdFx0XHR0aGlzLnN0YXRlID0gNzY7XG5cdFx0XHRcdHRoaXMubWF0Y2goU2ltcGxlVGV4dFBhcnNlci5MQlJBQ0spO1xuXHRcdFx0XHR0aGlzLnN0YXRlID0gODA7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0X2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdFx0XHRcdHdoaWxlICgoKChfbGEpICYgfjB4MUYpID09PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IFNpbXBsZVRleHRQYXJzZXIuV29yZCkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLlNtaWxleSkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLlVybCkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkxQQVJFTikgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkxBQ0NPTCkgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLkxCUkFDSykgfCAoMSA8PCBTaW1wbGVUZXh0UGFyc2VyLlFVT1RFKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuRFFVT1RFKSkpICE9PSAwKSkge1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDc3O1xuXHRcdFx0XHRcdHRoaXMuc2VudGVuY2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuc3RhdGUgPSA4Mjtcblx0XHRcdFx0XHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG5cdFx0XHRcdFx0X2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zdGF0ZSA9IDgzO1xuXHRcdFx0XHR0aGlzLm1hdGNoKFNpbXBsZVRleHRQYXJzZXIuUkJSQUNLKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgU2ltcGxlVGV4dFBhcnNlci5MQUNDT0w6XG5cdFx0XHRcdHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDUpO1xuXHRcdFx0XHR7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA4NDtcblx0XHRcdFx0dGhpcy5tYXRjaChTaW1wbGVUZXh0UGFyc2VyLkxBQ0NPTCk7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSA4ODtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuXHRcdFx0XHRfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0XHRcdFx0d2hpbGUgKCgoKF9sYSkgJiB+MHgxRikgPT09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5Xb3JkKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuU21pbGV5KSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuVXJsKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuTFBBUkVOKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuTEFDQ09MKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuTEJSQUNLKSB8ICgxIDw8IFNpbXBsZVRleHRQYXJzZXIuUVVPVEUpIHwgKDEgPDwgU2ltcGxlVGV4dFBhcnNlci5EUVVPVEUpKSkgIT09IDApKSB7XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnN0YXRlID0gODU7XG5cdFx0XHRcdFx0dGhpcy5zZW50ZW5jZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IDkwO1xuXHRcdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcblx0XHRcdFx0XHRfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnN0YXRlID0gOTE7XG5cdFx0XHRcdHRoaXMubWF0Y2goU2ltcGxlVGV4dFBhcnNlci5SQUNDT0wpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IE5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAocmUpIHtcblx0XHRcdGlmIChyZSBpbnN0YW5jZW9mIFJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG5cdFx0XHRcdF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcblx0XHRcdFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG5cdFx0XHRcdHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyByZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHR0aGlzLmV4aXRSdWxlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfbG9jYWxjdHg7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IF9zZXJpYWxpemVkQVROOiBzdHJpbmcgPVxuXHRcdFwiXFx4MDNcXHVDOTFEXFx1Q0FCQVxcdTA1OERcXHVBRkJBXFx1NEY1M1xcdTA2MDdcXHVFQThCXFx1QzI0MVxceDAzXFx4MTVhXFx4MDRcXHgwMlwiICtcblx0XHRcIlxcdFxceDAyXFx4MDRcXHgwM1xcdFxceDAzXFx4MDRcXHgwNFxcdFxceDA0XFx4MDRcXHgwNVxcdFxceDA1XFx4MDRcXHgwNlxcdFxceDA2XFx4MDRcXHgwN1wiICtcblx0XHRcIlxcdFxceDA3XFx4MDRcXGJcXHRcXGJcXHgwM1xceDAyXFx4MDdcXHgwMlxceDEyXFxuXFx4MDJcXGZcXHgwMlxceDBFXFx4MDJcXHgxNVxcdlxceDAyXFx4MDNcIiArXG5cdFx0XCJcXHgwMlxceDAzXFx4MDJcXHgwM1xceDAzXFx4MDZcXHgwM1xceDFBXFxuXFx4MDNcXHJcXHgwM1xceDBFXFx4MDNcXHgxQlxceDAzXFx4MDNcXHgwNVxceDAzXCIgK1xuXHRcdFwiXFx4MUZcXG5cXHgwM1xceDAzXFx4MDRcXHgwM1xceDA0XFx4MDZcXHgwNCNcXG5cXHgwNFxcclxceDA0XFx4MEVcXHgwNCRcXHgwM1xceDA0XFx4MDVcXHgwNFwiICtcblx0XHRcIihcXG5cXHgwNFxceDAzXFx4MDVcXHgwM1xceDA1XFx4MDNcXHgwNlxceDA2XFx4MDYtXFxuXFx4MDZcXHJcXHgwNlxceDBFXFx4MDYuXFx4MDNcXHgwNlwiICtcblx0XHRcIlxceDAzXFx4MDZcXHgwNVxceDA2M1xcblxceDA2XFx4MDNcXHgwN1xceDAzXFx4MDdcXHgwM1xcYlxceDAzXFxiXFx4MDdcXGI5XFxuXFxiXFxmXFxiXFx4MEVcIiArXG5cdFx0XCJcXGI8XFx2XFxiXFx4MDNcXGJcXHgwM1xcYlxceDAzXFxiXFx4MDdcXGJBXFxuXFxiXFxmXFxiXFx4MEVcXGJEXFx2XFxiXFx4MDNcXGJcXHgwM1xcYlxceDAzXFxiXCIgK1xuXHRcdFwiXFx4MDdcXGJJXFxuXFxiXFxmXFxiXFx4MEVcXGJMXFx2XFxiXFx4MDNcXGJcXHgwM1xcYlxceDAzXFxiXFx4MDdcXGJRXFxuXFxiXFxmXFxiXFx4MEVcXGJUXFx2XFxiXCIgK1xuXHRcdFwiXFx4MDNcXGJcXHgwM1xcYlxceDAzXFxiXFx4MDdcXGJZXFxuXFxiXFxmXFxiXFx4MEVcXGJcXFxcXFx2XFxiXFx4MDNcXGJcXHgwNVxcYl9cXG5cXGJcXHgwM1xcYlxceDAyXCIgK1xuXHRcdFwiXFx4MDJcXHgwMlxcdFxceDAyXFx4MDJcXHgwNFxceDAyXFx4MDZcXHgwMlxcYlxceDAyXFxuXFx4MDJcXGZcXHgwMlxceDBFXFx4MDJcXHgwMlxceDA0XFx4MDNcIiArXG5cdFx0XCJcXHgwMlxceDExXFx4MTNcXHgwM1xceDAyXFx4MDNcXHgwNVxceDAya1xceDAyXFx4MTNcXHgwM1xceDAyXFx4MDJcXHgwMlxceDA0XFx4MTlcXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MDJcXHgwMlxceDA2XFxcIlxceDAzXFx4MDJcXHgwMlxceDAyXFxiKVxceDAzXFx4MDJcXHgwMlxceDAyXFxuMlxceDAzXFx4MDJcXHgwMlxceDAyXCIgK1xuXHRcdFwiXFxmNFxceDAzXFx4MDJcXHgwMlxceDAyXFx4MEVeXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxMFxceDEyXFx4MDVcXHgwNFxceDAzXFx4MDJcXHgxMVxceDEwXCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxMlxceDE1XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxM1xceDExXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxM1xceDE0XCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxNFxceDE2XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxNVxceDEzXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxNlxceDE3XCIgK1xuXHRcdFwiXFx4MDdcXHgwMlxceDAyXFx4MDNcXHgxN1xceDAzXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxOFxceDFBXFx4MDVcXHgwNlxceDA0XFx4MDJcXHgxOVxceDE4XCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxQVxceDFCXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxQlxceDE5XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxQlxceDFDXCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxQ1xceDFFXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxRFxceDFGXFx4MDVcXG5cXHgwNlxceDAyXFx4MUVcXHgxRFwiICtcblx0XHRcIlxceDAzXFx4MDJcXHgwMlxceDAyXFx4MUVcXHgxRlxceDAzXFx4MDJcXHgwMlxceDAyXFx4MUZcXHgwNVxceDAzXFx4MDJcXHgwMlxceDAyICNcXHgwNVwiICtcblx0XHRcIlxcZlxceDA3XFx4MDIhI1xceDA1XFx4MEVcXGJcXHgwMlxcXCIgXFx4MDNcXHgwMlxceDAyXFx4MDJcXFwiIVxceDAzXFx4MDJcXHgwMlxceDAyIyRcXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MDJcXHgwMiRcXFwiXFx4MDNcXHgwMlxceDAyXFx4MDIkJVxceDAzXFx4MDJcXHgwMlxceDAyJVxcJ1xceDAzXFx4MDJcXHgwMlxceDAyJlwiICtcblx0XHRcIihcXHgwNVxcYlxceDA1XFx4MDJcXCcmXFx4MDNcXHgwMlxceDAyXFx4MDJcXCcoXFx4MDNcXHgwMlxceDAyXFx4MDIoXFx4MDdcXHgwM1xceDAyXFx4MDJcIiArXG5cdFx0XCJcXHgwMikqXFx0XFx4MDJcXHgwMlxceDAyKlxcdFxceDAzXFx4MDJcXHgwMlxceDAyKy1cXHgwN1xceDA2XFx4MDJcXHgwMiwrXFx4MDNcXHgwMlxceDAyXCIgK1xuXHRcdFwiXFx4MDItLlxceDAzXFx4MDJcXHgwMlxceDAyLixcXHgwM1xceDAyXFx4MDJcXHgwMi4vXFx4MDNcXHgwMlxceDAyXFx4MDIvM1xceDAzXFx4MDJcXHgwMlwiICtcblx0XHRcIlxceDAyMDNcXHgwN1xceDA3XFx4MDJcXHgwMjEzXFx4MDdcXGJcXHgwMlxceDAyMixcXHgwM1xceDAyXFx4MDJcXHgwMjIwXFx4MDNcXHgwMlxceDAyXCIgK1xuXHRcdFwiXFx4MDIyMVxceDAzXFx4MDJcXHgwMlxceDAyM1xcdlxceDAzXFx4MDJcXHgwMlxceDAyNDVcXHRcXHgwM1xceDAyXFx4MDI1XFxyXFx4MDNcXHgwMlxceDAyXCIgK1xuXHRcdFwiXFx4MDI2OlxceDA3XFx0XFx4MDJcXHgwMjc5XFx4MDVcXHgwNFxceDAzXFx4MDI4N1xceDAzXFx4MDJcXHgwMlxceDAyOTxcXHgwM1xceDAyXFx4MDJcIiArXG5cdFx0XCJcXHgwMjo4XFx4MDNcXHgwMlxceDAyXFx4MDI6O1xceDAzXFx4MDJcXHgwMlxceDAyOz1cXHgwM1xceDAyXFx4MDJcXHgwMjw6XFx4MDNcXHgwMlxceDAyXCIgK1xuXHRcdFwiXFx4MDI9X1xceDA3XFxuXFx4MDJcXHgwMj5CXFx4MDdcXHgwRlxceDAyXFx4MDI/QVxceDA1XFx4MDRcXHgwM1xceDAyQD9cXHgwM1xceDAyXFx4MDJcIiArXG5cdFx0XCJcXHgwMkFEXFx4MDNcXHgwMlxceDAyXFx4MDJCQFxceDAzXFx4MDJcXHgwMlxceDAyQkNcXHgwM1xceDAyXFx4MDJcXHgwMkNFXFx4MDNcXHgwMlxceDAyXCIgK1xuXHRcdFwiXFx4MDJEQlxceDAzXFx4MDJcXHgwMlxceDAyRV9cXHgwN1xceDBGXFx4MDJcXHgwMkZKXFx4MDdcXHgxMFxceDAyXFx4MDJHSVxceDA1XFx4MDRcXHgwM1wiICtcblx0XHRcIlxceDAySEdcXHgwM1xceDAyXFx4MDJcXHgwMklMXFx4MDNcXHgwMlxceDAyXFx4MDJKSFxceDAzXFx4MDJcXHgwMlxceDAySktcXHgwM1xceDAyXFx4MDJcIiArXG5cdFx0XCJcXHgwMktNXFx4MDNcXHgwMlxceDAyXFx4MDJMSlxceDAzXFx4MDJcXHgwMlxceDAyTV9cXHgwN1xceDEwXFx4MDJcXHgwMk5SXFx4MDdcXHJcXHgwMlwiICtcblx0XHRcIlxceDAyT1FcXHgwNVxceDA0XFx4MDNcXHgwMlBPXFx4MDNcXHgwMlxceDAyXFx4MDJRVFxceDAzXFx4MDJcXHgwMlxceDAyUlBcXHgwM1xceDAyXFx4MDJcIiArXG5cdFx0XCJcXHgwMlJTXFx4MDNcXHgwMlxceDAyXFx4MDJTVVxceDAzXFx4MDJcXHgwMlxceDAyVFJcXHgwM1xceDAyXFx4MDJcXHgwMlVfXFx4MDdcXHgwRVxceDAyXCIgK1xuXHRcdFwiXFx4MDJWWlxceDA3XFx2XFx4MDJcXHgwMldZXFx4MDVcXHgwNFxceDAzXFx4MDJYV1xceDAzXFx4MDJcXHgwMlxceDAyWVxcXFxcXHgwM1xceDAyXFx4MDJcIiArXG5cdFx0XCJcXHgwMlpYXFx4MDNcXHgwMlxceDAyXFx4MDJaW1xceDAzXFx4MDJcXHgwMlxceDAyW11cXHgwM1xceDAyXFx4MDJcXHgwMlxcXFxaXFx4MDNcXHgwMlwiICtcblx0XHRcIlxceDAyXFx4MDJdX1xceDA3XFxmXFx4MDJcXHgwMl42XFx4MDNcXHgwMlxceDAyXFx4MDJePlxceDAzXFx4MDJcXHgwMlxceDAyXkZcXHgwM1xceDAyXCIgK1xuXHRcdFwiXFx4MDJcXHgwMl5OXFx4MDNcXHgwMlxceDAyXFx4MDJeVlxceDAzXFx4MDJcXHgwMlxceDAyX1xceDBGXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxMFwiICtcblx0XHRcIlxceDEzXFx4MUJcXHgxRVxcXCIkXFwnLjI6QkpSWl5cIjtcblx0cHVibGljIHN0YXRpYyBfX0FUTjogQVROO1xuXHRwdWJsaWMgc3RhdGljIGdldCBfQVROKCk6IEFUTiB7XG5cdFx0aWYgKCFTaW1wbGVUZXh0UGFyc2VyLl9fQVROKSB7XG5cdFx0XHRTaW1wbGVUZXh0UGFyc2VyLl9fQVROID0gbmV3IEFUTkRlc2VyaWFsaXplcigpLmRlc2VyaWFsaXplKFV0aWxzLnRvQ2hhckFycmF5KFNpbXBsZVRleHRQYXJzZXIuX3NlcmlhbGl6ZWRBVE4pKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gU2ltcGxlVGV4dFBhcnNlci5fX0FUTjtcblx0fVxuXG59XG5cbmV4cG9ydCBjbGFzcyBQYXJhZ3JhcGhDb250ZXh0IGV4dGVuZHMgUGFyc2VyUnVsZUNvbnRleHQge1xuXHRwdWJsaWMgRU9GKCk6IFRlcm1pbmFsTm9kZSB7IHJldHVybiB0aGlzLmdldFRva2VuKFNpbXBsZVRleHRQYXJzZXIuRU9GLCAwKTsgfVxuXHRwdWJsaWMgc2VudGVuY2UoKTogU2VudGVuY2VDb250ZXh0W107XG5cdHB1YmxpYyBzZW50ZW5jZShpOiBudW1iZXIpOiBTZW50ZW5jZUNvbnRleHQ7XG5cdHB1YmxpYyBzZW50ZW5jZShpPzogbnVtYmVyKTogU2VudGVuY2VDb250ZXh0IHwgU2VudGVuY2VDb250ZXh0W10ge1xuXHRcdGlmIChpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhTZW50ZW5jZUNvbnRleHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBTZW50ZW5jZUNvbnRleHQpO1xuXHRcdH1cblx0fVxuXHRjb25zdHJ1Y3RvcihwYXJlbnQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLCBpbnZva2luZ1N0YXRlOiBudW1iZXIpIHtcblx0XHRzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZ2V0IHJ1bGVJbmRleCgpOiBudW1iZXIgeyByZXR1cm4gU2ltcGxlVGV4dFBhcnNlci5SVUxFX3BhcmFncmFwaDsgfVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGVudGVyUnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmVudGVyUGFyYWdyYXBoKSB7XG5cdFx0XHRsaXN0ZW5lci5lbnRlclBhcmFncmFwaCh0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBleGl0UnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmV4aXRQYXJhZ3JhcGgpIHtcblx0XHRcdGxpc3RlbmVyLmV4aXRQYXJhZ3JhcGgodGhpcyk7XG5cdFx0fVxuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgYWNjZXB0PFJlc3VsdD4odmlzaXRvcjogU2ltcGxlVGV4dFZpc2l0b3I8UmVzdWx0Pik6IFJlc3VsdCB7XG5cdFx0aWYgKHZpc2l0b3IudmlzaXRQYXJhZ3JhcGgpIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0UGFyYWdyYXBoKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuXHRcdH1cblx0fVxufVxuXG5cbmV4cG9ydCBjbGFzcyBTZW50ZW5jZUNvbnRleHQgZXh0ZW5kcyBQYXJzZXJSdWxlQ29udGV4dCB7XG5cdHB1YmxpYyBwcm9wb3NpdGlvbigpOiBQcm9wb3NpdGlvbkNvbnRleHRbXTtcblx0cHVibGljIHByb3Bvc2l0aW9uKGk6IG51bWJlcik6IFByb3Bvc2l0aW9uQ29udGV4dDtcblx0cHVibGljIHByb3Bvc2l0aW9uKGk/OiBudW1iZXIpOiBQcm9wb3NpdGlvbkNvbnRleHQgfCBQcm9wb3NpdGlvbkNvbnRleHRbXSB7XG5cdFx0aWYgKGkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKFByb3Bvc2l0aW9uQ29udGV4dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIFByb3Bvc2l0aW9uQ29udGV4dCk7XG5cdFx0fVxuXHR9XG5cdHB1YmxpYyBlbmRQdW5jdHVhdGlvbigpOiBFbmRQdW5jdHVhdGlvbkNvbnRleHQgfCB1bmRlZmluZWQge1xuXHRcdHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEVuZFB1bmN0dWF0aW9uQ29udGV4dCk7XG5cdH1cblx0Y29uc3RydWN0b3IocGFyZW50OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgaW52b2tpbmdTdGF0ZTogbnVtYmVyKSB7XG5cdFx0c3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBydWxlSW5kZXgoKTogbnVtYmVyIHsgcmV0dXJuIFNpbXBsZVRleHRQYXJzZXIuUlVMRV9zZW50ZW5jZTsgfVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGVudGVyUnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmVudGVyU2VudGVuY2UpIHtcblx0XHRcdGxpc3RlbmVyLmVudGVyU2VudGVuY2UodGhpcyk7XG5cdFx0fVxuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZXhpdFJ1bGUobGlzdGVuZXI6IFNpbXBsZVRleHRMaXN0ZW5lcik6IHZvaWQge1xuXHRcdGlmIChsaXN0ZW5lci5leGl0U2VudGVuY2UpIHtcblx0XHRcdGxpc3RlbmVyLmV4aXRTZW50ZW5jZSh0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBhY2NlcHQ8UmVzdWx0Pih2aXNpdG9yOiBTaW1wbGVUZXh0VmlzaXRvcjxSZXN1bHQ+KTogUmVzdWx0IHtcblx0XHRpZiAodmlzaXRvci52aXNpdFNlbnRlbmNlKSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdFNlbnRlbmNlKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuXHRcdH1cblx0fVxufVxuXG5cbmV4cG9ydCBjbGFzcyBQcm9wb3NpdGlvbkNvbnRleHQgZXh0ZW5kcyBQYXJzZXJSdWxlQ29udGV4dCB7XG5cdHB1YmxpYyB3b3JkKCk6IFdvcmRDb250ZXh0W107XG5cdHB1YmxpYyB3b3JkKGk6IG51bWJlcik6IFdvcmRDb250ZXh0O1xuXHRwdWJsaWMgd29yZChpPzogbnVtYmVyKTogV29yZENvbnRleHQgfCBXb3JkQ29udGV4dFtdIHtcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoV29yZENvbnRleHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBXb3JkQ29udGV4dCk7XG5cdFx0fVxuXHR9XG5cdHB1YmxpYyBleHByZXNzaW9uKCk6IEV4cHJlc3Npb25Db250ZXh0W107XG5cdHB1YmxpYyBleHByZXNzaW9uKGk6IG51bWJlcik6IEV4cHJlc3Npb25Db250ZXh0O1xuXHRwdWJsaWMgZXhwcmVzc2lvbihpPzogbnVtYmVyKTogRXhwcmVzc2lvbkNvbnRleHQgfCBFeHByZXNzaW9uQ29udGV4dFtdIHtcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoRXhwcmVzc2lvbkNvbnRleHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBFeHByZXNzaW9uQ29udGV4dCk7XG5cdFx0fVxuXHR9XG5cdHB1YmxpYyBtaWRQdW5jdHVhdGlvbigpOiBNaWRQdW5jdHVhdGlvbkNvbnRleHQgfCB1bmRlZmluZWQge1xuXHRcdHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIE1pZFB1bmN0dWF0aW9uQ29udGV4dCk7XG5cdH1cblx0Y29uc3RydWN0b3IocGFyZW50OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgaW52b2tpbmdTdGF0ZTogbnVtYmVyKSB7XG5cdFx0c3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBydWxlSW5kZXgoKTogbnVtYmVyIHsgcmV0dXJuIFNpbXBsZVRleHRQYXJzZXIuUlVMRV9wcm9wb3NpdGlvbjsgfVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGVudGVyUnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmVudGVyUHJvcG9zaXRpb24pIHtcblx0XHRcdGxpc3RlbmVyLmVudGVyUHJvcG9zaXRpb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZXhpdFJ1bGUobGlzdGVuZXI6IFNpbXBsZVRleHRMaXN0ZW5lcik6IHZvaWQge1xuXHRcdGlmIChsaXN0ZW5lci5leGl0UHJvcG9zaXRpb24pIHtcblx0XHRcdGxpc3RlbmVyLmV4aXRQcm9wb3NpdGlvbih0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBhY2NlcHQ8UmVzdWx0Pih2aXNpdG9yOiBTaW1wbGVUZXh0VmlzaXRvcjxSZXN1bHQ+KTogUmVzdWx0IHtcblx0XHRpZiAodmlzaXRvci52aXNpdFByb3Bvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdFByb3Bvc2l0aW9uKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuXHRcdH1cblx0fVxufVxuXG5cbmV4cG9ydCBjbGFzcyBNaWRQdW5jdHVhdGlvbkNvbnRleHQgZXh0ZW5kcyBQYXJzZXJSdWxlQ29udGV4dCB7XG5cdHB1YmxpYyBDT01NQSgpOiBUZXJtaW5hbE5vZGUgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLkNPTU1BLCAwKTsgfVxuXHRwdWJsaWMgQ09MT04oKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5DT0xPTiwgMCk7IH1cblx0cHVibGljIFNFTUlDT0xPTigpOiBUZXJtaW5hbE5vZGUgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLlNFTUlDT0xPTiwgMCk7IH1cblx0Y29uc3RydWN0b3IocGFyZW50OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgaW52b2tpbmdTdGF0ZTogbnVtYmVyKSB7XG5cdFx0c3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBydWxlSW5kZXgoKTogbnVtYmVyIHsgcmV0dXJuIFNpbXBsZVRleHRQYXJzZXIuUlVMRV9taWRQdW5jdHVhdGlvbjsgfVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGVudGVyUnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmVudGVyTWlkUHVuY3R1YXRpb24pIHtcblx0XHRcdGxpc3RlbmVyLmVudGVyTWlkUHVuY3R1YXRpb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZXhpdFJ1bGUobGlzdGVuZXI6IFNpbXBsZVRleHRMaXN0ZW5lcik6IHZvaWQge1xuXHRcdGlmIChsaXN0ZW5lci5leGl0TWlkUHVuY3R1YXRpb24pIHtcblx0XHRcdGxpc3RlbmVyLmV4aXRNaWRQdW5jdHVhdGlvbih0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBhY2NlcHQ8UmVzdWx0Pih2aXNpdG9yOiBTaW1wbGVUZXh0VmlzaXRvcjxSZXN1bHQ+KTogUmVzdWx0IHtcblx0XHRpZiAodmlzaXRvci52aXNpdE1pZFB1bmN0dWF0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdE1pZFB1bmN0dWF0aW9uKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuXHRcdH1cblx0fVxufVxuXG5cbmV4cG9ydCBjbGFzcyBFbmRQdW5jdHVhdGlvbkNvbnRleHQgZXh0ZW5kcyBQYXJzZXJSdWxlQ29udGV4dCB7XG5cdHB1YmxpYyBET1QoKTogVGVybWluYWxOb2RlW107XG5cdHB1YmxpYyBET1QoaTogbnVtYmVyKTogVGVybWluYWxOb2RlO1xuXHRwdWJsaWMgRE9UKGk/OiBudW1iZXIpOiBUZXJtaW5hbE5vZGUgfCBUZXJtaW5hbE5vZGVbXSB7XG5cdFx0aWYgKGkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0VG9rZW5zKFNpbXBsZVRleHRQYXJzZXIuRE9UKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5ET1QsIGkpO1xuXHRcdH1cblx0fVxuXHRwdWJsaWMgUVVFU1RJT05fTUFSSygpOiBUZXJtaW5hbE5vZGUgfCB1bmRlZmluZWQgeyByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLlFVRVNUSU9OX01BUkssIDApOyB9XG5cdHB1YmxpYyBFWENMQU1BVElPTl9NQVJLKCk6IFRlcm1pbmFsTm9kZSB8IHVuZGVmaW5lZCB7IHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNpbXBsZVRleHRQYXJzZXIuRVhDTEFNQVRJT05fTUFSSywgMCk7IH1cblx0Y29uc3RydWN0b3IocGFyZW50OiBQYXJzZXJSdWxlQ29udGV4dCB8IHVuZGVmaW5lZCwgaW52b2tpbmdTdGF0ZTogbnVtYmVyKSB7XG5cdFx0c3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBydWxlSW5kZXgoKTogbnVtYmVyIHsgcmV0dXJuIFNpbXBsZVRleHRQYXJzZXIuUlVMRV9lbmRQdW5jdHVhdGlvbjsgfVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGVudGVyUnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmVudGVyRW5kUHVuY3R1YXRpb24pIHtcblx0XHRcdGxpc3RlbmVyLmVudGVyRW5kUHVuY3R1YXRpb24odGhpcyk7XG5cdFx0fVxuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZXhpdFJ1bGUobGlzdGVuZXI6IFNpbXBsZVRleHRMaXN0ZW5lcik6IHZvaWQge1xuXHRcdGlmIChsaXN0ZW5lci5leGl0RW5kUHVuY3R1YXRpb24pIHtcblx0XHRcdGxpc3RlbmVyLmV4aXRFbmRQdW5jdHVhdGlvbih0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBhY2NlcHQ8UmVzdWx0Pih2aXNpdG9yOiBTaW1wbGVUZXh0VmlzaXRvcjxSZXN1bHQ+KTogUmVzdWx0IHtcblx0XHRpZiAodmlzaXRvci52aXNpdEVuZFB1bmN0dWF0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdEVuZFB1bmN0dWF0aW9uKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuXHRcdH1cblx0fVxufVxuXG5cbmV4cG9ydCBjbGFzcyBXb3JkQ29udGV4dCBleHRlbmRzIFBhcnNlclJ1bGVDb250ZXh0IHtcblx0cHVibGljIFdvcmQoKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5Xb3JkLCAwKTsgfVxuXHRwdWJsaWMgU21pbGV5KCk6IFRlcm1pbmFsTm9kZSB8IHVuZGVmaW5lZCB7IHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNpbXBsZVRleHRQYXJzZXIuU21pbGV5LCAwKTsgfVxuXHRwdWJsaWMgVXJsKCk6IFRlcm1pbmFsTm9kZSB8IHVuZGVmaW5lZCB7IHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNpbXBsZVRleHRQYXJzZXIuVXJsLCAwKTsgfVxuXHRjb25zdHJ1Y3RvcihwYXJlbnQ6IFBhcnNlclJ1bGVDb250ZXh0IHwgdW5kZWZpbmVkLCBpbnZva2luZ1N0YXRlOiBudW1iZXIpIHtcblx0XHRzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuXHR9XG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZ2V0IHJ1bGVJbmRleCgpOiBudW1iZXIgeyByZXR1cm4gU2ltcGxlVGV4dFBhcnNlci5SVUxFX3dvcmQ7IH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBlbnRlclJ1bGUobGlzdGVuZXI6IFNpbXBsZVRleHRMaXN0ZW5lcik6IHZvaWQge1xuXHRcdGlmIChsaXN0ZW5lci5lbnRlcldvcmQpIHtcblx0XHRcdGxpc3RlbmVyLmVudGVyV29yZCh0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBleGl0UnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmV4aXRXb3JkKSB7XG5cdFx0XHRsaXN0ZW5lci5leGl0V29yZCh0aGlzKTtcblx0XHR9XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBhY2NlcHQ8UmVzdWx0Pih2aXNpdG9yOiBTaW1wbGVUZXh0VmlzaXRvcjxSZXN1bHQ+KTogUmVzdWx0IHtcblx0XHRpZiAodmlzaXRvci52aXNpdFdvcmQpIHtcblx0XHRcdHJldHVybiB2aXNpdG9yLnZpc2l0V29yZCh0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcblx0XHR9XG5cdH1cbn1cblxuXG5leHBvcnQgY2xhc3MgRXhwcmVzc2lvbkNvbnRleHQgZXh0ZW5kcyBQYXJzZXJSdWxlQ29udGV4dCB7XG5cdHB1YmxpYyBMUEFSRU4oKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5MUEFSRU4sIDApOyB9XG5cdHB1YmxpYyBSUEFSRU4oKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5SUEFSRU4sIDApOyB9XG5cdHB1YmxpYyBzZW50ZW5jZSgpOiBTZW50ZW5jZUNvbnRleHRbXTtcblx0cHVibGljIHNlbnRlbmNlKGk6IG51bWJlcik6IFNlbnRlbmNlQ29udGV4dDtcblx0cHVibGljIHNlbnRlbmNlKGk/OiBudW1iZXIpOiBTZW50ZW5jZUNvbnRleHQgfCBTZW50ZW5jZUNvbnRleHRbXSB7XG5cdFx0aWYgKGkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKFNlbnRlbmNlQ29udGV4dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIFNlbnRlbmNlQ29udGV4dCk7XG5cdFx0fVxuXHR9XG5cdHB1YmxpYyBRVU9URSgpOiBUZXJtaW5hbE5vZGVbXTtcblx0cHVibGljIFFVT1RFKGk6IG51bWJlcik6IFRlcm1pbmFsTm9kZTtcblx0cHVibGljIFFVT1RFKGk/OiBudW1iZXIpOiBUZXJtaW5hbE5vZGUgfCBUZXJtaW5hbE5vZGVbXSB7XG5cdFx0aWYgKGkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0VG9rZW5zKFNpbXBsZVRleHRQYXJzZXIuUVVPVEUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLlFVT1RFLCBpKTtcblx0XHR9XG5cdH1cblx0cHVibGljIERRVU9URSgpOiBUZXJtaW5hbE5vZGVbXTtcblx0cHVibGljIERRVU9URShpOiBudW1iZXIpOiBUZXJtaW5hbE5vZGU7XG5cdHB1YmxpYyBEUVVPVEUoaT86IG51bWJlcik6IFRlcm1pbmFsTm9kZSB8IFRlcm1pbmFsTm9kZVtdIHtcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUb2tlbnMoU2ltcGxlVGV4dFBhcnNlci5EUVVPVEUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUb2tlbihTaW1wbGVUZXh0UGFyc2VyLkRRVU9URSwgaSk7XG5cdFx0fVxuXHR9XG5cdHB1YmxpYyBMQlJBQ0soKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5MQlJBQ0ssIDApOyB9XG5cdHB1YmxpYyBSQlJBQ0soKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5SQlJBQ0ssIDApOyB9XG5cdHB1YmxpYyBMQUNDT0woKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5MQUNDT0wsIDApOyB9XG5cdHB1YmxpYyBSQUNDT0woKTogVGVybWluYWxOb2RlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU2ltcGxlVGV4dFBhcnNlci5SQUNDT0wsIDApOyB9XG5cdGNvbnN0cnVjdG9yKHBhcmVudDogUGFyc2VyUnVsZUNvbnRleHQgfCB1bmRlZmluZWQsIGludm9raW5nU3RhdGU6IG51bWJlcikge1xuXHRcdHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG5cdH1cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBnZXQgcnVsZUluZGV4KCk6IG51bWJlciB7IHJldHVybiBTaW1wbGVUZXh0UGFyc2VyLlJVTEVfZXhwcmVzc2lvbjsgfVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGVudGVyUnVsZShsaXN0ZW5lcjogU2ltcGxlVGV4dExpc3RlbmVyKTogdm9pZCB7XG5cdFx0aWYgKGxpc3RlbmVyLmVudGVyRXhwcmVzc2lvbikge1xuXHRcdFx0bGlzdGVuZXIuZW50ZXJFeHByZXNzaW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGV4aXRSdWxlKGxpc3RlbmVyOiBTaW1wbGVUZXh0TGlzdGVuZXIpOiB2b2lkIHtcblx0XHRpZiAobGlzdGVuZXIuZXhpdEV4cHJlc3Npb24pIHtcblx0XHRcdGxpc3RlbmVyLmV4aXRFeHByZXNzaW9uKHRoaXMpO1xuXHRcdH1cblx0fVxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGFjY2VwdDxSZXN1bHQ+KHZpc2l0b3I6IFNpbXBsZVRleHRWaXNpdG9yPFJlc3VsdD4pOiBSZXN1bHQge1xuXHRcdGlmICh2aXNpdG9yLnZpc2l0RXhwcmVzc2lvbikge1xuXHRcdFx0cmV0dXJuIHZpc2l0b3IudmlzaXRFeHByZXNzaW9uKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuXHRcdH1cblx0fVxufVxuXG5cbiIsICIvLyBHZW5lcmF0ZWQgZnJvbSBncmFtbWFyL1NpbXBsZVRleHQuZzQgYnkgQU5UTFIgNC45LjAtU05BUFNIT1RcblxuXG5pbXBvcnQgeyBBVE4gfSBmcm9tIFwiYW50bHI0dHMvYXRuL0FUTlwiO1xuaW1wb3J0IHsgQVRORGVzZXJpYWxpemVyIH0gZnJvbSBcImFudGxyNHRzL2F0bi9BVE5EZXNlcmlhbGl6ZXJcIjtcbmltcG9ydCB7IENoYXJTdHJlYW0gfSBmcm9tIFwiYW50bHI0dHMvQ2hhclN0cmVhbVwiO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiYW50bHI0dHMvTGV4ZXJcIjtcbmltcG9ydCB7IExleGVyQVROU2ltdWxhdG9yIH0gZnJvbSBcImFudGxyNHRzL2F0bi9MZXhlckFUTlNpbXVsYXRvclwiO1xuaW1wb3J0IHsgTm90TnVsbCB9IGZyb20gXCJhbnRscjR0cy9EZWNvcmF0b3JzXCI7XG5pbXBvcnQgeyBPdmVycmlkZSB9IGZyb20gXCJhbnRscjR0cy9EZWNvcmF0b3JzXCI7XG5pbXBvcnQgeyBSdWxlQ29udGV4dCB9IGZyb20gXCJhbnRscjR0cy9SdWxlQ29udGV4dFwiO1xuaW1wb3J0IHsgVm9jYWJ1bGFyeSB9IGZyb20gXCJhbnRscjR0cy9Wb2NhYnVsYXJ5XCI7XG5pbXBvcnQgeyBWb2NhYnVsYXJ5SW1wbCB9IGZyb20gXCJhbnRscjR0cy9Wb2NhYnVsYXJ5SW1wbFwiO1xuXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiYW50bHI0dHMvbWlzYy9VdGlsc1wiO1xuXG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVUZXh0TGV4ZXIgZXh0ZW5kcyBMZXhlciB7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgV29yZCA9IDE7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU21pbGV5ID0gMjtcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBVcmwgPSAzO1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERPVCA9IDQ7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUVVFU1RJT05fTUFSSyA9IDU7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRVhDTEFNQVRJT05fTUFSSyA9IDY7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTFBBUkVOID0gNztcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBSUEFSRU4gPSA4O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExBQ0NPTCA9IDk7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUkFDQ09MID0gMTA7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTEJSQUNLID0gMTE7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUkJSQUNLID0gMTI7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUVVPVEUgPSAxMztcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBEUVVPVEUgPSAxNDtcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBDT0xPTiA9IDE1O1xuXHRwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENPTU1BID0gMTY7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU0VNSUNPTE9OID0gMTc7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU01JTEVZID0gMTg7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgV1MgPSAxOTtcblxuXHQvLyB0c2xpbnQ6ZGlzYWJsZTpuby10cmFpbGluZy13aGl0ZXNwYWNlXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY2hhbm5lbE5hbWVzOiBzdHJpbmdbXSA9IFtcblx0XHRcIkRFRkFVTFRfVE9LRU5fQ0hBTk5FTFwiLCBcIkhJRERFTlwiLFxuXHRdO1xuXG5cdC8vIHRzbGludDpkaXNhYmxlOm5vLXRyYWlsaW5nLXdoaXRlc3BhY2Vcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBtb2RlTmFtZXM6IHN0cmluZ1tdID0gW1xuXHRcdFwiREVGQVVMVF9NT0RFXCIsXG5cdF07XG5cblx0cHVibGljIHN0YXRpYyByZWFkb25seSBydWxlTmFtZXM6IHN0cmluZ1tdID0gW1xuXHRcdFwiV29yZFwiLCBcIlNtaWxleVwiLCBcIlVybFwiLCBcIkRPVFwiLCBcIlFVRVNUSU9OX01BUktcIiwgXCJFWENMQU1BVElPTl9NQVJLXCIsIFwiTFBBUkVOXCIsIFxuXHRcdFwiUlBBUkVOXCIsIFwiTEFDQ09MXCIsIFwiUkFDQ09MXCIsIFwiTEJSQUNLXCIsIFwiUkJSQUNLXCIsIFwiUVVPVEVcIiwgXCJEUVVPVEVcIiwgXCJDT0xPTlwiLCBcblx0XHRcIkNPTU1BXCIsIFwiU0VNSUNPTE9OXCIsIFwiU01JTEVZXCIsIFwiU1BBQ0VcIiwgXCJXU1wiLFxuXHRdO1xuXG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IF9MSVRFUkFMX05BTUVTOiBBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0gW1xuXHRcdHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCInLidcIiwgXCInPydcIiwgXCInISdcIiwgXCInKCdcIiwgXG5cdFx0XCInKSdcIiwgXCIneydcIiwgXCInfSdcIiwgXCInWydcIiwgXCInXSdcIiwgdW5kZWZpbmVkLCBcIidcXFwiJ1wiLCBcIic6J1wiLCBcIicsJ1wiLCBcIic7J1wiLFxuXHRdO1xuXHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBfU1lNQk9MSUNfTkFNRVM6IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZD4gPSBbXG5cdFx0dW5kZWZpbmVkLCBcIldvcmRcIiwgXCJTbWlsZXlcIiwgXCJVcmxcIiwgXCJET1RcIiwgXCJRVUVTVElPTl9NQVJLXCIsIFwiRVhDTEFNQVRJT05fTUFSS1wiLCBcblx0XHRcIkxQQVJFTlwiLCBcIlJQQVJFTlwiLCBcIkxBQ0NPTFwiLCBcIlJBQ0NPTFwiLCBcIkxCUkFDS1wiLCBcIlJCUkFDS1wiLCBcIlFVT1RFXCIsIFwiRFFVT1RFXCIsIFxuXHRcdFwiQ09MT05cIiwgXCJDT01NQVwiLCBcIlNFTUlDT0xPTlwiLCBcIlNNSUxFWVwiLCBcIldTXCIsXG5cdF07XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVk9DQUJVTEFSWTogVm9jYWJ1bGFyeSA9IG5ldyBWb2NhYnVsYXJ5SW1wbChTaW1wbGVUZXh0TGV4ZXIuX0xJVEVSQUxfTkFNRVMsIFNpbXBsZVRleHRMZXhlci5fU1lNQk9MSUNfTkFNRVMsIFtdKTtcblxuXHQvLyBAT3ZlcnJpZGVcblx0Ly8gQE5vdE51bGxcblx0cHVibGljIGdldCB2b2NhYnVsYXJ5KCk6IFZvY2FidWxhcnkge1xuXHRcdHJldHVybiBTaW1wbGVUZXh0TGV4ZXIuVk9DQUJVTEFSWTtcblx0fVxuXHQvLyB0c2xpbnQ6ZW5hYmxlOm5vLXRyYWlsaW5nLXdoaXRlc3BhY2VcblxuXG5cdGNvbnN0cnVjdG9yKGlucHV0OiBDaGFyU3RyZWFtKSB7XG5cdFx0c3VwZXIoaW5wdXQpO1xuXHRcdHRoaXMuX2ludGVycCA9IG5ldyBMZXhlckFUTlNpbXVsYXRvcihTaW1wbGVUZXh0TGV4ZXIuX0FUTiwgdGhpcyk7XG5cdH1cblxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBncmFtbWFyRmlsZU5hbWUoKTogc3RyaW5nIHsgcmV0dXJuIFwiU2ltcGxlVGV4dC5nNFwiOyB9XG5cblx0Ly8gQE92ZXJyaWRlXG5cdHB1YmxpYyBnZXQgcnVsZU5hbWVzKCk6IHN0cmluZ1tdIHsgcmV0dXJuIFNpbXBsZVRleHRMZXhlci5ydWxlTmFtZXM7IH1cblxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBzZXJpYWxpemVkQVROKCk6IHN0cmluZyB7IHJldHVybiBTaW1wbGVUZXh0TGV4ZXIuX3NlcmlhbGl6ZWRBVE47IH1cblxuXHQvLyBAT3ZlcnJpZGVcblx0cHVibGljIGdldCBjaGFubmVsTmFtZXMoKTogc3RyaW5nW10geyByZXR1cm4gU2ltcGxlVGV4dExleGVyLmNoYW5uZWxOYW1lczsgfVxuXG5cdC8vIEBPdmVycmlkZVxuXHRwdWJsaWMgZ2V0IG1vZGVOYW1lcygpOiBzdHJpbmdbXSB7IHJldHVybiBTaW1wbGVUZXh0TGV4ZXIubW9kZU5hbWVzOyB9XG5cblx0cHVibGljIHN0YXRpYyByZWFkb25seSBfc2VyaWFsaXplZEFUTjogc3RyaW5nID1cblx0XHRcIlxceDAzXFx1QzkxRFxcdUNBQkFcXHUwNThEXFx1QUZCQVxcdTRGNTNcXHUwNjA3XFx1RUE4QlxcdUMyNDFcXHgwMlxceDE1XFx4N0ZcXGJcXHgwMVwiICtcblx0XHRcIlxceDA0XFx4MDJcXHRcXHgwMlxceDA0XFx4MDNcXHRcXHgwM1xceDA0XFx4MDRcXHRcXHgwNFxceDA0XFx4MDVcXHRcXHgwNVxceDA0XFx4MDZcXHRcXHgwNlwiICtcblx0XHRcIlxceDA0XFx4MDdcXHRcXHgwN1xceDA0XFxiXFx0XFxiXFx4MDRcXHRcXHRcXHRcXHgwNFxcblxcdFxcblxceDA0XFx2XFx0XFx2XFx4MDRcXGZcXHRcXGZcXHgwNFxcclwiICtcblx0XHRcIlxcdFxcclxceDA0XFx4MEVcXHRcXHgwRVxceDA0XFx4MEZcXHRcXHgwRlxceDA0XFx4MTBcXHRcXHgxMFxceDA0XFx4MTFcXHRcXHgxMVxceDA0XFx4MTJcXHRcIiArXG5cdFx0XCJcXHgxMlxceDA0XFx4MTNcXHRcXHgxM1xceDA0XFx4MTRcXHRcXHgxNFxceDA0XFx4MTVcXHRcXHgxNVxceDAzXFx4MDJcXHgwN1xceDAyLVxcblxceDAyXCIgK1xuXHRcdFwiXFxmXFx4MDJcXHgwRVxceDAyMFxcdlxceDAyXFx4MDNcXHgwMlxceDA2XFx4MDIzXFxuXFx4MDJcXHJcXHgwMlxceDBFXFx4MDI0XFx4MDNcXHgwM1xceDAzXCIgK1xuXHRcdFwiXFx4MDNcXHgwM1xceDA0XFx4MDNcXHgwNFxceDAzXFx4MDRcXHgwM1xceDA0XFx4MDNcXHgwNFxceDAzXFx4MDRcXHgwNVxceDA0P1xcblxceDA0XFx4MDNcIiArXG5cdFx0XCJcXHgwNFxceDAzXFx4MDRcXHgwM1xceDA0XFx4MDNcXHgwNFxceDAzXFx4MDRcXHgwM1xceDA0XFx4MDZcXHgwNEdcXG5cXHgwNFxcclxceDA0XFx4MEVcIiArXG5cdFx0XCJcXHgwNEhcXHgwM1xceDA1XFx4MDNcXHgwNVxceDAzXFx4MDZcXHgwM1xceDA2XFx4MDNcXHgwN1xceDAzXFx4MDdcXHgwM1xcYlxceDAzXFxiXFx4MDNcIiArXG5cdFx0XCJcXHRcXHgwM1xcdFxceDAzXFxuXFx4MDNcXG5cXHgwM1xcdlxceDAzXFx2XFx4MDNcXGZcXHgwM1xcZlxceDAzXFxyXFx4MDNcXHJcXHgwM1xceDBFXFx4MDNcXHgwRVwiICtcblx0XHRcIlxceDAzXFx4MEVcXHgwNVxceDBFYFxcblxceDBFXFx4MDNcXHgwRlxceDAzXFx4MEZcXHgwM1xceDEwXFx4MDNcXHgxMFxceDAzXFx4MTFcXHgwM1xceDExXCIgK1xuXHRcdFwiXFx4MDNcXHgxMlxceDAzXFx4MTJcXHgwM1xceDEzXFx4MDNcXHgxM1xceDA1XFx4MTNsXFxuXFx4MTNcXHgwM1xceDEzXFx4MDNcXHgxM1xceDAzXFx4MTNcIiArXG5cdFx0XCJcXHgwM1xceDEzXFx4MDNcXHgxM1xceDAzXFx4MTNcXHgwM1xceDEzXFx4MDVcXHgxM3VcXG5cXHgxM1xceDAzXFx4MTRcXHgwM1xceDE0XFx4MDNcXHgxNVwiICtcblx0XHRcIlxceDA2XFx4MTV6XFxuXFx4MTVcXHJcXHgxNVxceDBFXFx4MTV7XFx4MDNcXHgxNVxceDAzXFx4MTVcXHgwMlxceDAyXFx4MDJcXHgxNlxceDAzXFx4MDJcIiArXG5cdFx0XCJcXHgwM1xceDA1XFx4MDJcXHgwNFxceDA3XFx4MDJcXHgwNVxcdFxceDAyXFx4MDZcXHZcXHgwMlxceDA3XFxyXFx4MDJcXGJcXHgwRlxceDAyXFx0XFx4MTFcIiArXG5cdFx0XCJcXHgwMlxcblxceDEzXFx4MDJcXHZcXHgxNVxceDAyXFxmXFx4MTdcXHgwMlxcclxceDE5XFx4MDJcXHgwRVxceDFCXFx4MDJcXHgwRlxceDFEXFx4MDJcXHgxMFwiICtcblx0XHRcIlxceDFGXFx4MDJcXHgxMSFcXHgwMlxceDEyI1xceDAyXFx4MTMlXFx4MDJcXHgxNFxcJ1xceDAyXFx4MDIpXFx4MDJcXHgxNVxceDAzXFx4MDJcXHRcXHgwRVwiICtcblx0XHRcIlxceDAyXFx2XFxmXFx4MEVcXHgwRlxcXCIkKisuLjAwPT1BQV1dX199fVxceDdGXFx4N0ZcXHgwRVxceDAyXFx2XFxmXFx4MEVcXHgwRlxcXCIkKSsuXCIgK1xuXHRcdFwiLjAwPD1BQV1dX199fVxceDdGXFx4N0ZcXHgwNVxceDAyMjtDXFxcXGN8XFx4MDdcXHgwMiUlXFwnXFwnLV1fX2N8XFx4MDNcXHgwMjw9XFx4MDZcIiArXG5cdFx0XCJcXHgwMiorRkZycn5+XFx4MDVcXHgwMlxcdlxcZlxceDBFXFx4MEZcXFwiXFxcIlxceDAyXFx4ODVcXHgwMlxceDAzXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlwiICtcblx0XHRcIlxceDA1XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDA3XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxcdFxceDAzXFx4MDJcXHgwMlxceDAyXFx4MDJcIiArXG5cdFx0XCJcXHZcXHgwM1xceDAyXFx4MDJcXHgwMlxceDAyXFxyXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDBGXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDExXCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDEzXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDE1XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDE3XCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDE5XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDFCXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDFEXCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMlxceDFGXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMiFcXHgwM1xceDAyXFx4MDJcXHgwMlxceDAyI1xceDAzXCIgK1xuXHRcdFwiXFx4MDJcXHgwMlxceDAyXFx4MDIlXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwMilcXHgwM1xceDAyXFx4MDJcXHgwMlxceDAzLlxceDAzXFx4MDJcXHgwMlwiICtcblx0XHRcIlxceDAyXFx4MDU2XFx4MDNcXHgwMlxceDAyXFx4MDJcXHgwNzhcXHgwM1xceDAyXFx4MDJcXHgwMlxcdEpcXHgwM1xceDAyXFx4MDJcXHgwMlxcdkxcXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MDJcXHgwMlxcck5cXHgwM1xceDAyXFx4MDJcXHgwMlxceDBGUFxceDAzXFx4MDJcXHgwMlxceDAyXFx4MTFSXFx4MDNcXHgwMlxceDAyXCIgK1xuXHRcdFwiXFx4MDJcXHgxM1RcXHgwM1xceDAyXFx4MDJcXHgwMlxceDE1VlxceDAzXFx4MDJcXHgwMlxceDAyXFx4MTdYXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxOVwiICtcblx0XHRcIlpcXHgwM1xceDAyXFx4MDJcXHgwMlxceDFCX1xceDAzXFx4MDJcXHgwMlxceDAyXFx4MURhXFx4MDNcXHgwMlxceDAyXFx4MDJcXHgxRmNcXHgwM1xceDAyXCIgK1xuXHRcdFwiXFx4MDJcXHgwMiFlXFx4MDNcXHgwMlxceDAyXFx4MDIjZ1xceDAzXFx4MDJcXHgwMlxceDAyJXRcXHgwM1xceDAyXFx4MDJcXHgwMlxcJ3ZcXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MDJcXHgwMil5XFx4MDNcXHgwMlxceDAyXFx4MDIrLVxcblxceDAyXFx4MDJcXHgwMiwrXFx4MDNcXHgwMlxceDAyXFx4MDItMFxceDAzXCIgK1xuXHRcdFwiXFx4MDJcXHgwMlxceDAyLixcXHgwM1xceDAyXFx4MDJcXHgwMi4vXFx4MDNcXHgwMlxceDAyXFx4MDIvMlxceDAzXFx4MDJcXHgwMlxceDAyMC5cXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MDJcXHgwMjEzXFxuXFx4MDNcXHgwMlxceDAyMjFcXHgwM1xceDAyXFx4MDJcXHgwMjM0XFx4MDNcXHgwMlxceDAyXFx4MDI0MlxceDAzXCIgK1xuXHRcdFwiXFx4MDJcXHgwMlxceDAyNDVcXHgwM1xceDAyXFx4MDJcXHgwMjVcXHgwNFxceDAzXFx4MDJcXHgwMlxceDAyNjdcXHgwNSVcXHgxM1xceDAyN1xceDA2XCIgK1xuXHRcdFwiXFx4MDNcXHgwMlxceDAyXFx4MDI4OVxceDA3alxceDAyXFx4MDI5OlxceDA3dlxceDAyXFx4MDI6O1xceDA3dlxceDAyXFx4MDI7PFxceDA3clxceDAyXCIgK1xuXHRcdFwiXFx4MDI8PlxceDAzXFx4MDJcXHgwMlxceDAyPT9cXHgwN3VcXHgwMlxceDAyPj1cXHgwM1xceDAyXFx4MDJcXHgwMj4/XFx4MDNcXHgwMlxceDAyXCIgK1xuXHRcdFwiXFx4MDI/QFxceDAzXFx4MDJcXHgwMlxceDAyQEFcXHgwNzxcXHgwMlxceDAyQUJcXHgwNzFcXHgwMlxceDAyQkNcXHgwNzFcXHgwMlxceDAyQ0RcIiArXG5cdFx0XCJcXHgwM1xceDAyXFx4MDJcXHgwMkRGXFx0XFx4MDRcXHgwMlxceDAyRUdcXHRcXHgwNVxceDAyXFx4MDJGRVxceDAzXFx4MDJcXHgwMlxceDAyR0hcXHgwM1wiICtcblx0XHRcIlxceDAyXFx4MDJcXHgwMkhGXFx4MDNcXHgwMlxceDAyXFx4MDJISVxceDAzXFx4MDJcXHgwMlxceDAySVxcYlxceDAzXFx4MDJcXHgwMlxceDAySktcIiArXG5cdFx0XCJcXHgwNzBcXHgwMlxceDAyS1xcblxceDAzXFx4MDJcXHgwMlxceDAyTE1cXHgwN0FcXHgwMlxceDAyTVxcZlxceDAzXFx4MDJcXHgwMlxceDAyTk9cXHgwN1wiICtcblx0XHRcIiNcXHgwMlxceDAyT1xceDBFXFx4MDNcXHgwMlxceDAyXFx4MDJQUVxceDA3KlxceDAyXFx4MDJRXFx4MTBcXHgwM1xceDAyXFx4MDJcXHgwMlJTXFx4MDdcIiArXG5cdFx0XCIrXFx4MDJcXHgwMlNcXHgxMlxceDAzXFx4MDJcXHgwMlxceDAyVFVcXHgwN31cXHgwMlxceDAyVVxceDE0XFx4MDNcXHgwMlxceDAyXFx4MDJWV1xceDA3XCIgK1xuXHRcdFwiXFx4N0ZcXHgwMlxceDAyV1xceDE2XFx4MDNcXHgwMlxceDAyXFx4MDJYWVxceDA3XVxceDAyXFx4MDJZXFx4MThcXHgwM1xceDAyXFx4MDJcXHgwMlwiICtcblx0XHRcIlpbXFx4MDdfXFx4MDJcXHgwMltcXHgxQVxceDAzXFx4MDJcXHgwMlxceDAyXFxcXF1cXHgwN1xcXCJcXHgwMlxceDAyXWBcXHgwNylcXHgwMlxceDAyXlwiICtcblx0XHRcImBcXHgwNylcXHgwMlxceDAyX1xcXFxcXHgwM1xceDAyXFx4MDJcXHgwMl9eXFx4MDNcXHgwMlxceDAyXFx4MDJgXFx4MUNcXHgwM1xceDAyXFx4MDJcXHgwMlwiICtcblx0XHRcImFiXFx4MDckXFx4MDJcXHgwMmJcXHgxRVxceDAzXFx4MDJcXHgwMlxceDAyY2RcXHgwNzxcXHgwMlxceDAyZCBcXHgwM1xceDAyXFx4MDJcXHgwMlwiICtcblx0XHRcImVmXFx4MDcuXFx4MDJcXHgwMmZcXFwiXFx4MDNcXHgwMlxceDAyXFx4MDJnaFxceDA3PVxceDAyXFx4MDJoJFxceDAzXFx4MDJcXHgwMlxceDAyaWtcIiArXG5cdFx0XCJcXHRcXHgwNlxceDAyXFx4MDJqbFxceDA3L1xceDAyXFx4MDJralxceDAzXFx4MDJcXHgwMlxceDAya2xcXHgwM1xceDAyXFx4MDJcXHgwMmxtXFx4MDNcIiArXG5cdFx0XCJcXHgwMlxceDAyXFx4MDJtblxcdFxceDA3XFx4MDJcXHgwMm51XFx4MDVcXCdcXHgxNFxceDAyb3BcXHgwNzpcXHgwMlxceDAycHFcXHgwNy9cXHgwMlwiICtcblx0XHRcIlxceDAycXJcXHgwNytcXHgwMlxceDAycnNcXHgwM1xceDAyXFx4MDJcXHgwMnN1XFx4MDVcXCdcXHgxNFxceDAydGlcXHgwM1xceDAyXFx4MDJcXHgwMlwiICtcblx0XHRcInRvXFx4MDNcXHgwMlxceDAyXFx4MDJ1JlxceDAzXFx4MDJcXHgwMlxceDAydndcXHRcXGJcXHgwMlxceDAydyhcXHgwM1xceDAyXFx4MDJcXHgwMnhcIiArXG5cdFx0XCJ6XFx4MDVcXCdcXHgxNFxceDAyeXhcXHgwM1xceDAyXFx4MDJcXHgwMnp7XFx4MDNcXHgwMlxceDAyXFx4MDJ7eVxceDAzXFx4MDJcXHgwMlxceDAyXCIgK1xuXHRcdFwie3xcXHgwM1xceDAyXFx4MDJcXHgwMnx9XFx4MDNcXHgwMlxceDAyXFx4MDJ9flxcYlxceDE1XFx4MDJcXHgwMn4qXFx4MDNcXHgwMlxceDAyXFx4MDJcIiArXG5cdFx0XCJcXHZcXHgwMi40Pkhfa3R7XFx4MDNcXGJcXHgwMlxceDAyXCI7XG5cdHB1YmxpYyBzdGF0aWMgX19BVE46IEFUTjtcblx0cHVibGljIHN0YXRpYyBnZXQgX0FUTigpOiBBVE4ge1xuXHRcdGlmICghU2ltcGxlVGV4dExleGVyLl9fQVROKSB7XG5cdFx0XHRTaW1wbGVUZXh0TGV4ZXIuX19BVE4gPSBuZXcgQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoVXRpbHMudG9DaGFyQXJyYXkoU2ltcGxlVGV4dExleGVyLl9zZXJpYWxpemVkQVROKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFNpbXBsZVRleHRMZXhlci5fX0FUTjtcblx0fVxuXG59XG5cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFXQyxJQUFDLFlBQVc7QUFHWCxVQUFJO0FBR0osVUFBSSxPQUFPLFlBQVcsYUFBYTtBQUNqQyxvQkFBWSxRQUFPLFVBQVU7QUFBQSxNQUMvQixP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
